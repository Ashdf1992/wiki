protocol Utility with
OPNAuthoring
{
    Copyright = "(c) Microsoft Corporation",
    References = 
        [
        ],
    RevisionSummary =
        [
            new Revision{Class = RevisionClass.Major, Version = "382596", Date = "12/03/2015"}
        ]
};

using Standard;
using InfrastructureResources;
using Diagnostics;
using MACOrganizationCodes;

const binary EmptyBinary = $[];

bool IsArrayItemWithinRange(array<string> arr, int start, int end, bool hexDigit)
{
    foreach (var a in arr)
    {
        var i = a.ToInt(hexDigit);

        if (i == nothing)
        {
            return false;
        }

        int val = i as int;
        if (val < start || val > end)
        {
            return false;
        }
    }
    return true;
}

// GetHashCode from Binary
// This method is similar with String.GetHashCode() in .Net Framework.
int GetHashCodeFromBinary(binary bin)
{
    if (bin == null)
        return 0;

    int hash1 = (5381 << 16) + 5381;
    int hash2 = hash1;

    int len = bin.Count;
    int index = 0;
    while (len > 2)
    {
        hash1 = ((hash1 << 5) + hash1 + (hash1 >> 27)) ^ bin[index];
        hash2 = ((hash2 << 5) + hash2 + (hash2 >> 27)) ^ bin[index + 1];
        index += 2;
        len -= 4;
    }

    if (len > 0)
    {
        hash1 = ((hash1 << 5) + hash1 + (hash1 >> 27)) ^ bin[index];
    }

    return hash1 + (hash2 * 1566083941);
}

type IPv4Address with SupportsAliasing{IsValid = IsIPv4Address} : IComparable
{
    binary Octets with BinaryEncoding{Length = 4};

    override string ToString()
    {
        string ip = "";
        for (int counter = 0; counter < Octets.Count; counter++)
        {
            ip = ip + (Octets[counter] as string);
            if (counter < Octets.Count - 1)
            {
                ip = ip + ".";
            }
        }
        return ip;
    }
    
    int CompareTo(any other)
    {
        if (other != null &&
            other is ipv4:IPv4Address)
        {
            return (this.Octets > ipv4.Octets ? 1 : (this.Octets == ipv4.Octets ? 0 : -1));
        }

        return 1;
    }
}

int get IPv4ToInt(this IPv4Address address)
{
    return ((address.Octets[3] as int) << 24) + 
        ((address.Octets[2] as int) << 16) + 
        ((address.Octets[1] as int) << 8) + 
        (address.Octets[0] as int);
}

bool IsIPv4Address(string address)
{
    if (address == null || address.Count == 0)
    {
        return false;
    }

    var arr = address.Split(['.']);
    if (arr.Count != 4)
    {
        return false;
    }
    
    return IsArrayItemWithinRange(arr, 0, 255, false);
}

// WORKAROUND: Revert ipv6 address back to binary type for it's hard to check the address of variouse types for other protocols currently
type IPv6Address with SupportsAliasing{IsValid = IsIPv6Address} : IComparable
{
    binary Octets with BinaryEncoding {Length = 16};

    override string ToString()
    {
        string ip = "";
        for (int index = 0; index < Octets.Count; index += 2)
        {
            int b = (Octets[index] << 8) + Octets[index + 1];
            ip += (b == 0) ? "0:" : (Format("{0:X}", b) + ":");
        }    
        return ip.Segment(0, ip.Count - 1);
    }
    
    int CompareTo(any other)
    {
        if (other != null &&
            other is ipv6:IPv6Address)
        {
            return (this.Octets > ipv6.Octets ? 1 : (this.Octets == ipv6.Octets ? 0 : -1));
        }

        return 1;
    }
}

bool IsIPv6Address(string address)
{
    if (address == null || address.Count == 0)
    {
        return false;
    }

    var arr = address.Split(["::"]);
    if (arr.Count > 2)
    {
        return false;
    }
    else if (arr.Count == 2)
    {
        var arr1 = null;
        var arr2 = null;
        
        if (arr[0] != "")
        {
            arr1 = arr[0].Split([':']);
        }

        if (arr[1] != "")
        {
            arr2 = arr[1].Split([':']);
        }

        if (arr1 != null && arr2 != null && arr1.Count + arr2.Count > 6)
        {
            return false;
        }
        else
        {
            if (arr1 != null)
            {
                if (arr1.Count > 6)
                {
                    return false;
                }
                
                if (!IsArrayItemWithinRange(arr1, 0, 65535, true))
                {
                    return false;
                }
            }
            
            if (arr2 != null)
            {
                if (arr2.Count > 6)
                {
                    return false;
                }
                
                if (!IsArrayItemWithinRange(arr2, 0, 65535, true))
                {
                    return false;
                }
            }
        }
    }
    else
    {
        arr = address.Split([':']);
        if (arr.Count != 8)
        {
            return false;
        }

        if (!IsArrayItemWithinRange(arr, 0, 65535, true))
        {
            return false;
        }
    }
   
    return true;
}

string GetOrgValue(MacAddress ma)
{
	uint macorg = ((ma.Octets[0] as uint) << 16) + 
				  ((ma.Octets[1] as uint) << 8) + 
				   (ma.Octets[2] as uint);

	if(macorg in OrganizationCodeMap)
	{
		return ma.ToString() + " " + OrganizationCodeMap[macorg];
	}
	else
	{
		return ma.ToString();
	}
}

type MacAddress with SupportsAliasing{IsValid = IsMacAddress} : IComparable
{
    binary Octets with BinaryEncoding{Length = 6};
    
    override string ToString()
    {
        string macFormated = "";
        int cnt = 0;
        foreach (byte cur in Octets)
        {
            macFormated += Utility.DecToHexFormat(2, cur).Segment(2) as string;
            if (cnt < Octets.Count - 1)
            {
                macFormated += "-";
            }
            cnt++;
        }
        return macFormated;
    }
    
    int CompareTo(any other)
    {
        if (other != null &&
            other is mac:MacAddress)
        {
            return (this.Octets > mac.Octets ? 1 : (this.Octets == mac.Octets ? 0 : -1));
        }

        return 1;
    }
} with DisplayInfo{ToText = (any input) => GetOrgValue(this)};

bool IsMacAddress(string address)
{
    if (address == null || address.Count == 0)
    {
        return false;
    }

    var arr = address.Split(['-']);
    if (arr.Count != 6)
    {
        return false;
    }

    return IsArrayItemWithinRange(arr, 0, 255, true);
}

// FlatAddress properties below are used by Filtering Transformer
binary get FlatAddress(this IPv4Address address)
{
    return address.Octets;
}

binary get FlatAddress(this IPv6Address address)
{
    return address.Octets;
}

binary get FlatAddress(this MacAddress address)
{
    return address.Octets;
}

pattern ZeroUint = uint where value == 0;
pattern ZeroByte = byte where value == 0;

pattern StringNotNullOrEmpty = string where value != null && value.Count > 0;

ushort MakeWord(byte highByte, byte lowByte)
{
    return ((highByte << 8) + lowByte) as ushort;
}

uint MakeDWord(byte b0, byte b1, byte b2, byte b3)
{
    return ((b0 << 24) + (b1 << 16) + (b2 << 8) + b3) as uint;
}

// Inserts an element into a array which is sorted in ascending order
// comparer:    return positive value if element1 > element2
//              return 0 if element1 == element2
//              return negative value if element1 < element2
array<T> InsertSorted<T>(this array<T> $"array", int(T, T) comparer, T element)
{
    int i = $"array".Count();
    $"array" = $"array" + [element];

    while (i > 0 && comparer(element, $"array"[i - 1]) < 0)
    {
        $"array"[i] = $"array"[i - 1];
        i--;
    }

    $"array"[i] = element;

    return $"array";
}

bool PeekByteCompare(this stream s, int bitOffset, array<byte> byteArr)
{
    int index = 0;
    while (index < byteArr.Count && s.PeekByte(bitOffset + index * 8) == byteArr[index])
    {
        index++;
    }
    return index == byteArr.Count;
}

bool IsFragmentsSequentialCompleted<T>( array<T> fragments, // fragments
    bool(T) isFirst, // function to identify the first fragment
    bool(T) isLast, // function to identify the last fragment
    int(T) sequence, // function to get the sequence token of current fragment
    int(T) nextSequence) // function to get the expected next sequence token
{
    int fragmentsCount = fragments.Count;
    
    if (isFirst(fragments[0]) && isLast(fragments[fragmentsCount - 1]))
    {
        int index = 0;
        while (index < fragmentsCount - 1 && nextSequence(fragments[index]) == sequence(fragments[index + 1]))
        {
            index++;
        }
        return index == fragmentsCount - 1;
    }
    
    return false;
}

type Empty{}

// Functions to handle padding.
optional binary AlignTo8Bytes(stream s)
{
    return AlignToNBytes(s, 8);
}

optional binary AlignTo4Bytes(stream s)
{
    return AlignToNBytes(s, 4);
}

optional binary AlignTo2Bytes(stream s)
{
    return AlignToNBytes(s, 2);
}

optional binary AlignToNBytes(stream s, int n)
{
    if (s.BytePosition % n is i:int && i != 0 && s.RemainingByteLength > n - i)
    {
        var v = BinaryDecoder<Blob[(n - i) as uint]>(s) as Blob;
        return v.Data;
    }
    else 
    {
        return nothing;
    }
}

type Blob[uint Bound]
{
    binary Data with BinaryEncoding{Length = Bound};
}

type BlobString[uint Bound]
{
    string Data with BinaryEncoding{Length = Bound};
}

type Padding[byte Length]
{
    array<byte> Padding with BinaryEncoding{Length = Length};
}

// WORKAROUND for Feature 64443 : Support Encoding related attributes on patterns
type UintInBigEndian
{
    uint Value with BinaryEncoding{Endian = Endian.Big};
}

// WORKAROUND for Feature 64443 : Support Encoding related attributes on patterns
type ASCIIString
{
    string Value with BinaryEncoding{TextEncoding = TextEncoding.ASCII};
}

// all 16-bit words are summed using one's complement arithmetic
bool ValidateCheckSum(binary parentPayload, ushort checksum)
{
    long sum = 0;
    // padded with zero octets at the end (if necessary) to make a multiple of two octets
    // If parentPayload length is odd octets, padding a zero one at the end of payload.
    if ((parentPayload.Count & 1) == 1)
    {
        parentPayload += ([0 as byte] as binary);
    }

    // sum of Payload
    for (int i = 0; i < parentPayload.Count; i += 2)
    {
        sum += MakeWord(parentPayload[i], parentPayload[i + 1]);
    }

    // because we have added initial Checksum into 'sum', so we subtract it from 'sum'
    sum -= checksum;

    // get the sum of sum's low 16bit and it's high 16 bit
    while ((sum >> 16) > 0)
    {
        sum = (sum & 0xffff) + (sum >> 16);
    }

    // take sum's complement
    sum = ~sum;

    return (sum as ushort) == checksum;
}

// If originalChecksum is zero, means taken as optional field in IPv4, then return true;
// If the CheckSum result equals to originalChecksum, means valid and return true; otherwise return false;
bool ValidateTCPUDPChecksum(binary sourceAddress, binary destinationAddress, byte protocolNum, binary parentPayload, ushort originalChecksum)
{
    if (originalChecksum == 0 && (sourceAddress.Count == 4))
    {
        // taken as optional field in IPv4, so return true at the very beginning.
        return true;
    }
    long sum = 0;
    binary temPayload = null;
    int initialLength = parentPayload.Count;

    // sum of protocolNum (17 for udp and 6 for TCP)  and length of parentPayload
    sum += (protocolNum + initialLength);

    // add 16bit words of IPv4 sourceAddress to sum;
    for (int index = 0; index < sourceAddress.Count; index += 2)
    {
        sum += Utility.MakeWord(sourceAddress[index], sourceAddress[index + 1]);
    }
    // add 16bit words of IPv4 destinationAddress to sum;
    for (int index = 0; index < destinationAddress.Count; index += 2)
    {
        sum += Utility.MakeWord(destinationAddress[index], destinationAddress[index + 1]);
    }
    temPayload = sum.ToBinary();
    temPayload += parentPayload;

    return ValidateCheckSum(temPayload, originalChecksum);
}

void DecodeBinaryWithErrorOnFail<T>(binary payload, string moduleName, string messageName, ref T decodedT)
{
    switch (payload)
    {
        case t:T from BinaryDecoder =>
            decodedT = t;
        default =>
            ThrowDecodingException(moduleName, messageName);
    }
}

void ThrowDecodingException(string moduleName)
{
    throw Format(UTILITY_STR_EXCEPTION, moduleName);
}

void ThrowDecodingException(string moduleName, string messageName)
{
    throw Format(UTILITY_STR_EXCEPTION_MESSAGE, moduleName, messageName);
}

void ThrowDecodingException(string moduleName, string reason, array<string> arg)
{
    switch (reason)
    {
        case UTILITY_INVALID_DATA =>
            if (arg.Count > 0)
            {
                throw Format(UTILITY_STR_EXCEPTION_WITH_REASON, moduleName, Format(reason, arg[0]));
            }
        case UTILITY_INVALID_DATA_WITH_VALUE =>
            if (arg.Count > 1)
            {
                throw Format(UTILITY_STR_EXCEPTION_WITH_REASON, moduleName, Format(reason, arg[0], arg[1]));
            }
        case UTILITY_UNKNOWN_DATA =>
            if (arg.Count > 0)
            {
                throw Format(UTILITY_STR_EXCEPTION_WITH_REASON, moduleName, Format(reason, arg[0]));
            }
        case UTILITY_UNDEFINED_DATA =>
            if (arg.Count > 0)
            {
                throw Format(UTILITY_STR_EXCEPTION_WITH_REASON, moduleName, Format(reason, arg[0]));
            }
        case UTILITY_DECODE_FAIL_WITH_ENCODING =>
            if (arg.Count > 1)
            {
                throw Format(UTILITY_STR_EXCEPTION_WITH_REASON, moduleName, Format(reason, arg[0], arg[1]));
            }
        case UTILITY_PARSE_ERROR =>
            if (arg.Count > 0)
            {
                throw Format(UTILITY_STR_EXCEPTION_WITH_REASON, moduleName, Format(reason, arg[0]));
            }
        default =>
            throw Format(UTILITY_STR_EXCEPTION_WITH_REASON, moduleName, reason);
    }
}

void ThrowDecodingException(string moduleName, string messageName, string reason, array<string> arg)
{
    switch (reason)
    {
        case UTILITY_INVALID_DATA =>
            if (arg.Count > 0)
            {
                throw Format(UTILITY_STR_EXCEPTION_MESSAGE_WITH_REASON, moduleName, messageName, Format(reason, arg[0]));
            }
        case UTILITY_INVALID_DATA_WITH_VALUE =>
            if (arg.Count > 1)
            {
                throw Format(UTILITY_STR_EXCEPTION_MESSAGE_WITH_REASON, moduleName, messageName, Format(reason, arg[0], arg[1]));
            }
        case UTILITY_UNKNOWN_DATA =>
            if (arg.Count > 0)
            {
                throw Format(UTILITY_STR_EXCEPTION_MESSAGE_WITH_REASON, moduleName, messageName, Format(reason, arg[0]));
            }
        case UTILITY_UNDEFINED_DATA =>
            if (arg.Count > 0)
            {
                throw Format(UTILITY_STR_EXCEPTION_MESSAGE_WITH_REASON, moduleName, messageName, Format(reason, arg[0]));
            }
        case UTILITY_DECODE_FAIL_WITH_ENCODING =>
            if (arg.Count > 1)
            {
                throw Format(UTILITY_STR_EXCEPTION_MESSAGE_WITH_REASON, moduleName, messageName, Format(reason, arg[0], arg[1]));
            }
        case UTILITY_PARSE_ERROR =>
            if (arg.Count > 0)
            {
                throw Format(UTILITY_STR_EXCEPTION_MESSAGE_WITH_REASON, moduleName, messageName, Format(reason, arg[0]));
            }
        default =>
            throw Format(UTILITY_STR_EXCEPTION_MESSAGE_WITH_REASON, moduleName, messageName, reason);
    }
}

// Transform decimal to hexadecimal as string to show hex in UI.
// E.g., Input an int with value 10d, Output is 0xA;
//       Input an ushort with value 17d, Out put is 0x11;
static string DecToHexFormat(any dec)
{
    switch (dec)
    {
        case (n:byte)=>
            return Format("0x{0:X2}", n);
        case (n:sbyte)=>
            return Format("0x{0:X2}", n);
        case (n:ushort)=>
            return Format("0x{0:X4}", n);
        case (n:short)=>
            return Format("0x{0:X4}", n);
        case (n:uint)=>
            return Format("0x{0:X8}", n);
        case (n:int)=>
            return Format("0x{0:X8}", n);
        case (n:ulong)=>
            return Format("0x{0:X16}", n);
        case (n:long)=>
            return Format("0x{0:X16}", n);
        default=>
            return dec as string;
    }
}

// Transform decimal to hexadecimal as string to show hex in UI.
// Same result with DecToHexFormat(any dec), but add Hex width with leading zeros
// E.g., hexWidthWithLeadingZeros = 4
//       Input an int with value 10d, Output is 0x000A;
//       Input an ushort with value 17d, Out put is 0x0011;
static string DecToHexFormat(int hexWidthWithLeadingZeros, any dec)
{
    switch (dec)
    {
        case (byte | sbyte | ushort | short | uint | int | ulong | long)=>
            return Format("0x{0:X" + hexWidthWithLeadingZeros.ToString() + "}", dec);
        default=>
            return dec as string;
    }
}

// used in ToString() for summaryline, it will return Enum meaningful value, for value out of enum range, it will return "Unknown(value)"
string EnumToStringInSummary<T>(T t)
{
    var valueAppended = EnumToString<T>(t, true);
    var leftParentheseIndex = valueAppended.LastIndexOf("(");
    if (leftParentheseIndex >= 0)
    {
        return valueAppended.Segment(0, leftParentheseIndex);
    }
    else
    {
        return "Unknown(" + valueAppended + ")";
    }
} with DeclarationInfo {GenerateGenericTypeInfoAsParameter = true};

string ConvertStringArrayToString(optional array<string> arr)
{
    if (arr is strArr:array<string> && strArr != null && strArr.Count > 0)
    {
        return strArr.Accumulate((string t, string s) => s + t);
    }
    return "";
}

string Array2String<T>(array<T> tArray, string separator)
{
    if (tArray != null && tArray.Count > 0)
    {
        string sum = "";
        for (int i= 0; i < tArray.Count; i++)
        {
            sum += tArray[i] as string;
            sum += separator;
        }
        return sum.Segment(0, sum.Count - 1);
    }
    return "";
}

// Determine whether a string contains a sub string, return true if it does, else false.
bool Contains(this string str, string subStr)
{
    if (str == null || subStr == null)
    {
        return false;
    }
    return str.IndexOf(subStr) >= 0;
}

// Convert binary to IPv4/IPv6 address if input is feasible.
string BinaryToIP(binary binVal)
{
    int binLen = binVal.Count;
    string ip = "";

    if (binLen != 4 && binLen != 16)
    {
        return "";
    }
    // IPv4 address
    else if (binLen == 4)
    {
        int counter = 0;
        foreach (byte b in binVal)
        {
            counter += 1;
            ip = ip + (b as string);
            if (counter < binLen)
            {
                ip = ip + ".";
            }
        }
        return ip;
    }
    // IPv6 address
    else
    {
        for (int index = 0; index < binLen; index += 2)
        {
            int b = (binVal[index] << 8) + binVal[index + 1];
            ip += (b == 0) ? "0:" : (Format("{0:X}", b) + ":");
        }
        return ip.Segment(0, ip.Count - 1);
    }
}

// Get the remaining bytes, bitOffset should be a relative value like StartBitPosition, which may not begin with zero.
binary PeekBytes(this stream s, int bitOffset)
{
    return s.PeekBytes(bitOffset, (s.StartBitPosition + s.BitLength - bitOffset) >> 3);
}

// Peek Uint from the stream with Endian
uint PeekUInt(this stream s, int bitOffset, Endian endian)
{
    if (endian == Endian.Big)
    {
        return ((s.PeekByte(bitOffset) << 24) + (s.PeekByte(bitOffset + 8) << 16) +
            (s.PeekByte(bitOffset + 16) << 8) + s.PeekByte(bitOffset + 24)) as uint;
    }
    return ((s.PeekByte(bitOffset + 24) << 24) + (s.PeekByte(bitOffset + 16) << 16) +
        (s.PeekByte(bitOffset + 8) << 8) + s.PeekByte(bitOffset)) as uint;
}

// Peek Ushort from the stream with Endian
ushort PeekUShort(this stream s, int bitOffset, Endian endian)
{
    if (endian == Endian.Big)
    {
        return ((s.PeekByte(bitOffset) << 8) + s.PeekByte(bitOffset + 8)) as ushort;
    }
    return ((s.PeekByte(bitOffset + 8) << 8) + s.PeekByte(bitOffset)) as ushort;
}

int get RemainingByteLength(this stream s)
{
    return s.RemainingBitLength >> 3;
}

// For almost cases and big endian stream, but do not use it when container type applied 'DecodeAsUnit' in case of little endian.
int get RemainingBitLength(this stream s)
{
    // BitPosition and StartBitPosition may not initialized with zero when create stream instance, instead, it's relative value from its parent stream.
    // BitLength is the exact bit count of current stream instance.
    return s.BitLength - (s.BitPosition - s.StartBitPosition);
}

/*
 * Type Event here is similar as C# events
 * This Event shouldn't be over-used, now it is only used
 * for HTTP endpoint register event to TCP endpoint to do
 * reassembly on TCP connection close
 * Notice that user should avoid to assign value to the "Next"
 * field of Event type, to avoid cyclic reference
 */
type Event
{
    void(array<any>) Handler;
    array<any> Arguments;
    // internal Event Next;
    Event Next;
    
    void Append(Event ev)
    {
        set<Event> events = {};
        var e = this;
        events[e] = true;
        while (e.Next != null && !events[e.Next])
        {
            e = e.Next;
            events[e] = true;
        }
        if (!events[ev])
        {
            e.Next = ev;
        }
    }
    
    void Remove(Event ev)
    {
        var previous = this;
        var current = Next;
        while (current != ev && current != null)
        {
            previous = current;
            current = current.Next;
        }
        if (current != null)
        {
            previous.Next = current.Next;
        }
    }
    
    void Invoke()
    {
        set<Event> events = {};
        var e = this;
        while (e != null && !(e in events))
        {
            events[e] = true;
            e = e.Next;
        }
        foreach (var ev in events)
        {
            ev.Handler(ev.Arguments);
        }
    }
}

Event operator +(Event x, Event y)
{
    if (x == null)
        return y;
    x.Append(y);
    return x;
}

Event operator -(Event x, Event y)
{
    if (x == null)
        return null;
    if (x == y)
        return null;
    x.Remove(y);
    return x;
}

// this could be used by:
//      int beginPosition = s.BitPosition;
//      t.XXX = BinaryDecoder<XXX>(s);
//      AssociateFieldPosition(t, "XXX", s, beginPosition);
void AssociateFieldPosition(any type t, string fieldName, stream s, int beginBitPosition)
{
    DataChunks dataChunk = new DataChunks();
    dataChunk.DataSource = s;
    dataChunk.Chunks = [new BinaryChunk{BitPosition = beginBitPosition, BitLength = s.BitPosition - beginBitPosition}];
    t.AssociateField(fieldName, dataChunk);
}

// this could be used by:
//      t.XXX = s.Segment(BytePosition, ByteLength);
//      AssociateFieldPosition(t, "XXX", s, BytePosition * 8, ByteLength * 8);
void AssociateFieldPosition(any type t, string fieldName, stream s, int beginBitPosition, int bitLength)
{
    DataChunks dataChunk = new DataChunks();
    dataChunk.DataSource = s;
    dataChunk.Chunks = [new BinaryChunk{BitPosition = beginBitPosition, BitLength = bitLength}];
    t.AssociateField(fieldName, dataChunk);
}

// Store extension summary prefix, usage examples:
//      [DDP Extended by RDMA]
//      [Reassembled]
annotation string SummaryPrefix;

// Browse origins of the message to find the lowest message and get #MessageNumber 
optional uint get FrameMessageNumber (this any message m)
{
    while ((m.Origins).Count > 0)
    {
        m = (m.Origins)[0];
    }
    return m#MessageNumber;
}

pattern MessageDirection = enum int
{
    Accepts = 0,
    Issues = 1
};

///////////////////////////////////////////////
// The enumeration to indicate whether the field is included in a type of a message.
pattern ReferenceType = enum string
{
    Type = INFRASTRUCTURE_STR_TYPE,
    Message = INFRASTRUCTURE_STR_MESSAGE,
};

// Pattern to accept parameters
pattern DescriptionParams = AnyNumber | bool | char | string | binary;

///////////////////////////////////////////////

// Use this funciton when decode structure failed, but will not abort parsing.
void ValidationCheckDecodingFailure(any message msg, string moduleName, string fieldName)
{
    ValidationCheck(false, msg, Format(UTILITY_STR_EXCEPTION_MESSAGE, moduleName, fieldName));
}

// Validation check decoding failed
bool ValidationCheckDecodingMessageFailedWithReason(any message msg, string moduleName, string fieldName, string rootCause)
{
    return ValidationCheck(false, msg, () => Format(UTILITY_STR_EXCEPTION_MESSAGE_WITH_REASON, [moduleName, fieldName, rootCause]));
}

string DiagnosticIntegerString(any integer)
{
    if (integer is (byte | sbyte | ushort | short | uint | int | ulong | long))
    {
        return integer.ToString() + " (" + DecToHexFormat(integer) + ")";
    }
    return integer.ToString();
}

// Validation check values
// If the type of parameter "actualValue" is integer, it will be shown as the format such as 10 (0x0A).
// Or, e.g. string or double, it will be shown as its original format, such as "Text", "1.1". 
bool ValidationCheckValue(bool condition, any message msg, bool isMustBehavior, ReferenceType typeOrMessage,
                    string moduleName, string fieldName, string structureName, any expectValue, any actualValue)
{
    if (!condition)
    {
        var description = Format(INFRASTRUCTURE_STR_CHECK_VALUE, [moduleName, fieldName, typeOrMessage, structureName, isMustBehavior ? INFRASTRUCTURE_STR_MUST : INFRASTRUCTURE_STR_SHOULD, expectValue, DiagnosticIntegerString(actualValue)]);
        return ValidationCheck(condition, msg, isMustBehavior ? DiagnosisLevel.Error : DiagnosisLevel.Warning, description);
    }
    return true;
}

// If the type of parameter "actualValue" is integer, it will be shown as the format such as 10 (0x0A).
// Or, e.g. string or double, it will be shown as its original format, such as "Text", "1.1". 
bool ValidationCheckGreaterThan(bool condition, any message msg, bool isMustBehavior, ReferenceType typeOrMessage,
                    string moduleName, string fieldName, string structureName, any greaterThanValue, any actualValue)
{
    if (!condition)
    {
        var description = Format(INFRASTRUCTURE_STR_CHECK_VALUE_GREATER_THAN, [moduleName, fieldName, typeOrMessage, structureName, isMustBehavior ? INFRASTRUCTURE_STR_MUST : INFRASTRUCTURE_STR_SHOULD, greaterThanValue, DiagnosticIntegerString(actualValue)]);
        return ValidationCheck(condition, msg, isMustBehavior ? DiagnosisLevel.Error : DiagnosisLevel.Warning, description);
    }
    return true;
}

// If the type of parameter "actualValue" is integer, it will be shown as the format such as 10 (0x0A).
// Or, e.g. string or double, it will be shown as its original format, such as "Text", "1.1". 
bool ValidationCheckGreaterThanOrEqualTo(bool condition, any message msg, bool isMustBehavior, ReferenceType typeOrMessage,
                    string moduleName, string fieldName, string structureName, any greaterThanOrEqualToValue, any actualValue)
{
    if (!condition)
    {
        var description = Format(INFRASTRUCTURE_STR_CHECK_VALUE_GREATER_THAN_OR_EQUAL_TO, [moduleName, fieldName, typeOrMessage, structureName, isMustBehavior ? INFRASTRUCTURE_STR_MUST : INFRASTRUCTURE_STR_SHOULD, greaterThanOrEqualToValue, DiagnosticIntegerString(actualValue)]);
        return ValidationCheck(condition, msg, isMustBehavior ? DiagnosisLevel.Error : DiagnosisLevel.Warning, description);
    }
    return true;
}

// If the type of parameter "actualValue" is integer, it will be shown as the format such as 10 (0x0A).
// Or, e.g. string or double, it will be shown as its original format, such as "Text", "1.1". 
bool ValidationCheckLessThanOrEqualTo(bool condition, any message msg, bool isMustBehavior, ReferenceType typeOrMessage,
                    string moduleName, string fieldName, string structureName, any lessThanOrEqualToValue, any actualValue)
{
    if (!condition)
    {
        var description = Format(INFRASTRUCTURE_STR_CHECK_VALUE_LESS_THAN_OR_EQUAL_TO, [moduleName, fieldName, typeOrMessage, structureName, isMustBehavior ? INFRASTRUCTURE_STR_MUST : INFRASTRUCTURE_STR_SHOULD, lessThanOrEqualToValue, DiagnosticIntegerString(actualValue)]);
        return ValidationCheck(condition, msg, isMustBehavior ? DiagnosisLevel.Error : DiagnosisLevel.Warning, description);
    }
    return true;
}

bool ValidationCheckLessThan(bool condition, any message msg, bool isMustBehavior, ReferenceType typeOrMessage,
                    string moduleName, string fieldName, string structureName, any lessThanValue, any actualValue)
{
    if (!condition)
    {
        var description = Format(INFRASTRUCTURE_STR_CHECK_VALUE_LESS_THAN, [moduleName, fieldName, typeOrMessage, structureName, isMustBehavior ? INFRASTRUCTURE_STR_MUST : INFRASTRUCTURE_STR_SHOULD, lessThanValue, DiagnosticIntegerString(actualValue)]);
        return ValidationCheck(condition, msg, isMustBehavior ? DiagnosisLevel.Error : DiagnosisLevel.Warning, description);
    }
    return true;
}

bool ValidationCheckValid(bool condition, any message msg, bool isMustBehavior, ReferenceType typeOrMessage,
                    string moduleName, string fieldName, string structureName, any expectation)
{
    if (!condition)
    {
        var description = Format(INFRASTRUCTURE_STR_CHECK_VALUE_IS_NOT_A_VALID, [moduleName, fieldName, typeOrMessage, structureName, expectation]);
        return ValidationCheck(condition, msg, isMustBehavior ? DiagnosisLevel.Error : DiagnosisLevel.Warning, description);
    }
    return true;
}

// If the type of parameter "actualValue" is integer, it will be shown as the format such as 10 (0x0A).
// Or, e.g. string or double, it will be shown as its original format, such as "Text", "1.1". 
bool ValidationCheckZero(bool condition, any message msg, bool isMustBehavior, ReferenceType typeOrMessage,
                    string moduleName, string fieldName, string structureName, any actualValue)
{
    if (!condition)
    {
        var description = Format(INFRASTRUCTURE_STR_CHECK_VALUE, [moduleName, fieldName, typeOrMessage, structureName, isMustBehavior ? INFRASTRUCTURE_STR_MUST : INFRASTRUCTURE_STR_SHOULD, INFRASTRUCTURE_STR_ZERO, DiagnosticIntegerString(actualValue)]);
        return ValidationCheck(condition, msg, isMustBehavior ? DiagnosisLevel.Error : DiagnosisLevel.Warning, description);
    }
    return true;
}

// If the type of parameter "actualValue" is integer, it will be shown as the format such as 10 (0x0A).
// Or, e.g. string or double, it will be shown as its original format, such as "Text", "1.1". 
bool ValidationCheckReservedZero(bool condition, any message msg, bool isMustBehavior, ReferenceType typeOrMessage,
                    string moduleName, string fieldName, string structureName, any actualValue)
{
    if (!condition)
    {
        var description = Format(INFRASTRUCTURE_STR_CHECK_RESERVED_ZERO, [moduleName, fieldName, typeOrMessage, structureName, isMustBehavior ? INFRASTRUCTURE_STR_MUST : INFRASTRUCTURE_STR_SHOULD, INFRASTRUCTURE_STR_ZERO, DiagnosticIntegerString(actualValue)]);
        return ValidationCheck(condition, msg, isMustBehavior ? DiagnosisLevel.Error : DiagnosisLevel.Warning, description);
    }
    return true;
}

// If the type of parameter "actualValue" is integer, it will be shown as the format such as 10 (0x0A).
// Or, e.g. string or double, it will be shown as its original format, such as "Text", "1.1". 
bool ValidationCheckEnumValue(bool condition, any message msg, bool isMustBehavior, ReferenceType typeOrMessage,
                    string moduleName, string fieldName, string structureName, any enumValueArray, any actualValue)
{
    if (!condition)
    {
        var description = Format(INFRASTRUCTURE_STR_CHECK_ENUM_VALUE, [moduleName, fieldName, typeOrMessage, structureName, isMustBehavior ? INFRASTRUCTURE_STR_MUST : INFRASTRUCTURE_STR_SHOULD, enumValueArray, DiagnosticIntegerString(actualValue)]);
        return ValidationCheck(condition, msg, isMustBehavior ? DiagnosisLevel.Error : DiagnosisLevel.Warning, description);
    }
    return true;
}

// If the number of valid values defined in the enum pattern is greater than 4, please use this function for validation check.
bool ValidationCheckEnumValueTooManyItems(bool condition, any message msg, bool isMustBehavior, ReferenceType typeOrMessage,
                    string moduleName, string fieldName, string structureName, string keywords, string tdName)
{
    if (!condition)
    {
        var description = Format(INFRASTRUCTURE_STR_CHECK_ENUM_VALUE_TOO_MANY_ITEMS, [moduleName, fieldName, typeOrMessage, structureName, keywords, tdName]);
        return ValidationCheck(condition, msg, isMustBehavior ? DiagnosisLevel.Error : DiagnosisLevel.Warning, description);
    }
    return true;
}

// If the type of parameter "actualValue" is integer, it will be shown as the format such as 10 (0x0A).
// Or, e.g. string or double, it will be shown as its original format, such as "Text", "1.1". 
bool ValidationCheckCombinationValue(bool condition, any message msg, bool isMustBehavior, ReferenceType typeOrMessage,
                    string moduleName, string fieldName, string structureName, any combinationValueArray, any actualValue)
{
    if (!condition)
    {
        var description = Format(INFRASTRUCTURE_STR_CHECK_COMBINATION_VALUE, [moduleName, fieldName, typeOrMessage, structureName, isMustBehavior ? INFRASTRUCTURE_STR_MUST : INFRASTRUCTURE_STR_SHOULD, combinationValueArray, actualValue.ToString() + " (" + DecToHexFormat(actualValue) + ")"]);
        return ValidationCheck(condition, msg, isMustBehavior ? DiagnosisLevel.Error : DiagnosisLevel.Warning, description);
    }
    return true;
}

// If the number of valid values defined in the flags pattern is greater than 4, please use this function for validation check.
bool ValidationCheckCombinationValueTooManyItems(bool condition, any message msg, bool isMustBehavior, ReferenceType typeOrMessage,
                    string moduleName, string fieldName, string structureName, string keywords, string tdName)
{
    if (!condition)
    {
        var description = Format(INFRASTRUCTURE_STR_CHECK_COMBINATION_VALUE_TOO_MANY_ITEMS, [moduleName, fieldName, typeOrMessage, structureName, keywords, tdName]);
        return ValidationCheck(condition, msg, isMustBehavior ? DiagnosisLevel.Error : DiagnosisLevel.Warning, description);
    }
    return true;
}

// If the type of parameter "actualValue" is integer, it will be shown as the format such as 10 (0x0A).
// Or, e.g. string or double, it will be shown as its original format, such as "Text", "1.1". 
bool ValidationCheckCombinationValueIncludeZero(bool condition, any message msg, bool isMustBehavior, ReferenceType typeOrMessage,
                    string moduleName, string fieldName, string structureName, any combinationValueArray, any actualValue)
{
    if (!condition)
    {
        var description = Format(INFRASTRUCTURE_STR_CHECK_COMBINATION_VALUE_INCLUDE_ZERO, [moduleName, fieldName, typeOrMessage, structureName, isMustBehavior ? INFRASTRUCTURE_STR_MUST : INFRASTRUCTURE_STR_SHOULD, INFRASTRUCTURE_STR_ZERO, combinationValueArray, DiagnosticIntegerString(actualValue)]);
        return ValidationCheck(condition, msg, isMustBehavior ? DiagnosisLevel.Error : DiagnosisLevel.Warning, description);
    }
    return true;
}

// If the number of valid values defined in the flags pattern is greater than 4, please use this function for validation check.
bool ValidationCheckCombinationValueIncludeZeroTooManyItems(bool condition, any message msg, bool isMustBehavior, ReferenceType typeOrMessage,
                    string moduleName, string fieldName, string structureName, string keywords, string tdName)
{
    if (!condition)
    {
        var description = Format(INFRASTRUCTURE_STR_CHECK_COMBINATION_VALUE_INCLUDE_ZERO_TOO_MANY_ITEMS, [moduleName, fieldName, typeOrMessage, structureName, keywords, tdName]);
        return ValidationCheck(condition, msg, isMustBehavior ? DiagnosisLevel.Error : DiagnosisLevel.Warning, description);
    }
    return true;
}

// If the type of parameter "actualValue" is integer, it will be shown as the format such as 10 (0x0A).
// Or, e.g. string or double, it will be shown as its original format, such as "Text", "1.1". 
bool ValidationCheckValueSame(bool condition, any message msg, bool isMustBehavior, ReferenceType currentMessageType,
                    string moduleName, string currentFieldName, string currentFieldStructureName, ReferenceType pivotMessageType, string pivotFieldName, string pivotFieldStructureName, any actualValue)
{
    if (!condition)
    {
        var description = Format(INFRASTRUCTURE_STR_CHECK_VALUE_SAME, [moduleName, currentFieldName, currentMessageType, currentFieldStructureName, isMustBehavior ? INFRASTRUCTURE_STR_MUST : INFRASTRUCTURE_STR_SHOULD, pivotFieldName, pivotMessageType, pivotFieldStructureName, DiagnosticIntegerString(actualValue)]);
        return ValidationCheck(condition, msg, isMustBehavior ? DiagnosisLevel.Error : DiagnosisLevel.Warning, description);
    }
    return true;
}

// If the type of parameter "actualValue" is integer, it will be shown as the format such as 10 (0x0A).
// Or, e.g. string or double, it will be shown as its original format, such as "Text", "1.1". 
bool ValidationCheckValueInRange(bool condition, any message msg, bool isMustBehavior, ReferenceType typeOrMessage,
                    string moduleName, string fieldName, string structureName, any expectLowerValue, any expectUpperValue, any actualValue)
{
    if (!condition)
    {
        var description = Format(INFRASTRUCTURE_STR_CHECK_VALUE_IN_RANGE, [moduleName, fieldName, typeOrMessage, structureName, isMustBehavior ? INFRASTRUCTURE_STR_MUST : INFRASTRUCTURE_STR_SHOULD, expectLowerValue, expectUpperValue, DiagnosticIntegerString(actualValue)]);
        return ValidationCheck(condition, msg, isMustBehavior ? DiagnosisLevel.Error : DiagnosisLevel.Warning, description);
    }
    return true;
}

// If the type of parameter "actualValue" is integer, it will be shown as the format such as 10 (0x0A).
// Or, e.g. string or double, it will be shown as its original format, such as "Text", "1.1". 
bool ValidationCheckLength(bool condition, any message msg, bool isMustBehavior, ReferenceType typeOrMessage,
                    string moduleName, string fieldName, string structureName, any expectValue, any actualValue)
{
    if (!condition)
    {
        var description = Format(INFRASTRUCTURE_STR_CHECK_LENGTH_EQUAL, [moduleName, fieldName, typeOrMessage, structureName, isMustBehavior ? INFRASTRUCTURE_STR_MUST : INFRASTRUCTURE_STR_SHOULD, expectValue, DiagnosticIntegerString(actualValue)]);
        return ValidationCheck(condition, msg, isMustBehavior ? DiagnosisLevel.Error : DiagnosisLevel.Warning, description);
    }
    return true;
}

///////////////////////////////////////////////
// Report insufficient data
void ReportInsufficientData(any message msg, DiagnosisLevel level, ReferenceType typeOrMessage,
                    string moduleName, string fieldName, string structureName)
{
    array<any> descParams = [moduleName, fieldName, typeOrMessage, structureName];
    ReportInsufficientData(msg, level, Format(UTILITY_STR_REPORT_INSUFFICIENT_DATA, descParams));
}

// Report incsufficient data in case operation misses request or request.
void ReportInsufficientOperation(any message msg, string moduleName, string opName, bool missRequest)
{
    if (missRequest)
    {
        ReportInsufficientData(msg, DiagnosisLevel.Error, Format(UTILITY_OPERATION_MISSING_REQUEST, moduleName, opName));
    }
    else
    {
        ReportInsufficientData(msg, DiagnosisLevel.Error, Format(UTILITY_OPERATION_MISSING_RESPONSE, moduleName, opName));
    }
}

///////////////////////////////////////////////
// Report insufficient data, 
// If trancated is true, indicates the traffic is truncated.
// If trancated is false, indicates the traffic is missing some segments.
void ReportInsufficientTruncation(any message m, string moduleName, string fieldName, string messageName, bool truncated)
{
    array<any> descParams = [moduleName, fieldName, messageName];
    if (truncated)
    {
        ValidationCheck(false, m, DiagnosisLevel.Information, Format(UTILITY_STR_REPORT_INSUFFICIENT_DATA_TRUNCATED, descParams));
    }
    else 
    {
        ReportInsufficientData(m, DiagnosisLevel.Error, Format(UTILITY_STR_REPORT_INSUFFICIENT_DATA_MISSING_SEGMENT, descParams));
    }
}

// Validate the content value in padding or reserved bytes/binary.
bool IsZeroValue((binary | array<byte>) val)
{
    if (!(val is binary || val is array<byte>))
    {
        return false;
    }
    else
    {
        var bin = val as binary;
        foreach (byte b in bin)
        {
            if (b != 0)
            {
                return false;
            }
        }
        return true;
    }
}

// Set the annotation for messages that are decoded in truncation decoding path.
// Put it in Utility.opn to let it be visible for all related protocols.
annotation bool IsTruncated;

// Private used in Utility.DisplayTopLevelMessage() and Overloaded Methods;
endpoint TopLevelDisplay accepts any message issues any message;

// Used when you want a message to be displayed immediately as Top-Level message.
// But when use this in destructor, there should be some reasonable diagnosis warning messages, which can be done by Overloaded methods Utility.DisplayTopLevelMessage()
// When use this in destructor, it's equivalent with 'release' statement for cached messages, which have been dispatched by other endpoints previously.
void DisplayTopLevelMessage(any message msg)
{
    if (msg != null)
    {
        dispatch endpoint TopLevelDisplay accepts msg;
    }
}

// Same functionality with Utility.DisplayTopLevelMessage(), but more option for customized message and indication for InsufficientData.
void DisplayTopLevelMessage(any message msg, string diagnosisWarningStr)
{
    if (msg != null)
    {
        ReportInsufficientData(msg, DiagnosisLevel.Warning, diagnosisWarningStr);
        dispatch endpoint TopLevelDisplay accepts msg;
    }
}

bool IsTrue(optional bool x)
{
    return (x == nothing) ? false : x as bool;
}

// A simple Segmented Most Recent Cache
// Holds at most Limit * 2 items
type SMRCache<K,T>
{
    uint Limit;
    map<K, T> Cache1 = {};
    map<K, T> Cache2 = {};
    
    void Add(K k, T t)
    {
        if(Cache1.Count >= Limit)
        {
            Cache2 = Cache1;
            Cache1 = {};
        }
        
        // Make sure there are duplicated key in the cache
        if(k in Cache2)
        {
            Cache2[k] = t;
        }
        else
        {
            Cache1[k] = t;
        }
    }
    
    optional T Get(K k)
    {
        if(k in Cache1)
        {
            return Cache1[k];
        }
        if(k in Cache2)
        {
            return Cache2[k];
        }
        return nothing;
    }
    
    optional Pair<K, T> FindFirst(bool(K, T) f)
    {
        foreach (var c in Cache1)
        {
            if(f(c.Key, c.Value))
            {
                return c;
            }
        }
        foreach (var c in Cache2)
        {
            if(f(c.Key, c.Value))
            {
                return c;
            }
        }
        return nothing;
    }
    
    uint Count()
    {
        return (Cache1.Count + Cache2.Count) as uint;
    }
    
    void Clear()
    {
        Cache1 = {};
        Cache2 = {};
    }
}

// This function is used in RPC type protocol to make the display value more meaningful
// Make sure that the input can be convert to type T
optional T PatternDecoder<T>(any input)
{
    if (input is t:T) 
    {
        return t;
    }
    else 
    {
        return nothing;
    }
}

optional T DecodeElementInAnyElement<T>(string namespace, string name, xml xmlValue)
{
    if (!(xmlValue.NamespaceUri == namespace && xmlValue.Name is xmlName:XmlName && xmlName.LocalName == name))
    {
        return nothing;
    }
    
    return XmlDecoder<T>(xmlValue);
}

/* 
 * Calculate the length which is ASN.1 BER decoder.
 * So far it only support to decode when the length of length is 1, 2, 3 or 4.
 * 
 * param offsetBitPosition: offest to current bit position in stream.
 */ 
optional uint CalculateAsn1BerLength(stream s, int offsetBitPosition)
{
    assert offsetBitPosition >= 0;
    
    if (s.RemainingByteLength() - (offsetBitPosition >> 3) <= 2)
    {
        return nothing;
    }
    
    // Second Byte, the Length or the length of the Length
    byte secondByte = s.PeekByte(s.BitPosition + offsetBitPosition + 8);
    
    uint length = 2; // tag and the length tag is not included in the length value
    if ((secondByte & 0x80) == 0x80)
    {
        // flag is set, and get the length of the binary, which represents the Length
        secondByte = (secondByte & 0x7F) as byte;
        if (s.RemainingByteLength() <= 2 + secondByte + (offsetBitPosition >> 3))
        {
            return nothing;
        }
        switch (secondByte)
        {
            case 0x01 =>
                length += s.PeekByte(s.BitPosition + offsetBitPosition + 16) as uint;
            case 0x02 =>
                length += s.PeekUShort(s.BitPosition + offsetBitPosition + 16, Endian.Big) as uint;
            case 0x03 =>
                length += (s.PeekUInt(s.BitPosition + offsetBitPosition + 16, Endian.Big) >> 8) as uint;
            case 0x04 =>
                length += s.PeekUInt(s.BitPosition + offsetBitPosition + 16, Endian.Big);
            default =>
                return nothing;
        }
    }
    length += (secondByte as uint);
    return length;
}

/* 
 * Calculate the length which is ASN.1 BER decoder.
 * So far it only support to decode when the length of length is 1, 2, 3 or 4.
 */
optional uint CalculateAsn1BerLength(stream s)
{
    return CalculateAsn1BerLength(s, 0);
}

// Generic implementation of sorted linked list.
type SortedLinkedList<T>
{
    // Head is the head of the list
    SortedLinkedListNode<T> Head = null;
    // Rear point to the last node in the list
    SortedLinkedListNode<T> Rear = null;
    // The Comparer function used for sorting in Insert function
    int(T, T) Comparer;
    // Count of node in the linked list
    int Count = 0;

    // Insert a segment in the sorted list
    void Insert(T v)
    {
        var newNode = new SortedLinkedListNode<T>{Value = v};
        Count++;

        // Insert the node into an empty list
        if (Head == null)
        {
            Head = newNode;
            Rear = newNode;
            return;
        }

        if (Comparer(Rear.Value, v) <= 0)
        {
            // Add the segment to the rear of the list since it is sequential
            Rear.Next = newNode;
            newNode.Previous = Rear;
            Rear = newNode;
            return;
        }
        else
        {
            // Find the proper position and insert
            var temp = Rear.Previous;
            // Move forward till the head or find the place to insert
            while (temp != null && Comparer(temp.Value, v) > 0)
            {
                temp = temp.Previous;
            }
            // Insert
            if (temp == null)
            {
                // Reached the head of the list
                Head.Previous = newNode;
                newNode.Next = Head;
                Head = newNode;
            }
            else
            {
                // Insert the new node in current position, which is in the middle of the list
                newNode.Next = temp.Next;
                temp.Next = newNode;
                newNode.Previous = temp;
                var nextNode = newNode.Next;
                nextNode.Previous = newNode;
            }
        }
    }

    void RemoveHead()
    {
        if (Head == null)
        {
            Count = 0;
            return;
        }
        Head = Head.Next;
        if (Head == null)
        {
            Rear = null;
        }
        else
        {
            Head.Previous = null;
        }
        Count--;
    }

    void Clear()
    {
        Head = null;
        Rear = null;
        Count = 0;
    }
}

type SortedLinkedListNode<T>
{
    T Value;
    SortedLinkedListNode<T> Previous;
    SortedLinkedListNode<T> Next;
}
