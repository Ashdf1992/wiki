protocol CSRA with 
Standard.Documentation
{
    ProtocolName = "Certificate Services Remote Administration Protocol",
    ProtocolType = "rpc",
    ShortName = "CSRA",
    DocumentName = "MS-CSRA",
    Description = ""
},
OPNAuthoring
{
    Copyright = "(c) Microsoft Corporation",
    References = 
    [
        new Reference {Name = "MS-CSRA", Version = "33.0", Date = "05/15/2014", ProgramName = ProgramName.WSPP}
    ],
    RevisionSummary = 
    [
        new Revision {Class = RevisionClass.Major, Version = "", Date = "11/24/2014"}
    ]
};

using Technologies.IDL;
using DTYP;
using ERREF;
using OAUT;
using MSRPCE;
using DCOM;
using WCCE;
using X509;
using CMS;
using Utility;
using Diagnostics;
using IdentityAndSecurityResources;

endpoint Server
    over MSRPCE.Server
    provides ICertAdminD
    provides ICertAdminD2;

contract ICertAdminD provides IUnknown
{
    accepts operation SetExtension
    {
        in string pwszAuthority
            with Technologies.IDL.IDL
            {
                PointerType = PointerKind.UniquePtr,
                BaseStringType = TypeOf<wchar_t>(),
                String = true,
                IndirectionLevel = 1
            };
        in DWORD dwRequestId where ValidationCheck(value != 0, this, DiagnosisLevel.Error, () => Format(CSRA_VALUE_MUST_BE_NONZERO, "dwRequestId", "SetExtension"));
        in string pwszExtensionName 
            where ValidationCheck(value != null && value.Count > 0 && value.Count <= 31, this, DiagnosisLevel.Error,
                () => Format(CSRA_STRING_LENGTH_MUST_BE_IN_RANGE, "pwszExtensionName", "SetExtension", "31"))
            with Technologies.IDL.IDL
            {
                PointerType = PointerKind.UniquePtr,
                BaseStringType = TypeOf<wchar_t>(),
                String = true,
                IndirectionLevel = 1
            };
        in SetExtension_dwType dwType with Encoding{Decoder = PatternDecoder<SetExtension_dwType>, SourcePattern = TypeOf<DWORD>()};
        in SetExtension_dwFlags dwFlags with Encoding{Decoder = PatternDecoder<SetExtension_dwFlags>, SourcePattern = TypeOf<DWORD>()};
        in CERTTRANSBLOB[dwType, 0, 0, 0] pctbValue
            with Technologies.IDL.IDL{PointerType = PointerKind.RefPtr, IndirectionLevel = 1};
        result CSRA.HRESULT ReturnValue;
        
        override string ToString()
        {
            return
                "SetExtension, ReturnValue: " + ReturnValue.ToString() + 
                ", pwszAuthority: " + pwszAuthority.ToString() +
                ", dwRequestId: " + dwRequestId.ToString() +
                ", pwszExtensionName: " + pwszExtensionName.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 3};
    
    accepts operation SetAttributes
    {
        in string pwszAuthority
            with Technologies.IDL.IDL
            {
                PointerType = PointerKind.UniquePtr,
                BaseStringType = TypeOf<wchar_t>(),
                String = true,
                IndirectionLevel = 1
            };
        in DWORD dwRequestId where ValidationCheck(value != 0, this, DiagnosisLevel.Error, () => Format(CSRA_VALUE_MUST_BE_NONZERO, "dwRequestId", "SetAttributes"));
        in string pwszAttributes
            with Technologies.IDL.IDL
            {
                PointerType = PointerKind.UniquePtr,
                BaseStringType = TypeOf<wchar_t>(),
                String = true,
                IndirectionLevel = 1
            };
        result CSRA.HRESULT ReturnValue;
        
        override string ToString()
        {
            return
                "SetAttributes, ReturnValue: " + ReturnValue.ToString() + 
                ", pwszAuthority: " + pwszAuthority.ToString() +
                ", dwRequestId: " + dwRequestId.ToString() +
                ", pwszAttributes: " + pwszAttributes.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 4};
    
    accepts operation ResubmitRequest
    {
        in string pwszAuthority
            with Technologies.IDL.IDL
            {
                PointerType = PointerKind.UniquePtr,
                BaseStringType = TypeOf<wchar_t>(),
                String = true,
                IndirectionLevel = 1
            };
        in DWORD dwRequestId where ValidationCheck(value != 0, this, DiagnosisLevel.Error, () => Format(CSRA_VALUE_MUST_BE_NONZERO, "dwRequestId", "ResubmitRequest"));
        out DWORD pdwDisposition with Technologies.IDL.IDL{IndirectionLevel = 1};
        result CSRA.HRESULT ReturnValue;
        
        override string ToString()
        {
            return
                "ResubmitRequest, ReturnValue: " + ReturnValue.ToString() + 
                ", pwszAuthority: " + pwszAuthority.ToString() +
                ", dwRequestId: " + dwRequestId.ToString() +
                ", pdwDisposition: " + pdwDisposition.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 5};
    
    accepts operation DenyRequest
    {
        in string pwszAuthority
            with Technologies.IDL.IDL
            {
                PointerType = PointerKind.UniquePtr,
                BaseStringType = TypeOf<wchar_t>(),
                String = true,
                IndirectionLevel = 1
            };
        in DWORD dwRequestId where ValidationCheck(value != 0, this, DiagnosisLevel.Error, () => Format(CSRA_VALUE_MUST_BE_NONZERO, "dwRequestId", "DenyRequest"));
        result CSRA.HRESULT ReturnValue;
        
        override string ToString()
        {
            return
                "DenyRequest, ReturnValue: " + ReturnValue.ToString() + 
                ", pwszAuthority: " + pwszAuthority.ToString() +
                ", dwRequestId: " + dwRequestId.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 6};
    
    accepts operation IsValidCertificate
    {
        in string pwszAuthority
            with Technologies.IDL.IDL
            {
                PointerType = PointerKind.UniquePtr,
                BaseStringType = TypeOf<wchar_t>(),
                String = true,
                IndirectionLevel = 1
            };
        in string pSerialNumber
            with Technologies.IDL.IDL
            {
                PointerType = PointerKind.UniquePtr,
                BaseStringType = TypeOf<wchar_t>(),
                String = true,
                IndirectionLevel = 1
            };
        out IsValidCertificate_RevocationReason pRevocationReason
            where ValidationCheckEnumValueTooManyItems(InRange<IsValidCertificate_RevocationReason>(value), this, true, ReferenceType.Message, "CSRA", "pRevocationReason", "IsValidCertificate", "IsValidCertificate", "[MS-CSRA]")
            with Technologies.IDL.IDL{IndirectionLevel = 1},
                Encoding{Decoder = PatternDecoder<IsValidCertificate_RevocationReason>, SourcePattern = TypeOf<LONG>()};
        out IsValidCertificate_Disposition pDisposition
            where ValidationCheckEnumValueTooManyItems(InRange<IsValidCertificate_Disposition>(value), this, true, ReferenceType.Message, "CSRA", "pDisposition", "IsValidCertificate", "IsValidCertificate", "[MS-CSRA]")
            with Technologies.IDL.IDL{IndirectionLevel = 1},
                Encoding{Decoder = PatternDecoder<IsValidCertificate_Disposition>, SourcePattern = TypeOf<LONG>()};
        result CSRA.HRESULT ReturnValue;
        
        override string ToString()
        {
            return
                "IsValidCertificate, ReturnValue: " + ReturnValue.ToString() +
                ", pwszAuthority: " + pwszAuthority.ToString() + 
                ", pRevocationReason: " + EnumToString<IsValidCertificate_RevocationReason>(pRevocationReason) + 
                ", pDisposition: " + EnumToString<IsValidCertificate_Disposition>(pDisposition);
        }
    }
    with Technologies.IDL.IDL{Opnum = 7};
    
    accepts operation PublishCRL
    {
        in string pwszAuthority
            with Technologies.IDL.IDL
            {
                PointerType = PointerKind.UniquePtr,
                BaseStringType = TypeOf<wchar_t>(),
                String = true,
                IndirectionLevel = 1
            };
        in FILETIME FileTime;
        result CSRA.HRESULT ReturnValue;
        
        override string ToString()
        {
            return
                "PublishCRL, ReturnValue: " + ReturnValue.ToString() + 
                ", pwszAuthority: " + pwszAuthority.ToString() +
                ", FileTime: " + FileTime.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 8};
    
    accepts operation GetCRL
    {
        in string pwszAuthority
            with Technologies.IDL.IDL
            {
                PointerType = PointerKind.UniquePtr,
                BaseStringType = TypeOf<wchar_t>(),
                String = true,
                IndirectionLevel = 1
            };
        out CERTTRANSBLOB[PROPTYPE.PROPTYPE_CRL, 0, 0, 0] pctbCRL
            with Technologies.IDL.IDL
                {PointerType = PointerKind.RefPtr, IndirectionLevel = 1};
        result CSRA.HRESULT ReturnValue;
        
        override string ToString()
        {
            return
                "GetCRL, ReturnValue: " + ReturnValue.ToString() +
                 ", pwszAuthority: " + pwszAuthority.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 9};
    
    accepts operation RevokeCertificate
    {
        in string pwszAuthority
            with Technologies.IDL.IDL
            {
                PointerType = PointerKind.UniquePtr,
                BaseStringType = TypeOf<wchar_t>(),
                String = true,
                IndirectionLevel = 1
            };
        in string pwszSerialNumber
            with Technologies.IDL.IDL
            {
                PointerType = PointerKind.UniquePtr,
                BaseStringType = TypeOf<wchar_t>(),
                String = true,
                IndirectionLevel = 1
            };
        in RevokeCertificate_Reason Reason
            where ValidationCheckEnumValueTooManyItems(InRange<RevokeCertificate_Reason>(value), this, true, ReferenceType.Message, "CSRA", "Reason", "RevokeCertificate", "RevokeCertificate", "[MS-CSRA]")
            with Encoding{Decoder = PatternDecoder<RevokeCertificate_Reason>, SourcePattern = TypeOf<DWORD>()};
        in FILETIME FileTime;
        result CSRA.HRESULT ReturnValue;
        
        override string ToString()
        {
            return
                "RevokeCertificate, ReturnValue: " + ReturnValue.ToString() +
                 ", pwszAuthority: " + pwszAuthority.ToString() +
                 ", Reason: " + EnumToString<RevokeCertificate_Reason>(Reason);
        }
    }
    with Technologies.IDL.IDL{Opnum = 10};
    
    accepts operation EnumViewColumn
    {
        in string pwszAuthority
            with Technologies.IDL.IDL
            {
                PointerType = PointerKind.UniquePtr,
                BaseStringType = TypeOf<wchar_t>(),
                String = true,
                IndirectionLevel = 1
            };
        in DWORD iColumn;
        in DWORD cColumn;
        out DWORD pcColumn with Technologies.IDL.IDL{IndirectionLevel = 1};
        out CERTTRANSBLOB[PROPTYPE.PROPTYPE_CERTTRANSDBCOLUMN, pcColumn, 0, 0] pctbColumnInfo
            with Technologies.IDL.IDL{PointerType = PointerKind.RefPtr, IndirectionLevel = 1};
        result CSRA.HRESULT ReturnValue;
        
        override string ToString()
        {
            return
                "EnumViewColumn, ReturnValue: " + ReturnValue.ToString() +
                 ", pwszAuthority: " + pwszAuthority.ToString() + 
                 ", iColumn: " + iColumn.ToString() +
                 ", cColumn: " + cColumn.ToString() + 
                 ", pcColumn: " + pcColumn.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 11};
    
    accepts operation GetViewDefaultColumnSet
    {
        in string pwszAuthority
            with Technologies.IDL.IDL
            {
                PointerType = PointerKind.UniquePtr,
                BaseStringType = TypeOf<wchar_t>(),
                String = true,
                IndirectionLevel = 1
            };
        in GetViewDefaultColumnSet_iColumnSetDefault iColumnSetDefault
            where ValidationCheckEnumValueTooManyItems(InRange<GetViewDefaultColumnSet_iColumnSetDefault>(value), this, true, ReferenceType.Message, "CSRA", "iColumnSetDefault", "GetViewDefaultColumnSet", "GetViewDefaultColumnSet", "[MS-CSRA]")
            with Encoding{Decoder = PatternDecoder<GetViewDefaultColumnSet_iColumnSetDefault>, SourcePattern = TypeOf<DWORD>()};
        out DWORD pcColumn with Technologies.IDL.IDL{IndirectionLevel = 1};
        out CERTTRANSBLOB[PROPTYPE.PROPTYPE_ARRAYDWORD, pcColumn, 0, 0] pctbColumnInfo
            with Technologies.IDL.IDL
                {PointerType = PointerKind.RefPtr, IndirectionLevel = 1};
        result CSRA.HRESULT ReturnValue;
        
        override string ToString()
        {
            return
                "GetViewDefaultColumnSet, ReturnValue: " + ReturnValue.ToString() +
                 ", pwszAuthority: " + pwszAuthority.ToString() + 
                 ", iColumnSetDefault: " + iColumnSetDefault.ToString() +
                 ", pcColumn: " + pcColumn.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 12};
    
    accepts operation EnumAttributesOrExtensions
    {
        in string pwszAuthority
            with Technologies.IDL.IDL
            {
                PointerType = PointerKind.UniquePtr,
                BaseStringType = TypeOf<wchar_t>(),
                String = true,
                IndirectionLevel = 1
            };
        in DWORD RowId;
        in EnumAttributesOrExtensions_Flags Flags
            where ValidationCheckEnumValueTooManyItems(InRange<EnumAttributesOrExtensions_Flags>(value), this, true, ReferenceType.Message, "CSRA", "Flags", "EnumAttributesOrExtensions", "EnumAttributesOrExtensions", "[MS-CSRA]")
            with Encoding{Decoder = PatternDecoder<EnumAttributesOrExtensions_Flags>, SourcePattern = TypeOf<DWORD>()};
        in string pwszLast
            with Technologies.IDL.IDL
            {
                PointerType = PointerKind.UniquePtr,
                BaseStringType = TypeOf<wchar_t>(),
                String = true,
                IndirectionLevel = 1
            };
        in DWORD celt;
        out DWORD pceltFetched with Technologies.IDL.IDL{IndirectionLevel = 1};
        out CERTTRANSBLOB[Flags == EnumAttributesOrExtensions_Flags.attributes ? PROPTYPE.PROPTYPE_CERTTRANSDBATTRIBUTE : PROPTYPE.PROPTYPE_CERTTRANSDBEXTENSION, pceltFetched, 0, 0] pctbOut
            with Technologies.IDL.IDL
                {PointerType = PointerKind.RefPtr, IndirectionLevel = 1};
        result CSRA.HRESULT ReturnValue;
        
        override string ToString()
        {
            return
                "EnumAttributesOrExtensions, ReturnValue: " + ReturnValue.ToString() +
                ", pwszAuthority: " + pwszAuthority.ToString() + 
                ", RowId: " + RowId.ToString() +
                ", Flags: " + EnumToString<EnumAttributesOrExtensions_Flags>(Flags) + 
                ", pceltFetched: " + pceltFetched.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 13};
    
    accepts operation OpenView
    {
        in string pwszAuthority
            with Technologies.IDL.IDL
            {
                PointerType = PointerKind.UniquePtr,
                BaseStringType = TypeOf<wchar_t>(),
                String = true,
                IndirectionLevel = 1
            };
        in DWORD ccvr;
        in array<CERTVIEWRESTRICTION> acvr
            with Technologies.IDL.IDL{Size_is = [ccvr], IndirectionLevel = 1};
        in DWORD ccolOut;
        in array<DWORD> acolOut
            with Technologies.IDL.IDL{Size_is = [ccolOut], IndirectionLevel = 1};
        in DWORD ielt;
        in DWORD celt;
        out DWORD pceltFetched with Technologies.IDL.IDL{IndirectionLevel = 1};
        out CERTTRANSBLOB[PROPTYPE.PROPTYPE_CERTTRANSDBRESULTROW, pceltFetched, 0, 0] pctbResultRows
            with Technologies.IDL.IDL{PointerType = PointerKind.RefPtr, IndirectionLevel = 1};
        result CSRA.HRESULT ReturnValue;
        
        override string ToString()
        {
            return
                "OpenView, ReturnValue: " + ReturnValue.ToString() + 
                ", pwszAuthority: " + pwszAuthority.ToString() +
                ", ccvr: " + ccvr.ToString() +
                ", ccolOut: " + ccolOut.ToString() + 
                ", pceltFetched: " + pceltFetched.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 14};
    
    accepts operation EnumView
    {
        in string pwszAuthority
            with Technologies.IDL.IDL
            {
                PointerType = PointerKind.UniquePtr,
                BaseStringType = TypeOf<wchar_t>(),
                String = true,
                IndirectionLevel = 1
            };
        in DWORD ielt;
        in DWORD celt;
        out DWORD pceltFetched with Technologies.IDL.IDL{IndirectionLevel = 1};
        out CERTTRANSBLOB[PROPTYPE.PROPTYPE_CERTTRANSDBRESULTROW, pceltFetched, 0, 0] pctbResultRows
            with Technologies.IDL.IDL
                {PointerType = PointerKind.RefPtr, IndirectionLevel = 1};
        result CSRA.HRESULT ReturnValue;
        
        override string ToString()
        {
            return
                "EnumView, ReturnValue: " + ReturnValue.ToString() +
                ", pwszAuthority: " + pwszAuthority.ToString() +
                ", pceltFetched: " + pceltFetched.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 15};
    
    accepts operation CloseView
    {
        in string pwszAuthority
            with Technologies.IDL.IDL
            {
                PointerType = PointerKind.UniquePtr,
                BaseStringType = TypeOf<wchar_t>(),
                String = true,
                IndirectionLevel = 1
            };
        result CSRA.HRESULT ReturnValue;
        
        override string ToString()
        {
            return
                "CloseView, ReturnValue: " + ReturnValue.ToString() + 
                ", pwszAuthority: " + pwszAuthority.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 16};
    
    accepts operation ServerControl
    {
        in string pwszAuthority
            with Technologies.IDL.IDL
            {
                PointerType = PointerKind.UniquePtr,
                BaseStringType = TypeOf<wchar_t>(),
                String = true,
                IndirectionLevel = 1
            };
        in ServerControl_dwControlFlags dwControlFlags
            where ValidationCheckEnumValue(InRange<ServerControl_dwControlFlags>(value), this, true, ReferenceType.Message, "CSRA", "dwControlFlags", "ServerControl", "0x000000001, 0x000000002, 0x000000003", value)
            with Encoding{Decoder = PatternDecoder<ServerControl_dwControlFlags>, SourcePattern = TypeOf<DWORD>()};
        out CERTTRANSBLOB[PROPTYPE.PROPTYPE_BINARY, 0, 0, 0] pctbOut
            where ValidationCheck(value.cb == 0 && value.pb == null, this, DiagnosisLevel.Error, () => Format(CSRA_ALL_FIELDS_MUST_BE_0, "pctbOut", "ServerControl"))
            with Technologies.IDL.IDL
                {PointerType = PointerKind.RefPtr, IndirectionLevel = 1};
        result CSRA.HRESULT ReturnValue;
        
        override string ToString()
        {
            return
                "ServerControl, ReturnValue: " + ReturnValue.ToString() + 
                ", pwszAuthority: " + pwszAuthority.ToString() +
                ", dwControlFlags: " + dwControlFlags.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 17};
    
    accepts operation Ping
    {
        in string pwszAuthority
            with Technologies.IDL.IDL
            {
                PointerType = PointerKind.UniquePtr,
                BaseStringType = TypeOf<wchar_t>(),
                String = true,
                IndirectionLevel = 1
            };
        result CSRA.HRESULT ReturnValue;
        
        override string ToString()
        {
            return
                "Ping, ReturnValue: " + ReturnValue.ToString() + 
                ", pwszAuthority: " + pwszAuthority.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 18};
    
    accepts operation GetServerState
    {
        in string pwszAuthority
            with Technologies.IDL.IDL
            {
                PointerType = PointerKind.UniquePtr,
                BaseStringType = TypeOf<wchar_t>(),
                String = true,
                IndirectionLevel = 1
            };
        out DWORD pdwState with Technologies.IDL.IDL{IndirectionLevel = 1};
        result CSRA.HRESULT ReturnValue;
        
        override string ToString()
        {
            return
                "GetServerState, ReturnValue: " + ReturnValue.ToString() +
                ", pwszAuthority: " + pwszAuthority.ToString() + 
                ", pdwState: " + pdwState.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 19};
    
    accepts operation BackupPrepare
    {
        in string pwszAuthority
            with Technologies.IDL.IDL
            {
                PointerType = PointerKind.UniquePtr,
                BaseStringType = TypeOf<wchar_t>(),
                String = true,
                IndirectionLevel = 1
            };
        in BackupPrepare_grbitJet grbitJet
            where ValidationCheckEnumValue(InRange<BackupPrepare_grbitJet>(value), this, true, ReferenceType.Message, "CSRA", "grbitJet", "BackupPrepare", "0x00000000, 0x00000001", value)
            with Encoding{Decoder = PatternDecoder<BackupPrepare_grbitJet>, SourcePattern = TypeOf<IDLUlong>()};
        in IDLUlong dwBackupFlags where ValidationCheckZero(value == 0, this, true, ReferenceType.Message, "CSRA", "dwBackupFlags", "BackupPrepare", value);
        in WCHAR pwszBackupAnnotation where ValidationCheckValue(value == '\0', this, true, ReferenceType.Message, "CSRA", "pwszBackupAnnotation", "BackupPrepare", "empty string(L\"\")", value)
            with Technologies.IDL.IDL{IndirectionLevel = 1};
        in DWORD dwClientIdentifier where ValidationCheckZero(value == 0, this, true, ReferenceType.Message, "CSRA", "dwClientIdentifier", "BackupPrepare", value);
        result CSRA.HRESULT ReturnValue;
        
        override string ToString()
        {
            return
                "BackupPrepare, ReturnValue: " + ReturnValue.ToString() + 
                ", pwszAuthority: " + pwszAuthority.ToString() +
                ", grbitJet: " + EnumToString<BackupPrepare_grbitJet>(grbitJet);
        }
    }
    with Technologies.IDL.IDL{Opnum = 20};
    
    accepts operation BackupEnd
    {
        result CSRA.HRESULT ReturnValue;
        
        override string ToString()
        {
            return "BackupEnd, ReturnValue: " + ReturnValue.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 21};
    
    accepts operation BackupGetAttachmentInformation
    {
        out DBFileName ppwszzDBFiles
            with Technologies.IDL.IDL{Size_is = [null, pcwcDBFiles], IndirectionLevel = 2},
                Encoding{Decoder = BinaryDecoder<DBFileName>, SourceConverter = ArrayWCHARToBinary, SourcePattern = TypeOf<array<WCHAR>>()};
        out LONG pcwcDBFiles with Technologies.IDL.IDL{IndirectionLevel = 1};
        result CSRA.HRESULT ReturnValue;
        
        override string ToString()
        {
            return
                "BackupGetAttachmentInformation, ReturnValue: " + ReturnValue.ToString() +
                ", pcwcDBFiles: " + pcwcDBFiles.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 22};
    
    accepts operation BackupGetBackupLogs
    {
        out DBFileName ppwszzLogFiles
            with Technologies.IDL.IDL{Size_is = [null, pcwcLogFiles], IndirectionLevel = 2},
                Encoding{Decoder = BinaryDecoder<DBFileName>, SourceConverter = ArrayWCHARToBinary, SourcePattern = TypeOf<array<WCHAR>>()};
        out LONG pcwcLogFiles with Technologies.IDL.IDL{IndirectionLevel = 1};
        result CSRA.HRESULT ReturnValue;
        
        override string ToString()
        {
            return
                "BackupGetBackupLogs, ReturnValue: " + ReturnValue.ToString() + 
                ", pcwcLogFiles: " + pcwcLogFiles.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 23};
    
    accepts operation BackupOpenFile
    {
        in string pwszPath
            with Technologies.IDL.IDL
            {
                PointerType = PointerKind.UniquePtr,
                BaseStringType = TypeOf<wchar_t>(),
                String = true,
                IndirectionLevel = 1
            };
        out uhyper pliLength with Technologies.IDL.IDL{IndirectionLevel = 1};
        result CSRA.HRESULT ReturnValue;
        
        override string ToString()
        {
            return
                "BackupOpenFile, ReturnValue: " + ReturnValue.ToString() +
                ", pwszPath: " + pwszPath.ToString() +
                ", pliLength: " + pliLength.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 24};
    
    accepts operation BackupReadFile
    {
        out array<BYTE> pbBuffer
            with Technologies.IDL.IDL
            {
                Size_is = [cbBuffer],
                PointerType = PointerKind.RefPtr,
                IndirectionLevel = 1
            };
        in LONG cbBuffer;
        out LONG pcbRead with Technologies.IDL.IDL{IndirectionLevel = 1};
        result CSRA.HRESULT ReturnValue;
        
        override string ToString()
        {
            return
                "BackupReadFile, ReturnValue: " + ReturnValue.ToString() + 
                ", cbBuffer: " + cbBuffer.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 25};
    
    accepts operation BackupCloseFile
    {
        result CSRA.HRESULT ReturnValue;
        
        override string ToString()
        {
            return
                "BackupCloseFile, ReturnValue: " + ReturnValue.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 26};
    
    accepts operation BackupTruncateLogs
    {
        result CSRA.HRESULT ReturnValue;
        
        override string ToString()
        {
            return "BackupTruncateLogs, ReturnValue: " + ReturnValue.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 27};
    
    accepts operation ImportCertificate
    {
        in string pwszAuthority
            with Technologies.IDL.IDL
            {
                PointerType = PointerKind.UniquePtr,
                BaseStringType = TypeOf<wchar_t>(),
                String = true,
                IndirectionLevel = 1
            };
        in CERTTRANSBLOB[PROPTYPE.PROPTYPE_CERT, 0, 0, 0] pctbCertificate
            with Technologies.IDL.IDL{PointerType = PointerKind.RefPtr, IndirectionLevel = 1};
        in ImportCertificate_dwFlags dwFlags
            where ValidationCheckEnumValue(InRange<ImportCertificate_dwFlags>(value), this, true, ReferenceType.Message, "CSRA", "dwFlags", "ImportCertificate", "0x00000000, 0x00010000, 0x00020000", value)
            with Encoding{Decoder = PatternDecoder<ImportCertificate_dwFlags>, SourcePattern = TypeOf<LONG>()};
        out LONG pdwRequestId with Technologies.IDL.IDL{IndirectionLevel = 1};
        result CSRA.HRESULT ReturnValue;
        
        override string ToString()
        {
            return
                "ImportCertificate, ReturnValue: " + ReturnValue.ToString() + 
                ", pwszAuthority: " + pwszAuthority.ToString() + 
                ", dwFlags: " + EnumToString<ImportCertificate_dwFlags>(dwFlags) +
                ", pdwRequestId" + pdwRequestId.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 28};
    
    accepts operation BackupGetDynamicFiles
    {
        out string ppwszzFiles
            with Technologies.IDL.IDL{Size_is = [null, pcwcFiles], IndirectionLevel = 2},
                Encoding{Decoder = BinaryDecoder<string>, SourceConverter = ArrayWCHARToBinary, SourcePattern = TypeOf<array<WCHAR>>()};
        out LONG pcwcFiles with Technologies.IDL.IDL{IndirectionLevel = 1};
        result CSRA.HRESULT ReturnValue;
        
        override string ToString()
        {
            return
                "BackupGetDynamicFiles, ReturnValue: " + ReturnValue.ToString() +
                ", pcwcFiles: " + pcwcFiles.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 29};
    
    accepts operation RestoreGetDatabaseLocations
    {
        out DBFileName ppwszzDatabaseLocations
            with Technologies.IDL.IDL{Size_is = [null, pcwcPaths], IndirectionLevel = 2},
                Encoding{Decoder = BinaryDecoder<DBFileName>, SourceConverter = ArrayWCHARToBinary, SourcePattern = TypeOf<array<WCHAR>>()};
        out LONG pcwcPaths with Technologies.IDL.IDL{IndirectionLevel = 1};
        result CSRA.HRESULT ReturnValue;
        
        override string ToString()
        {
            return
                "RestoreGetDatabaseLocations, ReturnValue: " + ReturnValue.ToString() +
                ", pcwcPaths: " + pcwcPaths.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 30};
}
with Technologies.IDL.IDL
{
    Uuid = {d99e6e71-fc88-11d0-b498-00a0c90312f3},
    Object = true,
    Pointer_default = PointerKind.UniquePtr,
    Helpstring = "ICertAdmin DCOM Interface"
};

contract ICertAdminD2 provides ICertAdminD
{
    accepts operation PublishCRLs
    {
        in string pwszAuthority
            with Technologies.IDL.IDL
            {
                PointerType = PointerKind.UniquePtr,
                BaseStringType = TypeOf<wchar_t>(),
                String = true,
                IndirectionLevel = 1
            };
        in FILETIME FileTime;
        in PublishCRLs_Flags Flags with Encoding{Decoder = PatternDecoder<PublishCRLs_Flags>, SourcePattern = TypeOf<DWORD>()};
        result CSRA.HRESULT ReturnValue;
        
        override string ToString()
        {
            return
                "PublishCRLs, ReturnValue: " + ReturnValue.ToString() +
                ", pwszAuthority: " + pwszAuthority.ToString() +
                ", Flags: " + EnumToString<PublishCRLs_Flags>(Flags);
        }
    }
    with Technologies.IDL.IDL{Opnum = 31};
    
    accepts operation GetCAProperty
    {
        in string pwszAuthority
            with Technologies.IDL.IDL
            {
                PointerType = PointerKind.UniquePtr,
                BaseStringType = TypeOf<wchar_t>(),
                String = true,
                IndirectionLevel = 1
            };
        in GetCAPropertyID PropId
            where ValidationCheckEnumValueTooManyItems(InRange<GetCAPropertyID>(value), this, true, ReferenceType.Message, "CSRA", "PropId", "GetCAProperty", "GetCAProperty", "[MS-CSRA]")
            with Encoding{Decoder = PatternDecoder<GetCAPropertyID>, SourcePattern = TypeOf<LONG>()};
        in LONG PropIndex;
        in WCCE.GetCAPropertyType PropType with Encoding{Decoder = PatternDecoder<WCCE.GetCAPropertyType>, SourcePattern = TypeOf<IDLLong>()};
        out CERTTRANSBLOB[PROPTYPE.PROPTYPE_GETCAPROPERTY, 0, PropId, PropType] pctbPropertyValue
            with Technologies.IDL.IDL{PointerType = PointerKind.RefPtr, IndirectionLevel = 1};
        result CSRA.HRESULT ReturnValue;
        
        override string ToString()
        {
            return
                "GetCAProperty, ReturnValue: " + ReturnValue.ToString() +
                ", pwszAuthority: " + pwszAuthority.ToString() +
                ", PropId: " + EnumToString<GetCAPropertyID>(PropId) + 
                ", PropType: " + EnumToString<WCCE.GetCAPropertyType>(PropType);
        }
    }
    with Technologies.IDL.IDL{Opnum = 32};
    
    accepts operation SetCAProperty
    {
        in string pwszAuthority
            with Technologies.IDL.IDL
            {
                PointerType = PointerKind.UniquePtr,
                BaseStringType = TypeOf<wchar_t>(),
                String = true,
                IndirectionLevel = 1
            };
        in GetCAPropertyID PropId with Encoding{Decoder = PatternDecoder<GetCAPropertyID>, SourcePattern = TypeOf<LONG>()};
        in LONG PropIndex where ValidationCheck((PropId == GetCAPropertyID.CR_PROP_KRACERT) || (PropId != GetCAPropertyID.CR_PROP_KRACERT && value == 0), this, DiagnosisLevel.Error, () => CSRA_PROPINDEX_MUST_BE_ZERO_OHTERWISE);
        in WCCE.GetCAPropertyType PropType
            where ValidationCheckEnumValue(InRange<WCCE.GetCAPropertyType>(value) && value != WCCE.GetCAPropertyType.PROPTYPE_DATE, this, true, ReferenceType.Message, "CSRA", "PropType", "SetCAProperty", "0x00000001, 0x00000003, 0x00000004", value)
            with Encoding{Decoder = PatternDecoder<WCCE.GetCAPropertyType>, SourcePattern = TypeOf<IDLLong>()};
        in CERTTRANSBLOB[PROPTYPE.PROPTYPE_SETCAPROPERTY, 0, PropId, PropType] pctbPropertyValue
            with Technologies.IDL.IDL{IndirectionLevel = 1};
        result CSRA.HRESULT ReturnValue;
        
        override string ToString()
        {
            return
                "SetCAProperty, ReturnValue: " + ReturnValue.ToString() + 
                ", pwszAuthority: " + pwszAuthority.ToString() +
                ", PropId: " + EnumToString<GetCAPropertyID>(PropId) + 
                ", PropType: " + EnumToString<WCCE.GetCAPropertyType>(PropType);
        }
    }
    with Technologies.IDL.IDL{Opnum = 33};
    
    accepts operation GetCAPropertyInfo
    {
        in string pwszAuthority
            with Technologies.IDL.IDL
            {
                PointerType = PointerKind.UniquePtr,
                BaseStringType = TypeOf<wchar_t>(),
                String = true,
                IndirectionLevel = 1
            };
        out LONG pcProperty with Technologies.IDL.IDL{IndirectionLevel = 1};
        out CERTTRANSBLOB[PROPTYPE.PROPTYPE_CATRANSPROP, pcProperty as uint, 0, 0] pctbPropInfo
            with Technologies.IDL.IDL{PointerType = PointerKind.RefPtr, IndirectionLevel = 1};
        result CSRA.HRESULT ReturnValue;
        
        override string ToString()
        {
            return
                "GetCAPropertyInfo, ReturnValue: " + ReturnValue.ToString() + 
                ", pwszAuthority: " + pwszAuthority.ToString() + 
                ", pcProperty: " + pcProperty.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 34};
    
    accepts operation EnumViewColumnTable
    {
        in string pwszAuthority
            with Technologies.IDL.IDL
            {
                PointerType = PointerKind.UniquePtr,
                BaseStringType = TypeOf<wchar_t>(),
                String = true,
                IndirectionLevel = 1
            };
        in EnumViewColumnTable_iTable iTable
            where ValidationCheckEnumValue(InRange<EnumViewColumnTable_iTable>(value), this, true, ReferenceType.Message, "CSRA", "iTable", "EnumViewColumnTable", "0x00000000, 0x00003000, 0x00004000, 0x00005000", value)
            with Encoding{Decoder = PatternDecoder<EnumViewColumnTable_iTable>, SourcePattern = TypeOf<DWORD>()};
        in DWORD iColumn;
        in DWORD cColumn;
        out DWORD pcColumn with Technologies.IDL.IDL{IndirectionLevel = 1};
        out CERTTRANSBLOB[PROPTYPE.PROPTYPE_CERTTRANSDBCOLUMN, pcColumn, 0, 0] pctbColumnInfo
            with Technologies.IDL.IDL
                {PointerType = PointerKind.RefPtr, IndirectionLevel = 1};
        result CSRA.HRESULT ReturnValue;
        
        override string ToString()
        {
            return
                "EnumViewColumnTable, ReturnValue: " + ReturnValue.ToString() + 
                ", pwszAuthority: " + pwszAuthority.ToString() + 
                ", iTable: " + iTable.ToString() +
                ", iColumn: " + iColumn.ToString() + 
                ", pcColumn: " + pcColumn.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 35};
    
    accepts operation GetCASecurity
    {
        in string pwszAuthority
            with Technologies.IDL.IDL
            {
                PointerType = PointerKind.UniquePtr,
                BaseStringType = TypeOf<wchar_t>(),
                String = true,
                IndirectionLevel = 1
            };
        out CERTTRANSBLOB[PROPTYPE.PROPTYPE_SECURITY_DESCRIPTOR, 0, 0, 0] pctbSD
            with Technologies.IDL.IDL{PointerType = PointerKind.RefPtr, IndirectionLevel = 1};
        result CSRA.HRESULT ReturnValue;
        
        override string ToString()
        {
            return
                "GetCASecurity, ReturnValue: " + ReturnValue.ToString() + 
                ", pwszAuthority: " + pwszAuthority.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 36};
    
    accepts operation SetCASecurity
    {
        in string pwszAuthority
            with Technologies.IDL.IDL
            {
                PointerType = PointerKind.UniquePtr,
                BaseStringType = TypeOf<wchar_t>(),
                String = true,
                IndirectionLevel = 1
            };
        in CERTTRANSBLOB[PROPTYPE.PROPTYPE_SECURITY_DESCRIPTOR, 0, 0, 0] pctbSD
            with Technologies.IDL.IDL{PointerType = PointerKind.RefPtr, IndirectionLevel = 1};
        result CSRA.HRESULT ReturnValue;
        
        override string ToString()
        {
            return
                "SetCASecurity, ReturnValue: " + ReturnValue.ToString() +
                ", pwszAuthority: " + pwszAuthority.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 37};
    
    accepts operation Ping2
    {
        in string pwszAuthority
            with Technologies.IDL.IDL
            {
                PointerType = PointerKind.UniquePtr,
                BaseStringType = TypeOf<wchar_t>(),
                String = true,
                IndirectionLevel = 1
            };
        result CSRA.HRESULT ReturnValue;
        
        override string ToString()
        {
            return
                "Ping2, ReturnValue: " + ReturnValue.ToString() +
                ", pwszAuthority: " + pwszAuthority.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 38};
    
    accepts operation GetArchivedKey
    {
        in string pwszAuthority
            with Technologies.IDL.IDL
            {
                PointerType = PointerKind.UniquePtr,
                BaseStringType = TypeOf<wchar_t>(),
                String = true,
                IndirectionLevel = 1
            };
        in DWORD dwRequestId;
        out CERTTRANSBLOB[PROPTYPE.PROPTYPE_BINARY, 0, 0, 0] pctbArchivedKey // Bug#80169
            with Technologies.IDL.IDL{PointerType = PointerKind.RefPtr, IndirectionLevel = 1};
        result CSRA.HRESULT ReturnValue;
        
        override string ToString()
        {
            return
                "GetArchivedKey, ReturnValue: " + ReturnValue.ToString() + 
                ", pwszAuthority: " + pwszAuthority.ToString() +
                ", dwRequestId: " + dwRequestId.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 39};
    
    accepts operation GetAuditFilter
    {
        in string pwszAuthority
            with Technologies.IDL.IDL
            {
                PointerType = PointerKind.UniquePtr,
                BaseStringType = TypeOf<wchar_t>(),
                String = true,
                IndirectionLevel = 1
            };
        out GetAuditFilter_pdwFilter pdwFilter with Technologies.IDL.IDL{IndirectionLevel = 1},
            Encoding{Decoder = PatternDecoder<GetAuditFilter_pdwFilter>, SourcePattern = TypeOf<DWORD>()};
        result CSRA.HRESULT ReturnValue;
        
        override string ToString()
        {
            return
                "GetAuditFilter, ReturnValue: " + ReturnValue.ToString() +
                ", pwszAuthority: " + pwszAuthority.ToString() + 
                ", pdwFilter: " + EnumToString<GetAuditFilter_pdwFilter>(pdwFilter);
        }
    }
    with Technologies.IDL.IDL{Opnum = 40};
    
    accepts operation SetAuditFilter
    {
        in string pwszAuthority
            with Technologies.IDL.IDL
            {
                PointerType = PointerKind.UniquePtr,
                BaseStringType = TypeOf<wchar_t>(),
                String = true,
                IndirectionLevel = 1
            };
        in GetAuditFilter_pdwFilter dwFilter with Encoding{Decoder = PatternDecoder<GetAuditFilter_pdwFilter>, SourcePattern = TypeOf<DWORD>()};
        result CSRA.HRESULT ReturnValue;
        
        override string ToString()
        {
            return
                "SetAuditFilter, ReturnValue: " + ReturnValue.ToString() + 
                ", pwszAuthority: " + pwszAuthority.ToString() + 
                ", dwFilter: " + EnumToString<GetAuditFilter_pdwFilter>(dwFilter);
        }
    }
    with Technologies.IDL.IDL{Opnum = 41};
    
    accepts operation GetOfficerRights
    {
        in string pwszAuthority
            with Technologies.IDL.IDL
            {
                PointerType = PointerKind.UniquePtr,
                BaseStringType = TypeOf<wchar_t>(),
                String = true,
                IndirectionLevel = 1
            };
        // Cannot use mix-encoding here because of bug#80657
        // out SetOfficerRights_fEnable pfEnabled with Technologies.IDL.IDL{IndirectionLevel = 1},
            //Encoding{Decoder = BinaryDecoder<SetOfficerRights_fEnable>, SourceConverter = BOOLToBinary, SourcePattern = TypeOf<BOOL>()};
        out BOOL pfEnabled with Technologies.IDL.IDL{IndirectionLevel = 1};
        out CERTTRANSBLOB[PROPTYPE.PROPTYPE_GETOFFICERRIGHTS, pfEnabled as uint, 0, 0] pctbSD
            with Technologies.IDL.IDL{PointerType = PointerKind.RefPtr, IndirectionLevel = 1};
        result CSRA.HRESULT ReturnValue;
        
        override string ToString()
        {
            return
                "GetOfficerRights, ReturnValue: " + ReturnValue.ToString() +
                ", pwszAuthority: " + pwszAuthority.ToString() + 
                ", pfEnabled: " + pfEnabled.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 42};
    
    accepts operation SetOfficerRights
    {
        in string pwszAuthority
            with Technologies.IDL.IDL
            {
                PointerType = PointerKind.UniquePtr,
                BaseStringType = TypeOf<wchar_t>(),
                String = true,
                IndirectionLevel = 1
            };
        in SetOfficerRights_fEnable fEnable with Encoding{Decoder = BinaryDecoder<SetOfficerRights_fEnable>, SourceConverter = BOOLToBinary, SourcePattern = TypeOf<BOOL>()};
        in CERTTRANSBLOB[PROPTYPE.PROPTYPE_SECURITY_DESCRIPTOR, 0, 0, 0] pctbSD
            with Technologies.IDL.IDL{PointerType = PointerKind.RefPtr, IndirectionLevel = 1};
        result CSRA.HRESULT ReturnValue;
        
        override string ToString()
        {
            return
                "SetOfficerRights, ReturnValue: " + ReturnValue.ToString() +
                ", pwszAuthority: " + pwszAuthority.ToString() + 
                ", fEnable: " + fEnable.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 43};
    
    accepts operation GetConfigEntry
    {
        in string pwszAuthority
            with Technologies.IDL.IDL
            {
                PointerType = PointerKind.UniquePtr,
                BaseStringType = TypeOf<wchar_t>(),
                String = true,
                IndirectionLevel = 1
            };
        in string pwszNodePath where ValidationCheck(value != null, this, DiagnosisLevel.Error, () => Format(CSRA_STRING_MUST_NOT_BE_NULL, "pwszNodePath", "GetConfigEntry"))
            with Technologies.IDL.IDL
            {
                PointerType = PointerKind.UniquePtr,
                BaseStringType = TypeOf<wchar_t>(),
                String = true,
                IndirectionLevel = 1
            };
        in string pwszEntry where ValidationCheck(value != null, this, DiagnosisLevel.Error, () => Format(CSRA_STRING_MUST_NOT_BE_NULL, "pwszEntry", "GetConfigEntry"))
            with Technologies.IDL.IDL
            {
                PointerType = PointerKind.RefPtr,
                BaseStringType = TypeOf<wchar_t>(),
                String = true,
                IndirectionLevel = 1
            };
        out VARIANT pVariant
            with Technologies.IDL.IDL{PointerType = PointerKind.RefPtr, IndirectionLevel = 1};
        result CSRA.HRESULT ReturnValue;
        
        override string ToString()
        {
            return
                "GetConfigEntry, ReturnValue: " + ReturnValue.ToString() +
                ", pwszAuthority: " + pwszAuthority.ToString() + 
                ", pwszNodePath: " + pwszNodePath.ToString() + 
                ", pwszEntry: " + pwszEntry.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 44};
    
    accepts operation SetConfigEntry
    {
        in string pwszAuthority
            with Technologies.IDL.IDL
            {
                PointerType = PointerKind.UniquePtr,
                BaseStringType = TypeOf<wchar_t>(),
                String = true,
                IndirectionLevel = 1
            };
        in string pwszNodePath where ValidationCheck(value != null, this, DiagnosisLevel.Error, () => Format(CSRA_STRING_MUST_NOT_BE_NULL, "pwszNodePath", "GetConfigEntry"))
            with Technologies.IDL.IDL
            {
                PointerType = PointerKind.UniquePtr,
                BaseStringType = TypeOf<wchar_t>(),
                String = true,
                IndirectionLevel = 1
            };
        in string pwszEntry where ValidationCheck(value != null, this, DiagnosisLevel.Error, () => Format(CSRA_STRING_MUST_NOT_BE_NULL, "pwszEntry", "GetConfigEntry"))
            with Technologies.IDL.IDL
            {
                PointerType = PointerKind.RefPtr,
                BaseStringType = TypeOf<wchar_t>(),
                String = true,
                IndirectionLevel = 1
            };
        in VARIANT pVariant
            with Technologies.IDL.IDL{PointerType = PointerKind.RefPtr, IndirectionLevel = 1};
        result CSRA.HRESULT ReturnValue;
        
        override string ToString()
        {
            return
                "SetConfigEntry, ReturnValue: " + ReturnValue.ToString() +
                ", pwszAuthority: " + pwszAuthority.ToString() + 
                ", pwszNodePath: " + pwszNodePath.ToString() + 
                ", pwszEntry: " + pwszEntry.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 45};
    
    accepts operation ImportKey
    {
        in string pwszAuthority
            with Technologies.IDL.IDL
            {
                PointerType = PointerKind.UniquePtr,
                BaseStringType = TypeOf<wchar_t>(),
                String = true,
                IndirectionLevel = 1
            };
        in DWORD dwRequestId;
        in string pwszCertHash
            with Technologies.IDL.IDL
            {
                PointerType = PointerKind.UniquePtr,
                BaseStringType = TypeOf<wchar_t>(),
                String = true,
                IndirectionLevel = 1
            };
        in ImportKey_dwFlags dwFlags with Encoding{Decoder = PatternDecoder<ImportKey_dwFlags>, SourcePattern = TypeOf<DWORD>()};
        in CERTTRANSBLOB[PROPTYPE.PROPTYPE_ARCHIVEDKEY, 0, 0, 0] pctbKey // Bug#80169
            with Technologies.IDL.IDL{PointerType = PointerKind.RefPtr, IndirectionLevel = 1};
        result CSRA.HRESULT ReturnValue;
        
        override string ToString()
        {
            return
                "ImportKey, ReturnValue: " + ReturnValue.ToString() + 
                ", pwszAuthority: " + pwszAuthority.ToString() +
                ", dwRequestId: " + dwRequestId.ToString() + 
                ", pwszCertHash: " + pwszCertHash.ToString() + 
                ", dwFlags: " + EnumToString<ImportKey_dwFlags>(dwFlags);
        }
    }
    with Technologies.IDL.IDL{Opnum = 46};
    
    accepts operation GetMyRoles
    {
        in string pwszAuthority
            with Technologies.IDL.IDL
            {
                PointerType = PointerKind.UniquePtr,
                BaseStringType = TypeOf<wchar_t>(),
                String = true,
                IndirectionLevel = 1
            };
        out Permission pdwRoles with Technologies.IDL.IDL{IndirectionLevel = 1}
            with Encoding{Decoder = PatternDecoder<Permission>, SourcePattern = TypeOf<LONG>()};
        result CSRA.HRESULT ReturnValue;
        
        override string ToString()
        {
            return
                "GetMyRoles, ReturnValue: " + ReturnValue.ToString() + 
                ", pwszAuthority: " + pwszAuthority.ToString() +
                ", pdwRoles: " + EnumToString<Permission>(pdwRoles);
        }
    }
    with Technologies.IDL.IDL{Opnum = 47};
    
    accepts operation DeleteRow
    {
        in string pwszAuthority
            with Technologies.IDL.IDL
            {
                PointerType = PointerKind.UniquePtr,
                BaseStringType = TypeOf<wchar_t>(),
                String = true,
                IndirectionLevel = 1
            };
        in DeleteRow_dwFlags dwFlags with Encoding{Decoder = PatternDecoder<DeleteRow_dwFlags>, SourcePattern = TypeOf<DWORD>()};
        in FILETIME FileTime;
        in DeleteRow_dwTable dwTable with Encoding{Decoder = PatternDecoder<DeleteRow_dwTable>, SourcePattern = TypeOf<DWORD>()};
        in DWORD dwRowId where ValidationCheck((FileTime.dwLowDateTime == 0 && FileTime.dwHighDateTime == 0) || ((FileTime.dwLowDateTime != 0 || FileTime.dwHighDateTime != 0) && value == 0), this, DiagnosisLevel.Error, () => CSRA_DWROWID_MUST_BE_ZERO_IF_FILETIME_IS_NONZERO);
        out LONG pcDeleted with Technologies.IDL.IDL{Retval = true, IndirectionLevel = 1};
        result CSRA.HRESULT ReturnValue;
        
        override string ToString()
        {
            return
                "DeleteRow, ReturnValue: " + ReturnValue.ToString() +
                ", pwszAuthority: " + pwszAuthority.ToString() +
                ", dwFlags: " + EnumToString<DeleteRow_dwFlags>(dwFlags) +
                ", dwTable: " + EnumToString<DeleteRow_dwTable>(dwTable) +
                ", dwRowId: " + dwRowId.ToString() + 
                ", pcDeleted: " + pcDeleted.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 48};
}
with Technologies.IDL.IDL
{
    Uuid = {7fe0d935-dda6-443f-85d0-1cfb58fe41dd},
    Object = true,
    Pointer_default = PointerKind.UniquePtr,
    Helpstring = "ICertAdmin2 DCOM Interface"
};

typedef BYTE = byte;

type CERTTRANSBLOB[PROPTYPE PropType, uint ItemCount, GetCAPropertyID PropId, WCCE.GetCAPropertyType GetCA_PropType]
{
    ULONG cb;
    PbType pb with Technologies.IDL.IDL
        {
            Size_is = [cb],
            PointerType = PointerKind.UniquePtr,
            IndirectionLevel = 1
        },
        Encoding
        {
            Decoder = pbDecoder,
            SourcePattern = TypeOf<array<BYTE>>(),
        };

    optional PbType pbDecoder(binary bin)
    {
        if (bin == null || bin.Count == 0)
        {
            return bin;
        }

        optional PbType res = nothing;
        bool isUndefinedGetCAProperty = false;
        bool isUndefinedSetCAProperty = false;
        switch (PropType)
        {
            case PROPTYPE.PROPTYPE_LONG =>
                res = BinaryDecoder<LONG>(bin);
            case PROPTYPE.PROPTYPE_DATE =>
                res = BinaryDecoder<FILETIME>(bin);
            case PROPTYPE.PROPTYPE_BINARY =>
                res = bin;
            case PROPTYPE.PROPTYPE_STRING =>
                res = BinaryDecoder<string>(bin);
            case PROPTYPE.PROPTYPE_ARRAYDWORD => 
                res = BinaryDecoder<DWORDArray[ItemCount]>(bin);
            case PROPTYPE.PROPTYPE_CERT =>
                res = Asn1BerDecoder<X509.Certificate>(bin);
            case PROPTYPE.PROPTYPE_CRL =>
                res = Asn1BerDecoder<X509.CertificateList>(bin);
            case PROPTYPE.PROPTYPE_CERTTRANSDBCOLUMN =>
                res = BinaryDecoder<MarshaledCERTTRANSDBCOLUMN[bin, ItemCount]>(bin);
            case PROPTYPE.PROPTYPE_CERTTRANSDBATTRIBUTE =>
                res = BinaryDecoder<MarshaledCERTTRANSDBATTRIBUTE[bin, ItemCount]>(bin);
            case PROPTYPE.PROPTYPE_CERTTRANSDBEXTENSION =>
                res = BinaryDecoder<MarshaledCERTTRANSDBEXTENSION[bin, ItemCount]>(bin);
            case PROPTYPE.PROPTYPE_CERTTRANSDBRESULTROW =>
                res = BinaryDecoder<MarshaledCERTTRANSDBRESULTROW[ItemCount]>(bin);
            case PROPTYPE.PROPTYPE_SECURITY_DESCRIPTOR =>
                res = BinaryDecoder<SECURITY_DESCRIPTOR_NonRpc>(bin);
            case PROPTYPE.PROPTYPE_GETCAPROPERTY =>
                res = WCCE.DecodePropertyValue(PropId, cb, bin);
                if (res == nothing)
                {
                    isUndefinedGetCAProperty = true;
                }
            case PROPTYPE.PROPTYPE_SETCAPROPERTY =>
                res = WCCE.DecodePropertyValue(PropId, cb, bin);
                if (res == nothing)
                {
                    isUndefinedSetCAProperty = true;
                }
            case PROPTYPE.PROPTYPE_CATRANSPROP =>
                res = BinaryDecoder<MarshaledCATRANSPROP[bin, ItemCount]>(bin);
            case PROPTYPE.PROPTYPE_ARCHIVEDKEY =>
                //res = Asn1BerDecoder<X509.ContentInfo>(bin); 
                res = bin;// Bug#80169
            case PROPTYPE.PROPTYPE_GETOFFICERRIGHTS =>
                // in this context, the ItemCount is the value of fEnable in GetOfficerRights
                bool isOfficerRightsEnabled = ItemCount != 0;
                if (BinaryDecoder<OfficerRights_EADisabled[isOfficerRightsEnabled]>(bin) is ord:OfficerRights_EADisabled)
                {
                    res = ord;
                }
                else if(BinaryDecoder<OfficerRights_EAEnabled[isOfficerRightsEnabled]>(bin) is ore:OfficerRights_EAEnabled)
                {
                    res = ore;
                }
                else
                {
                    res = BinaryDecoder<SECURITY_DESCRIPTOR_NonRpc>(bin); // Deal with this case that the Enrollment Agent rights are not supported by the server
                }
            default =>;
        }

        if (res == nothing)
        {
            if (isUndefinedGetCAProperty)
            {
                ValidationCheck(false, null, DiagnosisLevel.Error, () => Format(CSRA_INVALID_PROPID, EnumToString<GetCAPropertyID>(PropId), EnumToString<WCCE.GetCAPropertyType>(GetCA_PropType), "GetCAProperty"));
            }
            else if(isUndefinedSetCAProperty)
            {
                ValidationCheck(false, null, DiagnosisLevel.Error, () => Format(CSRA_INVALID_PROPID, EnumToString<GetCAPropertyID>(PropId), EnumToString<WCCE.GetCAPropertyType>(GetCA_PropType), "SetCAProperty"));
            }
            else
            {
                ValidationCheck(false, null, DiagnosisLevel.Error, () => Format(CSRA_DECODE_PB_FAILED, 
                    GetCA_PropType != 0 ? EnumToString<WCCE.GetCAPropertyType>(GetCA_PropType) : EnumToString<PROPTYPE>(PropType)));
            }
            return bin;
        }

        return res;
    }
}

pattern PbType = LONG | FILETIME | binary | string | DWORDArray | X509.Certificate | X509.CertificateList |
    MarshaledCERTTRANSDBCOLUMN | MarshaledCERTTRANSDBATTRIBUTE | MarshaledCERTTRANSDBEXTENSION | MarshaledCERTTRANSDBRESULTROW |
    SECURITY_DESCRIPTOR_NonRpc | CAINFO | uint | array<CATRANSPROP> | CMS.ContentInfo | DispositionStatusArray | KRACertStatusArray |
    CRLPublishFlags | ERREF.HRESULT | OfficerRights_EADisabled | OfficerRights_EAEnabled | MarshaledCATRANSPROP;

// Enum defined here to help decoding the CERTTRANSBLOB
pattern PROPTYPE = enum DWORD
{
    PROPTYPE_LONG                 = 0x00000001,
    PROPTYPE_DATE                 = 0x00000002,
    PROPTYPE_BINARY               = 0x00000003,
    PROPTYPE_STRING               = 0x00000004,
    PROPTYPE_ARRAYDWORD           = 0x00000005,
    PROPTYPE_CERT                 = 0x00000006,
    PROPTYPE_CRL                  = 0x00000007,
    PROPTYPE_CERTTRANSDBCOLUMN    = 0x00000008,
    PROPTYPE_CERTTRANSDBATTRIBUTE = 0x00000009,
    PROPTYPE_CERTTRANSDBEXTENSION = 0x0000000A,
    PROPTYPE_CERTTRANSDBRESULTROW = 0x0000000B,
    PROPTYPE_SECURITY_DESCRIPTOR  = 0x0000000C,
    PROPTYPE_GETCAPROPERTY        = 0x0000000D,
    PROPTYPE_SETCAPROPERTY        = 0x0000000E,
    PROPTYPE_CATRANSPROP          = 0x0000000F,
    PROPTYPE_ARCHIVEDKEY          = 0x00000010,
    PROPTYPE_GETOFFICERRIGHTS     = 0x00000011,
    ...
} with IDL{DoNotGenerate = true};

pattern ENUM_CATYPES = enum
{
    ENUM_ENTERPRISE_ROOTCA = 0x00000000,
    ENUM_ENTERPRISE_SUBCA = 0x00000001,
    ENUM_STANDALONE_ROOTCA = 0x00000003,
    ENUM_STANDALONE_SUBCA = 0x00000004,
    ...
};


// The following structures with value parameter EntryOffset is not align with TD, for it contains the actual contents.
// But we gain better user experience and performance by define it like this.
type CERTTRANSDBATTRIBUTE[binary SourceBuffer]
{
    ULONG obwszName where ValidationCheck((value & 0x00000003) == 0, null, DiagnosisLevel.Error, () => Format(CSRA_MUST_BE_DIVISIBLE_BY_4, "obwszName", "CERTTRANSDBATTRIBUTE"));
    ULONG obwszValue where ValidationCheck((value & 0x00000003) == 0, null, DiagnosisLevel.Error, () => Format(CSRA_MUST_BE_DIVISIBLE_BY_4, "obwszValue", "CERTTRANSDBATTRIBUTE"));
    optional [|obwszName > 0|] string Name with Encoding{Offset = obwszName, SourceData = SourceBuffer},
        IDL{DoNotGenerate = true};
    optional [|obwszValue > 0|] string Value with Encoding{Offset = obwszValue, SourceData = SourceBuffer},
        IDL{DoNotGenerate = true};
} with Encoding{EncodingKind = EncodingKind.Binary};

type MarshaledCERTTRANSDBATTRIBUTE[binary SourceBuffer, uint Count]
{
    array<CERTTRANSDBATTRIBUTE[SourceBuffer]> CERTTRANSDBATTRIBUTEs with BinaryEncoding{Length = Count};
} with IDL{DoNotGenerate = true},
    Encoding{EncodingKind = EncodingKind.Binary};

type CERTTRANSDBEXTENSION[binary SourceBuffer]
{
    ULONG obwszName where ValidationCheck((value & 0x00000003) == 0, null, DiagnosisLevel.Error, () => Format(CSRA_MUST_BE_DIVISIBLE_BY_4, "obwszName", "CERTTRANSDBEXTENSION"));
    CERTTRANSDBEXTENSION_ExtFlags ExtFlags;
    DWORD cbValue;
    ULONG obValue where ValidationCheck((value & 0x00000003) == 0, null, DiagnosisLevel.Error, () => Format(CSRA_MUST_BE_DIVISIBLE_BY_4, "obValue", "CERTTRANSDBEXTENSION"));
    optional [|obwszName > 0|] string Name with Encoding{Offset = obwszName, SourceData = SourceBuffer},
        IDL{DoNotGenerate = true};
    optional [|obValue > 0 && cbValue != 0|] Extension Value
        with Encoding{Offset = obValue, Size = cbValue, SourceData = SourceBuffer, Decoder = Asn1BerDecoder<Extension>, SourcePattern = TypeOf<binary>()},
            BinaryEncoding{Length = cbValue}, IDL{DoNotGenerate = true};
} with Encoding{EncodingKind = EncodingKind.Binary};

type CERTTRANSDBEXTENSION_ExtFlags
{
    CERTTRANSDBEXTENSION_ExtFlags_Nigiro Nigiro with BinaryEncoding{Endian = Standard.Endian.Big};
    CERTTRANSDBEXTENSION_ExtFlags_Flags Flags with BinaryEncoding{Endian = Standard.Endian.Big};
} with IDL{DoNotGenerate = true},
    Encoding{EncodingKind = EncodingKind.Binary},
    BinaryEncoding{WidthForComposedType = 32, DecodeAsUnit = true};

pattern CERTTRANSDBEXTENSION_ExtFlags_Nigiro = enum WORD
{
    $"come from request"                 = 0x0001,
    $"added by policy module"            = 0x0002,
    $"added by human admin"              = 0x0003,
    $"added by cert server engine"       = 0x0004,
    $"in preceding cert"                 = 0x0005,
    $"come from imported cert"           = 0x0006,
    $"come from PKCS7 request"           = 0x0007,
    $"come from CMC request"             = 0x0008,
    $"come from current CA signing cert" = 0x0009,
    ...
} with IDL{DoNotGenerate = true};

pattern CERTTRANSDBEXTENSION_ExtFlags_Flags = flags WORD
{
    C = 0x00001,
    D = 0x00002,
    ...
} with IDL{DoNotGenerate = true};

type MarshaledCERTTRANSDBEXTENSION[binary SourceBuffer, uint Count]
{
    array<CERTTRANSDBEXTENSION[SourceBuffer]> CERTTRANSDBEXTENSIONs with BinaryEncoding{Length = Count};
} with IDL{DoNotGenerate = true},
    Encoding{EncodingKind = EncodingKind.Binary};

type CERTTRANSDBCOLUMN[binary SourceBuffer]
{
    CERTTRANSDBCOLUMN_Type Type;
    DWORD Index;
    DWORD cbMax;
    ULONG obwszName where ValidationCheck((value & 0x00000003) == 0, null, DiagnosisLevel.Error, () => Format(CSRA_MUST_BE_DIVISIBLE_BY_4, "obwszName", "CERTTRANSDBCOLUMN"));
    ULONG obwszDisplayName where ValidationCheck((value & 0x00000003) == 0, null, DiagnosisLevel.Error, () => Format(CSRA_MUST_BE_DIVISIBLE_BY_4, "obwszDisplayName", "CERTTRANSDBCOLUMN"));
    optional [|obwszName > 0|] string Name with Encoding{Offset = obwszName, SourceData = SourceBuffer},
        IDL{DoNotGenerate = true};
    optional [|obwszDisplayName > 0|] string DisplayName with Encoding{Offset = obwszDisplayName, SourceData = SourceBuffer},
        IDL{DoNotGenerate = true};
} with Encoding{EncodingKind = EncodingKind.Binary};

type CERTTRANSDBCOLUMN_Type
{
    CERTTRANSDBCOLUMN_Type_Flags Flags with BinaryEncoding{Endian = Standard.Endian.Big};
    byte Reserved;
    CERTTRANSDBCOLUMN_Type_ValueType valuetype;
} with IDL{DoNotGenerate = true},
    Encoding{EncodingKind = EncodingKind.Binary},
    BinaryEncoding{WidthForComposedType = 32, DecodeAsUnit = true};

pattern CERTTRANSDBCOLUMN_Type_Flags = flags WORD
{
    I = 0x0001,
    ...
} with IDL{DoNotGenerate = true};

pattern CERTTRANSDBCOLUMN_Type_ValueType = enum byte
{
    $"signed integer" = 0x01,
    date              = 0x02,
    $"binary"         = 0x03,
    $"string"         = 0x04,
    ...
} with IDL{DoNotGenerate = true};

type MarshaledCERTTRANSDBCOLUMN[binary SourceBuffer, uint Count]
{
    array<CERTTRANSDBCOLUMN[SourceBuffer]> CERTTRANSDBCOLUMNs with BinaryEncoding{Length = Count};
} with IDL{DoNotGenerate = true},
    Encoding{EncodingKind = EncodingKind.Binary};

type CERTTRANSDBRESULTCOLUMN[binary SourceBuffer]
{
    CERTTRANSDBCOLUMN_Type Type;
    DWORD Index;
    ULONG obValue where ValidationCheck((value & 0x00000003) == 0, null, DiagnosisLevel.Error, () => Format(CSRA_MUST_BE_DIVISIBLE_BY_4, "obValue", "CERTTRANSDBRESULTCOLUMN"));
    DWORD cbValue;
    optional [|obValue > 0 && cbValue > 0|] 
        ([|Type.valuetype == CERTTRANSDBCOLUMN_Type_ValueType.$"signed integer"|] int
        | [|Type.valuetype == CERTTRANSDBCOLUMN_Type_ValueType.date|] FILETIME
        | [|Type.valuetype == CERTTRANSDBCOLUMN_Type_ValueType.$"string"|] string
        | binary) Value with Encoding{Offset = obValue > 0 && cbValue > 0 ? obValue - 12 : 0, Size = cbValue, SourceData = SourceBuffer},
            IDL{DoNotGenerate = true};
} with Encoding{EncodingKind = EncodingKind.Binary};

type CERTTRANSDBRESULTROW
{
    DWORD rowid;
    DWORD ccol;
    ULONG cbrow;
    binary dataBuffer with BinaryEncoding{Length = cbrow - 12}, IDL{DoNotGenerate = true};
    optional [|cbrow - 12 > 0|] array<CERTTRANSDBRESULTCOLUMN[dataBuffer]> CERTTRANSDBRESULTCOLUMNs
        with Encoding{SourceData = dataBuffer}, BinaryEncoding{Length = ccol}, IDL{DoNotGenerate = true};
} with Encoding{EncodingKind = EncodingKind.Binary};

type MarshaledCERTTRANSDBRESULTROW[uint Count]
{
    array<CERTTRANSDBRESULTROW> CERTTRANSDBRESULTROWs with BinaryEncoding{Length = Count};
} with IDL{DoNotGenerate = true}, 
    Encoding{EncodingKind = EncodingKind.Binary};

type CERTVIEWRESTRICTION
{
    DWORD ColumnIndex;
    CERTVIEWRESTRICTION_SeekOperator SeekOperator
        where ValidationCheckEnumValueTooManyItems(InRange<CERTVIEWRESTRICTION_SeekOperator>(value), null, true, ReferenceType.Type, "CSRA", "SeekOperator", "CERTVIEWRESTRICTION", "CERTVIEWRESTRICTION", "[MS-CSRA]")
        with Encoding{Decoder = PatternDecoder<CERTVIEWRESTRICTION_SeekOperator>, SourcePattern = TypeOf<LONG>()};
    CERTVIEWRESTRICTION_SortOrder SortOrder
        where ValidationCheckEnumValue(InRange<CERTVIEWRESTRICTION_SortOrder>(value), null, true, ReferenceType.Type, "CSRA", "SortOrder", "CERTVIEWRESTRICTION", "0x00000000, 0x00000001, 0x00000002", value)
        with Encoding{Decoder = PatternDecoder<CERTVIEWRESTRICTION_SortOrder>, SourcePattern = TypeOf<LONG>()};
    array<BYTE> pbValue with Technologies.IDL.IDL
        {
            Size_is = [cbValue],
            PointerType = PointerKind.UniquePtr,
            IndirectionLevel = 1
        };
    DWORD cbValue;
}

pattern CERTVIEWRESTRICTION_SeekOperator = enum LONG
{
    EqualTo              = 0x00000001,
    LessThan             = 0x00000002,
    LessThanOrEqualTo    = 0x00000004,
    GreaterThanOrEqualTo = 0x000000008,
    GreaterThan          = 0x00000010,
    ...
} with IDL{DoNotGenerate = true};

pattern CERTVIEWRESTRICTION_SortOrder = enum LONG
{
    NoSortOrder = 0x00000000,
    Ascending   = 0x00000001,
    Descending  = 0x00000002,
    ...
} with IDL{DoNotGenerate = true};

pattern SetExtension_dwType = enum DWORD
{
    $"unsigned long data" = 0x00000001,
    $"date/time"          = 0x00000002,
    $"binary data"        = 0x00000003,
    unicode               = 0x00000004,
    ...
} with IDL{DoNotGenerate = true};

pattern SetExtension_dwFlags = enum DWORD
{
    $"critical extension"         = 0x00000001,
    $"extension MUST NOT be used" = 0x00000002,
} with IDL{DoNotGenerate = true};

pattern IsValidCertificate_RevocationReason = enum LONG
{
    unspecified          = 0,
    keyCompromise        = 1,
    cACompromise         = 2,
    affiliationChanged   = 3,
    superseded           = 4,
    cessationOfOperation = 5,
    certificateHold      = 6,
    ...
} with IDL{DoNotGenerate = true};

pattern IsValidCertificate_Disposition = enum LONG
{
    revoked = 0x00000002,
    valid = 0x00000003,
    never_issued = 0x00000004,
    ...
} with IDL{DoNotGenerate = true};

pattern RevokeCertificate_Reason = enum DWORD
{
    unspecified                                 = 0,
    keyCompromise                               = 1,
    cACompromise                                = 2,
    affiliationChanged                          = 3,
    superseded                                  = 4,
    cessationOfOperation                        = 5,
    certificateHold                             = 6,
    removeFromCRL                               = 8,
    $"set the Publish_Expired_Cert_In_CRL to 0" = 0xfffffffd,
    $"set the Publish_Expired_Cert_In_CRL to 1" = 0xfffffffe,
    $"invalid data"                             = 0xffffffff,
    ...
} with IDL{DoNotGenerate = true};

pattern GetViewDefaultColumnSet_iColumnSetDefault = enum DWORD
{
    pending_requests = 0xFFFFFFFF,
    issued_certs     = 0xFFFFFFFE,
    failed_requests  = 0xFFFFFFFD,
    extensions       = 0xFFFFFFFC,
    attributes       = 0xFFFFFFFB,
    CRLs             = 0xFFFFFFFA,
    revoked_certs    = 0xFFFFFFF9,
    ...
} with IDL{DoNotGenerate = true};

pattern EnumAttributesOrExtensions_Flags = enum DWORD
{
    attributes = 0x00000000,
    extensions = 0x00000001,
    ...
} with IDL{DoNotGenerate = true};

pattern ServerControl_dwControlFlags = enum DWORD
{
    $"unregister for DCOM interfaces" = 0x00000001,
    unused                            = 0x00000002,
    unused2                           = 0x00000003,
    ...
} with IDL{DoNotGenerate = true};

pattern BackupPrepare_grbitJet = enum ULONG
{
    full_backup        = 0x00000000,
    incremental_backup = 0x00000001,
    ...
} with IDL{DoNotGenerate = true};

pattern ImportCertificate_dwFlags = enum LONG
{
    NOT_ALLOW_IMPORT_FOREIGN  = 0x00000000,
    FLAG_ALLOW_IMPORT_FOREIGN = 0x00010000,
    ICF_EXISTINGROW           = 0x00020000,
    ...
} with IDL{DoNotGenerate = true};

pattern PublishCRLs_Flags = flags DWORD
{
    B = 0x00000001,
    D = 0x00000002,
    F = 0x00000010,
    ...
} with IDL{DoNotGenerate = true};

pattern EnumViewColumnTable_iTable = enum DWORD
{
    Request   = 0x00000000,
    Extension = 0x00003000,
    Attribute = 0x00004000,
    CRL       = 0x00005000,
    ...
} with IDL{DoNotGenerate = true};

pattern GetAuditFilter_pdwFilter = flags DWORD
{
    ServerControl     = 0x00000001,
    Backup            = 0x00000002,
    ICertRequestD     = 0x00000004,
    RevokeCertificate = 0x00000008,
    SetCASecurity     = 0x00000010,
    GetArchivedKey    = 0x00000020,
    SetCAProperty     = 0x00000040,
    ...
} with IDL{DoNotGenerate = true};

type SetOfficerRights_fEnable
{
    ushort fRightsEnable;
    ushort RightsType;
} with IDL{DoNotGenerate = true}, Encoding{EncodingKind = EncodingKind.Binary};

uint get Value(this SetOfficerRights_fEnable fEnable)
{
    return ((fEnable.fRightsEnable as uint) << 16) + fEnable.RightsType;
}

type OfficerRights_EADisabled[bool IsOfficerRightsEnabled]
{
    optional [|IsOfficerRightsEnabled|] SECURITY_DESCRIPTOR_NonRpc OfficerRights;
    DWORD bEARightDisabled where value == 0;
} with IDL{DoNotGenerate = true}, Encoding{EncodingKind = EncodingKind.Binary};

type OfficerRights_EAEnabled[bool IsOfficerRightsEnabled]
{
    optional [|IsOfficerRightsEnabled|] SECURITY_DESCRIPTOR_NonRpc OfficerRights;
    DWORD bEARightEnabled where ValidationCheck(value != 0, null, DiagnosisLevel.Error, () => Format(CSRA_VALUE_MUST_BE_NONZERO_IN_TYPE, "bEARightEnabled", "OfficerRights_EAEnabled"));
    SECURITY_DESCRIPTOR_NonRpc EnrollmentAgentRights;
} with IDL{DoNotGenerate = true}, Encoding{EncodingKind = EncodingKind.Binary};

pattern ImportKey_dwFlags = enum DWORD
{
    overwrite = 0x00010000,
    ...
} with IDL{DoNotGenerate = true};

pattern Permission = flags LONG
{
    Read          = 0x00000100,
    Enroll        = 0x00000200,
    Officer       = 0x00000002,
    Administrator = 0x00000001,
    Auditor       = 0x00000004,
    Operator      = 0x00000008,
    ...
} with IDL{DoNotGenerate = true};

pattern DeleteRow_dwFlags = enum DWORD
{
    $"individual row"                     = 0x00000000,
    $"contain expired certs"              = 0x00000001,
    $"contain pending or failed requests" = 0x00000002,
    ...
} with IDL{DoNotGenerate = true};

pattern DeleteRow_dwTable = enum DWORD
{
    $"Request table"   = 0x00000000,
    $"extension table" = 0x00003000,
    $"attribute table" = 0x00004000,
    $"CRL table"       = 0x00005000,
    ...
} with IDL{DoNotGenerate = true};

optional binary BOOLToBinary(BOOL input)
{
    return input.ToBinary();
}

type DBFileName
{
    FileTypeCode fileTypeCode;
    string UNCPath;

    override string ToString()
    {
        return fileTypeCode.ToString() + UNCPath;
    }

} with IDL{DoNotGenerate = true}, Encoding{EncodingKind = EncodingKind.Binary};

pattern FileTypeCode = enum char
{
    DatabaseFiles = 'D',
    DatabaseLogFiles = '!',
    ...
} with IDL{DoNotGenerate = true};

optional binary ArrayWCHARToBinary(array<WCHAR> arr)
{
    if (arr != null && arr.Count > 0)
    {
        return arr.Accumulate<WCHAR, binary>((WCHAR item, binary bin) => bin + item.ToBinary(true));
    }

    return nothing;
}

optional binary IntToBinary(int val)
{
    return val.ToBinary();
}

pattern HRESULT = ERREF.HRESULT with IDL{DoNotGenerate = true},
    Encoding{Decoder = BinaryDecoder<ERREF.HRESULT>, SourceConverter = IntToBinary, SourcePattern = TypeOf<int>()};

type DWORDArray[uint Count]
{
    array<DWORD> DWORDArray with BinaryEncoding{Length = Count};
} with IDL{DoNotGenerate = true},
    Encoding{EncodingKind = EncodingKind.Binary};
