protocol SCMR with
Standard.Documentation
{
    ProtocolName = "Service Control Manager Remote Protocol",
    ProtocolType = "rpc",
    DocumentName = "MS-SCMR",
    ShortName = "SCMR",
    Description = ""
},
OPNAuthoring
{
    Copyright = "(c) Microsoft Corporation",
    References = 
    [
        new Reference {Name = "MS-SCMR", Version = "27.1", Date = "09/15/2017", ProgramName = ProgramName.WSPP}
    ],
    RevisionSummary = 
    [
        new Revision {Class = RevisionClass.Major, Version = "", Date = ""}
    ]
};

using Technologies.IDL;
using DTYP;
using MSRPCE;
using Utility;
using IdentityAndSecurityResources;
using InfrastructureResources;
using Diagnostics;

endpoint SvcctlService over MSRPCE.Server provides svcctl;

contract svcctl
{
    accepts operation RCloseServiceHandle
    {
        in out SC_RPC_HANDLE hSCObject with Technologies.IDL.IDL{IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RCloseServiceHandle, ReturnValue: " + ReturnValue.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 0};
    
    accepts operation RControlService
    {
        in SC_RPC_HANDLE hService;
        in ControlCode dwControl
            where ValidationCheckEnumValueTooManyItems(InRange<ControlCode>(value), this, true, ReferenceType.Message,
                "SCMR", "dwControl", "RControlService", "Control Code", "[MS-SCMR]") 
            with Encoding{Decoder = PatternDecoder<ControlCode>, SourcePattern = TypeOf<DWORD>()};
        out SERVICE_STATUS lpServiceStatus with Technologies.IDL.IDL{IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RControlService, ReturnValue: " + ReturnValue.ToString() +
                ", dwControl: " + EnumToStringInSummary<ControlCode>(dwControl);
        }
    }
    with Technologies.IDL.IDL{Opnum = 1};
    
    accepts operation RDeleteService
    {
        in SC_RPC_HANDLE hService;
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RDeleteService, ReturnValue: " + ReturnValue.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 2};
    
    accepts operation RLockServiceDatabase
    {
        in SC_RPC_HANDLE hSCManager;
        out SC_RPC_LOCK lpLock with Technologies.IDL.IDL{IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RLockServiceDatabase, ReturnValue: " + ReturnValue.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 3};
    
    accepts operation RQueryServiceObjectSecurity
    {
        in SC_RPC_HANDLE hService;
        in SecurityInformation dwSecurityInformation
            where ValidationCheckCombinationValueTooManyItems(InRange<SecurityInformation>(value), this, true, ReferenceType.Message,
                "SCMR", "dwSecurityInformation", "RQueryServiceObjectSecurity", "Security Information", "[MS-SCMR]") 
            with Encoding{Decoder = PatternDecoder<SecurityInformation>, SourcePattern = TypeOf<SECURITY_INFORMATION>()};
        out (SECURITY_DESCRIPTOR_NonRpc | binary) lpSecurityDescriptor
            with Technologies.IDL.IDL{Size_is = [cbBufSize], IndirectionLevel = 1},
            Encoding{Decoder = (x) => SecurityDescriptorDecoder(pcbBytesNeeded, x), SourcePattern = TypeOf<array<byte>>()};
        in DWORD cbBufSize with Technologies.IDL.IDL{Range = new RangePattern{Low = 0, High = 262144}};
        out BOUNDED_DWORD_256K pcbBytesNeeded with Technologies.IDL.IDL{IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RQueryServiceObjectSecurity, ReturnValue: " + ReturnValue.ToString() +
                ", dwSecurityInformation: " + EnumToStringInSummary<SecurityInformation>(dwSecurityInformation);
        }
    }
    with Technologies.IDL.IDL{Opnum = 4};
    
    accepts operation RSetServiceObjectSecurity
    {
        in SC_RPC_HANDLE hService;
        in SecurityInformation dwSecurityInformation
            where ValidationCheckCombinationValueTooManyItems(InRange<SecurityInformation>(value), this, true, ReferenceType.Message,
                "SCMR", "dwSecurityInformation", "RSetServiceObjectSecurity", "Security Information", "[MS-SCMR]") 
            with Encoding{Decoder = PatternDecoder<SecurityInformation>, SourcePattern = TypeOf<SECURITY_INFORMATION>()};
        in SECURITY_DESCRIPTOR_NonRpc lpSecurityDescriptor with Technologies.IDL.IDL{Size_is = [cbBufSize], IndirectionLevel = 1},
            Encoding{Decoder = BinaryDecoder<SECURITY_DESCRIPTOR_NonRpc>, SourcePattern = TypeOf<array<byte>>()};
        in DWORD cbBufSize;
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RSetServiceObjectSecurity, ReturnValue: " + ReturnValue.ToString() +
                ", dwSecurityInformation: " + EnumToStringInSummary<SecurityInformation>(dwSecurityInformation);
        }
    }
    with Technologies.IDL.IDL{Opnum = 5};
    
    accepts operation RQueryServiceStatus
    {
        in SC_RPC_HANDLE hService;
        out SERVICE_STATUS lpServiceStatus with Technologies.IDL.IDL{IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RQueryServiceStatus, ReturnValue: " + ReturnValue.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 6};
    
    accepts operation RSetServiceStatus
    {
        in SC_RPC_HANDLE hServiceStatus;
        in SERVICE_STATUS lpServiceStatus with Technologies.IDL.IDL{IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RSetServiceStatus, ReturnValue: " + ReturnValue.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 7};
    
    accepts operation RUnlockServiceDatabase
    {
        in out SC_RPC_LOCK Lock with Technologies.IDL.IDL{IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RUnlockServiceDatabase, ReturnValue: " + ReturnValue.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 8};
    
    accepts operation RNotifyBootConfigStatus
    {
        in string lpMachineName with Technologies.IDL.IDL
        {
            Range = new RangePattern{Low = 0, High = SC_MAX_COMPUTER_NAME_LENGTH},
            PointerType = PointerKind.UniquePtr,
            BaseStringType = TypeOf<SVCCTL_HANDLEW>(),
            String = true
        };
        in DWORD BootAcceptable;
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RNotifyBootConfigStatus, ReturnValue: " + ReturnValue.ToString() +
                ", lpMachineName: " + lpMachineName;
        }
    }
    with Technologies.IDL.IDL{Opnum = 9};
    
    accepts operation Opnum10NotUsedOnWire
    {
        override string ToString()
        {
            return "Opnum10NotUsedOnWire";
        }
    }
    with Technologies.IDL.IDL{Opnum = 10};
    
    accepts operation RChangeServiceConfigW
    {
        in SC_RPC_HANDLE hService;
        in RChangeServiceConfigServiceType dwServiceType
            where ValidationCheckEnumValueTooManyItems(InRange<RChangeServiceConfigServiceType>(value), this, true, ReferenceType.Message,
                "SCMR", "dwServiceType", "RChangeServiceConfigW", "Service Type", "[MS-SCMR]") 
            with Encoding{Decoder = PatternDecoder<RChangeServiceConfigServiceType>, SourcePattern = TypeOf<DWORD>()};
        in RChangeServiceConfigStartType dwStartType
            where ValidationCheckEnumValueTooManyItems(InRange<RChangeServiceConfigStartType>(value), this, true, ReferenceType.Message,
                "SCMR", "dwStartType", "RChangeServiceConfigW", "Start Type", "[MS-SCMR]") 
            with Encoding{Decoder = PatternDecoder<RChangeServiceConfigStartType>, SourcePattern = TypeOf<DWORD>()};
        in RChangeServiceConfigErrorControl dwErrorControl
            where ValidationCheckEnumValueTooManyItems(InRange<RChangeServiceConfigErrorControl>(value), this, true, ReferenceType.Message,
                "SCMR", "dwErrorControl", "RChangeServiceConfigW", "Error Control", "[MS-SCMR]") 
            with Encoding{Decoder = PatternDecoder<RChangeServiceConfigErrorControl>, SourcePattern = TypeOf<DWORD>()};
        in string lpBinaryPathName with Technologies.IDL.IDL
        {
            Range = new RangePattern{Low = 0, High = SC_MAX_PATH_LENGTH},
            PointerType = PointerKind.UniquePtr,
            BaseStringType = TypeOf<wchar_t>(),
            String = true,
            IndirectionLevel = 1
        };
        in string lpLoadOrderGroup with Technologies.IDL.IDL
        {
            Range = new RangePattern{Low = 0, High = SC_MAX_NAME_LENGTH},
            PointerType = PointerKind.UniquePtr,
            BaseStringType = TypeOf<wchar_t>(),
            String = true,
            IndirectionLevel = 1
        };
        in out IDLUlong? lpdwTagId with IDL{PointerType = PointerKind.UniquePtr, IndirectionLevel = 1};
        in array<char> lpDependencies with IDL{Size_is = [dwDependSize], PointerType = PointerKind.UniquePtr, IndirectionLevel = 1};
        in DWORD dwDependSize with Technologies.IDL.IDL{Range = new RangePattern{Low = 0, High = SC_MAX_DEPEND_SIZE}};
        in string lpServiceStartName with Technologies.IDL.IDL
        {
            Range = new RangePattern{Low = 0, High = SC_MAX_ACCOUNT_NAME_LENGTH},
            PointerType = PointerKind.UniquePtr,
            BaseStringType = TypeOf<wchar_t>(),
            String = true,
            IndirectionLevel = 1
        };
        in array<char> lpPassword with IDL{Size_is = [dwPwSize], PointerType = PointerKind.UniquePtr, IndirectionLevel = 1};
        in DWORD dwPwSize with IDL{Range = new RangePattern{Low = 0, High = SC_MAX_PWD_SIZE}};
        in string lpDisplayName with Technologies.IDL.IDL
        {
            Range = new RangePattern{Low = 0, High = SC_MAX_NAME_LENGTH},
            PointerType = PointerKind.UniquePtr,
            BaseStringType = TypeOf<wchar_t>(),
            String = true,
            IndirectionLevel = 1
        };
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RChangeServiceConfigW, ReturnValue: " + ReturnValue.ToString() +
                ", dwServiceType: " + EnumToStringInSummary<RChangeServiceConfigServiceType>(dwServiceType) +
                ", dwStartType: " + EnumToStringInSummary<RChangeServiceConfigStartType>(dwStartType) +
                ", dwErrorControl: " + EnumToStringInSummary<RChangeServiceConfigErrorControl>(dwErrorControl) +
                ", lpBinaryPathName: " + lpBinaryPathName +
                ", lpLoadOrderGroup: " + lpLoadOrderGroup +
                ", lpdwTagId: " + (lpdwTagId == null ? "NULL" : lpdwTagId.ToString()) +
                ", lpServiceStartName: " + lpServiceStartName +
                ", lpDisplayName: " + lpDisplayName.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 11};
    
    accepts operation RCreateServiceW
    {
        in SC_RPC_HANDLE hSCManager;
        in string lpServiceName with Technologies.IDL.IDL
        {
            Range = new RangePattern{Low = 0, High = SC_MAX_NAME_LENGTH},
            BaseStringType = TypeOf<wchar_t>(),
            String = true,
            IndirectionLevel = 1
        };
        in string lpDisplayName with Technologies.IDL.IDL
        {
            Range = new RangePattern{Low = 0, High = SC_MAX_NAME_LENGTH},
            PointerType = PointerKind.UniquePtr,
            BaseStringType = TypeOf<wchar_t>(),
            String = true,
            IndirectionLevel = 1
        };
        in SCMRAccessMask dwDesiredAccess
            where ValidationCheckCombinationValueTooManyItems(InRange<SCMRAccessMask>(value), this, true, ReferenceType.Message,
                "SCMR", "dwDesiredAccess", "RCreateServiceW", "Access Mask", "[MS-SCMR]") 
            with Encoding{Decoder = PatternDecoder<SCMRAccessMask>, SourcePattern = TypeOf<DWORD>()};
        in RCreateServiceServiceType dwServiceType
            where ValidationCheckCombinationValueTooManyItems(InRange<RCreateServiceServiceType>(value), this, true, ReferenceType.Message,
                "SCMR", "dwServiceType", "RCreateServiceW", "Service Type", "[MS-SCMR]") 
            with Encoding{Decoder = PatternDecoder<RCreateServiceServiceType>, SourcePattern = TypeOf<DWORD>()};
        in RCreateServiceStartType dwStartType
            where ValidationCheckEnumValueTooManyItems(InRange<RCreateServiceStartType>(value), this, true, ReferenceType.Message,
                "SCMR", "dwStartType", "RCreateServiceW", "Start Type", "[MS-SCMR]") 
            with Encoding{Decoder = PatternDecoder<RCreateServiceStartType>, SourcePattern = TypeOf<DWORD>()};
        in RCreateServiceErrorControl dwErrorControl
            where ValidationCheckEnumValueTooManyItems(InRange<RCreateServiceErrorControl>(value), this, true, ReferenceType.Message,
                "SCMR", "dwErrorControl", "RCreateServiceW", "Error Control", "[MS-SCMR]") 
            with Encoding{Decoder = PatternDecoder<RCreateServiceErrorControl>, SourcePattern = TypeOf<DWORD>()};
        in string lpBinaryPathName with Technologies.IDL.IDL
        {
            Range = new RangePattern{Low = 0, High = SC_MAX_PATH_LENGTH},
            BaseStringType = TypeOf<wchar_t>(),
            String = true,
            IndirectionLevel = 1
        };
        in string lpLoadOrderGroup with Technologies.IDL.IDL
        {
            Range = new RangePattern{Low = 0, High = SC_MAX_NAME_LENGTH},
            PointerType = PointerKind.UniquePtr,
            BaseStringType = TypeOf<wchar_t>(),
            String = true,
            IndirectionLevel = 1
        };
        in out IDLUlong? lpdwTagId with IDL{PointerType = PointerKind.UniquePtr, IndirectionLevel = 1};
        in array<char> lpDependencies with IDL{Size_is = [dwDependSize], PointerType = PointerKind.UniquePtr, IndirectionLevel = 1};
        in DWORD dwDependSize with IDL{Range = new RangePattern{Low = 0, High = SC_MAX_DEPEND_SIZE}};
        in string lpServiceStartName with Technologies.IDL.IDL
        {
            Range = new RangePattern{Low = 0, High = SC_MAX_ACCOUNT_NAME_LENGTH},
            PointerType = PointerKind.UniquePtr,
            BaseStringType = TypeOf<wchar_t>(),
            String = true,
            IndirectionLevel = 1
        };
        in array<char> lpPassword with IDL{Size_is = [dwPwSize], PointerType = PointerKind.UniquePtr, IndirectionLevel = 1};
        in DWORD dwPwSize with IDL{Range = new RangePattern{Low = 0, High = SC_MAX_PWD_SIZE}};
        out SC_RPC_HANDLE lpServiceHandle with Technologies.IDL.IDL{IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RCreateServiceW, ReturnValue: " + ReturnValue.ToString() +
                ", lpServiceName: " + lpServiceName +
                ", lpDisplayName: " + lpDisplayName +
                ", dwDesiredAccess: " + EnumToStringInSummary<SCMRAccessMask>(dwDesiredAccess) +
                ", dwServiceType: " + EnumToStringInSummary<RCreateServiceServiceType>(dwServiceType) +
                ", dwStartType: " + EnumToStringInSummary<RCreateServiceStartType>(dwStartType) +
                ", dwErrorControl: " + EnumToStringInSummary<RCreateServiceErrorControl>(dwErrorControl) +
                ", lpBinaryPathName: " + lpBinaryPathName +
                ", lpLoadOrderGroup: " + lpLoadOrderGroup +
                ", lpdwTagId: " + (lpdwTagId == null ? "NULL" : lpdwTagId.ToString()) + 
                ", dwDependSize: " + dwDependSize.ToString() +
                ", lpServiceStartName: " + lpServiceStartName.ToString() +
                ", dwPwSize: " + dwPwSize.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 12};
    
    accepts operation REnumDependentServicesW
    {
        in SC_RPC_HANDLE hService;
        in REnumServicesServiceState dwServiceState
            where ValidationCheckEnumValueTooManyItems(InRange<REnumServicesServiceState>(value), this, true, ReferenceType.Message,
                "SCMR", "dwServiceState", "REnumDependentServicesW", "Service State", "[MS-SCMR]") 
            with Encoding{Decoder = PatternDecoder<REnumServicesServiceState>, SourcePattern = TypeOf<DWORD>()};
        out array<ENUM_SERVICE_STATUS> lpServices with IDL{Size_is = [cbBufSize], IndirectionLevel = 1},
            Encoding{Decoder = (x) => EnumServiceStatusArrayDecoder(x, true), SourcePattern = TypeOf<array<byte>>()};
        in DWORD cbBufSize with Technologies.IDL.IDL{Range = new RangePattern{Low = 0, High = 262144}};
        out BOUNDED_DWORD_256K pcbBytesNeeded with Technologies.IDL.IDL{IndirectionLevel = 1};
        out BOUNDED_DWORD_256K lpServicesReturned
            where ValidationCheck(value == lpServices.Count, this, () => Format(SCMR_LPBUFFER_INVALID_DATA, "lpServices"))
            with Technologies.IDL.IDL{IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "REnumDependentServicesW, ReturnValue: " + ReturnValue.ToString() +
                ", dwServiceState: " + EnumToStringInSummary<REnumServicesServiceState>(dwServiceState);
        }
    }
    with Technologies.IDL.IDL{Opnum = 13};
    
    accepts operation REnumServicesStatusW
    {
        in SC_RPC_HANDLE hSCManager;
        in REnumServicesServiceType dwServiceType
            where ValidationCheckCombinationValueTooManyItems(InRange<REnumServicesServiceType>(value), this, true, ReferenceType.Message,
                "SCMR", "dwServiceType", "REnumServicesStatusW", "Service Type", "[MS-SCMR]") 
            with Encoding{Decoder = PatternDecoder<REnumServicesServiceType>, SourcePattern = TypeOf<DWORD>()};
        in REnumServicesServiceState dwServiceState
            where ValidationCheckEnumValueTooManyItems(InRange<REnumServicesServiceState>(value), this, true, ReferenceType.Message,
                "SCMR", "dwServiceState", "REnumServicesStatusW", "Service State", "[MS-SCMR]") 
            with Encoding{Decoder = PatternDecoder<REnumServicesServiceState>, SourcePattern = TypeOf<DWORD>()};
        out array<ENUM_SERVICE_STATUS> lpBuffer with IDL{Size_is = [cbBufSize], IndirectionLevel = 1},
            Encoding{Decoder = (x) => EnumServiceStatusArrayDecoder(x, true), SourcePattern = TypeOf<array<byte>>()};
        in DWORD cbBufSize with IDL{Range = new RangePattern{Low = 0, High = 262144}};
        out BOUNDED_DWORD_256K pcbBytesNeeded with IDL{IndirectionLevel = 1};
        out BOUNDED_DWORD_256K lpServicesReturned
            where ValidationCheck(value == lpBuffer.Count, this, () => Format(SCMR_LPBUFFER_INVALID_DATA, "lpBuffer"))
            with IDL{IndirectionLevel = 1};
        in out BOUNDED_DWORD_256K lpResumeIndex with IDL{PointerType = PointerKind.UniquePtr, IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "REnumServicesStatusW, ReturnValue: " + ReturnValue.ToString() +
                ", dwServiceType: " + EnumToStringInSummary<REnumServicesServiceType>(dwServiceType) +
                ", dwServiceState: " + EnumToStringInSummary<REnumServicesServiceState>(dwServiceState);
        }
    }
    with Technologies.IDL.IDL{Opnum = 14};
    
    accepts operation ROpenSCManagerW
    {
        in string lpMachineName with Technologies.IDL.IDL
        {
            Range = new RangePattern{Low = 0, High = SC_MAX_COMPUTER_NAME_LENGTH},
            PointerType = PointerKind.UniquePtr,
            BaseStringType = TypeOf<SVCCTL_HANDLEW>(),
            String = true
        };
        in string lpDatabaseName with Technologies.IDL.IDL
        {
            Range = new RangePattern{Low = 0, High = SC_MAX_NAME_LENGTH},
            PointerType = PointerKind.UniquePtr,
            BaseStringType = TypeOf<wchar_t>(),
            String = true,
            IndirectionLevel = 1
        };
        in SCMRServiceControlManagerAccessMask dwDesiredAccess
            where ValidationCheckCombinationValueTooManyItems(InRange<SCMRServiceControlManagerAccessMask>(value), this, true, ReferenceType.Message,
                "SCMR", "dwDesiredAccess", "ROpenSCManagerW", "Access Mask", "[MS-SCMR]") 
            with Encoding{Decoder = PatternDecoder<SCMRServiceControlManagerAccessMask>, SourcePattern = TypeOf<DWORD>()};
        out SC_RPC_HANDLE lpScHandle with Technologies.IDL.IDL{IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "ROpenSCManagerW, ReturnValue: " + ReturnValue.ToString() +
                (lpMachineName == null || lpMachineName.Count == 0 ? "" : ", lpMachineName: " + lpMachineName) +
                (lpDatabaseName == null || lpDatabaseName.Count == 0 ? "" : ", lpDatabaseName: " + lpDatabaseName) +
                ", dwDesiredAccess: " + EnumToStringInSummary<SCMRAccessMask>(dwDesiredAccess);
        }
    }
    with Technologies.IDL.IDL{Opnum = 15};
    
    accepts operation ROpenServiceW
    {
        in SC_RPC_HANDLE hSCManager;
        in string lpServiceName with Technologies.IDL.IDL
        {
            Range = new RangePattern{Low = 0, High = SC_MAX_NAME_LENGTH},
            BaseStringType = TypeOf<wchar_t>(),
            String = true,
            IndirectionLevel = 1
        };
        in SCMRAccessMask dwDesiredAccess
            where ValidationCheckCombinationValueTooManyItems(InRange<SCMRAccessMask>(value), this, true, ReferenceType.Message,
                "SCMR", "dwDesiredAccess", "ROpenServiceW", "Access Mask", "[MS-SCMR]") 
            with Encoding{Decoder = PatternDecoder<SCMRAccessMask>, SourcePattern = TypeOf<DWORD>()};
        out SC_RPC_HANDLE lpServiceHandle
                with Technologies.IDL.IDL{IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "ROpenServiceW, ReturnValue: " + ReturnValue.ToString() + 
                ", lpServiceName: " + lpServiceName +
                ", dwDesiredAccess: " + EnumToStringInSummary<SCMRAccessMask>(dwDesiredAccess);
        }
    }
    with Technologies.IDL.IDL{Opnum = 16};
    
    accepts operation RQueryServiceConfigW
    {
        in SC_RPC_HANDLE hService;
        out QUERY_SERVICE_CONFIGW lpServiceConfig with Technologies.IDL.IDL{IndirectionLevel = 1};
        in DWORD cbBufSize with Technologies.IDL.IDL{Range = new RangePattern{Low = 0, High = 8192}};
        out BOUNDED_DWORD_8K pcbBytesNeeded with Technologies.IDL.IDL{IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RQueryServiceConfigW, ReturnValue: " + ReturnValue.ToString() +
                ", cbBufSize: " + cbBufSize.ToString() +
                ", pcbBytesNeeded: " + pcbBytesNeeded.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 17};
    
    accepts operation RQueryServiceLockStatusW
    {
        in SC_RPC_HANDLE hSCManager;
        out QUERY_SERVICE_LOCK_STATUSW lpLockStatus with Technologies.IDL.IDL{IndirectionLevel = 1};
        in DWORD cbBufSize with Technologies.IDL.IDL{Range = new RangePattern{Low = 0, High = 4096}};
        out BOUNDED_DWORD_4K pcbBytesNeeded with Technologies.IDL.IDL{IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RQueryServiceLockStatusW, ReturnValue: " + ReturnValue.ToString() +
                ", cbBufSize: " + cbBufSize.ToString() +
                ", pcbBytesNeeded: " + pcbBytesNeeded.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 18};
    
    accepts operation RStartServiceW
    {
        in SC_RPC_HANDLE hService;
        in DWORD argc with IDL{Range = new RangePattern{Low = 0, High = SC_MAX_ARGUMENTS}};
        in STRING_PTRSW argv with IDL{Size_is = [argc], PointerType = PointerKind.UniquePtr, IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RStartServiceW, ReturnValue: " + ReturnValue.ToString() +
                ", argc: " + argc.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 19};
    
    accepts operation RGetServiceDisplayNameW
    {
        in SC_RPC_HANDLE hSCManager;
        in string lpServiceName with Technologies.IDL.IDL
        {
            Range = new RangePattern{Low = 0, High = SC_MAX_NAME_LENGTH},
            BaseStringType = TypeOf<wchar_t>(),
            String = true,
            IndirectionLevel = 1
        };
        out string lpDisplayName with Technologies.IDL.IDL
        {
            Size_is = [lpcchBuffer + 1],
            Range = new RangePattern{Low = 1, High = 4097},
            BaseStringType = TypeOf<wchar_t>(),
            String = true,
            IndirectionLevel = 1
        };
        in out DWORD lpcchBuffer with Technologies.IDL.IDL{IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RGetServiceDisplayNameW, ReturnValue: " + ReturnValue.ToString() +
                ", lpServiceName: " + lpServiceName +
                ", lpDisplayName: " + lpDisplayName;
        }
    }
    with Technologies.IDL.IDL{Opnum = 20};
    
    accepts operation RGetServiceKeyNameW
    {
        in SC_RPC_HANDLE hSCManager;
        in string lpDisplayName with Technologies.IDL.IDL
        {
            Range = new RangePattern{Low = 0, High = SC_MAX_NAME_LENGTH},
            BaseStringType = TypeOf<wchar_t>(),
            String = true,
            IndirectionLevel = 1
        };
        out string lpServiceName with Technologies.IDL.IDL
        {
            Size_is = [lpcchBuffer + 1],
            Range = new RangePattern{Low = 1, High = 4097},
            BaseStringType = TypeOf<wchar_t>(),
            String = true,
            IndirectionLevel = 1
        };
        in out DWORD lpcchBuffer with Technologies.IDL.IDL{IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RGetServiceKeyNameW, ReturnValue: " + ReturnValue.ToString() +
                ", lpDisplayName: " + lpDisplayName +
                ", lpServiceName: " + lpServiceName;
        }
    }
    with Technologies.IDL.IDL{Opnum = 21};
    
    accepts operation Opnum22NotUsedOnWire
    {
        override string ToString()
        {
            return "Opnum22NotUsedOnWire";
        }
    }
    with Technologies.IDL.IDL{Opnum = 22};
    
    accepts operation RChangeServiceConfigA
    {
        in SC_RPC_HANDLE hService;
        in RChangeServiceConfigServiceType dwServiceType
            where ValidationCheckEnumValueTooManyItems(InRange<RChangeServiceConfigServiceType>(value), this, true, ReferenceType.Message,
                "SCMR", "dwServiceType", "RChangeServiceConfigA", "Service Type", "[MS-SCMR]") 
            with Encoding{Decoder = PatternDecoder<RChangeServiceConfigServiceType>, SourcePattern = TypeOf<DWORD>()};
        in RChangeServiceConfigStartType dwStartType
            where ValidationCheckEnumValueTooManyItems(InRange<RChangeServiceConfigStartType>(value), this, true, ReferenceType.Message,
                "SCMR", "dwStartType", "RChangeServiceConfigA", "Start Type", "[MS-SCMR]") 
            with Encoding{Decoder = PatternDecoder<RChangeServiceConfigStartType>, SourcePattern = TypeOf<DWORD>()};
        in RChangeServiceConfigErrorControl dwErrorControl
            where ValidationCheckEnumValueTooManyItems(InRange<RChangeServiceConfigErrorControl>(value), this, true, ReferenceType.Message,
                "SCMR", "dwErrorControl", "RChangeServiceConfigA", "Error Control", "[MS-SCMR]") 
            with Encoding{Decoder = PatternDecoder<RChangeServiceConfigErrorControl>, SourcePattern = TypeOf<DWORD>()};
        in string lpBinaryPathName with Technologies.IDL.IDL
        {
            Range = new RangePattern{Low = 0, High = SC_MAX_PATH_LENGTH},
            PointerType = PointerKind.UniquePtr,
            BaseStringType = TypeOf<char>(),
            String = true,
            IndirectionLevel = 1
        };
        in string lpLoadOrderGroup with Technologies.IDL.IDL
        {
            Range = new RangePattern{Low = 0, High = SC_MAX_NAME_LENGTH},
            PointerType = PointerKind.UniquePtr,
            BaseStringType = TypeOf<char>(),
            String = true,
            IndirectionLevel = 1
        };
        in out IDLUlong? lpdwTagId with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr, IndirectionLevel = 1};
        in array<char> lpDependencies with Technologies.IDL.IDL
        {
            Size_is = [dwDependSize],
            PointerType = PointerKind.UniquePtr,
            IndirectionLevel = 1
        };
        in DWORD dwDependSize with Technologies.IDL.IDL{Range = new RangePattern{Low = 0, High = SC_MAX_DEPEND_SIZE}};
        in string lpServiceStartName with Technologies.IDL.IDL
        {
            Range = new RangePattern{Low = 0, High = SC_MAX_ACCOUNT_NAME_LENGTH},
            PointerType = PointerKind.UniquePtr,
            BaseStringType = TypeOf<char>(),
            String = true,
            IndirectionLevel = 1
        };
        in array<char> lpPassword with Technologies.IDL.IDL{Size_is = [dwPwSize], PointerType = PointerKind.UniquePtr, IndirectionLevel = 1};
        in DWORD dwPwSize with Technologies.IDL.IDL{Range = new RangePattern{Low = 0, High = SC_MAX_PWD_SIZE}};
        in string lpDisplayName with Technologies.IDL.IDL
        {
            Range = new RangePattern{Low = 0, High = SC_MAX_NAME_LENGTH},
            PointerType = PointerKind.UniquePtr,
            BaseStringType = TypeOf<char>(),
            String = true,
            IndirectionLevel = 1
        };
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RChangeServiceConfigA, ReturnValue: " + ReturnValue.ToString() +
                ", dwServiceType: " + EnumToStringInSummary<RChangeServiceConfigServiceType>(dwServiceType) +
                ", dwStartType: " + EnumToStringInSummary<RChangeServiceConfigStartType>(dwStartType) +
                ", dwErrorControl: " + EnumToStringInSummary<RChangeServiceConfigErrorControl>(dwErrorControl) +
                ", lpBinaryPathName: " + lpBinaryPathName +
                ", lpLoadOrderGroup: " + lpLoadOrderGroup +
                ", lpdwTagId: " + (lpdwTagId == null ? "NULL" : lpdwTagId.ToString()) +
                ", lpServiceStartName: " + lpServiceStartName +
                ", lpDisplayName: " + lpDisplayName.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 23};
    
    accepts operation RCreateServiceA
    {
        in SC_RPC_HANDLE hSCManager;
        in string lpServiceName with Technologies.IDL.IDL
        {
            Range = new RangePattern{Low = 0, High = SC_MAX_NAME_LENGTH},
            BaseStringType = TypeOf<char>(),
            String = true,
            IndirectionLevel = 1
        };
        in string lpDisplayName with Technologies.IDL.IDL
        {
            Range = new RangePattern{Low = 0, High = SC_MAX_NAME_LENGTH},
            PointerType = PointerKind.UniquePtr,
            BaseStringType = TypeOf<char>(),
            String = true,
            IndirectionLevel = 1
        };
        in SCMRAccessMask dwDesiredAccess
            where ValidationCheckCombinationValueTooManyItems(InRange<SCMRAccessMask>(value), this, true, ReferenceType.Message,
                "SCMR", "dwDesiredAccess", "RCreateServiceA", "Access Mask", "[MS-SCMR]") 
            with Encoding{Decoder = PatternDecoder<SCMRAccessMask>, SourcePattern = TypeOf<DWORD>()};
        in RCreateServiceServiceType dwServiceType
            where ValidationCheckCombinationValueTooManyItems(InRange<RCreateServiceServiceType>(value), this, true, ReferenceType.Message,
                "SCMR", "dwServiceType", "RCreateServiceA", "Service Type", "[MS-SCMR]") 
            with Encoding{Decoder = PatternDecoder<RCreateServiceServiceType>, SourcePattern = TypeOf<DWORD>()};
        in RCreateServiceStartType dwStartType
            where ValidationCheckEnumValueTooManyItems(InRange<RCreateServiceStartType>(value), this, true, ReferenceType.Message,
                "SCMR", "dwStartType", "RCreateServiceA", "Start Type", "[MS-SCMR]") 
            with Encoding{Decoder = PatternDecoder<RCreateServiceStartType>, SourcePattern = TypeOf<DWORD>()};
        in RCreateServiceErrorControl dwErrorControl
            where ValidationCheckEnumValueTooManyItems(InRange<RCreateServiceErrorControl>(value), this, true, ReferenceType.Message,
                "SCMR", "dwErrorControl", "RCreateServiceA", "Error Control", "[MS-SCMR]") 
            with Encoding{Decoder = PatternDecoder<RCreateServiceErrorControl>, SourcePattern = TypeOf<DWORD>()};
        in string lpBinaryPathName with Technologies.IDL.IDL
        {
            Range = new RangePattern{Low = 0, High = SC_MAX_PATH_LENGTH},
            BaseStringType = TypeOf<char>(),
            String = true,
            IndirectionLevel = 1
        };
        in string lpLoadOrderGroup with Technologies.IDL.IDL
        {
            Range = new RangePattern{Low = 0, High = SC_MAX_NAME_LENGTH},
            PointerType = PointerKind.UniquePtr,
            BaseStringType = TypeOf<char>(),
            String = true,
            IndirectionLevel = 1
        };
        in out IDLUlong? lpdwTagId with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr, IndirectionLevel = 1};
        in array<char> lpDependencies with IDL{Size_is = [dwDependSize], PointerType = PointerKind.UniquePtr, IndirectionLevel = 1};
        in DWORD dwDependSize with Technologies.IDL.IDL{Range = new RangePattern{Low = 0, High = SC_MAX_DEPEND_SIZE}};
        in string lpServiceStartName with Technologies.IDL.IDL
        {
            Range = new RangePattern{Low = 0, High = SC_MAX_ACCOUNT_NAME_LENGTH},
            PointerType = PointerKind.UniquePtr,
            BaseStringType = TypeOf<char>(),
            String = true,
            IndirectionLevel = 1
        };
        in array<char> lpPassword with IDL{Size_is = [dwPwSize], PointerType = PointerKind.UniquePtr, IndirectionLevel = 1};
        in DWORD dwPwSize with IDL{Range = new RangePattern{Low = 0, High = SC_MAX_PWD_SIZE}};
        out SC_RPC_HANDLE lpServiceHandle with IDL{IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RCreateServiceA, ReturnValue: " + ReturnValue.ToString() +
                ", lpServiceName: " + lpServiceName +
                ", lpDisplayName: " + lpDisplayName +
                ", dwDesiredAccess: " + EnumToStringInSummary<SCMRAccessMask>(dwDesiredAccess) +
                ", dwServiceType: " + EnumToStringInSummary<RCreateServiceServiceType>(dwServiceType) +
                ", dwStartType: " + EnumToStringInSummary<RCreateServiceStartType>(dwStartType) +
                ", dwErrorControl: " + EnumToStringInSummary<RCreateServiceErrorControl>(dwErrorControl) +
                ", lpBinaryPathName: " + lpBinaryPathName +
                ", lpLoadOrderGroup: " + lpLoadOrderGroup +
                ", lpdwTagId: " + (lpdwTagId == null ? "NULL" : lpdwTagId.ToString()) + 
                ", dwDependSize: " + dwDependSize.ToString() +
                ", lpServiceStartName: " + lpServiceStartName.ToString() +
                ", dwPwSize: " + dwPwSize.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 24};
    
    accepts operation REnumDependentServicesA
    {
        in SC_RPC_HANDLE hService;
        in REnumServicesServiceState dwServiceState
            where ValidationCheckEnumValueTooManyItems(InRange<REnumServicesServiceState>(value), this, true, ReferenceType.Message,
                "SCMR", "dwServiceState", "REnumDependentServicesW", "Service State", "[MS-SCMR]") 
            with Encoding{Decoder = PatternDecoder<REnumServicesServiceState>, SourcePattern = TypeOf<DWORD>()};
        out array<ENUM_SERVICE_STATUS> lpServices with Technologies.IDL.IDL{Size_is = [cbBufSize], IndirectionLevel = 1},
            Encoding{Decoder = (x) => EnumServiceStatusArrayDecoder(x, false), SourcePattern = TypeOf<array<byte>>()};
        in DWORD cbBufSize with Technologies.IDL.IDL{Range = new RangePattern{Low = 0, High = 262144}};
        out BOUNDED_DWORD_256K pcbBytesNeeded with Technologies.IDL.IDL{IndirectionLevel = 1};
        out BOUNDED_DWORD_256K lpServicesReturned
            where ValidationCheck(value == lpServices.Count, this, () => Format(SCMR_LPBUFFER_INVALID_DATA, "lpServices"))
            with Technologies.IDL.IDL{IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "REnumDependentServicesA, ReturnValue: " + ReturnValue.ToString() +
                ", dwServiceState: " + EnumToStringInSummary<REnumServicesServiceState>(dwServiceState);
        }
    }
    with Technologies.IDL.IDL{Opnum = 25};
    
    accepts operation REnumServicesStatusA
    {
        in SC_RPC_HANDLE hSCManager;
        in REnumServicesServiceType dwServiceType
            where ValidationCheckCombinationValueTooManyItems(InRange<REnumServicesServiceType>(value), this, true, ReferenceType.Message,
                "SCMR", "dwServiceType", "REnumServicesStatusA", "Service Type", "[MS-SCMR]") 
            with Encoding{Decoder = PatternDecoder<REnumServicesServiceType>, SourcePattern = TypeOf<DWORD>()};
        in REnumServicesServiceState dwServiceState
            where ValidationCheckEnumValueTooManyItems(InRange<REnumServicesServiceState>(value), this, true, ReferenceType.Message,
                "SCMR", "dwServiceState", "REnumServicesStatusA", "Service State", "[MS-SCMR]") 
            with Encoding{Decoder = PatternDecoder<REnumServicesServiceState>, SourcePattern = TypeOf<DWORD>()};
        out array<ENUM_SERVICE_STATUS> lpBuffer with IDL{Size_is = [cbBufSize], IndirectionLevel = 1},
            Encoding{Decoder = (x) => EnumServiceStatusArrayDecoder(x, false), SourcePattern = TypeOf<array<byte>>()};
        in DWORD cbBufSize with Technologies.IDL.IDL{Range = new RangePattern{Low = 0, High = 262144}};
        out BOUNDED_DWORD_256K pcbBytesNeeded with Technologies.IDL.IDL{IndirectionLevel = 1};
        out BOUNDED_DWORD_256K lpServicesReturned
            where ValidationCheck(value == lpBuffer.Count, this, () => Format(SCMR_LPBUFFER_INVALID_DATA, "lpBuffer"))
            with Technologies.IDL.IDL{IndirectionLevel = 1};
        in out BOUNDED_DWORD_256K lpResumeIndex with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr, IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "REnumServicesStatusA, ReturnValue: " + ReturnValue.ToString() +
                ", dwServiceType: " + EnumToStringInSummary<REnumServicesServiceType>(dwServiceType) +
                ", dwServiceState: " + EnumToStringInSummary<REnumServicesServiceState>(dwServiceState);
        }
    }
    with Technologies.IDL.IDL{Opnum = 26};
    
    accepts operation ROpenSCManagerA
    {
        in string lpMachineName with Technologies.IDL.IDL
        {
            Range = new RangePattern{Low = 0, High = SC_MAX_COMPUTER_NAME_LENGTH},
            PointerType = PointerKind.UniquePtr,
            BaseStringType = TypeOf<SVCCTL_HANDLEA>(),
            String = true
        };
        in string lpDatabaseName with Technologies.IDL.IDL
        {
            Range = new RangePattern{Low = 0, High = SC_MAX_NAME_LENGTH},
            PointerType = PointerKind.UniquePtr,
            BaseStringType = TypeOf<char>(),
            String = true,
            IndirectionLevel = 1
        };
        in SCMRServiceControlManagerAccessMask dwDesiredAccess
            where ValidationCheckCombinationValueTooManyItems(InRange<SCMRServiceControlManagerAccessMask>(value), this, true, ReferenceType.Message,
                "SCMR", "dwDesiredAccess", "ROpenSCManagerA", "Access Mask", "[MS-SCMR]") 
            with Encoding{Decoder = PatternDecoder<SCMRServiceControlManagerAccessMask>, SourcePattern = TypeOf<DWORD>()};
        out SC_RPC_HANDLE lpScHandle with Technologies.IDL.IDL{IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "ROpenSCManagerA" + ", ReturnValue: " + ReturnValue.ToString() +
                (lpMachineName == null || lpMachineName.Count == 0 ? "" : ", lpMachineName: " + lpMachineName) +
                (lpDatabaseName == null || lpDatabaseName.Count == 0 ? "" : ", lpDatabaseName: " + lpDatabaseName) +
                ", dwDesiredAccess: " + EnumToStringInSummary<SCMRAccessMask>(dwDesiredAccess);
        }
    }
    with Technologies.IDL.IDL{Opnum = 27};
    
    accepts operation ROpenServiceA
    {
        in SC_RPC_HANDLE hSCManager;
        in string lpServiceName with Technologies.IDL.IDL
        {
            Range = new RangePattern{Low = 0, High = SC_MAX_NAME_LENGTH},
            BaseStringType = TypeOf<char>(),
            String = true,
            IndirectionLevel = 1
        };
        in SCMRAccessMask dwDesiredAccess
            where ValidationCheckCombinationValueTooManyItems(InRange<SCMRAccessMask>(value), this, true, ReferenceType.Message,
                "SCMR", "dwDesiredAccess", "ROpenServiceA", "Access Mask", "[MS-SCMR]") 
            with Encoding{Decoder = PatternDecoder<SCMRAccessMask>, SourcePattern = TypeOf<DWORD>()};
        out SC_RPC_HANDLE lpServiceHandle with Technologies.IDL.IDL{IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "ROpenServiceW, ReturnValue: " + ReturnValue.ToString() + 
                ", lpServiceName: " + lpServiceName +
                ", dwDesiredAccess: " + EnumToStringInSummary<SCMRAccessMask>(dwDesiredAccess);
        }
    }
    with Technologies.IDL.IDL{Opnum = 28};
    
    accepts operation RQueryServiceConfigA
    {
        in SC_RPC_HANDLE hService;
        out QUERY_SERVICE_CONFIGA lpServiceConfig with Technologies.IDL.IDL{IndirectionLevel = 1};
        in DWORD cbBufSize with Technologies.IDL.IDL{Range = new RangePattern{Low = 0, High = 8192}};
        out BOUNDED_DWORD_8K pcbBytesNeeded with Technologies.IDL.IDL{IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RQueryServiceConfigA, ReturnValue: " + ReturnValue.ToString() +
                ", cbBufSize: " + cbBufSize.ToString() +
                ", pcbBytesNeeded: " + pcbBytesNeeded.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 29};
    
    accepts operation RQueryServiceLockStatusA
    {
        in SC_RPC_HANDLE hSCManager;
        out QUERY_SERVICE_LOCK_STATUSA lpLockStatus with Technologies.IDL.IDL{IndirectionLevel = 1};
        in DWORD cbBufSize with Technologies.IDL.IDL{Range = new RangePattern{Low = 0, High = 4096}};
        out BOUNDED_DWORD_4K pcbBytesNeeded with Technologies.IDL.IDL{IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RQueryServiceLockStatusA, ReturnValue: " + ReturnValue.ToString() +
                ", cbBufSize: " + cbBufSize.ToString() +
                ", pcbBytesNeeded: " + pcbBytesNeeded.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 30};
    
    accepts operation RStartServiceA
    {
        in SC_RPC_HANDLE hService;
        in DWORD argc with Technologies.IDL.IDL{Range = new RangePattern{Low = 0, High = SC_MAX_ARGUMENTS}};
        in STRING_PTRSA argv with Technologies.IDL.IDL{Size_is = [argc], PointerType = PointerKind.UniquePtr, IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RStartServiceA, ReturnValue: " + ReturnValue.ToString() +
                ", argc: " + argc.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 31};
    
    accepts operation RGetServiceDisplayNameA
    {
        in SC_RPC_HANDLE hSCManager;
        in string lpServiceName with Technologies.IDL.IDL
        {
            Range = new RangePattern{Low = 0, High = SC_MAX_NAME_LENGTH},
            BaseStringType = TypeOf<char>(),
            String = true,
            IndirectionLevel = 1
        };
        out string lpDisplayName with Technologies.IDL.IDL
        {
            Size_is = [lpcchBuffer],
            BaseStringType = TypeOf<char>(),
            String = true,
            IndirectionLevel = 1
        };
        in out BOUNDED_DWORD_4K lpcchBuffer with Technologies.IDL.IDL{IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RGetServiceDisplayNameA, ReturnValue: " + ReturnValue.ToString() +
                ", lpServiceName: " + lpServiceName +
                ", lpDisplayName: " + lpDisplayName.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 32};
    
    accepts operation RGetServiceKeyNameA
    {
        in SC_RPC_HANDLE hSCManager;
        in string lpDisplayName with Technologies.IDL.IDL
        {
            Range = new RangePattern{Low = 0, High = SC_MAX_NAME_LENGTH},
            BaseStringType = TypeOf<char>(),
            String = true,
            IndirectionLevel = 1
        };
        out string lpKeyName with Technologies.IDL.IDL
        {
            Size_is = [lpcchBuffer],
            BaseStringType = TypeOf<char>(),
            String = true,
            IndirectionLevel = 1
        };
        in out BOUNDED_DWORD_4K lpcchBuffer with Technologies.IDL.IDL{IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RGetServiceKeyNameA, ReturnValue: " + ReturnValue.ToString() +
                ", lpDisplayName: " + lpDisplayName +
                ", lpKeyName: " + lpKeyName;
        }
    }
    with Technologies.IDL.IDL{Opnum = 33};
    
    accepts operation Opnum34NotUsedOnWire
    {
        override string ToString()
        {
            return "Opnum34NotUsedOnWire";
        }
    }
    with Technologies.IDL.IDL{Opnum = 34};
    
    accepts operation REnumServiceGroupW
    {
        in SC_RPC_HANDLE hSCManager;
        in REnumServiceGroupServiceType dwServiceType
            where ValidationCheckCombinationValueTooManyItems(InRange<REnumServiceGroupServiceType>(value), this, true, ReferenceType.Message,
                "SCMR", "dwServiceType", "REnumServiceGroupW", "Service Type", "[MS-SCMR]") 
            with Encoding{Decoder = PatternDecoder<REnumServiceGroupServiceType>, SourcePattern = TypeOf<DWORD>()};
        in REnumServiceGroupServiceState dwServiceState
            where ValidationCheckEnumValueTooManyItems(InRange<REnumServiceGroupServiceState>(value), this, true, ReferenceType.Message,
                "SCMR", "dwServiceState", "REnumServiceGroupW", "Service State", "[MS-SCMR]") 
            with Encoding{Decoder = PatternDecoder<REnumServiceGroupServiceState>, SourcePattern = TypeOf<DWORD>()};
        out array<ENUM_SERVICE_STATUS> lpBuffer with Technologies.IDL.IDL{Size_is = [cbBufSize], IndirectionLevel = 1},
            Encoding{Decoder = (x) => EnumServiceStatusArrayDecoder(x, true), SourceConverter = ConvertArrayCharToBinary, SourcePattern = TypeOf<array<char>>()};
        in DWORD cbBufSize with Technologies.IDL.IDL{Range = new RangePattern{Low = 0, High = 262144}};
        out BOUNDED_DWORD_256K pcbBytesNeeded with Technologies.IDL.IDL{IndirectionLevel = 1};
        out BOUNDED_DWORD_256K lpServicesReturned
            where ValidationCheck(value == lpBuffer.Count, this, () => Format(SCMR_LPBUFFER_INVALID_DATA, "lpBuffer"))
            with Technologies.IDL.IDL{IndirectionLevel = 1};
        in out BOUNDED_DWORD_256K lpResumeIndex with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr, IndirectionLevel = 1};
        in string pszGroupName with Technologies.IDL.IDL
        {
            Range = new RangePattern{Low = 0, High = SC_MAX_NAME_LENGTH},
            PointerType = PointerKind.UniquePtr,
            BaseStringType = TypeOf<wchar_t>(),
            String = true,
            IndirectionLevel = 1
        };
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "REnumServiceGroupW, ReturnValue: " + ReturnValue.ToString() +
                ", dwServiceType: " + EnumToStringInSummary<REnumServiceGroupServiceType>(dwServiceType) +
                ", dwServiceState: " + EnumToStringInSummary<REnumServiceGroupServiceState>(dwServiceState) +
                ", pszGroupName: " + pszGroupName;
        }
    }
    with Technologies.IDL.IDL{Opnum = 35};
    
    accepts operation RChangeServiceConfig2A
    {
        in SC_RPC_HANDLE hService;
        in SC_RPC_CONFIG_INFOA Info with Technologies.IDL.IDL{IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RChangeServiceConfig2A, ReturnValue: " + ReturnValue.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 36};
    
    accepts operation RChangeServiceConfig2W
    {
        in SC_RPC_HANDLE hService;
        in SC_RPC_CONFIG_INFOW Info with Technologies.IDL.IDL{IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RChangeServiceConfig2W, ReturnValue: " + ReturnValue.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 37};
    
    accepts operation RQueryServiceConfig2A
    {
        in SC_RPC_HANDLE hService;
        in RQueryServiceConfig2InfoLevel dwInfoLevel
            where ValidationCheckEnumValueTooManyItems(InRange<RQueryServiceConfig2InfoLevel>(value), this, true, ReferenceType.Message,
                "SCMR", "dwInfoLevel", "RQueryServiceConfig2A", "Service Info Level", "[MS-SCMR]") 
            with Encoding{Decoder = PatternDecoder<RQueryServiceConfig2InfoLevel>, SourcePattern = TypeOf<DWORD>()};
        out QueryServiceConfigBuffer lpBuffer with Technologies.IDL.IDL{Size_is = [cbBufSize], IndirectionLevel = 1},
            Encoding{Decoder = (x) => QueryServiceConfigBufferDecoder(
                pcbBytesNeeded,
                dwInfoLevel,
                x,
                false), SourceConverter = ConvertArrayCharToBinary, SourcePattern = TypeOf<array<char>>()};
        in DWORD cbBufSize with Technologies.IDL.IDL{Range = new RangePattern{Low = 0, High = 8192}};
        out BOUNDED_DWORD_8K pcbBytesNeeded with Technologies.IDL.IDL{IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RQueryServiceConfig2A, ReturnValue: " + ReturnValue.ToString() +
                ", dwInfoLevel: " + EnumToStringInSummary<RQueryServiceConfig2InfoLevel>(dwInfoLevel);
        }
    }
    with Technologies.IDL.IDL{Opnum = 38};
    
    accepts operation RQueryServiceConfig2W
    {
        in SC_RPC_HANDLE hService;
        in RQueryServiceConfig2InfoLevel dwInfoLevel
            where ValidationCheckEnumValueTooManyItems(InRange<RQueryServiceConfig2InfoLevel>(value), this, true, ReferenceType.Message,
                "SCMR", "dwInfoLevel", "RQueryServiceConfig2W", "Service Info", "[MS-SCMR]") 
            with Encoding{Decoder = PatternDecoder<RQueryServiceConfig2InfoLevel>, SourcePattern = TypeOf<DWORD>()};
        out QueryServiceConfigBuffer lpBuffer with Technologies.IDL.IDL{Size_is = [cbBufSize], IndirectionLevel = 1},
            Encoding{Decoder = (x) => QueryServiceConfigBufferDecoder(
                pcbBytesNeeded,
                dwInfoLevel,
                x,
                true), SourceConverter = ConvertArrayCharToBinary, SourcePattern = TypeOf<array<char>>()};
        in DWORD cbBufSize with Technologies.IDL.IDL{Range = new RangePattern{Low = 0, High = 8192}};
        out BOUNDED_DWORD_8K pcbBytesNeeded with Technologies.IDL.IDL{IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RQueryServiceConfig2W, ReturnValue: " + ReturnValue.ToString() +
                ", dwInfoLevel: " + EnumToStringInSummary<RQueryServiceConfig2InfoLevel>(dwInfoLevel);
        }
    }
    with Technologies.IDL.IDL{Opnum = 39};
    
    accepts operation RQueryServiceStatusEx
    {
        in SC_RPC_HANDLE hService;
        in SC_STATUS_TYPE InfoLevel where ValidationCheckEnumValue(InRange<SC_STATUS_TYPE>(value), this, true, ReferenceType.Message,
            "SCMR", "InfoLevel", "RQueryServiceStatusEx", INFRASTRUCTURE_STR_ZERO, value);
        out (SERVICE_STATUS_PROCESS | binary) lpBuffer with Technologies.IDL.IDL{Size_is = [cbBufSize], IndirectionLevel = 1},
            Encoding{Decoder = (x) => RQueryServiceStatusExBufferDecoder(pcbBytesNeeded, x), SourceConverter = ConvertArrayCharToBinary, SourcePattern = TypeOf<array<char>>()};
        in DWORD cbBufSize with Technologies.IDL.IDL{Range = new RangePattern{Low = 0, High = 8192}};
        out BOUNDED_DWORD_8K pcbBytesNeeded with Technologies.IDL.IDL{IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RQueryServiceStatusEx, ReturnValue: " + ReturnValue.ToString() +
                ", InfoLevel: " + EnumToStringInSummary<SC_STATUS_TYPE>(InfoLevel);
        }
    }
    with Technologies.IDL.IDL{Opnum = 40};
    
    accepts operation REnumServicesStatusExA
    {
        in SC_RPC_HANDLE hSCManager;
        in SC_ENUM_TYPE InfoLevel
            where ValidationCheckEnumValue(InRange<SC_ENUM_TYPE>(value), this, true, ReferenceType.Message,
                "SCMR", "InfoLevel", "REnumServicesStatusExA", INFRASTRUCTURE_STR_ZERO, value);
        in REnumServicesServiceType dwServiceType
            where ValidationCheckCombinationValueTooManyItems(InRange<REnumServicesServiceType>(value), this, true, ReferenceType.Message,
                "SCMR", "dwServiceType", "REnumServicesStatusExA", "Service Type", "[MS-SCMR]") 
            with Encoding{Decoder = PatternDecoder<REnumServicesServiceType>, SourcePattern = TypeOf<DWORD>()};
        in REnumServicesServiceState dwServiceState
            where ValidationCheckEnumValueTooManyItems(InRange<REnumServicesServiceState>(value), this, true, ReferenceType.Message,
                "SCMR", "dwServiceState", "REnumServicesStatusExA", "Service State", "[MS-SCMR]") 
            with Encoding{Decoder = PatternDecoder<REnumServicesServiceState>, SourcePattern = TypeOf<DWORD>()};
        out array<ENUM_SERVICE_STATUS_PROCESS> lpBuffer with Technologies.IDL.IDL{Size_is = [cbBufSize], IndirectionLevel = 1},
            Encoding{Decoder = (x) => EnumServiceStatusProcessArrayDecoder(x, false), SourceConverter = ConvertArrayCharToBinary, SourcePattern = TypeOf<array<char>>()};
        in DWORD cbBufSize with Technologies.IDL.IDL{Range = new RangePattern{Low = 0, High = 262144}};
        out BOUNDED_DWORD_256K pcbBytesNeeded with Technologies.IDL.IDL{IndirectionLevel = 1};
        out BOUNDED_DWORD_256K lpServicesReturned
            where ValidationCheck(value == lpBuffer.Count, this, () => Format(SCMR_LPBUFFER_INVALID_DATA, "lpBuffer"))
            with Technologies.IDL.IDL{IndirectionLevel = 1};
        in out BOUNDED_DWORD_256K lpResumeIndex with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr, IndirectionLevel = 1};
        in string pszGroupName with Technologies.IDL.IDL
        {
            Range = new RangePattern{Low = 0, High = SC_MAX_NAME_LENGTH},
            PointerType = PointerKind.UniquePtr,
            BaseStringType = TypeOf<char>(),
            String = true,
            IndirectionLevel = 1
        };
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "REnumServicesStatusExA, ReturnValue: " + ReturnValue.ToString() +
                ", InfoLevel: " + EnumToStringInSummary<SC_ENUM_TYPE>(InfoLevel) +
                ", dwServiceType: " + EnumToStringInSummary<REnumServicesServiceType>(dwServiceType) +
                ", dwServiceState: " + EnumToStringInSummary<REnumServicesServiceState>(dwServiceState) +
                ", lpBuffer: " + lpBuffer.ToString() + ", cbBufSize: " +
                ", lpResumeIndex: " + lpResumeIndex.ToString() +
                ", pszGroupName: " + pszGroupName;
        }
    }
    with Technologies.IDL.IDL{Opnum = 41};
    
    accepts operation REnumServicesStatusExW
    {
        in SC_RPC_HANDLE hSCManager;
        in SC_ENUM_TYPE InfoLevel
            where ValidationCheckEnumValue(InRange<SC_ENUM_TYPE>(value), this, true, ReferenceType.Message,
                "SCMR", "InfoLevel", "REnumServicesStatusExW", INFRASTRUCTURE_STR_ZERO, value);
        in REnumServicesServiceType dwServiceType
            where ValidationCheckCombinationValueTooManyItems(InRange<REnumServicesServiceType>(value), this, true, ReferenceType.Message,
                "SCMR", "dwServiceType", "REnumServicesStatusExA", "Service Type", "[MS-SCMR]") 
            with Encoding{Decoder = PatternDecoder<REnumServicesServiceType>, SourcePattern = TypeOf<DWORD>()};
        in REnumServicesServiceState dwServiceState
            where ValidationCheckEnumValueTooManyItems(InRange<REnumServicesServiceState>(value), this, true, ReferenceType.Message,
                "SCMR", "dwServiceState", "REnumServicesStatusExA", "Service State", "[MS-SCMR]") 
            with Encoding{Decoder = PatternDecoder<REnumServicesServiceState>, SourcePattern = TypeOf<DWORD>()};
        out array<ENUM_SERVICE_STATUS_PROCESS> lpBuffer with Technologies.IDL.IDL{Size_is = [cbBufSize], IndirectionLevel = 1},
            Encoding{Decoder = (x) => EnumServiceStatusProcessArrayDecoder(x, true), SourceConverter = ConvertArrayCharToBinary, SourcePattern = TypeOf<array<char>>()};
        in DWORD cbBufSize with Technologies.IDL.IDL{Range = new RangePattern{Low = 0, High = 262144}};
        out BOUNDED_DWORD_256K pcbBytesNeeded with Technologies.IDL.IDL{IndirectionLevel = 1};
        out BOUNDED_DWORD_256K lpServicesReturned
            where ValidationCheck(value == lpBuffer.Count, this, () => Format(SCMR_LPBUFFER_INVALID_DATA, "lpBuffer"))
            with Technologies.IDL.IDL{IndirectionLevel = 1};
        in out BOUNDED_DWORD_256K lpResumeIndex with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr, IndirectionLevel = 1};
        in string pszGroupName with Technologies.IDL.IDL
        {
            Range = new RangePattern{Low = 0, High = SC_MAX_NAME_LENGTH},
            PointerType = PointerKind.UniquePtr,
            BaseStringType = TypeOf<wchar_t>(),
            String = true,
            IndirectionLevel = 1
        };
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "REnumServicesStatusExW, ReturnValue: " + ReturnValue.ToString() +
                ", InfoLevel: " + EnumToStringInSummary<SC_ENUM_TYPE>(InfoLevel) +
                ", dwServiceType: " + EnumToStringInSummary<REnumServicesServiceType>(dwServiceType) +
                ", dwServiceState: " + EnumToStringInSummary<REnumServicesServiceState>(dwServiceState) +
                ", lpBuffer: " + lpBuffer.ToString() + ", cbBufSize: " +
                ", lpResumeIndex: " + lpResumeIndex.ToString() +
                ", pszGroupName: " + pszGroupName;
        }
    }
    with Technologies.IDL.IDL{Opnum = 42};
    
    accepts operation Opnum43NotUsedOnWire
    {
        override string ToString()
        {
            return "Opnum43NotUsedOnWire";
        }
    }
    with Technologies.IDL.IDL{Opnum = 43};
    
    accepts operation RCreateServiceWOW64A
    {
        in SC_RPC_HANDLE hSCManager;
        in string lpServiceName with Technologies.IDL.IDL
        {
            Range = new RangePattern{Low = 0, High = SC_MAX_NAME_LENGTH},
            BaseStringType = TypeOf<char>(),
            String = true,
            IndirectionLevel = 1
        };
        in string lpDisplayName with Technologies.IDL.IDL
        {
            Range = new RangePattern{Low = 0, High = SC_MAX_NAME_LENGTH},
            PointerType = PointerKind.UniquePtr,
            BaseStringType = TypeOf<char>(),
            String = true,
            IndirectionLevel = 1
        };
        in SCMRAccessMask dwDesiredAccess
            where ValidationCheckCombinationValueTooManyItems(InRange<SCMRAccessMask>(value), this, true, ReferenceType.Message,
                "SCMR", "dwDesiredAccess", "RCreateServiceWOW64A", "Access Mask", "[MS-SCMR]") 
            with Encoding{Decoder = PatternDecoder<SCMRAccessMask>, SourcePattern = TypeOf<DWORD>()};
        in RCreateServiceServiceType dwServiceType
            where ValidationCheckEnumValueTooManyItems(InRange<RCreateServiceServiceType>(value), this, true, ReferenceType.Message,
                "SCMR", "dwServiceType", "RCreateServiceWOW64A", "Service Type", "[MS-SCMR]") 
            with Encoding{Decoder = PatternDecoder<RCreateServiceServiceType>, SourcePattern = TypeOf<DWORD>()};
        in RCreateServiceStartType dwStartType
            where ValidationCheckEnumValueTooManyItems(InRange<RCreateServiceStartType>(value), this, true, ReferenceType.Message,
                "SCMR", "dwStartType", "RCreateServiceWOW64A", "Start Type", "[MS-SCMR]") 
            with Encoding{Decoder = PatternDecoder<RCreateServiceStartType>, SourcePattern = TypeOf<DWORD>()};
        in RCreateServiceErrorControl dwErrorControl
            where ValidationCheckEnumValueTooManyItems(InRange<RCreateServiceErrorControl>(value), this, true, ReferenceType.Message,
                "SCMR", "dwErrorControl", "RCreateServiceWOW64A", "Error Control", "[MS-SCMR]") 
            with Encoding{Decoder = PatternDecoder<RCreateServiceErrorControl>, SourcePattern = TypeOf<DWORD>()};
        in string lpBinaryPathName with Technologies.IDL.IDL
        {
            Range = new RangePattern{Low = 0, High = SC_MAX_PATH_LENGTH},
            BaseStringType = TypeOf<char>(),
            String = true,
            IndirectionLevel = 1
        };
        in string lpLoadOrderGroup with Technologies.IDL.IDL
        {
            Range = new RangePattern{Low = 0, High = SC_MAX_NAME_LENGTH},
            PointerType = PointerKind.UniquePtr,
            BaseStringType = TypeOf<char>(),
            String = true,
            IndirectionLevel = 1
        };
        in out IDLUlong? lpdwTagId with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr, IndirectionLevel = 1};
        in array<char> lpDependencies with Technologies.IDL.IDL{Size_is = [dwDependSize], PointerType = PointerKind.UniquePtr, IndirectionLevel = 1};
        in DWORD dwDependSize with Technologies.IDL.IDL{Range = new RangePattern{Low = 0, High = SC_MAX_DEPEND_SIZE}};
        in string lpServiceStartName with Technologies.IDL.IDL
        {
            Range = new RangePattern{Low = 0, High = SC_MAX_ACCOUNT_NAME_LENGTH},
            PointerType = PointerKind.UniquePtr,
            BaseStringType = TypeOf<char>(),
            String = true,
            IndirectionLevel = 1
        };
        in array<char> lpPassword with Technologies.IDL.IDL{Size_is = [dwPwSize], PointerType = PointerKind.UniquePtr, IndirectionLevel = 1};
        in DWORD dwPwSize with Technologies.IDL.IDL{Range = new RangePattern{Low = 0, High = SC_MAX_PWD_SIZE}};
        out SC_RPC_HANDLE lpServiceHandle with Technologies.IDL.IDL{IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RCreateServiceWOW64A, ReturnValue: " + ReturnValue.ToString() +
                ", lpServiceName: " + lpServiceName +
                ", lpDisplayName: " + lpDisplayName +
                ", dwDesiredAccess: " + EnumToStringInSummary<SCMRAccessMask>(dwDesiredAccess) +
                ", dwServiceType: " + EnumToStringInSummary<RCreateServiceServiceType>(dwServiceType) +
                ", dwStartType: " + EnumToStringInSummary<RCreateServiceStartType>(dwStartType) +
                ", dwErrorControl: " + EnumToStringInSummary<RCreateServiceErrorControl>(dwErrorControl) +
                ", lpBinaryPathName: " + lpBinaryPathName +
                ", lpLoadOrderGroup: " + lpLoadOrderGroup +
                ", lpdwTagId: " + (lpdwTagId == null ? "NULL" : lpdwTagId.ToString()) + 
                ", dwDependSize: " + dwDependSize.ToString() +
                ", lpServiceStartName: " + lpServiceStartName.ToString() +
                ", dwPwSize: " + dwPwSize.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 44};
    
    accepts operation RCreateServiceWOW64W
    {
        in SC_RPC_HANDLE hSCManager;
        in string lpServiceName with Technologies.IDL.IDL
        {
            Range = new RangePattern{Low = 0, High = SC_MAX_NAME_LENGTH},
            BaseStringType = TypeOf<wchar_t>(),
            String = true,
            IndirectionLevel = 1
        };
        in string lpDisplayName with Technologies.IDL.IDL
        {
            Range = new RangePattern{Low = 0, High = SC_MAX_NAME_LENGTH},
            PointerType = PointerKind.UniquePtr,
            BaseStringType = TypeOf<wchar_t>(),
            String = true,
            IndirectionLevel = 1
        };
        in SCMRAccessMask dwDesiredAccess
            where ValidationCheckCombinationValueTooManyItems(InRange<SCMRAccessMask>(value), this, true, ReferenceType.Message,
                "SCMR", "dwDesiredAccess", "RCreateServiceWOW64W", "Access Mask", "[MS-SCMR]") 
            with Encoding{Decoder = PatternDecoder<SCMRAccessMask>, SourcePattern = TypeOf<DWORD>()};
        in RCreateServiceServiceType dwServiceType
            where ValidationCheckCombinationValueTooManyItems(InRange<RCreateServiceServiceType>(value), this, true, ReferenceType.Message,
                "SCMR", "dwServiceType", "RCreateServiceWOW64W", "Service Type", "[MS-SCMR]") 
            with Encoding{Decoder = PatternDecoder<RCreateServiceServiceType>, SourcePattern = TypeOf<DWORD>()};
        in RCreateServiceStartType dwStartType
            where ValidationCheckEnumValueTooManyItems(InRange<RCreateServiceStartType>(value), this, true, ReferenceType.Message,
                "SCMR", "dwStartType", "RCreateServiceWOW64W", "Start Type", "[MS-SCMR]") 
            with Encoding{Decoder = PatternDecoder<RCreateServiceStartType>, SourcePattern = TypeOf<DWORD>()};
        in RCreateServiceErrorControl dwErrorControl
            where ValidationCheckEnumValueTooManyItems(InRange<RCreateServiceErrorControl>(value), this, true, ReferenceType.Message,
                "SCMR", "dwErrorControl", "RCreateServiceWOW64W", "Error Control", "[MS-SCMR]") 
            with Encoding{Decoder = PatternDecoder<RCreateServiceErrorControl>, SourcePattern = TypeOf<DWORD>()};
        in string lpBinaryPathName with Technologies.IDL.IDL
        {
            Range = new RangePattern{Low = 0, High = SC_MAX_PATH_LENGTH},
            BaseStringType = TypeOf<wchar_t>(),
            String = true,
            IndirectionLevel = 1
        };
        in string lpLoadOrderGroup with Technologies.IDL.IDL
        {
            Range = new RangePattern{Low = 0, High = SC_MAX_NAME_LENGTH},
            PointerType = PointerKind.UniquePtr,
            BaseStringType = TypeOf<wchar_t>(),
            String = true,
            IndirectionLevel = 1
        };
        in out IDLUlong? lpdwTagId with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr, IndirectionLevel = 1};
        in array<char> lpDependencies with Technologies.IDL.IDL{Size_is = [dwDependSize], PointerType = PointerKind.UniquePtr, IndirectionLevel = 1};
        in DWORD dwDependSize with Technologies.IDL.IDL{Range = new RangePattern{Low = 0, High = SC_MAX_DEPEND_SIZE}};
        in string lpServiceStartName with Technologies.IDL.IDL
        {
            Range = new RangePattern{Low = 0, High = SC_MAX_ACCOUNT_NAME_LENGTH},
            PointerType = PointerKind.UniquePtr,
            BaseStringType = TypeOf<wchar_t>(),
            String = true,
            IndirectionLevel = 1
        };
        in array<char> lpPassword with Technologies.IDL.IDL{Size_is = [dwPwSize], PointerType = PointerKind.UniquePtr, IndirectionLevel = 1};
        in DWORD dwPwSize with Technologies.IDL.IDL{Range = new RangePattern{Low = 0, High = SC_MAX_PWD_SIZE}};
        out SC_RPC_HANDLE lpServiceHandle with Technologies.IDL.IDL{IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RCreateServiceWOW64W, ReturnValue: " + ReturnValue.ToString() +
                ", lpServiceName: " + lpServiceName +
                ", lpDisplayName: " + lpDisplayName +
                ", dwDesiredAccess: " + EnumToStringInSummary<SCMRAccessMask>(dwDesiredAccess) +
                ", dwServiceType: " + EnumToStringInSummary<RCreateServiceServiceType>(dwServiceType) +
                ", dwStartType: " + EnumToStringInSummary<RCreateServiceStartType>(dwStartType) +
                ", dwErrorControl: " + EnumToStringInSummary<RCreateServiceErrorControl>(dwErrorControl) +
                ", lpBinaryPathName: " + lpBinaryPathName +
                ", lpLoadOrderGroup: " + lpLoadOrderGroup +
                ", lpdwTagId: " + (lpdwTagId == null ? "NULL" : lpdwTagId.ToString()) + 
                ", dwDependSize: " + dwDependSize.ToString() +
                ", lpServiceStartName: " + lpServiceStartName.ToString() +
                ", dwPwSize: " + dwPwSize.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 45};
    
    accepts operation Opnum46NotUsedOnWire
    {
        override string ToString()
        {
            return "Opnum46NotUsedOnWire";
        }
    }
    with Technologies.IDL.IDL{Opnum = 46};
    
    accepts operation RNotifyServiceStatusChange
    {
        in SC_RPC_HANDLE hService;
        in SC_RPC_NOTIFY_PARAMS NotifyParams with Technologies.IDL.IDL{IndirectionLevel = 1};
        in GUID pClientProcessGuid with Technologies.IDL.IDL{IndirectionLevel = 1};
        out GUID pSCMProcessGuid with Technologies.IDL.IDL{IndirectionLevel = 1};
        out int pfCreateRemoteQueue with Technologies.IDL.IDL{IndirectionLevel = 1};
        out SC_NOTIFY_RPC_HANDLE phNotify with Technologies.IDL.IDL{IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RNotifyServiceStatusChange, ReturnValue: " + ReturnValue.ToString() +
                ", pClientProcessGuid: " + pClientProcessGuid.ToString() +
                ", pSCMProcessGuid: " + pSCMProcessGuid.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 47};
    
    accepts operation RGetNotifyResults
    {
        in SC_NOTIFY_RPC_HANDLE hNotify;
        out SC_RPC_NOTIFY_PARAMS_LIST ppNotifyParams with Technologies.IDL.IDL{IndirectionLevel = 2};
        result error_status_t ReturnValue;
        
        override string ToString()
        {
            return "RGetNotifyResults, ReturnValue: " + ReturnValue.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 48};
    
    accepts operation RCloseNotifyHandle
    {
        in out SC_NOTIFY_RPC_HANDLE phNotify with Technologies.IDL.IDL{IndirectionLevel = 1};
        out int pfApcFired with Technologies.IDL.IDL{IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RCloseNotifyHandle, ReturnValue: " + ReturnValue.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 49};
    
    accepts operation RControlServiceExA
    {
        in SC_RPC_HANDLE hService;
        in ControlCode dwControl
            where ValidationCheckEnumValueTooManyItems(InRange<ControlCode>(value), this, true, ReferenceType.Message,
                "SCMR", "dwControl", "RControlServiceExA", "Control Code", "[MS-SCMR]") 
            with Encoding{Decoder = PatternDecoder<ControlCode>, SourcePattern = TypeOf<DWORD>()};
        in DWORD dwInfoLevel where ValidationCheckValue(value == 1, this, true, ReferenceType.Message,
            "SCMR", "dwInfoLevel", "RControlServiceExA", "0x00000001", value);
        in SC_RPC_SERVICE_CONTROL_IN_PARAMSA[dwInfoLevel] pControlInParams with Technologies.IDL.IDL{Switch_Is = dwInfoLevel, IndirectionLevel = 1};
        out SC_RPC_SERVICE_CONTROL_OUT_PARAMSA[dwInfoLevel] pControlOutParams with Technologies.IDL.IDL{Switch_Is = dwInfoLevel, IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RControlServiceExA, ReturnValue: " + ReturnValue.ToString() +
                ", dwControl: " + EnumToStringInSummary<ControlCode>(dwControl) +
                ", dwInfoLevel: " + dwInfoLevel.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 50};
    
    accepts operation RControlServiceExW
    {
        in SC_RPC_HANDLE hService;
        in ControlCode dwControl
            where ValidationCheckEnumValueTooManyItems(InRange<ControlCode>(value), this, true, ReferenceType.Message,
                "SCMR", "dwControl", "RControlServiceExW", "Control Code", "[MS-SCMR]") 
            with Encoding{Decoder = PatternDecoder<ControlCode>, SourcePattern = TypeOf<DWORD>()};
        in DWORD dwInfoLevel where ValidationCheckValue(value == 1, this, true, ReferenceType.Message,
            "SCMR", "dwInfoLevel", "RControlServiceExW", "0x00000001", value);
        in SC_RPC_SERVICE_CONTROL_IN_PARAMSW[dwInfoLevel] pControlInParams with Technologies.IDL.IDL{Switch_Is = dwInfoLevel, IndirectionLevel = 1};
        out SC_RPC_SERVICE_CONTROL_OUT_PARAMSW[dwInfoLevel] pControlOutParams with Technologies.IDL.IDL{Switch_Is = dwInfoLevel, IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RControlServiceExW, ReturnValue: " + ReturnValue.ToString() +
                ", dwControl: " + EnumToStringInSummary<ControlCode>(dwControl) +
                ", dwInfoLevel: " + dwInfoLevel.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 51};
    
    accepts operation Opnum52NotUsedOnWire
    {
        override string ToString()
        {
            return "Opnum52NotUsedOnWire";
        }
    }
    with Technologies.IDL.IDL{Opnum = 52};
    
    accepts operation Opnum53NotUsedOnWire
    {
        override string ToString()
        {
            return "Opnum53NotUsedOnWire";
        }
    }
    with Technologies.IDL.IDL{Opnum = 53};
    
    accepts operation Opnum54NotUsedOnWire
    {
        override string ToString()
        {
            return "Opnum54NotUsedOnWire";
        }
    }
    with Technologies.IDL.IDL{Opnum = 54};
    
    accepts operation Opnum55NotUsedOnWire
    {
        override string ToString()
        {
            return "Opnum55NotUsedOnWire";
        }
    }
    with Technologies.IDL.IDL{Opnum = 55};
    
    accepts operation RQueryServiceConfigEx
    {
        in SC_RPC_HANDLE hService;
        in DWORD dwInfoLevel where ValidationCheckValue(value == 0x00000008, this, true, ReferenceType.Message,
            "SCMR", "dwInfoLevel", "RQueryServiceConfigEx", "0x00000008", value);
        out SC_RPC_CONFIG_INFOW pInfo with Technologies.IDL.IDL{IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RQueryServiceConfigEx, ReturnValue: " + ReturnValue.ToString() +
                ", dwInfoLevel: " + dwInfoLevel.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 56};

    accepts operation Opnum57NotUsedOnWire
    {
    }
    with Technologies.IDL.IDL{Opnum = 57};
    
    accepts operation Opnum58NotUsedOnWire
    {
    }
    with Technologies.IDL.IDL{Opnum = 58};
    
    accepts operation Opnum59NotUsedOnWire
    {
    }
    with Technologies.IDL.IDL{Opnum = 59};
    
    accepts operation RCreateWowService
    {
        in SC_RPC_HANDLE hSCManager;
        in string lpServiceName
               with Technologies.IDL.IDL
                        {Range = new RangePattern {Low = 0, High = SC_MAX_NAME_LENGTH},
                         BaseStringType = TypeOf<wchar_t>(),
                         String = true,
                         IndirectionLevel = 1};
        in string lpDisplayName
               with Technologies.IDL.IDL
                        {Range = new RangePattern {Low = 0, High = SC_MAX_NAME_LENGTH},
                         PointerType = PointerKind.UniquePtr,
                         BaseStringType = TypeOf<wchar_t>(),
                         String = true,
                         IndirectionLevel = 1};
        in DWORD dwDesiredAccess;
        in DWORD dwServiceType;
        in DWORD dwStartType;
        in DWORD dwErrorControl;
        in string lpBinaryPathName
               with Technologies.IDL.IDL
                        {Range = new RangePattern {Low = 0, High = SC_MAX_PATH_LENGTH},
                         BaseStringType = TypeOf<wchar_t>(),
                         String = true,
                         IndirectionLevel = 1};
        in string lpLoadOrderGroup
               with Technologies.IDL.IDL
                        {Range = new RangePattern {Low = 0, High = SC_MAX_NAME_LENGTH},
                         PointerType = PointerKind.UniquePtr,
                         BaseStringType = TypeOf<wchar_t>(),
                         String = true,
                         IndirectionLevel = 1};
        in out IDLUlong lpdwTagId
                   with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                             IndirectionLevel = 1};
        in char lpDependencies
               with Technologies.IDL.IDL{Size_is = [dwDependSize],
                                         PointerType = PointerKind.UniquePtr,
                                         IndirectionLevel = 1};
        in DWORD dwDependSize
               with Technologies.IDL.IDL
                        {Range = new RangePattern {Low = 0, High = SC_MAX_DEPEND_SIZE}};
        in string lpServiceStartName
               with Technologies.IDL.IDL
                        {Range = new RangePattern
                                     {Low = 0, High = SC_MAX_ACCOUNT_NAME_LENGTH},
                         PointerType = PointerKind.UniquePtr,
                         BaseStringType = TypeOf<wchar_t>(),
                         String = true,
                         IndirectionLevel = 1};
        in char lpPassword
               with Technologies.IDL.IDL{Size_is = [dwPwSize],
                                         PointerType = PointerKind.UniquePtr,
                                         IndirectionLevel = 1};
        in DWORD dwPwSize
               with Technologies.IDL.IDL
                        {Range = new RangePattern {Low = 0, High = SC_MAX_PWD_SIZE}};
        in USHORT dwServiceWowType;
        out SC_RPC_HANDLE lpServiceHandle
                with Technologies.IDL.IDL{IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return
                "RCreateWowService" + ", hSCManager: " + hSCManager.ToString() +
                ", lpServiceName: " + lpServiceName.ToString() +
                ", lpDisplayName: " + lpDisplayName.ToString() +
                ", dwDesiredAccess: " + dwDesiredAccess.ToString() +
                ", dwServiceType: " + dwServiceType.ToString() +
                ", dwStartType: " + dwStartType.ToString() +
                ", dwErrorControl: " + dwErrorControl.ToString() +
                ", lpBinaryPathName: " + lpBinaryPathName.ToString() +
                ", lpLoadOrderGroup: " + lpLoadOrderGroup.ToString() +
                ", lpdwTagId: " + lpdwTagId.ToString() + ", lpDependencies: " +
                lpDependencies.ToString() + ", dwDependSize: " +
                dwDependSize.ToString() + ", lpServiceStartName: " +
                lpServiceStartName.ToString() + ", lpPassword: " +
                lpPassword.ToString() + ", dwPwSize: " + dwPwSize.ToString() +
                ", dwServiceWowType: " + dwServiceWowType.ToString() +
                ", lpServiceHandle: " + lpServiceHandle.ToString() +
                ", ReturnValue: " + ReturnValue.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 60};
}
with Technologies.IDL.IDL
{
    Uuid = {367abb81-9844-35f1-ad32-98f038001003},
    Version = "2.0",
    Pointer_default = PointerKind.UniquePtr,
    Ms_union = true
};

typedef SC_RPC_HANDLE = ContextHandle;

type SERVICE_STATUS
{
    SERVICE_STATUSServiceType dwServiceType
        where ValidationCheckCombinationValueTooManyItems(InRange<SERVICE_STATUSServiceType>(value), null, true, ReferenceType.Type,
            "SCMR", "dwServiceType", "SERVICE_STATUS", "Service Type", "[MS-SCMR]") 
        with Encoding{Decoder = PatternDecoder<SERVICE_STATUSServiceType>, SourcePattern = TypeOf<DWORD>()};
    SERVICE_STATUSCurrentState dwCurrentState
        where ValidationCheckEnumValueTooManyItems(InRange<SERVICE_STATUSCurrentState>(value), null, true, ReferenceType.Type,
            "SCMR", "dwCurrentState", "SERVICE_STATUS", "Current State", "[MS-SCMR]") 
        with Encoding{Decoder = PatternDecoder<SERVICE_STATUSCurrentState>, SourcePattern = TypeOf<DWORD>()};
    SERVICE_STATUSControlAccepted dwControlsAccepted
        where ValidationCheckCombinationValueTooManyItems(InRange<SERVICE_STATUSControlAccepted>(value), null, true, ReferenceType.Type,
            "SCMR", "dwControlsAccepted", "SERVICE_STATUS", "Controls Accepted", "[MS-SCMR]") 
        with Encoding{Decoder = PatternDecoder<SERVICE_STATUSControlAccepted>, SourcePattern = TypeOf<DWORD>()};
    DWORD dwWin32ExitCode;
    DWORD dwServiceSpecificExitCode;
    DWORD dwCheckPoint;
    DWORD dwWaitHint;
}

typedef SC_RPC_LOCK = ContextHandle;

typedef BOUNDED_DWORD_256K = DWORD
    with Technologies.IDL.IDL{Range = new RangePattern{Low = 0, High = 262144}};

typedef SVCCTL_HANDLEW = wchar_t
    with Technologies.IDL.IDL{Handle = true, IndirectionLevel = 1};

type QUERY_SERVICE_CONFIGW
{
    QueryServiceConfigServiceType dwServiceType
        where ValidationCheckEnumValueTooManyItems(InRange<QueryServiceConfigServiceType>(value), null, true, ReferenceType.Type,
            "SCMR", "dwServiceType", "QUERY_SERVICE_CONFIGW", "Service Type", "[MS-SCMR]") 
        with Encoding{Decoder = PatternDecoder<QueryServiceConfigServiceType>, SourcePattern = TypeOf<DWORD>()};
    QueryServiceConfigStartType dwStartType
        where ValidationCheckEnumValueTooManyItems(InRange<QueryServiceConfigStartType>(value), null, true, ReferenceType.Type,
            "SCMR", "dwStartType", "QUERY_SERVICE_CONFIGW", "Start Type", "[MS-SCMR]") 
        with Encoding{Decoder = PatternDecoder<QueryServiceConfigStartType>, SourcePattern = TypeOf<DWORD>()};
    QueryServiceConfigErrorControl dwErrorControl
        where ValidationCheckEnumValueTooManyItems(InRange<QueryServiceConfigErrorControl>(value), null, true, ReferenceType.Type,
            "SCMR", "dwErrorControl", "QUERY_SERVICE_CONFIGW", "Error Control", "[MS-SCMR]") 
        with Encoding{Decoder = PatternDecoder<QueryServiceConfigErrorControl>, SourcePattern = TypeOf<DWORD>()};
    string lpBinaryPathName with Technologies.IDL.IDL
    {
        Range = new RangePattern{Low = 0, High = 8192},
        BaseStringType = TypeOf<wchar_t>(),
        String = true,
        IndirectionLevel = 1
    };
    string lpLoadOrderGroup with Technologies.IDL.IDL
    {
        Range = new RangePattern{Low = 0, High = 8192},
        BaseStringType = TypeOf<wchar_t>(),
        String = true,
        IndirectionLevel = 1
    };
    DWORD dwTagId;
    string lpDependencies with Technologies.IDL.IDL
    {
        Range = new RangePattern{Low = 0, High = 8192},
        BaseStringType = TypeOf<wchar_t>(),
        String = true,
        IndirectionLevel = 1
    };
    string lpServiceStartName with Technologies.IDL.IDL
    {
        Range = new RangePattern{Low = 0, High = 8192},
        BaseStringType = TypeOf<wchar_t>(),
        String = true,
        IndirectionLevel = 1
    };
    string lpDisplayName with Technologies.IDL.IDL
    {
        Range = new RangePattern{Low = 0, High = 8192},
        BaseStringType = TypeOf<wchar_t>(),
        String = true,
        IndirectionLevel = 1
    };
}

typedef BOUNDED_DWORD_8K = DWORD with Technologies.IDL.IDL{Range = new RangePattern{Low = 0, High = 8192}};

type QUERY_SERVICE_LOCK_STATUSW
{
    DWORD fIsLocked with DisplayInfo{ToText = IsLockedToText};
    string lpLockOwner with Technologies.IDL.IDL
    {
        Range = new RangePattern{Low = 0, High = 8192},
        BaseStringType = TypeOf<wchar_t>(),
        String = true,
        IndirectionLevel = 1
    };
    DWORD dwLockDuration;
}

typedef BOUNDED_DWORD_4K = DWORD with Technologies.IDL.IDL{Range = new RangePattern{Low = 0, High = 4096}};

type STRING_PTRSW
{
    string StringPtr
        with Technologies.IDL.IDL
                 {Range = new RangePattern{Low = 0, High = SC_MAX_ARGUMENT_LENGTH},
                  BaseStringType = TypeOf<wchar_t>(),
                  String = true,
                  IndirectionLevel = 1};
}

typedef SVCCTL_HANDLEA = LPSTR with Technologies.IDL.IDL{Handle = true};

type QUERY_SERVICE_CONFIGA
{
    QueryServiceConfigServiceType dwServiceType
        where ValidationCheckEnumValueTooManyItems(InRange<QueryServiceConfigServiceType>(value), null, true, ReferenceType.Type,
            "SCMR", "dwServiceType", "QUERY_SERVICE_CONFIGA", "Service Type", "[MS-SCMR]") 
        with Encoding{Decoder = PatternDecoder<QueryServiceConfigServiceType>, SourcePattern = TypeOf<DWORD>()};
    QueryServiceConfigStartType dwStartType
        where ValidationCheckEnumValueTooManyItems(InRange<QueryServiceConfigStartType>(value), null, true, ReferenceType.Type,
            "SCMR", "dwStartType", "QUERY_SERVICE_CONFIGA", "Start Type", "[MS-SCMR]") 
        with Encoding{Decoder = PatternDecoder<QueryServiceConfigStartType>, SourcePattern = TypeOf<DWORD>()};
    QueryServiceConfigErrorControl dwErrorControl
        where ValidationCheckEnumValueTooManyItems(InRange<QueryServiceConfigErrorControl>(value), null, true, ReferenceType.Type,
            "SCMR", "dwErrorControl", "QUERY_SERVICE_CONFIGA", "Error Control", "[MS-SCMR]") 
        with Encoding{Decoder = PatternDecoder<QueryServiceConfigErrorControl>, SourcePattern = TypeOf<DWORD>()};
    string lpBinaryPathName with Technologies.IDL.IDL
    {
        Range = new RangePattern{Low = 0, High = 8192},
        BaseStringType = TypeOf<char>(),
        String = true,
        IndirectionLevel = 1
    };
    string lpLoadOrderGroup with Technologies.IDL.IDL
    {
        Range = new RangePattern{Low = 0, High = 8192},
        BaseStringType = TypeOf<char>(),
        String = true,
        IndirectionLevel = 1
    };
    DWORD dwTagId;
    string lpDependencies with Technologies.IDL.IDL
    {
        Range = new RangePattern{Low = 0, High = 8192},
        BaseStringType = TypeOf<char>(),
        String = true,
        IndirectionLevel = 1
    };
    string lpServiceStartName with Technologies.IDL.IDL
    {
        Range = new RangePattern{Low = 0, High = 8192},
        BaseStringType = TypeOf<char>(),
        String = true,
        IndirectionLevel = 1
    };
    string lpDisplayName with Technologies.IDL.IDL
    {
        Range = new RangePattern{Low = 0, High = 8192},
        BaseStringType = TypeOf<char>(),
        String = true,
        IndirectionLevel = 1
    };
}

type QUERY_SERVICE_LOCK_STATUSA
{
    DWORD fIsLocked with DisplayInfo{ToText = IsLockedToText};
    string lpLockOwner with Technologies.IDL.IDL
    {
        Range = new RangePattern{Low = 0, High = 8192},
        BaseStringType = TypeOf<char>(),
        String = true,
        IndirectionLevel = 1
    };
    DWORD dwLockDuration;
}

type STRING_PTRSA
{
    string StringPtr with Technologies.IDL.IDL
    {
        Range = new RangePattern{Low = 0, High = SC_MAX_ARGUMENT_LENGTH},
        BaseStringType = TypeOf<char>(),
        String = true,
        IndirectionLevel = 1
    };

    override string ToString()
    {
        return StringPtr;
    }
}

type SC_RPC_CONFIG_INFOA
{
    DWORD dwInfoLevel;
    SC_RPC_CONFIG_INFOA_Union[dwInfoLevel] data with Technologies.IDL.IDL{Switch_Is = dwInfoLevel, EmbedType = true};
}

// TDI: #72523, it should have tag 10 and 11
type SC_RPC_CONFIG_INFOA_Union[DWORD Tag]
{
    optional [|Tag in {1}|] SERVICE_DESCRIPTIONA psd
        with Technologies.IDL.IDL{Case = [1], IndirectionLevel = 1};
    optional [|Tag in {2}|] SERVICE_FAILURE_ACTIONSA psfa
        with Technologies.IDL.IDL{Case = [2], IndirectionLevel = 1};
    optional [|Tag in {3}|] SERVICE_DELAYED_AUTO_START_INFO psda
        with Technologies.IDL.IDL{Case = [3], IndirectionLevel = 1};
    optional [|Tag in {4}|] SERVICE_FAILURE_ACTIONS_FLAG psfaf
        with Technologies.IDL.IDL{Case = [4], IndirectionLevel = 1};
    optional [|Tag in {5}|] SERVICE_SID_INFO pssid
        with Technologies.IDL.IDL{Case = [5], IndirectionLevel = 1};
    optional [|Tag in {6}|] SERVICE_RPC_REQUIRED_PRIVILEGES_INFO psrp
        with Technologies.IDL.IDL{Case = [6], IndirectionLevel = 1};
    optional [|Tag in {7}|] SERVICE_PRESHUTDOWN_INFO psps
        with Technologies.IDL.IDL{Case = [7], IndirectionLevel = 1};
    optional [|Tag in {8}|] SERVICE_TRIGGER_INFO psti
        with Technologies.IDL.IDL{Case = [8], IndirectionLevel = 1};
    optional [|Tag in {9}|] SERVICE_PREFERRED_NODE_INFO pspn
        with Technologies.IDL.IDL{Case = [9], IndirectionLevel = 1};

    override string ToString()
    {
        if (psd != nothing)
        {
            return psd.ToString();
        }
        else if (psfa != nothing)
        {
            return psfa.ToString();
        }
        else if (psda != nothing)
        {
            return psda.ToString();
        }
        else if (psfaf != nothing)
        {
            return psfaf.ToString();
        }
        else if (pssid != nothing)
        {
            return pssid.ToString();
        }
        else if (psrp != nothing)
        {
            return psrp.ToString();
        }
        else if (psps != nothing)
        {
            return psps.ToString();
        }
        else if (psti != nothing)
        {
            return psti.ToString();
        }
        else if (pspn != nothing)
        {
            return pspn.ToString();
        }

        return "";
    }
}
with Technologies.IDL.IDL{Switch_Type = TypeOf<DWORD>(), UnionKind = UnionKind.NonEncapsulated};

type SERVICE_DESCRIPTIONA
{
    string lpDescription with Technologies.IDL.IDL
    {
        Range = new RangePattern{Low = 0, High = 8192},
        BaseStringType = TypeOf<char>(),
        String = true,
        IndirectionLevel = 1
    };

    override string ToString()
    {
        return "Description: " + lpDescription;
    }
}

type SERVICE_FAILURE_ACTIONSA
{
    DWORD dwResetPeriod;
    string lpRebootMsg with Technologies.IDL.IDL
    {
        Range = new RangePattern{Low = 0, High = 8192},
        BaseStringType = TypeOf<char>(),
        String = true,
        IndirectionLevel = 1
    };
    string lpCommand with Technologies.IDL.IDL
    {
        Range = new RangePattern{Low = 0, High = 8192},
        BaseStringType = TypeOf<char>(),
        String = true,
        IndirectionLevel = 1
    };
    DWORD cActions with Technologies.IDL.IDL{Range = new RangePattern{Low = 0, High = 1024}};
    array<SC_ACTION> lpsaActions with Technologies.IDL.IDL{Size_is = [cActions], IndirectionLevel = 1};

    override string ToString()
    {
        return "Service Failure Actions";
    }
}

type SC_ACTION
{
    SC_ACTION_TYPE Type where ValidationCheckEnumValue(InRange<SC_ACTION_TYPE>(value), null, true, ReferenceType.Type,
        "SCMR", "Type", "SC_ACTION", INFRASTRUCTURE_STR_ZERO + ", 1, 2, 3", value);
    DWORD Delay;
}

pattern SC_ACTION_TYPE = enum 
{
    SC_ACTION_NONE = 0,
    SC_ACTION_RESTART = 1,
    SC_ACTION_REBOOT = 2,
    SC_ACTION_RUN_COMMAND = 3,
    ...
} with Technologies.IDL.IDL{V1_enum = true};

type SERVICE_DELAYED_AUTO_START_INFO
{
    BOOL fDelayedAutostart;

    override string ToString()
    {
        return "Service Delayed Auto Start: " + (fDelayedAutostart == 0 ? "False" : "True");
    }
}

type SERVICE_FAILURE_ACTIONS_FLAG
{
    BOOL fFailureActionsOnNonCrashFailures;

    override string ToString()
    {
        return "Failure Actions on Non-Crash Failures: " + (fFailureActionsOnNonCrashFailures == 0 ? "False" : "True");
    }
}

type SERVICE_SID_INFO
{
    ServiceSidType dwServiceSidType
        where ValidationCheckEnumValueTooManyItems(InRange<ServiceSidType>(value), null, true, ReferenceType.Type,
            "SCMR", "dwServiceSidType", "SERVICE_SID_INFO", "Service Sid Type", "[MS-SCMR]") 
        with Encoding{Decoder = PatternDecoder<ServiceSidType>, SourcePattern = TypeOf<DWORD>()};

    override string ToString()
    {
        return "Service Sid Type: " + EnumToStringInSummary<ServiceSidType>(dwServiceSidType);
    }
}

type SERVICE_RPC_REQUIRED_PRIVILEGES_INFO
{
    DWORD cbRequiredPrivileges with Technologies.IDL.IDL{Range = new RangePattern{Low = 0, High = 4096}};
    array<char> pRequiredPrivileges with Technologies.IDL.IDL{Size_is = [cbRequiredPrivileges], IndirectionLevel = 1};

    override string ToString()
    {
        return "Required Privileges: " + (pRequiredPrivileges as string);
    }
}

type SERVICE_PRESHUTDOWN_INFO
{
    DWORD dwPreshutdownTimeout;

    override string ToString()
    {
        return "Pre-Shutdown Timeout: " + dwPreshutdownTimeout.ToString();
    }
}

type SERVICE_TRIGGER_INFO
{
    DWORD cTriggers with Technologies.IDL.IDL{Range = new RangePattern{Low = 0, High = 64}};
    array<SERVICE_TRIGGER> pTriggers with Technologies.IDL.IDL{Size_is = [cTriggers], IndirectionLevel = 1};
    char pReserved with Technologies.IDL.IDL{IndirectionLevel = 1};

    override string ToString()
    {
        return "Service Trigger Information";
    }
}

type SERVICE_TRIGGER
{
    TriggerType dwTriggerType
        where ValidationCheckEnumValueTooManyItems(InRange<TriggerType>(value), null, true, ReferenceType.Type,
            "SCMR", "dwTriggerType", "SERVICE_TRIGGER", "Trigger Type", "[MS-SCMR]") 
        with Encoding{Decoder = PatternDecoder<TriggerType>, SourcePattern = TypeOf<DWORD>()};
    TriggerActionType dwAction
        where ValidationCheckEnumValueTooManyItems(InRange<TriggerActionType>(value), null, true, ReferenceType.Type,
            "SCMR", "dwAction", "SERVICE_TRIGGER", "Action Type", "[MS-SCMR]") 
        with Encoding{Decoder = PatternDecoder<TriggerActionType>, SourcePattern = TypeOf<DWORD>()};
    GUID pTriggerSubtype with Technologies.IDL.IDL{IndirectionLevel = 1};
    DWORD cDataItems with Technologies.IDL.IDL{Range = new RangePattern{Low = 0, High = 64}};
    array<SERVICE_TRIGGER_SPECIFIC_DATA_ITEM> pDataItems with Technologies.IDL.IDL{Size_is = [cDataItems], IndirectionLevel = 1};
}

type SERVICE_TRIGGER_SPECIFIC_DATA_ITEM
{
    TriggerDataType dwDataType
        where ValidationCheckEnumValueTooManyItems(InRange<TriggerDataType>(value), null, true, ReferenceType.Type,
            "SCMR", "dwDataType", "SERVICE_TRIGGER_SPECIFIC_DATA_ITEM", "Data Type", "[MS-SCMR]") 
        with Encoding{Decoder = PatternDecoder<TriggerDataType>, SourcePattern = TypeOf<DWORD>()};
    DWORD cbData with Technologies.IDL.IDL{Range = new RangePattern{Low = 0, High = 1024}};
    (string | binary) pData with Technologies.IDL.IDL{Size_is = [cbData], IndirectionLevel = 1},
        Encoding{Decoder = DataDecoder, SourceConverter = ConvertArrayCharToBinary, SourcePattern = TypeOf<array<char>>()};

    optional (string | binary) DataDecoder(binary data)
    {
        if (dwDataType == TriggerDataType.SERVICE_TRIGGER_DATA_TYPE_STRING &&
            BinaryStringDecoder(data, TextEncoding.Unicode) is str:string)
        {
            return str;
        }

        return data;
    }

    override string ToString()
    {
        return pData.ToString();
    }
}

type SERVICE_PREFERRED_NODE_INFO
{
    USHORT usPreferredNode;
    ServicePrefferedNodeDelete fDelete
        where ValidationCheckEnumValue(InRange<ServicePrefferedNodeDelete>(value), null, true, ReferenceType.Type,
            "SCMR", "fDelete", "SERVICE_PREFERRED_NODE_INFO", "0, 1", value)
        with Encoding{Decoder = PatternDecoder<ServicePrefferedNodeDelete>, SourcePattern = TypeOf<BOOLEAN>()};

    override string ToString()
    {
        return "Service Preferred Node Info";
    }
}

type SC_RPC_CONFIG_INFOW
{
    DWORD dwInfoLevel;
    SC_RPC_CONFIG_INFOW_Union[dwInfoLevel] data with Technologies.IDL.IDL{Switch_Is = dwInfoLevel, EmbedType = true};
}

type SC_RPC_CONFIG_INFOW_Union[DWORD Tag]
{
    optional [|Tag in {1}|] SERVICE_DESCRIPTIONW psd
        with Technologies.IDL.IDL{Case = [1], IndirectionLevel = 1};
    optional [|Tag in {2}|] SERVICE_FAILURE_ACTIONSW psfa
        with Technologies.IDL.IDL{Case = [2], IndirectionLevel = 1};
    optional [|Tag in {3}|] SERVICE_DELAYED_AUTO_START_INFO psda
        with Technologies.IDL.IDL{Case = [3], IndirectionLevel = 1};
    optional [|Tag in {4}|] SERVICE_FAILURE_ACTIONS_FLAG psfaf
        with Technologies.IDL.IDL{Case = [4], IndirectionLevel = 1};
    optional [|Tag in {5}|] SERVICE_SID_INFO pssid
        with Technologies.IDL.IDL{Case = [5], IndirectionLevel = 1};
    optional [|Tag in {6}|] SERVICE_RPC_REQUIRED_PRIVILEGES_INFO psrp
        with Technologies.IDL.IDL{Case = [6], IndirectionLevel = 1};
    optional [|Tag in {7}|] SERVICE_PRESHUTDOWN_INFO psps
        with Technologies.IDL.IDL{Case = [7], IndirectionLevel = 1};
    optional [|Tag in {8}|] SERVICE_TRIGGER_INFO psti
        with Technologies.IDL.IDL{Case = [8], IndirectionLevel = 1};
    optional [|Tag in {9}|] SERVICE_PREFERRED_NODE_INFO pspn
        with Technologies.IDL.IDL{Case = [9], IndirectionLevel = 1};

    override string ToString()
    {
        if (psd != nothing)
        {
            return psd.ToString();
        }
        else if (psfa != nothing)
        {
            return psfa.ToString();
        }
        else if (psda != nothing)
        {
            return psda.ToString();
        }
        else if (psfaf != nothing)
        {
            return psfaf.ToString();
        }
        else if (pssid != nothing)
        {
            return pssid.ToString();
        }
        else if (psrp != nothing)
        {
            return psrp.ToString();
        }
        else if (psps != nothing)
        {
            return psps.ToString();
        }
        else if (psti != nothing)
        {
            return psti.ToString();
        }
        else if (pspn != nothing)
        {
            return pspn.ToString();
        }

        return "";
    }
}
with Technologies.IDL.IDL
         {Switch_Type = TypeOf<DWORD>(), UnionKind = UnionKind.NonEncapsulated};

type SERVICE_DESCRIPTIONW
{
    string lpDescription with Technologies.IDL.IDL
    {
        Range = new RangePattern{Low = 0, High = 8192},
        BaseStringType = TypeOf<wchar_t>(),
        String = true,
        IndirectionLevel = 1
    };

    override string ToString()
    {
        return "Description: " + lpDescription;
    }
}

type SERVICE_FAILURE_ACTIONSW
{
    DWORD dwResetPeriod;
    string lpRebootMsg with Technologies.IDL.IDL
    {
        Range = new RangePattern{Low = 0, High = 8192},
        BaseStringType = TypeOf<wchar_t>(),
        String = true,
        IndirectionLevel = 1
    };
    string lpCommand with Technologies.IDL.IDL
    {
        Range = new RangePattern{Low = 0, High = 8192},
        BaseStringType = TypeOf<wchar_t>(),
        String = true,
        IndirectionLevel = 1
    };
    DWORD cActions with Technologies.IDL.IDL{Range = new RangePattern{Low = 0, High = 1024}};
    array<SC_ACTION> lpsaActions with Technologies.IDL.IDL{Size_is = [cActions], IndirectionLevel = 1};

    override string ToString()
    {
        return "Service Failure Actions";
    }
}

pattern SC_STATUS_TYPE = enum 
{
    SC_STATUS_PROCESS_INFO = 0,
    ...
} with Technologies.IDL.IDL{V1_enum = true};

pattern SC_ENUM_TYPE = enum 
{
    SC_ENUM_PROCESS_INFO = 0,
    ...
} with Technologies.IDL.IDL{V1_enum = true};

type SC_RPC_NOTIFY_PARAMS
{
    DWORD dwInfoLevel;
    SC_RPC_NOTIFY_PARAMS_Union[dwInfoLevel] data
        with Technologies.IDL.IDL{Switch_Is = dwInfoLevel, EmbedType = true};
}

type SC_RPC_NOTIFY_PARAMS_Union[DWORD Tag]
{
    optional [|Tag in {1}|] SERVICE_NOTIFY_STATUS_CHANGE_PARAMS_1
        pStatusChangeParam1
        with Technologies.IDL.IDL{Case = [1], IndirectionLevel = 1};
    optional [|Tag in {2}|] SERVICE_NOTIFY_STATUS_CHANGE_PARAMS_2
        pStatusChangeParams
        with Technologies.IDL.IDL{Case = [2], IndirectionLevel = 1};
}
with Technologies.IDL.IDL
         {Switch_Type = TypeOf<DWORD>(), UnionKind = UnionKind.NonEncapsulated};

type SERVICE_NOTIFY_STATUS_CHANGE_PARAMS_1
{
    ULONGLONG ullThreadId;
    NotifyMask dwNotifyMask
        where ValidationCheckCombinationValueTooManyItems(InRange<NotifyMask>(value), null, true, ReferenceType.Type,
            "SCMR", "dwNotifyMask", "SERVICE_NOTIFY_STATUS_CHANGE_PARAMS_1", "Notify Mask", "[MS-SCMR]") 
        with Encoding{Decoder = PatternDecoder<NotifyMask>, SourcePattern = TypeOf<DWORD>()};
    array<UCHAR> CallbackAddressArray with Technologies.IDL.IDL{Dimensions = [16]};
    array<UCHAR> CallbackParamAddressArray with Technologies.IDL.IDL{Dimensions = [16]};
    SERVICE_STATUS_PROCESS ServiceStatus;
    DWORD dwNotificationStatus;
    DWORD dwSequence;
}

type SERVICE_STATUS_PROCESS
{
    ServiceStatusProcessServiceType dwServiceType
        where ValidationCheckEnumValueTooManyItems(InRange<ServiceStatusProcessServiceType>(value), null, true, ReferenceType.Type,
            "SCMR", "dwServiceType", "SERVICE_STATUS_PROCESS", "Service Type", "[MS-SCMR]") 
        with Encoding{Decoder = PatternDecoder<ServiceStatusProcessServiceType>, SourcePattern = TypeOf<DWORD>()};
    ServiceStatusProcessCurrentState dwCurrentState
        where ValidationCheckEnumValueTooManyItems(InRange<ServiceStatusProcessCurrentState>(value), null, true, ReferenceType.Type,
            "SCMR", "dwCurrentState", "SERVICE_STATUS_PROCESS", "Current State", "[MS-SCMR]") 
        with Encoding{Decoder = PatternDecoder<ServiceStatusProcessCurrentState>, SourcePattern = TypeOf<DWORD>()};
    ServiceStatusProcessControlsAccepted dwControlsAccepted
        where ValidationCheckCombinationValueTooManyItems(InRange<ServiceStatusProcessControlsAccepted>(value), null, true, ReferenceType.Type,
            "SCMR", "dwControlsAccepted", "SERVICE_STATUS_PROCESS", "Controls Accepted", "[MS-SCMR]") 
        with Encoding{Decoder = PatternDecoder<ServiceStatusProcessControlsAccepted>, SourcePattern = TypeOf<DWORD>()};
    DWORD dwWin32ExitCode;
    DWORD dwServiceSpecificExitCode;
    DWORD dwCheckPoint;
    DWORD dwWaitHint;
    DWORD dwProcessId;
    DWORD dwServiceFlags;
}

type SERVICE_NOTIFY_STATUS_CHANGE_PARAMS_2
{
    ULONGLONG ullThreadId;
    NotifyMask dwNotifyMask
        where ValidationCheckCombinationValueTooManyItems(InRange<NotifyMask>(value), null, true, ReferenceType.Type,
            "SCMR", "dwNotifyMask", "SERVICE_NOTIFY_STATUS_CHANGE_PARAMS_2", "Notify Mask", "[MS-SCMR]") 
        with Encoding{Decoder = PatternDecoder<NotifyMask>, SourcePattern = TypeOf<DWORD>()};
    array<UCHAR> CallbackAddressArray with Technologies.IDL.IDL{Dimensions = [16]};
    array<UCHAR> CallbackParamAddressArray with Technologies.IDL.IDL{Dimensions = [16]};
    SERVICE_STATUS_PROCESS ServiceStatus;
    DWORD dwNotificationStatus;
    DWORD dwSequence;
    DWORD dwNotificationTriggered;
    string pszServiceNames with Technologies.IDL.IDL
    {
        Range = new RangePattern{Low = 0, High = 65536},
        BaseStringType = TypeOf<wchar_t>(),
        String = true,
        IndirectionLevel = 1
    };
}

typedef SC_NOTIFY_RPC_HANDLE = ContextHandle;

type SC_RPC_NOTIFY_PARAMS_LIST
{
    BOUNDED_DWORD_4K cElements;
    array<SC_RPC_NOTIFY_PARAMS> NotifyParamsArray with Technologies.IDL.IDL{Size_is = [cElements], Dimensions = [null]};
}

type SC_RPC_SERVICE_CONTROL_IN_PARAMSA[DWORD DwInfoLevel]
{
    optional [|DwInfoLevel == 1|]SERVICE_CONTROL_STATUS_REASON_IN_PARAMSA psrInParams
        with Technologies.IDL.IDL{Case = [1], IndirectionLevel = 1};
}
with Technologies.IDL.IDL{Switch_Type = TypeOf<DWORD>(), UnionKind = UnionKind.NonEncapsulated};

type SERVICE_CONTROL_STATUS_REASON_IN_PARAMSA
{
    ReasonCodeType dwReason with Encoding{Decoder = ReasonCodeTypeDecoder, SourcePattern = TypeOf<DWORD>()};
    string pszComment with Technologies.IDL.IDL
    {
        Range = new RangePattern{Low = 0, High = SC_MAX_COMMENT_LENGTH},
        BaseStringType = TypeOf<char>(),
        String = true,
        IndirectionLevel = 1
    };
}

type SC_RPC_SERVICE_CONTROL_OUT_PARAMSA[DWORD DwInfoLevel]
{
    optional [|DwInfoLevel == 1|] SERVICE_CONTROL_STATUS_REASON_OUT_PARAMS psrOutParams
        with Technologies.IDL.IDL{Case = [1], IndirectionLevel = 1};
}
with Technologies.IDL.IDL{Switch_Type = TypeOf<DWORD>(), UnionKind = UnionKind.NonEncapsulated};

type SERVICE_CONTROL_STATUS_REASON_OUT_PARAMS
{
    SERVICE_STATUS_PROCESS ServiceStatus;
}

type SC_RPC_SERVICE_CONTROL_IN_PARAMSW[DWORD DwInfoLevel]
{
    optional [|DwInfoLevel == 1|] SERVICE_CONTROL_STATUS_REASON_IN_PARAMSW psrInParams
        with Technologies.IDL.IDL{Case = [1], IndirectionLevel = 1};
}
with Technologies.IDL.IDL{Switch_Type = TypeOf<DWORD>(), UnionKind = UnionKind.NonEncapsulated};

type SERVICE_CONTROL_STATUS_REASON_IN_PARAMSW
{
    ReasonCodeType dwReason with Encoding{Decoder = ReasonCodeTypeDecoder, SourcePattern = TypeOf<DWORD>()};
    string pszComment with Technologies.IDL.IDL
    {
        Range = new RangePattern{Low = 0, High = SC_MAX_COMMENT_LENGTH},
        BaseStringType = TypeOf<wchar_t>(),
        String = true,
        IndirectionLevel = 1
    };
}

type ReasonCodeType
{
    GeneralReasonCode GeneralReasonCode with BinaryEncoding{Width = 4};
    MajorReasonCode MajorReasonCode with BinaryEncoding{Width = 12};
    MinorReasonCode MinorReasonCode;

    override string ToString()
    {
        return EnumToStringInSummary<GeneralReasonCode>(GeneralReasonCode) + 
            "|" + EnumToStringInSummary<MajorReasonCode>(MajorReasonCode) + 
            "|" + EnumToStringInSummary<MinorReasonCode>(MinorReasonCode);
    }
} with IDL{DoNotGenerate = true}, Encoding{EncodingKind = EncodingKind.Binary};

optional ReasonCodeType ReasonCodeTypeDecoder(DWORD data)
{
    ReasonCodeType ret =  new ReasonCodeType
    {
        GeneralReasonCode = (data >> 28) as byte,
        MajorReasonCode = ((data & 0x00FFFFFF) >> 16) as ushort,
        MinorReasonCode = (data & 0x0000FFFF) as ushort
    };
    
    ValidationCheckEnumValueTooManyItems(InRange<GeneralReasonCode>(ret.GeneralReasonCode), null, true, ReferenceType.Type,
        "SCMR", "GeneralReasonCode", "ReasonCodeType", "General Reason Code", "[MS-SCMR]");
    ValidationCheckEnumValueTooManyItems(InRange<MajorReasonCode>(ret.MajorReasonCode), null, true, ReferenceType.Type,
        "SCMR", "MajorReasonCode", "ReasonCodeType", "Major Reason Code", "[MS-SCMR]");
    ValidationCheckEnumValueTooManyItems(InRange<MinorReasonCode>(ret.MinorReasonCode), null, true, ReferenceType.Type,
        "SCMR", "MinorReasonCode", "ReasonCodeType", "Minor Reason Code", "[MS-SCMR]");
    return ret;
}

type SC_RPC_SERVICE_CONTROL_OUT_PARAMSW[DWORD DwInfoLevel]
{
    optional [|DwInfoLevel == 1|] SERVICE_CONTROL_STATUS_REASON_OUT_PARAMS psrOutParams
        with Technologies.IDL.IDL{Case = [1], IndirectionLevel = 1};
}
with Technologies.IDL.IDL{Switch_Type = TypeOf<DWORD>(), UnionKind = UnionKind.NonEncapsulated};

const int SC_MAX_COMPUTER_NAME_LENGTH = 1024;

const int SC_MAX_PATH_LENGTH = 32768;

const int MAX_SERVICE_NAME_LENGTH = 256;

const int SC_MAX_NAME_LENGTH = MAX_SERVICE_NAME_LENGTH + 1;

const int SC_MAX_DEPEND_SIZE = 4096;

const int SC_MAX_ACCOUNT_NAME_LENGTH = 2048;

const int SC_MAX_PWD_SIZE = 514;

const int SC_MAX_ARGUMENTS = 1024;

const int SC_MAX_ARGUMENT_LENGTH = 1024;

const int SC_MAX_COMMENT_LENGTH = 128;

// -------------------------------------------------------------------------------
// Binary Codec
pattern SCMRAccessMask = flags DWORD
{
    // defined in DTYP
    GENERIC_READ = 0x80000000,
    GENERIC_WRITE = 0x40000000,
    GENERIC_EXECUTE = 0x20000000,
    GENERIC_ALL = 0x10000000,
    MAXIMUM_ALLOWED = 0x02000000,
    ACCESS_SYSTEM_SECURITY = 0x01000000,
    SYNCHRONIZE = 0x00100000,
    WRITE_OWNER = 0x00080000,
    WRITE_DACL = 0x00040000,
    READ_CONTROL = 0x00020000,
    DELETE = 0x00010000,
    // defined in SCMR
    SERVICE_CHANGE_CONFIG = 0x00000002,
    SERVICE_ENUMERATE_DEPENDENTS = 0x00000008,
    SERVICE_INTERROGATE = 0x00000080,
    SERVICE_PAUSE_CONTINUE = 0x00000040,
    SERVICE_QUERY_CONFIG = 0x00000001,
    SERVICE_QUERY_STATUS = 0x00000004,
    SERVICE_START = 0x00000010,
    SERVICE_STOP = 0x00000020,
    SERVICE_USER_DEFINED_CONTROL = 0x00000100,
    SERVICE_SET_STATUS = 0x00008000,
    ...
} with IDL{DoNotGenerate = true}, Encoding{EncodingKind = EncodingKind.Binary};

pattern SCMRServiceControlManagerAccessMask = flags DWORD
{
    // defined in DTYP
    GENERIC_READ = 0x80000000,
    GENERIC_WRITE = 0x40000000,
    GENERIC_EXECUTE = 0x20000000,
    GENERIC_ALL = 0x10000000,
    MAXIMUM_ALLOWED = 0x02000000,
    ACCESS_SYSTEM_SECURITY = 0x01000000,
    SYNCHRONIZE = 0x00100000,
    WRITE_OWNER = 0x00080000,
    WRITE_DACL = 0x00040000,
    READ_CONTROL = 0x00020000,
    DELETE = 0x00010000,
    // defined in SCMR
    SC_MANAGER_LOCK = 0x00000008,
    SC_MANAGER_CREATE_SERVICE = 0x00000002,
    SC_MANAGER_ENUMERATE_SERVICE = 0x00000004,
    SC_MANAGER_CONNECT = 0x00000001,
    SC_MANAGER_QUERY_LOCK_STATUS = 0x00000010,
    SC_MANAGER_MODIFY_BOOT_CONFIG = 0x0020,
    ...
} with IDL{DoNotGenerate = true}, Encoding{EncodingKind = EncodingKind.Binary};

pattern RCreateServiceServiceType = flags DWORD
{
    SERVICE_KERNEL_DRIVER = 0x00000001,
    SERVICE_FILE_SYSTEM_DRIVER = 0x00000002,
    SERVICE_WIN32_OWN_PROCESS = 0x00000010,
    SERVICE_WIN32_SHARE_PROCESS = 0x00000020,
    SERVICE_INTERACTIVE_PROCESS = 0x00000100,
    ...
} with IDL{DoNotGenerate = true}, Encoding{EncodingKind = EncodingKind.Binary};

pattern RCreateServiceStartType = enum DWORD
{
    SERVICE_BOOT_START = 0x00000000,
    SERVICE_SYSTEM_START = 0x00000001,
    SERVICE_AUTO_START = 0x00000002,
    SERVICE_DEMAND_START = 0x00000003,
    SERVICE_DISABLED = 0x00000004,
    ...
} with IDL{DoNotGenerate = true}, Encoding{EncodingKind = EncodingKind.Binary};

pattern RCreateServiceErrorControl = enum DWORD
{
    SERVICE_ERROR_IGNORE = 0x00000000,
    SERVICE_ERROR_NORMAL = 0x00000001,
    SERVICE_ERROR_SEVERE = 0x00000002,
    SERVICE_ERROR_CRITICAL = 0x00000003,
    ...
} with IDL{DoNotGenerate = true}, Encoding{EncodingKind = EncodingKind.Binary};

pattern ControlCode = enum DWORD
{
    SERVICE_CONTROL_CONTINUE = 0x00000003,
    SERVICE_CONTROL_INTERROGATE = 0x00000004,
    SERVICE_CONTROL_NETBINDADD = 0x00000007,
    SERVICE_CONTROL_NETBINDDISABLE = 0x0000000A,
    SERVICE_CONTROL_NETBINDENABLE = 0x00000009,
    SERVICE_CONTROL_NETBINDREMOVE = 0x00000008,
    SERVICE_CONTROL_PARAMCHANGE = 0x00000006,
    SERVICE_CONTROL_PAUSE = 0x00000002,
    SERVICE_CONTROL_STOP = 0x00000001,
    ...
} with IDL{DoNotGenerate = true}, Encoding{EncodingKind = EncodingKind.Binary};

pattern SERVICE_STATUSServiceType = flags DWORD
{
    SERVICE_KERNEL_DRIVER = 0x00000001,
    SERVICE_FILE_SYSTEM_DRIVER = 0x00000002,
    SERVICE_WIN32_OWN_PROCESS = 0x00000010,
    SERVICE_WIN32_SHARE_PROCESS = 0x00000020,
    SERVICE_INTERACTIVE_PROCESS = 0x00000100,
    ...
} with IDL{DoNotGenerate = true}, Encoding{EncodingKind = EncodingKind.Binary};

pattern SERVICE_STATUSCurrentState = enum DWORD
{
    SERVICE_CONTINUE_PENDING = 0x00000005,
    SERVICE_PAUSE_PENDING = 0x00000006,
    SERVICE_PAUSED = 0x00000007,
    SERVICE_RUNNING = 0x00000004,
    SERVICE_START_PENDING = 0x0000002,
    SERVICE_STOP_PENDING = 0x00000003,
    SERVICE_STOPPED = 0x00000001,
    ...
} with IDL{DoNotGenerate = true}, Encoding{EncodingKind = EncodingKind.Binary};

pattern SERVICE_STATUSControlAccepted = flags DWORD
{
    SERVICE_ACCEPT_PARAMCHANGE = 0x00000008,
    SERVICE_ACCEPT_PAUSE_CONTINUE = 0x00000002,
    SERVICE_ACCEPT_SHUTDOWN = 0x00000004,
    SERVICE_ACCEPT_STOP = 0x00000001,
    SERVICE_ACCEPT_HARDWAREPROFILECHANGE = 0x00000020,
    SERVICE_ACCEPT_POWEREVENT = 0x00000040,
    SERVICE_ACCEPT_SESSIONCHANGE = 0x00000080,
    SERVICE_ACCEPT_PRESHUTDOWN = 0x00000100,
    SERVICE_ACCEPT_TIMECHANGE = 0x00000200,
    SERVICE_ACCEPT_TRIGGEREVENT = 0x00000400,
    ...
} with IDL{DoNotGenerate = true}, Encoding{EncodingKind = EncodingKind.Binary};

pattern SecurityInformation = flags SECURITY_INFORMATION
{
    DACL_SECURITY_INFORMATION = 0x00000004,
    GROUP_SECURITY_INFORMATION = 0x00000002,
    OWNER_SECURITY_INFORMATION = 0x00000001,
    SACL_SECURITY_INFORMATION = 0x00000008,
    ...
} with IDL{DoNotGenerate = true}, Encoding{EncodingKind = EncodingKind.Binary};

pattern RChangeServiceConfigServiceType = enum DWORD
{
    SERVICE_KERNEL_DRIVER = 0x00000001,
    SERVICE_FILE_SYSTEM_DRIVER = 0x00000002,
    SERVICE_WIN32_OWN_PROCESS = 0x00000010,
    SERVICE_WIN32_SHARE_PROCESS = 0x00000020,
    SERVICE_INTERACTIVE_PROCESS = 0x00000100,
    SERVICE_NO_CHANGE = 0xFFFFFFFF,
    ...
} with IDL{DoNotGenerate = true}, Encoding{EncodingKind = EncodingKind.Binary};

pattern RChangeServiceConfigStartType = enum DWORD
{
    SERVICE_BOOT_START = 0x00000000,
    SERVICE_SYSTEM_START = 0x00000001,
    SERVICE_AUTO_START = 0x00000002,
    SERVICE_DEMAND_START = 0x00000003,
    SERVICE_DISABLED = 0x00000004,
    SERVICE_NO_CHANGE = 0xFFFFFFFF,
    ...
} with IDL{DoNotGenerate = true}, Encoding{EncodingKind = EncodingKind.Binary};

pattern RChangeServiceConfigErrorControl = enum DWORD
{
    SERVICE_ERROR_IGNORE = 0x00000000,
    SERVICE_ERROR_NORMAL = 0x00000001,
    SERVICE_ERROR_SEVERE = 0x00000002,
    SERVICE_ERROR_CRITICAL = 0x00000003,
    SERVICE_NO_CHANGE = 0xFFFFFFFF,
    ...
} with IDL{DoNotGenerate = true}, Encoding{EncodingKind = EncodingKind.Binary};

pattern REnumServicesServiceState = enum DWORD
{
    SERVICE_ACTIVE = 0x00000001,
    SERVICE_INACTIVE = 0x00000002,
    SERVICE_STATE_ALL = 0x00000003,
    ...
} with IDL{DoNotGenerate = true}, Encoding{EncodingKind = EncodingKind.Binary};

pattern REnumServicesServiceType = flags DWORD
{
    SERVICE_KERNEL_DRIVER = 0x00000001,
    SERVICE_FILE_SYSTEM_DRIVER = 0x00000002,
    SERVICE_WIN32_OWN_PROCESS = 0x00000010,
    SERVICE_WIN32_SHARE_PROCESS = 0x00000020,
    ...
} with IDL{DoNotGenerate = true}, Encoding{EncodingKind = EncodingKind.Binary};

pattern QueryServiceConfigServiceType = enum DWORD
{
    SERVICE_KERNEL_DRIVER = 0x00000001,
    SERVICE_FILE_SYSTEM_DRIVER = 0x00000002,
    SERVICE_WIN32_OWN_PROCESS = 0x00000010,
    SERVICE_WIN32_SHARE_PROCESS = 0x00000020,
    ...
} with IDL{DoNotGenerate = true}, Encoding{EncodingKind = EncodingKind.Binary};

pattern QueryServiceConfigStartType = enum DWORD
{
    SERVICE_BOOT_START = 0x00000000,
    SERVICE_SYSTEM_START = 0x00000001,
    SERVICE_AUTO_START = 0x00000002,
    SERVICE_DEMAND_START = 0x00000003,
    SERVICE_DISABLED = 0x00000004,
    ...
} with IDL{DoNotGenerate = true}, Encoding{EncodingKind = EncodingKind.Binary};

pattern QueryServiceConfigErrorControl = enum DWORD
{
    SERVICE_ERROR_IGNORE = 0x00000000,
    SERVICE_ERROR_NORMAL = 0x00000001,
    SERVICE_ERROR_SEVERE = 0x00000002,
    SERVICE_ERROR_CRITICAL = 0x00000003,
    ...
} with IDL{DoNotGenerate = true}, Encoding{EncodingKind = EncodingKind.Binary};

pattern REnumServiceGroupServiceType = flags DWORD
{
    SERVICE_KERNEL_DRIVER = 0x00000001,
    SERVICE_FILE_SYSTEM_DRIVER = 0x00000002,
    SERVICE_WIN32_OWN_PROCESS = 0x00000010,
    SERVICE_WIN32_SHARE_PROCESS = 0x00000020,
    ...
} with IDL{DoNotGenerate = true}, Encoding{EncodingKind = EncodingKind.Binary};

pattern REnumServiceGroupServiceState = enum DWORD
{
    SERVICE_ACTIVE = 0x00000001,
    SERVICE_INACTIVE = 0x00000002,
    SERVICE_STATE_ALL = 0x00000003,
    ...
} with IDL{DoNotGenerate = true}, Encoding{EncodingKind = EncodingKind.Binary};

pattern RQueryServiceConfig2InfoLevel = enum DWORD
{
    SERVICE_CONFIG_DESCRIPTION = 0x00000001,
    SERVICE_CONFIG_FAILURE_ACTIONS = 0x00000002,
    SERVICE_CONFIG_DELAYED_AUTO_START_INFO = 0x00000003,
    SERVICE_CONFIG_FAILURE_ACTIONS_FLAG = 0x00000004,
    SERVICE_CONFIG_SERVICE_SID_INFO = 0x00000005,
    SERVICE_CONFIG_REQUIRED_PRIVILEGES_INFO = 0x00000006,
    SERVICE_CONFIG_PRESHUTDOWN_INFO = 0x00000007,
    SERVICE_CONFIG_PREFERRED_NODE = 0x00000009,
    SERVICE_CONFIG_RUNLEVEL_INFO = 0x0000000A,
    ...
} with IDL{DoNotGenerate = true}, Encoding{EncodingKind = EncodingKind.Binary};

pattern ServiceSidType = enum DWORD
{
    SERVICE_SID_TYPE_NONE = 0x00000000,
    SERVICE_SID_TYPE_RESTRICTED = 0x00000003,
    SERVICE_SID_TYPE_UNRESTRICTED = 0x00000001,
    ...
} with IDL{DoNotGenerate = true}, Encoding{EncodingKind = EncodingKind.Binary};

pattern TriggerType = enum DWORD
{
    SERVICE_TRIGGER_TYPE_DEVICE_INTERFACE_ARRIVAL = 0x00000001,
    SERVICE_TRIGGER_TYPE_IP_ADDRESS_AVAILABILITY = 0x00000002,
    SERVICE_TRIGGER_TYPE_DOMAIN_JOIN = 0x00000003,
    SERVICE_TRIGGER_TYPE_FIREWALL_PORT_EVENT = 0x00000004,
    SERVICE_TRIGGER_TYPE_GROUP_POLICY = 0x00000005,
    SERVICE_TRIGGER_TYPE_CUSTOM = 0x00000006,
    ...
} with IDL{DoNotGenerate = true}, Encoding{EncodingKind = EncodingKind.Binary};

pattern TriggerActionType = enum DWORD
{
    SERVICE_TRIGGER_ACTION_SERVICE_START = 0x00000001,
    SERVICE_TRIGGER_ACTION_SERVICE_STOP = 0x00000002,
    ...
} with IDL{DoNotGenerate = true}, Encoding{EncodingKind = EncodingKind.Binary};

pattern TriggerDataType = enum DWORD
{
    SERVICE_TRIGGER_DATA_TYPE_BINARY = 0x00000001,
    SERVICE_TRIGGER_DATA_TYPE_STRING = 0x00000002,
    ...
} with IDL{DoNotGenerate = true}, Encoding{EncodingKind = EncodingKind.Binary};

pattern ServicePrefferedNodeDelete = enum BOOLEAN
{
    $"Should be deleted" = 1,
    $"Should not be deleted" = 0,
    ...
} with IDL{DoNotGenerate = true}, Encoding{EncodingKind = EncodingKind.Binary};

pattern NotifyMask = flags DWORD
{
    SERVICE_NOTIFY_CREATED = 0x00000080,
    SERVICE_NOTIFY_CONTINUE_PENDING = 0x00000010,
    SERVICE_NOTIFY_DELETE_PENDING = 0x00000200,
    SERVICE_NOTIFY_DELETED = 0x00000100,
    SERVICE_NOTIFY_PAUSE_PENDING = 0x00000020,
    SERVICE_NOTIFY_PAUSED = 0x00000040,
    SERVICE_NOTIFY_RUNNING = 0x00000008,
    SERVICE_NOTIFY_START_PENDING = 0x00000002,
    SERVICE_NOTIFY_STOP_PENDING = 0x00000004,
    SERVICE_NOTIFY_STOPPED = 0x00000001,
    ...
} with IDL{DoNotGenerate = true}, Encoding{EncodingKind = EncodingKind.Binary};

pattern ServiceStatusProcessServiceType = enum DWORD
{
    SERVICE_KERNEL_DRIVER = 0x00000001,
    SERVICE_FILE_SYSTEM_DRIVER = 0x00000002,
    SERVICE_WIN32_OWN_PROCESS = 0x00000010,
    SERVICE_WIN32_SHARE_PROCESS = 0x00000020,
    SERVICE_INTERACTIVE_PROCESS = 0x00000100,
    ...
} with IDL{DoNotGenerate = true}, Encoding{EncodingKind = EncodingKind.Binary};

pattern ServiceStatusProcessCurrentState = enum DWORD
{
    SERVICE_CONTINUE_PENDING = 0x00000005,
    SERVICE_PAUSE_PENDING = 0x00000006,
    SERVICE_PAUSED = 0x00000007,
    SERVICE_RUNNING = 0x00000004,
    SERVICE_START_PENDING = 0x0000002,
    SERVICE_STOP_PENDING = 0x00000003,
    SERVICE_STOPPED = 0x00000001,
    ...
} with IDL{DoNotGenerate = true}, Encoding{EncodingKind = EncodingKind.Binary};

pattern ServiceStatusProcessControlsAccepted = flags DWORD
{
    SERVICE_ACCEPT_PARAMCHANGE = 0x00000008,
    SERVICE_ACCEPT_PAUSE_CONTINUE = 0x00000002,
    SERVICE_ACCEPT_SHUTDOWN = 0x00000004,
    SERVICE_ACCEPT_STOP = 0x00000001,
    SERVICE_ACCEPT_HARDWAREPROFILECHANGE = 0x00000020,
    SERVICE_ACCEPT_POWEREVENT = 0x00000040,
    SERVICE_ACCEPT_SESSIONCHANGE = 0x00000080,
    SERVICE_ACCEPT_PRESHUTDOWN = 0x00000100,
    SERVICE_ACCEPT_TIMECHANGE = 0x00000200,
    SERVICE_ACCEPT_TRIGGEREVENT = 0x00000400,
    ...
} with IDL{DoNotGenerate = true}, Encoding{EncodingKind = EncodingKind.Binary};

pattern GeneralReasonCode = enum byte
{
    SERVICE_STOP_CUSTOM = 0x20,
    SERVICE_STOP_PLANNED = 0x40,
    SERVICE_STOP_UNPLANNED = 0x10,
    ...
} with IDL{DoNotGenerate = true}, Encoding{EncodingKind = EncodingKind.Binary};

pattern MajorReasonCode = enum ushort
{
    SERVICE_STOP_REASON_MAJOR_APPLICATION = 0x0005,
    SERVICE_STOP_REASON_MAJOR_HARDWARE = 0x0002,
    SERVICE_STOP_REASON_MAJOR_NONE = 0x0006,
    SERVICE_STOP_REASON_MAJOR_OPERATINGSYSTEM = 0x0003,
    SERVICE_STOP_REASON_MAJOR_OTHER = 0x0001,
    SERVICE_STOP_REASON_MAJOR_SOFTWARE = 0x0004,
    ...
} with IDL{DoNotGenerate = true}, Encoding{EncodingKind = EncodingKind.Binary};

pattern MinorReasonCode = enum ushort
{
    SERVICE_STOP_REASON_MINOR_DISK = 0x00000008,
    SERVICE_STOP_REASON_MINOR_ENVIRONMENT = 0x0000000a,
    SERVICE_STOP_REASON_MINOR_HARDWARE_DRIVER = 0x0000000b,
    SERVICE_STOP_REASON_MINOR_HUNG = 0x00000006,
    SERVICE_STOP_REASON_MINOR_INSTALLATION = 0x00000003,
    SERVICE_STOP_REASON_MINOR_MAINTENANCE = 0x00000002,
    SERVICE_STOP_REASON_MINOR_MMC = 0x00000016,
    SERVICE_STOP_REASON_MINOR_NETWORK_CONNECTIVITY = 0x00000011,
    SERVICE_STOP_REASON_MINOR_NETWORKCARD = 0x00000009,
    SERVICE_STOP_REASON_MINOR_NONE = 0x00000017,
    SERVICE_STOP_REASON_MINOR_OTHER = 0x00000001,
    SERVICE_STOP_REASON_MINOR_OTHERDRIVER = 0x0000000c,
    SERVICE_STOP_REASON_MINOR_RECONFIG = 0x00000005,
    SERVICE_STOP_REASON_MINOR_SECURITY = 0x00000010,
    SERVICE_STOP_REASON_MINOR_SECURITYFIX = 0x0000000f,
    SERVICE_STOP_REASON_MINOR_SECURITYFIX_UNINSTALL = 0x00000015,
    SERVICE_STOP_REASON_MINOR_SERVICEPACK = 0x0000000d,
    SERVICE_STOP_REASON_MINOR_SERVICEPACK_UNINSTALL = 0x00000013,
    SERVICE_STOP_REASON_MINOR_SOFTWARE_UPDATE = 0x0000000e,
    SERVICE_STOP_REASON_MINOR_SOFTWARE_UPDATE_UNINSTALL = 0x00000014,
    SERVICE_STOP_REASON_MINOR_UNSTABLE = 0x00000007,
    SERVICE_STOP_REASON_MINOR_UPGRADE = 0x00000004,
    SERVICE_STOP_REASON_MINOR_WMI = 0x00000012,
    ...
} with IDL{DoNotGenerate = true}, Encoding{EncodingKind = EncodingKind.Binary};

pattern QueryServiceConfigBuffer = (binary | SERVICE_DESCRIPTION_WOW64 | ServiceDescriptionA_NonRpc | SERVICE_FAILURE_ACTIONS_WOW64 |
    ServiceFailureActionsA_NonRpc | SERVICE_DELAYED_AUTO_START_INFO |
    SERVICE_FAILURE_ACTIONS_FLAG | SERVICE_SID_INFO | ServiceRpcRequiredPrivilegesInfo_NonRpc | SERVICE_PRESHUTDOWN_INFO | SERVICE_PREFERRED_NODE_INFO)
    with IDL{DoNotGenerate = true}, Encoding{EncodingKind = EncodingKind.Binary};
optional QueryServiceConfigBuffer QueryServiceConfigBufferDecoder(
    BOUNDED_DWORD_8K bytesNeeded,
    RQueryServiceConfig2InfoLevel dwInfoLevel,
    binary bin,
    bool isWow64 /* Wow64 or A*/)
{
    if (bin.Count < bytesNeeded)
    {
        // data is not suffient to decode as structure, leave as binary
        return bin;
    }

    if (dwInfoLevel == RQueryServiceConfig2InfoLevel.SERVICE_CONFIG_DESCRIPTION)
    {
        if (isWow64)
        {
            if (BinaryDecoder<SERVICE_DESCRIPTION_WOW64>(bin) is serviceDescription:SERVICE_DESCRIPTION_WOW64)
            {
                return serviceDescription;
            }
        }
        else
        {
            if (BinaryDecoder<ServiceDescriptionA_NonRpc>(bin) is serviceDescription:ServiceDescriptionA_NonRpc)
            {
                return serviceDescription;
            }
        }
    }
    else if (dwInfoLevel == RQueryServiceConfig2InfoLevel.SERVICE_CONFIG_FAILURE_ACTIONS)
    {
        if (isWow64)
        {
            if (BinaryDecoder<SERVICE_FAILURE_ACTIONS_WOW64>(bin) is serviceFailureActions:SERVICE_FAILURE_ACTIONS_WOW64)
            {
                return serviceFailureActions;
            }
        }
        else
        {
            if (BinaryDecoder<ServiceFailureActionsA_NonRpc>(bin) is serviceDescription:ServiceFailureActionsA_NonRpc)
            {
                return serviceDescription;
            }
        }
    }
    else if (dwInfoLevel == RQueryServiceConfig2InfoLevel.SERVICE_CONFIG_DELAYED_AUTO_START_INFO)
    {
        if (BinaryDecoder<SERVICE_DELAYED_AUTO_START_INFO>(bin) is serviceDelayedAutoStartInfo:SERVICE_DELAYED_AUTO_START_INFO)
        {
            return serviceDelayedAutoStartInfo;
        }
    }
    else if (dwInfoLevel == RQueryServiceConfig2InfoLevel.SERVICE_CONFIG_FAILURE_ACTIONS_FLAG)
    {
        if (BinaryDecoder<SERVICE_FAILURE_ACTIONS_FLAG>(bin) is serviceFailureActionsFlag:SERVICE_FAILURE_ACTIONS_FLAG)
        {
            return serviceFailureActionsFlag;
        }
    }
    else if (dwInfoLevel == RQueryServiceConfig2InfoLevel.SERVICE_CONFIG_SERVICE_SID_INFO)
    {
        if (BinaryDecoder<SERVICE_SID_INFO>(bin) is serviceSidInfo:SERVICE_SID_INFO)
        {
            return serviceSidInfo;
        }
    }
    else if (dwInfoLevel == RQueryServiceConfig2InfoLevel.SERVICE_CONFIG_REQUIRED_PRIVILEGES_INFO)
    {
        if (BinaryDecoder<ServiceRpcRequiredPrivilegesInfo_NonRpc>(bin) is servicePrivilegesInfo:ServiceRpcRequiredPrivilegesInfo_NonRpc)
        {
            return servicePrivilegesInfo;
        }
    }
    else if (dwInfoLevel == RQueryServiceConfig2InfoLevel.SERVICE_CONFIG_PRESHUTDOWN_INFO)
    {
        if (BinaryDecoder<SERVICE_PRESHUTDOWN_INFO>(bin) is servicePreshutdownInfo:SERVICE_PRESHUTDOWN_INFO)
        {
            return servicePreshutdownInfo;
        }
    }
    else if (dwInfoLevel == RQueryServiceConfig2InfoLevel.SERVICE_CONFIG_PREFERRED_NODE)
    {
        if (BinaryDecoder<SERVICE_PREFERRED_NODE_INFO>(bin) is servicePreferredNodeInfo:SERVICE_PREFERRED_NODE_INFO)
        {
            return servicePreferredNodeInfo;
        }
    }

    // the data cannot be decoded as structure, leave it as binary
    return bin;
}

type SERVICE_DESCRIPTION_WOW64
{
    uint dwDescriptionOffset;
    optional [|dwDescriptionOffset > 0|] string dwDescription with Encoding{Offset = dwDescriptionOffset}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};

    override string ToString()
    {
        return (dwDescription is str:string ? ("Description: " + str) : "Description");
    }
} with IDL{DoNotGenerate = true}, Encoding{EncodingKind = EncodingKind.Binary};

type ServiceDescriptionA_NonRpc
{
    uint Offset with BinaryEncoding{Endian = Endian.Little};
    string lpDescription with Encoding{Offset = Offset}, BinaryEncoding{TextEncoding = TextEncoding.ASCII};

    override string ToString()
    {
        return "Description: " + lpDescription;
    }
} with IDL{DoNotGenerate = true}, Encoding{EncodingKind = EncodingKind.Binary};

type SERVICE_FAILURE_ACTIONS_WOW64
{
    uint dwResetPeriod;
    uint dwRebootMsgOffset;
    uint dwCommandOffset;
    uint cActions;
    uint dwsaActionsOffset;

    optional [|dwRebootMsgOffset > 0|] string dwRebootMsg with Encoding{Offset = dwRebootMsgOffset}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|dwCommandOffset > 0|] string dwCommand with Encoding{Offset = dwCommandOffset}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|dwsaActionsOffset > 0|] array<SC_ACTION_NonRpc> dwsaActions with Encoding{Offset = dwsaActionsOffset}, BinaryEncoding{Length = cActions};

    override string ToString()
    {
        return "Service Failure Actions";
    }
} with IDL{DoNotGenerate = true}, Encoding{EncodingKind = EncodingKind.Binary};

type ServiceFailureActionsA_NonRpc
{
    uint dwResetPeriod;
    uint dwRebootMsgOffset;
    uint dwCommandOffset;
    uint cActions;
    uint dwsaActionsOffset;

    optional [|dwRebootMsgOffset > 0|] string dwRebootMsg with Encoding{Offset = dwRebootMsgOffset}, BinaryEncoding{TextEncoding = TextEncoding.ASCII};
    optional [|dwCommandOffset > 0|] string dwCommand with Encoding{Offset = dwCommandOffset}, BinaryEncoding{TextEncoding = TextEncoding.ASCII};
    optional [|dwsaActionsOffset > 0|] array<SC_ACTION_NonRpc> dwsaActions with Encoding{Offset = dwsaActionsOffset}, BinaryEncoding{Length = cActions};

    override string ToString()
    {
        return "Service Failure Actions";
    }
} with IDL{DoNotGenerate = true}, Encoding{EncodingKind = EncodingKind.Binary};

type SC_ACTION_NonRpc
{
    SC_ACTION_TYPE_NonRpc Type where ValidationCheckEnumValue(InRange<SC_ACTION_TYPE_NonRpc>(value), null, true, ReferenceType.Type,
        "SCMR", "Type", "SC_ACTION_NonRpc", "0, 1, 2, 3", value);
    uint Delay;

    override string ToString()
    {
        return "Action: " + EnumToStringInSummary<SC_ACTION_TYPE_NonRpc>(Type);
    }
} with IDL{DoNotGenerate = true}, Encoding{EncodingKind = EncodingKind.Binary};

pattern SC_ACTION_TYPE_NonRpc = enum uint
{
    SC_ACTION_NONE = 0,
    SC_ACTION_RESTART = 1,
    SC_ACTION_REBOOT = 2,
    SC_ACTION_RUN_COMMAND = 3,
    ...
} with IDL{DoNotGenerate = true}, Encoding{EncodingKind = EncodingKind.Binary};

type ServiceRpcRequiredPrivilegesInfo_NonRpc
{
    uint requiredPrivilegesOffset;
    string requiredPrivileges with Encoding{Offset = requiredPrivilegesOffset}, BinaryEncoding{TextEncoding = TextEncoding.ASCII};

    override string ToString()
    {
        return "Required Privileges: " + requiredPrivileges;
    }
} with IDL{DoNotGenerate = true}, Encoding{EncodingKind = EncodingKind.Binary};

optional (binary | SERVICE_STATUS_PROCESS) RQueryServiceStatusExBufferDecoder(BOUNDED_DWORD_8K pcbBytesNeeded, binary bin)
{
    if (bin.Count < pcbBytesNeeded)
    {
        // data is not suffient to decode as structure, leave as binary
        return bin;
    }

    if (NdrDecoderFromStream<SERVICE_STATUS_PROCESS>(bin) is serviceStatusProcess:SERVICE_STATUS_PROCESS)
    {
        return serviceStatusProcess;
    }

    // if the data cannot be decoded as structure, leave it as binary
    return bin;
}

optional array<ENUM_SERVICE_STATUS> EnumServiceStatusArrayDecoder(binary data, bool isUnicode)
{
    stream s = data;

    array<ENUM_SERVICE_STATUS> ret = [];
    while (true)
    {
        /*
         * Decoding of array<ENUM_SERVICE_STATUS> depends on field lpServicesReturned in operatoin
         * according to MS-SCMR. Since field lpServicesReturned follows field field lpBuffer, so it cannot
         * use Mix-Encoding.
         * To avoid OPN code too complex, the condition to stop decoding items in array<ENUM_SERVICE_STATUS>
         * is to checks whether following binary data is valid ENUM_SERVICE_STATUS but not comparison with
         * lpServicesReturned.
         * 
         * check the name offset is valid and current state in SERVICE_STATE is valid
         */
        if (s.RemainingByteLength() > 26 && 
            s.PeekUInt(s.BitPosition, Endian.Little) < data.Count && 
            s.PeekUInt(s.BitPosition + 32, Endian.Little) < data.Count &&
            InRange<SERVICE_STATUSCurrentState>(s.PeekUInt(s.BitPosition + 96, Endian.Little)) &&
            BinaryDecoder<ENUM_SERVICE_STATUS[data, isUnicode]>(s) is item:ENUM_SERVICE_STATUS)
        {
            ret += [item];
        }
        else
        {
            break;
        }
    }
    return ret;
}

optional array<ENUM_SERVICE_STATUS_PROCESS> EnumServiceStatusProcessArrayDecoder(binary data, bool isUnicode)
{
    stream s = data;

    array<ENUM_SERVICE_STATUS_PROCESS> ret = [];
    while (true)
    {
        /*
         * Decoding of array<ENUM_SERVICE_STATUS_PROCESS> depends on field lpServicesReturned in operatoin
         * according to MS-SCMR. Since field lpServicesReturned follows field field lpBuffer, so it cannot
         * use Mix-Encoding.
         * To avoid OPN code too complex, the condition to stop decoding items in array<ENUM_SERVICE_STATUS_PROCESS>
         * is to checks whether following binary data is valid ENUM_SERVICE_STATUS_PROCESS but not comparison with
         * lpServicesReturned.
         *
         * check the name offset is valid and current state in SERVICE_STATE is valid
         */
        if (s.RemainingByteLength() > 26 && 
            s.PeekUInt(s.BitPosition, Endian.Little) < data.Count && 
            s.PeekUInt(s.BitPosition + 32, Endian.Little) < data.Count &&
            InRange<SERVICE_STATUSCurrentState>(s.PeekUInt(s.BitPosition + 96, Endian.Little)) &&
            BinaryDecoder<ENUM_SERVICE_STATUS_PROCESS[data, isUnicode]>(s) is item:ENUM_SERVICE_STATUS_PROCESS)
        {
            ret += [item];
        }
        else
        {
            break;
        }
    }
    return ret;
}

type ENUM_SERVICE_STATUS[binary Data, bool IsUnicode]
{
    uint lpServiceNameOffset;
    uint lpDisplayNameOffset;
    SERVICE_STATUS ServiceStatus;
    optional [|lpServiceNameOffset > 0|] string lpServiceName with Encoding{Offset = lpServiceNameOffset, SourceData = Data},
        BinaryEncoding{TextEncoding = IsUnicode ? TextEncoding.Unicode : TextEncoding.ASCII};
    optional [|lpDisplayNameOffset > 0|] string lpDisplayName with Encoding{Offset = lpDisplayNameOffset, SourceData = Data},
        BinaryEncoding{TextEncoding = IsUnicode ? TextEncoding.Unicode : TextEncoding.ASCII};
} with IDL{DoNotGenerate = true}, Encoding{EncodingKind = EncodingKind.Binary};

type ENUM_SERVICE_STATUSA[binary Data]
{
    LPSTR lpServiceNameOffset;
    LPSTR lpDisplayNameOffset;
    SERVICE_STATUS ServiceStatus;
    optional [|lpServiceNameOffset > 0|] string lpServiceName with Encoding{Offset = lpServiceNameOffset, SourceData = Data}, BinaryEncoding{TextEncoding = TextEncoding.ASCII};
    optional [|lpDisplayNameOffset > 0|] string lpDisplayName with Encoding{Offset = lpDisplayNameOffset, SourceData = Data}, BinaryEncoding{TextEncoding = TextEncoding.ASCII};
} with IDL{DoNotGenerate = true}, Encoding{EncodingKind = EncodingKind.Binary};

type ENUM_SERVICE_STATUS_PROCESS[binary Data, bool IsUnicode]
{
    uint lpServiceNameOffset;
    uint lpDisplayNameOffset;
    SERVICE_STATUS_PROCESS ServiceStatusProcess;
    optional [|lpServiceNameOffset > 0|] string lpServiceName with Encoding{Offset = lpServiceNameOffset, SourceData = Data},
        BinaryEncoding{TextEncoding = IsUnicode ? TextEncoding.Unicode : TextEncoding.ASCII};
    optional [|lpDisplayNameOffset > 0|] string lpDisplayName with Encoding{Offset = lpDisplayNameOffset, SourceData = Data},
        BinaryEncoding{TextEncoding = IsUnicode ? TextEncoding.Unicode : TextEncoding.ASCII};
} with IDL{DoNotGenerate = true}, Encoding{EncodingKind = EncodingKind.Binary};

optional (binary | SECURITY_DESCRIPTOR_NonRpc) SecurityDescriptorDecoder(BOUNDED_DWORD_256K bytesNeeded, array<byte> data)
{
    binary bin = data as binary;
    if (data.Count < bytesNeeded)
    {
        return bin;
    }

    if (BinaryDecoder<SECURITY_DESCRIPTOR_NonRpc>(bin) is securityDescriptor:SECURITY_DESCRIPTOR_NonRpc)
    {
        return securityDescriptor;
    }
    else
    {
        ValidationCheck(false, null, SCMR_SECURITY_DESCRIPTOR_DECODING_FAILURE);
    }
    return bin;
}

string IsLockedToText(any input)
{
    if (input is v:DWORD)
    {
        return v == 0 ? "Unlocked" : "Locked";
    }

    return "";
}

optional binary ConvertArrayCharToBinary(array<char> data)
{
    array<byte> ret = [];
    foreach (var d in data)
    {
        ret += [d as byte];
    }

    return ret as binary;
}
