module EMFPLUS with
    BinaryEncodingDefaults{Endian = Endian.Little},
Documentation
{
    ProtocolName = "Enhanced Metafile Format Plus Extensions",
    ShortName = "EMFPLUS",
    Description = ""
},
OPNAuthoring
{
    Copyright = "(c) Microsoft Corporation",
    References =
        [
            new Reference{Name = "MS-EMFPLUS", Version = "12.0", Date = "11/14/2013", ProgramName = ProgramName.MCPP},
        ],
    RevisionSummary =
        [
            new Revision{Class=RevisionClass.Major, Version="376320", Date="04/07/2015"}
        ]
};

using Utility;
using MicrosoftCommonResources;
using Diagnostics;

// 2.1.1.1 RecordType Enumeration
pattern RecordType = enum ushort
{
    EmfPlusHeader = 0x4001,
    EmfPlusEndOfFile = 0x4002,
    EmfPlusComment = 0x4003,
    EmfPlusGetDC = 0x4004,
    EmfPlusMultiFormatStart = 0x4005,
    EmfPlusMultiFormatSection = 0x4006,
    EmfPlusMultiFormatEnd = 0x4007,
    EmfPlusObject = 0x4008,
    EmfPlusClear = 0x4009,
    EmfPlusFillRects = 0x400A,
    EmfPlusDrawRects = 0x400B,
    EmfPlusFillPolygon = 0x400C,
    EmfPlusDrawLines = 0x400D,
    EmfPlusFillEllipse = 0x400E,
    EmfPlusDrawEllipse = 0x400F,
    EmfPlusFillPie = 0x4010,
    EmfPlusDrawPie = 0x4011,
    EmfPlusDrawArc = 0x4012,
    EmfPlusFillRegion = 0x4013,
    EmfPlusFillPath = 0x4014,
    EmfPlusDrawPath = 0x4015,
    EmfPlusFillClosedCurve = 0x4016,
    EmfPlusDrawClosedCurve = 0x4017,
    EmfPlusDrawCurve = 0x4018,
    EmfPlusDrawBeziers = 0x4019,
    EmfPlusDrawImage = 0x401A,
    EmfPlusDrawImagePoints = 0x401B,
    EmfPlusDrawString = 0x401C,
    EmfPlusSetRenderingOrigin = 0x401D,
    EmfPlusSetAntiAliasMode = 0x401E,
    EmfPlusSetTextRenderingHint = 0x401F,
    EmfPlusSetTextContrast = 0x4020,
    EmfPlusSetInterpolationMode = 0x4021,
    EmfPlusSetPixelOffsetMode = 0x4022,
    EmfPlusSetCompositingMode = 0x4023,
    EmfPlusSetCompositingQuality = 0x4024,
    EmfPlusSave = 0x4025,
    EmfPlusRestore = 0x4026,
    EmfPlusBeginContainer = 0x4027,
    EmfPlusBeginContainerNoParams = 0x4028,
    EmfPlusEndContainer = 0x4029,
    EmfPlusSetWorldTransform = 0x402A,
    EmfPlusResetWorldTransform = 0x402B,
    EmfPlusMultiplyWorldTransform = 0x402C,
    EmfPlusTranslateWorldTransform = 0x402D,
    EmfPlusScaleWorldTransform = 0x402E,
    EmfPlusRotateWorldTransform = 0x402F,
    EmfPlusSetPageTransform = 0x4030,
    EmfPlusResetClip = 0x4031,
    EmfPlusSetClipRect = 0x4032,
    EmfPlusSetClipPath = 0x4033,
    EmfPlusSetClipRegion = 0x4034,
    EmfPlusOffsetClip = 0x4035,
    EmfPlusDrawDriverString = 0x4036,
    EmfPlusStrokeFillPath = 0x4037,
    EmfPlusSerializableObject = 0x4038,
    EmfPlusSetTSGraphics = 0x4039,
    EmfPlusSetTSClip = 0x403A
};

// 2.1.1.2 BitmapDataType Enumeration
pattern BitmapDataType = enum uint
{
    BitmapDataTypePixel = 0x00000000,
    BitmapDataTypeCompressed = 0x00000001,
    ...
};

// 2.1.1.3 BrushType Enumeration
pattern BrushType = enum uint
{
    BrushTypeSolidColor = 0x00000000,
    BrushTypeHatchFill = 0x00000001,
    BrushTypeTextureFill = 0x00000002,
    BrushTypePathGradient = 0x00000003,
    BrushTypeLinearGradient = 0x00000004,
    ...
};

// 2.1.1.4 CombineMode Enumeration
pattern CombineMode = enum uint
{
    CombineModeReplace = 0x00000000,
    CombineModeIntersect = 0x00000001,
    CombineModeUnion = 0x00000002,
    CombineModeXOR = 0x00000003,
    CombineModeExclude = 0x00000004,
    CombineModeComplement = 0x00000005,
    ...
};

// 2.1.1.5 CompositingMode Enumeration
pattern CompositingMode = enum byte
{
    CompositingModeSourceOver = 0x00,
    CompositingModeSourceCopy = 0x01,
    ...
};

// 2.1.1.6 CompositingQuality Enumeration
pattern CompositingQuality = enum byte
{
    CompositingQualityDefault = 0x01,
    CompositingQualityHighSpeed = 0x02,
    CompositingQualityHighQuality = 0x03,
    CompositingQualityGammaCorrected = 0x04,
    CompositingQualityAssumeLinear = 0x05,
    ...
};

// 2.1.1.7 CurveAdjustments Enumeration
pattern CurveAdjustments = enum uint
{
    AdjustExposure = 0x00000000,
    AdjustDensity = 0x00000001,
    AdjustContrast = 0x00000002,
    AdjustHighlight = 0x00000003,
    AdjustShadow = 0x00000004,
    AdjustMidtone = 0x00000005,
    AdjustWhiteSaturation = 0x00000006,
    AdjustBlackSaturation = 0x00000007,
    ...
};

// 2.1.1.8 CurveChannel Enumeration
pattern CurveChannel = enum uint
{
    CurveChannelAll = 0x00000000,
    CurveChannelRed = 0x00000001,
    CurveChannelGreen = 0x00000002,
    CurveChannelBlue = 0x00000003,
    ...
};

// 2.1.1.9 CustomLineCapDataType Enumeration
pattern CustomLineCapDataType = enum uint
{
    CustomLineCapDataTypeDefault = 0x00000000,
    CustomLineCapDataTypeAdjustableArrow = 0x00000001,
    ...
};

// 2.1.1.10 DashedLineCapType Enumeration
pattern DashedLineCapType = enum uint
{
    DashedLineCapTypeFlat = 0x00000000,
    DashedLineCapTypeRound = 0x00000002,
    DashedLineCapTypeTriangle = 0x00000003,
    ...
};

// 2.1.1.11 FilterType Enumeration
pattern FilterType = enum byte
{  
    FilterTypeNone = 0x00,
    FilterTypePoint = 0x01,
    FilterTypeLinear = 0x02,
    FilterTypeTriangle = 0x03,
    FilterTypeBox = 0x04,
    FilterTypePyramidalQuad = 0x06,
    FilterTypeGaussianQuad = 0x07,
    ...
};

// 2.1.1.12 GraphicsVersion Enumeration
pattern GraphicsVersion = enum ushort
{  
    GraphicsVersion1 = 0x0001,
    GraphicsVersion1_1 = 0x0002,
    ...
};

// 2.1.1.13 HatchStyle Enumeration
pattern HatchStyle = enum uint
{
    HatchStyleHorizontal = 0x00000000,
    HatchStyleVertical = 0x00000001,
    HatchStyleForwardDiagonal = 0x00000002,
    HatchStyleBackwardDiagonal = 0x00000003,
    HatchStyleLargeGrid = 0x00000004,
    HatchStyleDiagonalCross = 0x00000005,
    HatchStyle05Percent = 0x00000006,
    HatchStyle10Percent = 0x00000007,
    HatchStyle20Percent = 0x00000008,
    HatchStyle25Percent = 0x00000009,
    HatchStyle30Percent = 0x0000000A,
    HatchStyle40Percent = 0x0000000B,
    HatchStyle50Percent = 0x0000000C,
    HatchStyle60Percent = 0x0000000D,
    HatchStyle70Percent = 0x0000000E,
    HatchStyle75Percent = 0x0000000F,
    HatchStyle80Percent = 0x00000010,
    HatchStyle90Percent = 0x00000011,
    HatchStyleLightDownwardDiagonal = 0x00000012,
    HatchStyleLightUpwardDiagonal = 0x00000013,
    HatchStyleDarkDownwardDiagonal = 0x00000014,
    HatchStyleDarkUpwardDiagonal = 0x00000015,
    HatchStyleWideDownwardDiagonal = 0x00000016,
    HatchStyleWideUpwardDiagonal = 0x00000017,
    HatchStyleLightVertical = 0x00000018,
    HatchStyleLightHorizontal = 0x00000019,
    HatchStyleNarrowVertical = 0x0000001A,
    HatchStyleNarrowHorizontal = 0x0000001B,
    HatchStyleDarkVertical = 0x0000001C,
    HatchStyleDarkHorizontal = 0x0000001D,
    HatchStyleDashedDownwardDiagonal = 0x0000001E,
    HatchStyleDashedUpwardDiagonal = 0x0000001F,
    HatchStyleDashedHorizontal = 0x00000020,
    HatchStyleDashedVertical = 0x00000021,
    HatchStyleSmallConfetti = 0x00000022,
    HatchStyleLargeConfetti = 0x00000023,
    HatchStyleZigZag = 0x00000024,
    HatchStyleWave = 0x00000025,
    HatchStyleDiagonalBrick = 0x00000026,
    HatchStyleHorizontalBrick = 0x00000027,
    HatchStyleWeave = 0x00000028,
    HatchStylePlaid = 0x00000029,
    HatchStyleDivot = 0x0000002A,
    HatchStyleDottedGrid = 0x0000002B,
    HatchStyleDottedDiamond = 0x0000002C,
    HatchStyleShingle = 0x0000002D,
    HatchStyleTrellis = 0x0000002E,
    HatchStyleSphere = 0x0000002F,
    HatchStyleSmallGrid = 0x00000030,
    HatchStyleSmallCheckerBoard = 0x00000031,
    HatchStyleLargeCheckerBoard = 0x00000032,
    HatchStyleOutlinedDiamond = 0x00000033,
    HatchStyleSolidDiamond = 0x00000034,
    ...
};

// 2.1.1.14 HotkeyPrefix Enumeration
pattern HotkeyPrefix = enum uint
{
    HotkeyPrefixNone = 0x00000000,
    HotkeyPrefixShow = 0x00000001,
    HotkeyPrefixHide = 0x00000002,
    ...
};

// 2.1.1.15 ImageDataType Enumeration
pattern ImageDataType = enum uint
{
    ImageDataTypeUnknown = 0x00000000,
    ImageDataTypeBitmap = 0x00000001,
    ImageDataTypeMetafile = 0x00000002,
    ...
};

// 2.1.1.16 InterpolationMode Enumeration
pattern InterpolationMode = enum byte
{
    InterpolationModeDefault = 0x00,
    InterpolationModeLowQuality = 0x01,
    InterpolationModeHighQuality = 0x02,
    InterpolationModeBilinear = 0x03,
    InterpolationModeBicubic = 0x04,
    InterpolationModeNearestNeighbor = 0x05,
    InterpolationModeHighQualityBilinear = 0x06,
    InterpolationModeHighQualityBicubic = 0x07,
    ...
};

// 2.1.1.17 LanguageIdentifier Enumeration
pattern LanguageIdentifier = enum ushort
{
    LANG_NEUTRAL = 0x0000,
    $"zh-CHS" = 0x0004,
    LANG_INVARIANT = 0x007F,
    LANG_NEUTRAL_USER_DEFAULT = 0x0400,
    $"ar-SA" = 0x0401,
    $"bg-BG" = 0x0402,
    $"ca-ES" = 0x0403,
    $"zh-CHT" = 0x0404,
    $"cs-CZ" = 0x0405,
    $"da-DK" = 0x0406,
    $"de-DE" = 0x0407,
    $"el-GR" = 0x0408,
    $"en-US" = 0x0409,
    $"es-Tradnl-ES" = 0x040A,
    $"fi-FI" = 0x040B,
    $"fr-FR" = 0x040C,
    $"he-IL" = 0x040D,
    $"hu-HU" = 0x040E,
    $"is-IS" = 0x040F,
    $"it-IT" = 0x0410,
    $"ja-JA" = 0x0411,
    $"ko-KR" = 0x0412,
    $"nl-NL" = 0x0413,
    $"nb-NO" = 0x0414,
    $"pl-PL" = 0x0415,
    $"pt-BR" = 0x0416,
    $"rm-CH" = 0x0417,
    $"ro-RO" = 0x0418,
    $"ru-RU" = 0x0419,
    $"hr-HR" = 0x041A,
    $"sk-SK" = 0x041B,
    $"sq-AL" = 0x041C,
    $"sv-SE" = 0x041D,
    $"th-TH" = 0x041E,
    $"tr-TR" = 0x041F,
    $"ur-PK" = 0x0420,
    $"id-ID" = 0x0421,
    $"uk-UA" = 0x0422,
    $"be-BY" = 0x0423,
    $"sl-SI" = 0x0424,
    $"et-EE" = 0x0425,
    $"lv-LV" = 0x0426,
    $"lt-LT" = 0x0427,
    $"tg-TJ" = 0x0428,
    $"fa-IR" = 0x0429,
    $"vi-VN" = 0x042A,
    $"hy-AM" = 0x042B,
    $"az-Latn-AZ" = 0x042C,
    $"eu-ES" = 0x042D,
    $"wen-DE" = 0x042E,
    $"mk-MK" = 0x042F,
    $"st-ZA" = 0x0430,
    $"tn-ZA" = 0x0432,
    $"xh-ZA" = 0x0434,
    $"zu-ZA" = 0x0435,
    $"af-ZA" = 0x0436,
    $"ka-GE" = 0x0437,
    $"fa-FA" = 0x0438,
    $"hi-IN" = 0x0439,
    $"mt-MT" = 0x043A,
    $"se-NO" = 0x043B,
    $"ga-GB" = 0x043C,
    $"ms-MY" = 0x043E,
    $"kk-KZ" = 0x043F,
    $"ky-KG" = 0x0440,
    $"sw-KE" = 0x0441,
    $"tk-TM" = 0x0442,
    $"uz-Latn-UZ" = 0x0443,
    $"tt-Ru" = 0x0444,
    $"bn-IN" = 0x0445,
    $"pa-IN" = 0x0446,
    $"gu-IN" = 0x0447,
    $"or-IN" = 0x0448,
    $"ta-IN" = 0x0449,
    $"te-IN" = 0x044A,
    $"kn-IN" = 0x044B,
    $"ml-IN" = 0x044C,
    $"as-IN" = 0x044D,
    $"mr-IN" = 0x044E,
    $"sa-IN" = 0x044F,
    $"mn-MN" = 0x0450,
    $"bo-CN" = 0x0451,
    $"cy-GB" = 0x0452,
    $"km-KH" = 0x0453,
    $"lo-LA" = 0x0454,
    $"gl-ES" = 0x0456,
    $"kok-IN" = 0x0457,
    $"sd-IN" = 0x0459,
    $"syr-SY" = 0x045A,
    $"si-LK" = 0x045B,
    $"iu-Cans-CA" = 0x045D,
    $"am-ET" = 0x045E,
    $"ne-NP" = 0x0461,
    $"fy-NL" = 0x0462,
    $"ps-AF" = 0x0463,
    $"fil-PH" = 0x0464,
    $"div-MV" = 0x0465,
    $"ha-Latn-NG" = 0x0468,
    $"yo-NG" = 0x046A,
    $"quz-BO" = 0x046B,
    $"nzo-ZA" = 0x046C,
    $"ba-RU" = 0x046D,
    $"lb-LU" = 0x046E,
    $"kl-GL" = 0x046F,
    $"ig-NG" = 0x0470,
    $"so-SO" = 0x0477,
    $"ii-CN" = 0x0478,
    $"arn-CL" = 0x047A,
    $"moh-CA" = 0x047C,
    $"br-FR" = 0x047E,
    $"ug-CN" = 0x0480,
    $"mi-NZ" = 0x0481,
    $"oc-FR" = 0x0482,
    $"co-FR" = 0x0483,
    $"gsw-FR" = 0x0484,
    $"sah-RU" = 0x0485,
    $"qut-GT" = 0x0486,
    $"rw-RW" = 0x0487,
    $"wo-SN" = 0x0488,
    $"gbz-AF" = 0x048C,
    LANG_NEUTRAL_SYS_DEFAULT = 0x0800,
    $"ar-IQ" = 0x0801,
    $"zh-CN" = 0x0804,
    $"de-CH" = 0x0807,
    $"en-GB" = 0x0809,
    $"es-MX" = 0x080A,
    $"fr-BE" = 0x080C,
    $"it-CH" = 0x0810,
    $"ko-Johab-KR" = 0x0812,
    $"nl-BE" = 0x0813,
    $"nn-NO" = 0x0814,
    $"pt-PT" = 0x0816,
    $"sr-Latn-SP" = 0x081A,
    $"sv-FI" = 0x081D,
    $"ur-IN" = 0x0820,
    $"lt-C-LT" = 0x0827,
    $"az-Cyrl-AZ" = 0x082C,
    $"wee-DE" = 0x082E,
    $"se-SE" = 0x083B,
    $"ga-IE" = 0x083C,
    $"ms-BN" = 0x083E,
    $"uz-Cyrl-UZ" = 0x0843,
    $"bn-BD" = 0x0845,
    $"mn-Mong-CN" = 0x0850,
    $"sd-PK" = 0x0859,
    $"iu-Latn-CA" = 0x085D,
    $"tzm-Latn-DZ" = 0x085F,
    $"quz-EC" = 0x086B,
    LANG_NEUTRAL_CUSTOM_DEFAULT = 0x0C00,
    $"ar-EG" = 0x0C01,
    $"zh-HK" = 0x0C04,
    $"de-AT" = 0x0C07,
    $"en-AU" = 0x0C09,
    $"es-ES" = 0x0C0A,
    $"fr-CA" = 0x0C0C,
    $"sr-Cyrl-CS" = 0x0C1A,
    $"se-FI" = 0x0C3B,
    $"quz-PE" = 0x0C6B,
    LANG_NEUTRAL_CUSTOM = 0x1000,
    $"ar-LY" = 0x1001,
    $"zh-SG" = 0x1004,
    $"de-LU" = 0x1007,
    $"en-CA" = 0x1009,
    $"es-GT" = 0x100A,
    $"fr-CH" = 0x100C,
    $"hr-BA" = 0x101A,
    $"smj-NO" = 0x103B,
    LANG_NEUTRAL_CUSTOM_DEFAULT_MUI = 0x1400,
    $"ar-DZ" = 0x1401,
    $"zh-MO" = 0x1404,
    $"de-LI" = 0x1407,
    $"en-NZ" = 0x1409,
    $"es-CR" = 0x140A,
    $"fr-LU" = 0x140C,
    $"bs-Latn-BA" = 0x141A,
    $"smj-SE" = 0x143B,
    $"ar-MA" = 0x1801,
    $"en-IE" = 0x1809,
    $"es-PA" = 0x180A,
    $"ar-MC" = 0x180C,
    $"sr-Latn-BA" = 0x181A,
    $"sma-NO" = 0x183B,
    $"ar-TN" = 0x1C01,
    $"en-ZA" = 0x1C09,
    $"es-DO" = 0x1C0A,
    $"sr-Cyrl-BA" = 0x1C1A,
    $"sma-SE" = 0x1C3B,
    $"ar-OM" = 0x2001,
    $"el-2-GR" = 0x2008,
    $"en-JM" = 0x2009,
    $"es-VE" = 0x200A,
    $"bs-Cyrl-BA" = 0x201A,
    $"sms-FI" = 0x203B,
    $"ar-YE" = 0x2401,
    $"ar-029" = 0x2409,
    $"es-CO" = 0x240A,
    $"smn-FI" = 0x243B,
    $"ar-SY" = 0x2801,
    $"en-BZ" = 0x2809,
    $"es-PE" = 0x280A,
    $"ar-JO" = 0x2C01,
    $"en-TT" = 0x2C09,
    $"es-AR" = 0x2C0A,
    $"ar-LB" = 0x3001,
    $"en-ZW" = 0x3009,
    $"es-EC" = 0x300A,
    $"ar-KW" = 0x3401,
    $"en-PH" = 0x3409,
    $"es-CL" = 0x340A,
    $"ar-AE" = 0x3801,
    $"es-UY" = 0x380A,
    $"ar-BH" = 0x3C01,
    $"es-PY" = 0x3C0A,
    $"ar-QA" = 0x4001,
    $"en-IN" = 0x4009,
    $"es-BO" = 0x400A,
    $"en-MY" = 0x4409,
    $"es-SV" = 0x440A,
    $"en-SG" = 0x4809,
    $"es-HN" = 0x480A,
    $"es-NI" = 0x4C0A,
    $"es-PR" = 0x500A,
    $"es-US" = 0x540A,
    $"zh-Hant" = 0x7C04,
    ...
};

// 2.1.1.18 LineCapType Enumeration
pattern LineCapType = enum int
{  
    LineCapTypeFlat = 0x00000000,
    LineCapTypeSquare = 0x00000001,
    LineCapTypeRound = 0x00000002,
    LineCapTypeTriangle = 0x00000003,
    LineCapTypeNoAnchor = 0x00000010,
    LineCapTypeSquareAnchor = 0x00000011,
    LineCapTypeRoundAnchor = 0x00000012,
    LineCapTypeDiamondAnchor = 0x00000013,
    LineCapTypeArrowAnchor = 0x00000014,
    LineCapTypeAnchorMask = 0x000000F0,
    LineCapTypeCustom = 0x000000FF,
    ...
};

// 2.1.1.19 LineJoinType Enumeration
pattern LineJoinType = enum int
{
    LineJoinTypeMiter = 0x00000000,
    LineJoinTypeBevel = 0x00000001,
    LineJoinTypeRound = 0x00000002,
    LineJoinTypeMiterClipped = 0x00000003,
    ...
};

// 2.1.1.20 LineStyle Enumeration
pattern LineStyle = enum int
{
    LineStyleSolid = 0x00000000,
    LineStyleDash = 0x00000001,
    LineStyleDot = 0x00000002,
    LineStyleDashDot = 0x00000003,
    LineStyleDashDotDot = 0x00000004,
    LineStyleCustom = 0x00000005,
    ...
};

// 2.1.1.21 MetafileDataType Enumeration
pattern MetafileDataType = enum uint
{
    MetafileDataTypeWmf = 0x00000001,
    MetafileDataTypeWmfPlaceable = 0x00000002,
    MetafileDataTypeEmf = 0x00000003,
    MetafileDataTypeEmfPlusOnly = 0x00000004,
    MetafileDataTypeEmfPlusDual = 0x00000005,
    ...
};

// 2.1.1.22 ObjectType Enumeration
pattern ObjectType = enum uint
{
    ObjectTypeInvalid = 0x00000000,
    ObjectTypeBrush = 0x00000001,
    ObjectTypePen = 0x00000002,
    ObjectTypePath = 0x00000003,
    ObjectTypeRegion = 0x00000004,
    ObjectTypeImage = 0x00000005,
    ObjectTypeFont = 0x00000006,
    ObjectTypeStringFormat = 0x00000007,
    ObjectTypeImageAttributes = 0x00000008,
    ObjectTypeCustomLineCap = 0x00000009,
    ...
};

// 2.1.1.23 PathPointType Enumeration
pattern PathPointTypeEnumeration = enum byte
{
    PathPointTypeStart = 0x00,
    PathPointTypeLine = 0x01,
    PathPointTypeBezier = 0x03,
    ...
};

// 2.1.1.24 PenAlignment Enumeration
pattern PenAlignment = enum uint
{
    PenAlignmentCenter = 0x00000000,
    PenAlignmentInset = 0x00000001,
    PenAlignmentLeft = 0x00000002,
    PenAlignmentOutset = 0x00000003,
    PenAlignmentRight = 0x00000004,
    ...
};

// 2.1.1.25 PixelFormat Enumeration
pattern PixelFormat = enum uint
{
    PixelFormatUndefined = 0x00000000,
    PixelFormat1bppIndexed = 0x00030101,
    PixelFormat4bppIndexed = 0x00030402,
    PixelFormat8bppIndexed = 0x00030803,
    PixelFormat16bppGrayScale = 0x00101004,
    PixelFormat16bppRGB555 = 0x00021005,
    PixelFormat16bppRGB565 = 0x00021006,
    PixelFormat16bppARGB1555 = 0x00061007,
    PixelFormat24bppRGB = 0x00021808,
    PixelFormat32bppRGB = 0x00022009,
    PixelFormat32bppARGB = 0x0026200A,
    PixelFormat32bppPARGB = 0x000E200B,
    PixelFormat48bppRGB = 0x0010300C,
    PixelFormat64bppARGB = 0x0034400D,
    PixelFormat64bppPARGB = 0x001A400E,
    ...
};

// 2.1.1.26 PixelOffsetMode Enumeration
pattern PixelOffsetMode = enum byte
{
    PixelOffsetModeDefault = 0x00,
    PixelOffsetModeHighSpeed = 0x01,
    PixelOffsetModeHighQuality = 0x02,
    PixelOffsetModeNone = 0x03,
    PixelOffsetModeHalf = 0x04,
    ...
};

// 2.1.1.27 RegionNodeDataType Enumeration
pattern RegionNodeDataType = enum uint
{
    RegionNodeDataTypeAnd = 0x00000001,
    RegionNodeDataTypeOr = 0x00000002,
    RegionNodeDataTypeXor = 0x00000003,
    RegionNodeDataTypeExclude = 0x00000004,
    RegionNodeDataTypeComplement = 0x00000005,
    RegionNodeDataTypeRect = 0x10000000,
    RegionNodeDataTypePath = 0x10000001,
    RegionNodeDataTypeEmpty = 0x10000002,
    RegionNodeDataTypeInfinite = 0x10000003,
    ...
};

// 2.1.1.28 SmoothingMode Enumeration
pattern SmoothingMode = enum byte
{
    SmoothingModeDefault = 0x00,
    SmoothingModeHighSpeed = 0x01,
    SmoothingModeHighQuality = 0x02,
    SmoothingModeNone = 0x03,
    SmoothingModeAntiAlias8x4 = 0x04,
    SmoothingModeAntiAlias8x8 = 0x05,
    ...
};

// 2.1.1.29 StringAlignment Enumeration
pattern StringAlignment = enum uint
{
    StringAlignmentNear = 0x00000000,
    StringAlignmentCenter = 0x00000001,
    StringAlignmentFar = 0x00000002,
    ...
};

// 2.1.1.30 StringDigitSubstitution Enumeration
pattern StringDigitSubstitution = enum uint
{
    StringDigitSubstitutionUser = 0x00000000,
    StringDigitSubstitutionNone = 0x00000001,
    StringDigitSubstitutionNational = 0x00000002,
    StringDigitSubstitutionTraditional = 0x00000003,
    ...
};

// 2.1.1.31 StringTrimming Enumeration
pattern StringTrimming = enum uint
{
    StringTrimmingNone = 0x00000000,
    StringTrimmingCharacter = 0x00000001,
    StringTrimmingWord = 0x00000002,
    StringTrimmingEllipsisCharacter = 0x00000003,
    StringTrimmingEllipsisWord = 0x00000004,
    StringTrimmingEllipsisPath = 0x00000005,
    ...
};

// 2.1.1.32 TextRenderingHint Enumeration
pattern TextRenderingHint = enum byte
{
    TextRenderingHintSystemDefault = 0x00,
    TextRenderingHintSingleBitPerPixelGridFit = 0x01,
    TextRenderingHintSingleBitPerPixel = 0x02,
    TextRenderingHintAntialiasGridFit = 0x03,
    TextRenderingHintAntialias = 0x04,
    TextRenderingHintClearTypeGridFit = 0x05,
    ...
};

// 2.1.1.33 UnitType Enumeration
pattern UnitType = enum byte
{
    UnitTypeWorld = 0x00,
    UnitTypeDisplay = 0x01,
    UnitTypePixel = 0x02,
    UnitTypePoint = 0x03,
    UnitTypeInch = 0x04,
    UnitTypeDocument = 0x05,
    UnitTypeMillimeter = 0x06,
    ...
};

pattern UnitType32Bit = enum uint
{
    UnitTypeWorld = 0x00000000,
    UnitTypeDisplay = 0x00000001,
    UnitTypePixel = 0x00000002,
    UnitTypePoint = 0x00000003,
    UnitTypeInch = 0x00000004,
    UnitTypeDocument = 0x00000005,
    UnitTypeMillimeter = 0x00000006,
    ...
};

// 2.1.1.34 WrapMode Enumeration
pattern WrapMode = enum uint
{
    WrapModeTile = 0x00000000,
    WrapModeTileFlipX = 0x00000001,
    WrapModeTileFlipY = 0x00000002,
    WrapModeTileFlipXY = 0x00000003,
    WrapModeClamp = 0x00000004,
    ...
};

// 2.1.2.1 BrushData Flags
pattern BrushData = flags uint
{
    BrushDataPath = 0x00000001,
    BrushDataTransform = 0x00000002,
    BrushDataPresetColors = 0x00000004,
    BrushDataBlendFactorsH = 0x00000008,
    BrushDataBlendFactorsV = 0x00000010,
    BrushDataFocusScales = 0x00000040,
    BrushDataIsGammaCorrected = 0x00000080,
    BrushDataDoNotTransform = 0x00000100,
    ...
};

// 2.1.2.2 CustomLineCapData Flags
pattern CustomLineCapData = flags uint
{
    CustomLineCapDataFillPath = 0x00000001,
    CustomLineCapDataLinePath = 0x00000002,
    ...
};

// 2.1.2.3 DriverStringOptions Flags
pattern DriverStringOptions = flags uint
{
    DriverStringOptionsCmapLookup = 0x00000001,
    DriverStringOptionsVertical = 0x00000002,
    DriverStringOptionsRealizedAdvance = 0x00000004,
    DriverStringOptionsLimitSubpixel = 0x00000008,
    ...
};

// 2.1.2.4 FontStyle Flags
pattern FontStyle = flags uint
{
    FontStyleBold = 0x00000001,
    FontStyleItalic = 0x00000002,
    FontStyleUnderline = 0x00000004,
    FontStyleStrikeout = 0x00000008,
    ...
};

// 2.1.2.5 PaletteStyle Flags
pattern PaletteStyle = flags uint
{
    PaletteStyleHasAlpha = 0x00000001,
    PaletteStyleGrayScale = 0x00000002,
    PaletteStyleHalftone = 0x00000004,
    ...
};

// 2.1.2.6 PathPointType Flags
pattern PathPointTypeFlags = flags byte
{
    PathPointTypeDashMode = 0x01,
    PathPointTypePathMarker = 0x02,
    PathPointTypeCloseSubpath = 0x08,
    ...
};

// 2.1.2.7 PenData Flags
pattern PenData = flags uint
{
    PenDataTransform = 0x00000001,
    PenDataStartCap = 0x00000002,
    PenDataEndCap = 0x00000004,
    PenDataJoin = 0x00000008,
    PenDataMiterLimit = 0x00000010,
    PenDataLineStyle = 0x00000020,
    PenDataDashedLineCap = 0x00000040,
    PenDataDashedLineOffset = 0x00000080,
    PenDataDashedLine = 0x00000100,
    PenDataNonCenter = 0x00000200,
    PenDataCompoundLine = 0x00000400,
    PenDataCustomStartCap = 0x00000800,
    PenDataCustomEndCap = 0x00001000,
    ...
};

// 2.1.2.8 StringFormat Flags
pattern StringFormat = flags uint
{
    StringFormatDirectionRightToLeft = 0x00000001,
    StringFormatDirectionVertical = 0x00000002,
    StringFormatNoFitBlackBox = 0x00000004,
    StringFormatDisplayFormatControl = 0x00000020,
    StringFormatNoFontFallback = 0x00000400,
    StringFormatMeasureTrailingSpaces = 0x00000800,
    StringFormatNoWrap = 0x00001000,
    StringFormatLineLimit = 0x00002000,
    StringFormatNoClip = 0x00004000,
    StringFormatBypassGDI = 0x80000000,
    ...
};

// 2.1.3.1 ImageEffects Identifiers
map<guid, string> ImageEffectsIdentifiersStringMap = 
{
    {633C80A4-1843-482B-9EF2-BE2834C5FDD4} -> "BlurEffectGuid",
    {D3A1DBE1-8EC4-4C17-9F4C-EA97AD1C343D} -> "BrightnessContrastEffectGuid",
    {537E597D-251E-48DA-9664-29CA496B70F8} -> "ColorBalanceEffectGuid",
    {DD6A0022-58E4-4A67-9D9B-D48EB881A53D} -> "ColorCurveEffectGuid",
    {A7CE72A9-0F7F-40D7-B3CC-D0C02D5C3212} -> "ColorLookupTableEffectGuid",
    {718F2615-7933-40E3-A511-5F68FE14DD74} -> "ColorMatrixEffectGuid",
    {8B2DD6C3-EB07-4D87-A5F0-7108E26A9C5F} -> "HueSaturationLightnessEffectGuid",
    {99C354EC-2A31-4F3A-8C34-17A803B33A25} -> "LevelsEffectGuid",
    {74D29D05-69A4-4266-9549-3CC52836B632} -> "RedEyeCorrectionEffectGuid",
    {63CBF3EE-C526-402C-8F71-62C540BF5142} -> "SharpenEffectGuid",
    {1077AF00-2848-4441-9489-44AD4C2D7A2C} -> "TintEffectGuid",
};

// 2.2.1.1 EmfPlusBrush Object
type EmfPlusBrushObject
{
    EmfPlusGraphicsVersionObject Version;
    BrushType Type where ValidationCheckEnumValueTooManyItems(InRange<BrushType>(value), null, true, ReferenceType.Type,
                    "EMFPLUS", "Type", "EmfPlusBrushObject", "BrushType Enumeration", "[MS-EMFPLUS]");
    ([|Type == BrushType.BrushTypeSolidColor|] EmfPlusSolidBrushDataObject |
    [|Type == BrushType.BrushTypeHatchFill|] EmfPlusHatchBrushDataObject |
    [|Type == BrushType.BrushTypeTextureFill|] EmfPlusTextureBrushDataObject |
    [|Type == BrushType.BrushTypePathGradient|] EmfPlusPathGradientBrushDataObject |
    [|Type == BrushType.BrushTypeLinearGradient|] EmfPlusLinearGradientBrushDataObject) BrushData;

    override string ToString()
    {
        return "EmfPlusBrushObject, " + BrushData.ToString();
    }
}

// 2.2.1.2 EmfPlusCustomLineCap Object
type EmfPlusCustomLineCapObject
{
    EmfPlusGraphicsVersionObject Version;
    CustomLineCapDataType Type where ValidationCheckEnumValue(InRange<CustomLineCapDataType>(value), null, true, ReferenceType.Type,
                    "EMFPLUS", "Type", "EmfPlusCustomLineCapObject", "0x00000000, 0x00000001", value);
    ([|Type == CustomLineCapDataType.CustomLineCapDataTypeAdjustableArrow|] EmfPlusCustomLineCapArrowDataObject |
     [|Type == CustomLineCapDataType.CustomLineCapDataTypeDefault|] EmfPlusCustomLineCapDataObject) CustomLineCapData;

    override string ToString()
    {
        return "EmfPlusCustomLineCapObject, " + EnumToString<CustomLineCapDataType>(Type);
    }
}

// 2.2.1.3 EmfPlusFont Object
type EmfPlusFontObject
{
    EmfPlusGraphicsVersionObject Version;
    float EmSize;
    UnitType32Bit SizeUnit where ValidationCheckEnumValueTooManyItems(InRange<UnitType32Bit>(value), null, true, ReferenceType.Type,
                    "EMFPLUS", "SizeUnit", "EmfPlusFontObject", "UnitType Enumeration", "[MS-EMFPLUS]");
    FontStyle FontStyleFlags where ValidationCheckCombinationValue(InRange<FontStyle>(value), null, true, ReferenceType.Type,
                    "EMFPLUS", "FontStyleFlags", "EmfPlusFontObject", "0x00000001, 0x00000002, 0x00000004, 0x00000008", value);
    uint Reserved;
    uint Length;
    string FamilyName with BinaryEncoding{TextEncoding = TextEncoding.Unicode, Length = Length};

    override string ToString()
    {
        return "EmfPlusFontObject, EmSize: " + EmSize.ToString() + ", " + EnumToString<FontStyle>(FontStyleFlags);
    }
}

// 2.2.1.4 EmfPlusImage Object
type EmfPlusImageObject
{
    EmfPlusGraphicsVersionObject Version;
    ImageDataType Type where ValidationCheckEnumValue(InRange<ImageDataType>(value), null, true, ReferenceType.Type,
                    "EMFPLUS", "Type", "EmfPlusImageObject", "0x00000000, 0x00000001, 0x00000002", value);
    ([|Type == ImageDataType.ImageDataTypeBitmap|] EmfPlusBitmapObject |
     [|Type == ImageDataType.ImageDataTypeMetafile|] EmfPlusMetafileObject | binary) ImageData;

    override string ToString()
    {
        return "EmfPlusImageObject, " + EnumToString<ImageDataType>(Type);
    }
}

// 2.2.1.5 EmfPlusImageAttributes Object
type EmfPlusImageAttributesObject
{
    EmfPlusGraphicsVersionObject Version;
    uint Reserved1;
    WrapMode WrapMode where ValidationCheckEnumValueTooManyItems(InRange<WrapMode>(value), null, true, ReferenceType.Type,
                    "EMFPLUS", "WrapMode", "EmfPlusImageAttributesObject", "WrapMode Enumeration", "[MS-EMFPLUS]");
    EmfPlusARGBObject ClampColor;
    EmfPlusImageAttributesObject_ObjectClamp ObjectClamp where ValidationCheckEnumValue(InRange<EmfPlusImageAttributesObject_ObjectClamp>(value), null, true, ReferenceType.Type,
                    "EMFPLUS", "ObjectClamp", "EmfPlusImageAttributesObject", "0x00000000, 0x00000001", value);
    uint Reserved2 where ValidationCheckZero(value == 0, null, false, ReferenceType.Type, "EMFPLUS", "Reserved2", "EmfPlusImageAttributesObject", value);

    override string ToString()
    {
        return "EmfPlusImageAttributesObject, " + EnumToString<WrapMode>(WrapMode) + ", ClampColor: " + ClampColor.ToString();
    }
}

pattern EmfPlusImageAttributesObject_ObjectClamp = enum uint
{
    RectClamp = 0x00000000,
    BitmapClamp = 0x00000001,
    ...
};

// 2.2.1.6 EmfPlusPath Object
type EmfPlusPathObject
{
    EmfPlusGraphicsVersionObject Version;
    uint PathPointCount;
    EmfPlusPathObject_PathPointFlags PathPointFlags where ValidationCheckCombinationValue(InRange<EmfPlusPathObject_PathPointFlags>(value), null, true, ReferenceType.Type,
                    "EMFPLUS", "PathPointFlags", "EmfPlusPathObject", "0x4000, 0x1000, 0x0800", value);
    ushort Reserved;
    ([|(PathPointFlags & EmfPlusPathObject_PathPointFlags.P) != 0|] array<EmfPlusPointRObject> |
     [|(PathPointFlags  & EmfPlusPathObject_PathPointFlags.C) != 0|] array<EmfPlusPointObject> |
     array<EmfPlusPointFObject>) PathPoints with BinaryEncoding{Length = PathPointCount};
    ([|(PathPointFlags & EmfPlusPathObject_PathPointFlags.R) != 0|] array<EmfPlusPathPointTypeRLEObject | EmfPlusPathPointTypeObject> | array<EmfPlusPathPointTypeObject>) PathPointTypes with BinaryEncoding{Length = PathPointCount};
    optional binary AlignmentPadding with BinaryEncoding{Length = GetPaddingLength(PathPointFlags, PathPoints, PathPointTypes)};

    override string ToString()
    {
        return "EmfPlusPathObject, PathPoints: " + PathPoints.ToString();
    }
}

uint GetPaddingLength(ushort Flags, any PathPoints, any PathPointTypes)
{
    uint length = 0;
    // If P is not set, the length of field PathPoints is 4-byte aligned.
    if ((Flags & EmfPlusPathObject_PathPointFlags.P) != 0)
    {
        array<EmfPlusPointRObject> points = PathPoints as array<EmfPlusPointRObject>;
        foreach (EmfPlusPointRObject obj in points)
        {
            length += obj.Length();
        }
    }
    array<any> pointTypes = PathPointTypes as array<any>;
    foreach (var p in pointTypes)
    {
        if (p is EmfPlusPathPointTypeRLEObject)
        {
            length += 2;
        }
        else if (p is EmfPlusPathPointTypeObject)
        {
            length += 1;
        }
    }
    length = (4 - length % 4) % 4;
    return length;
}

pattern EmfPlusPathObject_PathPointFlags = flags ushort
{
    C = 0x4000,
    R = 0x1000,
    P = 0x0800,
    ...
};

// 2.2.1.7 EmfPlusPen Object
type EmfPlusPenObject
{
    EmfPlusGraphicsVersionObject Version;
    uint Type where ValidationCheckZero(value == 0, null, true, ReferenceType.Type, "EMFPLUS", "Type", "EmfPlusPenObject", value);
    EmfPlusPenDataObject PenData;
    EmfPlusBrushObject BrushObject;

    override string ToString()
    {
        return "EmfPlusPenObject, PenData: " + PenData.ToString() + ", BrushObject: " + BrushObject.ToString();
    }
}

// 2.2.1.8 EmfPlusRegion Object
type EmfPlusRegionObject
{
    EmfPlusGraphicsVersionObject Version;
    uint RegionNodeCount;
    array<EmfPlusRegionNodeObject> RegionNode with BinaryEncoding{Length = RegionNodeCount + 1};

    override string ToString()
    {
        return "EmfPlusRegionObject, RegionNodeCount: " + RegionNodeCount.ToString() + ", RegionNode: " + RegionNode.ToString();
    }
}

// 2.2.1.9 EmfPlusStringFormat Object
type EmfPlusStringFormatObject
{
    EmfPlusGraphicsVersionObject Version;
    StringFormat StringFormatFlags where ValidationCheckCombinationValueTooManyItems(InRange<StringFormat>(value), null, true, ReferenceType.Type,
                    "EMFPLUS", "StringFormatFlags", "EmfPlusStringFormatObject", "StringFormat Flags", "[MS-EMFPLUS]");
    EmfPlusLanguageIdentifierObject Language with DisplayInfo{ToText = EmfPlusLanguageIdentifierToText};
    StringAlignment StringAlignment where ValidationCheckEnumValue(InRange<StringAlignment>(value), null, true, ReferenceType.Type,
                    "EMFPLUS", "StringAlignment", "EmfPlusStringFormatObject", "0x00000000, 0x00000001, 0x00000002", value);
    StringAlignment LineAlign where ValidationCheckEnumValue(InRange<StringAlignment>(value), null, true, ReferenceType.Type,
                    "EMFPLUS", "LineAlign", "EmfPlusStringFormatObject", "0x00000000, 0x00000001, 0x00000002", value);
    StringDigitSubstitution DigitSubstitution where ValidationCheckEnumValue(InRange<StringDigitSubstitution>(value), null, true, ReferenceType.Type,
                    "EMFPLUS", "DigitSubstitution", "EmfPlusStringFormatObject", "0x00000000, 0x00000001, 0x00000002, 0x00000003", value);
    EmfPlusLanguageIdentifierObject DigitLanguage with DisplayInfo{ToText = EmfPlusLanguageIdentifierToText};
    float FirstTabOffset;
    HotkeyPrefix HotkeyPrefix where ValidationCheckEnumValue(InRange<HotkeyPrefix>(value), null, true, ReferenceType.Type,
                    "EMFPLUS", "HotkeyPrefix", "EmfPlusStringFormatObject", "0x00000000, 0x00000001, 0x00000002", value);
    float LeadingMargin;
    float TrailingMargin;
    float Tracking;
    StringTrimming Trimming where ValidationCheckEnumValueTooManyItems(InRange<StringTrimming>(value), null, true, ReferenceType.Type,
                    "EMFPLUS", "Trimming", "EmfPlusStringFormatObject", "StringTrimming Enumeration", "[MS-EMFPLUS]");
    int TabStopCount;
    int RangeCount;
    EmfPlusStringFormatDataObject[TabStopCount, RangeCount] StringFormatData;

    override string ToString()
    {
        return "EmfPlusStringFormatObject";
    }
}

// 2.2.2.1 EmfPlusARGB Object
type EmfPlusARGBObject
{
    byte Blue;
    byte Green;
    byte Red;
    byte Alpha;

    override string ToString()
    {
        return "RGBA: (" + Red.ToString() + ", " + Green.ToString() + ", " + Blue.ToString() + ", " + Alpha.ToString() + ")";
    }
}

// 2.2.2.2 EmfPlusBitmap Object
type EmfPlusBitmapObject
{
    int Width;
    int Height;
    int Stride;
    EmfPlusBitmapObject_PixelFormat PixelFormat with DisplayInfo{ToText = PixelFormatToText};
    BitmapDataType Type where ValidationCheckEnumValue(InRange<BitmapDataType>(value), null, true, ReferenceType.Type,
                    "EMFPLUS", "Type", "EmfPlusBitmapObject", "0x00000000, 0x00000001", value);
    ([|Type == BitmapDataType.BitmapDataTypePixel|] EmfPlusBitmapDataObject[Width, Height, PixelFormat] |
     [|Type == BitmapDataType.BitmapDataTypeCompressed|] EmfPlusCompressedImageObject) BitmapData;
}

type EmfPlusBitmapObject_PixelFormat
{
    byte Reserved with BinaryEncoding{Width = 10, Endian = Endian.Big};
    bool N with BinaryEncoding{Width = 1};
    bool E with BinaryEncoding{Width = 1};
    bool P with BinaryEncoding{Width = 1};
    bool A with BinaryEncoding{Width = 1};
    bool G with BinaryEncoding{Width = 1};
    bool I with BinaryEncoding{Width = 1};
    byte BitsPerPixel;
    byte Index;
} with BinaryEncoding{WidthForComposedType = 32, DecodeAsUnit = true};

string PixelFormatToText(any data)
{
    EmfPlusBitmapObject_PixelFormat pf = data as EmfPlusBitmapObject_PixelFormat;
    uint v = pf.Index;
    v = ((pf.BitsPerPixel as uint) << 8) | v;
    v = v | (pf.I ? 0x00010000 : 0) | (pf.G ? 0x00020000 : 0) | (pf.A ? 0x00040000 : 0) | (pf.P ? 0x00080000 : 0) | (pf.E ? 0x00100000 : 0) | (pf.N ? 0x00200000 : 0);
    return EnumToString(v, "EMFPLUS.PixelFormat");
}

// 2.2.2.3 EmfPlusBitmapData Object
type EmfPlusBitmapDataObject[int width, int height, EmfPlusBitmapObject_PixelFormat pixel]
{
    optional [|pixel.I|] EmfPlusPaletteObject Colors;
    binary PixelData with BinaryEncoding{Length = (width * height * pixel.BitsPerPixel / 8)};
}

// 2.2.2.4 EmfPlusBlendColors Object
type EmfPlusBlendColorsObject
{
    uint PositionCount;
    array<float> BlendPositions where ValidationCheck((all (float x in value) x >= 0) && (all (float x in value) x <= 1), null, DiagnosisLevel.Error, EMFPLUS_STR_EmfPlusBlendColorsObject_BlendPositions)
        with BinaryEncoding{Length = PositionCount};
    array<EmfPlusARGBObject> BlendColors with BinaryEncoding{Length = PositionCount};
}
  
// 2.2.2.5 EmfPlusBlendFactors Object
type EmfPlusBlendFactorsObject
{
    uint PositionCount;
    array<float> BlendPositions with BinaryEncoding{Length = PositionCount};
    array<float> BlendColors with BinaryEncoding{Length = PositionCount};
}

// 2.2.2.6 EmfPlusBoundaryPathData Object
type EmfPlusBoundaryPathDataObject
{
    uint BoundaryPathSize;
    EmfPlusPathObject BoundaryPathData;
}

// 2.2.2.7 EmfPlusBoundaryPointData Object
type EmfPlusBoundaryPointDataObject
{
    uint BoundaryPointCount;
    array<EmfPlusPointFObject> BoundaryPointData with BinaryEncoding{Length = BoundaryPointCount};
}

// 2.2.2.8 EmfPlusCharacterRange Object
type EmfPlusCharacterRangeObject
{
    int First;
    int Length;
}

// 2.2.2.9 EmfPlusCompoundLineData Object
type EmfPlusCompoundLineDataObject
{
    uint CompoundLineDataSize;
    array<float> CompoundLineData with BinaryEncoding{Length = CompoundLineDataSize};
}

// 2.2.2.10 EmfPlusCompressedImage Object
type EmfPlusCompressedImageObject
{
    binary CompressedImageData;
}

// 2.2.2.11 EmfPlusCustomEndCapData Object
type EmfPlusCustomEndCapDataObject
{
    uint CustomEndCapSize;
    EmfPlusCustomLineCapObject CustomEndCap;
}

// 2.2.2.12 EmfPlusCustomLineCapArrowData Object
type EmfPlusCustomLineCapArrowDataObject
{
    float Width;
    float Height;
    float MiddleInset;
    Boolean32Bit FillState;
    uint LineStartCap;
    uint LineEndCap;
    uint LineJoin;
    float LineMiterLimit;
    float WidthScale;
    EmfPlusPointFObject FillHotSpot where ValidationCheck(value.X == 0 && value.Y == 0, null, DiagnosisLevel.Error, () => Format(EMFPLUS_STR_EmfPlusCustomLineCap, ["FillHotSpot", "EmfPlusCustomLineCapArrowDataObject"]));
    EmfPlusPointFObject LineHotSpot where ValidationCheck(value.X == 0 && value.Y == 0, null, DiagnosisLevel.Error, () => Format(EMFPLUS_STR_EmfPlusCustomLineCap, ["LineHotSpot", "EmfPlusCustomLineCapArrowDataObject"]));
}

// 2.2.2.13 EmfPlusCustomLineCapData Object
type EmfPlusCustomLineCapDataObject
{
    CustomLineCapData CustomLineCapDataFlags where ValidationCheckCombinationValue(InRange<CustomLineCapData>(value), null, true, ReferenceType.Type,
                    "EMFPLUS", "CustomLineCapDataFlags", "EmfPlusCustomLineCapDataObject", "0x00000001, 0x00000002", value);
    LineCapType BaseCap where ValidationCheckEnumValueTooManyItems(InRange<LineCapType>(value), null, true, ReferenceType.Type,
                    "EMFPLUS", "BaseCap", "EmfPlusCustomLineCapDataObject", "LineCapType Enumeration", "[MS-EMFPLUS]");
    float BaseInset;
    uint StrokeStartCap;
    uint StrikeEndCap;
    LineJoinType StrokeJoin where ValidationCheckEnumValue(InRange<LineJoinType>(value), null, true, ReferenceType.Type,
                    "EMFPLUS", "StrokeJoin", "EmfPlusCustomLineCapDataObject", "0x00000000, 0x00000001, 0x00000002, 0x00000003", value);
    float StrokeMiterLimit;
    float WidthScale;
    EmfPlusPointFObject FillHotSpot where ValidationCheck(value.X == 0 && value.Y == 0, null, DiagnosisLevel.Error, () => Format(EMFPLUS_STR_EmfPlusCustomLineCap, ["FillHotSpot", "EmfPlusCustomLineCapDataObject"]));
    EmfPlusPointFObject StrokeHotSpot where ValidationCheck(value.X == 0 && value.Y == 0, null, DiagnosisLevel.Error, () => Format(EMFPLUS_STR_EmfPlusCustomLineCap, ["StrokeHotSpot", "EmfPlusCustomLineCapDataObject"]));
    optional [|(CustomLineCapDataFlags & CustomLineCapData.CustomLineCapDataFillPath) != 0 
            || (CustomLineCapDataFlags & CustomLineCapData.CustomLineCapDataLinePath) != 0|] EmfPlusCustomLineCapOptionalDataObject[CustomLineCapDataFlags] OptionalData;
}

// 2.2.2.14 EmfPlusCustomLineCapOptionalData Object
type EmfPlusCustomLineCapOptionalDataObject[CustomLineCapData flag]
{
    optional [|(flag & CustomLineCapData.CustomLineCapDataFillPath) != 0|] EmfPlusFillPathObject FillData;
    optional [|(flag & CustomLineCapData.CustomLineCapDataLinePath) != 0|] EmfPlusLinePathObject OutlineData;
} 

// 2.2.2.15 EmfPlusCustomStartCapData Object
type EmfPlusCustomStartCapDataObject
{
    uint CustomStartCapSize;
    EmfPlusCustomLineCapObject CustomStartCap;
}

// 2.2.2.16 EmfPlusDashedLineData Object
type EmfPlusDashedLineDataObject
{
    uint DashedLineDataSize;
    array<float> DashedLineData with BinaryEncoding{Length = DashedLineDataSize};
}

// 2.2.2.17 EmfPlusFillPath Object
type EmfPlusFillPathObject
{
    uint FillPathLength;
    EmfPlusPathObject FillPath;
}

// 2.2.2.18 EmfPlusFocusScaleData Object
type EmfPlusFocusScaleDataObject
{
    uint FocusScaleCount where ValidationCheckValue(value == 2, null, true, ReferenceType.Type, "EMFPLUS", "FocusScaleCount", "EmfPlusFocusScaleDataObject", 2, value);
    float FocusScaleX where ValidationCheckValueInRange(value <= 1 && value >= 0, null, true, ReferenceType.Type, "EMFPLUS", "FocusScaleX", "EmfPlusFocusScaleDataObject", "0.0", "1.0", value);
    float FocusScaleY where ValidationCheckValueInRange(value <= 1 && value >= 0, null, true, ReferenceType.Type, "EMFPLUS", "FocusScaleY", "EmfPlusFocusScaleDataObject", "0.0", "1.0", value);
}

// 2.2.2.19 EmfPlusGraphicsVersion Object
type EmfPlusGraphicsVersionObject
{
    uint MetafileSignature where ValidationCheckValue(value == 0xDBC01, null, true, ReferenceType.Type, "EMFPLUS", "MetafileSignature", "EmfPlusGraphicsVersionObject", 0xDBC01, value)
        with BinaryEncoding{Width = 20, Endian = Endian.Big};
    GraphicsVersion GraphicsVersion where ValidationCheckEnumValue(InRange<GraphicsVersion>(value), null, true, ReferenceType.Type,
                    "EMFPLUS", "GraphicsVersion", "EmfPlusGraphicsVersionObject", "0x0001, 0x0002", value) with BinaryEncoding{Width = 12, Endian = Endian.Big};
} with BinaryEncoding{WidthForComposedType = 32, DecodeAsUnit = true};

// 2.2.2.20 EmfPlusHatchBrushData Object
type EmfPlusHatchBrushDataObject
{
    HatchStyle HatchStyle where ValidationCheckEnumValueTooManyItems(InRange<HatchStyle>(value), null, true, ReferenceType.Type,
                    "EMFPLUS", "HatchStyle", "EmfPlusHatchBrushDataObject", "HatchStyle Enumeration", "[MS-EMFPLUS]");
    EmfPlusARGBObject ForeColor;
    EmfPlusARGBObject BackColor;

    override string ToString()
    {
        return "EmfPlusHatchBrushDataObject, " + EnumToString<HatchStyle>(HatchStyle) + ", ForeColor: " + ForeColor.ToString() + ", BackColor: " + BackColor.ToString();
    }
}

// 2.2.2.21 EmfPlusInteger7 Object
type EmfPlusInteger7Object
{
    byte Zero where value == 0 with BinaryEncoding{Width = 1};
    sbyte Value with BinaryEncoding{Width = 7};

    override string ToString()
    {
        return Value.ToString();
    }
}

// 2.2.2.22 EmfPlusInteger15 Object
type EmfPlusInteger15Object
{
    byte One where value == 1 with BinaryEncoding{Width = 1};
    short Value with BinaryEncoding{Width = 15, Endian = Endian.Big};

    override string ToString()
    {
        return Value.ToString();
    }
} with BinaryEncoding{WidthForComposedType = 16, DecodeAsUnit = true};

// 2.2.2.23 EmfPlusLanguageIdentifier Object
type EmfPlusLanguageIdentifierObject
{
    byte SubLanguageId with BinaryEncoding{Width = 6};
    ushort PrimaryLanguageId with BinaryEncoding{Width = 10, Endian = Endian.Big};
} with BinaryEncoding{WidthForComposedType = 16, DecodeAsUnit = true};

string EmfPlusLanguageIdentifierToText(any data)
{
    EmfPlusLanguageIdentifierObject obj = data as EmfPlusLanguageIdentifierObject;
    ushort languageId = (obj.PrimaryLanguageId | (obj.SubLanguageId as ushort) << 10) as ushort;
    return EnumToString(languageId, "EMFPLUS.LanguageIdentifier");
}

// 2.2.2.24 EmfPlusLinearGradientBrushData Object
type EmfPlusLinearGradientBrushDataObject
{
    BrushData BrushDataFlags where ValidationCheckCombinationValueTooManyItems(InRange<BrushData>(value), null, true, ReferenceType.Type,
                    "EMFPLUS", "BrushDataFlags", "EmfPlusLinearGradientBrushDataObject", "BrushData Flags", "[MS-EMFPLUS]");
    WrapMode WrapMode where ValidationCheckEnumValueTooManyItems(InRange<WrapMode>(value), null, true, ReferenceType.Type,
                    "EMFPLUS", "WrapMode", "EmfPlusLinearGradientBrushDataObject", "WrapMode Enumeration", "[MS-EMFPLUS]");
    EmfPlusRectFObject RectF;
    EmfPlusARGBObject StartColor;
    EmfPlusARGBObject EndColor;
    uint Reserved1;
    uint Reserved2;
    optional [|(BrushDataFlags & BrushData.BrushDataTransform) != 0 || 
               (BrushDataFlags & BrushData.BrushDataPresetColors) != 0 ||
               (BrushDataFlags & BrushData.BrushDataBlendFactorsH) != 0 || 
               (BrushDataFlags & BrushData.BrushDataBlendFactorsV) != 0|] EmfPlusLinearGradientBrushOptionalDataObject[BrushDataFlags] OptionalData;

    override string ToString()
    {
        return "EmfPlusLinearGradientBrushDataObject, " + EnumToString<BrushData>(BrushDataFlags) + ", " + EnumToString<WrapMode>(WrapMode);
    }
}

// 2.2.2.25 EmfPlusLinearGradientBrushOptionalData Object
type EmfPlusLinearGradientBrushOptionalDataObject[BrushData flag]
{
    optional [|(flag & BrushData.BrushDataTransform) != 0|] EmfPlusTransformMatrixObject TransformMatrix;
    optional ([|(flag & BrushData.BrushDataPresetColors) != 0|] EmfPlusLinearGradientBrushOptionalDataObject
            | [|(flag & BrushData.BrushDataBlendFactorsH) != 0 && (flag & BrushData.BrushDataBlendFactorsV) != 0|] array<EmfPlusBlendFactorsObject>
            | [|(flag & BrushData.BrushDataBlendFactorsH) != 0 || (flag & BrushData.BrushDataBlendFactorsV) != 0|] EmfPlusBlendFactorsObject) BlendPattern with BinaryEncoding{Length = 2};
}

// 2.2.2.26 EmfPlusLinePath Object
type EmfPlusLinePathObject
{
    uint LinePathLength;
    EmfPlusPathObject LinePath;
}

// 2.2.2.27 EmfPlusMetafile Object
type EmfPlusMetafileObject
{
    MetafileDataType Type where ValidationCheckEnumValueTooManyItems(InRange<MetafileDataType>(value), null, true, ReferenceType.Type,
                    "EMFPLUS", "Type", "EmfPlusMetafileObject", "MetafileDataType Enumeration", "[MS-EMFPLUS]");
    uint MetafileDataSize;
    binary MetafileData with BinaryEncoding{Length = MetafileDataSize};
}

// 2.2.2.28 EmfPlusPalette Object
type EmfPlusPaletteObject
{
    PaletteStyle PaletteStyleFlags where ValidationCheckCombinationValue(InRange<PaletteStyle>(value), null, true, ReferenceType.Type,
                    "EMFPLUS", "PaletteStyleFlags", "EmfPlusPaletteObject", "0x00000001, 0x00000002, 0x00000004", value);
    uint PaletteCount;
    array<EmfPlusARGBObject> PaletteEntries with BinaryEncoding{Length = PaletteCount};
}

// 2.2.2.29 EmfPlusPathGradientBrushData Object
type EmfPlusPathGradientBrushDataObject
{
    BrushData BrushDataFlags where ValidationCheckCombinationValueTooManyItems(InRange<BrushData>(value), null, true, ReferenceType.Type,
                    "EMFPLUS", "BrushDataFlags", "EmfPlusPathGradientBrushDataObject", "BrushData Flags", "[MS-EMFPLUS]");
    WrapMode WrapMode where ValidationCheckEnumValueTooManyItems(InRange<WrapMode>(value), null, true, ReferenceType.Type,
                    "EMFPLUS", "WrapMode", "EmfPlusPathGradientBrushDataObject", "WrapMode Enumeration", "[MS-EMFPLUS]");
    EmfPlusARGBObject CenterColor;
    EmfPlusPointFObject CenterPointF;
    uint SurroundingColorCount;
    ([|(BrushDataFlags & BrushData.BrushDataPath) != 0|] EmfPlusBoundaryPathDataObject | EmfPlusBoundaryPointDataObject) BoundaryData;
    optional [|(BrushDataFlags & BrushData.BrushDataTransform) != 0 ||
               (BrushDataFlags & BrushData.BrushDataPresetColors) != 0 ||
               (BrushDataFlags & BrushData.BrushDataBlendFactorsH) != 0 || 
               (BrushDataFlags & BrushData.BrushDataFocusScales) != 0|] EmfPlusPathGradientBrushOptionalDataObject[BrushDataFlags] OptionalData;

    override string ToString()
    {
        return "EmfPlusPathGradientBrushDataObject, " + EnumToString<BrushData>(BrushDataFlags) + ", " + EnumToString<WrapMode>(WrapMode);
    }
}

// 2.2.2.30 EmfPlusPathGradientBrushOptionalData Object
type EmfPlusPathGradientBrushOptionalDataObject[BrushData flag]
{
    optional [|(flag & BrushData.BrushDataTransform) != 0|] EmfPlusTransformMatrixObject TransformMatrix;
    optional ([|(flag & BrushData.BrushDataPresetColors) != 0 && (flag & BrushData.BrushDataBlendFactorsH) == 0|] EmfPlusBlendColorsObject
            | [|(flag & BrushData.BrushDataPresetColors) == 0 && (flag & BrushData.BrushDataBlendFactorsH) != 0|] EmfPlusBlendFactorsObject) BlendPattern;
    optional [|(flag & BrushData.BrushDataFocusScales) != 0|] EmfPlusFocusScaleDataObject FocusScaleData;
}

// 2.2.2.31 EmfPlusPathPointType Object
type EmfPlusPathPointTypeObject
{
    PathPointTypeFlags Flags where ValidationCheckCombinationValue(InRange<PathPointTypeFlags>(value), null, true, ReferenceType.Type,
                    "EMFPLUS", "Flags", "EmfPlusPathPointTypeObject", "0x01, 0x02, 0x08", value) with BinaryEncoding{Width = 4};
    PathPointTypeEnumeration Type where ValidationCheckEnumValue(InRange<PathPointTypeEnumeration>(value), null, true, ReferenceType.Type,
                    "EMFPLUS", "Type", "EmfPlusPathPointTypeObject", "0x00, 0x01, 0x03", value) with BinaryEncoding{Width = 4};
}

// 2.2.2.32 EmfPlusPathPointTypeRLE Object
type EmfPlusPathPointTypeRLEObject
{
    bool B with BinaryEncoding{Width = 1};
    byte One where value == 1 with BinaryEncoding{Width = 1};
    byte RunCount with BinaryEncoding{Width = 6};
    EmfPlusPathPointTypeObject PointType;
}

// 2.2.2.33 EmfPlusPenData Object
type EmfPlusPenDataObject
{
    PenData PenDataFlags where ValidationCheckCombinationValueTooManyItems(InRange<PenData>(value), null, true, ReferenceType.Type,
                    "EMFPLUS", "PenDataFlags", "EmfPlusPenDataObject", "PenData Flags", "[MS-EMFPLUS]");
    UnitType PenUnit where ValidationCheckEnumValueTooManyItems(InRange<UnitType>(value), null, true, ReferenceType.Type,
                    "EMFPLUS", "UnitType", "EmfPlusPenDataObject", "UnitType Enumeration", "[MS-EMFPLUS]");
    float PenWidth;
    optional [|PenDataFlags != 0|] EmfPlusPenOptionalDataObject[PenDataFlags] OptionalData;

    override string ToString()
    {
        return "EmfPlusPenDataObject, " + EnumToString<PenData>(PenDataFlags) + ", " + EnumToString<UnitType>(PenUnit);
    }
}

// 2.2.2.34 EmfPlusPenOptionalData Object
type EmfPlusPenOptionalDataObject[PenData flag]
{
    optional [|(flag & PenData.PenDataTransform) != 0|] EmfPlusTransformMatrixObject TransformMatrix;
    optional [|(flag & PenData.PenDataStartCap) != 0|] LineCapType StartCap where ValidationCheckEnumValueTooManyItems(value != nothing && InRange<LineCapType>(value as LineCapType), null, true, ReferenceType.Type,
                    "EMFPLUS", "StartCap", "EmfPlusPenOptionalDataObject", "LineCapType Enumeration", "[MS-EMFPLUS]");
    optional [|(flag & PenData.PenDataEndCap) != 0|] LineCapType EndCap where ValidationCheckEnumValueTooManyItems(value != nothing && InRange<LineCapType>(value as LineCapType), null, true, ReferenceType.Type,
                    "EMFPLUS", "EndCap", "EmfPlusPenOptionalDataObject", "LineCapType Enumeration", "[MS-EMFPLUS]");
    optional [|(flag & PenData.PenDataJoin) != 0|] LineJoinType Join where ValidationCheckEnumValue(value != nothing && InRange<LineJoinType>(value as LineJoinType), null, true, ReferenceType.Type,
                    "EMFPLUS", "Join", "EmfPlusPenOptionalDataObject", "0x00000000, 0x00000001, 0x00000002, 0x00000003", value);
    optional [|(flag & PenData.PenDataMiterLimit) != 0|] float MiterLimit;
    optional [|(flag & PenData.PenDataLineStyle) != 0|] LineStyle LineStyle where ValidationCheckEnumValueTooManyItems(value != nothing && InRange<LineStyle>(value as LineStyle), null, true, ReferenceType.Type,
                    "EMFPLUS", "LineStyle", "EmfPlusPenOptionalDataObject", "LineStyle Enumeration", "[MS-EMFPLUS]");
    optional [|(flag & PenData.PenDataDashedLineCap) != 0|] DashedLineCapType DashedLineCapType where ValidationCheckEnumValue(value != nothing && InRange<DashedLineCapType>(value as DashedLineCapType), null, true, ReferenceType.Type,
                    "EMFPLUS", "DashedLineCapType", "EmfPlusPenOptionalDataObject", "0x00000000, 0x00000002, 0x00000003", value);
    optional [|(flag & PenData.PenDataDashedLineOffset) != 0|] float DashOffset;
    optional [|(flag & PenData.PenDataDashedLine) != 0|] EmfPlusDashedLineDataObject DashedLineData;
    optional [|(flag & PenData.PenDataNonCenter) != 0|] PenAlignment PenAlignment where ValidationCheckEnumValueTooManyItems(value != nothing && InRange<PenAlignment>(value as PenAlignment), null, true, ReferenceType.Type,
                    "EMFPLUS", "PenAlignment", "EmfPlusPenOptionalDataObject", "PenAlignment Enumeration", "[MS-EMFPLUS]");
    optional [|(flag & PenData.PenDataCompoundLine) != 0|] EmfPlusCompoundLineDataObject CompoundLineData;
    optional [|(flag & PenData.PenDataCustomStartCap) != 0|] EmfPlusCustomStartCapDataObject CustomStartCapData;
    optional [|(flag & PenData.PenDataCustomEndCap) != 0|] EmfPlusCustomEndCapDataObject CustomEndCapData;
}

// 2.2.2.35 EmfPlusPoint Object
type EmfPlusPointObject
{
    short X;
    short Y;

    override string ToString()
    {
        return "X: " + X.ToString() + ", Y: " + Y.ToString();
    }
}

// 2.2.2.36 EmfPlusPointF Object
type EmfPlusPointFObject
{
    float X;
    float Y;

    override string ToString()
    {
        return "X: " + X.ToString() + ", Y: " + Y.ToString();
    }
}

// 2.2.2.37 EmfPlusPointR Object
type EmfPlusPointRObject
{
    (EmfPlusInteger7Object | EmfPlusInteger15Object) X;
    (EmfPlusInteger7Object | EmfPlusInteger15Object) Y;
    
    uint Length()
    {
        uint length = (X is EmfPlusInteger7Object) ? 1 : 2;
        length += (Y is EmfPlusInteger7Object) ? 1 : 2;
        return length;
    }

    override string ToString()
    {
        return "X: " + X.ToString() + ", Y: " + Y.ToString();
    }
}

// 2.2.2.38 EmfPlusRect Object
type EmfPlusRectObject
{
    short X;
    short Y;
    short Width;
    short Height;

    override string ToString()
    {
        return "X: " + X.ToString() + ", Y: " + Y.ToString() + "Width: " + Width.ToString() + "Height: " + Height.ToString();
    }
}

// 2.2.2.39 EmfPlusRectF Object
type EmfPlusRectFObject
{
    float X;
    float Y;
    float Width;
    float Height;

    override string ToString()
    {
        return "X: " + X.ToString() + ", Y: " + Y.ToString() + "Width: " + Width.ToString() + "Height: " + Height.ToString();
    }
}

// 2.2.2.40 EmfPlusRegionNode Object
type EmfPlusRegionNodeObject
{
    RegionNodeDataType Type where ValidationCheckEnumValueTooManyItems(InRange<RegionNodeDataType>(value), null, true, ReferenceType.Type,
                    "EMFPLUS", "Type", "EmfPlusRegionNodeObject", "RegionNodeDataType Enumeration", "[MS-EMFPLUS]");
    optional ([|Type == RegionNodeDataType.RegionNodeDataTypeAnd || 
                Type == RegionNodeDataType.RegionNodeDataTypeOr ||
                Type == RegionNodeDataType.RegionNodeDataTypeXor ||
                Type == RegionNodeDataType.RegionNodeDataTypeExclude ||
                Type == RegionNodeDataType.RegionNodeDataTypeComplement|] EmfPlusRegionNodeChildNodesObject |
              [|Type == RegionNodeDataType.RegionNodeDataTypeRect|] EmfPlusRectFObject |
              [|Type == RegionNodeDataType.RegionNodeDataTypePath|] EmfPlusRegionNodePathObject) RegionNodeData;

    override string ToString()
    {
        return EnumToString<RegionNodeDataType>(Type);
    }
}

// 2.2.2.41 EmfPlusRegionNodeChildNodes Object
type EmfPlusRegionNodeChildNodesObject
{
    EmfPlusRegionNodeObject Left;
    EmfPlusRegionNodeObject Right;
}

// 2.2.2.42 EmfPlusRegionNodePath Object
type EmfPlusRegionNodePathObject
{
    uint RegionNodePathLength;
    EmfPlusPathObject RegionNodePath;
}

// 2.2.2.43 EmfPlusSolidBrushData Object
type EmfPlusSolidBrushDataObject
{
    EmfPlusARGBObject SolidColor;

    override string ToString()
    {
        return "EmfPlusSolidBrushDataObject, SolidColor: " + SolidColor.ToString();
    }
}

// 2.2.2.44 EmfPlusStringFormatData Object
type EmfPlusStringFormatDataObject[int TabStopCount, int RangeCount]
{
    optional [|TabStopCount > 0|] array<float> TabStops with BinaryEncoding{Length = TabStopCount};
    optional [|RangeCount > 0|] array<EmfPlusCharacterRangeObject> CharRange with BinaryEncoding{Length = RangeCount};
}

// 2.2.2.45 EmfPlusTextureBrushData Object
type EmfPlusTextureBrushDataObject
{
    BrushData BrushDataFlags where ValidationCheckCombinationValueTooManyItems(InRange<BrushData>(value), null, true, ReferenceType.Type,
                    "EMFPLUS", "BrushDataFlags", "EmfPlusTextureBrushDataObject", "BrushData Flags", "[MS-EMFPLUS]");
    WrapMode WrapMode where ValidationCheckEnumValueTooManyItems(InRange<WrapMode>(value), null, true, ReferenceType.Type,
                    "EMFPLUS", "WrapMode", "EmfPlusTextureBrushDataObject", "WrapMode Enumeration", "[MS-EMFPLUS]");
    optional EmfPlusTextureBrushOptionalDataObject[BrushDataFlags] OptionalData;

    override string ToString()
    {
        return "EmfPlusTextureBrushDataObject, " + EnumToString<BrushData>(BrushDataFlags) + ", " + EnumToString<WrapMode>(WrapMode);
    }
}

// 2.2.2.46 EmfPlusTextureBrushOptionalData Object
type EmfPlusTextureBrushOptionalDataObject[BrushData flag]
{
    optional [|(flag & BrushData.BrushDataTransform) != 0|] EmfPlusTransformMatrixObject TransformMatrix;
    optional EmfPlusImageObject ImageObject;
}

// 2.2.2.47 EmfPlusTranformMatrix object
type EmfPlusTransformMatrixObject
{
    array<uint> TransformMatrix with BinaryEncoding{Length = 6};
}

// 2.2.3.1 BlurEffect Object
type BlurEffectObject
{
    float BlurRadius where ValidationCheckValueInRange(value <= 255 && value >= 0, null, true, ReferenceType.Type, "EMFPLUS", "BlurRadius", "BlurEffectObject", "0.0", "255.0", value);
    Boolean32Bit ExpandEdge;
}

pattern Boolean32Bit = enum uint
{
    FALSE = 0x00000000,
    TRUE = 0x00000001,
    ...
};

// 2.2.3.2 BrightnessContrastEffect Object
type BrightnessContrastEffectObject
{
    int BrightnessLevel where ValidationCheckValueInRange(value <= 255 && value >= -255, null, true, ReferenceType.Type, "EMFPLUS", "BrightnessLevel", "BrightnessContrastEffectObject", -255, 255, value);
    int ContrastLevel where ValidationCheckValueInRange(value <= 100 && value >= -100, null, true, ReferenceType.Type, "EMFPLUS", "ContrastLevel", "BrightnessContrastEffectObject", -100, 100, value);
}

// 2.2.3.3 ColorBalanceEffect Object
type ColorBalanceEffectObject
{
    int CyanRed where ValidationCheckValueInRange(value <= 100 && value >= -100, null, true, ReferenceType.Type, "EMFPLUS", "CyanRed", "ColorBalanceEffectObject", -100, 100, value);
    int MagentaGreen where ValidationCheckValueInRange(value <= 100 && value >= -100, null, true, ReferenceType.Type, "EMFPLUS", "MagentaGreen", "ColorBalanceEffectObject", -100, 100, value);
    int YellowBlue where ValidationCheckValueInRange(value <= 100 && value >= -100, null, true, ReferenceType.Type, "EMFPLUS", "YellowBlue", "ColorBalanceEffectObject", -100, 100, value);
}

// 2.2.3.4 ColorCurveEffect Object
type ColorCurveEffectObject
{
    CurveAdjustments CurveAdjustment where ValidationCheckEnumValueTooManyItems(InRange<CurveAdjustments>(value), null, true, ReferenceType.Type,
                    "EMFPLUS", "CurveAdjustments", "ColorCurveEffectObject", "CurveAdjustments Enumeration", "[MS-EMFPLUS]");
    CurveChannel CurveChannel where ValidationCheckEnumValue(InRange<CurveChannel>(value), null, true, ReferenceType.Type,
                    "EMFPLUS", "CurveChannel", "ColorCurveEffectObject", "0x00000000, 0x00000001, 0x00000002, 0x00000003", value);
    int AdjustmentIntensity;
}

// 2.2.3.5 ColorLookupTableEffect Object
type ColorLookupTableEffectObject
{
    binary BlueLookupTable with BinaryEncoding{Length = 256};
    binary GreenLookupTable with BinaryEncoding{Length = 256};
    binary RedLookupTable with BinaryEncoding{Length = 256};
    binary AlphaLookupTable with BinaryEncoding{Length = 256};
}

// 2.2.3.6 ColorMatrixEffect Object
type ColorMatrixEffectObject
{
    array<uint> Matrix_N_0 with BinaryEncoding{Length = 5};
    array<uint> Matrix_N_1 with BinaryEncoding{Length = 5};
    array<uint> Matrix_N_2 with BinaryEncoding{Length = 5};
    array<uint> Matrix_N_3 with BinaryEncoding{Length = 5};
    array<uint> Matrix_N_4 with BinaryEncoding{Length = 5};
}

// 2.2.3.7 HueSaturationLightnessEffect Object
type HueSaturationLightnessEffectObject
{
    int HueLevel where ValidationCheckValueInRange(value <= 180 && value >= -180, null, true, ReferenceType.Type, "EMFPLUS", "HueLevel", "HueSaturationLightnessEffectObject", -180, 180, value);
    int SaturationLevel where ValidationCheckValueInRange(value <= 100 && value >= -100, null, true, ReferenceType.Type, "EMFPLUS", "SaturationLevel", "HueSaturationLightnessEffectObject", -100, 100, value);
    int LightnessLevel where ValidationCheckValueInRange(value <= 100 && value >= -100, null, true, ReferenceType.Type, "EMFPLUS", "LightnessLevel", "HueSaturationLightnessEffectObject", -100, 100, value);
}

// 2.2.3.8 LevelsEffect Object
type LevelsEffectObject
{
    int Highlight where ValidationCheckValueInRange(value <= 100 && value >= 0, null, true, ReferenceType.Type, "EMFPLUS", "Highlight", "LevelsEffectObject", 0, 100, value);
    int MidTone where ValidationCheckValueInRange(value <= 100 && value >= -100, null, true, ReferenceType.Type, "EMFPLUS", "MidTone", "LevelsEffectObject", -100, 100, value);
    int Shadow where ValidationCheckValueInRange(value <= 100 && value >= 0, null, true, ReferenceType.Type, "EMFPLUS", "Shadow", "LevelsEffectObject", 0, 100, value);
}

// 2.2.3.9 RedEyeCorrectionEffect Object
type RedEyeCorrectionEffectObject
{
    int NumberOfAreas;
    optional [|NumberOfAreas >= 0|] array<RectLObject> Areas with BinaryEncoding{Length = NumberOfAreas};
}

// [MS-WMF] 2.2.2.19 RectL Object
type RectLObject
{
    int Left;
    int Top;
    int Right;
    int Bottom;
}

// 2.2.3.10 SharpenEffect Object
type SharpenEffectObject
{
    float Radius;
    int Amount where ValidationCheckValueInRange(value <= 100 && value >= 0, null, true, ReferenceType.Type, "EMFPLUS", "Amount", "SharpenEffectObject", 0, 100, value);
}

// 2.2.3.11 TintEffect Object
type TintEffectObject
{
    int Hue where ValidationCheckValueInRange(value <= 180 && value >= -180, null, true, ReferenceType.Type, "EMFPLUS", "Hue", "TintEffectObject", -180, 180, value);
    int Amount where ValidationCheckValueInRange(value <= 100 && value >= -100, null, true, ReferenceType.Type, "EMFPLUS", "Amount", "TintEffectObject", -100, 100, value);
}

// 2.3.1 Clipping Record Types
pattern ClippingRecord = EmfPlusOffsetClipRecord |
                         EmfPlusResetClipRecord |
                         EmfPlusSetClipPathRecord |
                         EmfPlusSetClipRectRecord |
                         EmfPlusSetClipRegionRecord;

// 2.3.1.1 EmfPlusOffsetClip Record
type EmfPlusOffsetClipRecord
{
    RecordType Type where value == RecordType.EmfPlusOffsetClip;
    ushort Flags;
    uint Size where ValidationCheckValue(value == 0x00000014, null, true, ReferenceType.Type, "EMFPLUS", "Size", "EmfPlusOffsetClipRecord", 0x00000014, value);
    uint DataSize where ValidationCheckValue(value == 0x00000008, null, true, ReferenceType.Type, "EMFPLUS", "DataSize", "EmfPlusOffsetClipRecord", 0x00000008, value);
    float dx;
    float dy;

    override string ToString()
    {
        return "EmfPlusOffsetClipRecord, dx: " + dx.ToString() + ", dy: " + dy.ToString();
    }
}

// 2.3.1.2 EmfPlusResetClip Record
type EmfPlusResetClipRecord
{
    RecordType Type where value == RecordType.EmfPlusResetClip;
    ushort Flags;
    uint Size where ValidationCheckValue(value == 0x0000000C, null, true, ReferenceType.Type, "EMFPLUS", "Size", "EmfPlusResetClipRecord", 0x0000000C, value);
    uint DataSize where ValidationCheckZero(value == 0, null, true, ReferenceType.Type, "EMFPLUS", "DataSize", "EmfPlusResetClipRecord", value);

    override string ToString()
    {
        return "EmfPlusResetClipRecord";
    }
}

// 2.3.1.3 EmfPlusSetClipPath Record
type EmfPlusSetClipPathRecord
{
    RecordType Type where value == RecordType.EmfPlusSetClipPath;
    EmfPlusSetClipPathRecord_Flags Flags;
    uint Size where ValidationCheckValue(value == 0x0000000C, null, true, ReferenceType.Type, "EMFPLUS", "Size", "EmfPlusSetClipPathRecord", 0x0000000C, value);
    uint DataSize where ValidationCheckZero(value == 0, null, true, ReferenceType.Type, "EMFPLUS", "DataSize", "EmfPlusSetClipPathRecord", value);

    override string ToString()
    {
        return "EmfPlusSetClipPathRecord, " + Flags.ToString();
    }
}

type EmfPlusSetClipPathRecord_Flags
{
    byte Reserved with BinaryEncoding{Width = 4};
    CombineMode CM where ValidationCheckEnumValueTooManyItems(InRange<CombineMode>(value), null, true, ReferenceType.Type,
                    "EMFPLUS", "CM", "EmfPlusSetClipPathRecord_Flags", "CombineMode Enumeration", "[MS-EMFPLUS]") with BinaryEncoding{Width = 4};
    byte ObjectID where ValidationCheckValueInRange(value <= 63 && value >= 0, null, true, ReferenceType.Type, "EMFPLUS", "ObjectID", "EmfPlusSetClipPathRecord_Flags", 0, 63, value);

    override string ToString()
    {
        return EnumToString<CombineMode>(CM) + ", ObjectID: " + ObjectID.ToString();
    }
} with BinaryEncoding{WidthForComposedType = 16, DecodeAsUnit = true};

// 2.3.1.4 EmfPlusSetClipRect Record
type EmfPlusSetClipRectRecord
{
    RecordType Type where value == RecordType.EmfPlusSetClipRect;
    EmfPlusSetClipRectRecord_Flags Flags;
    uint Size where ValidationCheckValue(value == 0x0000001C, null, true, ReferenceType.Type, "EMFPLUS", "Size", "EmfPlusSetClipRectRecord", 0x0000001C, value);
    uint DataSize where ValidationCheckValue(value == 0x00000010, null, true, ReferenceType.Type, "EMFPLUS", "DataSize", "EmfPlusSetClipRectRecord", 0x00000010, value);
    EmfPlusRectFObject ClipRect;

    override string ToString()
    {
        return "EmfPlusSetClipRectRecord, " + Flags.ToString();
    }
}

type EmfPlusSetClipRectRecord_Flags
{
    byte Reserved1 with BinaryEncoding{Width = 4};
    CombineMode CM where ValidationCheckEnumValueTooManyItems(InRange<CombineMode>(value), null, true, ReferenceType.Type,
                    "EMFPLUS", "CM", "EmfPlusSetClipRectRecord_Flags", "CombineMode Enumeration", "[MS-EMFPLUS]") with BinaryEncoding{Width = 4};
    ushort Reserved2;

    override string ToString()
    {
        return EnumToString<CombineMode>(CM);
    }
} with BinaryEncoding{WidthForComposedType = 16, DecodeAsUnit = true};

// 2.3.1.5 EmfPlusSetClipRegion Record
type EmfPlusSetClipRegionRecord
{
    RecordType Type where value == RecordType.EmfPlusSetClipRegion;
    EmfPlusSetClipRegionRecord_Flags Flags;
    uint Size where ValidationCheckValue(value == 0x0000001C, null, true, ReferenceType.Type, "EMFPLUS", "Size", "EmfPlusSetClipRegionRecord", 0x0000001C, value);
    uint DataSize where ValidationCheckValue(value == 0x00000010, null, true, ReferenceType.Type, "EMFPLUS", "DataSize", "EmfPlusSetClipRegionRecord", 0x00000010, value);

    override string ToString()
    {
        return "EmfPlusSetClipRegionRecord, " + Flags.ToString();
    }
}

type EmfPlusSetClipRegionRecord_Flags
{
    byte Reserved with BinaryEncoding{Width = 4};
    CombineMode CM where ValidationCheckEnumValueTooManyItems(InRange<CombineMode>(value), null, true, ReferenceType.Type,
                    "EMFPLUS", "CM", "EmfPlusSetClipRegionRecord_Flags", "CombineMode Enumeration", "[MS-EMFPLUS]") with BinaryEncoding{Width = 4};
    byte ObjectID where ValidationCheckValueInRange(value <= 63 && value >= 0, null, true, ReferenceType.Type, "EMFPLUS", "ObjectID", "EmfPlusSetClipRegionRecord_Flags", 0, 63, value);

    override string ToString()
    {
        return EnumToString<CombineMode>(CM) + ", ObjectID: " + ObjectID.ToString();
    }
} with BinaryEncoding{WidthForComposedType = 16, DecodeAsUnit = true};

// 2.3.2 Comment Record Type
pattern CommentRecord = EmfPlusCommentRecord;

// 2.3.2.1 EmfPlusComment Record
type EmfPlusCommentRecord
{
    RecordType Type where value == RecordType.EmfPlusComment;
    ushort Flags where ValidationCheckZero(value == 0, null, false, ReferenceType.Type, "EMFPLUS", "Flags", "EmfPlusCommentRecord", value);
    uint Size;
    uint DataSize;
    binary PrivateData with BinaryEncoding{Length = DataSize};

    override string ToString()
    {
        return "EmfPlusCommentRecord";
    }
}

// 2.3.3 Control Record Types
pattern ControlRecord = EmfPlusEndOfFileRecord |
                        EmfPlusGetDCRecord |
                        EmfPlusHeaderRecord;

// 2.3.3.1 EmfPlusEndOfFile Record
type EmfPlusEndOfFileRecord
{
    RecordType Type where value == RecordType.EmfPlusEndOfFile;
    ushort Flags where ValidationCheckZero(value == 0, null, false, ReferenceType.Type, "EMFPLUS", "Flags", "EmfPlusEndOfFileRecord", value);
    uint Size where ValidationCheckValue(value == 0x0000000C, null, true, ReferenceType.Type, "EMFPLUS", "Size", "EmfPlusEndOfFileRecord", 0x0000000C, value);
    uint DataSize where ValidationCheckZero(value == 0, null, true, ReferenceType.Type, "EMFPLUS", "DataSize", "EmfPlusEndOfFileRecord", value);

    override string ToString()
    {
        return "EmfPlusEndOfFileRecord";
    }
}

// 2.3.3.2 EmfPlusGetDC Record
type EmfPlusGetDCRecord
{
    RecordType Type where value == RecordType.EmfPlusGetDC;
    ushort Flags where ValidationCheckZero(value == 0, null, false, ReferenceType.Type, "EMFPLUS", "Flags", "EmfPlusGetDCRecord", value);
    uint Size where ValidationCheckValue(value == 0x0000000C, null, true, ReferenceType.Type, "EMFPLUS", "Size", "EmfPlusGetDCRecord", 0x0000000C, value);
    uint DataSize where ValidationCheckZero(value == 0, null, true, ReferenceType.Type, "EMFPLUS", "DataSize", "EmfPlusGetDCRecord", value);

    override string ToString()
    {
        return "EmfPlusGetDCRecord";
    }
}

// 2.3.3.3 EmfPlusHeader Record
type EmfPlusHeaderRecord
{
    RecordType Type where value == RecordType.EmfPlusHeader;
    EmfPlusHeaderRecord_Flags Flags where ValidationCheckCombinationValue(InRange<EmfPlusHeaderRecord_Flags>(value), null, true, ReferenceType.Type,
                    "EMFPLUS", "Flags", "EmfPlusHeaderRecord", "0x0001", value);
    uint Size where ValidationCheckValue(value == 0x0000001C, null, true, ReferenceType.Type, "EMFPLUS", "Size", "EmfPlusHeaderRecord", 0x0000001C, value);
    uint DataSize where ValidationCheckValue(value == 0x00000010, null, true, ReferenceType.Type, "EMFPLUS", "DataSize", "EmfPlusHeaderRecord", 0x00000010, value);
    EmfPlusGraphicsVersionObject Version;
    EmfPlusHeaderRecord_EmfPlusFlags EmfPlusFlags where ValidationCheckCombinationValue(InRange<EmfPlusHeaderRecord_EmfPlusFlags>(value), null, true, ReferenceType.Type,
                    "EMFPLUS", "EmfPlusFlags", "EmfPlusHeaderRecord", "0x00000001", value);
    uint LogicalDpiX;
    uint LogicalDpiY;

    override string ToString()
    {
        return "EmfPlusHeaderRecord, LogicalDpiX: " + LogicalDpiX.ToString() + ", LogicalDpiY: " + LogicalDpiY.ToString();
    }
}

pattern EmfPlusHeaderRecord_Flags = flags ushort
{
    D = 0x0001,
    ...
};

pattern EmfPlusHeaderRecord_EmfPlusFlags = flags uint
{
    V = 0x00000001,
    ...
};

// 2.3.4 Drawing Record Types
pattern DrawingRecord = EmfPlusClearRecord |
                        EmfPlusDrawArcRecord |
                        EmfPlusDrawBeziersRecord |
                        EmfPlusDrawClosedCurveRecord |
                        EmfPlusDrawCurveRecord |
                        EmfPlusDrawDriverStringRecord |
                        EmfPlusDrawEllipseRecord | 
                        EmfPlusDrawImageRecord | 
                        EmfPlusDrawImagePointsRecord | 
                        EmfPlusDrawLinesRecord |
                        EmfPlusDrawPathRecord |
                        EmfPlusDrawPieRecord |
                        EmfPlusDrawRectsRecord |
                        EmfPlusDrawStringRecord |
                        EmfPlusFillClosedCurveRecord |
                        EmfPlusFillEllipseRecord |
                        EmfPlusFillPathRecord |
                        EmfPlusFillPieRecord |
                        EmfPlusFillPolygonRecord |
                        EmfPlusFillRectsRecord |
                        EmfPlusFillRegionRecord;

// 2.3.4.1 EmfPlusClear Record
type EmfPlusClearRecord
{
    RecordType Type where value == RecordType.EmfPlusClear;
    ushort Flags where ValidationCheckZero(value == 0, null, false, ReferenceType.Type, "EMFPLUS", "Flags", "EmfPlusClearRecord", value);
    uint Size where ValidationCheckValue(value == 0x00000010, null, true, ReferenceType.Type, "EMFPLUS", "Size", "EmfPlusClearRecord", 0x00000010, value);
    uint DataSize where ValidationCheckValue(value == 0x00000004, null, true, ReferenceType.Type, "EMFPLUS", "DataSize", "EmfPlusClearRecord", 0x00000004, value);
    EmfPlusARGBObject Color;

    override string ToString()
    {
        return "EmfPlusClearRecord, Color: " + Color.ToString();
    }
}

// 2.3.4.2 EmfPlusDrawArc Record
type EmfPlusDrawArcRecord
{
    RecordType Type where value == RecordType.EmfPlusDrawArc;
    EmfPlusDrawArcRecord_Flags Flags;
    uint Size where ValidationCheck((Flags.C && value == 0x0000001C) || (!Flags.C && value == 0x00000024), null, DiagnosisLevel.Error, () => Format(EMFPLUS_STR_EmfPlusDrawRecord_C1, 
        ["Size", "EmfPlusDrawArcRecord", 0x0000001C, 0x00000024]));
    uint DataSize where ValidationCheck((Flags.C && value == 0x00000010) || (!Flags.C && value == 0x00000018), null, DiagnosisLevel.Error, () => Format(EMFPLUS_STR_EmfPlusDrawRecord_C1, 
        ["DataSize", "EmfPlusDrawArcRecord", 0x00000010, 0x00000018]));
    float StartAngle;
    float SweepAngle;
    ([|Flags.C|] EmfPlusRectObject | EmfPlusRectFObject) RectData;

    override string ToString()
    {
        return "EmfPlusDrawArcRecord, StartAngle: " + StartAngle.ToString() + ", SweepAngle: " + SweepAngle.ToString() + ", " + RectData.ToString();
    }
}

type EmfPlusDrawArcRecord_Flags
{
    byte Reserved1 with BinaryEncoding{Width = 1};
    bool C with BinaryEncoding{Width = 1};
    byte Reserved2 with BinaryEncoding{Width = 6};
    byte ObjectID where ValidationCheckValueInRange(value <= 63 && value >= 0, null, true, ReferenceType.Type, "EMFPLUS", "ObjectID", "EmfPlusDrawArcRecord_Flags", 0, 63, value);
} with BinaryEncoding{WidthForComposedType = 16, DecodeAsUnit = true};

// 2.3.4.3 EmfPlusDrawBeziers Record
type EmfPlusDrawBeziersRecord
{
    RecordType Type where value == RecordType.EmfPlusDrawBeziers;
    EmfPlusDrawBeziersRecord_Flags Flags;
    uint Size where ValidationCheck((Flags.P && value >= 0x00000018) || (!Flags.P && Flags.C && value >= 0x00000020) || (!Flags.P && !Flags.C && value >= 0x00000030), null, 
        DiagnosisLevel.Error, () => Format(EMFPLUS_STR_EmfPlusDrawRecord_CP2, ["Size", "EmfPlusDrawBeziersRecord", 0x00000018, 0x00000020, 0x00000030]));
    uint DataSize where ValidationCheck((Flags.P && value >= 0x0000000C) || (!Flags.P && Flags.C && value >= 0x00000014) || (!Flags.P && !Flags.C && value >= 0x00000024), null, 
        DiagnosisLevel.Error, () => Format(EMFPLUS_STR_EmfPlusDrawRecord_CP2, ["DataSize", "EmfPlusDrawBeziersRecord", 0x0000000C, 0x00000014, 0x00000024]));
    uint Count where ValidationCheckGreaterThanOrEqualTo(value >= 4, null, true, ReferenceType.Type, "EMFPLUS", "Count", "EmfPlusDrawBeziersRecord", 4, value);
    ([|Flags.P|] array<EmfPlusPointRObject> |
     [|!Flags.P && Flags.C|] array<EmfPlusPointObject> |
     array<EmfPlusPointFObject>) PointData with BinaryEncoding{Length = Count};

    override string ToString()
    {
        return "EmfPlusDrawBeziersRecord,  " + PointData.ToString();
    }
}

type EmfPlusDrawBeziersRecord_Flags
{
    byte Reserved1 with BinaryEncoding{Width = 1};
    bool C with BinaryEncoding{Width = 1};
    byte Reserved2 with BinaryEncoding{Width = 2};
    bool P with BinaryEncoding{Width = 1};
    byte Reserved3 with BinaryEncoding{Width = 3};
    byte ObjectID;
} with BinaryEncoding{WidthForComposedType = 16, DecodeAsUnit = true};

// 2.3.4.4 EmfPlusDrawClosedCurve Record
type EmfPlusDrawClosedCurveRecord
{
    RecordType Type where value == RecordType.EmfPlusDrawClosedCurve;
    EmfPlusDrawClosedCurveRecord_Flags Flags;
    uint Size where ValidationCheck((Flags.P && value >= 0x0000001C) || (!Flags.P && Flags.C && value >= 0x00000020) || (!Flags.P && !Flags.C && value >= 0x0000002C), null, 
        DiagnosisLevel.Error, () => Format(EMFPLUS_STR_EmfPlusDrawRecord_CP2, ["Size", "EmfPlusDrawClosedCurveRecord", 0x0000001C, 0x00000020, 0x0000002C]));
    uint DataSize where ValidationCheck((Flags.P && value >= 0x00000010) || (!Flags.P && Flags.C && value >= 0x00000014) || (!Flags.P && !Flags.C && value >= 0x00000020), null, 
        DiagnosisLevel.Error, () => Format(EMFPLUS_STR_EmfPlusDrawRecord_CP2, ["DataSize", "EmfPlusDrawClosedCurveRecord", 0x00000010, 0x00000014, 0x00000020]));
    float Tension;
    uint Count where ValidationCheckGreaterThanOrEqualTo(value >= 3, null, true, ReferenceType.Type, "EMFPLUS", "Count", "EmfPlusDrawClosedCurveRecord", 3, value);
    ([|Flags.P|] array<EmfPlusPointRObject> |
     [|!Flags.P && Flags.C|] array<EmfPlusPointObject> |
     array<EmfPlusPointFObject>) PointData with BinaryEncoding{Length = Count};

    override string ToString()
    {
        return "EmfPlusDrawClosedCurveRecord,  " + PointData.ToString();
    }
}

type EmfPlusDrawClosedCurveRecord_Flags
{
    byte Reserved1 with BinaryEncoding{Width = 1};
    bool C with BinaryEncoding{Width = 1};
    byte Reserved2 with BinaryEncoding{Width = 2};
    bool P with BinaryEncoding{Width = 1};
    byte Reserved3 with BinaryEncoding{Width = 3};
    byte ObjectID;
} with BinaryEncoding{WidthForComposedType = 16, DecodeAsUnit = true};

// 2.3.4.5 EmfPlusDrawCurve Record
type EmfPlusDrawCurveRecord
{
    RecordType Type where value == RecordType.EmfPlusDrawCurve;
    EmfPlusDrawCurveRecord_Flags Flags;
    uint Size where ValidationCheck((Flags.C && value >= 0x00000024) || (!Flags.C && value >= 0x0000002C), null, 
        DiagnosisLevel.Error, () => Format(EMFPLUS_STR_EmfPlusDrawRecord_C2, ["Size", "EmfPlusDrawCurveRecord", 0x00000024, 0x0000002C]));
    uint DataSize where ValidationCheck((Flags.C && value >= 0x00000018) || (!Flags.C && value >= 0x00000020), null, 
        DiagnosisLevel.Error, () => Format(EMFPLUS_STR_EmfPlusDrawRecord_C2, ["DataSize", "EmfPlusDrawCurveRecord", 0x00000018, 0x00000020]));
    float Tension;
    uint Offset;
    uint NumSegments;
    uint Count where ValidationCheckGreaterThanOrEqualTo(value >= 2, null, true, ReferenceType.Type, "EMFPLUS", "Count", "EmfPlusDrawCurveRecord", 2, value);
    ([|Flags.C|] array<EmfPlusPointObject> | array<EmfPlusPointFObject>) PointData with BinaryEncoding{Length = Count};

    override string ToString()
    {
        return "EmfPlusDrawCurveRecord,  " + PointData.ToString();
    }
}

type EmfPlusDrawCurveRecord_Flags
{
    byte Reserved1 with BinaryEncoding{Width = 1};
    bool C with BinaryEncoding{Width = 1};
    byte Reserved2 with BinaryEncoding{Width = 6};
    byte ObjectID;
} with BinaryEncoding{WidthForComposedType = 16, DecodeAsUnit = true};

// 2.3.4.6 EmfPlusDrawDriverString Record
type EmfPlusDrawDriverStringRecord
{
    RecordType Type where value == RecordType.EmfPlusDrawDriverString;
    EmfPlusDrawDriverStringRecord_Flags Flags;
    uint Size where ValidationCheckGreaterThanOrEqualTo(value >= 0x0000001C, null, true, ReferenceType.Type, "EMFPLUS", "Size", "EmfPlusDrawDriverStringRecord", 0x0000001C, value);
    uint DataSize where ValidationCheckGreaterThanOrEqualTo(value >= 0x00000010, null, true, ReferenceType.Type, "EMFPLUS", "DataSize", "EmfPlusDrawDriverStringRecord", 0x00000010, value);
    ([|Flags.S|] EmfPlusARGBObject | uint) BrushId;
    DriverStringOptions DriverStringOptionsFlags where ValidationCheckCombinationValue(InRange<DriverStringOptions>(value), null, true, ReferenceType.Type,
                    "EMFPLUS", "DriverStringOptionsFlags", "EmfPlusDrawDriverStringRecord", "0x00000001, 0x00000002, 0x00000004, 0x00000008", value);
    uint MatrixPresent;
    uint GlyphCount;
    ([|(DriverStringOptionsFlags & DriverStringOptions.DriverStringOptionsCmapLookup ) != 0|] string | array<ushort>) Glyphs with BinaryEncoding{Length = GlyphCount, TextEncoding = TextEncoding.Unicode};
    array<EmfPlusPointFObject> GlyphPos with BinaryEncoding{Length = GlyphCount};
    optional [|MatrixPresent == 0x00000001|] EmfPlusTransformMatrixObject TransformMatrix;

    override string ToString()
    {
        return "EmfPlusDrawDriverStringRecord";
    }
}

type EmfPlusDrawDriverStringRecord_Flags
{
    bool S with BinaryEncoding{Width = 1};
    byte Reserved with BinaryEncoding{Width = 7};
    byte ObjectID;
} with BinaryEncoding{WidthForComposedType = 16, DecodeAsUnit = true};

// 2.3.4.7 EmfPlusDrawEllipse Record
type EmfPlusDrawEllipseRecord
{
    RecordType Type where value == RecordType.EmfPlusDrawEllipse;
    EmfPlusDrawEllipseRecord_Flags Flags;
    uint Size where ValidationCheck((Flags.C && value == 0x00000014) || (!Flags.C && value == 0x0000001C), null, 
        DiagnosisLevel.Error, () => Format(EMFPLUS_STR_EmfPlusDrawRecord_C1, ["Size", "EmfPlusDrawEllipseRecord", 0x00000014, 0x0000001C]));
    uint DataSize where ValidationCheck((Flags.C && value == 0x00000008) || (!Flags.C && value == 0x00000010), null, 
        DiagnosisLevel.Error, () => Format(EMFPLUS_STR_EmfPlusDrawRecord_C1, ["DataSize", "EmfPlusDrawEllipseRecord", 0x00000008, 0x00000010]));
    ([|Flags.C|] EmfPlusRectObject | EmfPlusRectFObject) RectData;

    override string ToString()
    {
        return "EmfPlusDrawEllipseRecord, RectData: " + RectData.ToString();
    }
}

type EmfPlusDrawEllipseRecord_Flags
{
    byte Reserved1 with BinaryEncoding{Width = 1};
    bool C with BinaryEncoding{Width = 1};
    byte Reserved2 with BinaryEncoding{Width = 6};
    byte ObjectID;
} with BinaryEncoding{WidthForComposedType = 16, DecodeAsUnit = true};

// 2.3.4.8 EmfPlusDrawImage Record
type EmfPlusDrawImageRecord
{
    RecordType Type where value == RecordType.EmfPlusDrawImage;
    EmfPlusDrawImageRecord_Flags Flags;
    uint Size where ValidationCheck((Flags.C && value == 0x0000002C) || (!Flags.C && value == 0x00000034), null, 
        DiagnosisLevel.Error, () => Format(EMFPLUS_STR_EmfPlusDrawRecord_C1, ["Size", "EmfPlusDrawImageRecord", 0x0000002C, 0x00000034]));
    uint DataSize where ValidationCheck((Flags.C && value == 0x00000020) || (!Flags.C && value == 0x00000028), null, 
        DiagnosisLevel.Error, () => Format(EMFPLUS_STR_EmfPlusDrawRecord_C1, ["DataSize", "EmfPlusDrawImageRecord", 0x00000020, 0x00000028]));
    uint ImageAttributesID;
    UnitType32Bit SrcUnit where ValidationCheckValue(value == UnitType32Bit.UnitTypePixel, null, true, ReferenceType.Type, "EMFPLUS", "SrcUnit", "EmfPlusDrawImageRecord", 0x00000002, value);
    EmfPlusRectFObject SrcRect;
    ([|Flags.C|] EmfPlusRectObject | EmfPlusRectFObject) RectData;

    override string ToString()
    {
        return "EmfPlusDrawImageRecord, SrcRect: " + SrcRect.ToString() + ", RectData: " + RectData.ToString();
    }
}

type EmfPlusDrawImageRecord_Flags
{
    byte Reserved1 with BinaryEncoding{Width = 1};
    bool C with BinaryEncoding{Width = 1};
    byte Reserved2 with BinaryEncoding{Width = 6};
    byte ObjectID;
} with BinaryEncoding{WidthForComposedType = 16, DecodeAsUnit = true};

// 2.3.4.9 EmfPlusDrawImagePoints Record
type EmfPlusDrawImagePointsRecord
{
    RecordType Type where value == RecordType.EmfPlusDrawImagePoints;
    EmfPlusDrawImagePointsRecord_Flags Flags;
    uint Size where ValidationCheck((Flags.P && value == 0x00000030) || (!Flags.P && Flags.C && value == 0x00000034) || (!Flags.P && !Flags.C && value == 0x00000040), null, 
        DiagnosisLevel.Error, () => Format(EMFPLUS_STR_EmfPlusDrawRecord_CP1, ["Size", "EmfPlusDrawImagePointsRecord", 0x00000030, 0x00000034, 0x00000040]));
    uint DataSize where ValidationCheck((Flags.P && value == 0x00000024) || (!Flags.P && Flags.C && value == 0x00000028) || (!Flags.P && !Flags.C && value == 0x00000034), null, 
        DiagnosisLevel.Error, () => Format(EMFPLUS_STR_EmfPlusDrawRecord_CP1, ["DataSize", "EmfPlusDrawImagePointsRecord", 0x00000024, 0x00000028, 0x00000034]));
    uint ImageAttributesID;
    UnitType32Bit SrcUnit where ValidationCheckValue(value == UnitType32Bit.UnitTypePixel, null, true, ReferenceType.Type, "EMFPLUS", "SrcUnit", "EmfPlusDrawImagePointsRecord", 0x00000002, value);
    EmfPlusRectFObject SrcRect;
    uint Count where ValidationCheckValue(value == 3, null, true, ReferenceType.Type, "EMFPLUS", "Count", "EmfPlusDrawImagePointsRecord", 3, value);
    ([|Flags.P|] array<EmfPlusPointRObject> |
     [|!Flags.P && Flags.C|] array<EmfPlusPointObject> |
     array<EmfPlusPointFObject>) PointData with BinaryEncoding{Length = Count};

    override string ToString()
    {
        return "EmfPlusDrawImagePointsRecord, SrcRect: " + SrcRect.ToString() + ", PointData: " + PointData.ToString();
    }
}

type EmfPlusDrawImagePointsRecord_Flags
{
    byte Reserved1 with BinaryEncoding{Width = 1};
    bool C with BinaryEncoding{Width = 1};
    bool E with BinaryEncoding{Width = 1};
    byte Reserved2 with BinaryEncoding{Width = 1};
    bool P with BinaryEncoding{Width = 1};
    byte Reserved3 with BinaryEncoding{Width = 3};
    byte ObjectID;
} with BinaryEncoding{WidthForComposedType = 16, DecodeAsUnit = true};

// 2.3.4.10 EmfPlusDrawLines Record
type EmfPlusDrawLinesRecord
{
    RecordType Type where value == RecordType.EmfPlusDrawLines;
    EmfPlusDrawLinesRecord_Flags Flags;
    uint Size where ValidationCheck((Flags.P && value >= 0x00000014) || (!Flags.P && Flags.C && value >= 0x00000018) || (!Flags.P && !Flags.C && value >= 0x00000020), null, 
        DiagnosisLevel.Error, () => Format(EMFPLUS_STR_EmfPlusDrawRecord_CP2, ["Size", "EmfPlusDrawLinesRecord", 0x00000014, 0x00000018, 0x00000020]));
    uint DataSize where ValidationCheck((Flags.P && value >= 0x00000008) || (!Flags.P && Flags.C && value >= 0x0000000C) || (!Flags.P && !Flags.C && value >= 0x00000014), null, 
        DiagnosisLevel.Error, () => Format(EMFPLUS_STR_EmfPlusDrawRecord_CP2, ["DataSize", "EmfPlusDrawLinesRecord", 0x00000008, 0x0000000C, 0x00000014]));
    uint Count where ValidationCheckGreaterThanOrEqualTo(value >= 2, null, true, ReferenceType.Type, "EMFPLUS", "Count", "EmfPlusDrawLinesRecord", 2, value);
    ([|Flags.P|] array<EmfPlusPointRObject> |
     [|!Flags.P && Flags.C|] array<EmfPlusPointObject> |
     array<EmfPlusPointFObject>) PointData with BinaryEncoding{Length = Count};

    override string ToString()
    {
        return "EmfPlusDrawLinesRecord, PointData: " + PointData.ToString();
    }
}

type EmfPlusDrawLinesRecord_Flags
{
    byte Reserved1 with BinaryEncoding{Width = 1};
    bool C with BinaryEncoding{Width = 1};
    bool L with BinaryEncoding{Width = 1};
    byte Reserved2 with BinaryEncoding{Width = 1};
    bool P with BinaryEncoding{Width = 1};
    byte Reserved3 with BinaryEncoding{Width = 3};
    byte ObjectID;
} with BinaryEncoding{WidthForComposedType = 16, DecodeAsUnit = true};

// 2.3.4.11 EmfPlusDrawPath Record
type EmfPlusDrawPathRecord
{
    RecordType Type where value == RecordType.EmfPlusDrawPath;
    EmfPlusDrawPathRecord_Flags Flags;
    uint Size where ValidationCheckValue(value == 0x00000010, null, true, ReferenceType.Type, "EMFPLUS", "Size", "EmfPlusDrawPathRecord", 0x00000010, value);
    uint DataSize where ValidationCheckValue(value == 0x00000004, null, true, ReferenceType.Type, "EMFPLUS", "DataSize", "EmfPlusDrawPathRecord", 0x00000004, value);
    uint PenId;

    override string ToString()
    {
        return "EmfPlusDrawPathRecord, PenId: " + PenId.ToString();
    }
}

type EmfPlusDrawPathRecord_Flags
{
    byte Reserved;
    byte ObjectId;
} with BinaryEncoding{WidthForComposedType = 16, DecodeAsUnit = true};

// 2.3.4.12 EmfPlusDrawPie Record
type EmfPlusDrawPieRecord
{
    RecordType Type where value == RecordType.EmfPlusDrawPie;
    EmfPlusDrawPieRecord_Flags Flags;
    uint Size where ValidationCheck((Flags.C && value == 0x0000001C) || (!Flags.C && value == 0x00000024), null, 
        DiagnosisLevel.Error, () => Format(EMFPLUS_STR_EmfPlusDrawRecord_C1, ["Size", "EmfPlusDrawPieRecord", 0x0000001C, 0x00000024]));
    uint DataSize where ValidationCheck((Flags.C && value == 0x00000010) || (!Flags.C && value == 0x00000018), null, 
        DiagnosisLevel.Error, () => Format(EMFPLUS_STR_EmfPlusDrawRecord_C1, ["DataSize", "EmfPlusDrawPieRecord", 0x00000010, 0x00000018]));
    float StartAngle;
    float SweepAngle;
    ([|Flags.C|] EmfPlusRectObject | EmfPlusRectFObject) RectData;

    override string ToString()
    {
        return "EmfPlusDrawPieRecord, StartAngle: " + StartAngle.ToString() + ", SweepAngle: " + SweepAngle.ToString() + ", RectData: " + RectData.ToString();
    }
}

type EmfPlusDrawPieRecord_Flags
{
    byte Reserved1 with BinaryEncoding{Width = 1};
    bool C with BinaryEncoding{Width = 1};
    byte Reserved2 with BinaryEncoding{Width = 6};
    byte ObjectID;
} with BinaryEncoding{WidthForComposedType = 16, DecodeAsUnit = true};

// 2.3.4.13 EmfPlusDrawRects Record
type EmfPlusDrawRectsRecord
{
    RecordType Type where value == RecordType.EmfPlusDrawRects;
    EmfPlusDrawRectsRecord_Flags Flags;
    uint Size where ValidationCheck((Flags.C && value >= 0x00000018) || (!Flags.C && value >= 0x00000020), null, 
        DiagnosisLevel.Error, () => Format(EMFPLUS_STR_EmfPlusDrawRecord_C2, ["Size", "EmfPlusDrawRectsRecord", 0x00000018, 0x00000020]));
    uint DataSize where ValidationCheck((Flags.C && value >= 0x0000000C) || (!Flags.C && value >= 0x00000014), null, 
        DiagnosisLevel.Error, () => Format(EMFPLUS_STR_EmfPlusDrawRecord_C2, ["DataSize", "EmfPlusDrawRectsRecord", 0x0000000C, 0x00000014]));
    int Count;
    ([|Flags.C|] array<EmfPlusRectObject> | array<EmfPlusRectFObject>) RectData with BinaryEncoding{Length = Count};

    override string ToString()
    {
        return "EmfPlusDrawRectsRecord, RectData: " + RectData.ToString();
    }
}

type EmfPlusDrawRectsRecord_Flags
{
    byte Reserved1 with BinaryEncoding{Width = 1};
    bool C with BinaryEncoding{Width = 1};
    byte Reserved2 with BinaryEncoding{Width = 6};
    byte ObjectID;
} with BinaryEncoding{WidthForComposedType = 16, DecodeAsUnit = true};

// 2.3.4.14 EmfPlusDrawString Record
type EmfPlusDrawStringRecord
{
    RecordType Type where value == RecordType.EmfPlusDrawString;
    EmfPlusDrawStringRecord_Flags Flags;
    uint Size where ValidationCheckGreaterThanOrEqualTo(value >= 0x0000002A, null, true, ReferenceType.Type, "EMFPLUS", "Size", "EmfPlusDrawStringRecord", 0x0000002A, value);
    uint DataSize where ValidationCheckGreaterThanOrEqualTo(value >= 0x0000001E, null, true, ReferenceType.Type, "EMFPLUS", "DataSize", "EmfPlusDrawStringRecord", 0x0000001E, value);
    ([|Flags.S|] EmfPlusARGBObject | uint) BrushId;
    uint FormatID;
    uint Length;
    EmfPlusRectFObject LayoutRect;
    string StringData with BinaryEncoding{TextEncoding = TextEncoding.Unicode, Length = Length};

    override string ToString()
    {
        return "EmfPlusDrawStringRecord, BrushId: " + BrushId.ToString() + ", FormatID: " + FormatID.ToString();
    }
}

type EmfPlusDrawStringRecord_Flags
{
    bool S with BinaryEncoding{Width = 1};
    byte Reserved with BinaryEncoding{Width = 7};
    byte ObjectID;
} with BinaryEncoding{WidthForComposedType = 16, DecodeAsUnit = true};

// 2.3.4.15 EmfPlusFillClosedCurve Record
type EmfPlusFillClosedCurveRecord
{
    RecordType Type where value == RecordType.EmfPlusFillClosedCurve;
    EmfPlusFillClosedCurveRecord_Flags Flags where ValidationCheckCombinationValueTooManyItems(InRange<EmfPlusFillClosedCurveRecord_Flags>(value), null, true, ReferenceType.Type,
                    "EMFPLUS", "Flags", "EmfPlusFillClosedCurveRecord", "EmfPlusFillClosedCurveRecord", "[MS-EMFPLUS]");
    uint Size where ValidationCheck(((Flags & EmfPlusFillClosedCurveRecord_Flags.P) != 0 && value >= 0x00000020) || 
        ((Flags & EmfPlusFillClosedCurveRecord_Flags.P) == 0 && (Flags & EmfPlusFillClosedCurveRecord_Flags.C) != 0 && value >= 0x00000024) || 
        ((Flags & EmfPlusFillClosedCurveRecord_Flags.P) == 0 && (Flags & EmfPlusFillClosedCurveRecord_Flags.C) == 0 && value >= 0x00000030), null, 
        DiagnosisLevel.Error, () => Format(EMFPLUS_STR_EmfPlusDrawRecord_CP2, ["Size", "EmfPlusFillClosedCurveRecord", 0x00000020, 0x00000024, 0x00000030]));
    uint DataSize where ValidationCheck(((Flags & EmfPlusFillClosedCurveRecord_Flags.P) != 0 && value >= 0x00000014) || 
        ((Flags & EmfPlusFillClosedCurveRecord_Flags.P) == 0 && (Flags & EmfPlusFillClosedCurveRecord_Flags.C) != 0 && value >= 0x00000018) || 
        ((Flags & EmfPlusFillClosedCurveRecord_Flags.P) == 0 && (Flags & EmfPlusFillClosedCurveRecord_Flags.C) == 0 && value >= 0x00000024), null, 
        DiagnosisLevel.Error, () => Format(EMFPLUS_STR_EmfPlusDrawRecord_CP2, ["DataSize", "EmfPlusFillClosedCurveRecord", 0x00000014, 0x00000018, 0x00000024]));
    ([|(Flags & EmfPlusFillClosedCurveRecord_Flags.S) != 0|] EmfPlusARGBObject | uint) BrushId;
    float Tension;
    uint Count where ValidationCheckGreaterThanOrEqualTo(value >= 3, null, true, ReferenceType.Type, "EMFPLUS", "Count", "EmfPlusFillClosedCurveRecord", 3, value);
    ([|(Flags & EmfPlusFillClosedCurveRecord_Flags.P) != 0|] array<EmfPlusPointRObject> |
     [|(Flags & EmfPlusFillClosedCurveRecord_Flags.C) != 0|] array<EmfPlusPointObject> |
     array<EmfPlusPointFObject>) PointData with BinaryEncoding{Length = Count};

    override string ToString()
    {
        return "EmfPlusFillClosedCurveRecord, BrushId: " + BrushId.ToString() + ", Tension: " + Tension.ToString();
    }
}

pattern EmfPlusFillClosedCurveRecord_Flags = flags ushort
{
    S = 0x8000,
    C = 0x4000,
    W = 0x2000,
    X = 0x1000,
    P = 0x0800,
    ...
};

// 2.3.4.16 EmfPlusFillEllipse Record
type EmfPlusFillEllipseRecord
{
    RecordType Type where value == RecordType.EmfPlusFillEllipse;
    EmfPlusFillEllipseRecord_Flags Flags where ValidationCheckCombinationValue(InRange<EmfPlusFillEllipseRecord_Flags>(value), null, true, ReferenceType.Type,
                    "EMFPLUS", "Flags", "EmfPlusFillEllipseRecord", "0x8000, 0x4000", value);
    uint Size where ValidationCheck(((Flags & EmfPlusFillEllipseRecord_Flags.C) != 0 && value == 0x00000018) || 
        ((Flags & EmfPlusFillEllipseRecord_Flags.C) == 0 && value == 0x00000028), null, DiagnosisLevel.Error, () => Format(EMFPLUS_STR_EmfPlusDrawRecord_C1, 
        ["Size", "EmfPlusFillEllipseRecord", 0x00000018, 0x00000020]));
    uint DataSize where ValidationCheck(((Flags & EmfPlusFillEllipseRecord_Flags.C) != 0 && value == 0x0000000C) || 
        ((Flags & EmfPlusFillEllipseRecord_Flags.C) == 0 && value == 0x00000014), null, DiagnosisLevel.Error, () => Format(EMFPLUS_STR_EmfPlusDrawRecord_C1, 
        ["DataSize", "EmfPlusFillEllipseRecord", 0x0000000C, 0x00000014]));
    ([|(Flags & EmfPlusFillEllipseRecord_Flags.S) != 0|] EmfPlusARGBObject | uint) BrushId;
    ([|(Flags & EmfPlusFillEllipseRecord_Flags.C) != 0|] EmfPlusRectObject | EmfPlusRectFObject) RectData;

    override string ToString()
    {
        return "EmfPlusFillEllipseRecord, BrushId: " + BrushId.ToString() + ", RectData: " + RectData.ToString();
    }
}

pattern EmfPlusFillEllipseRecord_Flags = flags ushort
{
    S = 0x8000,
    C = 0x4000,
    ...
};

// 2.3.4.17 EmfPlusFillPath Record
type EmfPlusFillPathRecord
{
    RecordType Type where value == RecordType.EmfPlusFillPath;
    EmfPlusFillPathRecord_Flags Flags;
    uint Size where ValidationCheckValue(value == 0x00000010, null, true, ReferenceType.Type, "EMFPLUS", "Size", "EmfPlusFillPathRecord", 0x00000010, value);
    uint DataSize where ValidationCheckValue(value == 0x00000004, null, true, ReferenceType.Type, "EMFPLUS", "DataSize", "EmfPlusFillPathRecord", 0x00000004, value);
    ([|Flags.S|] EmfPlusARGBObject | uint) BrushId;

    override string ToString()
    {
        return "EmfPlusFillEllipseRecord, BrushId: " + BrushId.ToString();
    }
}

type EmfPlusFillPathRecord_Flags
{
    bool S with BinaryEncoding{Width = 1};
    byte Reserved with BinaryEncoding{Width = 7};
    byte ObjectID where ValidationCheckValueInRange(value <= 63 && value >= 0, null, true, ReferenceType.Type, "EMFPLUS", "ObjectID", "EmfPlusFillPathRecord_Flags", 0, 63, value);
} with BinaryEncoding{WidthForComposedType = 16, DecodeAsUnit = true};

// 2.3.4.18 EmfPlusFillPie Record
type EmfPlusFillPieRecord
{
    RecordType Type where value == RecordType.EmfPlusFillPie;
    EmfPlusFillPieRecord_Flags Flags where ValidationCheckCombinationValue(InRange<EmfPlusFillPieRecord_Flags>(value), null, true, ReferenceType.Type,
                    "EMFPLUS", "Flags", "EmfPlusFillPieRecord", "0x8000, 0x4000", value);
    uint Size where ValidationCheck(((Flags & EmfPlusFillPieRecord_Flags.C) != 0 && value == 0x00000020) || 
        ((Flags & EmfPlusFillPieRecord_Flags.C) == 0 && value == 0x00000028), null, DiagnosisLevel.Error, () => Format(EMFPLUS_STR_EmfPlusDrawRecord_C1, 
        ["Size", "EmfPlusFillPieRecord", 0x00000020, 0x00000028]));
    uint DataSize where ValidationCheck(((Flags & EmfPlusFillPieRecord_Flags.C) != 0 && value == 0x00000014) || 
        ((Flags & EmfPlusFillPieRecord_Flags.C) == 0 && value == 0x0000001C), null, DiagnosisLevel.Error, () => Format(EMFPLUS_STR_EmfPlusDrawRecord_C1, 
        ["DataSize", "EmfPlusFillPieRecord", 0x00000014, 0x0000001C]));
    ([|(Flags & EmfPlusFillPieRecord_Flags.S) != 0|] EmfPlusARGBObject | uint) BrushId;
    float StartAngle;
    float SweepAngle;
    ([|(Flags & EmfPlusFillPieRecord_Flags.C) != 0|] EmfPlusRectObject | EmfPlusRectFObject) RectData;

    override string ToString()
    {
        return "EmfPlusFillPieRecord, BrushId: " + BrushId.ToString() + ", StartAngle: " + StartAngle.ToString() + ", SweepAngle: " + SweepAngle.ToString();
    }
}

pattern EmfPlusFillPieRecord_Flags = flags ushort
{
    S = 0x8000,
    C = 0x4000,
    ...
};

// 2.3.4.19 EmfPlusFillPolygon Record
type EmfPlusFillPolygonRecord
{
    RecordType Type where value == RecordType.EmfPlusFillPolygon;
    EmfPlusFillPolygonRecord_Flags Flags where ValidationCheckCombinationValue(InRange<EmfPlusFillPolygonRecord_Flags>(value), null, true, ReferenceType.Type,
                    "EMFPLUS", "Flags", "EmfPlusFillPolygonRecord", "0x8000, 0x4000, 0x0800", value);
    uint Size where ValidationCheck(((Flags & EmfPlusFillPolygonRecord_Flags.P) != 0 && value >= 0x0000001C) || 
        ((Flags & EmfPlusFillPolygonRecord_Flags.P) == 0 && (Flags & EmfPlusFillPolygonRecord_Flags.C) != 0 && value >= 0x00000020) || 
        ((Flags & EmfPlusFillPolygonRecord_Flags.P) == 0 && (Flags & EmfPlusFillPolygonRecord_Flags.C) == 0 && value >= 0x0000002C), null, 
        DiagnosisLevel.Error, () => Format(EMFPLUS_STR_EmfPlusDrawRecord_CP2, ["Size", "EmfPlusFillPolygonRecord", 0x0000001C, 0x00000020, 0x0000002C]));
    uint DataSize where ValidationCheck(((Flags & EmfPlusFillPolygonRecord_Flags.P) != 0 && value >= 0x00000010) || 
        ((Flags & EmfPlusFillPolygonRecord_Flags.P) == 0 && (Flags & EmfPlusFillPolygonRecord_Flags.C) != 0 && value >= 0x00000014) || 
        ((Flags & EmfPlusFillPolygonRecord_Flags.P) == 0 && (Flags & EmfPlusFillPolygonRecord_Flags.C) == 0 && value >= 0x00000020), null, 
        DiagnosisLevel.Error, () => Format(EMFPLUS_STR_EmfPlusDrawRecord_CP2, ["DataSize", "EmfPlusFillPolygonRecord", 0x00000010, 0x00000014, 0x00000020]));
    ([|(Flags & EmfPlusFillPolygonRecord_Flags.S) != 0|] EmfPlusARGBObject | uint) BrushId;
    uint Count where ValidationCheckGreaterThanOrEqualTo(value >= 3, null, true, ReferenceType.Type, "EMFPLUS", "Count", "EmfPlusFillPolygonRecord", 3, value);
    ([|(Flags & EmfPlusFillPolygonRecord_Flags.P) != 0|] array<EmfPlusPointRObject> |
     [|(Flags & EmfPlusFillPolygonRecord_Flags.C) != 0|] array<EmfPlusPointObject> |
     array<EmfPlusPointFObject>) PointData with BinaryEncoding{Length = Count};

    override string ToString()
    {
        return "EmfPlusFillPolygonRecord, BrushId: " + BrushId.ToString() + ", PointData: " + PointData.ToString();
    }
}

pattern EmfPlusFillPolygonRecord_Flags = flags ushort
{
    S = 0x8000,
    C = 0x4000,
    P = 0x0800,
    ...
};

// 2.3.4.20 EmfPlusFillRects Record
type EmfPlusFillRectsRecord
{
    RecordType Type where value == RecordType.EmfPlusFillRects;
    EmfPlusFillRectsRecord_Flags Flags where ValidationCheckCombinationValue(InRange<EmfPlusFillRectsRecord_Flags>(value), null, true, ReferenceType.Type,
                    "EMFPLUS", "Flags", "EmfPlusFillRectsRecord", "0x8000, 0x4000", value);
    uint Size where ValidationCheck(((Flags & EmfPlusFillPolygonRecord_Flags.C) != 0 && value >= 0x0000001C) || 
        ((Flags & EmfPlusFillPolygonRecord_Flags.C) == 0 && value >= 0x00000024), null, 
        DiagnosisLevel.Error, () => Format(EMFPLUS_STR_EmfPlusDrawRecord_C2, ["Size", "EmfPlusFillRectsRecord", 0x0000001C, 0x00000024]));
    uint DataSize where ValidationCheck(((Flags & EmfPlusFillPolygonRecord_Flags.C) != 0 && value >= 0x00000010) || 
        ((Flags & EmfPlusFillPolygonRecord_Flags.C) == 0 && value >= 0x00000018), null, 
        DiagnosisLevel.Error, () => Format(EMFPLUS_STR_EmfPlusDrawRecord_C2, ["DataSize", "EmfPlusFillRectsRecord", 0x00000010, 0x00000018]));
    ([|(Flags & EmfPlusFillPolygonRecord_Flags.S) != 0|] EmfPlusARGBObject | uint) BrushId;
    uint Count;
    ([|(Flags & EmfPlusFillPolygonRecord_Flags.C) != 0|] array<EmfPlusRectObject> | array<EmfPlusRectFObject>) RectData with BinaryEncoding{Length = Count};

    override string ToString()
    {
        return "EmfPlusFillRectsRecord, BrushId: " + BrushId.ToString() + ", RectData: " + RectData.ToString();
    }
}

pattern EmfPlusFillRectsRecord_Flags = flags ushort
{
    S = 0x8000,
    C = 0x4000,
    ...
};

// 2.3.4.21 EmfPlusFillRegion Record
type EmfPlusFillRegionRecord
{
    RecordType Type where value == RecordType.EmfPlusFillRegion;
    EmfPlusFillRegionRecord_Flags Flags;
    uint Size where ValidationCheckValue(value == 0x00000010, null, true, ReferenceType.Type, "EMFPLUS", "Size", "EmfPlusFillRegionRecord", 0x00000010, value);
    uint DataSize where ValidationCheckValue(value == 0x00000004, null, true, ReferenceType.Type, "EMFPLUS", "DataSize", "EmfPlusFillRegionRecord", 0x00000004, value);
    ([|Flags.S|] EmfPlusARGBObject | uint) BrushId;

    override string ToString()
    {
        return "EmfPlusFillRegionRecord, BrushId: " + BrushId.ToString();
    }
}

type EmfPlusFillRegionRecord_Flags
{
    bool S with BinaryEncoding{Width = 1};
    byte Reserved with BinaryEncoding{Width = 7};
    byte ObjectID where ValidationCheckValueInRange(value <= 63 && value >= 0, null, true, ReferenceType.Type, "EMFPLUS", "ObjectID", "EmfPlusFillRegionRecord_Flags", 0, 63, value);
} with BinaryEncoding{WidthForComposedType = 16, DecodeAsUnit = true};

// 2.3.5 Object Record Types
pattern ObjectRecord = EmfPlusObjectRecord | EmfPlusSerializableObjectRecord;

// 2.3.5.1 EmfPlusObject Record
type EmfPlusObjectRecord
{
    RecordType Type where value == RecordType.EmfPlusObject;
    EmfPlusObjectRecord_Flags Flags;
    uint Size;
    optional [|Flags.C|] uint TotalObjectSize;
    uint DataSize;
    ([|Flags.ObjectType == ObjectType.ObjectTypeBrush|] EmfPlusBrushObject |
     [|Flags.ObjectType == ObjectType.ObjectTypePen|] EmfPlusPenObject |
     [|Flags.ObjectType == ObjectType.ObjectTypePath|] EmfPlusPathObject |
     [|Flags.ObjectType == ObjectType.ObjectTypeRegion|] EmfPlusRegionObject |
     [|Flags.ObjectType == ObjectType.ObjectTypeImage|] EmfPlusImageObject |
     [|Flags.ObjectType == ObjectType.ObjectTypeFont|] EmfPlusFontObject |
     [|Flags.ObjectType == ObjectType.ObjectTypeStringFormat|] EmfPlusStringFormatObject |
     [|Flags.ObjectType == ObjectType.ObjectTypeImageAttributes|] EmfPlusImageAttributesObject |
     [|Flags.ObjectType == ObjectType.ObjectTypeCustomLineCap|] EmfPlusCustomLineCapObject) ObjectData with BinaryEncoding{WidthForComposedType = DataSize * 8 as int};

    override string ToString()
    {
        return "EmfPlusObjectRecord, ObjectData: " + ObjectData.ToString();
    }
}

type EmfPlusObjectRecord_Flags
{
    bool C with BinaryEncoding{Width = 1};
    ObjectType ObjectType where ValidationCheckEnumValueTooManyItems(InRange<ObjectType>(value), null, true, ReferenceType.Type,
                    "EMFPLUS", "ObjectType", "EmfPlusObjectRecord_Flags", "ObjectType Enumeration", "[MS-EMFPLUS]") with BinaryEncoding{Width = 7};
    byte ObjectID where ValidationCheckValueInRange(value <= 63 && value >= 0, null, true, ReferenceType.Type, "EMFPLUS", "ObjectID", "EmfPlusObjectRecord_Flags", 0, 63, value);
} with BinaryEncoding{WidthForComposedType = 16, DecodeAsUnit = true};

// 2.3.5.2 EmfPlusSerializableObject Record
type EmfPlusSerializableObjectRecord
{
    RecordType Type where value == RecordType.EmfPlusSerializableObject;
    ushort Flags where ValidationCheckZero(value == 0, null, false, ReferenceType.Type, "EMFPLUS", "Flags", "EmfPlusSerializableObjectRecord", value);
    uint Size;
    uint DataSize;
    guid ObjectGUID with DisplayInfo{ToText = ImageEffectsIdentifierToText};
    uint BufferSize;
    ([|ObjectGUID == {633C80A4-1843-482B-9EF2-BE2834C5FDD4}|] array<BlurEffectObject> |
     [|ObjectGUID == {D3A1DBE1-8EC4-4C17-9F4C-EA97AD1C343D}|] array<BrightnessContrastEffectObject> |
     [|ObjectGUID == {537E597D-251E-48DA-9664-29CA496B70F8}|] array<ColorBalanceEffectObject> |
     [|ObjectGUID == {DD6A0022-58E4-4A67-9D9B-D48EB881A53D}|] array<ColorCurveEffectObject> |
     [|ObjectGUID == {A7CE72A9-0F7F-40D7-B3CC-D0C02D5C3212}|] array<ColorLookupTableEffectObject> |
     [|ObjectGUID == {718F2615-7933-40E3-A511-5F68FE14DD74}|] array<ColorMatrixEffectObject> |
     [|ObjectGUID == {8B2DD6C3-EB07-4D87-A5F0-7108E26A9C5F}|] array<HueSaturationLightnessEffectObject> |
     [|ObjectGUID == {99C354EC-2A31-4F3A-8C34-17A803B33A25}|] array<LevelsEffectObject> |
     [|ObjectGUID == {74D29D05-69A4-4266-9549-3CC52836B632}|] array<RedEyeCorrectionEffectObject> |
     [|ObjectGUID == {63CBF3EE-C526-402C-8F71-62C540BF5142}|] array<SharpenEffectObject> |
     [|ObjectGUID == {1077AF00-2848-4441-9489-44AD4C2D7A2C}|] array<TintEffectObject>) Buffer with BinaryEncoding{WidthForComposedType = BufferSize * 8 as int};

    override string ToString()
    {
        return "EmfPlusSerializableObjectRecord, ObjectGUID: " + ImageEffectsIdentifierToText(ObjectGUID);
    }
}

string ImageEffectsIdentifierToText(any data)
{
    guid ObjectGuid = data as guid;
    if (ObjectGuid in ImageEffectsIdentifiersStringMap)
    {
        return ImageEffectsIdentifiersStringMap[ObjectGuid];
    }
    else
    {
        return ObjectGuid.ToString();
    }
}

// 2.3.6 Property Record Type
pattern PropertyRecord = EmfPlusSetAntiAliasModeRecord |
                         EmfPlusSetCompositingModeRecord |
                         EmfPlusSetCompositingQualityRecord |
                         EmfPlusSetInterpolationModeRecord |
                         EmfPlusSetPixelOffsetModeRecord |
                         EmfPlusSetRenderingOriginRecord |
                         EmfPlusSetTextContrastRecord |
                         EmfPlusSetTextRenderingHintRecord;

// 2.3.6.1 EmfPlusSetAntiAliasMode Record
type EmfPlusSetAntiAliasModeRecord
{
    RecordType Type where value == RecordType.EmfPlusSetAntiAliasMode;
    EmfPlusSetAntiAliasModeRecord_Flags Flags;
    uint Size;
    uint DataSize where ValidationCheckZero(value == 0, null, true, ReferenceType.Type, "EMFPLUS", "DataSize", "EmfPlusSetAntiAliasModeRecord", value);

    override string ToString()
    {
        return "EmfPlusSetAntiAliasModeRecord";
    }
}

type EmfPlusSetAntiAliasModeRecord_Flags
{
    byte Reserved;
    SmoothingMode SmoothingMode where ValidationCheckEnumValueTooManyItems(InRange<SmoothingMode>(value), null, true, ReferenceType.Type,
                    "EMFPLUS", "SmoothingMode", "EmfPlusSetAntiAliasModeRecord_Flags", "SmoothingMode Enumeration", "[MS-EMFPLUS]") with BinaryEncoding{Width = 7};
    bool A with BinaryEncoding{Width = 1};
} with BinaryEncoding{WidthForComposedType = 16, DecodeAsUnit = true};

// 2.3.6.2 EmfPlusSetCompositingMode Record
type EmfPlusSetCompositingModeRecord
{
    RecordType Type where value == RecordType.EmfPlusSetCompositingMode;
    EmfPlusSetCompositingModeRecord_Flags Flags;
    uint Size where ValidationCheckValue(value == 0x0000000C, null, true, ReferenceType.Type, "EMFPLUS", "Size", "EmfPlusSetCompositingModeRecord", 0x0000000C, value);
    uint DataSize where ValidationCheckZero(value == 0, null, true, ReferenceType.Type, "EMFPLUS", "DataSize", "EmfPlusSetCompositingModeRecord", value);

    override string ToString()
    {
        return "EmfPlusSetCompositingModeRecord";
    }
}

type EmfPlusSetCompositingModeRecord_Flags
{
    byte Reserved;
    CompositingMode CompositingMode where ValidationCheckEnumValue(InRange<CompositingMode>(value), null, true, ReferenceType.Type,
                    "EMFPLUS", "CompositingMode", "EmfPlusSetCompositingModeRecord_Flags", "0x00, 0x01", value);
} with BinaryEncoding{WidthForComposedType = 16, DecodeAsUnit = true};

// 2.3.6.3 EmfPlusSetCompositingQuality Record
type EmfPlusSetCompositingQualityRecord
{
    RecordType Type where value == RecordType.EmfPlusSetCompositingQuality;
    EmfPlusSetCompositingQualityRecord_Flags Flags;
    uint Size where ValidationCheckValue(value == 0x0000000C, null, true, ReferenceType.Type, "EMFPLUS", "Size", "EmfPlusSetCompositingQualityRecord", 0x0000000C, value);
    uint DataSize where ValidationCheckZero(value == 0, null, true, ReferenceType.Type, "EMFPLUS", "DataSize", "EmfPlusSetCompositingQualityRecord", value);

    override string ToString()
    {
        return "EmfPlusSetCompositingQualityRecord";
    }
}

type EmfPlusSetCompositingQualityRecord_Flags
{
    byte Reserved;
    CompositingQuality CompositingQuality where ValidationCheckEnumValueTooManyItems(InRange<CompositingQuality>(value), null, true, ReferenceType.Type,
                    "EMFPLUS", "CompositingQuality", "EmfPlusSetCompositingQualityRecord_Flags", "CompositingQuality Enumeration", "[MS-EMFPLUS]");
} with BinaryEncoding{WidthForComposedType = 16, DecodeAsUnit = true};

// 2.3.6.4 EmfPlusSetInterpolationMode Record
type EmfPlusSetInterpolationModeRecord
{
    RecordType Type where value == RecordType.EmfPlusSetInterpolationMode;
    EmfPlusSetInterpolationModeRecord_Flags Flags;
    uint Size where ValidationCheckValue(value == 0x0000000C, null, true, ReferenceType.Type, "EMFPLUS", "Size", "EmfPlusSetInterpolationModeRecord", 0x0000000C, value);
    uint DataSize where ValidationCheckZero(value == 0, null, true, ReferenceType.Type, "EMFPLUS", "DataSize", "EmfPlusSetInterpolationModeRecord", value);

    override string ToString()
    {
        return "EmfPlusSetInterpolationModeRecord";
    }
}

type EmfPlusSetInterpolationModeRecord_Flags
{
    byte Reserved;
    InterpolationMode InterpolationMode where ValidationCheckEnumValueTooManyItems(InRange<InterpolationMode>(value), null, true, ReferenceType.Type,
                    "EMFPLUS", "InterpolationMode", "EmfPlusSetInterpolationModeRecord_Flags", "InterpolationMode Enumeration", "[MS-EMFPLUS]");
} with BinaryEncoding{WidthForComposedType = 16, DecodeAsUnit = true};

// 2.3.6.5 EmfPlusSetPixelOffsetMode Record
type EmfPlusSetPixelOffsetModeRecord
{
    RecordType Type where value == RecordType.EmfPlusSetPixelOffsetMode;
    EmfPlusSetPixelOffsetModeRecord_Flags Flags;
    uint Size where ValidationCheckValue(value == 0x0000000C, null, true, ReferenceType.Type, "EMFPLUS", "Size", "EmfPlusSetPixelOffsetModeRecord", 0x0000000C, value);
    uint DataSize where ValidationCheckZero(value == 0, null, true, ReferenceType.Type, "EMFPLUS", "DataSize", "EmfPlusSetPixelOffsetModeRecord", value);

    override string ToString()
    {
        return "EmfPlusSetPixelOffsetModeRecord";
    }
}

type EmfPlusSetPixelOffsetModeRecord_Flags
{
    byte Reserved;
    PixelOffsetMode PixelOffsetMode where ValidationCheckEnumValueTooManyItems(InRange<PixelOffsetMode>(value), null, true, ReferenceType.Type,
                    "EMFPLUS", "PixelOffsetMode", "EmfPlusSetPixelOffsetModeRecord_Flags", "PixelOffsetMode Enumeration", "[MS-EMFPLUS]");
} with BinaryEncoding{WidthForComposedType = 16, DecodeAsUnit = true};

// 2.3.6.6 EmfPlusSetRenderingOrigin Record
type EmfPlusSetRenderingOriginRecord
{
    RecordType Type where value == RecordType.EmfPlusSetRenderingOrigin;
    ushort Flags where ValidationCheckZero(value == 0, null, false, ReferenceType.Type, "EMFPLUS", "Flags", "EmfPlusSetRenderingOriginRecord", value);
    uint Size where ValidationCheckValue(value == 0x00000014, null, true, ReferenceType.Type, "EMFPLUS", "Size", "EmfPlusSetRenderingOriginRecord", 0x00000014, value);
    uint DataSize where ValidationCheckValue(value == 0x00000008, null, true, ReferenceType.Type, "EMFPLUS", "DataSize", "EmfPlusSetRenderingOriginRecord", 0x00000008, value);
    uint x;
    uint y;

    override string ToString()
    {
        return "EmfPlusSetRenderingOriginRecord, x: " + x.ToString() + "y: " + y.ToString();
    }
}

// 2.3.6.7 EmfPlusSetTextContrast Record
type EmfPlusSetTextContrastRecord
{
    RecordType Type where value == RecordType.EmfPlusSetTextContrast;
    EmfPlusSetTextContrastRecord_Flags Flags;
    uint Size where ValidationCheckValue(value == 0x0000000C, null, true, ReferenceType.Type, "EMFPLUS", "Size", "EmfPlusSetTextContrastRecord", 0x0000000C, value);
    uint DataSize where ValidationCheckZero(value == 0, null, true, ReferenceType.Type, "EMFPLUS", "DataSize", "EmfPlusSetTextContrastRecord", value);

    override string ToString()
    {
        return "EmfPlusSetTextContrastRecord";
    }
}

type EmfPlusSetTextContrastRecord_Flags
{
    byte Reserved with BinaryEncoding{Width = 4};
    ushort TextContrast with BinaryEncoding{Width = 12, Endian = Endian.Big};
} with BinaryEncoding{WidthForComposedType = 16, DecodeAsUnit = true};

// 2.3.6.8 EmfPlusSetTextRenderingHint Record
type EmfPlusSetTextRenderingHintRecord
{
    RecordType Type where value == RecordType.EmfPlusSetTextRenderingHint;
    EmfPlusSetTextRenderingHintRecord_Flags Flags;
    uint Size where ValidationCheckValue(value == 0x0000000C, null, true, ReferenceType.Type, "EMFPLUS", "Size", "EmfPlusSetTextRenderingHintRecord", 0x0000000C, value);
    uint DataSize where ValidationCheckZero(value == 0, null, true, ReferenceType.Type, "EMFPLUS", "DataSize", "EmfPlusSetTextRenderingHintRecord", value);

    override string ToString()
    {
        return "EmfPlusSetTextRenderingHintRecord";
    }
}

type EmfPlusSetTextRenderingHintRecord_Flags
{
    byte Reserved;
    TextRenderingHint TextRenderingHint where ValidationCheckEnumValueTooManyItems(InRange<TextRenderingHint>(value), null, true, ReferenceType.Type,
                    "EMFPLUS", "TextRenderingHint", "EmfPlusSetTextRenderingHintRecord_Flags", "TextRenderingHint Enumeration", "[MS-EMFPLUS]");
} with BinaryEncoding{WidthForComposedType = 16, DecodeAsUnit = true};

// 2.3.7 State Record Types
pattern StateRecord = EmfPlusBeginContainerRecord |
                      EmfPlusBeginContainerNoParamsRecord |
                      EmfPlusEndContainerRecord |
                      EmfPlusRestoreRecord |
                      EmfPlusSaveRecord;

// 2.3.7.1 EmfPlusBeginContainer Record
type EmfPlusBeginContainerRecord
{
    RecordType Type where value == RecordType.EmfPlusBeginContainer;
    EmfPlusBeginContainerRecord_Flags Flags;
    uint Size where ValidationCheckValue(value == 0x00000030, null, true, ReferenceType.Type, "EMFPLUS", "Size", "EmfPlusBeginContainerRecord", 0x00000030, value);
    uint DataSize where ValidationCheckValue(value == 0x00000024, null, true, ReferenceType.Type, "EMFPLUS", "DataSize", "EmfPlusBeginContainerRecord", 0x00000024, value);
    EmfPlusRectFObject DestRect;
    EmfPlusRectFObject SrcRect;
    uint StackIndex;

    override string ToString()
    {
        return "EmfPlusBeginContainerRecord, DestRect: " + DestRect.ToString() + ", SrcRect: " + SrcRect.ToString();
    }
}

type EmfPlusBeginContainerRecord_Flags
{
    UnitType PageUnit where ValidationCheckEnumValueTooManyItems(InRange<UnitType>(value), null, true, ReferenceType.Type,
                    "EMFPLUS", "PageUnit", "EmfPlusBeginContainerRecord_Flags", "UnitType Enumeration", "[MS-EMFPLUS]");
    byte Zero;
} with BinaryEncoding{WidthForComposedType = 16, DecodeAsUnit = true};

// 2.3.7.2 EmfPlusBeginContainerNoParams Record
type EmfPlusBeginContainerNoParamsRecord
{
    RecordType Type where value == RecordType.EmfPlusBeginContainerNoParams;
    ushort Flags where ValidationCheckZero(value == 0, null, false, ReferenceType.Type, "EMFPLUS", "Flags", "EmfPlusBeginContainerNoParamsRecord", value);
    uint Size where ValidationCheckValue(value == 0x00000010, null, true, ReferenceType.Type, "EMFPLUS", "Size", "EmfPlusBeginContainerNoParamsRecord", 0x00000010, value);
    uint DataSize where ValidationCheckValue(value == 0x00000004, null, true, ReferenceType.Type, "EMFPLUS", "DataSize", "EmfPlusBeginContainerNoParamsRecord", 0x00000004, value);
    uint StackIndex;

    override string ToString()
    {
        return "EmfPlusBeginContainerNoParamsRecord, StackIndex: " + StackIndex.ToString();
    }
}

// 2.3.7.3 EmfPlusEndContainer Record
type EmfPlusEndContainerRecord
{
    RecordType Type where value == RecordType.EmfPlusBeginContainerNoParams;
    ushort Flags where ValidationCheckZero(value == 0, null, false, ReferenceType.Type, "EMFPLUS", "Flags", "EmfPlusEndContainerRecord", value);
    uint Size where ValidationCheckValue(value == 0x00000010, null, true, ReferenceType.Type, "EMFPLUS", "Size", "EmfPlusEndContainerRecord", 0x00000010, value);
    uint DataSize where ValidationCheckValue(value == 0x00000004, null, true, ReferenceType.Type, "EMFPLUS", "DataSize", "EmfPlusEndContainerRecord", 0x00000004, value);
    uint StackIndex;

    override string ToString()
    {
        return "EmfPlusEndContainerRecord, StackIndex: " + StackIndex.ToString();
    }
}

// 2.3.7.4 EmfPlusRestore Record
type EmfPlusRestoreRecord
{
    RecordType Type where value == RecordType.EmfPlusRestore;
    ushort Flags where ValidationCheckZero(value == 0, null, false, ReferenceType.Type, "EMFPLUS", "Flags", "EmfPlusRestoreRecord", value);
    uint Size where ValidationCheckValue(value == 0x00000010, null, true, ReferenceType.Type, "EMFPLUS", "Size", "EmfPlusRestoreRecord", 0x00000010, value);
    uint DataSize where ValidationCheckValue(value == 0x00000004, null, true, ReferenceType.Type, "EMFPLUS", "DataSize", "EmfPlusRestoreRecord", 0x00000004, value);
    uint StackIndex;

    override string ToString()
    {
        return "EmfPlusRestoreRecord, StackIndex: " + StackIndex.ToString();
    }
}

// 2.3.7.5 EmfPlusSave Record
type EmfPlusSaveRecord
{
    RecordType Type where value == RecordType.EmfPlusSave;
    ushort Flags where ValidationCheckZero(value == 0, null, false, ReferenceType.Type, "EMFPLUS", "Flags", "EmfPlusSaveRecord", value);
    uint Size where ValidationCheckValue(value == 0x00000010, null, true, ReferenceType.Type, "EMFPLUS", "Size", "EmfPlusSaveRecord", 0x00000010, value);
    uint DataSize where ValidationCheckValue(value == 0x00000004, null, true, ReferenceType.Type, "EMFPLUS", "DataSize", "EmfPlusSaveRecord", 0x00000004, value);
    uint StackIndex;

    override string ToString()
    {
        return "EmfPlusSaveRecord, StackIndex: " + StackIndex.ToString();
    }
}

// 2.3.8 Terminal Server Record Types
pattern TerminalServerRecord = EmfPlusSetTSClipRecord | EmfPlusSetTSGraphicsRecord;

// 2.3.8.1 EmfPlusSetTSClip Record
type EmfPlusSetTSClipRecord
{
    RecordType Type where value == RecordType.EmfPlusSetTSClip;
    EmfPlusSetTSClipRecord_Flags Flags;
    uint Size;
    uint DataSize;
    ([|Flags.C|] array<uint> | array<ulong>) rects with BinaryEncoding{Length = Flags.NumRects};

    override string ToString()
    {
        return "EmfPlusSetTSClipRecord";
    }
}

type EmfPlusSetTSClipRecord_Flags
{
    bool C with BinaryEncoding{Width = 1};
    ushort NumRects with BinaryEncoding{Width = 15, Endian = Endian.Big};
} with BinaryEncoding{WidthForComposedType = 16, DecodeAsUnit = true};

// 2.3.8.2 EmfPlusSetTSGraphics Record
type EmfPlusSetTSGraphicsRecord
{
    RecordType Type where value == RecordType.EmfPlusSetTSGraphics;
    EmfPlusSetTSGraphicsRecord_Flags Flags where ValidationCheckCombinationValue(InRange<EmfPlusSetTSGraphicsRecord_Flags>(value), null, true, ReferenceType.Type,
                    "EMFPLUS", "Flags", "EmfPlusSetTSGraphicsRecord", "0x0001, 0x0002", value);
    uint Size;
    uint DataSize;
    SmoothingMode AntiAliasMode where ValidationCheckEnumValueTooManyItems(InRange<SmoothingMode>(value), null, true, ReferenceType.Type,
                    "EMFPLUS", "AntiAliasMode", "EmfPlusSetTSGraphicsRecord", "SmoothingMode Enumeration", "[MS-EMFPLUS]");
    TextRenderingHint TextRenderingHint where ValidationCheckEnumValueTooManyItems(InRange<TextRenderingHint>(value), null, true, ReferenceType.Type,
                    "EMFPLUS", "TextRenderingHint", "EmfPlusSetTSGraphicsRecord", "TextRenderingHint Enumeration", "[MS-EMFPLUS]");
    CompositingMode CompositingMode where ValidationCheckEnumValue(InRange<CompositingMode>(value), null, true, ReferenceType.Type,
                    "EMFPLUS", "CompositingMode", "EmfPlusSetTSGraphicsRecord", "0x00, 0x01", value);
    CompositingQuality CompositingQuality where ValidationCheckEnumValueTooManyItems(InRange<CompositingQuality>(value), null, true, ReferenceType.Type,
                    "EMFPLUS", "CompositingQuality", "EmfPlusSetTSGraphicsRecord", "CompositingQuality Enumeration", "[MS-EMFPLUS]");
    short RenderOriginX;
    short RenderOriginY;
    ushort TextContrast where ValidationCheckValueInRange(value <= 12 && value >= 0, null, true, ReferenceType.Type, "EMFPLUS", "TextContrast", "EmfPlusSetTSGraphicsRecord", 0, 12, value);
    FilterType FilterType where ValidationCheckEnumValueTooManyItems(InRange<FilterType>(value), null, true, ReferenceType.Type,
                    "EMFPLUS", "FilterType", "EmfPlusSetTSGraphicsRecord", "FilterType Enumeration", "[MS-EMFPLUS]");
    PixelOffsetMode PixelOffset where ValidationCheckEnumValueTooManyItems(InRange<PixelOffsetMode>(value), null, true, ReferenceType.Type,
                    "EMFPLUS", "PixelOffset", "EmfPlusSetTSGraphicsRecord", "PixelOffsetMode Enumeration", "[MS-EMFPLUS]");
    EmfPlusTransformMatrixObject WorldToDevice;
    optional [|Size > 0x00000030|] EmfPlusPaletteObject Palette;

    override string ToString()
    {
        return "EmfPlusSetTSGraphicsRecord";
    }
}

pattern EmfPlusSetTSGraphicsRecord_Flags = flags ushort
{
    V = 0x0002,
    T = 0x0001,
    ...
};

// 2.3.9 Transform Record Types
pattern TransformRecord = EmfPlusMultiplyWorldTransformRecord |
                          EmfPlusResetWorldTransformRecord |
                          EmfPlusRotateWorldTransformRecord |
                          EmfPlusScaleWorldTransformRecord |
                          EmfPlusSetPageTransformRecord |
                          EmfPlusSetWorldTransformRecord |
                          EmfPlusTranslateWorldTransformRecord;

// 2.3.9.1 EmfPlusMultiplyWorldTransform Record
type EmfPlusMultiplyWorldTransformRecord
{
    RecordType Type where value == RecordType.EmfPlusMultiplyWorldTransform;
    EmfPlusMultiplyWorldTransformRecord_Flags Flags where ValidationCheckCombinationValue(InRange<EmfPlusMultiplyWorldTransformRecord_Flags>(value), null, true, ReferenceType.Type,
                    "EMFPLUS", "Flags", "EmfPlusMultiplyWorldTransformRecord", "0x2000", value);
    uint Size where ValidationCheckValue(value == 0x00000024, null, true, ReferenceType.Type, "EMFPLUS", "Size", "EmfPlusMultiplyWorldTransformRecord", 0x00000024, value);
    uint DataSize where ValidationCheckValue(value == 0x00000018, null, true, ReferenceType.Type, "EMFPLUS", "DataSize", "EmfPlusMultiplyWorldTransformRecord", 0x00000018, value);
    EmfPlusTransformMatrixObject MatrixData;

    override string ToString()
    {
        return "EmfPlusMultiplyWorldTransformRecord";
    }
}

pattern EmfPlusMultiplyWorldTransformRecord_Flags = flags ushort
{
    A = 0x2000,
    ...
};

// 2.3.9.2 EmfPlusResetWorldTransform Record
type EmfPlusResetWorldTransformRecord
{
    RecordType Type where value == RecordType.EmfPlusResetWorldTransform;
    ushort Flags  where ValidationCheckZero(value == 0, null, false, ReferenceType.Type, "EMFPLUS", "Flags", "EmfPlusResetWorldTransformRecord", value);
    uint Size where ValidationCheckValue(value == 0x0000000C, null, true, ReferenceType.Type, "EMFPLUS", "Size", "EmfPlusResetWorldTransformRecord", 0x0000000C, value);
    uint DataSize where ValidationCheckZero(value == 0, null, true, ReferenceType.Type, "EMFPLUS", "DataSize", "EmfPlusResetWorldTransformRecord", value);

    override string ToString()
    {
        return "EmfPlusResetWorldTransformRecord";
    }
}

// 2.3.9.3 EmfPlusRotateWorldTransform Record
type EmfPlusRotateWorldTransformRecord
{
    RecordType Type where value == RecordType.EmfPlusRotateWorldTransform;
    EmfPlusRotateWorldTransformRecord_Flags Flags where ValidationCheckCombinationValue(InRange<EmfPlusRotateWorldTransformRecord_Flags>(value), null, true, ReferenceType.Type,
                    "EMFPLUS", "Flags", "EmfPlusRotateWorldTransformRecord", "0x2000", value);
    uint Size where ValidationCheckValue(value == 0x00000010, null, true, ReferenceType.Type, "EMFPLUS", "Size", "EmfPlusRotateWorldTransformRecord", 0x00000010, value);
    uint DataSize where ValidationCheckValue(value == 0x00000004, null, true, ReferenceType.Type, "EMFPLUS", "DataSize", "EmfPlusRotateWorldTransformRecord", 0x00000004, value);
    float Angle;

    override string ToString()
    {
        return "EmfPlusRotateWorldTransformRecord, Angle: " + Angle.ToString();
    }
}

pattern EmfPlusRotateWorldTransformRecord_Flags = flags ushort
{
    A = 0x2000,
    ...
};

// 2.3.9.4 EmfPlusScaleWorldTransform Record
type EmfPlusScaleWorldTransformRecord
{
    RecordType Type where value == RecordType.EmfPlusScaleWorldTransform;
    EmfPlusScaleWorldTransformRecord_Flags Flags where ValidationCheckCombinationValue(InRange<EmfPlusScaleWorldTransformRecord_Flags>(value), null, true, ReferenceType.Type,
                    "EMFPLUS", "Flags", "EmfPlusScaleWorldTransformRecord", "0x2000", value);
    uint Size where ValidationCheckValue(value == 0x00000014, null, true, ReferenceType.Type, "EMFPLUS", "Size", "EmfPlusScaleWorldTransformRecord", 0x00000014, value);
    uint DataSize where ValidationCheckValue(value == 0x00000008, null, true, ReferenceType.Type, "EMFPLUS", "DataSize", "EmfPlusScaleWorldTransformRecord", 0x00000008, value);
    float Sx;
    float Sy;

    override string ToString()
    {
        return "EmfPlusScaleWorldTransformRecord, Sx: " + Sx.ToString() + ", Sy: " + Sy.ToString();
    }
}

pattern EmfPlusScaleWorldTransformRecord_Flags = flags ushort
{
    A = 0x2000,
    ...
};

// 2.3.9.5 EmfPlusSetPageTransform Record
type EmfPlusSetPageTransformRecord
{
    RecordType Type where value == RecordType.EmfPlusSetPageTransform;
    EmfPlusSetPageTransformRecord_Flags Flags;
    uint Size where ValidationCheckValue(value == 0x00000010, null, true, ReferenceType.Type, "EMFPLUS", "Size", "EmfPlusSetPageTransformRecord", 0x00000010, value);
    uint DataSize where ValidationCheckValue(value == 0x00000004, null, true, ReferenceType.Type, "EMFPLUS", "DataSize", "EmfPlusSetPageTransformRecord", 0x00000004, value);
    float PageScale;

    override string ToString()
    {
        return "EmfPlusSetPageTransformRecord, PageScale: " + PageScale.ToString();
    }
}

type EmfPlusSetPageTransformRecord_Flags
{
    byte Zero;
    UnitType PageUnit where ValidationCheck(value != UnitType.UnitTypeDisplay && value != UnitType.UnitTypeWorld, null, DiagnosisLevel.Warning, EMFPLUS_STR_EmfPlusSetPageTransform_PageUnit);
} with BinaryEncoding{WidthForComposedType = 16, DecodeAsUnit = true};

// 2.3.9.6 EmfPlusSetWorldTransform Record
type EmfPlusSetWorldTransformRecord
{
    RecordType Type where value == RecordType.EmfPlusSetWorldTransform;
    ushort Flags  where ValidationCheckZero(value == 0, null, false, ReferenceType.Type, "EMFPLUS", "Flags", "EmfPlusSetWorldTransformRecord", value);
    uint Size where ValidationCheckValue(value == 0x00000024, null, true, ReferenceType.Type, "EMFPLUS", "Size", "EmfPlusSetWorldTransformRecord", 0x00000024, value);
    uint DataSize where ValidationCheckValue(value == 0x00000018, null, true, ReferenceType.Type, "EMFPLUS", "DataSize", "EmfPlusSetWorldTransformRecord", 0x00000018, value);
    EmfPlusTransformMatrixObject MatrixData;

    override string ToString()
    {
        return "EmfPlusSetWorldTransformRecord";
    }
}

// 2.3.9.7 EmfPlusTranslateWorldTransform Record
type EmfPlusTranslateWorldTransformRecord
{
    RecordType Type where value == RecordType.EmfPlusTranslateWorldTransform;
    EmfPlusTranslateWorldTransformRecord_Flags Flags where ValidationCheckCombinationValue(InRange<EmfPlusTranslateWorldTransformRecord_Flags>(value), null, true, ReferenceType.Type,
                    "EMFPLUS", "Flags", "EmfPlusTranslateWorldTransformRecord", "0x2000", value);
    uint Size where ValidationCheckValue(value == 0x00000014, null, true, ReferenceType.Type, "EMFPLUS", "Size", "EmfPlusTranslateWorldTransformRecord", 0x00000014, value);
    uint DataSize where ValidationCheckValue(value == 0x00000008, null, true, ReferenceType.Type, "EMFPLUS", "DataSize", "EmfPlusTranslateWorldTransformRecord", 0x00000008, value);
    float dx;
    float dy;

    override string ToString()
    {
        return "EmfPlusTranslateWorldTransformRecord, dx: " + dx.ToString() + ", dy: " + dy.ToString();
    }
}

pattern EmfPlusTranslateWorldTransformRecord_Flags = flags ushort
{
    A = 0x2000,
    ...
};

// Future Reference: The code for all the or pattern of Record Type in this opn should be changed if feature "Look ahead" is implemented
pattern EMFRecord = ClippingRecord |
                    CommentRecord |
                    ControlRecord |
                    DrawingRecord |
                    ObjectRecord |
                    PropertyRecord |
                    StateRecord |
                    TerminalServerRecord |
                    TransformRecord;
