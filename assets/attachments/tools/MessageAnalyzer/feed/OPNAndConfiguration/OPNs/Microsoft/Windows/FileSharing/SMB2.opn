protocol SMB2 with
Documentation
{
    ProtocolName = "Server Message Block (SMB) Protocol Versions 2 and 3",
    ShortName = "SMB2",
    Description = ""
},
OPNAuthoring
{
    Copyright = "(c) Microsoft Corporation",
    References =
        [
            new Reference{Name = "MS-SMB2", Version = "56.0", Date = "09/12/2018", ProgramName = ProgramName.MCPP},
        ],
    RevisionSummary =
        [
            new Revision{Class=RevisionClass.Major, Version="384345", Date="02/26/2016"}
        ]
};

using Standard;
using Utility;
using DTYP;
using ERREF;
using FSCC;
using NBTSS;
using PCCRC;
using Diagnostics;
using SMBTransport;
using MSRPCE;
using GSSAPI;
using NLMP;
using SMB;
using FAS;
using FileSharingResources;
using InfrastructureResources;

// -------------------------------------------
// Static values

const ulong InvalidFileId = 0xFFFFFFFFFFFFFFFF;
const ulong InvalidMessageId = 0xFFFFFFFFFFFFFFFF;
const binary SMB2ProtocolId = $[FE534D42];
const binary SMB3EncryptdProtocolId = $[FD534D42];
const binary SMB3CompressionProtocolId = $[FC534D42];
const int SMB2_HEADER_SIZE = 64; // SMB2 Header Size
const bool SMB2_REQUEST = true;
const bool SMB2_RESPONSE = false;
const binary DefaultSmb2ServerIndex = $[];  // default endpoint index for messages not from ETW
// -------------------------------------------
// annotation

// Keep the file name for the file access messages
annotation string SMB2Request#SMB2FileName;
annotation string SMB2Response#SMB2FileName;
annotation string SMB2Request#SMB2SessionIdName;
annotation string SMB2Response#SMB2SessionIdName;
annotation string SMB2Request#SMB2TreeIdName;
annotation string SMB2Response#SMB2TreeIdName;
annotation ulong SMB2Request#FileId;
annotation ulong SMB2Response#FileId;

// Mark if the message is in a compounded message chain
annotation bool SMB2Request#IsCompounded;
annotation bool SMB2Response#IsCompounded;

// Keep the command name for SMB2HeaderOnly message
annotation string SMB2HeaderOnly#SMB2MessageName;

// Mark if the message is reassembled or not
annotation bool SMB2Response#IsReassembled;

// Keep Information for GSSAPI, NLMP messages.
annotation string SMB2Request#KeyInformation;
annotation string SMB2Response#KeyInformation;

// --------------Global values-----------------------------

// Store the global file name by fileId
map<ulong, string> SMB2GlobalFileNames = {};
// Store the association between lease key and names
map<GUID, SMB2Names> SMB2GlobalLeaseKeyMapToNames = {};

type SMB2Names
{
    optional string SessionIdName;
    optional string TreeIdName;
    optional string FileName;
}
// ---------------------------------------------Design Notes--------------------------------------------- //
/*
 * 1. SMB2 protocol facts: SMB2 MessageId is assigned per connection;
 *    Impact to parser: We should group virtual operation based on MessageId on each connection seperately;
 *    Current solution: Group virtual operation on lower layer endpoint (Server) which is over underlying connection.
 * 2. SMB2 protocol facts: In multiple channels scenario, one single SMB2 session may have multiple different connections.
 *                         And different segments of one single file can be transferred on any one of these connections.
 *    Impact to parser: Upper layer protocol may need reassemble one file transferred on mulitiple connections.
 *    Current solution: Upper layer endpoint (FileServer) is not 'over' lower layer endpoint (Server). Instead, use
 *                      (FileId, SessionId) as index of FileServer. So, upperlayer can reassembe a file according to (FileId, SessionId).
 *    Drawback of current solution : When we capture traffic on an SMB2 Client which has been connected to
 *                      2 different SMB2 Server. Theoretically, we may get message from the 2 different server but have the same
 *                      (FileId, SessionId). In current solution, we just ignore this case since it's small probability event,
 *                      and we think it will never happen in real world.
 *                      If we want to deal with this case, we need to add ServerName as another index to FileServer, because
 *                      FileId is unique on an SMB2 Server. However, we cannot get the ServerName because it's not transferred
 *                      on the wire. The Share path in SMB2 TREE_CONNECT Request is not applicable here since it can be an ip
 *                      address of the server, and one server can have mulitple ip addresses.
 * 3. We don't perform reassembling in SMB2 layer, upper layer protocol should perform reassembling by themselves if necessary.
 * 4. Since SMB2 client can read segments of a file in any order (applicable in multiple channel or single channel).
 *    Upper layer protocol need to order file segments according to the offset field in SMB2 Read Request.
 * 5. Ioctl Request does not need reassemble, we can assume that Ioctl is not applicable for reading file,
 *    because it has no offset in the message.
 */

// ------------------------------------------- Architecture ------------------------------------------- //

// Endpoints
/* SMB2 Endpoint Layers:
 * The architecture design refers to section 3.2.1 Abstract Data Model.
 *
 * [Upper layer]
 * --------------------------------------------------------|-------------------------------------------
 * [Per Application Open of a File]                  FileServer
 *                                                              Index: (FileId, SessionId); FileServer is not 'over' Server
 *                                                              Jobs: use (FileId, SessionId) as index to deal with multiple channels scenario
 * [Per Transport Connection]                            Server
 *                                                              Index: 
 *                                                                      For 'over' SMBTransport.Server, the index is 'over' SMBTransport.Server
 *                                                                      For 'over' NBTSS.Server, the index is 'over' NBTSS.Server
 *                                                                      For 'over' Microsoft_Windows_SMBClient or Microsoft_Windows_SMBServer, the index is a binary which is "Source + Destination + Port"
 *                                                              Jobs: Group virtual operation; Set annotation #SMB2FileName; Dispatch SMB2 message to endpoint FileServer which have corresponding index (FileId, SessionId)
 * --------------------------------------------------------|--------------------------------------------
 * [Lower layer]
 */

// Actors
/* SMBNegotiateActor: Actor to dispatch SMB Com Negotiate to VirtualOperation endpoint SMB2.Server. So SMB Com Negotiate Request and SMB2 Negotiate Response can be grouped.
 * SMB2OverSMBTransport: Actor that listens to SMBTransport.TransportPacket messages on endpoint SMBTransport.Server, decode as SMB2 messages and dispatch to endpoint SMB2.Server
 *      DecodeAndDispatchRequestMessages and DecodeAndDispatchResponseMessages functions: decode TransportPacket messages as SMB2 messages; Set annotation #FileId; deal with compounded messages
 * SMB2OverNBTSS: Actor that listens to NBTSS.SessionService messages on NBTSS.Server, decode as SMB2 messages and dispatch to endpoint SMB2.Server
*/

// Top layer endpoint available for the protocol that specifies the file content.
endpoint FileServer[ulong FileId, ulong SessionId]
    accepts SMB2Request
    issues SMB2Response;

map<uint, string> SMB2GlobalTreeIdToPath = {};

endpoint Server[binary Index]
    over SMBTransport.Server | over NBTSS.Server
    accepts TransformMessage issues TransformMessage
    accepts CompressedTransformMessage issues CompressedTransformMessage
    provides VirtualOperations
    accepts SMB.Messages.ComNegotiateRequest
    accepts SMB2Request
    issues SMB2Response
{
    // 1. For calculate and validate the credits
    // Keeps the dialect of SMB2 negotiated with the server.
    ushort dialect = 0;
    // Keeps the Capabilities.SMB2GlobalCapLargeMtu flag bit from NegotiateResponse message
    // Indicates whether the server supports multi-credit operations.
    bool supportsMultiCredit = false;
    // The number of credits held by the client MUST be considered as 1 when the connection is established.
    int credits = 1;
    // Check if the message is decoded successfully
    bool hasAnyMessageDecodeFailed = false;

    // 2. For file name 
    // Keeps the Capabilities.SMB2GlobalCapMultiChannel flag bit from NegotiateResponse message.
    // Indicates whether the server supports establishing multiple channels for sessions.
    bool supportsMultiChannel = false;

    // Keep cached opens, the index is fileId, the value is fileName
    // Add entry when get SMB2 Open Message(Create Response), all messages after the open can use cachedOpens to set their fileName
    map<ulong, string> cachedOpens = {};
    map<ulong, string> cachedSessions = {};
    map<uint, string> cachedTreeConnects = {};

    // For Create Request, store the fileName by MessageId for the response message
    map<ulong, SMB2.Messages.CreateRequest> CreateRequestByMid = {};
    map<ulong, SMB2.Messages.SessionSetupRequest> SessionSetupRequestByMid = {};
    map<ulong, SMB2.Messages.TreeConnectRequest> TreeConnectRequestByMid = {};
    array<SMB2Request> compoundedRequests = [];
    array<SMB2Response> compoundedResponses = [];

    // Store the fileId by MessageId for the response message
    // Add entry for each SMB2 request, and use fidByMid to set fileId when decode SMB2 response
    map<ulong, ulong> fidByMid = {};

    // section 3.2.4.1.6, "The client MUST use the lowest available sequence number in its allowable set for each request."
    ulong nextExpectedMessageId = 0; // nextExpectedMessageId is the lowest available sequence number in the allowable message id window.

    // Indicates if PduFull bit is set in SMB ETW provider
    bool pduFull = true;

    // Get the values from NegotiateResponse message
    observe this issues m:Messages.NegotiateResponse
    {
        var resp = m.Response as SMB2.SMB2NegotiateResponse;
        dialect = resp.DialectRevision;
        supportsMultiCredit =  (resp.Capabilities & SMB2.SMB2NegotiateResponseCapabilities.SMB2GlobalCapLargeMtu) > 0;
        supportsMultiChannel =  (resp.Capabilities & SMB2.SMB2NegotiateResponseCapabilities.SMB2GlobalCapMultiChannel) > 0;
        if (nextExpectedMessageId == 0)
        {
            // increase nextExpectedMessageId for COM NEGOTIATE message
            nextExpectedMessageId = m.Header.CreditCharge > 0 ? m.Header.CreditCharge : 1;
        }
    }
    
    // Updates the credits and validate if it exceeds the number of granted.
    // Exclude the credits check if the negotiate message is missing or there's message can't be decoded completely
    observe this accepts m:SMB2Request where (dialect != 0 && !hasAnyMessageDecodeFailed) || m.Header.Command == SMB2.SMB2PacketHeaderCommand.SMB2Negotiate
    {
        /* Decreases the credits consumed by client.
         * If the server implements SMB 2.1 or later version and the request is a multi-credit request,
         * the credit consumed is based on the CreditCharge field, or else consumes one credit for any
         * request except for the SMB2 CANCEL Request.
         */
        if (supportsMultiCredit && m.Header.CreditCharge > 1 && (dialect != SMB2.SMB2NegotiateResponseDialectRevision.SMB2002DialectRevisionNumber))
        {
            credits -= m.Header.CreditCharge;
        }
        else
        {
            credits--;
        }
        ValidationCheck(credits >= 0, m, DiagnosisLevel.Error, FileSharingResources.SMB2_STR_CHECK_MESSAGE_CREDIT);
        if (m.Header.Command != SMB2.SMB2PacketHeaderCommand.SMB2Cancel)
        {
            ValidationCheck(m.Header.MessageId == nextExpectedMessageId, m, () => Format(FileSharingResources.SMB2_STR_CHECK_MESSAGE_ID, nextExpectedMessageId));
            // section 2.2.1.1   SMB2 Packet Header - ASYNC
            // In the SMB 2.0.2 dialect, this field MUST NOT be used and MUST be reserved. The sender MUST set this to 0, and the receiver MUST ignore it.
            // In all other dialects, this field indicates the number of credits that this request consumes.
            var temp = m.Header.MessageId + (m.Header.CreditCharge > 0 ? m.Header.CreditCharge : 1);
            nextExpectedMessageId = nextExpectedMessageId > temp ? nextExpectedMessageId :temp;
        }
    }
    
    // Accumulates the credits granted by the server
    observe this issues m:SMB2Response where dialect != 0 && !hasAnyMessageDecodeFailed
    {
        credits += m.Header.Credit;
    }

    observe this accepts req:SMB2Request where req.Header.Command >= 1
    { 
        var mid = req.Header.MessageId;
        var command = req.Header.Command;

        if (req.Header.Command > 1) // the messages after SMB2 SESSION_SETUP
        {
            // deal with SMB2FileName
            var fileId = GetSMB2FileId(req);
            fidByMid[mid] = fileId;

            /* Set the value of annotation FileName based on the FileId for the other request messages 
             * and store the file name by MessageId for the response messages
             */
            if (fileId in cachedOpens)
            {
                req#SMB2FileName = cachedOpens[fileId];
            }
            else if (supportsMultiChannel && fileId in SMB2GlobalFileNames)
            {
                req#SMB2FileName = SMB2GlobalFileNames[fileId];
            }
            // Store the file name by MessageId for SMB2 Create Request
            else if (command == SMB2.SMB2PacketHeaderCommand.SMB2Create)
            {
                CreateRequestByMid[mid] = req as SMB2.Messages.CreateRequest;
            }
            // if the capture doesn't include the create request or doesn't include the create response, the following request use fileId as SMB2FileName
            else if (req#SMB2FileName is nothing && fileId != InvalidFileId)
            {
                req#SMB2FileName = Utility.DecToHexFormat(fileId);
            }

            // deal with SMB2TreeIdName
            var optionalTreeid = req.Header.TreeId;
            if (optionalTreeid is treeId:ULONG)
            {
                if (treeId in cachedTreeConnects)
                {
                    req#SMB2TreeIdName = cachedTreeConnects[treeId];
                }
                else if (supportsMultiChannel && treeId in SMB2GlobalTreeIdToPath)
                {
                     req#SMB2TreeIdName = SMB2GlobalTreeIdToPath[treeId];
                }
                else if (command == SMB2.SMB2PacketHeaderCommand.SMB2TreeConnect)
                {
                    TreeConnectRequestByMid[mid] = req as SMB2.Messages.TreeConnectRequest;
                }
                // if the capture doesn't include tree connect message, set #SMB2TreeIdName to "(SessionId)" for the following requests
                else if (req#SMB2TreeIdName is nothing)
                {
                    req#SMB2TreeIdName = "(" + Utility.DecToHexFormat(treeId) + ")";
                }
            }
        }

        // deal with SMB2SessionIdName
        var sessionId = req.Header.SessionId;
        if (sessionId in cachedSessions)
        {
            req#SMB2SessionIdName = cachedSessions[sessionId];
        }
        else if (command == SMB2.SMB2PacketHeaderCommand.SMB2SessionSetup)
        {
            SessionSetupRequestByMid[mid] = req as SMB2.Messages.SessionSetupRequest;
        }
        // if there is no userName or the capture doesn't include session setup message, set #SMB2SessionIdName to "(SessionId)" for the following requests
        else if (req#SMB2SessionIdName is nothing)
        {
            req#SMB2SessionIdName = "(" + Utility.DecToHexFormat(sessionId) + ")";
        }

        // ----------Begin: deal with compounded messages
        if (req.Header.NextCommand != 0 && (req.Header.Flags & SMB2.SMB2PacketHeaderFlags.SMB2FlagsRelatedOperations) == 0) // the first compounded message
        {
            foreach (var followingReq in compoundedRequests)
            {
                if (followingReq.Header.MessageId > mid)
                {
                    var sessionName = req#SMB2SessionIdName;
                    if (sessionName != nothing)
                    {
                        followingReq#SMB2SessionIdName = sessionName;
                    }
                    var treeName = req#SMB2TreeIdName;
                    if (treeName != nothing)
                    {
                        followingReq#SMB2TreeIdName = treeName;
                    }
                    var fileId = req#FileId;
                    if (fileId != nothing)
                    {
                        followingReq#FileId = fileId;
                    }
                    var fileName = req#SMB2FileName;
                    if (fileName != nothing)
                    {
                        followingReq#SMB2FileName = fileName;
                    }
                    if (followingReq.Header.NextCommand == 0) // the last compounded request
                        break;
                }
            }
        }
    }

    observe this issues res:SMB2Response where res.Header.Command >= 1
    {
        var mid = res.Header.MessageId;
        var fid = GetSMB2FileId(res);
        var command = res.Header.Command;

        // ----------Begin: To set #SMB2SessionIdName for SMB2 Response----------
        var sessionId = res.Header.SessionId;
        if (sessionId in cachedSessions)
        {
            res#SMB2SessionIdName = cachedSessions[sessionId];
        }
        else if (command == SMB2.SMB2PacketHeaderCommand.SMB2SessionSetup && mid in SessionSetupRequestByMid)
        {
            var sessionSetupReq = SessionSetupRequestByMid[mid];
            if (sessionSetupReq#SMB2SessionIdName is userName:string)
            {
                string userNameWithId = userName + "@#" + Utility.DecToHexFormat(sessionId);
                cachedSessions[sessionId] = userNameWithId;
                res#SMB2SessionIdName = userNameWithId;
                // for multichannel session binding, the session binding request include the userName itself, we set the session binding request's SMB2SessionIdName here too
                sessionSetupReq#SMB2SessionIdName = userNameWithId;
            }
            else 
            {
                string result = "(" + Utility.DecToHexFormat(sessionId) + ")";
                res#SMB2SessionIdName = result;
                sessionSetupReq#SMB2SessionIdName = result; // if there is no userName, set SMB2 SessionSetupRequest#SMB2SessionIdName to "(SessionId)"
            }

            if (!(res is errorRes:SMB2.Messages.ErrorResponse && errorRes.Header.Status is sta:ERREF.NTSTATUS && sta.Value == Smb2StatusValue.STATUS_PENDING))
            {
                SessionSetupRequestByMid = SessionSetupRequestByMid.Remove(mid);
            }
        }
        // if there is no userName or the capture doesn't include session setup message, set #SMB2SessionIdName to "(SessionId)" for the following responses
        else if (res#SMB2SessionIdName is nothing)
        {
            res#SMB2SessionIdName = "(" + Utility.DecToHexFormat(sessionId) + ")";
        }
        // ----------End: To set #SMB2SessionIdName for SMB2 Response----------

        if (res.Header.Command > 1) // the messages after SMB2 SESSION_SETUP
        {
            // ----------Begin: To set #SMB2TreeIdName for SMB2 Response----------
            var optionalTreeid = res.Header.TreeId;
            if (optionalTreeid is treeId:ULONG)
            {
                if (treeId in cachedTreeConnects)
                {
                    res#SMB2TreeIdName = cachedTreeConnects[treeId];
                }
                else if (supportsMultiChannel && treeId in SMB2GlobalTreeIdToPath)
                {
                     res#SMB2TreeIdName = SMB2GlobalTreeIdToPath[treeId];
                }
                else if (command == SMB2.SMB2PacketHeaderCommand.SMB2TreeConnect && mid in TreeConnectRequestByMid)
                {
                    var treeConnectReq = TreeConnectRequestByMid[mid];
                    if (treeConnectReq#SMB2TreeIdName is path:string)
                    {
                        string pathWithId = path + "@#" + Utility.DecToHexFormat(treeId);
                        cachedTreeConnects[treeId] = pathWithId;
                        if (supportsMultiChannel)
                        {
                            SMB2GlobalTreeIdToPath[treeId] = pathWithId;
                        }
                        res#SMB2TreeIdName = pathWithId;
                        treeConnectReq#SMB2TreeIdName = pathWithId;

                        if (!(res is errorRes:SMB2.Messages.ErrorResponse && errorRes.Header.Status is sta:ERREF.NTSTATUS && sta.Value == Smb2StatusValue.STATUS_PENDING))
                        {
                            TreeConnectRequestByMid = TreeConnectRequestByMid.Remove(mid);
                        }
                    }
                }
                // if the capture doesn't include tree connect message, set #SMB2TreeIdName to "(SessionId)" for the following responses
                else if (res#SMB2TreeIdName is nothing)
                {
                    res#SMB2TreeIdName = "(" + Utility.DecToHexFormat(treeId) + ")";
                }
            }
            // ----------End: To set #SMB2FileName for SMB2 Response----------

            // ----------Begin: If #FileId is not set by lower level, then set #FileId for SMB2 Response----------
            // fid == InvalidFileId: #FileId is not set
            // mid in fidByMid: we can get response#FileId from fidByMid which is cached when decode request
            if (fid == InvalidFileId && mid in fidByMid)
            {
                fid = fidByMid[mid];
                if (!(res is errorRes:SMB2.Messages.ErrorResponse && errorRes.Header.Status is sta:ERREF.NTSTATUS && sta.Value == Smb2StatusValue.STATUS_PENDING))
                {
                    fidByMid = fidByMid.Remove(mid);
                }
                res#FileId = fid;
            }
            // ----------End: If #FileId is not set by lower level, then set #FileId for SMB2 Response----------

            // ----------Begin: To set #SMB2FileName for SMB2 Response----------
            // If #FileId is set by when decode SMB2 message in DecodeAndDispatchRequestMessages and DecodeAndDispatchResponseMessages
            // or #FileId is set by per fidByMid
            if (fid != InvalidFileId)
            {
                // If fid in cachedOpens,set #SMB2FileName per cachedOpens
                if (fid in cachedOpens)
                {
                    res#SMB2FileName = cachedOpens[fid];
                }
                else if (supportsMultiChannel && fid in SMB2GlobalFileNames)
                {
                    res#SMB2FileName = SMB2GlobalFileNames[fid];
                }
                // For CreateResponse, set #SMB2FileName per CreateRequestByMid, cache filename in cachedOpens and SMB2GlobalFileNames
                else if (command == SMB2.SMB2PacketHeaderCommand.SMB2Create && mid in CreateRequestByMid)
                {
                    var createReq = CreateRequestByMid[mid];
                    if (createReq#SMB2FileName is fileName:string)
                    {
                        string fileNameWithId = fileName + "@#" + Utility.DecToHexFormat(fid);
                        cachedOpens[fid] = fileNameWithId;
                        // Keep in SMB2GlobalFileNames if client supports multi channel
                        if (supportsMultiChannel)
                        {
                            SMB2GlobalFileNames[fid] = fileNameWithId;
                        }

                        res#SMB2FileName = fileNameWithId;
                        createReq#SMB2FileName = fileNameWithId;

                        // cache the map between LeaseKey and FileName
                        if (createReq.Request.Buffer.CreateContextList is ctxList:array<SMB2CreateContextRequest> && ctxList != null)
                        {
                            foreach (var ctx in ctxList)
                            {
                                if (ctx.Buffer.Data is lease:SMB2CreateRequestLease)
                                {
                                    var names = new SMB2Names{SessionIdName = res#SMB2SessionIdName, TreeIdName = res#SMB2TreeIdName, FileName = fileNameWithId};
                                    SMB2GlobalLeaseKeyMapToNames[lease.LeaseKey] = names;
                                    break;
                                }
                                else if (ctx.Buffer.Data is lease2:SMB2CreateRequestLeaseV2)
                                {
                                    var names = new SMB2Names{SessionIdName = res#SMB2SessionIdName, TreeIdName = res#SMB2TreeIdName, FileName = fileNameWithId};
                                    SMB2GlobalLeaseKeyMapToNames[lease2.LeaseKey] = names;
                                    break;
                                }
                            }
                        }

                        // Clear map entry in CreateRequestByMid
                        if (!(res is errorRes:SMB2.Messages.ErrorResponse && errorRes.Header.Status is sta:ERREF.NTSTATUS && sta.Value == Smb2StatusValue.STATUS_PENDING))
                        {
                            CreateRequestByMid = CreateRequestByMid.Remove(mid);
                        }
                    }
                }
                else if (res#SMB2FileName is nothing)
                {
                    // if the capture doesn't include the create request, the following responses(include the create response) will use fid as SMB2FileName,
                    //      if the capture include the create response. for create response, the fid is in the response message;
                    //      if the capture donesn't include the create response, for the following response, the fid is from the matching request by using fidByMid
                    res#SMB2FileName = Utility.DecToHexFormat(fid);
                }
            }
            // ----------End: To set #SMB2FileName for SMB2 Response----------
        }

        // ----------Begin: deal with compounded messages
        if (res.Header.NextCommand != 0)
        {
            if (res is SMB2.Messages.SessionSetupResponse)
            {
                foreach (var followingReq in compoundedRequests)
                {
                    if (followingReq.Header.MessageId > mid)
                    {
                        var sessionName = res#SMB2SessionIdName;
                        if (sessionName != nothing)
                        {
                            followingReq#SMB2SessionIdName = sessionName;
                        }
                    }
                    if (followingReq.Header.NextCommand == 0) // the last compounded request
                        break;
                }
            }
            else if (res is SMB2.Messages.TreeConnectResponse)
            {
                foreach (var followingReq in compoundedRequests)
                {
                    if (followingReq.Header.MessageId > mid)
                    {
                        var treeName = res#SMB2TreeIdName;
                        if (treeName != nothing)
                        {
                            followingReq#SMB2TreeIdName = treeName;
                        }
                    }
                    if (followingReq.Header.NextCommand == 0) // the last compounded request
                        break;
                }
            }
            else if (res is SMB2.Messages.CreateResponse)
            {
                foreach (var followingReq in compoundedRequests)
                {
                    if (followingReq.Header.MessageId > mid)
                    {
                        var fileId = res#FileId;
                        if (fileId != nothing)
                        {
                            followingReq#FileId = fileId;
                        }
                        var fileName = res#SMB2FileName;
                        if (fileName != nothing)
                        {
                            followingReq#SMB2FileName = fileName;
                        }
                    }
                    if (followingReq.Header.NextCommand == 0) // the last compounded request
                        break;
                }
            }

            foreach (var followingRes in compoundedResponses)
            {
                if (followingRes.Header.MessageId > mid)
                {
                    var sessionName = res#SMB2SessionIdName;
                    if (sessionName != nothing)
                    {
                        followingRes#SMB2SessionIdName = sessionName;
                    }
                    var treeName = res#SMB2TreeIdName;
                    if (treeName != nothing)
                    {
                        followingRes#SMB2TreeIdName = treeName;
                    }
                    var fileId = res#FileId;
                    if (fileId != nothing)
                    {
                        followingRes#FileId = fileId;
                    }
                    var fileName = res#SMB2FileName;
                    if (fileName != nothing)
                    {
                        followingRes#SMB2FileName = fileName;
                    }
                    if (followingRes.Header.NextCommand == 0) // the last compounded response
                        break;
                }
            }
        }
        else if ((res.Header.Flags & SMB2.SMB2PacketHeaderFlags.SMB2FlagsRelatedOperations) != 0)  // the last compounded response
        {
            compoundedRequests = [];
            compoundedResponses =[];
        }
    }

    process this accepts m:SMB2Request where m.Header.Command > 3
    {
        if (!pduFull)
        {
            DisplayTopLevelMessage(m);
        }
        else if (m.Header.Command == SMB2.SMB2PacketHeaderCommand.SMB2Cancel)
        {
            dispatch (endpoint FileServer[InvalidFileId, m.Header.SessionId]) accepts m;
        }
        else
        {
            dispatch (endpoint FileServer[GetSMB2FileId(m), m.Header.SessionId]) accepts m;
        }
    }
    
    process this issues m:SMB2Response where m.Header.Command > 2
    {
        ulong fid = GetSMB2FileId(m);
        if (m.Header.Command == SMB2.SMB2PacketHeaderCommand.SMB2Close) // for SMB2 close response, delete the entry
        {
            if (fid in SMB2GlobalFileNames)
            {
                SMB2GlobalFileNames = SMB2GlobalFileNames.Remove(fid);
            }
            if (fid in cachedOpens)
            {
                cachedOpens = cachedOpens.Remove(fid);
            }
        }

        if (m.Header.Command == SMB2.SMB2PacketHeaderCommand.SMB2Logoff)
        {
            ulong sessionId = m.Header.SessionId;
            if (sessionId in cachedSessions)
            {
                cachedSessions = cachedSessions.Remove(sessionId);
            }
        }

        if (m.Header.Command == SMB2.SMB2PacketHeaderCommand.SMB2TreeDisconnect)
        {
            var optionalTreeid = m.Header.TreeId;
            if (optionalTreeid is treeId:ULONG)
            {
                if (treeId in SMB2GlobalTreeIdToPath)
                {
                    SMB2GlobalTreeIdToPath = SMB2GlobalTreeIdToPath.Remove(treeId);
                }
                if (treeId in cachedTreeConnects)
                {
                    cachedTreeConnects = cachedTreeConnects.Remove(treeId);
                }
            }
        }
        if (!pduFull)
        {
            DisplayTopLevelMessage(m);
        }
        else
        {
            dispatch (endpoint FileServer[fid, m.Header.SessionId]) issues m;
        }
    }

    ~endpoint(Server server)
    {
        cachedOpens = {};
        cachedSessions = {};
        cachedTreeConnects = {};
        CreateRequestByMid = {};
        SessionSetupRequestByMid = {};
        TreeConnectRequestByMid = {};
        compoundedRequests = [];
        compoundedResponses = [];
        fidByMid = {};
    }
}

// actor to dispatch SMB Com Negotiate to VirtualOperation endpoint. So SMB Com Negotiate Request and SMB2 Negotiate Response can be grouped.
autostart actor SMBNegotiateActor(SMB.Server server)
{
    process server accepts m:SMB.Messages.ComNegotiateRequest
    {
        SMB.LowestServer lowestServer = server.GetTransport<SMB.LowestServer>();
        if (lowestServer != null)
        {
            SMBTransport.Server smbOverTcpEndpoint = lowestServer.GetTransport<SMBTransport.Server>();
            if (smbOverTcpEndpoint != null)
            {
                dispatch (endpoint Server[SMB2.DefaultSmb2ServerIndex] over smbOverTcpEndpoint) accepts m;
                return;
            }
            NBTSS.Server nbtssEndpoint = lowestServer.GetTransport<NBTSS.Server>();
            if (nbtssEndpoint != null)
            {
                dispatch (endpoint Server[SMB2.DefaultSmb2ServerIndex] over nbtssEndpoint) accepts m;
                return;
            }
            // The transport of SMB.LowestServer could also be ep_Microsoft_Windows_SMBClient(which is defined in Microsoft_Windows_SMBClient module) or
            // ep_Microsoft_Windows_SmbServer as used in SuppSMBxx.opn. But we can not reference these modules because they are generated dynamically.
            // So, here, we directly dispatch the SMB.Messages.ComNegotiateRequest to a VirtualOperationServer endpoint without specifying the underlying transport.
            // The potential issue is that, if multiple SMB2 endpoints begins ComNegotiate in the same time (which is less common), 
            // then MA may erroneously group SMB.ComNegotiateRequest/SMB2.NegotiateResponse from different endpoint as a virtual operation.
            if (lowestServer.GetTransport() != null)
            {
                if (m#EndpointIndex is edpIdx:binary && edpIdx != null)
                {
                    dispatch (endpoint Server[edpIdx]) accepts m;
                }
                else
                {
                    dispatch (endpoint Server[SMB2.DefaultSmb2ServerIndex]) accepts m;
                }
                return;
            }
        }
        reject;
    }
}

//-------------------------------------------
// Client side

// The same architecture is defined for the Client.
client endpoint Client connected to Server;
client endpoint FileClient connected to FileServer;

// -------------------------------------------
// Actors

// Actor that listens to TransportPacket messages on both possible directions.
autostart actor SMB2OverSMBTransport(SMBTransport.Server server) precedes SMBTransport.SMB2OverSMBTransportWithoutFileSharing
{
    Smb2DecodingContext dc = new Smb2DecodingContext{};

    // Parsing request message
    process server accepts s:SMBTransport.TransportPacket where GetProtocolIdBin(s) == SMB2ProtocolId
    {
        DecodeAndDispatchRequestMessages(dc, s.SMBMessage, GetSMB2Server(server));
    }

    // Parsing response message
    process server issues s:SMBTransport.TransportPacket where GetProtocolIdBin(s) == SMB2ProtocolId
    {
        DecodeAndDispatchResponseMessages(dc, s.SMBMessage, GetSMB2Server(server));
    }

    // Parsing Transform request message
    process server accepts s:SMBTransport.TransportPacket where GetProtocolIdBin(s) == SMB3EncryptdProtocolId
    {
        switch (s.SMBMessage)
        {
            case m:TransformMessage from BinaryDecoder<TransformMessage[dc.DialectRevision, dc.CipherId]> =>
                dispatch GetSMB2Server(server) accepts m;
            default =>
                ThrowDecodingException("SMB2 Transform");
        }
    }

    // Parsing Transform response message
    process server issues s:SMBTransport.TransportPacket where GetProtocolIdBin(s) == SMB3EncryptdProtocolId
    {
        switch (s.SMBMessage)
        {
            case m:TransformMessage from BinaryDecoder<TransformMessage[dc.DialectRevision, dc.CipherId]> =>
                dispatch GetSMB2Server(server) issues m;
            default =>
                ThrowDecodingException("SMB2 Transform");
        }
    }

    // Parsing Compression Transform request message
    process server accepts s:SMBTransport.TransportPacket where GetProtocolIdBin(s) == SMB3CompressionProtocolId
    {
        switch (s.SMBMessage)
        {
            case m:CompressedTransformMessage from BinaryDecoder<CompressedTransformMessage> =>
                dispatch GetSMB2Server(server) accepts m;
            default =>
                ThrowDecodingException("SMB2 CompressionTransform");
        }
    }

    // Parsing Compression Transform response message
    process server issues s:SMBTransport.TransportPacket where GetProtocolIdBin(s) == SMB3CompressionProtocolId
    {
        switch (s.SMBMessage)
        {
            case m:CompressedTransformMessage from BinaryDecoder<CompressedTransformMessage> =>
                dispatch GetSMB2Server(server) issues m;
            default =>
                ThrowDecodingException("SMB2 CompressionTransform");
        }
    }
}

// Actor that listens to SessionService messages on both possible directions.
autostart actor SMB2OverNBTSS(NBTSS.Server server) precedes SMBTransport.SMBTransportOverNBTSS
{
    Smb2DecodingContext dc = null;

    // Parsing request message
    process server accepts s:NBTSS.SessionService where GetProtocolIdBin(s) == SMB2ProtocolId
    {
        if (dc == null)
        {
            dc = new Smb2DecodingContext{};
        }
        DecodeAndDispatchRequestMessages(dc, (s.Trailer as SessionMessagePacket).UserData, GetSMB2Server(server));
    }

    // Parsing response message
    process server issues s:NBTSS.SessionService where GetProtocolIdBin(s) == SMB2ProtocolId
    {
        if (dc == null)
        {
            dc = new Smb2DecodingContext{};
        }
        DecodeAndDispatchResponseMessages(dc, (s.Trailer as SessionMessagePacket).UserData, GetSMB2Server(server));
    }

    // Parsing Transform request message
    process server accepts s:NBTSS.SessionService where GetProtocolIdBin(s) == SMB3EncryptdProtocolId
    {
        if (dc == null)
        {
            dc = new Smb2DecodingContext{};
        }
        switch ((s.Trailer as SessionMessagePacket).UserData)
        {
            case m:TransformMessage from BinaryDecoder<TransformMessage[dc.DialectRevision, dc.CipherId]> =>
                dispatch GetSMB2Server(server) accepts m;
            default =>
                 ThrowDecodingException("SMB2 TransformMessage");
        }
    }

    // Parsing Transform response message
    process server issues s:NBTSS.SessionService where GetProtocolIdBin(s) == SMB3EncryptdProtocolId
    {
        if (dc == null)
        {
            dc = new Smb2DecodingContext{};
        }
        switch ((s.Trailer as SessionMessagePacket).UserData)
        {
            case m:TransformMessage from BinaryDecoder<TransformMessage[dc.DialectRevision, dc.CipherId]> =>
                dispatch GetSMB2Server(server) accepts m;
            default =>
                 ThrowDecodingException("SMB2 TransformMessage");
        }
    }
}

autostart actor MsrpceOverSmb2Server(SMB2.FileServer server)
{
    MSRPCEOverNamedpipeDecodingHelper helper = null;

    process server issues s:SMB2.Messages.ReadResponse where helper != null && helper.IssuesCache.BufferCount() > 0 || 
        IsRpcconnCommonHdrT(s.Response.Buffer) && s.Response.Buffer[2] in IssuesMsgTypeSet
    {
        EnsureInitialized();
        helper.TryDecode(s.Response.Buffer, s, MessageDirection.Issues);
    }

    process server accepts s:SMB2.Messages.WriteRequest where helper != null && helper.AcceptsCache.BufferCount() > 0 ||
        IsRpcconnCommonHdrT(s.Request.Buffer) && s.Request.Buffer[2] in AcceptsMsgTypeSet
    {
        EnsureInitialized();
        helper.TryDecode(s.Request.Buffer, s, MessageDirection.Accepts);
    }
    
    process server accepts s:SMB2.Messages.IoctlRequest where s.Request.Buffer is bin:binary && 
        (helper != null && helper.AcceptsCache.BufferCount() > 0 || IsRpcconnCommonHdrT(bin) && bin[2] in AcceptsMsgTypeSet)
    {
        EnsureInitialized();
        helper.TryDecode(bin, s, MessageDirection.Accepts);
    }
    
    process server issues s:SMB2.Messages.IoctlResponse where s.Response.Buffer is bin:binary && 
        (helper != null && helper.IssuesCache.BufferCount() > 0 || IsRpcconnCommonHdrT(bin) && bin[2] in IssuesMsgTypeSet)
    {
        EnsureInitialized();
        helper.TryDecode(bin, s, MessageDirection.Issues);
    }
    
    ~endpoint(SMB2.FileServer server)
    {
        if (helper != null)
        {
            helper.ClearInDestructor();
        }
    }

    void EnsureInitialized()
    {
        if (helper == null)
        {
            helper = new MSRPCEOverNamedpipeDecodingHelper{};
            helper.Initialize(endpoint MSRPCE.Server over server);
        }
    }
}

// For performance consideration, file is reassembled only when there are upper layer file protocols implemented.
autostart actor ReassembleFileOverSMB2Actor(SMB2.FileServer fileServer)
{
    FAS.Server FASServer = null;
    process fileServer accepts req:Messages.WriteRequest 
            where req.FileNameReference is fileName:string && NeedFASReassemble(fileName) && req.Request.Offset == 0 || FASServer != null && 
                    FASServer.Command == CommandType.Write
    {   
        if (req.Request.Offset == 0)
        {
            FASServer = FAS.InitializeFASServer(fileServer, CommandType.Write, 
                    (any message m, FAS.Server fasServer) => (m as Messages.WriteRequest).Request.Offset,
                    (any message m) => (m as Messages.WriteRequest).Request.Buffer,
                    fileName);
        }
        dispatch FASServer accepts req;
    }
    
    observe fileServer accepts req:Messages.ReadRequest 
            where req.FileNameReference is fileName:string && NeedFASReassemble(fileName) && req.Request.Offset == 0 || FASServer != null && 
                FASServer.Command == CommandType.Read
    {
        if (req.Request.Offset == 0)
        {
            FASServer = FAS.InitializeFASServer(fileServer, CommandType.Read, 
                    (any message m, FAS.Server fasServer) => (fasServer.ReadResponseOffset != null ? (fasServer.ReadResponseOffset as ulong) : 0xFFFFFFFFFFFFFFFF), 
                    (any message m) => (m as Messages.ReadResponse).Response.Buffer,
                    fileName);
        }
        FASServer.ReadResponseOffset = req.Request.Offset;
    }
    
    process fileServer issues res:Messages.ReadResponse 
            where res.FileNameReference is fileName:string && NeedFASReassemble(fileName) && FASServer != null && 
                    FASServer.Command == CommandType.Read
    {
        dispatch FASServer issues res;
    }

    process fileServer accepts closeReq:Messages.CloseRequest where FASServer != null
    {
        dispatch FASServer accepts closeReq;
        FASServer.HasCloseRequestAccepted = true;
    }
}

// ----------------Types and functions for the message decoding---------------------------

ushort PeekUshortLE(binary data, int bytePos)
{
    return (data[bytePos] + (data[bytePos + 1] << 8)) as ushort;
}

uint PeekUintLE(binary data, int bytePos)
{
    return (data[bytePos] + (data[bytePos + 1] << 8) + (data[bytePos + 2] << 16) + (data[bytePos + 3] << 24)) as uint;
}

ulong PeekUlongLE(binary data, int bytePos)
{
    return data[bytePos] + ((data[bytePos + 1] as ulong) << 8) + ((data[bytePos + 2] as ulong) << 16) + ((data[bytePos + 3] as ulong) << 24) + 
        ((data[bytePos + 4] + ((data[bytePos + 5] as ulong) << 8) + ((data[bytePos + 6] as ulong) << 16) + ((data[bytePos + 7] as ulong) << 24)) << 32);
}

// Decoding the request messages
void DecodeAndDispatchRequestMessages(Smb2DecodingContext dc, binary payload, SMB2.Server server)
{
    // The beginning offset of current message
    int offset = 0;
    // The beginning offset of next message
    int nextOffset = 0;
    var streamLength = payload.Count;

    ushort headerCommand;
    uint headerFlags;
    uint headerNextCommand;
    binary messageData;
    bool isAsyncCommand;
    SMB2.SMB2Request m = null;
    bool isCompounded = false;
    SMB2.SMB2Request firstRequest = null;

    while (offset + SMB2_HEADER_SIZE < streamLength) // 64 is the total size of the Header part
    {
        headerCommand = PeekUshortLE(payload, offset + 12);
        headerFlags = PeekUintLE(payload, offset + 16);
        headerNextCommand = PeekUintLE(payload, offset + 20);
        nextOffset = (headerNextCommand == 0 ? streamLength : headerNextCommand + offset) as int;
        messageData = payload.Segment(offset, nextOffset - offset);
        isAsyncCommand = (headerFlags & SMB2PacketHeaderFlags.SMB2FlagsAsyncCommand) > 0;
        server.hasAnyMessageDecodeFailed = true;
        m = null;
        if (!isCompounded && headerNextCommand != 0)
        {
            isCompounded = true;
        }
        switch (headerCommand)
        {
            case SMB2PacketHeaderCommand.SMB2Negotiate =>
                if (BinaryDecoder<SMB2.Messages.NegotiateRequest[dc.DialectRevision]>(messageData) is req:SMB2.Messages.NegotiateRequest)
                {
                    m = req;
                }

            case SMB2PacketHeaderCommand.SMB2SessionSetup =>
                if (BinaryDecoder<SMB2.Messages.SessionSetupRequest[dc.DialectRevision]>(messageData) is req:SMB2.Messages.SessionSetupRequest)
                {
                    DecodeSecurityBufferInSMB2SessionSetupRequest(req);
                    if (messageData.Count < req.Request.SecurityBufferOffset + req.Request.SecurityBufferLength)
                    {
                        ReportInsufficientTruncation(req, "SMB2", "Buffer", "SessionSetupRequest", !dc.pduFull);
                    }
                    NlmpMessage nlmpMess = null;
                    if (req.Request.Buffer is nlmpMess1:NlmpMessage)
                    {
                        nlmpMess = nlmpMess1;
                    }
                    else if (req.Request.Buffer is gss:GssapiType && GetNTLMFromGssapiType(gss) is nlmpMess2:NlmpMessage)
                    {
                        nlmpMess = nlmpMess2;
                    }
                    if (nlmpMess != null && nlmpMess is authMess:AuthenticateMessage && authMess.UserName is name:string)
                    {
                        if (authMess.WorkstationName != nothing)
                            req#SMB2SessionIdName = (authMess.WorkstationName as string) + "\\" + name;
                        else if (authMess.DomainName != nothing)
                            req#SMB2SessionIdName = (authMess.DomainName as string) + "\\" + name;
                        else
                            req#SMB2SessionIdName = name;
                    }

                    m = req;
                }

            case SMB2PacketHeaderCommand.SMB2Logoff =>
                if (BinaryDecoder<SMB2.Messages.LogoffRequest[dc.DialectRevision]>(messageData) is req:SMB2.Messages.LogoffRequest)
                {
                    m = req;
                }

            case SMB2PacketHeaderCommand.SMB2TreeConnect =>
                if (BinaryDecoder<SMB2.Messages.TreeConnectRequest[dc.DialectRevision]>(messageData) is req:SMB2.Messages.TreeConnectRequest)
                {
                    req#SMB2TreeIdName = req.Request.GetPathName();
                    m = req;
                }

            case SMB2PacketHeaderCommand.SMB2TreeDisconnect =>
                if (BinaryDecoder<SMB2.Messages.TreeDisconnectRequest[dc.DialectRevision]>(messageData) is req:SMB2.Messages.TreeDisconnectRequest)
                {
                    m = req;
                }
            case SMB2PacketHeaderCommand.SMB2Create =>
                bool isDirectory = (messageData.Count >= 108) ? (PeekUintLE(messageData, 104) & SMB2.SMB2CreateRequestCreateOptions.FileDirectoryFile) > 0 : false;
                if (BinaryDecoder<SMB2.Messages.CreateRequest[dc.DialectRevision, isDirectory]>(messageData) is req:SMB2.Messages.CreateRequest)
                {
                    // Set annotation for create request.
                    req#SMB2FileName = (req.Request.Buffer == null || !(req.Request.Buffer.Name is name:StringNotNullOrEmpty)) ? "*NULL*": req.Request.Buffer.Name.ToString();
                    m = req;
                }
            case SMB2PacketHeaderCommand.SMB2Close =>
                if (BinaryDecoder<SMB2.Messages.CloseRequest[dc.DialectRevision]>(messageData) is req:SMB2.Messages.CloseRequest)
                {
                    req#FileId = req.Request.FileId.Persistent;
                    m = req;
                }

            case SMB2PacketHeaderCommand.SMB2Flush =>
                if (BinaryDecoder<SMB2.Messages.FlushRequest[dc.DialectRevision]>(messageData) is req:SMB2.Messages.FlushRequest)
                {
                    req#FileId = req.Request.FileId.Persistent;
                    m = req;
                }

            case SMB2PacketHeaderCommand.SMB2Read =>
                if (BinaryDecoder<SMB2.Messages.ReadRequest[dc.DialectRevision]>(messageData) is req:SMB2.Messages.ReadRequest)
                {
                    req#FileId = req.Request.FileId.Persistent;
                    m = req;
                }

            case SMB2PacketHeaderCommand.SMB2Write =>
                if (BinaryDecoder<SMB2.Messages.WriteRequest[dc.DialectRevision]>(messageData) is req:SMB2.Messages.WriteRequest)
                {
                    if (messageData.Count < req.Request.DataOffset + req.Request.Length)
                    {
                        ReportInsufficientTruncation(req, "SMB2", "Buffer", "WriteRequest", !dc.pduFull);
                    }
                    req#FileId = req.Request.FileId.Persistent;
                    m = req;
                }
                        
            case SMB2PacketHeaderCommand.SMB2Lock =>
                if (BinaryDecoder<SMB2.Messages.LockRequest[dc.DialectRevision]>(messageData) is req:SMB2.Messages.LockRequest)
                {
                    req#FileId = req.Request.FileId.Persistent;
                    m = req;
                }

            case SMB2PacketHeaderCommand.SMB2Ioctl =>
                if (BinaryDecoder<SMB2.Messages.IoctlRequest[dc.DialectRevision]>(messageData) is req:SMB2.Messages.IoctlRequest)
                {
                    req#FileId = req.Request.FileId.Persistent;
                    if (messageData.Count < req.Request.InputOffset + req.Request.InputCount)
                    {
                        ReportInsufficientTruncation(req, "SMB2", "Buffer", "IoctlRequest", !dc.pduFull);
                    }
                    // Keep the HashRetrievalType in cache for the response message
                    if (req.Request.Buffer is buffer:SrvReadHashRequest)
                    {
                        var key = CombineAsDouble(req.Header.MessageId, req.Header.SessionId);
                        dc.hashRetrievalTypeMap[key] = buffer.HashRetrievalType;
                        dc.hashVersionMap[key] = buffer.HashVersion;
                        dc.offsetMap[key] = buffer.Offset;
                    }
                    m = req;
                }

            case SMB2PacketHeaderCommand.SMB2Echo =>
                if (BinaryDecoder<SMB2.Messages.EchoRequest[dc.DialectRevision]>(messageData) is req:SMB2.Messages.EchoRequest)
                {
                    m = req;
                }

            case SMB2PacketHeaderCommand.SMB2Cancel =>
                if (BinaryDecoder<SMB2.Messages.CancelRequest[dc.DialectRevision]>(messageData) is req:SMB2.Messages.CancelRequest)
                {
                    m = req;
                }

            case SMB2PacketHeaderCommand.SMB2QueryDirectory =>
                if (BinaryDecoder<SMB2.Messages.QueryDirectoryRequest[dc.DialectRevision]>(messageData) is req:SMB2.Messages.QueryDirectoryRequest)
                {
                    var key = CombineAsDouble(req.Header.MessageId, req.Header.SessionId);
                    dc.queryInfoClassMap[key] = req.Request.FileInformationClass;
                    req#FileId = req.Request.FileId.Persistent;
                    m = req;
                }

            case SMB2PacketHeaderCommand.SMB2ChangeNotify =>
                if (BinaryDecoder<SMB2.Messages.ChangeNotifyRequest[dc.DialectRevision]>(messageData) is req:SMB2.Messages.ChangeNotifyRequest)
                {
                    req#FileId = req.Request.FileId.Persistent;
                    m = req;
                }

            case SMB2PacketHeaderCommand.SMB2QueryInfo =>
                if (BinaryDecoder<SMB2.Messages.QueryInfoRequest[dc.DialectRevision]>(messageData) is req:SMB2.Messages.QueryInfoRequest)
                {
                    var key = CombineAsDouble(req.Header.MessageId, req.Header.SessionId);
                    dc.queryInfoTypeMap[key] = req.Request.InfoType;
                    dc.queryInfoClassMap[key] = req.Request.FileInfoClass;
                    if (messageData.Count < req.Request.InputBufferOffset + req.Request.InputBufferLength)
                    {
                        ReportInsufficientTruncation(req, "SMB2", "Buffer", "QueryInfoRequest", !dc.pduFull);
                    }
                    req#FileId = req.Request.FileId.Persistent;
                    m = req;
                }

            case SMB2PacketHeaderCommand.SMB2SetInfo =>
                if (BinaryDecoder<SMB2.Messages.SetInfoRequest[dc.DialectRevision]>(messageData) is req:SMB2.Messages.SetInfoRequest)
                {
                    if (messageData.Count < req.Request.BufferOffset + req.Request.BufferLength)
                    {
                        ReportInsufficientTruncation(req, "SMB2", "Buffer", "SetInfoRequest", !dc.pduFull);
                    }
                    req#FileId = req.Request.FileId.Persistent;
                    m = req;
                }
                        
            case SMB2PacketHeaderCommand.SMB2OplockBreak =>
                // Look ahead the value of the StructureSize field in request package
                var structureSize = PeekUshortLE(messageData, SMB2_HEADER_SIZE);
                if (structureSize == 24)
                {
                    if (BinaryDecoder<SMB2.Messages.OplockBreakAcknowledgment[dc.DialectRevision]>(messageData) is req:SMB2.Messages.OplockBreakAcknowledgment)
                    {
                        req#FileId = req.Acknowledgment.FileId.Persistent;
                        m = req;
                    }
                }
                else if (BinaryDecoder<SMB2.Messages.LeaseBreakAcknowledgment[dc.DialectRevision]>(messageData) is req1:SMB2.Messages.LeaseBreakAcknowledgment)
                {
                    m = req1;
                    if (req1.Acknowledgment.LeaseKey in SMB2GlobalLeaseKeyMapToNames)
                    {
                        var names = SMB2GlobalLeaseKeyMapToNames[req1.Acknowledgment.LeaseKey];
                        m#SMB2FileName = names.FileName;
                        m#SMB2SessionIdName = names.SessionIdName;
                        m#SMB2TreeIdName = names.TreeIdName;
                    }
                }

            default =>
                ThrowDecodingException("SMB2", UTILITY_UNKNOWN_DATA, ["SMB2 request message"]);
        }
        
        if (m != null)
        {
            // Set annotation to mark if this message is in a compounded message chain
            if (isCompounded)
            {
                m#IsCompounded = true;

                // only need handle compounded related messages
                if ((m.Header.Flags & SMB2.SMB2PacketHeaderFlags.SMB2FlagsRelatedOperations) == 0) // the first compounded message
                {
                    firstRequest = m;
                }
                else if ((m.Header.Flags & SMB2.SMB2PacketHeaderFlags.SMB2FlagsRelatedOperations) != 0) // the following compounded related messages
                {
                    if (firstRequest != null)
                    {
                        // clean previous cache when caching the first compounded request
                        server.compoundedRequests = [];
                        server.compoundedResponses = [];
                        server.compoundedRequests += [firstRequest];
                        firstRequest = null;
                    }
                    if (server.compoundedRequests.Count > 0) // insert the following compounded related messages only if we have insert the first request
                        server.compoundedRequests += [m];
                }
            }
            
            server.hasAnyMessageDecodeFailed = false;
            server.pduFull = dc.pduFull;
            // Dispatch the message
            dispatch server accepts m;
        }
        else if (BinaryDecoder<SMB2HeaderOnly[true, dc.DialectRevision]>(messageData) is headerOnlyMsg:SMB2HeaderOnly) // try to decode header only message
        {
            headerOnlyMsg#SMB2MessageName = SMB2HeaderOnlyMessageName(headerOnlyMsg);
            DisplayTopLevelMessage(headerOnlyMsg);
        }
        else
        {
            ThrowDecodingException("SMB2");
        }
        // Update the offset value to the beginning of next message
        offset = nextOffset;
    }
}

// Decoding the response messages
void DecodeAndDispatchResponseMessages(Smb2DecodingContext dc, binary payload, SMB2.Server server)
{
    int offset = 0;
    int nextOffset = 0;
    var streamLength = payload.Count;
    ushort headerCommand;
    uint headerFlag;
    uint headerNextCommand;
    uint headerStatus;
    bool isCompounded = false;
    SMB2.SMB2Response firstResponse = null;

    while (offset + SMB2_HEADER_SIZE < streamLength) // 64 is the total size of the Header part
    {
        headerStatus = PeekUintLE(payload, offset + 8);
        headerCommand = PeekUshortLE(payload, offset + 12);
        headerFlag = PeekUintLE(payload, offset + 16);
        headerNextCommand = PeekUintLE(payload, offset + 20);
        nextOffset = (headerNextCommand == 0 ? streamLength : headerNextCommand + offset) as int;
        var messageData = payload.Segment(offset, nextOffset - offset);
        bool isAsyncCommand = (headerFlag & SMB2PacketHeaderFlags.SMB2FlagsAsyncCommand) > 0;
        var structureSize = PeekUshortLE(messageData, SMB2_HEADER_SIZE);
        server.hasAnyMessageDecodeFailed = true;
        SMB2.SMB2Response m = null;
        if (!isCompounded && headerNextCommand != 0)
        {
            isCompounded = true;
        }
        // (headerStatus != 0x00000000): for most case, the Status is STATUS_SUCCESS, we needn't call IsErrorResponse
        if ((headerStatus != 0x00000000) && IsErrorResponse(headerCommand, headerStatus, structureSize == 49, isAsyncCommand))
        {
            if (BinaryDecoder<Messages.ErrorResponse[headerStatus, dc.DialectRevision]>(messageData) is tm:SMB2.Messages.ErrorResponse)
            {
                m = tm;
            }
        }
        else
        {
            switch (headerCommand)
            {
                case SMB2PacketHeaderCommand.SMB2Negotiate =>
                    if (BinaryDecoder<SMB2.Messages.NegotiateResponse>(messageData) is tm:SMB2.Messages.NegotiateResponse)
                    {       
                        // get dc.DialectRevision from SMB2.NegotiateResponse 
                        dc.DialectRevision = tm.Response.DialectRevision;
                        // get dc.CipherId from SMB2.NegotiateResponse 
                        if (dc.DialectRevision == SMB2NegotiateResponseDialectRevision.SMB311DialectRevisionNumber &&
                            tm.Response.NegotiateContextList is negotiateContextList:array<SMB2NegotiateContext>)
                        {
                            foreach (var negotiateContext in negotiateContextList)
                            {
                                if (negotiateContext.Data is encryptionAlgorithms:SMB2EncryptionCapabilities)
                                {
                                    if (encryptionAlgorithms.Ciphers.Count >= 1)
                                    {
                                        dc.CipherId = encryptionAlgorithms.Ciphers[0];
                                    }
                                }                               
                            }
                        }

                        if (messageData.Count < tm.Response.SecurityBufferLength + tm.Response.SecurityBufferOffset)
                        {
                            ReportInsufficientTruncation(tm, "SMB2", "Buffer", "NegotiateResponse", !dc.pduFull);
                        }
                        if ((tm.Response.Buffer is b:binary) && IsGSSAPIByCheckingTag(b))
                        {
                            if (DecodeGssapiAndSetAnnotation(tm.Response.Buffer as binary, tm) is gssapi:GssapiType)
                            {
                                tm.Response.Buffer = gssapi as GssapiType;
                            }
                            else
                            {
                                ValidationCheck(false, tm, DiagnosisLevel.Warning, () => Format(SMB2_STR_GSSAPI_DECODING_FAILURE, "NegotiateResponse"));
                            }
                        }
                        m = tm;
                    }

                case SMB2PacketHeaderCommand.SMB2SessionSetup =>
                    if (BinaryDecoder<SMB2.Messages.SessionSetupResponse>(messageData) is tm:SMB2.Messages.SessionSetupResponse)
                    {
                        if (messageData.Count < tm.Response.SecurityBufferOffset + tm.Response.SecurityBufferLength)
                        {
                            ReportInsufficientTruncation(tm, "SMB2", "Buffer", "SessionSetupResponse", !dc.pduFull);
                        }
                        DecodeSecurityBufferInSMB2SessionSetupResponse(tm);
                        m = tm;
                    }

                case SMB2PacketHeaderCommand.SMB2Logoff =>
                    if (BinaryDecoder<SMB2.Messages.LogoffResponse>(messageData) is tm:SMB2.Messages.LogoffResponse)
                    {
                        m = tm;
                    }

                case SMB2PacketHeaderCommand.SMB2TreeConnect =>
                    if (BinaryDecoder<SMB2.Messages.TreeConnectResponse>(messageData) is tm:SMB2.Messages.TreeConnectResponse)
                    {
                        m = tm;
                    }
                case SMB2PacketHeaderCommand.SMB2TreeDisconnect =>
                    if (BinaryDecoder<SMB2.Messages.TreeDisconnectResponse>(messageData) is tm:SMB2.Messages.TreeDisconnectResponse)
                    {
                        m = tm;
                    }
                case SMB2PacketHeaderCommand.SMB2Create =>
                    if (BinaryDecoder<SMB2.Messages.CreateResponse>(messageData) is tm:SMB2.Messages.CreateResponse)
                    {
                        tm#FileId = tm.Response.FileId.Persistent;
                        m = tm;
                    }

                case SMB2PacketHeaderCommand.SMB2Close =>
                    if (BinaryDecoder<SMB2.Messages.CloseResponse>(messageData) is tm:SMB2.Messages.CloseResponse)
                    {
                        m = tm;
                    }
                case SMB2PacketHeaderCommand.SMB2Flush =>
                    if (BinaryDecoder<SMB2.Messages.FlushResponse>(messageData) is tm:SMB2.Messages.FlushResponse)
                    {
                        m = tm;
                    }
                case SMB2PacketHeaderCommand.SMB2Read =>
                    if (BinaryDecoder<SMB2.Messages.ReadResponse>(messageData) is tm:SMB2.Messages.ReadResponse)
                    {
                        if (messageData.Count < tm.Response.DataOffset + tm.Response.DataLength)
                        {
                            ReportInsufficientTruncation(tm, "SMB2", "Buffer", "ReadResponse", !dc.pduFull);
                        }
                        m = tm;
                    }

                case SMB2PacketHeaderCommand.SMB2Write =>
                    if (BinaryDecoder<SMB2.Messages.WriteResponse>(messageData) is tm:SMB2.Messages.WriteResponse)
                    {
                        m = tm;
                    }
                case SMB2PacketHeaderCommand.SMB2Lock =>
                    if (BinaryDecoder<SMB2.Messages.LockResponse>(messageData) is tm:SMB2.Messages.LockResponse)
                    {
                        m = tm;
                    }
                case SMB2PacketHeaderCommand.SMB2Ioctl =>
                    if (BinaryDecoder<SMB2.Messages.IoctlResponse>(messageData) is tm:SMB2.Messages.IoctlResponse)
                    {
                        var key = CombineAsDouble(tm.Header.MessageId, tm.Header.SessionId);
                        uint? hashRetrievalType = null;
                        uint? hashVersion = null;
                        ulong? offsetInRequest = null;

                        if (key in dc.hashRetrievalTypeMap)
                        {
                            hashRetrievalType = dc.hashRetrievalTypeMap[key];
                            dc.hashRetrievalTypeMap = dc.hashRetrievalTypeMap.Remove(key);
                        } 
                        if (key in dc.hashVersionMap)
                        {
                            hashVersion = dc.hashVersionMap[key];
                            dc.hashVersionMap = dc.hashVersionMap.Remove(key);
                        }
                        if (key in dc.offsetMap)
                        {
                            offsetInRequest = dc.offsetMap[key];
                            dc.offsetMap = dc.offsetMap.Remove(key);
                        }

                        DecodeIoctlResponseBuffer(tm.Response, hashRetrievalType, hashVersion, offsetInRequest, dc.DialectRevision);

                        if (messageData.Count < tm.Response.OutputOffset + tm.Response.OutputCount)
                        {
                            ReportInsufficientTruncation(tm, "SMB2", "Buffer", "IoctlResponse", !dc.pduFull);
                        }
                        tm#FileId = tm.Response.FileId.Persistent;
                        m = tm;
                    }
                            
                case SMB2PacketHeaderCommand.SMB2Echo =>
                    if (BinaryDecoder<SMB2.Messages.EchoResponse>(messageData) is tm:SMB2.Messages.EchoResponse)
                    {
                        m = tm;
                    }

                case SMB2PacketHeaderCommand.SMB2QueryDirectory =>
                    if (BinaryDecoder<SMB2.Messages.QueryDirectoryResponse>(messageData) is tm:SMB2.Messages.QueryDirectoryResponse)
                    {
                        var key = CombineAsDouble(tm.Header.MessageId, tm.Header.SessionId);
                        if (key in dc.queryInfoClassMap)
                        {
                            DecodeQueryDirectoryResponseBuffer(tm.Response, dc.queryInfoClassMap[key]);
                            dc.queryInfoClassMap = dc.queryInfoClassMap.Remove(key);
                        }
                        else
                        {
                            ValidationCheck(false, null, DiagnosisLevel.Error, FileSharingResources.SMB2_STR_QUERYDIRECTORYRESPONSE_FAILURE);
                        }
                        if (messageData.Count < tm.Response.OutputBufferOffset + tm.Response.OutputBufferLength)
                        {
                            ReportInsufficientTruncation(tm, "SMB2", "Buffer", "QueryDirectoryResponse", !dc.pduFull);
                        }
                        m = tm;
                    }

                case SMB2PacketHeaderCommand.SMB2ChangeNotify =>
                    if (BinaryDecoder<SMB2.Messages.ChangeNotifyResponse>(messageData) is tm:SMB2.Messages.ChangeNotifyResponse)
                    {
                        m = tm;
                    }

                case SMB2PacketHeaderCommand.SMB2QueryInfo =>
                    if (BinaryDecoder<SMB2.Messages.QueryInfoResponse>(messageData) is tm:SMB2.Messages.QueryInfoResponse)
                    {
                        var key = CombineAsDouble(tm.Header.MessageId, tm.Header.SessionId);
                        if (key in dc.queryInfoTypeMap && key in dc.queryInfoClassMap)
                        {
                            DecodeQueryInfoResponseBuffer(tm.Response, dc.queryInfoTypeMap[key], dc.queryInfoClassMap[key]);
                            dc.queryInfoTypeMap = dc.queryInfoTypeMap.Remove(key);
                            dc.queryInfoClassMap = dc.queryInfoClassMap.Remove(key);
                        }
                        else
                        {
                            ValidationCheck(false, null, DiagnosisLevel.Error, FileSharingResources.SMB2_STR_QUERYINFORESPONSE_FAILURE);
                        }
                        m = tm;
                    }
                case SMB2PacketHeaderCommand.SMB2SetInfo =>
                    if (BinaryDecoder<SMB2.Messages.SetInfoResponse>(messageData) is tm:SMB2.Messages.SetInfoResponse)
                    {
                        m = tm;
                    }
                case SMB2PacketHeaderCommand.SMB2OplockBreak =>
                    // Use the StructureSize to differentiate between an Oplock break message and a lease break message
                    if (structureSize == 24)
                    {
                        // If the MessageId field of the SMB2 header of the response is 0xFFFFFFFFFFFFFFFF, this MUST be processed as an oplock break indication.
                        ulong headerMessageId = PeekUlongLE(messageData, 24);
                        if (headerMessageId == InvalidMessageId)
                        {
                            if (BinaryDecoder<SMB2.Messages.OplockBreakNotification>(messageData) is tm1:SMB2.Messages.OplockBreakNotification)
                            {
                                tm1#FileId = tm1.Notification.FileId.Persistent;
                                m = tm1;
                            }
                        }
                        else
                        {
                            if (BinaryDecoder<SMB2.Messages.OplockBreakResponse>(messageData) is tm2:SMB2.Messages.OplockBreakResponse)
                            {
                                tm2#FileId = tm2.Response.FileId.Persistent;
                                m = tm2;
                            }
                        }
                    }
                    else if (structureSize == 44)
                    {
                        if (BinaryDecoder<SMB2.Messages.LeaseBreakNotification>(messageData) is tm3:SMB2.Messages.LeaseBreakNotification)
                        {
                            m = tm3;
                            if (tm3.Notification.LeaseKey in SMB2GlobalLeaseKeyMapToNames)
                            {
                                var names = SMB2GlobalLeaseKeyMapToNames[tm3.Notification.LeaseKey];
                                m#SMB2FileName = names.FileName;
                                m#SMB2SessionIdName = names.SessionIdName;
                                m#SMB2TreeIdName = names.TreeIdName;
                            }
                        }
                    }
                    else if (BinaryDecoder<SMB2.Messages.LeaseBreakResponse>(messageData) is tm4:SMB2.Messages.LeaseBreakResponse)
                    {
                        m = tm4;
                        if (tm4.Response.LeaseKey in SMB2GlobalLeaseKeyMapToNames)
                        {
                            var names = SMB2GlobalLeaseKeyMapToNames[tm4.Response.LeaseKey];
                            m#SMB2FileName = names.FileName;
                            m#SMB2SessionIdName = names.SessionIdName;
                            m#SMB2TreeIdName = names.TreeIdName;
                        }
                    }

                default =>
                    ThrowDecodingException("SMB2", UTILITY_UNKNOWN_DATA, ["SMB2 response message"]);
            }
        }
        if (m != null)
        {
            ValidationCheck((m.Header.Flags & SMB2PacketHeaderFlags.SMB2FlagsServerToRedir) > 0, m, DiagnosisLevel.Error, "SMB2: The SMB2FlagsServerToRedir bit of the Header.Flags field in response must be set to true.");
            var statusValue = (m.Header.Status as ERREF.NTSTATUS).Value;
            ErrorCodeIf((statusValue & 0xC0000000) == 0xC0000000 && !(statusValue in IgnoredErrorCode), m, DiagnosisLevel.Warning, "SMB2: The Status of the message is " + NtStatusValuesToText(statusValue) + "(" + Utility.DecToHexFormat(statusValue) + "). Please refer to " + NtStatusValuesToText(statusValue) + " in Technical Document MS-ERREF.");
            server.hasAnyMessageDecodeFailed = false;
            // Set annotation to mark if this message is in a compounded message chain
            if (isCompounded)
            {
                m#IsCompounded = true;

                // only need handle compounded related messages
                if ((m.Header.Flags & SMB2.SMB2PacketHeaderFlags.SMB2FlagsRelatedOperations) == 0) // the first compounded message
                {
                    firstResponse = m;
                }
                else if ((m.Header.Flags & SMB2.SMB2PacketHeaderFlags.SMB2FlagsRelatedOperations) != 0) // compounded related messages after the first message
                {
                    if (firstResponse != null)
                    {
                        server.compoundedResponses += [firstResponse];
                        firstResponse = null;
                    }
                    if (server.compoundedResponses.Count > 0) // insert the following compounded related messages only if we have inserted the first response
                        server.compoundedResponses += [m];
                }
            }
            server.pduFull = dc.pduFull;
            // Dispatch the message
            dispatch server issues m;
        }
        else if (BinaryDecoder<SMB2HeaderOnly[false, dc.DialectRevision]>(messageData) is headerOnlyMsg:SMB2HeaderOnly) // try to decode header only message
        {
            headerOnlyMsg#SMB2MessageName = SMB2HeaderOnlyMessageName(headerOnlyMsg);
            DisplayTopLevelMessage(headerOnlyMsg);
        }
        else
        {
            ThrowDecodingException("SMB2");
        }
        offset = nextOffset;
    }
}

// Keep the values during the decoding
type Smb2DecodingContext
{
    // Keep the values from the request message to decode the buffer in response message for QueryInfo
    map<double, byte> queryInfoTypeMap = {};
    map<double, byte> queryInfoClassMap = {};
    // Keep the values from the request message to decode the buffer in response message for IOCTL
    map<double, uint?> hashRetrievalTypeMap = {};
    map<double, uint?> hashVersionMap = {};
    map<double, ulong?> offsetMap = {};
    // Indicates if PduFull bit is set in SMB ETW provider
    bool pduFull = true;
    // Negotiate DialectRevision, some value of SMB2NegotiateResponseDialectRevision
    ushort DialectRevision = 0xFFFF;
    // Negotiate Encryption Capabilities
    ushort CipherId = 0xFFFF;
}

// Defined for look ahead the field values in the Header part
type SMB2Header
{
    ushort StructureSize;
    ushort CreditCharge;
    uint Status;
    ushort Command;
    ushort Credit;
    SMB2PacketHeaderFlags Flags;
    uint NextCommand;
    ulong MessageId;
    ulong AsyncId;
    ulong SessionId;
}

SMB2.Server GetSMB2Server((SMBTransport.Server | NBTSS.Server | binary) transportEndpointOrEtwIndex)
{
    SMB2.Server node;
    switch (transportEndpointOrEtwIndex)
    {
        case lowerNode:SMBTransport.Server =>
            node = endpoint SMB2.Server[SMB2.DefaultSmb2ServerIndex] over lowerNode;
        case lowerNode:NBTSS.Server =>
            node = endpoint SMB2.Server[SMB2.DefaultSmb2ServerIndex] over lowerNode;
        case bin:binary => 
            node = endpoint SMB2.Server[bin];
        default =>
            // No binding of the lower endpoint for other transports
            node = endpoint SMB2.Server[SMB2.DefaultSmb2ServerIndex];
    }
    return node;
}

void DecodeQueryInfoResponseBuffer(SMB2QueryInfoResponse respBody, byte queryInfoType, byte queryInfoClass)
{
    if (respBody.Buffer is data:binary)
    {
        any parsedBuffer = null;
        switch (queryInfoType)
        {
            case SMB2QueryInfoRequestInfoType.SMB20InfoFile =>
                if (BinaryDecoder<SMB20InfoFileBuffer[queryInfoClass]>(data) is infoFile:SMB20InfoFileBuffer)
                {
                    parsedBuffer = infoFile;
                }
            case SMB2QueryInfoRequestInfoType.SMB20InfoFilesystem =>
                if (BinaryDecoder<SMB20InfoFilesystemBuffer[queryInfoClass]>(data) is infoFileSystem:SMB20InfoFilesystemBuffer)
                {
                    parsedBuffer = infoFileSystem;
                }
            case SMB2QueryInfoRequestInfoType.SMB20InfoSecurity =>
                if (BinaryDecoder<SECURITY_DESCRIPTOR_NonRpc>(data) is infoSecurity:SECURITY_DESCRIPTOR_NonRpc)
                {
                    parsedBuffer = infoSecurity;
                }
            case SMB2QueryInfoRequestInfoType.SMB20InfoQuota =>
                if (BinaryDecoder<FileQuotaInformationList>(data) is infoQuota:FileQuotaInformationList)
                {
                    parsedBuffer = infoQuota;
                }
            default =>;
        }
        if (parsedBuffer != null)
        {
            respBody.Buffer = parsedBuffer;
        }
        else
        {
            ThrowDecodingException("SMB2", "QueryInfoResponse");
        }
    }
}

void DecodeQueryDirectoryResponseBuffer(SMB2QueryDirectoryResponse respBody, SMB2QueryDirectoryRequestFileInformationClass queryInfoClass)
{
    if (respBody.Buffer is bin:binary)
    {
        if (BinaryDecoder<SMB20InfoFileBuffer[queryInfoClass]>(bin) is r:SMB20InfoFileBuffer)
        {
            respBody.Buffer = r;
        }
        else
        {
            ThrowDecodingException("SMB2", "QueryDirectoryResponse");
        }
    }
}

void DecodeIoctlResponseBuffer(SMB2IoctlResponse respBody, uint? hashRetrievalType, uint? hashVersion, ulong? offsetInRequest, ushort dialectRevision)
{
    if (respBody.CtlCode == SMB2IoctlCtlCode.FSCTL_SRV_READ_HASH && respBody.Buffer is bin:binary)
    {
        switch (hashRetrievalType)
        {
            case SrvReadHashHashRetrievalType.SrvReadRetrieveHashBased =>
                if (BinaryDecoder<ResponseForSrvHashRetrieveHashBased[hashVersion, dialectRevision]>(bin) is hash:ResponseForSrvHashRetrieveHashBased)
                {
                    respBody.Buffer = hash;
                }
            case SrvReadHashHashRetrievalType.SrvReadRetrieveFileBased =>
                if (BinaryDecoder<ResponseForSrvHashRetrieveFileBased[hashVersion, offsetInRequest, dialectRevision]>(bin) is file:ResponseForSrvHashRetrieveFileBased)
                {
                    respBody.Buffer = file;
                }
            default =>;
        }
    }
}

const array<byte> SMB2Acknowledgment_BYTEARRAY = [0x18, 0x00];

// messages
abstract message SMB2Request
{
    SMB2PacketHeader Header where ValidationCheck((value.Flags & SMB2PacketHeaderFlags.SMB2FlagsServerToRedir) == 0, this, DiagnosisLevel.Error, "SMB2: The SMB2FlagsServerToRedir bit of the Header.Flags field in request must be set to false")
            with Encoding{Decoder = HeaderDecoder};

    abstract optional SMB2PacketHeader HeaderDecoder(stream s); // Inheriting request messages need to override this method.
    
    override string ToString()
    {
        return Header.GetStatus();
    }
}

const array<byte> SMB2ErrorResponse_BYTEARRAY = [0x31, 0x00];
const array<byte> SMB2OplockBreakResponse_BYTEARRAY = [0x18, 0x00];
const array<byte> SMB2LeaseBreakNotification_BYTEARRAY = [0x2C, 0x00];

message SMB2Response
{
    SMB2PacketHeader[SMB2_RESPONSE] Header;

    override string ToString()
    {
        return Header.GetStatus();
    }
}

contract Messages
{
    // Protocol Negotiation
    accepts NegotiateRequest[ushort Dialect]:SMB2Request
    {
        SMB2NegotiateRequest Request;
        invariant Header != null && Request != null;

        override optional SMB2PacketHeader HeaderDecoder(stream s)
        {
            return BinaryDecoder<SMB2PacketHeader[SMB2_REQUEST, Dialect]>(s);
        }

        override string ToString()
        {
            string summary = "NegotiateRequest" + (this#IsCompounded is cmp:bool && cmp ? ", Compounded" : "") + ", Dialects: ";
            bool needComma = false;
            if (Request.Dialects.Count > 1)
            {
                summary += "[";
            }
            foreach (var e in Request.Dialects)
            {           
                if (needComma)
                {
                    summary += ", ";
                }
                else
                {
                    needComma = true;
                }
                summary += SMB2.DialectRevisionToText(e);
            }
            if (Request.Dialects.Count > 1)
            {
                summary += "]";
            }
            summary += ", Capabilities: " + EnumToString(Request.Capabilities, "SMB2.SMB2NegotiateRequestCapabilities") + ", ClientGuid: {" + (Request.ClientGuid as string) + "}";
            return summary;
        }
    }

    issues NegotiateResponse:SMB2Response
    {
        SMB2NegotiateResponse Response;
        invariant Header != null && Response != null;

        override string ToString()
        {
            return "NegotiateResponse, " + (this#IsCompounded is cmp:bool && cmp ? "Compounded, " : "") + Header.GetStatus() + ", " + Response.ToString();
        }
    }
    
    // User Authentication
    accepts SessionSetupRequest[ushort Dialect]:SMB2Request
    {
        SMB2SessionSetupRequest Request;
        invariant Header != null && Request != null;

        override optional SMB2PacketHeader HeaderDecoder(stream s)
        {
            return BinaryDecoder<SMB2PacketHeader[SMB2_REQUEST, Dialect]>(s);
        }
        override string ToString()
        {
            return "SessionSetupRequest" + (this#IsCompounded is cmp:bool && cmp ? ", Compounded" : "") +
                (this#KeyInformation != nothing ? ", " + this#KeyInformation.ToString() : "") +
                ", " + Request.ToString();
        }
    }

    issues SessionSetupResponse:SMB2Response
    {
        SMB2SessionSetupResponse Response;
        invariant Header != null && Response != null;

        override string ToString()
        {
            return "SessionSetupResponse, " + (this#IsCompounded is cmp:bool && cmp ? "Compounded, " : "") + Header.GetStatus() +
                (this#KeyInformation != nothing ? ", " + this#KeyInformation.ToString() : "") +
                (Response.ToString().Count == 0 ? "" : (", " + Response.ToString())) + ", SessionId: " +
                DecToHexFormat(Header.SessionId);
        }
    }

    accepts LogoffRequest[ushort Dialect]:SMB2Request
    {
        SMB2LogoffRequest Request;
        invariant Header != null && Request != null;

        override optional SMB2PacketHeader HeaderDecoder(stream s)
        {
            return BinaryDecoder<SMB2PacketHeader[SMB2_REQUEST, Dialect]>(s);
        }
        override string ToString()
        {    
            return "LogoffRequest" + (this#IsCompounded is cmp:bool && cmp ? ", Compounded" : "") + ", SessionId: " + DecToHexFormat(Header.SessionId);
        }
    }

    issues LogoffResponse:SMB2Response
    {
        SMB2LogoffResponse Response;
        invariant Header != null && Response != null;

        override string ToString()
        {
            return "LogoffResponse, " + (this#IsCompounded is cmp:bool && cmp ? "Compounded, " : "") + Header.GetStatus();
        }
    }

    // Share Access
    accepts TreeConnectRequest[ushort Dialect]:SMB2Request
    {
        SMB2TreeConnectRequest[Dialect] Request;
        invariant Header != null && Request != null;

        override optional SMB2PacketHeader HeaderDecoder(stream s)
        {
            return BinaryDecoder<SMB2PacketHeader[SMB2_REQUEST, Dialect]>(s);
        }
        override string ToString()
        {
            
            return "TreeConnectRequest" + (this#IsCompounded is cmp:bool && cmp ? ", Compounded" : "") + 
                ", Path: " + Request.GetPathName();
        }
    }

    issues TreeConnectResponse:SMB2Response
    {
        SMB2TreeConnectResponse Response;
        invariant Header != null && Response != null;

        override string ToString()
        {
            return "TreeConnectResponse, " + (this#IsCompounded is cmp:bool && cmp ? "Compounded, " : "") + Header.GetStatus() + ", ShareFlags: " + Response.ShareFlags.ToString() + ", TreeId: " + DecToHexFormat(GetTreeId(Header)) + ", Capabilities: " + EnumToString(Response.Capabilities, "SMB2.SMB2TreeConnectResponseCapabilities");
        }
    }

    accepts TreeDisconnectRequest[ushort Dialect]:SMB2Request
    {
        SMB2TreeDisconnectRequest Request;
        invariant Header != null && Request != null;

        override optional SMB2PacketHeader HeaderDecoder(stream s)
        {
            return BinaryDecoder<SMB2PacketHeader[SMB2_REQUEST, Dialect]>(s);
        }
        override string ToString()
        {    
            return "TreeDisconnectRequest" + (this#IsCompounded is cmp:bool && cmp ? ", Compounded" : "") + ", TreeId: " + DecToHexFormat(GetTreeId(Header));
        }
    }

    issues TreeDisconnectResponse:SMB2Response
    {
        SMB2TreeDisconnectResponse Response;
        invariant Header != null && Response != null;

        override string ToString()
        {
            return "TreeDisconnectResponse, " + (this#IsCompounded is cmp:bool && cmp ? "Compounded, " : "") + Header.GetStatus() + ", TreeId: " + DecToHexFormat(GetTreeId(Header));
        }
    }

    // File Access
    accepts CreateRequest[ushort Dialect, bool IsDirectory]:SMB2Request
    {
        SMB2CreateRequest[IsDirectory] Request;
        invariant Header != null && Request != null;
        
        override optional SMB2PacketHeader HeaderDecoder(stream s)
        {
            return BinaryDecoder<SMB2PacketHeader[SMB2_REQUEST, Dialect]>(s);
        }
        override string ToString()
        {    
            string summary = "CreateRequest" + (this#IsCompounded is cmp:bool && cmp ? ", Compounded" : "") + GetFileNameOrFID(this) + ", RequestedOplockLevel: " + EnumToString(Request.RequestedOplockLevel, "SMB2.SMB2CreateRequestRequestedOplockLevel");
            if (Request.Buffer.CreateContextList != nothing)
            {
                var buffer = Request.Buffer.CreateContextList as array<SMB2CreateContextRequest>;
                int count = buffer.Count;
                string comma = "";
                summary += ", CreateContext: ";
                if (count > 1)
                {
                    summary += "[";
                }
                for (int i = 0; i < count; i++)
                {
                    summary += comma + buffer[i].Buffer.ToString();
                    comma = ", ";
                }
                if (count > 1)
                {
                    summary += "]";
                }
            }
            return summary;
        }
    }

    issues CreateResponse:SMB2Response
    {
        SMB2CreateResponse Response;
        invariant Header != null && Response != null;

        override string ToString()
        {
            string summary = "CreateResponse, " + (this#IsCompounded is cmp:bool && cmp ? "Compounded, " : "") + Header.GetStatus() + GetFileNameOrFID(this) + ", OplockLevel: " + EnumToString(Response.OplockLevel, "SMB2.SMB2CreateResponseOplockLevel");
            if (Response.Buffer != nothing)
            {
                var buffer = Response.Buffer as array<SMB2CreateContextResponse>;
                int count = buffer.Count;
                string comma = "";
                summary += ", CreateContext: ";
                if (count > 1)
                {
                    summary += "[";
                }
                for (int i = 0; i < count; i++)
                {
                    summary += comma + buffer[i].Buffer.ToString();
                    comma = ", ";
                }
                if (count > 1)
                {
                    summary += "]";
                }
            }
            return summary;
        }
    }

    accepts CloseRequest[ushort Dialect]:SMB2Request
    {
        SMB2CloseRequest Request;
        invariant Header != null && Request != null;

        override optional SMB2PacketHeader HeaderDecoder(stream s)
        {
            return BinaryDecoder<SMB2PacketHeader[SMB2_REQUEST, Dialect]>(s);
        }
        override string ToString()
        {
            return "CloseRequest" + (this#IsCompounded is cmp:bool && cmp ? ", Compounded" : "") + GetFileNameOrFID(this);
        }
    }

    issues CloseResponse:SMB2Response
    {
        SMB2CloseResponse Response;
        invariant Header != null && Response != null;

        override string ToString()
        {
            return "CloseResponse, " + (this#IsCompounded is cmp:bool && cmp ? "Compounded, " : "") + Header.GetStatus() + GetFileNameOrFID(this);
        }
    }

    accepts ReadRequest[ushort Dialect]:SMB2Request
    {
        SMB2ReadRequest[Dialect] Request;
        invariant Header != null && Request != null;
        
        override optional SMB2PacketHeader HeaderDecoder(stream s)
        {
            return BinaryDecoder<SMB2PacketHeader[SMB2_REQUEST, Dialect]>(s);
        }
        override string ToString()
        {    
            string summary = "ReadRequest" + (this#IsCompounded is cmp:bool && cmp ? ", Compounded" : "") + GetFileNameOrFID(this);
            summary += ", TreeId: " + DecToHexFormat(GetTreeId(Header)) + ", Length: " + (Request.Length as string) + ", Offset: " + (Request.Offset as string);
            if ((Request.Channel & SMB2ReadRequestChannel.SMB2_CHANNEL_RDMA_V1) > 0)
            {
                summary += ", Channel: RdmaV1";
            }
            return summary;
        }
    }

    issues ReadResponse:SMB2Response
    {
        SMB2ReadResponse Response;
        invariant Header != null && Response != null;

        override string ToString()
        {
            string summary = "ReadResponse";
            if (this#IsReassembled != nothing)
            {
                summary += ", Reassembled";
            }
            summary += ", " + (this#IsCompounded is cmp:bool && cmp ? "Compounded, " : "") + Header.GetStatus() + GetFileNameOrFID(this) + ", TreeId: " + DecToHexFormat(GetTreeId(Header)) + ", DataLength: " + (Response.DataLength as string);
            return summary;
        }
    }
    
    accepts WriteRequest[ushort Dialect]:SMB2Request
    {
        SMB2WriteRequest Request;
        invariant Header != null && Request != null;
        
        override optional SMB2PacketHeader HeaderDecoder(stream s)
        {
            return BinaryDecoder<SMB2PacketHeader[SMB2_REQUEST, Dialect]>(s);
        }
        override string ToString()
        {    
            string summary = "WriteRequest" + (this#IsCompounded is cmp:bool && cmp ? ", Compounded" : "") + GetFileNameOrFID(this);
            summary += ", Length: " + (Request.Length as string) + ", Offset: " + (Request.Offset as string);
            if ((Request.Channel & SMB2WriteRequestChannel.SMB2_CHANNEL_RDMA_V1) > 0)
            {
                summary += ", Channel: RdmaV1";
            }
            return summary;
        }
    }

    issues WriteResponse:SMB2Response
    {
        SMB2WriteResponse Response;
        invariant Header != null && Response != null;
        
        override string ToString()
        {
            return "WriteResponse, " + (this#IsCompounded is cmp:bool && cmp ? "Compounded, " : "") + Header.GetStatus() + GetFileNameOrFID(this) + ", Count: " + (Response.Count as string);
        }
    }

    accepts LockRequest[ushort Dialect]:SMB2Request
    {
        SMB2LockRequest Request;
        invariant Header != null && Request != null;
        
        override optional SMB2PacketHeader HeaderDecoder(stream s)
        {
            return BinaryDecoder<SMB2PacketHeader[SMB2_REQUEST, Dialect]>(s);
        }
        override string ToString()
        {
            return "LockRequest, " + (this#IsCompounded is cmp:bool && cmp ? ", Compounded" : "") + GetFileNameOrFID(this);
        }
    }

    issues LockResponse:SMB2Response
    {
        SMB2LockResponse Response;
        invariant Header != null && Response != null;
        
        override string ToString()
        {
            return "LockResponse, " + (this#IsCompounded is cmp:bool && cmp ? "Compounded, " : "") + Header.GetStatus() + GetFileNameOrFID(this);
        }
    }

    accepts IoctlRequest[ushort Dialect]:SMB2Request
    {
        SMB2IoctlRequest Request;
        invariant Header != null && Request != null;
        
        override optional SMB2PacketHeader HeaderDecoder(stream s)
        {
            return BinaryDecoder<SMB2PacketHeader[SMB2_REQUEST, Dialect]>(s);
        }
        override string ToString()
        {
            return "IoctlRequest" + (this#IsCompounded is cmp:bool && cmp ? ", Compounded" : "") + GetFileNameOrFID(this) + ", CtlCode: " + SMB2.CtlCodeToText(Request.CtlCode);
        }
    }

    issues IoctlResponse:SMB2Response
    {
        SMB2IoctlResponse Response;
        invariant Header != null && Response != null;
        
        override string ToString()
        {
            string summary = "IoctlResponse";
            if (this#IsReassembled != nothing)
            {
                summary += ", Reassembled";
            }
            summary += ", " + (this#IsCompounded is cmp:bool && cmp ? "Compounded, " : "") + Header.GetStatus() + GetFileNameOrFID(this) + ", CtlCode: " + SMB2.CtlCodeToText(Response.CtlCode);
            return summary;
        }
    }

    accepts QueryInfoRequest[ushort Dialect]:SMB2Request
    {
        SMB2QueryInfoRequest Request;
        invariant Header != null && Request != null;
        
        override optional SMB2PacketHeader HeaderDecoder(stream s)
        {
            return BinaryDecoder<SMB2PacketHeader[SMB2_REQUEST, Dialect]>(s);
        }
        override string ToString()
        {
            string summary = "QueryInfoRequest" + (this#IsCompounded is cmp:bool && cmp ? ", Compounded" : "") + GetFileNameOrFID(this);
            summary += ", InfoType: " + InfoTypeToText(Request.InfoType) + ", FileInfoClass: " + FileInfoClassToText(Request.InfoType, Request.FileInfoClass);
            return summary;
        }
    }

    issues QueryInfoResponse[optional byte QueryInfoType, optional byte QueryInfoClass]:SMB2Response
    {
        SMB2QueryInfoResponse[QueryInfoType, QueryInfoClass] Response;
        invariant Header != null && Response != null;
        
        override string ToString()
        {
            return "QueryInfoResponse, " + (this#IsCompounded is cmp:bool && cmp ? "Compounded, " : "") + Header.GetStatus() + GetFileNameOrFID(this);
        }
    }

    accepts SetInfoRequest[ushort Dialect]:SMB2Request
    {
        SMB2SetInfoRequest Request;
        invariant Header != null && Request != null;
        
        override optional SMB2PacketHeader HeaderDecoder(stream s)
        {
            return BinaryDecoder<SMB2PacketHeader[SMB2_REQUEST, Dialect]>(s);
        }
        override string ToString()
        {
            string summary = "SetInfoRequest" + (this#IsCompounded is cmp:bool && cmp ? ", Compounded" : "") + GetFileNameOrFID(this);
            summary += ", InfoType: " + InfoTypeToText(Request.InfoType) + ", FileInfoClass: " + FileInfoClassToText(Request.InfoType, Request.FileInfoClass);
            return summary;
        }
    }

    issues SetInfoResponse:SMB2Response
    {
        SMB2SetInfoResponse Response;
        invariant Header != null && Response != null;
        
        override string ToString()
        {
            return "SetInfoResponse, " + (this#IsCompounded is cmp:bool && cmp ? "Compounded, " : "") + Header.GetStatus() + GetFileNameOrFID(this);
        }
    }

    accepts FlushRequest[ushort Dialect]:SMB2Request
    {
        SMB2FlushRequest Request;
        invariant Header != null && Request != null;
        
        override optional SMB2PacketHeader HeaderDecoder(stream s)
        {
            return BinaryDecoder<SMB2PacketHeader[SMB2_REQUEST, Dialect]>(s);
        }
        override string ToString()
        {
            return "FlushRequest" + (this#IsCompounded is cmp:bool && cmp ? ", Compounded" : "") + GetFileNameOrFID(this);
        }
    }

    issues FlushResponse:SMB2Response
    {
        SMB2FlushResponse Response;
        invariant Header != null && Response != null;
        
        override string ToString()
        {
            return "FlushResponse, " + (this#IsCompounded is cmp:bool && cmp ? "Compounded, " : "") + Header.GetStatus() + GetFileNameOrFID(this);
        }
    }

    accepts CancelRequest[ushort Dialect]:SMB2Request
    {
        SMB2CancelRequest Request;
        invariant Header != null && Request != null;
        
        override optional SMB2PacketHeader HeaderDecoder(stream s)
        {
            return BinaryDecoder<SMB2PacketHeader[SMB2_REQUEST, Dialect]>(s);
        }
        override string ToString()
        {
            return "CancelRequest" + (this#IsCompounded is cmp:bool && cmp ? ", Compounded" : "");
        }
    }

    // Directory Access
    accepts QueryDirectoryRequest[ushort Dialect]:SMB2Request
    {
        SMB2QueryDirectoryRequest Request;
        invariant Header != null && Request != null;
        
        override optional SMB2PacketHeader HeaderDecoder(stream s)
        {
            return BinaryDecoder<SMB2PacketHeader[SMB2_REQUEST, Dialect]>(s);
        }
        override string ToString()
        {
            string summary = "QueryDirectoryRequest" + (this#IsCompounded is cmp:bool && cmp ? ", Compounded" : "");
            summary += ", Flags: " + EnumToString(Request.Flags, "SMB2.SMB2QueryDirectoryRequestFlags") + GetFileNameOrFID(this) + ", SearchPattern: " + Request.Buffer;
            summary += ", FileInformationClass: " + EnumToString(Request.FileInformationClass, "SMB2.SMB2QueryDirectoryRequestFileInformationClass");
            return summary;
        }
    }

    issues QueryDirectoryResponse[optional byte QueryInfoClass]:SMB2Response
    {
        SMB2QueryDirectoryResponse[QueryInfoClass] Response;
        invariant Header != null && Response != null;
        
        override string ToString()
        {
            return "QueryDirectoryResponse, " + (this#IsCompounded is cmp:bool && cmp ? "Compounded, " : "") + Header.GetStatus() + GetFileNameOrFID(this);
        }
    }

    accepts ChangeNotifyRequest[ushort Dialect]:SMB2Request
    {
        SMB2ChangeNotifyRequest Request;
        invariant Header != null && Request != null;
        
        override optional SMB2PacketHeader HeaderDecoder(stream s)
        {
            return BinaryDecoder<SMB2PacketHeader[SMB2_REQUEST, Dialect]>(s);
        }
        override string ToString()
        {
            string summary = "ChangeNotifyRequest" + (this#IsCompounded is cmp:bool && cmp ? ", Compounded" : "") + GetFileNameOrFID(this);
            summary += ", CompletionFilter: " + EnumToString(Request.CompletionFilter, "SMB2.SMB2ChangeNotifyRequestCompletionFilter");
            return summary;
        }
    }

    issues ChangeNotifyResponse:SMB2Response
    {
        SMB2ChangeNotifyResponse Response;
        invariant Header != null && Response != null;
        
        override string ToString()
        {
            return "ChangeNotifyResponse, " + (this#IsCompounded is cmp:bool && cmp ? "Compounded, " : "") + Header.GetStatus() + GetFileNameOrFID(this);
        }
    }

    // Cache Coherency
    issues OplockBreakNotification:SMB2Response
    {
        SMB2OplockBreakNotification Notification;
        invariant Header != null && Notification != null;
        
        override string ToString()
        {
            return "OplockBreakNotification, " + (this#IsCompounded is cmp:bool && cmp ? "Compounded, " : "") + Header.GetStatus() + ", FileName: " + this.FileName + ", OplockLevel: " + EnumToString(Notification.OplockLevel, "SMB2.SMB2OplockBreakNotificationOplockLevel");
        }
    }

    accepts OplockBreakAcknowledgment[ushort Dialect]:SMB2Request
    {
        SMB2OplockBreakAcknowledgment Acknowledgment where value.StructureSize == 24;
        invariant Header != null && Acknowledgment != null;
        
        override optional SMB2PacketHeader HeaderDecoder(stream s)
        {
            return BinaryDecoder<SMB2PacketHeader[SMB2_REQUEST, Dialect]>(s);
        }
        override string ToString()
        {
            return "OplockBreakAcknowledgment" + (this#IsCompounded is cmp:bool && cmp ? ", Compounded" : "") + ", FileName: " + this.FileName + ", OplockLevel: " + EnumToString(Acknowledgment.OplockLevel, "SMB2.SMB2OplockBreakAcknowledgmentOplockLevel");
        }
    }
    
    issues OplockBreakResponse:SMB2Response
    {
        SMB2OplockBreakResponse Response;
        invariant Header != null && Response != null;
        
        override string ToString()
        {    
            return "OplockBreakResponse, " + (this#IsCompounded is cmp:bool && cmp ? "Compounded, " : "") + Header.GetStatus() + ", FileName: " + this.FileName + ", OplockLevel: " + EnumToString(Response.OplockLevel, "SMB2.SMB2OplockBreakResponseOplockLevel");
        }
    }
    
    issues LeaseBreakNotification:SMB2Response
    {
        SMB2LeaseBreakNotification Notification;
        invariant Header != null && Notification != null;
        
        override string ToString()
        {
            string summary = "LeaseBreakNotification, " + (this#IsCompounded is cmp:bool && cmp ? "Compounded, " : "") + Header.GetStatus() + ", CurrentLeaseState: " + SMB2LeaseBreakNotificationCurrentLeaseStateToText(Notification.CurrentLeaseState);
            summary += ", NewLeaseState: " + SMB2LeaseBreakNotificationNewLeaseStateToText(Notification.NewLeaseState);
            return summary;
        }
    }

    accepts LeaseBreakAcknowledgment[ushort Dialect]:SMB2Request
    {
        SMB2LeaseBreakAcknowledgment Acknowledgment where value.StructureSize == 36;
        invariant Header != null && Acknowledgment != null;
        
        override optional SMB2PacketHeader HeaderDecoder(stream s)
        {
            return BinaryDecoder<SMB2PacketHeader[SMB2_REQUEST, Dialect]>(s);
        }
        override string ToString()
        {
            return "LeaseBreakAcknowledgment" + (this#IsCompounded is cmp:bool && cmp ? ", Compounded" : "") + ", LeaseState: " + SMB2LeaseBreakAcknowledgmentLeaseStateToText(Acknowledgment.LeaseState) + ", LeaseKey: {" + (Acknowledgment.LeaseKey as string) + "}";
        }
    }
    
    issues LeaseBreakResponse:SMB2Response
    {
        SMB2LeaseBreakResponse Response;
        invariant Header != null && Response != null;
        
        override string ToString()
        {
            return "LeaseBreakResponse, " + (this#IsCompounded is cmp:bool && cmp ? "Compounded, " : "") + Header.GetStatus() + ", LeaseState: " + SMB2LeaseBreakResponseLeaseStateToText(Response.LeaseState);
        }
    }
    
    // Simple Messaging
    accepts EchoRequest[ushort Dialect]:SMB2Request
    {
        SMB2EchoRequest Request;
        invariant Header != null && Request != null;
        
        override optional SMB2PacketHeader HeaderDecoder(stream s)
        {
            return BinaryDecoder<SMB2PacketHeader[SMB2_REQUEST, Dialect]>(s);
        }
        override string ToString()
        {
            return "EchoRequest" + (this#IsCompounded is cmp:bool && cmp ? ", Compounded" : "");
        }
    }

    issues EchoResponse:SMB2Response
    {
        SMB2EchoResponse Response;
        invariant Header != null && Response != null;
        
        override string ToString()
        {
            return "EchoResponse, " + (this#IsCompounded is cmp:bool && cmp ? "Compounded, " : "") + Header.GetStatus();
        }
    }
    
    // ERROR Response Packet
    issues ErrorResponse[uint Status, ushort Dialect]:SMB2Response
    {
        SMB2ErrorResponse[Status, Dialect] Response;
        invariant Header != null && Response != null;
        
        override string ToString()
        {
            return "ErrorResponse, " + (this#IsCompounded is cmp:bool && cmp ? "Compounded, " : "") + Header.GetStatus();
        }
    }
}

contract VirtualOperations
{
    // Future Reference: enable virtual operation accept multi-message types, normal response and error response.
    issues virtual operation ComNegotiate
    {
        out SMB2NegotiateResponseDialectRevision DialectRevision = dialectRevision;
        out ERREF.NTSTATUS Status = status as ERREF.NTSTATUS;
        
        override string ToString()
        {
            string compoundedStr = "";
            if (this.Origins[1] is resp:SMB2.SMB2Response && resp#IsCompounded is cmp:bool && cmp)
            {
                compoundedStr = "Compounded, ";
            }
            return "ComNegotiate, " + compoundedStr + "Status: " + NTStatusLEToString(Status) + ", DialectRevision: " + SMB2.DialectRevisionToText(DialectRevision);
        }
    } = ComNegotiateScenario[out var dialectRevision, out var status];
    
    // Future Reference: enable virtual operation accept multi-message types, normal response and error response.
    issues virtual operation Negotiate
    {
        in GUID ClientGuid = clientGuid;
        out optional SMB2NegotiateResponseDialectRevision DialectRevision = dialectRevision;
        out ERREF.NTSTATUS Status = status as ERREF.NTSTATUS;
        
        override string ToString()
        {
            return "Negotiate, " + GetCompoundedString(this.Origins[0]) + "Status: " + NTStatusLEToString(Status) + ", ClientGuid: {" + (ClientGuid as string) + "}" + 
                (DialectRevision is dia:SMB2NegotiateResponseDialectRevision ? ", DialectRevision: " + SMB2.DialectRevisionToText(dia) : "");
        }
    } = NegotiateScenario[out var clientGuid, out var dialectRevision, out var status];
    
    issues virtual operation SessionSetup
    {
        in SMB2SessionSetupRequestFlags Flags = requestFlags;
        in string AuthenticationMethod = ki != nothing ? GetAuthInfoFromSummary(ki.ToString()) : "";
        in optional string User = ki != nothing && GetUserInfoFromSummary(ki.ToString()).Count > 0 ? GetUserInfoFromSummary(ki.ToString()) : nothing;
        out optional SMB2SessionSetupResponseSessionFlags SessionFlags = sessionFlags;
        out ERREF.NTSTATUS Status = status as ERREF.NTSTATUS;

        override string ToString()
        {
            string compoundedStr = "";
            return "SessionSetup, " + GetCompoundedString(this.Origins[0]) + "Status: " + NTStatusLEToString(Status) + 
                (AuthenticationMethod.Count == 0 ? "" : (", " + AuthenticationMethod)) + (User == nothing ? "" : (", User: " + User.ToString())) +
                ", Flags: " + EnumToString(Flags, "SMB2.SMB2SessionSetupRequestFlags") + 
                ((SessionFlags is sf:SMB2SessionSetupResponseSessionFlags && (sf & SMB2SessionSetupResponseSessionFlags.SMB2SessionFlagEncryptData) > 0) ? ", SessionFlags: ENCRYPT_DATA" : "");
        }
    } = SessionSetupScenario[out var requestFlags, out var sessionFlags, out var ki, out var status];
    
    issues virtual operation Logoff
    {
        out UINT64 SessionId = sessionId;
        out ERREF.NTSTATUS Status = status as ERREF.NTSTATUS;
        
        override string ToString()
        {
            return "Logoff, " + GetCompoundedString(this.Origins[0]) + "Status: " + NTStatusLEToString(Status) + ", SessionId: " + DecToHexFormat(SessionId);
        }
    } = LogoffScenario[out var sessionId, out var status];
    
    issues virtual operation TreeConnect
    {
        in string Path = buffer;
        out optional ULONG TreeId = treeId;
        out optional SMB2TreeConnectResponseCapabilities Capabilities = capabilities;
        out ERREF.NTSTATUS Status = status as ERREF.NTSTATUS;
        
        override string ToString()
        {
            string summary = "TreeConnect";
            if (Status != nothing)
            {
                summary += ", " + GetCompoundedString(this.Origins[0]) + "Status: " + NTStatusLEToString(Status);
            }
            summary += ", Path: " + (Path as string) + (TreeId is tid:ULONG ? ", TreeID: " + DecToHexFormat(tid) : "") +
                (Capabilities is cap:SMB2TreeConnectResponseCapabilities ? ", Capabilities: " + EnumToString(cap, "SMB2.SMB2TreeConnectResponseCapabilities") : "");
            return summary;
        }
    } = TreeConnectScenario[out var buffer, out var treeId, out var capabilities, out var status];

    issues virtual operation TreeDisconnect
    {
        in ULONG TreeId = treeId as ULONG;
        out ERREF.NTSTATUS Status = status as ERREF.NTSTATUS;
        
        override string ToString()
        {
            string summary = "TreeDisconnect";
            if (Status != nothing)
            {
                summary += ", " + GetCompoundedString(this.Origins[0]) + "Status: " + NTStatusLEToString(Status);
            }
            summary += ", TreeId: " + DecToHexFormat(TreeId);
            return summary;
        }
    } = TreeDisconnectScenario[out var treeId, out var status];

    issues virtual operation Create
    {
        in string Name = buffer.Name is nm:StringNotNullOrEmpty ? nm : "*NULL*";
        in UINT64 MessageId = messageId;
        out optional SMB2Fileid FileId = fileId;
        out ERREF.NTSTATUS Status = status as ERREF.NTSTATUS;
        
        override string ToString()
        {
            return "Create, " + GetCompoundedString(this.Origins[0]) + "Status: " + NTStatusLEToString(Status) + ", FileName: " + Name;
        }
    } = CreateScenario[out var buffer, out var messageId, out var fileId, out var status];
   
    issues virtual operation Close
    {
        in SMB2Fileid FileId = fileId;
        out ERREF.NTSTATUS Status = status as ERREF.NTSTATUS;
        
        override string ToString()
        {
            return "Close, " + GetCompoundedString(this.Origins[0]) + "Status: " + NTStatusLEToString(Status) + ", FileId: " + DecToHexFormat(FileId.Persistent);
        }
    } = CloseScenario[out var fileId, out var status];
    
    issues virtual operation Read
    {
        in SMB2Fileid FileId = request.FileId;
        in ULONG Length = request.Length;
        in SMB2ReadRequestChannel Channel = request.Channel;
        in UINT64 Offset = request.Offset;
        in UINT64 MessageId = messageId;
        out optional binary Buffer = readBuffer;
        out ERREF.NTSTATUS Status = status as ERREF.NTSTATUS;
        
        override string ToString()
        {
            string summary = "Read, " + GetCompoundedString(this.Origins[0]) + "Status: " + NTStatusLEToString(Status) + GetFileNameOrFID(this.Origins[0] as SMB2Request) +
                ", Read " + (Length as string) + " bytes from offset " + (Offset as string);
            if ((Channel & SMB2ReadRequestChannel.SMB2_CHANNEL_RDMA_V1) > 0)
            {
                summary += ", Channel: RdmaV1";
            }
            return summary;
        }
    } = ReadScenario[out var request, out var messageId, out var readBuffer, out var status];
    
    issues virtual operation Write
    {
        in SMB2Fileid FileId = request.FileId;
        in SMB2WriteRequestChannel Channel = request.Channel;
        in ULONG Length = request.Length;
        in UINT64 Offset = request.Offset;
        in UINT64 MessageId = messageId;
        in binary Buffer = request.Buffer;
        out ERREF.NTSTATUS Status = status as ERREF.NTSTATUS;
        
        override string ToString()
        {
            string summary = "Write, " + GetCompoundedString(this.Origins[0]) + "Status: " + NTStatusLEToString(Status) + ", FileId: " + DecToHexFormat(FileId.Persistent) + ", Write " + (Length as string) + " bytes from offset " + (Offset as string);
            if ((Channel & SMB2WriteRequestChannel.SMB2_CHANNEL_RDMA_V1) > 0)
            {
                summary += ", Channel: RdmaV1";
            }
            return summary;
        }
    } = WriteScenario[out var request, out var messageId, out var status];

    issues virtual operation Lock
    {
        in SMB2Fileid FileId = fileId;
        in UINT64 MessageId = messageId;
        out ERREF.NTSTATUS Status = status as ERREF.NTSTATUS;
        
        override string ToString()
        {
            return "Lock, " + GetCompoundedString(this.Origins[0]) + "Status: " + NTStatusLEToString(Status) + ", FileId: " + DecToHexFormat(FileId.Persistent);
        }
    } = LockScenario[out var fileId, out var messageId, out var status];

    issues virtual operation Ioctl
    {
        in SMB2Fileid FileId = fileId;
        in ULONG CtlCode = ctlCode;
        in UINT64 MessageId = messageId;
        out ERREF.NTSTATUS Status = status as ERREF.NTSTATUS;
        
        override string ToString()
        {
            return "Ioctl, " + GetCompoundedString(this.Origins[0]) + "Status: " + NTStatusLEToString(Status) + ", FileId: " + DecToHexFormat(FileId.Persistent) + ", CtlCode: " + SMB2.CtlCodeToText(CtlCode);
        }
    } = IoctlScenario[out var fileId, out var ctlCode, out var messageId, out var status];
    
    issues virtual operation QueryInfo
    {
        in SMB2Fileid FileId = request.FileId;
        in BYTE InfoType = request.InfoType;
        in BYTE FileInfoClass = request.FileInfoClass;
        out ERREF.NTSTATUS Status = status as ERREF.NTSTATUS;
        
        override string ToString()
        {
            return "QueryInfo, " + GetCompoundedString(this.Origins[0]) + "Status: " + NTStatusLEToString(Status) + ", FileId: " + DecToHexFormat(FileId.Persistent) + ", FileInfoClass: " + FileInfoClassToText(InfoType, FileInfoClass);
        }
    } = QueryInfoScenario[out var request, out var status];
    
    issues virtual operation SetInfo
    {
        in SMB2Fileid FileId = request.FileId;
        in BYTE InfoType = request.InfoType;
        in BYTE FileInfoClass = request.FileInfoClass;
        out ERREF.NTSTATUS Status = status as ERREF.NTSTATUS;
        
        override string ToString()
        {
            return "SetInfo, " + GetCompoundedString(this.Origins[0]) + "Status: " + NTStatusLEToString(Status) + ", FileId: " + DecToHexFormat(FileId.Persistent) +
                ", FileInfoClass: " + FileInfoClassToText(InfoType, FileInfoClass);
        }
    } = SetInfoScenario[out var request, out var status];
    
    issues virtual operation Flush
    {
        in SMB2Fileid FileId = request.FileId;
        out ERREF.NTSTATUS Status = status as ERREF.NTSTATUS;
        
        override string ToString()
        {
            return "Flush, " + GetCompoundedString(this.Origins[0]) + "Status: " + NTStatusLEToString(Status) + ", FileId: " + DecToHexFormat(FileId.Persistent);
        }
    } = FlushScenario[out var request, out var status];

    issues virtual operation CancelSuccess
    {
        out ERREF.NTSTATUS Status = status as ERREF.NTSTATUS; // 0xC0000120 is NtStatus."STATUS_CANCELLED"
        out UINT64 MessageId = messageId;
        
        override string ToString()
        {
            return "CancelSuccess, " + GetCompoundedString(this.Origins[0]) + "Status: " + NtStatusMap[Status.Value] + ", MessageId: " + DecToHexFormat(MessageId);
        }
    } = CancelSuccessScenario[out var messageId, out var status];

    issues virtual operation QueryDirectory
    {
        in SMB2Fileid FileId = request.FileId;
        in FileInformationClasses FileInformationClass = request.FileInformationClass;
        in string Buffer = request.Buffer;
        out ERREF.NTSTATUS Status = status as ERREF.NTSTATUS;
        
        override string ToString()
        {
            return "QueryDirectory, " + GetCompoundedString(this.Origins[0]) + "Status: " + NTStatusLEToString(Status) + ", FileId: " + DecToHexFormat(FileId.Persistent) +
                ", SearchPattern: " + (Buffer.Count == 0 ? "NULL":Buffer) + 
                ", FileInformationClass: " + FileInformationClassesToText(FileInformationClass);
        }
    } = QueryDirectoryScenario[out var request, out var status];

    issues virtual operation ChangeNotify
    {
        in SMB2Fileid FileId = request.FileId;
        in SMB2ChangeNotifyRequestCompletionFilter CompletionFilter = request.CompletionFilter;
        in UINT64 MessageId = messageId;
        out optional ERREF.NTSTATUS Status = status as (optional ERREF.NTSTATUS);
        
        override string ToString()
        {
            return "ChangeNotify, " + GetCompoundedString(this.Origins[0]) + (Status is st:ERREF.NTSTATUS ? ("Status: " + NTStatusLEToString(st) + ", ") : "") + ", FileId: " + DecToHexFormat(FileId.Persistent) +
                ", CompletionFilter: " + EnumToString(CompletionFilter, "SMB2.SMB2ChangeNotifyRequestCompletionFilter");
        }
    } = ChangeNotifyScenario[out var request, out var messageId, out var status];

    // Future Reference: enable virtual operation accept multi-message types, OplockBreakResponse and OplockBreakNotificaiton
    issues virtual operation OplockBreak
    {
        in SMB2OplockBreakAcknowledgmentOplockLevel OplockLevel = ack.OplockLevel;
        in SMB2Fileid FileId = ack.FileId;
        out ERREF.NTSTATUS Status = status as ERREF.NTSTATUS;

        override string ToString()
        {
            return "OplockBreak, " + GetCompoundedString(this.Origins[0]) + "Status: " + NTStatusLEToString(Status) + ", FileId: " + DecToHexFormat(FileId.Persistent) + ", OplockLevel: " + EnumToString(OplockLevel, "SMB2.SMB2OplockBreakAcknowledgmentOplockLevel");
        }
    } = OplockBreakScenario[out var ack, out var status];
    
    issues virtual operation LeaseBreak
    {
        in GUID LeaseKey = leaseKey;
        out optional SMB2LeaseBreakResponseLeaseState LeaseState = leaseState with DisplayInfo{ToText = SMB2LeaseStateToFullText};
        out ERREF.NTSTATUS Status = status as ERREF.NTSTATUS;

        override string ToString()
        {
            return "LeaseBreak, " + GetCompoundedString(this.Origins[0]) + "Status: " + NTStatusLEToString(Status) +
                (LeaseState is ls:SMB2LeaseBreakResponseLeaseState ? ", LeaseState: " + SMB2LeaseStateToText(ls) : "") +
                ", LeaseKey: {" + LeaseKey.ToString() + "}";
        }
    } = LeaseBreakScenario[out var leaseKey, out var leaseState, out var status];
    
    issues virtual operation Echo
    {
        out ERREF.NTSTATUS Status = status as ERREF.NTSTATUS;
        
        override string ToString()
        {
            return "Echo, " + GetCompoundedString(this.Origins[0]) + "Status: " + NTStatusLEToString(Status);
        }
    } = EchoScenario[out var status];
}

// ------------------------------------------
// Scenario

scenario ComNegotiateScenario[out SMB2.SMB2NegotiateResponseDialectRevision dialectRevision, out optional ERREF.NTSTATUS status] =
    accepts SMB.Messages.ComNegotiateRequest{Mid is var mid}
    issues SMB2.Messages.NegotiateResponse{Header is SMB2.SMB2PacketHeader{MessageId == (mid as ulong), Status is status}, Response is var response, response.DialectRevision is dialectRevision};
    
scenario NegotiateScenario[out GUID clientGuid, out optional SMB2.SMB2NegotiateResponseDialectRevision dialectRevision, out optional ERREF.NTSTATUS status] =
    backtrack(Messages.NegotiateRequest{})
    accepts SMB2.Messages.NegotiateRequest{Header is var header, Request.ClientGuid is clientGuid}
    (
        issues SMB2.Messages.NegotiateResponse{Header is SMB2.SMB2PacketHeader{MessageId == header.MessageId, Status is status}, Response.DialectRevision is dialectRevision}
        or
        issues SMB2.Messages.ErrorResponse{Header is SMB2.SMB2PacketHeader{MessageId == header.MessageId, Status is status}}
    );

scenario SessionSetupScenario[out SMB2SessionSetupRequestFlags requestFlags, out optional SMB2SessionSetupResponseSessionFlags sessionFlags, out optional string ki, out optional ERREF.NTSTATUS status] =
    backtrack(Messages.SessionSetupRequest{})
    accepts SMB2.Messages.SessionSetupRequest{#KeyInformation is ki, Header.MessageId is var messageId, Request.Flags is requestFlags}
    later
    (
        issues SMB2.Messages.SessionSetupResponse{Header is SMB2.SMB2PacketHeader{MessageId == messageId, Status is status}, Response.SessionFlags is sessionFlags}
        or
        issues SMB2.Messages.ErrorResponse{Header is SMB2.SMB2PacketHeader{MessageId == messageId, Status is status}}
    );
   
scenario LogoffScenario[out UINT64 sessionId, out optional ERREF.NTSTATUS status] =
    backtrack(Messages.LogoffRequest{})
    accepts SMB2.Messages.LogoffRequest{Header.MessageId is var messageId}
    later
    (
        issues SMB2.Messages.LogoffResponse{Header is (SMB2.SMB2PacketHeader{MessageId == messageId, Status is status, SessionId is sessionId})}
        or
        issues SMB2.Messages.ErrorResponse{Header is SMB2.SMB2PacketHeader{MessageId == messageId, Status is status, SessionId is sessionId}}
    );

scenario TreeConnectScenario[out string buffer, out optional ULONG treeId, out optional SMB2.SMB2TreeConnectResponseCapabilities capabilities, out optional ERREF.NTSTATUS status] =
    backtrack(Messages.TreeConnectRequest{})
    accepts SMB2.Messages.TreeConnectRequest{Header.MessageId is var messageId, Request.GetPathName() is buffer}
    later
    (
        issues SMB2.Messages.TreeConnectResponse{Header is SMB2.SMB2PacketHeader{MessageId == messageId, Status is status, TreeId is treeId}, Response.Capabilities is capabilities}
        or
        issues SMB2.Messages.ErrorResponse{Header is SMB2.SMB2PacketHeader{MessageId == messageId, Status is status}}
    );
     
scenario TreeDisconnectScenario[out optional ULONG treeId, out optional ERREF.NTSTATUS status] =
    backtrack(Messages.TreeDisconnectRequest{})
    accepts SMB2.Messages.TreeDisconnectRequest{Header.TreeId is treeId, Header.MessageId is var messageId}
    later
    (
        issues SMB2.Messages.TreeDisconnectResponse{Header is SMB2.SMB2PacketHeader{MessageId == messageId, Status is status}}
        or
        issues SMB2.Messages.ErrorResponse{Header is SMB2.SMB2PacketHeader{MessageId == messageId, Status is status}}
    );

scenario CreateScenario[out SMB2CreateRequestBuffer buffer, out UINT64 messageId, out optional SMB2.SMB2Fileid fileId, out optional ERREF.NTSTATUS status] =
    backtrack(Messages.CreateRequest{})
    accepts SMB2.Messages.CreateRequest{Header.MessageId is messageId, Request.Buffer is buffer}
    later
    (
        issues SMB2.Messages.ErrorResponse{Header is SMB2.SMB2PacketHeader{MessageId == messageId && Status is sta:ERREF.NTSTATUS && sta.Value == 0x00000103, Status is status}}
    )?
    later
    (
        issues SMB2.Messages.CreateResponse{Header is SMB2.SMB2PacketHeader{MessageId == messageId, Status is status}, Response.FileId is fileId}
        or
        issues SMB2.Messages.ErrorResponse{Header is SMB2.SMB2PacketHeader{MessageId == messageId && Status is sta:ERREF.NTSTATUS && sta.Value != 0x00000103, Status is status}}
    );

scenario CloseScenario[out SMB2.SMB2Fileid fileId, out optional ERREF.NTSTATUS status] =
    backtrack(Messages.CloseRequest{})
    accepts SMB2.Messages.CloseRequest{Header.MessageId is var messageId, Request.FileId is fileId}
    later
    (
        issues SMB2.Messages.CloseResponse{Header is SMB2.SMB2PacketHeader{MessageId == messageId, Status is status}}
        or
        issues SMB2.Messages.ErrorResponse{Header is SMB2.SMB2PacketHeader{MessageId == messageId, Status is status}}
    );

scenario ReadScenario[out SMB2.SMB2ReadRequest request, out UINT64 messageId, out optional binary readBuffer, out optional ERREF.NTSTATUS status] =
    backtrack(Messages.ReadRequest{})
    accepts SMB2.Messages.ReadRequest{Header.MessageId is messageId, Request is request}
    later
    (
        issues SMB2.Messages.ErrorResponse{Header is SMB2.SMB2PacketHeader{MessageId == messageId && Status is sta:ERREF.NTSTATUS && sta.Value == 0x00000103, Status is status}, nothing is readBuffer}
    )?
    later
    (
        issues SMB2.Messages.ReadResponse{Header is SMB2.SMB2PacketHeader{MessageId == messageId, Status is status}, Response.Buffer is readBuffer}
        or
        issues SMB2.Messages.ErrorResponse{Header is SMB2.SMB2PacketHeader{MessageId == messageId && Status is sta:ERREF.NTSTATUS && sta.Value != 0x00000103, Status is status}, nothing is readBuffer}
    );

scenario WriteScenario[out SMB2.SMB2WriteRequest request, out UINT64 messageId, out optional ERREF.NTSTATUS status] =
    backtrack(Messages.WriteRequest{})
    accepts SMB2.Messages.WriteRequest{Header.MessageId is messageId, Request is request}
    later
    (
        issues SMB2.Messages.ErrorResponse{Header is SMB2.SMB2PacketHeader{MessageId == messageId && Status is sta:ERREF.NTSTATUS && sta.Value == 0x00000103, Status is status}}
    )?
    later
    (
        issues SMB2.Messages.WriteResponse{Header is SMB2.SMB2PacketHeader{MessageId == messageId, Status is status}}
        or
        issues SMB2.Messages.ErrorResponse{Header is SMB2.SMB2PacketHeader{MessageId == messageId && Status is sta:ERREF.NTSTATUS && sta.Value != 0x00000103, Status is status}}
    );

scenario LockScenario[out SMB2.SMB2Fileid fileId, out UINT64 messageId, out optional ERREF.NTSTATUS status] =
    backtrack(Messages.LockRequest{})
    accepts SMB2.Messages.LockRequest{Header.MessageId is messageId, Request.FileId is fileId}
    later
    (
        issues SMB2.Messages.ErrorResponse{Header is SMB2.SMB2PacketHeader{MessageId == messageId && Status is sta:ERREF.NTSTATUS && sta.Value == 0x00000103, Status is status}}
    )?
    later
    (
        issues SMB2.Messages.LockResponse{Header is SMB2.SMB2PacketHeader{MessageId == messageId, Status is status}}
        or
        issues SMB2.Messages.ErrorResponse{Header is SMB2.SMB2PacketHeader{MessageId == messageId && Status is sta:ERREF.NTSTATUS && sta.Value != 0x00000103, Status is status}}
    );

scenario IoctlScenario[out SMB2.SMB2Fileid fileId, out ULONG ctlCode, out UINT64 messageId, out optional ERREF.NTSTATUS status] =
    backtrack(Messages.IoctlRequest{})
    accepts SMB2.Messages.IoctlRequest{Header.MessageId is messageId, Request.FileId is fileId, Request.CtlCode is ctlCode}
    later
    (
        issues SMB2.Messages.ErrorResponse{Header is SMB2.SMB2PacketHeader{MessageId == messageId && Status is sta:ERREF.NTSTATUS && sta.Value == 0x00000103, Status is status}}
    )?
    later
    (
        issues SMB2.Messages.IoctlResponse{Header is SMB2.SMB2PacketHeader{MessageId == messageId, Status is status}}
        or
        issues SMB2.Messages.ErrorResponse{Header is SMB2.SMB2PacketHeader{MessageId == messageId && Status is sta:ERREF.NTSTATUS && sta.Value != 0x00000103, Status is status}}
    );

scenario QueryInfoScenario[out SMB2.SMB2QueryInfoRequest request, out optional ERREF.NTSTATUS status] =
    backtrack(Messages.QueryInfoRequest{})
    accepts SMB2.Messages.QueryInfoRequest{Header.MessageId is var messageId, Request is request}
    later
    (
        issues SMB2.Messages.QueryInfoResponse{Header is SMB2.SMB2PacketHeader{MessageId == messageId, Status is status}}
        or
        issues SMB2.Messages.ErrorResponse{Header is SMB2.SMB2PacketHeader{MessageId == messageId, Status is status}}
    );

scenario SetInfoScenario[out SMB2.SMB2SetInfoRequest request, out optional ERREF.NTSTATUS status] =
    backtrack(Messages.SetInfoRequest{})
    accepts SMB2.Messages.SetInfoRequest{Header.MessageId is var messageId, Request is request}
    later
    (
        issues SMB2.Messages.SetInfoResponse{Header is SMB2.SMB2PacketHeader{MessageId == messageId, Status is status}}
        or
        issues SMB2.Messages.ErrorResponse{Header is SMB2.SMB2PacketHeader{MessageId == messageId, Status is status}}
    );

scenario FlushScenario[out SMB2.SMB2FlushRequest request, out optional ERREF.NTSTATUS status] =
    backtrack(Messages.FlushRequest{})
    accepts SMB2.Messages.FlushRequest{Header.MessageId is var messageId, Request is request}
    later
    (
        issues SMB2.Messages.FlushResponse{Header is SMB2.SMB2PacketHeader{MessageId == messageId, Status is status}}
        or
        issues SMB2.Messages.ErrorResponse{Header is SMB2.SMB2PacketHeader{MessageId == messageId, Status is status}}
    );

// If Request.AsyncId is not empty, indicating that the command has previously returned an interim response, 
// the client sets SMB2_FLAGS_ASYNC_COMMAND to TRUE in the Flags field and sets AsyncId to Request.AsyncId
scenario CancelSuccessScenario[out UINT64 messageId, out optional ERREF.NTSTATUS status] =
    backtrack(Messages.CancelRequest{})
    accepts SMB2.Messages.CancelRequest{Header is SMB2.SMB2PacketHeader{MessageId is messageId, AsyncId is var asyncId}}
    later
    issues SMB2.Messages.ErrorResponse{Header is SMB2.SMB2PacketHeader{MessageId == messageId || AsyncId == asyncId, (Status is status) && (Status != nothing) && (Status as ERREF.NTSTATUS).Value == 0xC0000120}}; // 0xC0000120 is NtStatus.STATUS_CANCELLED

scenario QueryDirectoryScenario[out SMB2.SMB2QueryDirectoryRequest request, out optional ERREF.NTSTATUS status] =
    backtrack(Messages.QueryDirectoryRequest{})
    accepts SMB2.Messages.QueryDirectoryRequest{Header is var header, Request is request}
    later
    (
        issues SMB2.Messages.QueryDirectoryResponse{Header is SMB2.SMB2PacketHeader{MessageId == header.MessageId, Status is status}}
        or
        issues SMB2.Messages.ErrorResponse{Header is SMB2.SMB2PacketHeader{MessageId == header.MessageId, Status is status}}
    );

scenario ChangeNotifyScenario[out SMB2.SMB2ChangeNotifyRequest request, out UINT64 messageId, out optional ERREF.NTSTATUS status] =
    backtrack(Messages.ChangeNotifyRequest{})
    accepts SMB2.Messages.ChangeNotifyRequest{Header.MessageId is messageId, Request is request}
    later
    (
        issues SMB2.Messages.ErrorResponse{Header is SMB2.SMB2PacketHeader{MessageId == messageId && Status is sta:ERREF.NTSTATUS && sta.Value == 0x00000103, Status is status}}
    )?
    later
    (
        (
            issues SMB2.Messages.ChangeNotifyResponse{Header is SMB2.SMB2PacketHeader{MessageId == messageId, Status is status}}
            or
            issues SMB2.Messages.ErrorResponse{Header is SMB2.SMB2PacketHeader{MessageId == messageId && Status is sta:ERREF.NTSTATUS && sta.Value != 0x00000103, Status is status}}
            or
            // if we cannot find a complete sequence {Request->(Interim Response)*->Response} until the end of this trace, then we'll try to group {Request->Interim Response} as VOP.
            // we only do this for change notify message which has gearter chance to lost the final response message.
            [|eos() && status != nothing|] // status != nothing, means the interim response is matched already
        )
    );

scenario OplockBreakScenario[out SMB2.SMB2OplockBreakAcknowledgment ack, out optional ERREF.NTSTATUS status] =
    backtrack(Messages.OplockBreakNotification{})
    (
        issues SMB2.Messages.OplockBreakNotification{Notification.FileId is SMB2.SMB2Fileid{Persistent is var persistentFid, Volatile is var volatileFid}}
    )
    later
    accepts SMB2.Messages.OplockBreakAcknowledgment{Acknowledgment.FileId is SMB2.SMB2Fileid{Persistent == persistentFid, Volatile == volatileFid}, Header.MessageId is var messageId, Acknowledgment is ack}
    later
    (
        issues SMB2.Messages.OplockBreakResponse{Header.MessageId == messageId && Response.FileId is SMB2.SMB2Fileid{Persistent == persistentFid, Volatile == volatileFid}, Header.Status is status}
        or
        issues SMB2.Messages.ErrorResponse{Header is SMB2.SMB2PacketHeader{MessageId == messageId, Status is status}}
    );

scenario LeaseBreakScenario[out GUID leaseKey, out optional SMB2LeaseBreakResponseLeaseState leaseState, out optional ERREF.NTSTATUS status] =
    backtrack(Messages.LeaseBreakNotification{})
    (
        issues SMB2.Messages.LeaseBreakNotification{Notification is SMB2.SMB2LeaseBreakNotification{LeaseKey is leaseKey}}
    )
    later
    accepts SMB2.Messages.LeaseBreakAcknowledgment{Acknowledgment.LeaseKey == leaseKey, Header.MessageId is var messageId, Acknowledgment is var ack}
    later
    (
        issues SMB2.Messages.LeaseBreakResponse{Header.MessageId == messageId && Response.LeaseKey == leaseKey, Header.Status is status, Response is SMB2.SMB2LeaseBreakResponse{LeaseState is leaseState}}
        or
        issues SMB2.Messages.ErrorResponse{Header is SMB2.SMB2PacketHeader{MessageId == messageId, Status is status}}
    );

scenario EchoScenario[out optional ERREF.NTSTATUS status] =
    backtrack(Messages.EchoRequest{})
    accepts SMB2.Messages.EchoRequest{Header.MessageId is var messageId}
    later
    (
        issues SMB2.Messages.EchoResponse{Header is SMB2.SMB2PacketHeader{MessageId == messageId, Status is status}}
        or
        issues SMB2.Messages.ErrorResponse{Header is SMB2.SMB2PacketHeader{MessageId == messageId, Status is status}}
    );

void DecodeSecurityBufferInSMB2SessionSetupRequest(SMB2.Messages.SessionSetupRequest req)
{
    if (req.Request.Buffer is b:binary)
    {
        if (IsGSSAPIByCheckingTag(b))
        {
            var g = DecodeGssapiAndSetAnnotation(b, req);
            if (g != nothing)
            {
                GssapiType gssapi = g as GssapiType;
                req.Request.Buffer = gssapi;
                req#KeyInformation = gssapi#KeyInformation;
            }
            else
            {
                ValidationCheck(false, req, DiagnosisLevel.Warning, () => Format(SMB2_STR_GSSAPI_DECODING_FAILURE, "SessionSetupRequest"));
            }
        }
        else if (IsNLMP(b))
        {
            var nlmpMessage = NlmpDecoder(b);
            if (nlmpMessage != nothing && nlmpMessage is nm:NegotiateMessage)
            {
                req.Request.Buffer = nm;
                req#Embedded = {"NLMP" -> ""};
                req#KeyInformation = GetSummaryInfo(nm);
            }
            else if (nlmpMessage != nothing && nlmpMessage is am:AuthenticateMessage)
            {
                req.Request.Buffer = am;
                req#Embedded = {"NLMP" -> ""};
                req#KeyInformation = GetSummaryInfo(am);
            }
            else
            {
                ValidationCheck(false, req, DiagnosisLevel.Warning, () => Format(SMB2_STR_NLMP_DECODING_FAILURE, "SessionSetupRequest"));
            }
        }
    }
}

void DecodeSecurityBufferInSMB2SessionSetupResponse(SMB2.Messages.SessionSetupResponse resp)
{
    if (resp.Response.Buffer is b:binary)
    {
        if (IsGSSAPIByCheckingTag(b))
        {
            var g = DecodeGssapiAndSetAnnotation(b, resp);
            if (g != nothing)
            {
                GssapiType gssapi = g as GssapiType;
                resp.Response.Buffer = gssapi;
                resp#KeyInformation = gssapi#KeyInformation;
            }
            else
            {
                ValidationCheck(false, resp, DiagnosisLevel.Warning, () => Format(SMB2_STR_GSSAPI_DECODING_FAILURE, "SessionSetupResponse"));
            }
        }
        else if (IsNLMP(b))
        {
            var nlmpMessage = NlmpDecoder(b);
            if (nlmpMessage != nothing)
            {
                resp.Response.Buffer = nlmpMessage as ChallengeMessage;
                resp#Embedded = {"NLMP" -> ""};
                resp#KeyInformation = GetSummaryInfo(nlmpMessage);
            }
            else
            {
                ValidationCheck(false, resp, DiagnosisLevel.Warning, () => Format(SMB2_STR_NLMP_DECODING_FAILURE, "SessionSetupResponse"));
            }
        }
    }
}

// Header only message for in case that the data is insufficient for the body part or the body part can't be decoded successfully
message SMB2HeaderOnly[bool IsRequest, ushort DialectRevision]
{
    SMB2.SMB2PacketHeader[IsRequest, DialectRevision] Header
        where ValidationCheck(false, this, DiagnosisLevel.Error, "SMB2: The body part cannot be decoded successfully.");
    
    override string ToString()
    {
        return (this#SMB2MessageName is nothing) ? "" : ((this#SMB2MessageName as string) + ", ") + "Header Only" + (Header.GetStatus().Count == 0 ? "" : (", " + Header.GetStatus()));
    }
}

message TransformMessage[ushort DialectRevision, ushort CipherId]
{
    SMB2TransformHeader[DialectRevision, CipherId] Header;
    binary Data;
    
    override string ToString()
    {
        return "TransformMessage, Encrypted";
    }
}

message CompressedTransformMessage
{
    SMB2CompressedTransformHeader Header;
    binary Data;
    
    override string ToString()
    {
        return "CompressedTransformMessage, Compressed";
    }
}

// -------------------------------------------
// Data types

// 2.2.1   SMB2 Packet Header 
type SMB2PacketHeader[bool IsRequest, ushort DialectRevision]
{
    ULONG ProtocolId where ValidationCheckValue(value == 0xFE534D42, null, true, ReferenceType.Type, "SMB2", "ProtocolId", "SMB2PacketHeader", "(in network order) 0xFE, 'S', 'M', and 'B'", value)
        with BinaryEncoding {Endian = Endian.Big};
  
    USHORT StructureSize where ValidationCheckValue(value == 64, null, true, ReferenceType.Type, "SMB2", "StructureSize", "SMB2PacketHeader", 64, value);
    
    USHORT CreditCharge;

    // In a request of SMB 3.x dialect, this 4 bytes is interpreted as (ChannelSequence + Reserved);
    // Otherwise, it is interpreted as Status.
    optional [|IsRequest && InRange<SMB3xDialectFamily>(DialectRevision)|] USHORT ChannelSequence;
    optional [|IsRequest && InRange<SMB3xDialectFamily>(DialectRevision)|] USHORT Reserved;

    optional [|!IsRequest || !InRange<SMB3xDialectFamily>(DialectRevision)|] ERREF.NTSTATUS Status;
  
    SMB2PacketHeaderCommand Command
        where ValidationCheck(InRange<SMB2PacketHeaderCommand>(value), null, DiagnosisLevel.Error, 
            () => Format(INFRASTRUCTURE_STR_CHECK_VALUE_IN_RANGE, ["SMB2", "Command", INFRASTRUCTURE_STR_TYPE, "SMB2PacketHeader", INFRASTRUCTURE_STR_MUST, "0x0000", "0x0012", value]));
  
    USHORT Credit;
  
    SMB2PacketHeaderFlags Flags where ValidationCheckEnumValueTooManyItems(InRange<SMB2PacketHeaderFlags>(value), null, true, 
            ReferenceType.Type, "SMB2", "Flags", "SMB2PacketHeaderFlags", "SMB2PacketHeader", "SMB2");

    ULONG NextCommand;
  
    UINT64 MessageId;

    optional [|(Flags & SMB2PacketHeaderFlags.SMB2FlagsAsyncCommand) == 0|] ULONG Reserved2;
  
    optional [|(Flags & SMB2PacketHeaderFlags.SMB2FlagsAsyncCommand) == 0|] ULONG TreeId;

    optional [|(Flags & SMB2PacketHeaderFlags.SMB2FlagsAsyncCommand) != 0|] UINT64 AsyncId;

    UINT64 SessionId;

    binary Signature where ValidationCheck(((Flags & SMB2PacketHeaderFlags.SMB2FlagsSigned) != 0 && value != $[00000000000000000000000000000000]) || 
                                            ((Flags & SMB2PacketHeaderFlags.SMB2FlagsSigned) == 0 && value == $[00000000000000000000000000000000]), null, DiagnosisLevel.Error,
                                            () => ((Flags & SMB2PacketHeaderFlags.SMB2FlagsSigned) != 0) ?
                                                "SMB2: The SMB2_FLAGS_SIGNED bit of the Flags field in type SMB2PacketHeader must not be set if the Signature field is zero." :
                                                "SMB2: The Signature field in type SMB2PacketHeader must be zero if SMB2_FLAGS_SIGNED bit of the Flags field is not set, not " + value.ToString() + ".")
        with BinaryEncoding{Length = 16};

    override string ToString()
    {
        string summary = "";
        if (!IsRequest)
        {
            summary = "Status: " + StatusToText(this) + ", ";
        }
        return summary + "Command: " + EnumToStringInSummary<SMB2.SMB2PacketHeaderCommand>(Command) + ", " +
            "SessionId: " + DecToHexFormat(SessionId) + ", " +
            ((TreeId != nothing) ? "TreeId: " + DecToHexFormat(TreeId as ULONG) : "AsyncId: " + DecToHexFormat(AsyncId as UINT64)) + ", " +
            "MessageId: " + DecToHexFormat(MessageId) + ", " +
            "Credit: " + DecToHexFormat(Credit) + ", " +
            "CreditCharge: " + DecToHexFormat(CreditCharge);
    }

    string GetStatus()
    {
        if (!IsRequest)
        {
            return "Status: " + StatusToText(this);
        }
        else
        {
            return "";
        }
    }

    bool IsRequestMessage()
    {
        return IsRequest;
    }
}

pattern SMB2PacketHeaderCommand = enum USHORT
{
    SMB2Negotiate      = 0x0000,
    SMB2SessionSetup   = 0x0001,
    SMB2Logoff         = 0x0002,
    SMB2TreeConnect    = 0x0003,
    SMB2TreeDisconnect = 0x0004,
    SMB2Create         = 0x0005,
    SMB2Close          = 0x0006,
    SMB2Flush          = 0x0007,
    SMB2Read           = 0x0008,
    SMB2Write          = 0x0009,
    SMB2Lock           = 0x000A,
    SMB2Ioctl          = 0x000B,
    SMB2Cancel         = 0x000C,
    SMB2Echo           = 0x000D,
    SMB2QueryDirectory = 0x000E,
    SMB2ChangeNotify   = 0x000F,
    SMB2QueryInfo      = 0x0010,
    SMB2SetInfo        = 0x0011,
    SMB2OplockBreak    = 0x0012,
    ...
};

pattern SMB2PacketHeaderFlags = flags ULONG
{
    SMB2FlagsServerToRedir = 0x00000001
        with Documentation
            {Description = "When set, indicates the message is a response rather than a request. This MUST be set on responses sent from the server to the client, and MUST NOT be set on requests sent from the client to the server."},
    SMB2FlagsAsyncCommand = 0x00000002
        with Documentation
            {Description = "When set, indicates that this is an Async SMB2 header. Always set for headers of the form described in this section."},
    SMB2FlagsRelatedOperations = 0x00000004
        with Documentation
            {Description = "When set in an SMB2 request, indicates that this request is a related operation in a compounded request chain. The use of this flag in an SMB2 request is as specified in .When set in an SMB2 compound response, indicates that the request corresponding to this response was part of a related operation in a compounded request chain. The use of this flag in an SMB2 response is as specified in ."},       
    SMB2FlagsSigned = 0x00000008
        with Documentation
            {Description = "When set, indicates that this packet has been signed. The use of this flag is as specified in 3.1.5.1."},
    SMB2FlagsPriorityMask = 0x00000070
        with Documentation
            {Description = "This flag is only valid for the SMB 3.1.1 dialect. It is a mask for the requested I/O priority of the request, and it MUST be a value in the range 0 to 7."},
    SMB2FlagsDFSOperations = 0x10000000
        with Documentation
            {Description = "When set, indicates that this command is a Distributed File System(DFS) operation. The use of this flag is as specified in ."},
    SMB2FlagsReplayOperation = 0x20000000
        with Documentation
            {Description = "This flag is only valid for the SMB 3.x dialect family. When set, it indicates that this command is a replay operation. The client MUST ignore this bit on receipt."}
    ...
};

// 2.2.2   SMB2 ERROR Response
type SMB2ErrorResponse[uint Status, ushort DialectRevision]
{
    USHORT StructureSize where ValidationCheckValue(value == 9, null, true, ReferenceType.Type, "SMB2", "StructureSize", "SMB2ErrorResponse", 9, value);
    // 2.2.2   SMB2 ERROR Response: This field MUST be set to 0 for SMB dialects other than 3.1.1
    BYTE ErrorContextCount
        where ValidationCheck(DialectRevision == SMB2NegotiateResponseDialectRevision.SMB311DialectRevisionNumber || ErrorContextCount == 0,
            null, DiagnosisLevel.Error, () => SMB2_STR_SMB2ErrorResponse_ErrorContextCount);
    BYTE Reserved where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Reserved", "SMB2ErrorResponse", value);

    ULONG ByteCount;

    (
    // 2.2.2   SMB2 ERROR Response: If the ByteCount field is zero
    // then the server MUST supply an ErrorData field that is one byte in length
    [|ByteCount == 0|] BYTE
    // 2.2.2   SMB2 ERROR Response: For the SMB dialect 3.1.1, if this field is nonzero,
    // the ErrorData field MUST be formatted as a variable-length array of SMB2 ERROR Context structures containing ErrorContextCount entries.
    | [|DialectRevision == SMB2NegotiateResponseDialectRevision.SMB311DialectRevisionNumber && ErrorContextCount > 0|] array<SMB2ErrorContext[Status]>
    // 2.2.2.2 ErrorData format: If the error code in the header of the response is set to STATUS_STOPPED_ON_SYMLINK, 
    // this field MUST contain a Symbolic Link Error Response as specified in section 2.2.2.2.1.
    | [|Status == Smb2StatusValue.STATUS_STOPPED_ON_SYMLINK|] SymbolicLinkErrorResponseErrorData
    // 2.2.2.2 ErrorData format: If the error code in the header of the response is STATUS_BUFFER_TOO_SMALL,
    // this field MUST be set to a 4-byte value indicating the minimum required buffer length.
    | [|Status == Smb2StatusValue.STATUS_BUFFER_TOO_SMALL|] UINT
    | string
    ) ErrorData with BinaryEncoding{WidthForComposedType = ByteCount == 0 ? 8 : ByteCount * 8, Length = ErrorContextCount};
};

// 2.2.2.1   SMB2 ERROR Context Response
type SMB2ErrorContext[uint Status]
{
    UINT ErrorDataLength;
    SMB2ErrorContext_ErrorId ErrorId where ValidationCheckEnumValue(InRange<SMB2ErrorContext_ErrorId>(value), null, true, ReferenceType.Type, "SMB2", "ErrorId", "SMB2ErrorContext", "0x00000000, 0x72645253", value);
    // 2.2.2 SMB2 ERROR Response: Each SMB2 ERROR Context MUST start at an 8-byte aligned boundary relative to the start of the SMB2 ERROR Response.
    ([|Status == Smb2StatusValue.STATUS_STOPPED_ON_SYMLINK|] SymbolicLinkErrorResponseErrorData
    // 2.2.2.2 ErrorData format: If the error code in the header of the response is set to STATUS_BAD_NETWORK_NAME, 
    // and the ErrorId in the SMB2 Error Context response is set to SMB2_ERROR_ID_SHARE_REDIRECT, 
    // this field MUST contain a Share Redirect Error Response as specified in section 2.2.2.2.2.
    | [|Status == Smb2StatusValue.STATUS_BAD_NETWORK_NAME && ErrorId == SMB2ErrorContext_ErrorId.SMB2_ERROR_ID_SHARE_REDIRECT|] ShareRedirectErrorContextResponseErrorData
    // 2.2.2.2 ErrorData format: If the error code in the header of the response is STATUS_BUFFER_TOO_SMALL,
    // this field MUST be set to a 4-byte value indicating the minimum required buffer length.
    | [|Status == Smb2StatusValue.STATUS_BUFFER_TOO_SMALL|] UINT
    | string) ErrorContextData with BinaryEncoding{Length = ErrorDataLength, TrailPadding = (ErrorDataLength % 8) > 0 ? (8 - (ErrorDataLength % 8)) : 0};
}

pattern SMB2ErrorContext_ErrorId = enum UINT
{
    SMB2_ERROR_ID_DEFAULT      = 0x00000000,
    SMB2_ERROR_ID_SHARE_REDIRECT = 0x72645253
    ...
};

// 2.2.2.2.1 Symbolic Link Error Response
type SymbolicLinkErrorResponseErrorData
{
    ULONG SymLinkLength;

    ULONG SymLinkErrorTag where ValidationCheckValue(value == 0x4C4D5953, null, true, ReferenceType.Type, "SMB2", "SymLinkErrorTag", "SymbolicLinkErrorResponseErrorData", "0x4C4D5953", value);

    ULONG ReparseTag where ValidationCheckValue(value == 0xA000000C, null, true, ReferenceType.Type, "SMB2", "ReparseTag", "SymbolicLinkErrorResponseErrorData", "0xA000000C", value);

    USHORT ReparseDataLength where ValidationCheck(value >= 12, null, DiagnosisLevel.Error, () => "SMB2: The ReparseDataLength field in type SymbolicLinkErrorResponseErrorData must be greater than or equal to 12, not " + Utility.DecToHexFormat(value) + ".");

    USHORT UnparsedPathLength;

    USHORT SubstituteNameOffset;

    USHORT SubstituteNameLength;

    USHORT PrintNameOffset;

    USHORT PrintNameLength;

    SymbolicLinkErrorResponseFlags Flags
        where ValidationCheck(InRange<SymbolicLinkErrorResponseFlags>(value), null, DiagnosisLevel.Error,
            () => Format(INFRASTRUCTURE_STR_CHECK_ENUM_VALUE, ["SMB2", "Flags", INFRASTRUCTURE_STR_TYPE, "SymbolicLinkErrorResponseErrorData", INFRASTRUCTURE_STR_MUST, "0x00000000, 0x00000001", Utility.DecToHexFormat(value)]));

    optional [|ReparseDataLength - 12 > 0|] PathBuffer[SubstituteNameOffset, SubstituteNameLength, PrintNameOffset, PrintNameLength] PathBuffer
        with BinaryEncoding{WidthForComposedType = (ReparseDataLength - 12) * 8};
}

type PathBuffer[USHORT SubstituteNameOffset, USHORT SubstituteNameLength, USHORT PrintNameOffset, USHORT PrintNameLength]
{
    string SubstituteName with Encoding{Offset = SubstituteNameOffset, Size = SubstituteNameLength};
    string PrintName with Encoding{Offset = PrintNameOffset, Size = PrintNameLength};
}

pattern SymbolicLinkErrorResponseFlags = enum ULONG
{
    SYMLinkFlagPath = 0x00000000,
    SYMLinkFlagRelative = 0x00000001,
    ...
};

// 2.2.2.2.2 Share Redirect Error Context Response
type ShareRedirectErrorContextResponseErrorData
{
    uint StructureSize;
    uint NotificationType where ValidationCheckValue(value == 3, null, true, ReferenceType.Type, "SMB2", "NotificationType", "ShareRedirectErrorContextResponse", 3, value);
    uint ResourceNameOffset;
    uint ResourceNameLength;
    ushort Flags;
    ushort TargetType;
    uint IPAddrCount;
    array<MOVE_DST_IPADDR> IPAddrMoveList with BinaryEncoding{Length = IPAddrCount};
    string ResourceName with Encoding{Offset = ResourceNameOffset - (IPAddrCount + 1) * 24, Size = ResourceNameLength};
}

// 2.2.2.2.2.1 MOVE_DST_IPADDR structure
type MOVE_DST_IPADDR
{
    MOVE_DST_IPADDR_TYPE Type;
    uint Reserved;
    ([|Type == MOVE_DST_IPADDR_TYPE.MOVE_DST_IPADDR_V4|] IPv4Address |
     [|Type == MOVE_DST_IPADDR_TYPE.MOVE_DST_IPADDR_V6|] IPv6Address) Address;
    optional [|Type == MOVE_DST_IPADDR_TYPE.MOVE_DST_IPADDR_V4|] binary Reserved2 with BinaryEncoding{Length = 12};
}

pattern MOVE_DST_IPADDR_TYPE = enum uint
{
    MOVE_DST_IPADDR_V4 = 0x00000001,
    MOVE_DST_IPADDR_V6 = 0x00000002,
    ...
};

// 2.2.3 SMB2 NEGOTIATE Request
type SMB2NegotiateRequest
{
    USHORT StructureSize where ValidationCheckValue(value == 36, null, true, ReferenceType.Type, "SMB2", "StructureSize", "SMB2NegotiateRequest", 36, value);

    USHORT DialectCount where ValidationCheckGreaterThan(value > 0, null, true, ReferenceType.Type, "SMB2", "DialectCount", "SMB2NegotiateRequest", INFRASTRUCTURE_STR_ZERO, value);

    SMB2NegotiateRequestSecurityMode SecurityMode;

    USHORT Reserved where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Reserved", "SMB2NegotiateRequest", value);

    SMB2NegotiateRequestCapabilities Capabilities;

    GUID ClientGuid;

    // Check whether the last dialect is SMB3.1.1
    optional [|stream.RemainingByteLength() >= (8 + DialectCount * 2) && (stream.PeekUShort(stream.BitPosition + (8 + (DialectCount - 1) * 2) * 8, Endian.Little) == SMB2NegotiateRequestDialects.SMB311DialectRevisionNumber)|] 
        UINT NegotiateContextOffset;
    optional [|NegotiateContextOffset != nothing|] 
        USHORT NegotiateContextCount;
    optional [|NegotiateContextOffset != nothing|] 
        USHORT Reserved2;
    optional [|NegotiateContextOffset == nothing|]
        FILETIME ClientStartTime with DisplayInfo {ToText = SMB2.FileTimeToText};
    array<SMB2NegotiateRequestDialects> Dialects
        with BinaryEncoding{Length = DialectCount};
    optional [|(NegotiateContextCount != nothing) && ((36 + DialectCount * 2) % 8 > 0)|] binary Padding 
        with BinaryEncoding{Length = 8 - ((36 + DialectCount * 2) % 8)};
    optional [|(NegotiateContextCount != nothing) && (NegotiateContextCount as USHORT) > 0|]
        array<SMB2NegotiateContext> NegotiateContextList with BinaryEncoding{Length = NegotiateContextCount as USHORT};

    override string ToString()
    {
        string summary = "Dialects: [";
        bool needComma = false;
        foreach (var e in Dialects)
        {           
            if (needComma)
            {
                summary += ", ";
            }
            else
            {
                needComma = true;
            }
            summary += SMB2.DialectRevisionToText(e);
        }
        summary += "], Capabilities: " + EnumToString<SMB2.SMB2NegotiateRequestCapabilities>(Capabilities) + ", ClientGuid: {" + (ClientGuid as string) + "}";
        return summary;
    }
};

// 2.2.3.1 SMB2 NEGOTIATE_CONTEXT Request Values
type SMB2NegotiateContext
{
    SMB2NegotiateContextContextType ContextType 
        where ValidationCheckEnumValue(InRange<SMB2NegotiateContextContextType>(value), null, true, ReferenceType.Type,
            "SMB2", "ContextType", "SMB2NegotiateContext", "0x0001, 0x0002, 0x0003, 0x0005", value);
    USHORT DataLength;
    UINT Reserved where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Reserved", "SMB2NegotiateContext", value);
    // 2.2.3 SMB2 NEGOTIATE Request: Subsequent negotiate contexts MUST appear at the first 8-byte-aligned offset following the previous negotiate context.
    ([|ContextType == SMB2NegotiateContextContextType.SMB2_PREAUTH_INTEGRITY_CAPABILITIES|] SMB2PreauthIntegrityCapabilities |
    [|ContextType == SMB2NegotiateContextContextType.SMB2_ENCRYPTION_CAPABILITIES|] SMB2EncryptionCapabilities |
    [|ContextType == SMB2NegotiateContextContextType.SMB2_COMPRESSION_CAPABILITIES|] SMB2CompressionCapabilities |
    [|ContextType == SMB2NegotiateContextContextType.SMB2_NETNAME_NEGOTIATE_CONTEXT_ID|] SMB2NetnameNegotiateContextId |
    binary) Data with BinaryEncoding{Length = DataLength};
    optional binary Padding with Encoding{Decoder = AlignTo8Bytes}; // A struct must start on an 8-byte boundary regardless of the type of the struct fields. 
};

pattern SMB2NegotiateContextContextType = enum USHORT
{
    SMB2_PREAUTH_INTEGRITY_CAPABILITIES = 0x0001,
    SMB2_ENCRYPTION_CAPABILITIES        = 0x0002,
    SMB2_COMPRESSION_CAPABILITIES       = 0x0003,
    SMB2_NETNAME_NEGOTIATE_CONTEXT_ID   = 0x0005,
    ...
};

// 2.2.3.1.1 SMB2_PREAUTH_INTEGRITY_CAPABILITIES
type SMB2PreauthIntegrityCapabilities
{
    USHORT HashAlgorithmCount 
        where ValidationCheckGreaterThan(value > 0, null, true, ReferenceType.Type, 
            "SMB2", "HashAlgorithmCount", "SMB2PreauthIntegrityCapabilities", 0, value);
    USHORT SaltLength;
    array<SMB2PreauthIntegrityCapabilitiesHashAlgorithms> HashAlgorithms with BinaryEncoding{Length = HashAlgorithmCount};
    binary Salt with BinaryEncoding{Length = SaltLength};
};

pattern SMB2PreauthIntegrityCapabilitiesHashAlgorithms = enum USHORT
{
    $"SHA-512" = 0x0001,
    ...
};

// 2.2.3.1.2 SMB2_ENCRYPTION_CAPABILITIES
type SMB2EncryptionCapabilities
{
    USHORT CipherCount where ValidationCheckGreaterThan(value > 0, null, true, ReferenceType.Type, "SMB2", "CipherCount", "SMB2EncryptionCapabilities", "0", value);
    array<SMB2EncryptionCapabilitiesCiphers> Ciphers with BinaryEncoding{Length = CipherCount};
};

pattern SMB2EncryptionCapabilitiesCiphers = enum USHORT
{
    AES128CCM = 0x0001,
    AES128GCM = 0x0002,
    ...
};

// 2.2.3.1.3 SMB2_COMPRESSION_CAPABILITIES
type SMB2CompressionCapabilities
{
    USHORT CompressionAlgorithmCount;
    USHORT Padding where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Padding", "SMB2CompressionCapabilities", value);
    UINT Reserved where ValidationCheckReservedZero(value == nothing || value == 0, null, false, ReferenceType.Type, "SMB2", "Reserved", "SMB2CompressionCapabilities", value);
    array<SMB2CompressionCapabilitiesCompressionAlgorithms> CompressionAlgorithms  with BinaryEncoding{Length = CompressionAlgorithmCount};
};

pattern SMB2CompressionCapabilitiesCompressionAlgorithms = enum USHORT
{
    NONE = 0x0000,
    LZNT1 = 0x0001,
    LZ77 = 0x0002,
    LZ77Huffman = 0x0003,
    ...
};

// 2.2.3.1.4 SMB2_NETNAME_NEGOTIATE_CONTEXT_ID
type SMB2NetnameNegotiateContextId
{
    string NetName;
};

pattern SMB2NegotiateRequestCapabilities = flags ULONG
{
    SMB2GlobalCapDfs = 0x00000001
        with Documentation
            {Description = "When set, indicates that the client supports the Distributed File System (DFS)."},
    SMB2GlobalCapLeasing = 0x00000002
        with Documentation
            {Description = "When set, indicates that the client supports leasing."},
    SMB2GlobalCapLargeMtu = 0x00000004
        with Documentation
            {Description = "When set, indicates that the client supports multi-credit operations."},
    SMB2GlobalCapMultiChannel = 0x00000008
        with Documentation
            {Description = "When set, indicates that the client supports establishing multiple channels for a single session."},
    SMB2GlobalCapPersistentHandles = 0x00000010
        with Documentation
            {Description = "When set, indicates that the client supports persistent handles."},
    SMB2GlobalCapDirectoryLeasing = 0x00000020
        with Documentation
            {Description = "When set, indicates that the client supports directory leasing."},
    SMB2GlobalCapEncryption = 0x00000040,
    ...
};

pattern SMB2NegotiateRequestSecurityMode = flags USHORT
{
    SMB2NegotiateSigningEnabled = 0x0001
        with Documentation
               {Description = "When set, indicates that security signatures are enabled on the client. The client MUST set this bit if the SMB2_NEGOTIATE_SIGNING_REQUIRED bit is not set, and MUST NOT set this bit if the SMB2_NEGOTIATE_SIGNING_REQUIRED bit is set. The server MUST ignore this bit."},
    SMB2NegotiateSigningRequired = 0x0002
        with Documentation
               {Description = "When set, indicates that security signatures are required by the client."},
    ...
} with Documentation {EmbeddedType = true};

pattern SMB2NegotiateRequestDialects = enum USHORT
{
    SMB2002DialectRevisionNumber = 0x0202
        with Documentation
            {Description = "SMB 2.002 dialect revision number. Windows Vista SP1, Windows Server 2008, Windows 7, Windows Server 2008 R2, Windows 8, Windows Server 2012, Windows 8.1, and Windows Server 2012 R2 support this dialect revision."},
    SMB21DialectRevisionNumber = 0x0210
        with Documentation
            {Description = "SMB 2.1 dialect revision number. Windows Vista SP1 and Windows Server 2008 do not support this dialect revision."},
    SMB30DialectRevisionNumber = 0x0300
        with Documentation
            {Description = "SMB 3.0 dialect revision number. Windows Vista SP1, Windows Server 2008, Windows 7, and Windows Server 2008 R2 do not support this dialect revision."},
    SMB302DialectRevisionNumber = 0x0302
        with Documentation
            {Description = "SMB 3.02 dialect revision number. Windows Vista SP1, Windows Server 2008, Windows 7, Windows Server 2008 R2, Windows 8, and Windows Server 2012 do not support the SMB 3.02 dialect."},
    SMB311DialectRevisionNumber = 0x0311
        with Documentation
            {Description = "SMB 3.1.1 dialect revision number. Windows Vista SP1, Windows Server 2008, Windows 7, Windows Server 2008 R2, Windows 8, Windows Server 2012, Windows 8.1, and Windows Server 2012 R2 do not support the SMB 3.1.1 dialect."},
    ...
};

// 2.2.4   SMB2 NEGOTIATE Response
type SMB2NegotiateResponse
{
    USHORT StructureSize where ValidationCheckValue(value == 65, null, true, ReferenceType.Type, "SMB2", "StructureSize", "SMB2NegotiateResponse", 65, value);

    SMB2NegotiateResponseSecurityMode SecurityMode;

    SMB2NegotiateResponseDialectRevision DialectRevision where ValidationCheckEnumValue(InRange<SMB2NegotiateResponseDialectRevision>(value), null, false, ReferenceType.Type, "SMB2", "DialectRevision", "SMB2NegotiateResponse", "0x0202, 0x0210, 0x0300, 0x0302, 0x0311, 0x02FF", value)
        with DisplayInfo{ToText = SMB2.DialectRevisionToText};

    optional [|DialectRevision == SMB2NegotiateResponseDialectRevision.SMB311DialectRevisionNumber|] USHORT NegotiateContextCount;
    optional [|DialectRevision != SMB2NegotiateResponseDialectRevision.SMB311DialectRevisionNumber|] USHORT Reserved
        where ValidationCheckReservedZero(value == nothing || value == 0, null, false, ReferenceType.Type, "SMB2", "Reserved", "SMB2NegotiateResponse", value);

    GUID ServerGuid;

    SMB2NegotiateResponseCapabilities Capabilities
        where ValidationCheckCombinationValueIncludeZeroTooManyItems((0 == value) || InRange<SMB2NegotiateResponseCapabilities>(value), 
            null, true, ReferenceType.Type, "SMB2", "Capabilities", "SMB2NegotiateResponse", "SMB2 NEGOTIATE Response", "[MS-SMB2]");

    ULONG MaxTransactSize;

    ULONG MaxReadSize;

    ULONG MaxWriteSize;

    FILETIME SystemTime;

    FILETIME ServerStartTime;

    USHORT SecurityBufferOffset;

    USHORT SecurityBufferLength;

    optional [|DialectRevision == SMB2NegotiateResponseDialectRevision.SMB311DialectRevisionNumber|] ULONG NegotiateContextOffset;
    optional [|DialectRevision != SMB2NegotiateResponseDialectRevision.SMB311DialectRevisionNumber|] ULONG Reserved2;

    // Future Reference: We can try to use mix-encoding here
    (binary | GssapiType) Buffer with BinaryEncoding{Length = SecurityBufferLength, LeadPadding = (SecurityBufferLength == 0 ? 0 : (SecurityBufferOffset - 128))};

    optional [|NegotiateContextOffset != nothing && ((NegotiateContextOffset as ULONG) - SecurityBufferOffset - SecurityBufferLength > 0)|] binary Padding with BinaryEncoding{Length = (NegotiateContextOffset as ULONG) - SecurityBufferOffset - SecurityBufferLength};
    
    optional [|NegotiateContextCount != nothing && ((NegotiateContextCount as USHORT) > 0)|] array<SMB2NegotiateContext> NegotiateContextList with BinaryEncoding{Length = NegotiateContextCount as USHORT};
    
    override string ToString()
    {
        string summary = "DialectRevision: " + SMB2.DialectRevisionToText(DialectRevision) + ", Capabilities: " + EnumToStringInSummary<SMB2.SMB2NegotiateResponseCapabilities>(Capabilities);
        return summary;
    }
};

pattern SMB2NegotiateResponseSecurityMode = flags USHORT
{
    SMB2NegotiateSigningEnabled = 0x0001
        with Documentation
            {Description = "When set, indicates that security signatures are enabled on the server. The server MUST set this bit, and the client MUST return STATUS_INVALID_NETWORK_RESPONSE if the flag is missing."},
    SMB2NegotiateSigningRequired = 0x0002
        with Documentation
            {Description = "When set, indicates that security signatures are required by the server."},
    ...
}with Documentation {EmbeddedType = true};

pattern SMB2NegotiateResponseDialectRevision = enum USHORT
{
    SMB2002DialectRevisionNumber = 0x0202
        with Documentation
            {Description = "SMB 2.002 dialect revision number. Windows Vista SP1, Windows Server 2008, Windows 7, Windows Server 2008 R2, Windows 8, Windows Server 2012, Windows 8.1, Windows Server 2012 R2 support this dialect revision."},
    SMB21DialectRevisionNumber = 0x0210
        with Documentation
            {Description = "SMB 2.1 dialect revision number. Windows Vista SP1 and Windows Server 2008 do not support this dialect revision."},
    SMB30DialectRevisionNumber = 0x0300
        with Documentation
            {Description = "SMB 3.0 dialect revision number. Windows Vista SP1, Windows Server 2008, Windows 7 and Windows Server 2008 R2 do not support this dialect revision."},
    SMB302DialectRevisionNumber = 0x0302
        with Documentation
            {Description = "SMB 3.02 dialect revision number. Windows Vista SP1, Windows Server 2008, Windows 7, Windows Server 2008 R2, Windows 8, and Windows Server 2012 do not support this dialect revision."},
    SMB311DialectRevisionNumber = 0x0311
        with Documentation
            {Description = "SMB 3.1.1 dialect revision number. Windows Vista SP1, Windows Server 2008, Windows 7, Windows Server 2008 R2, Windows 8, Windows Server 2012, Windows 8.1, and Windows Server 2012 R2 do not support the SMB 3.1.1 dialect."},
    SMB2WildcardRevisionNumber = 0x02FF
        with Documentation
            {Description = "SMB2 wildcard revision number; indicates that the server supports SMB 2.1 or future dialect revisions and expects the client to send a subsequent SMB2 Negotiate request to negotiate the actual SMB 2 Protocol revision to be used. The wildcard revision number is sent only in response to a multi-protocol negotiate request with the \"SMB 2.???\" dialect string.The \"SMB 2.???\" dialect string is not supported by SMB2 clients and servers in  Windows Vista SP1 and Windows Server 2008."},
    ...
};

pattern SMB3xDialectFamily  = enum USHORT
{
    SMB30DialectRevisionNumber = 0x0300,
    SMB302DialectRevisionNumber = 0x0302,
    SMB311DialectRevisionNumber = 0x0311,
};

pattern SMB2NegotiateResponseCapabilities = flags ULONG
{
    SMB2GlobalCapDfs = 0x00000001
         with Documentation
            {Description = "When set, indicates that the server supports the Distributed File System(DFS)."},
    SMB2GlobalCapLeasing = 0x00000002
         with Documentation
             {Description = "When set, indicates that the server supports leasing. This flag is not valid for the SMB 2.002 dialect."},
     SMB2GlobalCapLargeMtu = 0x00000004
         with Documentation
             {Description = "When set, indicates that the server supports multi-credit operations. This flag is not valid for the SMB 2.002 dialect."},
     SMB2GlobalCapMultiChannel = 0x00000008
         with Documentation
             {Description = "When set, indicates that the server supports establishing multiple channels for a single session. This flag is not valid for the SMB 2.002 and SMB 2.1 dialects."},
     SMB2GlobalCapPersistentHandles = 0x00000010
         with Documentation
             {Description = "When set, indicates that the server supports persistent handles. This flag is not valid for the SMB 2.002 and SMB 2.1 dialects."},
     SMB2GlobalCapDirectoryLeasing = 0x00000020
         with Documentation
             {Description = "When set, indicates that the server supports directory leasing. This flag is not valid for the SMB 2.002 and SMB 2.1 dialects."},
     SMB2GlobalCapEncryption = 0x00000040
         with Documentation
             {Description = "When set, indicates that the server supports encryption. This flag is not valid for the SMB 23.0.2 and SMB 3.0.2.1 dialects."},
    ...
} with Documentation {EmbeddedType = true};

// 2.2.5   SMB2 SESSION_SETUP Request
type SMB2SessionSetupRequest
{
    USHORT StructureSize where ValidationCheckValue(value == 25, null, true, ReferenceType.Type, "SMB2", "StructureSize", "SMB2SessionSetupRequest", 25, value);

    SMB2SessionSetupRequestFlags Flags 
        where ValidationCheck(InRange<SMB2SessionSetupRequestFlags>(value), null, DiagnosisLevel.Error, 
            () => Format(INFRASTRUCTURE_STR_CHECK_ENUM_VALUE, ["SMB2", "Flags", INFRASTRUCTURE_STR_TYPE, "SMB2SessionSetupRequest", INFRASTRUCTURE_STR_MUST, "0x00, 0x01", Utility.DecToHexFormat(value)]));

    SMB2SessionSetupRequestSecurityMode SecurityMode;

    SMB2SessionSetupRequestCapabilities Capabilities 
        where ValidationCheckCombinationValueIncludeZero(InRange<SMB2SessionSetupRequestCapabilities>(value), null,
            true, ReferenceType.Type, "SMB2", "Capabilities", "SMB2SessionSetupRequest","0x00000001, 0x00000002, 0x00000004, 0x00000008", value);

    ULONG Channel where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Channel", "SMB2SessionSetupRequest", value);

    USHORT SecurityBufferOffset;

    USHORT SecurityBufferLength;

    UINT64 PreviousSessionId;
    
    (binary | GssapiType | NlmpMessage) Buffer with Encoding{Offset = SecurityBufferOffset - 64, Size = SecurityBufferLength};
        
    override string ToString()
    {
        string summary = "Flags: " + EnumToString<SMB2.SMB2SessionSetupRequestFlags>(Flags) + ", PreviousSessionId: " + DecToHexFormat(PreviousSessionId);
        return summary;
    }
};
       
pattern SMB2SessionSetupRequestSecurityMode = flags BYTE
{
    SMB2NegotiateSigningEnabled = 0x01
        with Documentation
            {Description = "When set, indicates that security signatures are enabled on the client. The client MUST set this bit if the SMB2_NEGOTIATE_SIGNING_REQUIRED bit is not set, and MUST NOT set this bit if the SMB2_NEGOTIATE_SIGNING_REQUIRED bit is set. The server MUST ignore this bit."},
    SMB2NegotiateSigningRequired = 0x02
        with Documentation
            {Description = "When set, indicates that security signatures are required by the client."},
    ...
} with Documentation {EmbeddedType = true};

pattern SMB2SessionSetupRequestCapabilities = flags ULONG
{
    SMB2GlobalCapDfs = 0x00000001
        with Documentation
            {Description = "When set, indicates that the client supports the Distributed File System(DFS)."},
    SMB2GlobalCapUnused1 = 0x00000002
        with Documentation
            {Description = "SHOULD be set to zero, and server MUST ignore."},
    SMB2GlobalCapUnused2 = 0x00000004
        with Documentation
            {Description = "SHOULD be set to zero and server MUST ignore."},
    SMB2GlobalCapUnused3 = 0x00000008
    ...
};

pattern SMB2SessionSetupRequestFlags = flags BYTE
{
    SMB2SessionFlagBinding = 0x01
        with Documentation
            {Description = "When set, indicates that the request is to bind an existing session to a new connection."},
    ...
};

// 2.2.6   SMB2 SESSION_SETUP Response
type SMB2SessionSetupResponse
{
    USHORT StructureSize where ValidationCheckValue(value == 9, null, true, ReferenceType.Type, "SMB2", "StructureSize", "SMB2SessionSetupResponse", 9, value);

    SMB2SessionSetupResponseSessionFlags SessionFlags;

    USHORT SecurityBufferOffset 
        where ValidationCheck(value >= 72, null, DiagnosisLevel.Error, () => "SMB2: The SecurityBufferOffset field in type SMB2SessionSetupResponse must be greater than or equal to 72, not " + Utility.DecToHexFormat(value) + ".");

    USHORT SecurityBufferLength;
    
    (binary | GssapiType | NlmpMessage) Buffer with Encoding{Offset = SecurityBufferOffset - 64, Size = SecurityBufferLength};
       
    override string ToString()
    {
        string summary = (((SessionFlags & SMB2SessionSetupResponseSessionFlags.SMB2SessionFlagEncryptData) > 0) ? ", SessionFlags: ENCRYPT_DATA" : "");
        return summary;
    }
};

pattern SMB2SessionSetupResponseSessionFlags = flags USHORT
{
   SMB2SessionFlagIsGuest = 0x0001
       with Documentation
           {Description = "If set, the client has been authenticated as a guest user."},
   SMB2SessionFlagIsNull = 0x0002
       with Documentation
           {Description = "If set, the client has been authenticated as an anonymous user."},
   SMB2SessionFlagEncryptData = 0x0004
       with Documentation
           {Description = "If set, the server requires encryption of messages on this session, per the conditions specified in section . This flag is only valid for the SMB 3.x dialect family."},
    ...
} with Documentation {EmbeddedType = true};

// 2.2.7   SMB2 LOGOFF Request
type SMB2LogoffRequest
{
    USHORT StructureSize where ValidationCheckValue(value == 4, null, true, ReferenceType.Type, "SMB2", "StructureSize", "SMB2LogoffRequest", 4, value);

    USHORT Reserved where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Reserved", "SMB2LogoffRequest", value);
};

// 2.2.8   SMB2 LOGOFF Response
type SMB2LogoffResponse
{
    USHORT StructureSize where ValidationCheckValue(value == 4, null, true, ReferenceType.Type, "SMB2", "StructureSize", "SMB2LogoffResponse", 4, value);

    USHORT Reserved where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Reserved", "SMB2LogoffResponse", value);
};

// 2.2.9   SMB2 TREE_CONNECT Request
type SMB2TreeConnectRequest[ushort DialectRevision]
{
    USHORT StructureSize where ValidationCheckValue(value == 9, null, true, ReferenceType.Type, "SMB2", "StructureSize", "SMB2TreeConnectRequest", 9, value);

    optional [|DialectRevision == SMB2NegotiateResponseDialectRevision.SMB311DialectRevisionNumber|] SMB2TreeConnectRequestFlags Flags
        where ValidationCheckCombinationValue((value == nothing) || InRange<SMB2TreeConnectRequestFlags>(value as USHORT), 
            null, true, ReferenceType.Type, "SMB2", "Flags", "SMB2TreeConnectRequest", "0x0001, 0x0002, 0x0004", value);
    optional [|DialectRevision != SMB2NegotiateResponseDialectRevision.SMB311DialectRevisionNumber|] USHORT Reserved
        where ValidationCheckReservedZero(value == nothing || value == 0, null, true, ReferenceType.Type, "SMB2", "Reserved", "SMB2TreeConnectRequest", value);

    USHORT PathOffset;

    USHORT PathLength;
            
    ([|(Flags & SMB2TreeConnectRequestFlags.SMB2_TREE_CONNECT_FLAG_EXTENSION_PRESENT) == SMB2TreeConnectRequestFlags.SMB2_TREE_CONNECT_FLAG_EXTENSION_PRESENT|] SMB2TreeConnectRequestExtension[(PathOffset - 72) as ushort, PathLength] |
     PathName[(PathOffset - 72) as ushort, PathLength]) Buffer;

    public string GetPathName()
    {
        string pathName = "";
        if (Buffer is path:PathName)
        {
            pathName = path.FullSharePathName;
        }
        else
        {
            var buffer = Buffer as SMB2TreeConnectRequestExtension;
            pathName = buffer.PathName;
        }
        return pathName;
    }
};

type PathName[ushort offset, ushort pathLength]
{
    string FullSharePathName with Encoding{Offset = offset, Size = pathLength};
}

pattern SMB2TreeConnectRequestFlags = flags USHORT
{
    SMB2_TREE_CONNECT_FLAG_CLUSTER_RECONNECT = 0x0001
        with Documentation
        {Description = "When set, indicates that the client has previously connected to the specified cluster share using the SMB dialect of the connection on which the request is received."},
    SMB2_TREE_CONNECT_FLAG_REDIRECT_TO_OWNER = 0x0002
        with Documentation
        {Description = "When set, indicates that the client can handle synchronous share redirects via a Share Redirect error context response."},
    SMB2_TREE_CONNECT_FLAG_EXTENSION_PRESENT = 0x0004
        with Documentation
        {Description = "When set, indicates that a tree connect request extension, as specified in section 2.2.9.1, is present, starting at the Buffer field of this tree connect request."},
    ...
};

// 2.2.9.1 SMB2 TREE_CONNECT Request Extension
type SMB2TreeConnectRequestExtension[ushort offset, ushort pathLength]
{
    uint TreeConnectContextOffset;
    ushort TreeConnectContextCount;
    binary Reserved with BinaryEncoding{Length = 10};
    string PathName with Encoding{Offset = offset, Size = pathLength};
    array<SMB2TreeConnectContext> TreeConnectContexts with BinaryEncoding{Length = TreeConnectContextCount} with Encoding{Offset = TreeConnectContextOffset - 72};
}

// 2.2.9.2 SMB2 TREE_CONNECT_CONTEXT Request Values
type SMB2TreeConnectContext
{
    SMB2TreeConnectRequestContextType ContextType;
    ushort DataLength;
    uint Reserved where ValidationCheckValue(value == 0, null, true, ReferenceType.Type, "SMB2", "Reserved", "SMB2TreeConnectRequestValues", 0, value);
    optional ([|ContextType == SMB2TreeConnectRequestContextType.SMB2_REMOTED_IDENTITY_TREE_CONNECT_CONTEXT_ID|] SMB2RemotedIdentityTreeConnectContext | binary)  Data with BinaryEncoding{Length = DataLength};
}

pattern SMB2TreeConnectRequestContextType = enum ushort
{
    SMB2_RESERVED_TREE_CONNECT_CONTEXT_ID = 0x0000,
    SMB2_REMOTED_IDENTITY_TREE_CONNECT_CONTEXT_ID = 0x0001,
    ...
};

// 2.2.9.2.1 SMB2_REMOTED_IDENTITY_TREE_CONNECT Context
type SMB2RemotedIdentityTreeConnectContext
{
    ushort TicketType where ValidationCheckValue(value == 1, null, true, ReferenceType.Type, "SMB2", "TicketType", "SMB2RemotedIdentityTreeConnectContext", "0x0001", value);
    ushort TicketSize;
    ushort User;
    ushort UserName;
    ushort Domain;
    ushort Groups;
    ushort RestrictedGroups;
    ushort Privileges;
    ushort PrimaryGroup;
    ushort Owner;
    ushort DefaultDacl;
    ushort DeviceGroups;
    ushort UserClaims;
    ushort DeviceClaims;
    TicketInfoType[User, UserName, Domain, Groups, RestrictedGroups, Privileges, 
                   PrimaryGroup, Owner, DefaultDacl, DeviceGroups, UserClaims, 
                   DeviceClaims] TicketInfo with BinaryEncoding{WidthForComposedType = (TicketSize - 28) * 8};
}

type TicketInfoType[ushort user, ushort userName, ushort domain, ushort groups, 
                    ushort restrictedGroups, ushort privileges, ushort primaryGroup, 
                    ushort owner, ushort defaultDacl, ushort deviceGroups, 
                    ushort userClaims, ushort deviceClaims]
{
    SidAttrData User with Encoding{Offset = user - 28};
    string UserName with BinaryEncoding{TextEncoding = TextEncoding.Unicode}, Encoding{Offset = userName - 28};
    string Domain with BinaryEncoding{TextEncoding = TextEncoding.Unicode}, Encoding{Offset = domain - 28};
    SidArrayData Groups with Encoding{Offset = groups - 28};
    SidArrayData RestrictedGroups with Encoding{Offset = restrictedGroups - 28};
    PrivilegeData Privileges with Encoding{Offset = privileges - 28};
    SidArrayData PrimaryGroup with Encoding{Offset = primaryGroup - 28};
    BlobData Owner with Encoding{Offset = owner - 28};
    BlobData DefaultDacl with Encoding{Offset = defaultDacl - 28};
    SidArrayData DeviceGroups with Encoding{Offset = deviceGroups - 28};
    BlobDataForClaims UserClaims with Encoding{Offset = userClaims - 28};
    BlobDataForClaims DeviceClaims with Encoding{Offset = deviceClaims - 28};
}

// 2.2.9.2.1.1 BLOB_DATA
type BlobData
{
    ushort BlobSize;
    binary BlobData with BinaryEncoding{Length = BlobSize};
}

type BlobDataForClaims
{
    ushort BlobSize;
    array<CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1> Data with BinaryEncoding{WidthForComposedType = BlobSize * 8};
}

// 2.2.9.2.1.2 SID_ATTR_DATA
type SidAttrData
{
    BlobData SidData;
    SIDAttrDataAttr Attr;
}

pattern SIDAttrDataAttr = flags uint
{
    SE_GROUP_ENABLED            = 0x00000004
        with Documentation {Description = "The SID is enabled for access checks. A SID without this attribute is ignored during an access check unless the SE_GROUP_USE_FOR_DENY_ONLY attribute is set."},
    SE_GROUP_ENABLED_BY_DEFAULT = 0x00000002
        with Documentation {Description = "The SID is enabled by default."},
    SE_GROUP_INTEGRITY          = 0x00000020
        with Documentation {Description = "The SID is a mandatory integrity SID."},
    SE_GROUP_INTEGRITY_ENABLED  = 0x00000040
        with Documentation {Description = "The SID is enabled for mandatory integrity checks."},
    SE_GROUP_LOGON_ID           = 0xC0000000
        with Documentation {Description = "The SID is a logon SID that identifies the logon session associated with an access token."},
    SE_GROUP_MANDATORY          = 0x00000001
        with Documentation {Description = "The SID cannot have the SE_GROUP_ENABLED attribute cleared."},
    SE_GROUP_OWNER              = 0x00000008
        with Documentation {Description = "The SID identifies a group account for which the user of the token is the owner of the group, or the SID can be assigned as the owner of the token or objects."},
    SE_GROUP_RESOURCE           = 0x20000000
        with Documentation {Description = "The SID identifies a domain-local group."},
    SE_GROUP_USE_FOR_DENY_ONLY  = 0x00000010
        with Documentation {Description = "The SID is a deny-only SID in a restricted token. If this attribute is set, SE_GROUP_ENABLED is not set, and the SID cannot be reenabled."},
    ...
};

// 2.2.9.2.1.3 SID_ARRAY_DATA
type SidArrayData
{
    ushort SidAttrCount;
    array<SidAttrData> SidAttrList with BinaryEncoding{Length = SidAttrCount};
}

// 2.2.9.2.1.4 LUID_ATTR_DATA
type LuidAttrData
{
    LUID Luid; // TDI: TD specifies this field as LUID in MS-DTYP, but set its length as 4-byte
    AttributesPattern Attr;
}

// MS-LSAD: 2.2.5.4 LSAPR_LUID_AND_ATTRIBUTES
pattern AttributesPattern = flags uint
{
    D = 0x00000001
        with Documentation {Description = "The privilege is enabled by default."},
    E = 0x00000002
        with Documentation {Description = "The privilege is enabled."},
    ...
};

// 2.2.9.2.1.5 PRIVILEGE_DATA
type PrivilegeData
{
    ushort PrivilegeCount;
    array<LuidAttrData> PrivilegeList with BinaryEncoding{Length = PrivilegeCount};
}

// 2.2.10   SMB2 TREE_CONNECT Response
type SMB2TreeConnectResponse
{
    USHORT StructureSize where ValidationCheckValue(value == 16, null, true, ReferenceType.Type, "SMB2", "StructureSize", "SMB2TreeConnectResponse", 16, value);

    SMB2TreeConnectResponseShareType ShareType
        where ValidationCheck(InRange<SMB2TreeConnectResponseShareType>(value), null, DiagnosisLevel.Error,
            () => Format(INFRASTRUCTURE_STR_CHECK_ENUM_VALUE, ["SMB2", "ShareType", INFRASTRUCTURE_STR_TYPE, "SMB2TreeConnectResponse", INFRASTRUCTURE_STR_MUST, "0x01, 0x02, 0x03", Utility.DecToHexFormat(value)]));

    BYTE Reserved where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Reserved", "SMB2TreeConnectResponse", value);

    SMB2TreeConnectResponseShareFlags ShareFlags;

    SMB2TreeConnectResponseCapabilities Capabilities;

    ([|ShareType == SMB2TreeConnectResponseShareType.SMB2ShareTypeDisk|] DirectoryAccessMask
        | FilePipePrinterAccessMask) MaximalAccess;
};

pattern SMB2TreeConnectResponseShareType = enum BYTE
{
    SMB2ShareTypeDisk = 0x01,
    SMB2ShareTypePipe = 0x02,
    SMB2ShareTypeprint = 0x03,
    ...
};

pattern SMB2ShareflagCachingType = enum BYTE
{
    SMB2ShareflagManualCaching = 0x00,
    SMB2ShareflagAutoCaching = 0x01,
    SMB2ShareflagVdoCaching = 0x02,
    SMB2ShareflagNoCaching = 0x03,
    ...
};

type SMB2TreeConnectResponseShareFlags
{
    SMB2ShareflagCachingType SMB2ShareflagCaching
        where ValidationCheck(InRange<SMB2ShareflagCachingType>(value), null, DiagnosisLevel.Error,
            () => Format(INFRASTRUCTURE_STR_CHECK_ENUM_VALUE, ["SMB2", "ShareFlagCaching", INFRASTRUCTURE_STR_TYPE, "SMB2TreeConnectResponse", INFRASTRUCTURE_STR_MUST, "0x00, 0x01, 0x02, 0x03", Utility.DecToHexFormat(value)]))
        with BinaryEncoding{Width = 4};
    byte Reserved1 with BinaryEncoding{Width = 2};
    bool SMB2ShareflagDfsRoot with BinaryEncoding{Width = 1};
    bool SMB2ShareflagDfs with BinaryEncoding{Width = 1};
   
    bool SMB2ShareflagEncryptData with BinaryEncoding{Width = 1};
    bool SMB2ShareflagEnableHashV2 with BinaryEncoding{Width = 1};
    bool SMB2ShareflagEnableHashV1 with BinaryEncoding{Width = 1};
    bool SMB2ShareflagForceLeveliiOplock with BinaryEncoding{Width = 1};
    bool SMB2ShareflagAccessBasedDirectoryEnum with BinaryEncoding{Width = 1};
    bool SMB2ShareflagAllowNamespaceCaching with BinaryEncoding{Width = 1};
    bool SMB2ShareflagForceSharedDelete with BinaryEncoding{Width = 1};
    bool SMB2ShareflagRestrictExclusiveOpens with BinaryEncoding{Width = 1};

    USHORT Reserved2;
    override string ToString()
    {
        string shareflags = "";
        bool flag = false;
        if (SMB2ShareflagDfsRoot)
        {
            shareflags += "DfsRoot";
            flag = true;
        }
        if (SMB2ShareflagDfs)
        {
            shareflags += flag ? "|Dfs" : "Dfs";
            flag = true;
        }
        if (SMB2ShareflagEncryptData)
        {
            shareflags += flag ? "|EncryptData" : "EncryptData";
            flag = true;
        }
        if (SMB2ShareflagEnableHashV2)
        {
            shareflags += flag ? "|EnableHashV2" : "EnableHashV2";
            flag = true;
        }
        if (SMB2ShareflagEnableHashV1)
        {
            shareflags += flag ? "|EnableHashV1" : "EnableHashV1";
            flag = true;
        }
        if (SMB2ShareflagForceLeveliiOplock)
        {
            shareflags += flag ? "|ForceLeveliiOplock" : "ForceLeveliiOplock";
            flag = true;
        }
        if (SMB2ShareflagAccessBasedDirectoryEnum)
        {
            shareflags += flag ? "|AccessBasedDirectoryEnum" : "AccessBasedDirectoryEnum";
            flag = true;
        }
        if (SMB2ShareflagAllowNamespaceCaching)
        {
            shareflags += flag ? "|AllowNamespaceCaching" : "AllowNamespaceCaching";
            flag = true;
        }
        if (SMB2ShareflagForceSharedDelete)
        {
            shareflags += flag ? "|ForceSharedDelete" : "ForceSharedDelete";
            flag = true;
        }
        if (SMB2ShareflagRestrictExclusiveOpens)
        {
            shareflags += flag ? "|RestrictExclusiveOpens" : "RestrictExclusiveOpens";
            flag = true;
        }
        return shareflags;
    }
};
 
pattern SMB2TreeConnectResponseCapabilities = flags ULONG
{
    SMB2_SHARE_CAP_DFS = 0x00000008
        with Documentation
        {Description = "The specified share is present in a DFS tree structure. The server MUST set the SMB2_SHARE_CAP_DFS bit in the Capabilities field if the per-share property Share.IsDfs is TRUE."},
    SMB2_SHARE_CAP_CONTINUOUS_AVAILABILITY = 0x00000010
        with Documentation
        {Description = "The specified share is continuously available. This flag is only valid for the SMB 3.x dialect family."},
    SMB2_SHARE_CAP_SCALEOUT = 0x00000020
        with Documentation
            {Description = "The specified share is present on a server configuration which facilitates faster recovery of durable handles. This flag is only valid for the SMB 3.x dialect family."},
    SMB2_SHARE_CAP_CLUSTER = 0x00000040
        with Documentation
            {Description = "The specified share is present on a server configuration which provides monitoring of the availability of share through the Witness service specified in [MS-SWN]. This flag is only valid for the SMB 3.x dialect family."},
    SMB2_SHARE_CAP_ASYMMETRIC = 0x00000080
       with Documentation
            {Description = "The specified share is present on a server configuration that allows dynamic changes in the ownership of the share. This flag is only valid for the SMB 3.02 dialect."},
    SMB2_SHARE_CAP_REDIRECT_TO_OWNER = 0x00000100
       with Documentation
            {Description = "The specified share is present on a server configuration that supports synchronous share level redirection via a Share Redirect error context response. This flag is not valid for SMB 2.0.2, 2.1, 3.0, and 3.0.2 dialects."}
    ...
} with Documentation {EmbeddedType = true};

// 2.2.11   SMB2 TREE_DISCONNECT Request
type SMB2TreeDisconnectRequest
{
    USHORT StructureSize where ValidationCheckValue(value == 4, null, true, ReferenceType.Type, "SMB2", "StructureSize", "SMB2TreeDisconnectRequest", 4, value);

    USHORT Reserved where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Reserved", "SMB2TreeDisconnectRequest", value);
};

// 2.2.12   SMB2 TREE_DISCONNECT Response
type SMB2TreeDisconnectResponse
{
    USHORT StructureSize where ValidationCheckValue(value == 4, null, true, ReferenceType.Type, "SMB2", "StructureSize", "SMB2TreeDisconnectResponse", 4, value);

    USHORT Reserved where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Reserved", "SMB2TreeDisconnectResponse", value);
};

// 2.2.13   SMB2 CREATE Request
type SMB2CreateRequest[bool IsDirectory]
{
    USHORT StructureSize where ValidationCheckValue(value == 57, null, true, ReferenceType.Type, "SMB2", "StructureSize", "SMB2CreateRequest", 57, value);

    BYTE SecurityFlags where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "SecurityFlags", "SMB2CreateRequest", value);

    SMB2CreateRequestRequestedOplockLevel RequestedOplockLevel
        where ValidationCheck(InRange<SMB2CreateRequestRequestedOplockLevel>(value), null, DiagnosisLevel.Error,
            () => Format(INFRASTRUCTURE_STR_CHECK_ENUM_VALUE, ["SMB2", "RequestedOplockLevel", INFRASTRUCTURE_STR_TYPE, "SMB2CreateRequest", INFRASTRUCTURE_STR_MUST, "0x00, 0x01, 0x08, 0x09, 0xFF", Utility.DecToHexFormat(value)]));

    SMB2CreateRequestImpersonationLevel ImpersonationLevel
        where ValidationCheck(InRange<SMB2CreateRequestImpersonationLevel>(value), null, DiagnosisLevel.Error,
            () => Format(INFRASTRUCTURE_STR_CHECK_ENUM_VALUE, ["SMB2", "ImpersonationLevel", INFRASTRUCTURE_STR_TYPE, "SMB2CreateRequest", INFRASTRUCTURE_STR_MUST, "0x00000000, 0x00000001, 0x00000002, 0x00000003", Utility.DecToHexFormat(value)]));

    UINT64 SmbCreateFlags where ValidationCheckReservedZero(value == 0, null, false, ReferenceType.Type, "SMB2", "SmbCreateFlags", "SMB2CreateRequest", value);

    UINT64 Reserved;

    ([|IsDirectory|] DirectoryAccessMask
        | FilePipePrinterAccessMask) DesiredAccess;
    
    FileAttributes FileAttributes;

    SMB2CreateRequestShareAccess ShareAccess;

    SMB2CreateRequestCreateDisposition CreateDisposition
        where ValidationCheck(InRange<SMB2CreateRequestCreateDisposition>(value), null, DiagnosisLevel.Error,
            () => Format(INFRASTRUCTURE_STR_CHECK_VALUE_IN_RANGE, ["SMB2", "CreateDisposition", INFRASTRUCTURE_STR_TYPE, "SMB2CreateRequest", INFRASTRUCTURE_STR_MUST, "0x00000000", "0x00000005", Utility.DecToHexFormat(value)]));

    SMB2CreateRequestCreateOptions CreateOptions
        where ValidationCheck(InRange<SMB2CreateRequestCreateOptions>(value), null, 
            "SMB2: For CreateOptions in type SMB2CreateRequest, all bits that are not specified in the table in [MS-SMB2] should be zero, because they are reserved by Windows server implementations.");

    USHORT NameOffset;

    USHORT NameLength;

    ULONG CreateContextsOffset;

    ULONG CreateContextsLength;

    SMB2CreateRequestBuffer[NameOffset, NameLength, CreateContextsOffset, CreateContextsLength] Buffer 
        with BinaryEncoding{WidthForComposedType = (BufferEnd() - 120) * 8};

    uint BufferEnd()
    {
        if (CreateContextsOffset == 0)
        {
            return (NameOffset + NameLength) as uint;
        }

        return Max(NameOffset + NameLength, CreateContextsOffset + CreateContextsLength) as uint;
    }

    override string ToString()
    {
        string summary = "Da(";
        if (DesiredAccess is filePipePrinterAccessMask:FilePipePrinterAccessMask)
        {
            summary += (filePipePrinterAccessMask.FilePipePrinterAccessMaskFlags & 0x00000001) > 0 ? "R" : "";     // FILE_READ_DATA (LIST_DIRECTORY)
            summary += (filePipePrinterAccessMask.FilePipePrinterAccessMaskFlags & 0x00000002) > 0 ? "W" : "";     // FILE_WRITE_DATA (ADD_FILE)
            summary += (filePipePrinterAccessMask.FilePipePrinterAccessMaskFlags & 0x00000004) > 0 ? "A" : "";     // FILE_APPEND_DATA (ADD_SUBDIRECTORY)
            summary += (filePipePrinterAccessMask.FilePipePrinterAccessMaskFlags & 0x00000008) > 0 ? "E" : "";     // FILE_READ_EA
            summary += (filePipePrinterAccessMask.FilePipePrinterAccessMaskFlags & 0x00000010) > 0 ? "e" : "";     // FILE_WRITE_eA
            summary += (filePipePrinterAccessMask.FilePipePrinterAccessMaskFlags & 0x00000020) > 0 ? "X" : "";     // FILE_EXECUTE (TRAVERSE)
            summary += (filePipePrinterAccessMask.FilePipePrinterAccessMaskFlags & 0x00000040) > 0 ? "C" : "";     // FILE_DELETE_CHILD
            summary += (filePipePrinterAccessMask.FilePipePrinterAccessMaskFlags & 0x00000080) > 0 ? "r" : "";     // FILE_rEAD_ATTRIBUTES
            summary += (filePipePrinterAccessMask.FilePipePrinterAccessMaskFlags & 0x00000100) > 0 ? "w" : "";     // FILE_wRITE_ATTRIBUTES
            summary += (filePipePrinterAccessMask.FilePipePrinterAccessMaskFlags & 0x00010000) > 0 ? "D" : "";     // DELETE
            summary += (filePipePrinterAccessMask.FilePipePrinterAccessMaskFlags & 0x00020000) > 0 ? "c" : "";     // READ_cONTROL
            summary += (filePipePrinterAccessMask.FilePipePrinterAccessMaskFlags & 0x00040000) > 0 ? "d" : "";     // WRITE_dAC
            summary += (filePipePrinterAccessMask.FilePipePrinterAccessMaskFlags & 0x00080000) > 0 ? "o" : "";     // WRITE_oWNER
            summary += (filePipePrinterAccessMask.FilePipePrinterAccessMaskFlags & 0x00100000) > 0 ? "S" : "";     // SYNCHRONIZE
            summary += (filePipePrinterAccessMask.FilePipePrinterAccessMaskFlags & 0x01000000) > 0 ? "s" : "";     // ACCESS_sYSTEM_sECURITY
            summary += (filePipePrinterAccessMask.FilePipePrinterAccessMaskFlags & 0x02000000) > 0 ? "M" : "";     // MAXIMUM_ALLOWED
        }
        else if (DesiredAccess is directoryAccessMask:DirectoryAccessMask)
        {
            summary += EnumToStringInSummary<SMB2.DirectoryAccessMaskDirectoryAccessMask>(directoryAccessMask.DirectoryAccessMaskValue);
        }
        summary += "), Sh(";
        summary += (ShareAccess & SMB2CreateRequestShareAccess.FileShareRead) > 0 ? "R" : "";
        summary += (ShareAccess & SMB2CreateRequestShareAccess.FileShareWrite) > 0 ? "W" : "";
        summary += (ShareAccess & SMB2CreateRequestShareAccess.FileShareDelete) > 0 ? "D" : "";
        summary += "), ";
        
        summary += "CreateOptions = " + Utility.DecToHexFormat(CreateOptions) + ", ";
        
        if (Buffer.CreateContextList != nothing)
        {
            var buffer = Buffer.CreateContextList as array<SMB2CreateContextRequest>;
            int count = buffer.Count;
            for (int i = 0; i < count; i++)
            {
                if (i != count - 1)
                {
                    summary += buffer[i].Buffer.ToString() + "+";
                }
                else
                {
                    summary += buffer[i].Buffer.ToString();
                }
            }
        }
        return summary;
    }
};

type SMB2CreateRequestBuffer[ushort NameOffset, ushort NameLength, uint CreateContextsOffset, uint CreateContextsLength]
{
    optional [|NameLength > 0|] string Name with Encoding{Offset = (NameLength == 0 ? 0 : (NameOffset - 120)), Size = NameLength}; // UTF16
    optional [|CreateContextsOffset > 0|] array<SMB2CreateContextRequest> CreateContextList
        where ValidationCheck(GetLastNext() == 0, null, DiagnosisLevel.Error, "SMB2: The Next field in the last entry of SMB2CreateContextRequest must be zero, not " + (GetLastNext() as string) + ".")
        with Encoding{Offset = (CreateContextsOffset == 0 ? 0 : (CreateContextsOffset - 120)), Size = (CreateContextsOffset == 0 ? 0 : CreateContextsLength)};
    
    uint GetLastNext()
    {
        if (CreateContextList != nothing)
        {
            var buffer = CreateContextList as array<SMB2CreateContextRequest>;
            if (buffer.Count > 0)
            {
                return buffer[buffer.Count - 1].Next;
            }
        }
        return 0;
    }
}

pattern SMB2CreateRequestCreateOptions = flags ULONG
{
    FileDirectoryFile = 0x00000001
        with Documentation
            {Description = "The file being created or opened is a directory file. With this flag, the CreateDisposition field MUST be set to FILE_CREATE, FILE_OPEN_IF, or FILE_OPEN. With this flag, only the following CreateOptions values are valid: FILE_WRITE_THROUGH, FILE_OPEN_FOR_BACKUP_INTENT, FILE_DELETE_ON_CLOSE, and FILE_OPEN_REPARSE_POINT. If the file being created or opened already exists and is not a directory file and FILE_CREATE is specified in the CreateDisposition field, then the server MUST fail the request with STATUS_OBJECT_NAME_COLLISION. If the file being created or opened already exists and is not a directory file and FILE_CREATE is not specified in the CreateDisposition field, then the server MUST fail the request with STATUS_NOT_A_DIRECTORY. The server MUST fail an invalid CreateDisposition field or an invalid combination of CreateOptions flags with STATUS_INVALID_PARAMETER."},
    FileWriteThrough = 0x00000002
        with Documentation
            {Description = "The server MUST propagate writes to this open to persistent storage before returning success to the client on write operations."},
    FileSequentialOnly = 0x00000004
        with Documentation
            {Description = "This indicates that the application intends to read or write at sequential offsets using this handle, so the server SHOULD optimize for sequential access. However, the server MUST accept any access pattern. This flag value is incompatible with the FILE_RANDOM_ACCESS value."},
    FileNoIntermediateBuffering = 0x00000008
        with Documentation
            {Description = "The server or underlying object store SHOULD NOT cache data at intermediate layers and SHOULD allow it to flow through to persistent storage."},
    FileSynchronousIoAlert = 0x00000010
        with Documentation
            {Description = "This bit SHOULD be set to 0 and MUST be ignored by the server.windows SMB2 clients do not initialize this bit. The bit contains the value specified by the caller when requesting the open."},
    FileSynchronousIoNonalert = 0x00000020
        with Documentation
            {Description = "This bit SHOULD be set to 0 and MUST be ignored by the server.windows SMB2 clients do not initialize this bit. The bit contains the value specified by the caller when requesting the open."},
    FileNonDirectoryFile = 0x00000040
        with Documentation
            {Description = "The file being opened MUST NOT be a directory file or the server MUST fail the request with STATUS_FILE_IS_A_DIRECTORY. This flag MUST NOT be used with FILE_DIRECTORY_FILE or the server MUST fail the request with STATUS_INVALID_PARAMETER."},
    FileCompleteIfOplocked = 0x00000100
        with Documentation
            {Description = "This bit SHOULD be set to 0 and MUST be ignored by the server.windows SMB2 clients do not initialize this bit. The bit contains the value specified by the caller when requesting the open."},
    FileNoEaKnowledge = 0x00000200
        with Documentation
            {Description = "The caller does not understand how to handle extended attributes. If the request includes an SMB2_CREATE_EA_BUFFER create context, then the server MUST fail this request with STATUS_ACCESS_DENIED. If extended attributes with the FILE_NEED_EA flag(see [MS-FSCC] section ) set are associated with the file being opened, then the server MUST fail this request with STATUS_ACCESS_DENIED."},
    FileRandomAccess = 0x00000800
        with Documentation
            {Description = "This indicates that the application intends to read or write at random offsets using this handle, so the server SHOULD optimize for random access. However, the server MUST accept any access pattern. This flag value is incompatible with the FILE_SEQUENTIAL_ONLY value. If both FILE_RANDOM_ACCESS and FILE_SEQUENTIAL_ONLY are set, then FILE_SEQUENTIAL_ONLY is ignored."},
    FileDeleteOnClose = 0x00001000
        with Documentation
            {Description = "The file MUST be automatically deleted when the last open request on this file is closed. When this option is set, the DesiredAccess field MUST include the DELETE flag. This option is often used for temporary files."},
    FileOpenByFileID = 0x00002000
        with Documentation
            {Description = "This bit SHOULD be set to 0 and the server MUST fail the request with a STATUS_NOT_SUPPORTED error if this bit is set.windows SMB2 clients do not initialize this bit. The bit contains the value specified by the caller when requesting the open."},
    FileOpenForBackupIntent = 0x00004000
        with Documentation
            {Description = "The file is being opened for backup intent. That is, it is being opened or created for the purposes of either a backup or a restore operation. The server MAY check to ensure that the caller is capable of overriding whatever security checks have been placed on the file to allow a backup or restore operation to occur. The server MAY check for access rights to the file before checking the DesiredAccess field."},
    FileNoCompression = 0x00008000
        with Documentation 
            {Description = "The file cannot be compressed. This bit is ignored when FILE_DIRECTORY_FILE is set in CreateOptions."},
    FileOpenRemoteInstance = 0x00000400
        with Documentation
            {Description = "This bit SHOULD be set to 0 and MUST be ignored by the server."},
    FileOpenRequiringOplock = 0x00010000
        with Documentation
            {Description = "This bit SHOULD be set to 0 and MUST be ignored by the server."},
    FileDisallowExclusive = 0x00020000
        with Documentation
            {Description = "This bit SHOULD be set to 0 and MUST be ignored by the server."},
    FileReserveOpfilter = 0x00100000
        with Documentation
            {Description = "This bit SHOULD be set to 0 and the server MUST fail the request with a STATUS_NOT_SUPPORTED error if this bit is set.windows SMB2 clients do not initialize this bit. The bit contains the value specified by the caller when requesting the open."},
    FileOpenReparsePoint = 0x00200000
        with Documentation
            {Description = "If the file or directory being opened is a reparse point, open the reparse point itself rather than the target that the reparse point references."},
    FileOpenNoRecall = 0x00400000
        with Documentation
            {Description = "In an HSM(Hierarchical Storage Management) environment, this flag means the file SHOULD NOT be recalled from tertiary storage such as tape. The recall can take several minutes. The caller can specify this flag to avoid those delays."},
    FileOpenForFreeSpaceQuery = 0x00800000
        with Documentation
            {Description = "Open file to query for free space. The client SHOULD set this to 0 and the server MUST ignore it.windows_vista and windows_server_2008-based clients will set this bit when it is requested by the application.windows_vista, windows_server_2008, and windows_7-based clients will set this bit when it is requested by the application."}
    ...
};

pattern SMB2CreateRequestRequestedOplockLevel = enum BYTE
{
    SMB2OplockLevelNone = 0x00
        with Documentation {Description = "No oplock is requested."},
    SMB2OplockLevelII = 0x01
        with Documentation {Description = "A level II oplock is requested."},
    SMB2OplockLevelExclusive = 0x08
        with Documentation {Description = "An exclusive oplock is requested."},
    SMB2OplockLevelBatch = 0x09
        with Documentation {Description = "A batch oplock is requested."},
    SMB2OplockLevelLease = 0xFF
        with Documentation
            {Description = "A lease is requested. If set, the request packet MUST contain an SMB2_CREATE_REQUEST_LEASE create context. This value is only valid for the SMB 2.1 dialect."},
    ...
};

pattern SMB2CreateRequestImpersonationLevel = enum ULONG
{
    Anonymous = 0x00000000
        with Documentation
            {Description = "The application-requested impersonation level is Anonymous."},
    Identification = 0x00000001
        with Documentation
            {Description = "The application-requested impersonation level is Identification."},
    Impersonation = 0x00000002
        with Documentation
            {Description = "The application-requested impersonation level is Impersonation."},
    Delegate = 0x00000003
        with Documentation
            {Description = "The application-requested impersonation level is Delegate."},
    ...
};

pattern SMB2CreateRequestShareAccess = flags ULONG
{
    FileShareRead = 0x00000001
         with Documentation
             {Description = "When set, indicates that other opens are allowed to read this file while this open is present. This bit MUST NOT be set for a named pipe or a printer file. Each open creates a new instance of a named pipe. Likewise, opening a printer file always creates a new file."},
    FileShareWrite = 0x00000002
         with Documentation
             {Description = "When set, indicates that other opens are allowed to write this file while this open is present. This bit MUST NOT be set for a named pipe or a printer file. Each open creates a new instance of a named pipe. Likewise, opening a printer file always creates a new file."},
    FileShareDelete = 0x00000004
         with Documentation
             {Description = "When set, indicates that other opens are allowed to delete or rename this file while this open is present. This bit MUST NOT be set for a named pipe or a printer file. Each open creates a new instance of a named pipe. Likewise, opening a printer file always creates a new file."},
    ...
}with Documentation {EmbeddedType = true};
 
pattern SMB2CreateRequestCreateDisposition = enum ULONG
{
    FileSupersede = 0x00000000
        with Documentation
            {Description = "If the file already exists, supersede it. Otherwise, create the file. This value SHOULD NOT be used for a printer object.When opening a printer object, windows-based servers ignore this value."},
    FileOpen = 0x00000001
        with Documentation
            {Description = "If the file already exists, return success; otherwise, fail the operation. MUST NOT be used for a printer object."},
    FileCreate = 0x00000002
        with Documentation
            {Description = "If the file already exists, fail the operation; otherwise, create the file."},
    FileOpenIf = 0x00000003
        with Documentation
            {Description = "Open the file if it already exists; otherwise, create the file. This value SHOULD NOT be used for a printer object.When opening a printer object, windows-based servers ignore this value."},
    FileOverWrite = 0x00000004
        with Documentation
            {Description = "Overwrite the file if it already exists; otherwise, fail the operation. MUST NOT be used for a printer object."},
    FileOverWriteIf = 0x00000005
        with Documentation
            {Description = "Overwrite the file if it already exists; otherwise, create the file. This value SHOULD NOT be used for a printer object.When opening a printer object, windows-based servers ignore this value."},
    ...
};

// 2.2.13.1.1   File_Pipe_Printer_Access_Mask
type FilePipePrinterAccessMask
{
    FilePipePrinterAccessMaskFilePipePrinterAccessMask FilePipePrinterAccessMaskFlags
        where ValidationCheck(InRange<FilePipePrinterAccessMaskFilePipePrinterAccessMask>(value), null, DiagnosisLevel.Error, 
            () => Format(INFRASTRUCTURE_STR_CHECK_COMBINATION_VALUE_TOO_MANY_ITEMS, ["SMB2", "FilePipePrinterAccessMaskFlags", "type", "FilePipePrinterAccessMask", "File_Pipe_Printer_Access_Mask", "[MS-SMB2]"]));
};

// 2.2.13.1.2   Directory_Access_Mask
type DirectoryAccessMask
{
    DirectoryAccessMaskDirectoryAccessMask DirectoryAccessMaskValue
        where ValidationCheck(InRange<DirectoryAccessMaskDirectoryAccessMask>(value), null, DiagnosisLevel.Error, 
            () => Format(INFRASTRUCTURE_STR_CHECK_COMBINATION_VALUE_TOO_MANY_ITEMS, ["SMB2", "FilePipePrinterAccessMaskFlags", "type", "FilePipePrinterAccessMask", "Directory_Access_Mask", "[MS-SMB2]"]));
};

pattern FilePipePrinterAccessMaskFilePipePrinterAccessMask = flags ULONG
{
    FileReadData = 0x00000001
        with Documentation
            {Description = "This value indicates the right to read data from the file or named pipe."},
    FileWriteData = 0x00000002
        with Documentation
            {Description = "This value indicates the right to write data into the file or named pipe beyond the end of the file."},
    FileAppendData = 0x00000004
        with Documentation
            {Description = "This value indicates the right to append data into the file or named pipe."},
    FileReadEa = 0x00000008
        with Documentation
            {Description = "This value indicates the right to read the extended attributes of the file or named pipe."},
    FileWriteEa = 0x00000010
        with Documentation
            {Description = "This value indicates the right to write or change the extended attributes to the file or named pipe."},
    FileExecute = 0x00000020
        with Documentation
            {Description = "This value indicates the right to execute the file."},
    FileDeleteChild = 0x00000040
        with Documentation
            {Description = "This value indicates the right to delete entries within a directory."},
    FileReadAttributes = 0x00000080
        with Documentation
            {Description = "This value indicates the right to read the attributes of the file."},
    FileWriteAttributes = 0x00000100
        with Documentation
            {Description = "This value indicates the right to change the attributes of the file."},
    Delete = 0x00010000
        with Documentation
            {Description = "This value indicates the right to delete the file."},
    ReadControl = 0x00020000
        with Documentation
            {Description = "This value indicates the right to read the security descriptor for the file or named pipe."},
    WriteDac = 0x00040000
        with Documentation
            {Description = "This value indicates the right to change the discretionary access control list(DACL) in the security descriptor for the file or named pipe. For the DACL data structure, see ACL in [MS-DTYP]."},
    WriteOwner = 0x00080000
        with Documentation
            {Description = "This value indicates the right to change the owner in the security descriptor for the file or named pipe."},
    Synchronize = 0x00100000
        with Documentation
            {Description = "SMB2 clients set this flag to any value.windows sets this flag to the value passed in by the higher-level application."},
    AccessSystemSecurity = 0x01000000
        with Documentation
            {Description = "This value indicates the right to read or change the system access control list(SACL) in the security descriptor for the file or named pipe. For the SACL data structure, see ACL in [MS-DTYP].windows fails the create request with STATUS_ACCESS_DENIED if the caller does not have the SeSecurityPrivilege, as specified in [MS-LSAD] section ."},
    MaximumAllowed = 0x02000000
        with Documentation
            {Description = "This value indicates that the client is requesting an open to the file with the highest level of access the client has on this file. If no access is granted for the client on this file, the server MUST fail the open with STATUS_ACCESS_DENIED."},
    GenericAll = 0x10000000
        with Documentation
            {Description = "This value indicates a request for all the access flags that are previously listed except MAXIMUM_ALLOWED and ACCESS_SYSTEM_SECURITY."},
    GenericExecute = 0x20000000
        with Documentation
            {Description = "This value indicates a request for the following combination of access flags listed above: FILE_READ_ATTRIBUTES| FILE_EXECUTE| SyncHRONIZE| READ_CONTROL."},
    GenericWrite = 0x40000000
        with Documentation
            {Description = "This value indicates a request for the following combination of access flags listed above: FILE_WRITE_DATA| FILE_APPEND_DATA| FILE_WRITE_ATTRIBUTES| FILE_WRITE_EA| SyncHRONIZE| READ_CONTROL."},
    GenericRead = 0x80000000
        with Documentation
            {Description = "This value indicates a request for the following combination of access flags listed above: FILE_READ_DATA| FILE_READ_ATTRIBUTES| FILE_READ_EA| SyncHRONIZE| READ_CONTROL."}
    ...
};

// 2.2.13.2   SMB2_CREATE_CONTEXT Request Values
type SMB2CreateContextRequest
{
    ULONG Next;

    USHORT NameOffset;

    USHORT NameLength;

    USHORT Reserved where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Reserved", "SMB2CreateContextRequest", value);

    USHORT DataOffset;

    ULONG DataLength;

    SMB2CreateContextRequestBuffer[NameOffset, NameLength, DataOffset, DataLength] Buffer
      with BinaryEncoding{WidthForComposedType = (CreateContextEnd() - 16) * 8};

    optional [|Next > CreateContextEnd()|] array<byte> TrailPadding with BinaryEncoding{Length = Next - CreateContextEnd()};
    
    uint CreateContextEnd()
    {
        if (DataLength == 0)
        {
            return (NameOffset + NameLength) as uint;
        }

        return Max(NameOffset + NameLength, DataOffset + DataLength) as uint;
    }
    
    override string ToString()
    {
        return Buffer.ToString();
    }
};

const binary SMB2_CREATE_APP_INSTANCE_ID = $[45BCA66AEFA7F74A9008FA462E144D74];
const binary SMB2_CREATE_APP_INSTANCE_VERSION = $[B982D0B73B56074FA07B524A8116A010];
const binary SVHDX_OPEN_DEVICE_CONTEXT = $[9CCBCF9E04C1E643980E158DA1F6EC83];

type SMB2CreateContextRequestBuffer[ushort NameOffset, ushort NameLength, ushort DataOffset, uint DataLength]
{
    ([|NameLength == 16 && (value == SMB2_CREATE_APP_INSTANCE_ID || value == SMB2_CREATE_APP_INSTANCE_VERSION || value == SVHDX_OPEN_DEVICE_CONTEXT)|] binary 
        | string) Name 
        where ValidationCheck(((value is string && InRange<SMB2CreateContextRequestValuesName>(value as string))
                            || value == SMB2_CREATE_APP_INSTANCE_ID
                            || value == SMB2_CREATE_APP_INSTANCE_VERSION
                            || value == SVHDX_OPEN_DEVICE_CONTEXT
                            || (value.ToString()).Count == 0), null, DiagnosisLevel.Error,
                            "SMB2: The Name field in type SMB2CreateContextRequestBuffer must be one of the values provided in pattern SMB2CreateContextRequestValuesName.") 
        with BinaryEncoding{TextEncoding = TextEncoding.ASCII}, DisplayInfo{ToText = CreateContextNameToText},
            Encoding{Offset = NameOffset - 16, Size = NameLength};
    
    ([|DataLength == 0|] Empty
     | [|Name == SMB2CreateContextRequestValuesName.SMB2CreateEaBuffer|] FileFullEaInformation
     | [|Name == SMB2CreateContextRequestValuesName.SMB2CreateSdBuffer|] SECURITY_DESCRIPTOR_NonRpc
     | [|Name == SMB2CreateContextRequestValuesName.SMB2CreateDurableHandleRequest|] SMB2CreateDurableHandleRequest
     | [|Name == SMB2CreateContextRequestValuesName.SMB2CreateDurableHandleRequestV2|] SMB2CreateDurableHandleRequestV2
     | [|Name == SMB2CreateContextRequestValuesName.SMB2CreateDurableHandleReconnect|] SMB2CreateDurableHandleReconnect
     | [|Name == SMB2CreateContextRequestValuesName.SMB2CreateDurableHandleReconnectV2|] SMB2CreateDurableHandleReconnectV2
     | [|Name == SMB2CreateContextRequestValuesName.SMB2CreateQueryMaximalAccessRequest|] SMB2CreateQueryMaximalAccessRequest
     | [|Name == SMB2CreateContextRequestValuesName.SMB2CreateAllocationSize|] SMB2CreateAllocationSize
     | [|Name == SMB2CreateContextRequestValuesName.SMB2CreateTimewarpToken|] SMB2CreateTimewarpToken
     | [|Name == SMB2CreateContextRequestValuesName.SMB2CreateRequestLease && DataLength == 32|] SMB2CreateRequestLease
     | [|Name == SMB2CreateContextRequestValuesName.SMB2CreateRequestLease && DataLength >= 52|] SMB2CreateRequestLeaseV2
     | [|Name == SMB2_CREATE_APP_INSTANCE_ID|] SMB2CreateAppInstanceId
     | [|Name == SMB2_CREATE_APP_INSTANCE_VERSION|] SMB2CreateAppInstanceVersion
     | binary) Data with Encoding{Offset = (DataLength == 0 ? 0 : (DataOffset - 16)), Size = DataLength};
     
    override string ToString()
    {
        string summary = "";
        if (Name == SMB2_CREATE_APP_INSTANCE_ID)
        {
            summary += "AppInstanceID";
        }
        else if (Name == SMB2_CREATE_APP_INSTANCE_VERSION)
        {
            summary += "AppInstanceVersion";
        }
        else if (Name == SVHDX_OPEN_DEVICE_CONTEXT)
        {
            summary += "SvhdxOpenDeviceContext";
        }
        else
        {
            summary += Name as string;
        }
        switch (Data)
        {
            case dh2q:SMB2CreateDurableHandleRequestV2 =>
               summary += (dh2q.Flags & 0x00000002) > 0 ? "(P)" : "";
            case dh2c:SMB2CreateDurableHandleReconnectV2 =>
               summary += (dh2c.Flags & 0x00000002) > 0 ? "(P)" : "";
            case rqls:SMB2CreateRequestLease =>
               summary += "(" + SMB2LeaseStateToText(rqls.LeaseState) + ")";
            case rqls2:SMB2CreateRequestLeaseV2 =>
               summary += "(" + SMB2LeaseStateToText(rqls2.LeaseState);
               summary += (rqls2.Flags & 0x00000002) > 0 ? "-PK)" : ")";
        }
        return summary;
    }
}
     
pattern SMB2CreateContextRequestValuesName = enum string
{
    SMB2CreateEaBuffer = "ExtA",
    SMB2CreateSdBuffer = "SecD",
    SMB2CreateDurableHandleRequest = "DHnQ",
    SMB2CreateDurableHandleReconnect = "DHnC",
    SMB2CreateAllocationSize = "AlSi",
    SMB2CreateQueryMaximalAccessRequest = "MxAc",
    SMB2CreateTimewarpToken = "TWrp",
    SMB2CreateQueryOnDiskId = "QFid",
    SMB2CreateRequestLease = "RqLs",
    SMB2CreateDurableHandleRequestV2 = "DH2Q",
    SMB2CreateDurableHandleReconnectV2 = "DH2C",
    ...
};

// 2.2.13.2.3   SMB2_CREATE_DURABLE_HANDLE_REQUEST
type SMB2CreateDurableHandleRequest
{
    binary DurableRequest where ValidationCheckReservedZero(value == $[00000000000000000000000000000000], null, true, ReferenceType.Type, "SMB2", "DurableRequest", "SMB2CreateDurableHandleRequest", value.ToString()) with BinaryEncoding{Length = 16};
};

// 2.2.13.2.4   SMB2_CREATE_DURABLE_HANDLE_RECONNECT
type SMB2CreateDurableHandleReconnect
{
    SMB2Fileid Data;
};

// 2.2.13.2.5   SMB2_CREATE_QUERY_MAXIMAL_ACCESS_REQUEST
type SMB2CreateQueryMaximalAccessRequest
{
    FILETIME Timestamp;
};

// 2.2.13.2.6   SMB2_CREATE_ALLOCATION_SIZE
type SMB2CreateAllocationSize
{
    UINT64 AllocationSize;
};

// 2.2.13.2.7   SMB2_CREATE_TIMEWARP_TOKEN
type SMB2CreateTimewarpToken
{
    FILETIME Timestamp;
};

pattern SMB2CreateRequestLeaseLeaseState = flags ULONG
{
   SMB2LeaseReadCaching = 0x01
       with Documentation {Description = "A read caching lease is requested."},
   SMB2LeaseHandleCaching = 0x02
       with Documentation {Description = "A handle caching lease is requested."},
   SMB2LeaseWriteCaching = 0x04
       with Documentation {Description = "A write caching lease is requested."},
    ...
} with Documentation {EmbeddedType = true};

// 2.2.13.2.8   SMB2_CREATE_REQUEST_LEASE
type SMB2CreateRequestLease
{
    GUID LeaseKey;

    SMB2CreateRequestLeaseLeaseState LeaseState with DisplayInfo{ToText = SMB2LeaseStateToFullText};

    ULONG LeaseFlags where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "LeaseFlags", "SMB2CreateRequestLease", value);

    UINT64 LeaseDuration where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "LeaseDuration", "SMB2CreateRequestLease", value);
};

// 2.2.13.2.10   SMB2_CREATE_REQUEST_LEASE_V2
type SMB2CreateRequestLeaseV2
{
    GUID LeaseKey;

    SMB2CreateRequestLeaseV2LeaseState LeaseState;

    SMB2CreateRequestLeaseV2Flags Flags;

    UINT64 LeaseDuration where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "LeaseDuration", "SMB2CreateRequestLeaseV2", value);

    GUID ParentLeaseKey;

    USHORT Epoch;

    USHORT Reserved where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Reserved", "SMB2CreateRequestLeaseV2", value);
};

pattern SMB2CreateRequestLeaseV2LeaseState = flags ULONG
{
    SMB2LeaseReadCaching = 0x00000001
        with Documentation
            {Description = "A read caching lease is requested."},
    SMB2LeaseHandleCaching = 0x00000002
        with Documentation
            {Description = "A handle caching lease is requested."},
    SMB2LeaseWriteCaching = 0x00000004
        with Documentation
            {Description = "A write caching lease is requested."}
    ...
} with Documentation {EmbeddedType = true};

pattern SMB2CreateRequestLeaseV2Flags = flags ULONG
{
    SMB2LeaseFlagParentLeaseKeySet = 0x00000004
        with Documentation
            {Description = "When set, indicates that the ParentLeaseKey is set."}
    ...
} with Documentation {EmbeddedType = true};

// 2.2.13.2.11   SMB2_CREATE_DURABLE_HANDLE_REQUEST_V2
type SMB2CreateDurableHandleRequestV2
{
    ULONG Timeout;
    
    SMB2CreateDurableHandleRequestV2Flags Flags;
    
    UINT64 Reserved where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Reserved", "SMB2CreateDurableHandleRequestV2", value);

    // WORKAROUND: BUG35565 - Can't use "CreateGuid" to name a guid field, compile error occurs in cs file
    GUID Create_Guid;
};

pattern SMB2CreateDurableHandleRequestV2Flags = flags ULONG
{
    SMB2DhandleFlagPersistent = 0x00000002
        with Documentation
            {Description = "A persistent handle is requested."}
    ...
} with Documentation {EmbeddedType = true};

// 2.2.13.2.12   SMB2_CREATE_DURABLE_HANDLE_RECONNECT_V2
type SMB2CreateDurableHandleReconnectV2
{
    SMB2Fileid FileId;

    // WORKAROUND: BUG35565 - Can't use "CreateGuid" to name a guid field, compile error occurs in cs file
    GUID Create_Guid;

    SMB2CreateDurableHandleReconnectV2Flags Flags;
};

pattern SMB2CreateDurableHandleReconnectV2Flags = flags ULONG
{
    SMB2DhandleFlagPersistent = 0x00000002
        with Documentation
            {Description = "A persistent handle is requested."}
    ...
} with Documentation {EmbeddedType = true};

// 2.2.13.2.13   SMB2_CREATE_APP_INSTANCE_ID
type SMB2CreateAppInstanceId
{
    USHORT StructureSize where ValidationCheckValue(value == 20, null, true, ReferenceType.Type, "SMB2", "StructureSize", "SMB2CreateAppInstanceId", 20, value);

    USHORT Reserved where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Reserved", "SMB2CreateAppInstanceId", value);

    GUID AppInstanceId;
};

// 2.2.13.2.15 SMB2_CREATE_APP_INSTANCE_VERSION
type SMB2CreateAppInstanceVersion
{
    USHORT StructureSize where ValidationCheckValue(value == 24, null, true, ReferenceType.Type, "SMB2", "StructureSize", "SMB2CreateAppInstanceVersion", 24, value);

    USHORT Reserved where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Reserved", "SMB2CreateAppInstanceVersion", value);
    UINT Padding where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Padding", "SMB2CreateAppInstanceVersion", value);
    UINT64 AppInstanceVersionHigh;
    UINT64 AppInstanceVersionLow;
};
// 2.2.14   SMB2 CREATE Response
type SMB2CreateResponse
{
    USHORT StructureSize where ValidationCheckValue(value == 89, null, true, ReferenceType.Type, "SMB2", "StructureSize", "SMB2CreateResponse", 89, value);

    SMB2CreateResponseOplockLevel OplockLevel
        where ValidationCheck(InRange<SMB2CreateResponseOplockLevel>(value), null, DiagnosisLevel.Error,
            () => Format(INFRASTRUCTURE_STR_CHECK_ENUM_VALUE, ["SMB2", "OplockLevel", INFRASTRUCTURE_STR_TYPE, "SMB2CreateResponse", INFRASTRUCTURE_STR_MUST, "0x00, 0x01, 0x08, 0x09, 0xFF", Utility.DecToHexFormat(value)]));

    SMB2CreateResponseFlags Flags;

    SMB2CreateResponseCreateAction CreateAction
        where ValidationCheck(InRange<SMB2CreateResponseCreateAction>(value), null, DiagnosisLevel.Error, 
            () => Format(INFRASTRUCTURE_STR_CHECK_VALUE_IN_RANGE, ["SMB2", "CreateAction", INFRASTRUCTURE_STR_TYPE, "SMB2CreateResponse", INFRASTRUCTURE_STR_MUST, "0x00000000", "0x00000003", Utility.DecToHexFormat(value)]));

    FILETIME CreationTime;

    FILETIME LastAccessTime;

    FILETIME LastWriteTime;

    FILETIME ChangeTime;

    LARGE_INTEGER AllocationSize;

    LARGE_INTEGER EndofFile;

    FileAttributes FileAttributes;

    ULONG Reserved2;

    SMB2Fileid FileId;

    ULONG CreateContextsOffset;

    ULONG CreateContextsLength;

    optional [|CreateContextsOffset > 0|] array<SMB2CreateContextResponse> Buffer
        where ValidationCheck(GetLastNext() == 0, null, DiagnosisLevel.Error, "SMB2: The Next field of the last entry of SMB2CreateContextResponse must be zero, not " + (GetLastNext() as string) + ".")
        with BinaryEncoding{LeadPadding = CreateContextsOffset > 152 ? (CreateContextsOffset - 152) * 8 : 0, WidthForComposedType = (CreateContextsOffset == 0 ? 0 : CreateContextsLength) * 8};
   
    uint GetLastNext()
    {
        if (Buffer != nothing)
        {
            var buffer = Buffer as array<SMB2CreateContextResponse>;
            if (buffer.Count > 0)
            {
                return buffer[buffer.Count - 1].Next;
            }
        }
        return 0;
    }
        
    override string ToString()
    {
        string summary = "";
        if (Buffer != nothing)
        {
            var buffer = Buffer as array<SMB2CreateContextResponse>;
            int count = buffer.Count;
            for (int i = 0; i < count; i++)
            {
                if (i != count - 1)
                {
                    summary += buffer[i].Buffer.ToString() + "+";
                }
                else
                {
                    summary += buffer[i].Buffer.ToString();
                }
            }
        }
        return summary;
    }
};

pattern SMB2CreateResponseFlags = flags BYTE
{
    SMB2CreateFlagReparsepoint = 0x01
        with Documentation
            {Description = "When set, indicates the last portion of the file path is a reparse point."},
    ...
};

// 2.2.14.1   SMB2_FILEID
type SMB2Fileid
{
    UINT64 Persistent with DisplayInfo{ToText = (any data) => Utility.DecToHexFormat(data)}; // bug#82071

    UINT64 Volatile with DisplayInfo{ToText = (any data) => Utility.DecToHexFormat(data)};

    override string ToString()
    {
        return "Persistent = " + Utility.DecToHexFormat(Persistent) + ", Volatile = " + Utility.DecToHexFormat(Volatile);
    }
};

// 2.2.14.2   SMB2_CREATE_CONTEXT Response Values
type SMB2CreateContextResponse
{
    ULONG Next;
    USHORT NameOffset;
    USHORT NameLength;
    USHORT Reserved;
    USHORT DataOffset;
    ULONG DataLength;
    SMB2CreateContextResponseBuffer[NameOffset, NameLength, DataOffset, DataLength] Buffer
        with BinaryEncoding{WidthForComposedType = (CreateContextEnd() - 16) * 8};
    optional [|Next > CreateContextEnd()|] array<byte> TrailPadding with BinaryEncoding{Length = Next - CreateContextEnd()};
    
    uint CreateContextEnd()
    {
        if (DataLength == 0)
        {
            return (NameOffset + NameLength) as uint;
        }

        return Max(NameOffset + NameLength, DataOffset + DataLength) as uint;
    }

    override string ToString()
    {
        return Buffer.ToString();
    }
};

type SMB2CreateContextResponseBuffer[ushort NameOffset, ushort NameLength, ushort DataOffset, uint DataLength]
{
    ([|NameLength == 16 && value == SVHDX_OPEN_DEVICE_CONTEXT|] binary | string) Name
        where ValidationCheck((value is string && InRange<SMB2CreateContextRequestValuesName>(value as string)) || value == SVHDX_OPEN_DEVICE_CONTEXT || value.ToString().Count == 0, null, DiagnosisLevel.Error, @"SMB2: The Name field in type SMB2CreateContextResponseBuffer is an undefined value. Please refer to SMB2_CREATE_CONTEXT Response Values in Technical Document [MS-SMB2].")
        with BinaryEncoding{TextEncoding = TextEncoding.ASCII}, DisplayInfo{ToText = CreateContextNameToText},
            Encoding{Offset = NameOffset - 16, Size = NameLength};

    ([|DataLength == 0|] Empty
     | [|Name == SMB2CreateContextRequestValuesName.SMB2CreateDurableHandleRequest|] SMB2CreateDurableHandleResponse
     | [|Name == SMB2CreateContextRequestValuesName.SMB2CreateDurableHandleRequestV2|] SMB2CreateDurableHandleResponseV2
     | [|Name == SMB2CreateContextRequestValuesName.SMB2CreateRequestLease && DataLength == 32|] SMB2CreateResponseLease
     | [|Name == SMB2CreateContextRequestValuesName.SMB2CreateRequestLease && DataLength >= 52|] SMB2CreateResponseLeaseV2
     | [|Name == SMB2CreateContextRequestValuesName.SMB2CreateQueryMaximalAccessRequest|] SMB2CreateQueryMaximalAccessResponse
     | [|Name == SMB2CreateContextRequestValuesName.SMB2CreateQueryOnDiskId|] SMB2CreateQueryOnDiskId
     | binary) Data with Encoding{Offset = (DataLength == 0 ? 0 : (DataOffset - 16)), Size = DataLength};
    
    override string ToString()
    {
        string summary = Name as string;
        switch (Data)
        {
            case dh2q:SMB2CreateDurableHandleResponseV2 =>
                summary += (dh2q.Flags & 0x00000002) > 0 ? "(P)" : "";
            case rqls:SMB2CreateResponseLease =>
                summary += "(" + SMB2LeaseStateToText(rqls.LeaseState) + ")";
            case rqls2:SMB2CreateResponseLeaseV2 =>
                summary += "(" + SMB2LeaseStateToText(rqls2.LeaseState);
                summary += (rqls2.Flags & 0x00000002) > 0 ? "-PK)" : ")";
        }
        return summary;
    }
}

// 2.2.14.2.3   SMB2_CREATE_DURABLE_HANDLE_RESPONSE
type SMB2CreateDurableHandleResponse
{
    UINT64 Reserved where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Reserved", "SMB2CreateDurableHandleResponse", value);
};

// 2.2.14.2.5   SMB2_CREATE_QUERY_MAXIMAL_ACCESS_RESPONSE
type SMB2CreateQueryMaximalAccessResponse
{
    ERREF.NTSTATUS QueryStatus;

    FilePipePrinterAccessMask MaximalAccess;
};

// 2.2.14.2.9   SMB2_CREATE_QUERY_ON_DISK_ID
type SMB2CreateQueryOnDiskId
{
    UINT64 DiskFileId;

    UINT64 VolumeId;
            
    binary Reserved where ValidationCheckZero(value == $[00000000000000000000000000000000], null, true, ReferenceType.Type, "SMB2", "Reserved", "SMB2CreateQueryOnDiskId", value)
        with BinaryEncoding{Length = 16};
};

pattern SMB2CreateResponseLeaseLeaseState = flags ULONG
{
    SMB2LeaseReadCaching = 0x01
        with Documentation {Description = "A read caching lease is granted."},
    SMB2LeaseHandleCaching = 0x02
        with Documentation {Description = "A handle caching lease is granted."},
    SMB2LeaseWriteCaching = 0x04
        with Documentation {Description = "A write caching lease is granted."}
    ...
} with Documentation {EmbeddedType = true};

pattern SMB2CreateResponseLeaseLeaseFlags = enum ULONG
{
    SMB2LeaseFlagBreakInProgress = 0x02,
    ...
};

// 2.2.14.2.10   SMB2_CREATE_RESPONSE_LEASE
type SMB2CreateResponseLease
{
    GUID LeaseKey;

    SMB2CreateResponseLeaseLeaseState LeaseState with DisplayInfo{ToText = SMB2LeaseStateToFullText};

    SMB2CreateResponseLeaseLeaseFlags LeaseFlags where ValidationCheck(value == 0 || value is SMB2CreateResponseLeaseLeaseFlags, null, DiagnosisLevel.Error, 
        () => "SMB2: The LeaseFlags field in type SMB2CreateResponseLease must be set to zero or 0x02, not " + Utility.DecToHexFormat(2, value) + ".");

    ULONG64 LeaseDuration where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "LeaseDuration", "SMB2CreateResponseLease", value);
};

// 2.2.14.2.11   SMB2_CREATE_RESPONSE_LEASE_V2
type SMB2CreateResponseLeaseV2
{
    GUID LeaseKey;

    SMB2CreateResponseLeaseV2LeaseState LeaseState;

    SMB2CreateResponseLeaseV2Flags Flags where ValidationCheck(value == 0 || InRange<SMB2CreateResponseLeaseV2Flags>(value), null, DiagnosisLevel.Error, 
        () => "SMB2: The Flags field in type SMB2CreateResponseLeaseV2 must be set to zero or one of 0x00000002, 0x00000004 if the server implements SMB 2.1, not " + Utility.DecToHexFormat(8, value) + ".");
    
    ULONG64 LeaseDuration where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "LeaseDuration", "SMB2CreateResponseLeaseV2", value);

    GUID ParentLeaseKey;

    USHORT Epoch;

    USHORT Reserved;
};

pattern SMB2CreateResponseLeaseV2LeaseState = flags ULONG
{
    SMB2LeaseReadCaching = 0x00000001
        with Documentation
            {Description = "A read caching lease is granted."},
    SMB2LeaseHandleCaching = 0x00000002
        with Documentation
            {Description = "A handle caching lease is granted."},
    SMB2LeaseWriteCaching = 0x00000004
        with Documentation
            {Description = "A write caching lease is granted."}
    ...
} with Documentation {EmbeddedType = true};

pattern SMB2CreateResponseLeaseV2Flags = flags ULONG
{
    SMB2LeaseFlagBreakInProgress = 0x00000002
        with Documentation
            {Description = "A break for the lease identified by the lease key is in progress."},
    SMB2LeaseFlagParentLeaseKeySet = 0x00000004
        with Documentation
            {Description = "When set, indicates that the ParentLeaseKey is set."}
    ...
} with Documentation {EmbeddedType = true};

// 2.2.14.2.12   SMB2_CREATE_DURABLE_HANDLE_RESPONSE_V2
type SMB2CreateDurableHandleResponseV2
{
    ULONG Timeout;

    SMB2CreateDurableHandleResponseV2Flags Flags;
};

pattern SMB2CreateDurableHandleResponseV2Flags = flags ULONG
{
    SMB2DhandleFlagPersistent = 0x00000002
        with Documentation
            {Description = "A persistent handle is granted."}
    ...
} with Documentation {EmbeddedType = true};

// 2.2.15   SMB2 CLOSE Request
type SMB2CloseRequest
{
    USHORT StructureSize where ValidationCheckValue(value == 24, null, true, ReferenceType.Type, "SMB2", "StructureSize", "SMB2CloseRequest", 24, value);

    SMB2CloseRequestFlags Flags;

    ULONG Reserved where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Reserved", "SMB2CloseRequest", value);

    SMB2Fileid FileId;
};

pattern SMB2CloseRequestFlags = flags USHORT
{
   SMB2CloseFlagPostqueryAttrib = 0x0001
       with Documentation
          {Description = "If set, the server MUST set the attribute fields in the response, as specified in section 2.2.16, to valid values. If not set, the client MUST NOT use the values that are returned in the response."},
    ...
}with Documentation {EmbeddedType = true};

pattern SMB2CloseResponseFlags = flags USHORT
{
    SMB2CloseFlagPostqueryAttrib = 0x0001
        with Documentation
            {Description = "If set, the client MUST use the attribute fields in the response. If not set, the client MUST NOT use the attribute fields that are returned in the response."},
    ...
}with Documentation {EmbeddedType = true};

// 2.2.16   SMB2 CLOSE Response
type SMB2CloseResponse
{
    USHORT StructureSize where ValidationCheckValue(value == 60, null, true, ReferenceType.Type, "SMB2", "StructureSize", "SMB2CloseResponse", 60, value);

    SMB2CloseResponseFlags Flags;

    ULONG Reserved where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Reserved", "SMB2CloseResponse", value);

    FILETIME CreationTime with DisplayInfo {ToText = SMB2.FileTimeToText};

    FILETIME LastAccessTime with DisplayInfo {ToText = SMB2.FileTimeToText};

    FILETIME LastWriteTime with DisplayInfo {ToText = SMB2.FileTimeToText};

    FILETIME ChangeTime with DisplayInfo {ToText = SMB2.FileTimeToText};

    LARGE_INTEGER AllocationSize;

    LARGE_INTEGER EndofFile;

    FileAttributes FileAttributes;
};

string FileTimeToText(any data)
{    
    if (data is FILETIME) 
    {
        FILETIME time = data as FILETIME;
        if (time.dwLowDateTime == 0 && time.dwHighDateTime == 0)
        {
            return "No Time Specified (0)";
        }
        else
        {
            return time.ToString();
        }
    } 
    else
    {
        return "Unknown Type";
    } 
}
       
// 2.2.17   SMB2 FLUSH Request
type SMB2FlushRequest
{
    USHORT StructureSize where ValidationCheckValue(value == 24, null, true, ReferenceType.Type, "SMB2", "StructureSize", "SMB2FlushRequest", 24, value);

    USHORT Reserved1 where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Reserved1", "SMB2FlushRequest", value);

    ULONG Reserved2 where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Reserved2", "SMB2FlushRequest", value);

    SMB2Fileid FileId;
};

// 2.2.18   SMB2 FLUSH Response
type SMB2FlushResponse
{
    USHORT StructureSize where ValidationCheckValue(value == 4, null, true, ReferenceType.Type, "SMB2", "StructureSize", "SMB2FlushResponse", 4, value);

    USHORT Reserved where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Reserved", "SMB2FlushResponse", value);
};

// 2.2.19   SMB2 READ Request
type SMB2ReadRequest[ushort DialectRevision]
{
    USHORT StructureSize where ValidationCheckValue(value == 49, null, true, ReferenceType.Type, "SMB2", "StructureSize", "SMB2ReadRequest", 49, value);

    UCHAR Padding;

    SMB2ReadRequestFlags Flags 
        where ValidationCheck(
            ((DialectRevision == SMB2NegotiateResponseDialectRevision.SMB302DialectRevisionNumber || DialectRevision == SMB2NegotiateResponseDialectRevision.SMB311DialectRevisionNumber) ? (value == 0 || value is SMB2ReadRequestFlags.SMB2_READFLAG_READ_UNBUFFERED || value is SMB2ReadRequestFlags.SMB2_READFLAG_REQUEST_COMPRESSED) : (value == 0)), 
            null, 
            DiagnosisLevel.Error,
            ((DialectRevision == SMB2NegotiateResponseDialectRevision.SMB302DialectRevisionNumber || DialectRevision == SMB2NegotiateResponseDialectRevision.SMB311DialectRevisionNumber) ? 
                ("SMB2: For the SMB 3.0.2 and SMB 3.1.1 dialects, the Flags in type SMB2ReadRequest must be set to zero or 0x01 or 0x02, not " + DecToHexFormat(value) + ".") : 
                ("SMB2: For the SMB 2.0.2, 2.1 and 3.0 dialects, the Flags in type SMB2ReadRequest must be set to zero, not " + DecToHexFormat(value) + "."))
            );

    ULONG Length;

    UINT64 Offset;

    SMB2Fileid FileId;

    ULONG MinimumCount;

    SMB2ReadRequestChannel Channel;

    ULONG RemainingBytes;

    USHORT ReadChannelInfoOffset where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "ReadChannelInfoOffset", "SMB2ReadRequest", value);

    USHORT ReadChannelInfoLength where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "ReadChannelInfoLength", "SMB2ReadRequest", value);

    BYTE Buffer where ValidationCheckZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Buffer", "SMB2ReadRequest", value);
};

pattern SMB2ReadRequestChannel = flags ULONG
{
    SMB2_CHANNEL_NONE = 0x00000000
        with Documentation
            {Description = "No channel information is present in the request. The ReadChannelInfoOffset and ReadChannelInfoLength fields MUST be set to 0 by the client and MUST be ignored by the server."},
    SMB2_CHANNEL_RDMA_V1 = 0x00000001
        with Documentation
            {Description = "One or more SMB_DIRECT_BUFFER_DESCRIPTOR_V1 structures as specified in [MS-SMBD] section 2.2.3.1 are present in the channel information specified by ReadChannelInfoOffset and ReadChannelInfoLength fields."},
    SMB2_CHANNEL_RDMA_V1_INVALIDATE = 0x00000002
        with Documentation
            {Description = "This flag is not valid for the SMB 2.0.2, 2.1, and 3.0 dialects. One or more SMB_DIRECT_BUFFER_DESCRIPTOR_V1 structures as specified in [MS-SMBD] section 2.2.3.1 are present in the channel information specified by the WriteChannelInfoOffset and WriteChannelInfoLength fields. The server is requested to perform remote invalidation when responding to the request as specified in [MS-SMBD] section .3.1.4.2."},
    ...
}with Documentation {EmbeddedType = true};

pattern SMB2ReadRequestFlags = enum UCHAR
{
    SMB2_READFLAG_READ_UNBUFFERED    = 0x01,
    SMB2_READFLAG_REQUEST_COMPRESSED = 0x02,
    ...
};

// 2.2.20   SMB2 READ Response
type SMB2ReadResponse
{
    USHORT StructureSize where ValidationCheckValue(value == 17, null, true, ReferenceType.Type, "SMB2", "StructureSize", "SMB2ReadResponse", 17, value);

    UCHAR DataOffset;

    UCHAR Reserved where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Reserved", "SMB2ReadResponse", value);

    ULONG DataLength;

    ULONG DataRemaining;
            
    ULONG Reserved2 where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Reserved2", "SMB2ReadResponse", value);
    
    optional [|DataOffset > 80|] array<byte> DataPadding with BinaryEncoding{Length = DataOffset - 80};
    binary Buffer where ValidationCheck(value.Count > 0, null, "SMB2: The minimum length of Buffer in type SMB2ReadResponse is 1 byte, not " + (value.Count as string) + ".")
        with BinaryEncoding{MaxLength = DataLength};
};

// 2.2.21   SMB2 WRITE Request
type SMB2WriteRequest
{
    USHORT StructureSize where ValidationCheckValue(value == 49, null, true, ReferenceType.Type, "SMB2", "StructureSize", "SMB2WriteRequest", 49, value);

    USHORT DataOffset;

    ULONG Length;

    UINT64 Offset;

    SMB2Fileid FileId;

    SMB2WriteRequestChannel Channel;

    ULONG RemainingBytes;

    USHORT WriteChannelInfoOffset;

    USHORT WriteChannelInfoLength;

    SMB2WriteRequestFlags Flags where ValidationCheck((value == 0 || value is SMB2WriteRequestFlags), null, DiagnosisLevel.Error, "SMB2: the Flags in type SMB2WriteRequest must be set to zero, 0x00000001 or 0x00000002, not " + DecToHexFormat(value) + ".");
    
    optional [|DataOffset > 112|] array<byte> DataPadding with BinaryEncoding{Length = DataOffset - 112};
    binary Buffer with BinaryEncoding{MaxLength = Length};
};

pattern SMB2WriteRequestFlags = flags ULONG
{
    SMB2_WRITEFLAG_WRITE_THROUGH = 0x00000001
        with Documentation
           {Description = "The write data should be written to persistent storage before the response is sent regardless of how the file was opened.  This value is only supported for the SMB 2.1 dialect."},
    SMB2_WRITEFLAG_WRITE_UNBUFFERED = 0x00000002
        with Documentation
           {Description = "The server or underlying object store SHOULD NOT cache the write data at intermediate layers and SHOULD allow it to flow through to persistent storage. This bit is only valid for the SMB 3.02 dialect."}
    ...
};

pattern SMB2WriteRequestChannel = flags ULONG
{
    SMB2_CHANNEL_NONE = 0x00000000
        with Documentation
            {Description = "No channel information is present in the request. The WriteChannelInfoOffset and WriteChannelInfoLength fields MUST be set to zero by the client and MUST be ignored by the server."},
    SMB2_CHANNEL_RDMA_V1 = 0x00000001
        with Documentation
            {Description = "One or more SMB_DIRECT_BUFFER_DESCRIPTOR_V1 structures as specified in [MS-SMBD] section 2.2.3.1 are present in the channel information specified by WriteChannelInfoOffset and WriteChannelInfoLength fields."},
    SMB2_CHANNEL_RDMA_V1_INVALIDATE = 0x00000002
        with Documentation
            {Description = "This value is valid only for the SMB 3.02 dialect. One or more SMB_DIRECT_BUFFER_DESCRIPTOR_V1 structures as specified in [MS-SMBD] section 2.2.3.1 are present in the channel information specified by the WriteChannelInfoOffset and WriteChannelInfoLength fields. The server is requested to perform remote invalidation when responding to the request as specified in [MS-SMBD] section 3.1.4.2."},
    ...
}with Documentation {EmbeddedType = true};

// 2.2.22   SMB2 WRITE Response
type SMB2WriteResponse
{
    USHORT StructureSize where ValidationCheckValue(value == 17, null, true, ReferenceType.Type, "SMB2", "StructureSize", "SMB2WriteResponse", 17, value);

    USHORT Reserved where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Reserved", "SMB2WriteResponse", value);

    ULONG Count;

    ULONG Remaining where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Remaining", "SMB2WriteResponse", value);

    USHORT WriteChannelInfoOffset where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "WriteChannelInfoOffset", "SMB2WriteResponse", value);

    USHORT WriteChannelInfoLength where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "WriteChannelInfoLength", "SMB2WriteResponse", value);
};

// 2.2.23.1   Oplock Break Notification
type SMB2OplockBreakNotification
{
    USHORT StructureSize where ValidationCheckValue(value == 24, null, true, ReferenceType.Type, "SMB2", "StructureSize", "SMB2OplockBreakNotification", 24, value);

    SMB2OplockBreakNotificationOplockLevel OplockLevel
        where ValidationCheck(InRange<SMB2OplockBreakNotificationOplockLevel>(value), null, DiagnosisLevel.Error, 
            () => Format(INFRASTRUCTURE_STR_CHECK_ENUM_VALUE, ["SMB2", "OplockLevel", INFRASTRUCTURE_STR_TYPE, "SMB2OplockBreakNotification", INFRASTRUCTURE_STR_MUST, "0x00, 0x01", Utility.DecToHexFormat(value)]));

    UCHAR Reserved where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Reserved", "SMB2OplockBreakNotification", value);

    ULONG Reserved2 where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Reserved2", "SMB2OplockBreakNotification", value);

    SMB2Fileid FileId;
};

pattern SMB2OplockBreakNotificationOplockLevel = enum BYTE
{
    SMB2OplockLevelNone = 0x00,
    SMB2OplockLevelII = 0x01,
    ...
};

// 2.2.23.2   Lease Break Notification
type SMB2LeaseBreakNotification
{
    USHORT StructureSize where ValidationCheckValue(value == 44, null, true, ReferenceType.Type, "SMB2", "StructureSize", "SMB2LeaseBreakNotification", 44, value);

    USHORT NewEpoch;

    SMB2LeaseBreakNotificationFlags Flags;

    GUID LeaseKey;

    SMB2LeaseBreakNotificationCurrentLeaseState CurrentLeaseState;

    SMB2LeaseBreakNotificationNewLeaseState NewLeaseState with DisplayInfo{ToText = SMB2LeaseStateToFullText};

    ULONG BreakReason where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "BreakReason", "SMB2LeaseBreakNotification", value);

    ULONG AccessMaskHint where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "AccessMaskHint", "SMB2LeaseBreakNotification", value);

    ULONG ShareMaskHint where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "ShareMaskHint", "SMB2LeaseBreakNotification", value);
};

pattern SMB2LeaseBreakNotificationFlags = flags
{
    SMB2NotifyBreakLeaseFlagAckRequired = 0x01
        with Documentation
            {Description = "A Lease Break Acknowledgment is required."},
    ...
}with Documentation {EmbeddedType = true};
 
pattern SMB2LeaseBreakNotificationNewLeaseState = flags ULONG
{
    SMB2LeaseReadCaching = 0x01
        with Documentation {Description = "A read caching lease is granted."},
    SMB2LeaseHandleCaching = 0x02
        with Documentation {Description = "A handle caching lease is granted."},
    SMB2LeaseWriteCaching = 0x04
        with Documentation {Description = "A write caching lease is granted."},
    ...
};

pattern SMB2LeaseBreakNotificationCurrentLeaseState = flags ULONG
{
    SMB2LeaseReadCaching = 0x01
        with Documentation {Description = "A read caching lease is granted."},
    SMB2LeaseHandleCaching = 0x02
        with Documentation {Description = "A handle caching lease is granted."},
    SMB2LeaseWriteCaching = 0x04
        with Documentation {Description = "A write caching lease is granted."},
    ...
}with Documentation {EmbeddedType = true};

pattern DirectoryAccessMaskDirectoryAccessMask = flags ULONG
{
    FileListDirectory = 0x00000001
        with Documentation
            {Description = "This value indicates the right to enumerate the contents of the directory."},
    FileAddFile = 0x00000002
        with Documentation
            {Description = "This value indicates the right to create a file under the directory."},
    FileAddSubdirectory = 0x00000004
        with Documentation
            {Description = "This value indicates the right to add a sub-directory under the directory."},
    FileReadEa = 0x00000008
        with Documentation
            {Description = "This value indicates the right to read the extended attributes of the directory."},
    FileWriteEa = 0x00000010
        with Documentation
            {Description = "This value indicates the right to write or change the extended attributes of the directory."},
    FileTraverse = 0x00000020
        with Documentation
            {Description = "This value indicates the right to traverse this directory if the server enforces traversal checking."},
    FileDeleteChild = 0x00000040
        with Documentation
            {Description = "This value indicates the right to delete the files and directories within this directory."},
    FileReadAttributes = 0x00000080
        with Documentation
            {Description = "This value indicates the right to read the attributes of the directory."},
    FileWriteAttributes = 0x00000100
        with Documentation
            {Description = "This value indicates the right to change the attributes of the directory."},
    Delete = 0x00010000
        with Documentation
            {Description = "This value indicates the right to delete the directory."},
    ReadControl = 0x00020000
        with Documentation
            {Description = "This value indicates the right to read the security descriptor for the directory."},
    WriteDac = 0x00040000
        with Documentation
            {Description = "This value indicates the right to change the DACL in the security descriptor for the directory. For the DACL data structure, see ACL in [MS-DTYP]."},
    WriteOwner = 0x00080000
        with Documentation
            {Description = "This value indicates the right to change the owner in the security descriptor for the directory."},
    Synchronize = 0x00100000
        with Documentation
            {Description = "SMB2 clients set this flag to any value.windows sets this flag to the value passed in by the higher-level application. SMB2 servers SHOULDwindows_server_2008_r2 and windows_7 do not ignore the SyncHRONIZE bit, and pass it to the underlying object store. If the caller requests SyncHRONIZE in the DesiredAccess parameter, but the SyncHRONIZE access is not granted to the caller for the object being created or opened, the underlying object store fails the request and returns STATUS_ACCESS_DENIED. When SyncHRONIZE access is granted, the SyncHRONIZE bit is returned in MaximalAccess field of SMB2_CREATE_QUERY_MAXIMAL_ACCESS_RESPONSE with no other behavior. ignore this flag."},
    AccessSystemSecurity = 0x01000000
        with Documentation
            {Description = "This value indicates the right to read or change the SACL in the security descriptor for the directory. For the SACL data structure, see ACL in [MS-DTYP].windows fails the create request with STATUS_ACCESS_DENIED if the caller does not have the SeSecurityPrivilege, as specified in [MS-LSAD] section ."},
    MaximumAllowed = 0x02000000
        with Documentation
            {Description = "This value indicates that the client is requesting an open to the directory with the highest level of access the client has on this directory. If no access is granted for the client on this directory, the server MUST fail the open with STATUS_ACCESS_DENIED."},
    GenericAll = 0x10000000
        with Documentation
            {Description = "This value indicates a request for all the access flags that are listed above except MAXIMUM_ALLOWED and ACCESS_SYSTEM_SECURITY."},
    GenericExecute = 0x20000000
        with Documentation
            {Description = "This value indicates a request for the following access flags listed above: FILE_READ_ATTRIBUTES| FILE_TRAVERSE| SyncHRONIZE| READ_CONTROL."},
    GenericWrite = 0x40000000
        with Documentation
            {Description = "This value indicates a request for the following access flags listed above: FILE_ADD_FILE| FILE_ADD_SUBDIRECTORY| FILE_WRITE_ATTRIBUTES| FILE_WRITE_EA| SyncHRONIZE| READ_CONTROL."},
    GenericRead = 0x80000000
        with Documentation
            {Description = "This value indicates a request for the following access flags listed above: FILE_LIST_DIRECTORY| FILE_READ_ATTRIBUTES| FILE_READ_EA| SyncHRONIZE| READ_CONTROL."},
    ...
} with Documentation {EmbeddedType = true};

// 2.2.24.1   Oplock Break Acknowledgment
type SMB2OplockBreakAcknowledgment
{
    USHORT StructureSize where ValidationCheckValue(value == 24, null, true, ReferenceType.Type, "SMB2", "StructureSize", "SMB2OplockBreakAcknowledgment", 24, value);

    SMB2OplockBreakAcknowledgmentOplockLevel OplockLevel
        where ValidationCheck(InRange<SMB2OplockBreakAcknowledgmentOplockLevel>(value), null, DiagnosisLevel.Error,
            () => Format(INFRASTRUCTURE_STR_CHECK_ENUM_VALUE, ["SMB2", "OplockLevel", INFRASTRUCTURE_STR_TYPE, "SMB2OplockBreakAcknowledgment", INFRASTRUCTURE_STR_MUST, "0x00, 0x01", Utility.DecToHexFormat(value)]));

    UCHAR Reserved where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Reserved", "SMB2OplockBreakAcknowledgment", value);

    ULONG Reserved2 where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Reserved2", "SMB2OplockBreakAcknowledgment", value);

    SMB2Fileid FileId;
};

pattern SMB2OplockBreakAcknowledgmentOplockLevel = enum BYTE
{
    SMB2OplockLevelNone = 0x00,
    SMB2OplockLevelII = 0x01,
    ...
};

// 2.2.24.2   Lease Break Acknowledgment
type SMB2LeaseBreakAcknowledgment
{
    USHORT StructureSize where ValidationCheckValue(value == 36, null, true, ReferenceType.Type, "SMB2", "StructureSize", "SMB2LeaseBreakAcknowledgment", 36, value);

    USHORT Reserved where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Reserved", "SMB2LeaseBreakAcknowledgment", value);

    UINT32 Flags where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Flags", "SMB2LeaseBreakAcknowledgment", value);

    GUID LeaseKey;

    SMB2LeaseBreakAcknowledgmentLeaseState LeaseState with DisplayInfo{ToText = SMB2LeaseStateToFullText};

    ULONG64 LeaseDuration where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "LeaseDuration", "SMB2LeaseBreakAcknowledgment", value);
};

pattern SMB2LeaseBreakAcknowledgmentLeaseState = flags ULONG
{
   SMB2LeaseReadCaching = 0x01
       with Documentation {Description = "A read caching lease is accepted."},
   SMB2LeaseHandleCaching = 0x02
       with Documentation {Description = "A handle caching lease is accepted."},
   SMB2LeaseWriteCaching = 0x04
       with Documentation {Description = "A write caching lease is accepted."},
   Reservered = 0xFFFFFFF0
} with Documentation {EmbeddedType = true};

// 2.2.25.1   Oplock Break Response
type SMB2OplockBreakResponse
{
    USHORT StructureSize where ValidationCheckValue(value == 24, null, true, ReferenceType.Type, "SMB2", "StructureSize", "SMB2OplockBreakResponse", 24, value);

    SMB2OplockBreakResponseOplockLevel OplockLevel
        where ValidationCheck(InRange<SMB2OplockBreakResponseOplockLevel>(value), null, DiagnosisLevel.Error,
            () => Format(INFRASTRUCTURE_STR_CHECK_ENUM_VALUE, ["SMB2", "OplockLevel", INFRASTRUCTURE_STR_TYPE, "SMB2OplockBreakResponse", INFRASTRUCTURE_STR_MUST, "0x00, 0x01", Utility.DecToHexFormat(value)]));

    UCHAR Reserved where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Reserved", "SMB2OplockBreakResponse", value);

    ULONG Reserved2 where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Reserved2", "SMB2OplockBreakResponse", value);

    SMB2Fileid FileId;
};

pattern SMB2OplockBreakResponseOplockLevel = enum BYTE
{
    SMB2OplockLevelNone = 0x00,
    SMB2OplockLevelII = 0x01,
    ...
};
 
// 2.2.25.2   Lease Break Response
type SMB2LeaseBreakResponse
{
    USHORT StructureSize where ValidationCheckValue(value == 36, null, true, ReferenceType.Type, "SMB2", "StructureSize", "SMB2LeaseBreakResponse", 36, value);

    USHORT Reserved where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Reserved", "SMB2LeaseBreakResponse", value);

    UINT32 Flags where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Flags", "SMB2LeaseBreakResponse", value);

    GUID LeaseKey;

    SMB2LeaseBreakResponseLeaseState LeaseState with DisplayInfo{ToText = SMB2LeaseStateToFullText};

    ULONG64 LeaseDuration where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "LeaseDuration", "SMB2LeaseBreakResponse", value);
};

pattern SMB2LeaseBreakResponseLeaseState = flags ULONG
{
    SMB2LeaseReadCaching = 0x01
       with Documentation {Description = "A read caching lease is granted."},
    SMB2LeaseHandleCaching = 0x02
       with Documentation {Description = "A handle caching lease is granted."},
    SMB2LeaseWriteCaching = 0x04
       with Documentation {Description = "A write caching lease is granted."},
    ...
} with Documentation {EmbeddedType = true};

// 2.2.26   SMB2 LOCK Request
type SMB2LockRequest
{
    USHORT StructureSize where ValidationCheckValue(value == 48, null, true, ReferenceType.Type, "SMB2", "StructureSize", "SMB2LockRequest", 48, value);

    USHORT LockCount where ValidationCheckGreaterThan(value > 0, null, true, ReferenceType.Type, "SMB2", "LockCount", "SMB2LockRequest", 0, value);

    byte LockSequenceNumber with BinaryEncoding{Width = 4};

    uint LockSequenceIndex  with BinaryEncoding{Width = 28};

    SMB2Fileid FileId;

    array<SMB2LockElement> Locks with BinaryEncoding{Length = LockCount};
};

// 2.2.26.1   SMB2_LOCK_ELEMENT Structure
type SMB2LockElement
{
    UINT64 Offset;

    UINT64 Length;

    SMB2LockElementFlags Flags;

    ULONG Reserved where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Reserved", "SMB2LockElement", value);
};

// WORKAROUND: Bug#27596 - [DCR] Show the bits combination in the Details view for a flags pattern field
type SMB2LockElementFlags
{
    byte Reserved1 with BinaryEncoding{Width = 3};
    bool SMB2LockflagFailImmediately with BinaryEncoding{Width = 1};
    byte Reserved2 with BinaryEncoding{Width = 1};
    bool SMB2LockflagUnlock with BinaryEncoding{Width = 1};
    bool SMB2LockflagExclusiveLock with BinaryEncoding{Width = 1};
    bool SMB2LockflagSharedLock with BinaryEncoding{Width = 1};
    array<byte> Reserved3 with BinaryEncoding{Length = 3};
}

/*  pattern SMB2LockElementFlags =
 *  flags
 *  {
 *   SMB2LockflagSharedLock = 0x00000001,
 *   SMB2LockflagExclusiveLock = 0x00000002,
 *   SMB2LockflagUnlock = 0x00000004,
 *   SMB2LockflagFailImmediately = 0x00000010;
 */

// 2.2.27   SMB2 LOCK Response
type SMB2LockResponse
{
    USHORT StructureSize where ValidationCheckValue(value == 4, null, true, ReferenceType.Type, "SMB2", "StructureSize", "SMB2LockResponse", 4, value);

    USHORT Reserved where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Reserved", "SMB2LockResponse", value);
};

// 2.2.28   SMB2 ECHO Request
type SMB2EchoRequest
{
    USHORT StructureSize where ValidationCheckValue(value == 4, null, true, ReferenceType.Type, "SMB2", "StructureSize", "SMB2EchoRequest", 4, value);

    USHORT Reserved where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Reserved", "SMB2EchoRequest", value);
};

// 2.2.29   SMB2 ECHO Response
type SMB2EchoResponse
{
    USHORT StructureSize where ValidationCheckValue(value == 4, null, true, ReferenceType.Type, "SMB2", "StructureSize", "SMB2EchoResponse", 4, value);

    USHORT Reserved where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Reserved", "SMB2EchoResponse", value);
};

// 2.2.30   SMB2 CANCEL Request
type SMB2CancelRequest
{
    USHORT StructureSize where ValidationCheckValue(value == 4, null, true, ReferenceType.Type, "SMB2", "StructureSize", "SMB2CancelRequest", 4, value);

    USHORT Reserved where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Reserved", "SMB2CancelRequest", value);
};

pattern SMB2CreateResponseOplockLevel = enum BYTE
{
    SMB2OplockLevelNone = 0x00,
    SMB2OplockLevelII = 0x01,
    SMB2OplockLevelExclusive = 0x08,
    SMB2OplockLevelBatch = 0x09,
    OplockLevelLease = 0xFF,
    ...
};

pattern SMB2CreateResponseCreateAction = enum ULONG
{
    FileSuperseded = 0x00000000,
    FileOpened = 0x00000001,
    FileCreated = 0x00000002,
    FileOverwritten = 0x00000003,
    ...
};

// 2.2.31   SMB2 IOCTL Request
type SMB2IoctlRequest
{
    USHORT StructureSize where ValidationCheckValue(value == 57, null, true, ReferenceType.Type, "SMB2", "StructureSize", "SMB2IoctlRequest", 57, value);

    USHORT Reserved where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Reserved", "SMB2IoctlRequest", value);
    
    ULONG CtlCode with DisplayInfo{ToText = SMB2.CtlCodeToText};

    SMB2Fileid FileId;

    ULONG InputOffset;

    ULONG InputCount;

    ULONG MaxInputResponse;

    ULONG OutputOffset;

    ULONG OutputCount where ValidationCheckZero(value == 0, null, true, ReferenceType.Type, "SMB2", "OutputCount", "SMB2IoctlRequest", value);

    ULONG MaxOutputResponse;

    SMB2IoctlRequestFlags Flags
        where ValidationCheck(InRange<SMB2IoctlRequestFlags>(value), null, DiagnosisLevel.Error,
            () => Format(INFRASTRUCTURE_STR_CHECK_ENUM_VALUE, ["SMB2", "Flags", INFRASTRUCTURE_STR_TYPE, "SMB2IoctlRequest", INFRASTRUCTURE_STR_MUST, "0x00000000, 0x00000001", Utility.DecToHexFormat(value)]));

    ULONG Reserved2 where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Reserved2", "SMB2IoctlRequest", value);

    ([|InputCount == 0|] Empty
        | [|(CtlCode == SMB2IoctlCtlCode.FSCTL_SRV_COPYCHUNK || CtlCode == SMB2IoctlCtlCode.FSCTL_SRV_COPYCHUNK_WRITE)|] SrvCopychunkCopy
        | [|CtlCode == SMB2IoctlCtlCode.FSCTL_PIPE_WAIT|] FSCTLPipeWaitRequest
        | [|CtlCode == SMB2IoctlCtlCode.FSCTL_SRV_READ_HASH|] SrvReadHashRequest
        | [|CtlCode == SMB2IoctlCtlCode.FSCTL_LMR_REQUEST_RESILIENCY|] NetworkResiliencyRequest
        | [|CtlCode == SMB2IoctlCtlCode.FSCTL_SET_REPARSE_POINT|] FSCTLSetReparsePointRequest
        | [|CtlCode == SMB2IoctlCtlCode.FSCTL_LMR_SET_LINK_TRACKING_INFORMATION|] FSCTLLmrSetLinkTrackingInformationRequestForSmb2
        | [|CtlCode == SMB2IoctlCtlCode.FSCTL_GET_RETRIEVAL_POINTERS|] FSCTLGetRetrievalPointersRequest
        | [|CtlCode == SMB2IoctlCtlCode.FSCTL_OFFLOAD_READ|] FSCTLOffloadReadRequest
        | [|CtlCode == SMB2IoctlCtlCode.FSCTL_OFFLOAD_WRITE|] FSCTLOffloadWriteRequest
        | [|CtlCode == SMB2IoctlCtlCode.FSCTL_FILE_LEVEL_TRIM|] FSCTLFileLevelTrimRequest
        | [|CtlCode == SMB2IoctlCtlCode.FSCTL_VALIDATE_NEGOTIATE_INFO|] ValidateNegotiateInfoRequest
        
        | [|CtlCode == FSCC.CtlCode.FSCTLDeleteReparsePoint|] FSCTLDeleteReparsePointRequest
        | [|CtlCode == FSCC.CtlCode.FSCTLFindFilesBySID|] FSCTLFindFilesBySIDRequest
        | [|CtlCode == FSCC.CtlCode.FSCTLGetCompression|] FSCTLGetCompressionReply
        | [|CtlCode == FSCC.CtlCode.FSCTLIsPathnameValid|] FSCTLIsPathnameValidRequest
        | [|CtlCode == FSCC.CtlCode.FSCTLQueryAllocatedRanges|] FSCTLQueryAllocatedRangesRequest
        | [|CtlCode == FSCC.CtlCode.FSCTLQueryFileRegions|] FSCTLQueryFileRegionsRequest
        | [|CtlCode == FSCC.CtlCode.FSCTLSetCompression|] FSCTLSetCompressionRequest
        | [|CtlCode == FSCC.CtlCode.FSCTLSetDefectManagement|] FSCTLSetDefectManagementRequest
        | [|CtlCode == FSCC.CtlCode.FSCTLSetEncryption|] FSCTLSetEncryptionRequest
        | [|CtlCode == FSCC.CtlCode.FSCTLSetIntegrityInformation|] FSCTLSetIntegrityInformationRequest
        | [|CtlCode == FSCC.CtlCode.FSCTLSetObjectID|] FSCTLSetObjectIdRequest
        | [|CtlCode == FSCC.CtlCode.FSCTLSetObjectIDExtended|] FSCTLSetObjectIdExtendedRequest
        | [|CtlCode == FSCC.CtlCode.FSCTLSetSparse|] FSCTLSetSparseRequest
        | [|CtlCode == FSCC.CtlCode.FSCTLSetZeroData|] FSCTLSetZeroDataRequest
        | [|CtlCode == FSCC.CtlCode.FSCTLSisCopyfile|] FSCTLSisCopyfileRequest
        | [|CtlCode == FSCC.CtlCode.FSCTLDuplicateExtensToFile|] SMB2DuplicateExtensDataRequest
        | [|CtlCode == FSCC.CtlCode.FSCTLDuplicateExtensToFileEX|] SMB2DuplicateExtensDataEXRequest
        | [|CtlCode == FSCC.CtlCode.FSCTLReadFileUSNData|] FSCTLReadFileUSNDataRequest
        | binary) Buffer with BinaryEncoding{MaxLength = InputCount}, Encoding{Offset = InputOffset - 64};
};

pattern SMB2IoctlCtlCode = enum ULONG
{
    FSCTL_DFS_GET_REFERRALS = 0x00060194,
    FSCTL_PIPE_PEEK = 0x0011400C, 
    FSCTL_PIPE_WAIT = 0x00110018,
    FSCTL_PIPE_TRANSCEIVE = 0x0011C017,
    FSCTL_SRV_COPYCHUNK = 0x001440F2,
    FSCTL_SRV_ENUMERATE_SNAPSHOTS = 0x00144064,
    FSCTL_SRV_REQUEST_RESUME_KEY = 0x00140078,
    FSCTL_SRV_READ_HASH = 0x001441bb, 
    FSCTL_SRV_COPYCHUNK_WRITE = 0x001480F2, 
    FSCTL_LMR_REQUEST_RESILIENCY = 0x001401D4, 
    FSCTL_QUERY_NETWORK_INTERFACE_INFO = 0x001401FC, 
    FSCTL_SET_REPARSE_POINT = 0x000900A4, 
    FSCTL_LMR_SET_LINK_TRACKING_INFORMATION = 0x001400EC,
    FSCTL_DFS_GET_REFERRALS_EX = 0x000601B0,
    FSCTL_GET_RETRIEVAL_POINTERS = 0x00090073,
    FSCTL_OFFLOAD_READ = 0x00094264,
    FSCTL_OFFLOAD_WRITE = 0x00098268,
    FSCTL_FILE_LEVEL_TRIM = 0x00098208,
    FSCTL_VALIDATE_NEGOTIATE_INFO = 0x00140204,
    FSCTL_SVHDX_SYNC_TUNNEL_REQUEST = 0x00090304,
    FSCTL_QUERY_SHARED_VIRTUAL_DISK_SUPPORT = 0x00090300,
    FSCTL_SVHDX_ASYNC_TUNNEL_REQUEST = 0x00090364,
    FSCTL_STORAGE_QOS_CONTROL = 0x00090350,
    ...
};

pattern SMB2IoctlRequestFlags = enum ULONG
{
    SMB20Ioctl = 0x00000000,
    SMB20IoctlIsFsctl = 0x00000001,
    ...
};

// 2.2.31.1   SRV_COPYCHUNK_COPY
type SrvCopychunkCopy
{
    array<byte> SourceKey
        with BinaryEncoding{Length = 24};

    ULONG ChunkCount;

    ULONG Reserved where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Reserved", "SMB2IoctlRequest", value);

    array<SrvCopyChunk> Chunks
        with BinaryEncoding{Length = ChunkCount};
};

// 2.2.31.1.1   SRV_COPYCHUNK
type SrvCopyChunk
{
    UINT64 SourceOffset;

    UINT64 TargetOffset;

    ULONG Length;

    ULONG Reserved;
};

// 2.2.31.2   SRV_READ_HASH Request
type SrvReadHashRequest
{
    SrvReadHashHashType HashType
        where ValidationCheck(InRange<SrvReadHashHashType>(value), null, DiagnosisLevel.Error,
            () => Format(INFRASTRUCTURE_STR_CHECK_VALUE, ["SMB2", "HashType", INFRASTRUCTURE_STR_TYPE, "SrvReadHashRequest", INFRASTRUCTURE_STR_MUST, "0x00000001", Utility.DecToHexFormat(value)]));

    SrvReadHashHashVersion HashVersion
        where ValidationCheck(InRange<SrvReadHashHashVersion>(value), null, DiagnosisLevel.Error,
            () => Format(INFRASTRUCTURE_STR_CHECK_ENUM_VALUE, ["SMB2", "HashVersion", INFRASTRUCTURE_STR_TYPE, "SrvReadHashRequest", INFRASTRUCTURE_STR_MUST, "0x00000001, 0x00000002", Utility.DecToHexFormat(value)]));

    SrvReadHashHashRetrievalType HashRetrievalType
        where ValidationCheck(InRange<SrvReadHashHashRetrievalType>(value), null, DiagnosisLevel.Error,
            () => Format(INFRASTRUCTURE_STR_CHECK_ENUM_VALUE, ["SMB2", "HashRetrievalType", INFRASTRUCTURE_STR_TYPE, "SrvReadHashRequest", INFRASTRUCTURE_STR_MUST, "0x00000001, 0x00000002", Utility.DecToHexFormat(value)]));

    ULONG Length;

    UINT64 Offset;
};

pattern SrvReadHashHashType = enum ULONG
{
    SrvHashTypePeerDist = 0x00000001,
    ...
};

pattern SrvReadHashHashVersion = enum ULONG
{
    SrvHashVer1 = 0x00000001,
    SrvHashVer2 = 0x00000002,
    ...
};

pattern SrvReadHashHashRetrievalType = enum ULONG
{
    SrvReadRetrieveHashBased = 0x00000001,
    SrvReadRetrieveFileBased = 0x00000002,
    ...
};

// 2.2.31.3   NETWORK_RESILIENCY_REQUEST Request
type NetworkResiliencyRequest
{
    ULONG Timeout;

    ULONG Reserved where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Reserved", "NetworkResiliencyRequest", value);
};

// 2.2.31.4   VALIDATE_NEGOTIATE_INFO Request
type ValidateNegotiateInfoRequest
{
    SMB2NegotiateRequestCapabilities Capabilities;

    GUID GUID;

    SMB2NegotiateRequestSecurityMode SecurityMode;

    USHORT DialectCount;

    array<SMB2NegotiateRequestDialects> Dialects with BinaryEncoding{Length = DialectCount};
};

// 2.2.32   SMB2 IOCTL Response
type SMB2IoctlResponse
{
    USHORT StructureSize where ValidationCheckValue(value == 49, null, true, ReferenceType.Type, "SMB2", "StructureSize", "SMB2IoctlResponse", 49, value);

    USHORT Reserved where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Reserved", "SMB2IoctlResponse", value);

    ULONG CtlCode with DisplayInfo{ToText = SMB2.CtlCodeToText};

    SMB2Fileid FileId where ValidationCheck((CtlCode != SMB2IoctlCtlCode.FSCTL_DFS_GET_REFERRALS && CtlCode != SMB2IoctlCtlCode.FSCTL_PIPE_WAIT) || (value.Persistent == InvalidFileId && value.Volatile == InvalidFileId), null, DiagnosisLevel.Error, "SMB2: The FileId field in type SMB2IoctlResponse must be set to 0xFFFFFFFFFFFFFFFF if the CtlCode field value is FsctlDFS_GET_REFERRALS or FsctlPIPE_WAIT.");

    ULONG InputOffset;

    ULONG InputCount;

    ULONG OutputOffset where ValidationCheck(value == 0 ||
                                             value == ((InputOffset + InputCount) % 8 != 0 ? ((InputOffset + InputCount) / 8 * 8 + 8) : InputCount + InputOffset),
                                null, "SMB2: The OutputOffset field in type SMB2IoctlResponse must be set to InputOffset + InputCount rounded up to a multiple of 8 if output data is returned. If no output data is returned for the FSCTL/IOCTL command that was issued, then this value should be set to zero.");

    ULONG OutputCount;

    ULONG Flags where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Flags", "SMB2IoctlResponse", value);

    ULONG Reserved2 where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Reserved2", "SMB2IoctlResponse", value);

    // Buffer part
    binary InputBuffer with Encoding{Offset = InputOffset - 64, Size = InputCount};
    
    ( [|OutputCount == 0|] Empty
        | [|CtlCode == SMB2IoctlCtlCode.FSCTL_PIPE_PEEK|] FSCTLPipePeekReply[OutputCount]
        | [|CtlCode == SMB2IoctlCtlCode.FSCTL_SRV_COPYCHUNK || CtlCode is SMB2IoctlCtlCode.FSCTL_SRV_COPYCHUNK_WRITE|] SrvCopychunkResponse
        | [|CtlCode == SMB2IoctlCtlCode.FSCTL_SRV_ENUMERATE_SNAPSHOTS|] SrvSnapshotArray
        | [|CtlCode == SMB2IoctlCtlCode.FSCTL_SRV_REQUEST_RESUME_KEY|] SrvRequestResumeKeyResponse
        | [|CtlCode == SMB2IoctlCtlCode.FSCTL_QUERY_NETWORK_INTERFACE_INFO|] NetworkInterfaceInfoResponse
        | [|CtlCode == SMB2IoctlCtlCode.FSCTL_GET_RETRIEVAL_POINTERS|] FSCTLGetRetrievalPointersReply
        | [|CtlCode == SMB2IoctlCtlCode.FSCTL_OFFLOAD_READ|] FSCTLOffloadReadOutput
        | [|CtlCode == SMB2IoctlCtlCode.FSCTL_OFFLOAD_WRITE|] FSCTLOffloadWriteOutput
        | [|CtlCode == SMB2IoctlCtlCode.FSCTL_FILE_LEVEL_TRIM|] FileLevelTrimOutput
        | [|CtlCode == SMB2IoctlCtlCode.FSCTL_VALIDATE_NEGOTIATE_INFO|] ValidateNegotiateInfoResponse
        
        // The SRV_READ_HASH response is returned to the client by the server in an SMB2 IOCTL Response for the FSCTL_SRV_READ_HASH request.
        //| [|CtlCode == SMB2IoctlCtlCode.FSCTL_SRV_READ_HASH && HashRetrievalType == SrvReadHashHashRetrievalType.SrvReadRetrieveHashBased|] ResponseForSrvHashRetrieveHashBased[HashVersion]
        //| [|CtlCode == SMB2IoctlCtlCode.FSCTL_SRV_READ_HASH && HashRetrievalType == SrvReadHashHashRetrievalType.SrvReadRetrieveFileBased|] ResponseForSrvHashRetrieveFileBased[HashVersion]
        | [|CtlCode == SMB2IoctlCtlCode.FSCTL_SRV_READ_HASH|] binary // leave this not decoded here, and decode it manually later
        | [|CtlCode == FSCC.CtlCode.FSCTLCreateOrGetObjectID|] FSCTLCreateOrGetObjectIDReply
        | [|CtlCode == FSCC.CtlCode.FSCTLFilesystemGetStatistics|] FSCTLFilesystemGetStatisticsReply
        | [|CtlCode == FSCC.CtlCode.FSCTLFindFilesBySID|] FSCTLFindFilesBySIDReply
        | [|CtlCode == FSCC.CtlCode.FSCTLGetCompression|] FSCTLGetCompressionReply
        | [|CtlCode == FSCC.CtlCode.FSCTLGetIntegrityInformation|] FSCTLGetIntegrityInformationReply
        | [|CtlCode == FSCC.CtlCode.FSCTLGetNTFSVolumeData|] FSCTLGetNtfsVolumeDataReply
        | [|CtlCode == FSCC.CtlCode.FSCTLGetObjectID|] FSCTLGetObjectIdReply
        | [|CtlCode == FSCC.CtlCode.FSCTLGetReparsePoint|] FSCTLGetReparsePointReply
        | [|CtlCode == FSCC.CtlCode.FSCTLQueryFatBPB|] FSCTLQueryFatBpbReply
        | [|CtlCode == FSCC.CtlCode.FSCTLQueryAllocatedRanges|] FSCTLQueryAllocatedRangesReply
        | [|CtlCode == FSCC.CtlCode.FSCTLQueryFileRegions|] FSCTLQueryFileRegionsReply
        | [|CtlCode == FSCC.CtlCode.FSCTLQueryOnDiskVolumeInfo|] FSCTLQueryOnDiskVolumeInfoReply
        | [|CtlCode == FSCC.CtlCode.FSCTLQuerySparingInfo|] FSCTLQuerySparingInfoReply
        | [|CtlCode == FSCC.CtlCode.FSCTLWriteUSNCloseRecord|] FSCTLWriteUSNCloseRecordReply
        | [|CtlCode == FSCC.CtlCode.FSCTLGetREFSVolumeData|] FSCTLGetREFSVolumeDataReply
        | [|CtlCode == FSCC.CtlCode.FSCTLReadFileUSNData|] FSCTLReadFileUSNDataResponse
        | binary
        | any ) Buffer with BinaryEncoding{MaxLength = OutputCount}, Encoding{Offset = OutputOffset - 64};
}

// 2.2.32.1   SRV_COPYCHUNK_RESPONSE
type SrvCopychunkResponse
{
    ULONG ChunksWritten;

    ULONG ChunkBytesWritten;

    ULONG TotalBytesWritten;
};

// 2.2.32.2   SRV_SNAPSHOT_ARRAY
type SrvSnapshotArray
{
    ULONG NumberOfSnapShots;

    ULONG NumberOfSnapShotsReturned;

    ULONG SnapShotArraySize;

    optional [|NumberOfSnapShotsReturned > 0|] array<string> SnapShots with BinaryEncoding{Length = NumberOfSnapShotsReturned};
    optional [|NumberOfSnapShotsReturned > 0|] NullTerminator Terminator;
};

pattern NullTerminator = ushort where value == 0;

// 2.2.32.3   SRV_REQUEST_RESUME_KEY Response
type SrvRequestResumeKeyResponse
{
    array<byte> ResumeKey
        with BinaryEncoding{Length = 24};

    ULONG ContextLength where ValidationCheckZero(value == 0, null, true, ReferenceType.Type, "SMB2", "ContextLength", "SrvRequestResumeKeyResponse", value);

    ULONG Context;
};

// 2.2.32.4.1   HASH_HEADER
type HashHeader
{
    HashHeaderHashType HashType;

    HashHeaderHashVersion HashVersion
        where ValidationCheck(InRange<HashHeaderHashVersion>(value), null, DiagnosisLevel.Error,
            () => Format(INFRASTRUCTURE_STR_CHECK_ENUM_VALUE, ["SMB2", "HashVersion", INFRASTRUCTURE_STR_TYPE, "HashHeader", INFRASTRUCTURE_STR_MUST, "0x00000001, 0x00000002", Utility.DecToHexFormat(value)]));

    FILETIME SourceFileChangeTime;

    UINT64 SourceFileSize;

    ULONG HashBlobLength;

    ULONG HashBlobOffset;

    USHORT Dirty;

    USHORT SourceFileNameLength;

    string SourceFileName 
        with BinaryEncoding{Length = SourceFileNameLength / 2};
};

pattern HashHeaderHashType = flags
{
    SrvHashTypePeerDist = 0x00000001
        with Documentation
            {Description = "Indicates that the hash is requested for branch caching as described in [MS-PCCRC]."},
    ...
}with Documentation {EmbeddedType = true};

pattern HashHeaderHashVersion = enum ULONG
{
    SrvHashVer1 = 0x00000001
        with Documentation {Description = "Branch cache version 1."},

    SrvHashVer2 = 0x00000002
        with Documentation {Description = "Branch cache version 2. This value is only applicable for servers that implement the SMB 3.x dialect family."},
    ...
};

type ContentInformationFile[ULONG BufferLength, uint? HashVersion, ulong? OffsetInRequest, ushort DialectRevision]
{
    // Content Information File
    // TDI 72581:if SRV_READ_HASH Request.Offset != 0, it is implicit that HASH_HEADER is not included.
    optional [|OffsetInRequest == null || OffsetInRequest == 0|] HashHeader Header;

    optional ([|HashVersion == HashHeaderHashVersion.SrvHashVer1|] ContentInformationVersion10
        | [|HashVersion == HashHeaderHashVersion.SrvHashVer2|] ContentInformationVersion20) ContentInformation 
        with BinaryEncoding{LeadPadding = (Header != nothing && (Header as HashHeader).HashBlobOffset > (36 + (Header as HashHeader).SourceFileNameLength)) ? ((Header as HashHeader).HashBlobOffset - 36 - (Header as HashHeader).SourceFileNameLength) * 8 : 0,
            Length = (Header != nothing) ? (InRange<SMB3xDialectFamily>(DialectRevision) ? (BufferLength - (Header as HashHeader).HashBlobOffset) : (Header as HashHeader).HashBlobLength) : BufferLength};
}

// 2.2.32.4.2   Response for SRV_HASH_RETRIEVE_HASH_BASED
type ResponseForSrvHashRetrieveHashBased[uint? HashVersion, ushort DialectRevision]
{
    UINT64 Offset;

    ULONG BufferLength;

    ULONG Reserved where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Reserved", "ResponseForSrvHashRetrieveHashBased", value);

    ContentInformationFile[BufferLength, HashVersion, null, DialectRevision] Buffer;
};

// 2.2.32.4.3   Response for SRV_HASH_RETRIEVE_FILE_BASED
type ResponseForSrvHashRetrieveFileBased[uint? HashVersion, ulong? OffsetInRequest, ushort DialectRevision]
{
    UINT64  FileDataOffset;
    
    UINT64 FileDataLength;
    
    ULONG BufferLength;
    
    ULONG Reserved where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Reserved", "ResponseForSrvHashRetrieveFileBased", value);
    
    ContentInformationFile[BufferLength, HashVersion, OffsetInRequest, DialectRevision] Buffer;
};

// 2.2.32.5   NETWORK_INTERFACE_INFO Response
type NetworkInterfaceInfoResponse
{
    ULONG Next;
    
    ULONG IfIndex;
    
    NetworkInterfaceInfoResponseCapability Capability;
    
    ULONG Reserved where ValidationCheckZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Reserved", "NetworkInterfaceInfoResponse", value);
    
    UINT64 LinkSpeed;
    
    SockAddrStorage SockAddrStorage;
    
    optional [|Next > 152|] array<byte> EntryPadding with BinaryEncoding{Length = Next - 152};
    optional [|Next != 0|] NetworkInterfaceInfoResponse NextEntry;
}

pattern NetworkInterfaceInfoResponseCapability = flags ULONG
{
    RssCapable = 0x00000001
        with Documentation
            {Description = "When set, specifies that the interface is RSS-capable."},
    
    RdmaCapable = 0x00000002
        with Documentation
            {Description = "When set, specifies that the interface is RDMA-capable."}
    ...
} with Documentation {EmbeddedType = true};

// 2.2.32.5.1   SOCKADDR_STORAGE
type SockAddrStorage
{
    AddressFamily Family;
            
    ([|Family is AddressFamily.InterNetwork|] SockAddrIn
     | [|Family is AddressFamily.InterNetworkV6|] SockAddrIn6) Buffer;
     
    binary Reserved
        with BinaryEncoding{Length = (128 - 2 - (Family == AddressFamily.InterNetwork ? 14: 26))};
}

pattern AddressFamily = enum USHORT
{
    InterNetwork = 0x0002,
    InterNetworkV6 = 0x0017,
    ...
};

// 2.2.32.5.1.1   SOCKADDR_IN
type SockAddrIn
{
    USHORT Port where ValidationCheckZero(value == 0, null, false, ReferenceType.Type, "SMB2", "Port", "SockAddrIn", value);

    IPv4Address IPv4Address;

    UINT64 Reserved where ValidationCheckZero(value == 0, null, false, ReferenceType.Type, "SMB2", "Reserved", "SockAddrIn", value);
} with BinaryEncodingDefaults{Endian = Endian.Big};

// 2.2.32.5.1.2   SOCKADDR_IN6
type SockAddrIn6
{
    USHORT Port where ValidationCheckZero(value == 0, null, false, ReferenceType.Type, "SMB2", "Port", "SockAddrIn6", value);
    
    ULONG FlowInfo where ValidationCheckZero(value == 0, null, false, ReferenceType.Type, "SMB2", "FlowInfo", "SockAddrIn6", value);

    IPv6Address IPv6Address;
            
    ULONG ScopeId where ValidationCheckZero(value == 0, null, false, ReferenceType.Type, "SMB2", "ScopeId", "SockAddrIn6", value);
} with BinaryEncodingDefaults{Endian = Endian.Big};
        
// 2.2.32.6   VALIDATE_NEGOTIATE_INFO Response
type ValidateNegotiateInfoResponse
{
    SMB2NegotiateResponseCapabilities Capability;
    
    GUID GUID;
    
    SMB2NegotiateResponseSecurityMode SecurityMode;
    
    SMB2NegotiateResponseDialectRevision Dialect;
}

// 2.2.33   SMB2 QUERY_DIRECTORY Request
type SMB2QueryDirectoryRequest
{
    USHORT StructureSize where ValidationCheckValue(value == 33, null, true, ReferenceType.Type, "SMB2", "StructureSize", "SMB2QueryDirectoryRequest", 33, value);

    SMB2QueryDirectoryRequestFileInformationClass FileInformationClass
        where ValidationCheck(InRange<SMB2QueryDirectoryRequestFileInformationClass>(value), null, DiagnosisLevel.Error,
            () => Format(INFRASTRUCTURE_STR_CHECK_ENUM_VALUE, ["SMB2", "FileInformationClass", INFRASTRUCTURE_STR_TYPE, "SMB2QueryDirectoryRequest", INFRASTRUCTURE_STR_MUST, "0x01, 0x02, 0x26, 0x03, 0x25, 0x0C", Utility.DecToHexFormat(value)]));

    SMB2QueryDirectoryRequestFlags Flags;

    ULONG FileIndex where ValidationCheck(((Flags & SMB2QueryDirectoryRequestFlags.SMB2IndexSpecified) > 0 && value != 0)
        || ((Flags & SMB2QueryDirectoryRequestFlags.SMB2IndexSpecified) == 0 && value == 0), null, DiagnosisLevel.Error, "SMB2: For the FileIndex in type SMB2QueryDirectoryRequest, if SMB2_INDEX_SPECIFIED is set in Flags, this value must be supplied. Otherwise, it must be set to zero and the server must ignore it.");

    SMB2Fileid FileId;

    USHORT FileNameOffset;

    USHORT FileNameLength where ValidationCheck((FileNameOffset == 0 && value == 0) || (FileNameOffset != 0 && value != 0), null, DiagnosisLevel.Error, 
        () => "SMB2: The FileNameLength in type SMB2QueryDirectoryRequest must be zero, not " + Utility.DecToHexFormat(value) + ".");

    ULONG OutputBufferLength;

    string Buffer with BinaryEncoding{Length = FileNameLength / 2, LeadPadding = FileNameOffset > 96 ? (FileNameOffset - 96) * 8 : 0};
};

pattern SMB2QueryDirectoryRequestFileInformationClass = enum BYTE
{
    FileDirectoryInformation = 0x01,
    FileFullDirectoryInformation = 0x02,
    FileIdFullDirectoryInformation = 0x26,
    FileBothDirectoryInformation = 0x03,
    FileIdBothDirectoryInformation = 0x25,
    FileNamesInformation = 0x0C,
    ...
};

pattern SMB2QueryDirectoryRequestFlags = flags BYTE
{
   SMB2RestartScans = 0x01
       with Documentation
          {Description = "The server MUST restart the enumeration from the beginning, but the search pattern is not changed."},
   SMB2ReturnSingleEntry = 0x02
       with Documentation
          {Description = "The server MUST only return the first entry of the search results."},
   SMB2IndexSpecified = 0x04
       with Documentation
          {Description = "The server SHOULDwindows-based servers do not support resuming an enumeration at a specified FileIndex. The server will ignore this flag. return entries beginning at the byte number specified by FileIndex."},
   SMB2Reopen = 0x10
       with Documentation
          {Description = "The server MUST restart the enumeration from the beginning, and the search pattern MUST be changed to the provided value. This often involves silently closing and reopening the directory on the server side."},
    ...
} with Documentation {EmbeddedType = true};

// 2.2.34   SMB2 QUERY_DIRECTORY Response
type SMB2QueryDirectoryResponse[optional byte QueryInfoClass]
{
    USHORT StructureSize where ValidationCheckValue(value == 9, null, true, ReferenceType.Type, "SMB2", "StructureSize", "SMB2QueryDirectoryResponse", 9, value);

    USHORT OutputBufferOffset;

    ULONG OutputBufferLength;

    ([|OutputBufferLength > 0 && QueryInfoClass != nothing && (QueryInfoClass as byte) is SMB2QueryDirectoryRequestFileInformationClass|] SMB20InfoFileBuffer[QueryInfoClass as byte]
        |binary) Buffer
        with BinaryEncoding{MaxLength = OutputBufferLength}, Encoding{Offset = OutputBufferOffset - 64};
};

// 2.2.35   SMB2 CHANGE_NOTIFY Request
type SMB2ChangeNotifyRequest
{
    USHORT StructureSize where ValidationCheckValue(value == 32, null, true, ReferenceType.Type, "SMB2", "StructureSize", "SMB2WriteResponse", 32, value);

    SMB2ChangeNotifyRequestFlags Flags;

    ULONG OutputBufferLength;

    SMB2Fileid FileId;

    SMB2ChangeNotifyRequestCompletionFilter CompletionFilter;

    ULONG Reserved where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Reserved", "SMB2ChangeNotifyRequest", value);
};

pattern SMB2ChangeNotifyRequestFlags = flags USHORT
{
    SMB2WatchTree = 0x0001
        with Documentation
               {Description = "The request MUST monitor changes on any file or directory contained beneath the directory specified by FileId."},
    ...
}with Documentation {EmbeddedType = true};

pattern SMB2ChangeNotifyRequestCompletionFilter =  flags ULONG
{
    FileNotifyChangeFileName = 0x00000001
        with Documentation
            {Description = "The client is notified if a file-name changes."},
    FileNotifyChangeDirName = 0x00000002
        with Documentation
            {Description = "The client is notified if a directory name changes."},
    FileNotifyChangeAttributes = 0x00000004
        with Documentation
            {Description = "The client is notified if a file's attributes change. Possible file attribute values are specified in [MS-FSCC]."},
    FileNotifyChangeSize = 0x00000008
        with Documentation
            {Description = "The client is notified if a file's size changes."},
    FileNotifyChangeLastWrite = 0x00000010
        with Documentation
            {Description = "The client is notified if the last write time of a file changes."},
    FileNotifyChangeLastAccess = 0x00000020
        with Documentation
            {Description = "The client is notified if the last access time of a file changes."},
    FileNotifyChangeCreation = 0x00000040
        with Documentation
            {Description = "The client is notified if the creation time of a file changes."},
    FileNotifyChangeEa = 0x00000080
        with Documentation
            {Description = "The client is notified if a file's extended attributes(EAs) change."},
    FileNotifyChangeSecurity = 0x00000100
        with Documentation
            {Description = "The client is notified of a file's access control list(ACL) settings change."},
    FileNotifyChangeStreamName = 0x00000200
        with Documentation
            {Description = "The client is notified if a named stream is added to a file."},
    FileNotifyChangeStreamSize = 0x00000400
        with Documentation
            {Description = "The client is notified if the size of a named stream is changed."},
    FileNotifyChangeStreamWrite = 0x00000800
        with Documentation
            {Description = "The client is notified if a named stream is modified."},
    ...
} with Documentation {EmbeddedType = true};

// 2.2.36   SMB2 CHANGE_NOTIFY Response
type SMB2ChangeNotifyResponse
{
    USHORT StructureSize where ValidationCheck(value == 9, null, DiagnosisLevel.Error, 
        () => "SMB2: The StructureSize in type SMB2ChangeNotifyResponse must be set to 9, not " + Utility.DecToHexFormat(value) + ".");

    USHORT OutputBufferOffset;

    ULONG OutputBufferLength;

    optional [|OutputBufferLength > 0|] array<FileNotifyInformation> Buffer
        where ValidationCheck(GetLastOffset() == 0, null, DiagnosisLevel.Error, "SMB2: The NextEntryOffset field in the last entry of FileNotifyInformation array must be zero, not " + (GetLastOffset() as string) + ".")
        with BinaryEncoding{MaxLength = OutputBufferLength, LeadPadding = OutputBufferOffset > 72 ? (OutputBufferOffset - 72) * 8 : 0};

    uint GetLastOffset()
    {
        if (Buffer != nothing)
        {
            var buffer = Buffer as array<FileNotifyInformation>;
            if (buffer.Count > 0)
            {
                return buffer[buffer.Count - 1].NextEntryOffset;
            }
        }
        return 0;
    }
};

// 2.2.37   SMB2 QUERY_INFO Request
type SMB2QueryInfoRequest
{
    USHORT StructureSize where ValidationCheckValue(value == 41, null, true, ReferenceType.Type, "SMB2", "StructureSize", "SMB2QueryInfoRequest", 41, value);

    SMB2QueryInfoRequestInfoType InfoType
        where ValidationCheckEnumValue(InRange<SMB2QueryInfoRequestInfoType>(value), null, true, ReferenceType.Type, "SMB2", "InfoType", "SMB2QueryInfoRequest", "0x01, 0x02, 0x03, 0x04", value);

    ([|InfoType == SMB2QueryInfoRequestInfoType.SMB20InfoFile|] FileInformationClasses
       | [|InfoType == SMB2QueryInfoRequestInfoType.SMB20InfoFilesystem|] FileSystemInformationClasses
       | BYTE) FileInfoClass where ValidationCheck(InfoType != SMB2QueryInfoRequestInfoType.SMB20InfoSecurity && InfoType != SMB2QueryInfoRequestInfoType.SMB20InfoQuota || value == 0, null, DiagnosisLevel.Error, 
       () => "SMB2: SMB2QueryInfoRequest.FileInfoClass, for security queries, this field must be set to zero. For quota queries, this field should be set to zero, not " + Utility.DecToHexFormat(value) + ".")
       with DisplayInfo{ToText = FileInfoClassToText};

    ULONG OutputBufferLength
        where ValidationCheck((FileInfoClass != FileInformationClasses.FileFullEaInformation) || OutputBufferLength == 0, null, "SMB2: The OutputBufferLength field in type SMB2QueryInfoRequest must be set to zero for a FileFullEaInformation query.");

    USHORT InputBufferOffset;

    USHORT Reserved where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Reserved", "SMB2QueryInfoRequest", value);

    ULONG InputBufferLength where ValidationCheck(InfoType == SMB2QueryInfoRequestInfoType.SMB20InfoQuota || FileInfoClass == FileInformationClasses.FileFullEaInformation || value == 0, null, DiagnosisLevel.Error, 
        () => "SMB2: The InputBufferLength in type SMB2QueryInfoRequest, for FileFullEaInformation requests, this must be set to the length of the user-supplied EA list specified in [MS-FSCC]. For other information queries, this field must be set to zero, not " + Utility.DecToHexFormat(value) + ".");

    ([|InfoType == SMB2QueryInfoRequestInfoType.SMB20InfoSecurity|] SMB2QueryInfoRequestAdditionalInformation
     | [|FileInfoClass == FileInformationClasses.FileFullEaInformation|] ULONG
     | ZeroUint) AdditionalInformation;

    // Future Reference: Add ValidationCheck after bug 27596 is fixed
    SMB2QueryInfoRequestFlags Flags; // where ValidationCheck(FileInfoClass == FileInformationClasses.FileFullEaInformation || value == 0, null, "SMB2: For the Flags int type SMB2QueryInfoRequest, if the query is not a FileFullEaInformation query, this field must be set to zero, not " + Utility.DecToHexFormat(value) + ".")

    SMB2Fileid FileId;

    ([|InputBufferLength > 0 && InfoType == SMB2QueryInfoRequestInfoType.SMB20InfoQuota|] SMB2QueryQuotaInfo
        | [|InputBufferLength > 0 && FileInfoClass == FileInformationClasses.FileFullEaInformation|] FileGetEaInformationList
        /* note<64> Windows clients send a 1-byte buffer of 0 when InputBufferLength is set to 0.
         * So the length of Buffer is not simply equal to InputBufferLength when InputBufferLength is set to 0.
         */
        | binary) Buffer with BinaryEncoding{MaxLength = InputBufferLength, LeadPadding = InputBufferOffset > 104 ? (InputBufferOffset - 104) * 8 : 0};

    string FileInfoClassToText(any data)
    {
        if (InfoType == SMB2QueryInfoRequestInfoType.SMB20InfoFile)
        {
            return FileInformationClassesToText(data as byte) + "(" + (data as string) + ")";
        }
        else if (InfoType == SMB2QueryInfoRequestInfoType.SMB20InfoFilesystem)
        {
            return FileSystemInformationClassesToText(data as byte) + "(" + (data as string) + ")";
        }
        else
        {
            return data as string;
        }
    }
};

pattern SMB2QueryInfoRequestInfoType = enum BYTE
{
    SMB20InfoFile = 0x01,
    SMB20InfoFilesystem = 0x02,
    SMB20InfoSecurity = 0x03,
    SMB20InfoQuota = 0x04,
    ...
};

pattern SMB2QueryInfoRequestFlags = flags ULONG
{
    SLRestartScan = 0x00000001
        with Documentation
            {Description = "Restart the scan for EAs from the beginning."},
    SLReturnSingleEntry = 0x00000002
        with Documentation
            {Description = "Return a single EA entry in the response buffer."},
    SLIndexSpecified = 0x00000004
        with Documentation {Description = "The caller has specified an EA index."},
    ...
} with Documentation {EmbeddedType = true};

pattern SMB2QueryInfoRequestAdditionalInformation = flags ULONG
{
    OwnerSecurityInformation = 0x00000001
        with Documentation
            {Description = "The client is querying the owner from the security descriptor of the file or named pipe."},
    GroupSecurityInformation = 0x00000002
        with Documentation
            {Description = "The client is querying the group from the security descriptor of the file or named pipe."},
    DaclSecurityInformation = 0x00000004
        with Documentation
            {Description = "The client is querying the discretionary access control list from the security descriptor of the file or named pipe."},
    SaclSecurityInformation = 0x00000008
        with Documentation
            {Description = "The client is querying the system access control list from the security descriptor of the file or named pipe."},
    LabelSecurityInformation = 0x00000010
        with Documentation
            {Description = "The client is querying the integrity label from the security descriptor of the file or named pipe."}
    ...
} with Documentation {EmbeddedType = true};

// 2.2.37.1   SMB2_QUERY_QUOTA_INFO
type SMB2QueryQuotaInfo
{
    BOOLEAN ReturnSingle;

    BOOLEAN RestartScan;

    USHORT Reserved where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Reserved", "SMB2QueryQuotaInfo", value);

    ULONG SidListLength;

    ULONG StartSidLength;

    ULONG StartSidOffset;

    ([|SidListLength > 0|] FileGetQuotaInformationList
     | [|StartSidLength > 0|] SID
     | Empty) SidBuffer with Encoding{Offset = StartSidOffset + 16};
};

// 2.2.38   SMB2 QUERY_INFO Response
type SMB2QueryInfoResponse[optional byte QueryInfoType, optional byte QueryInfoClass]
{
    USHORT StructureSize where ValidationCheckValue(value == 9, null, true, ReferenceType.Type, "SMB2", "StructureSize", "SMB2QueryInfoResponse", 9, value);

    USHORT OutputBufferOffset;

    ULONG OutputBufferLength;

    ([|OutputBufferLength == 0|] Empty
        | [|QueryInfoType == nothing || QueryInfoClass == nothing|] binary
        | [|QueryInfoType == SMB2QueryInfoRequestInfoType.SMB20InfoFile|] SMB20InfoFileBuffer[QueryInfoClass as byte]
        | [|QueryInfoType == SMB2QueryInfoRequestInfoType.SMB20InfoFilesystem|] SMB20InfoFilesystemBuffer[QueryInfoClass as byte]
        | [|QueryInfoType == SMB2QueryInfoRequestInfoType.SMB20InfoSecurity|] SECURITY_DESCRIPTOR_NonRpc
        | [|QueryInfoType == SMB2QueryInfoRequestInfoType.SMB20InfoQuota|] FileQuotaInformationList
        | any) Buffer
        // Can't use ReportInsufficientTruncation in where clause
        with BinaryEncoding{MaxLength = OutputBufferLength, LeadPadding = OutputBufferOffset > 72 ? (OutputBufferOffset - 72) * 8 : 0};
};

// Comment off the list type temporarily for UI freeze issue.
type SMB20InfoFileBuffer[byte AdditionalInformation]
{
    ([|AdditionalInformation == FileInformationClasses.FileDirectoryInformation|] FileDirectoryInformationList
    | [|AdditionalInformation == FileInformationClasses.FileFullDirectoryInformation|] FileFullDirectoryInformationList
    | [|AdditionalInformation == FileInformationClasses.FileBothDirectoryInformation|] FileBothDirectoryInformationList
    | [|AdditionalInformation == FileInformationClasses.FileBasicInformation|] FileBasicInformation
    | [|AdditionalInformation == FileInformationClasses.FileStandardInformation|] FileStandardInformation
    | [|AdditionalInformation == FileInformationClasses.FileInternalInformation|] FileInternalInformation
    | [|AdditionalInformation == FileInformationClasses.FileEaInformation|] FileEaInformation
    | [|AdditionalInformation == FileInformationClasses.FileAccessInformation|] FileAccessInformation
    | [|AdditionalInformation == FileInformationClasses.FileNameInformation|] FileNameInformation
    | [|AdditionalInformation == FileInformationClasses.FileRenameInformation|] FileRenameInformationForSMB2
    | [|AdditionalInformation == FileInformationClasses.FileLinkInformation|] FileLinkInformationForSMB2
    | [|AdditionalInformation == FileInformationClasses.FileNamesInformation|] FileNamesInformationList
    | [|AdditionalInformation == FileInformationClasses.FileDispositionInformation|] FileDispositionInformation
    | [|AdditionalInformation == FileInformationClasses.FilePositionInformation|] FilePositionInformation
    | [|AdditionalInformation == FileInformationClasses.FileFullEaInformation|] FileFullEaInformation
    | [|AdditionalInformation == FileInformationClasses.FileModeInformation|] FileModeInformation
    | [|AdditionalInformation == FileInformationClasses.FileAlignmentInformation|] FileAlignmentInformation
    | [|AdditionalInformation == FileInformationClasses.FileAllInformation|] FileAllInformation
    | [|AdditionalInformation == FileInformationClasses.FileAllocationInformation|] FileAllocationInformation
    | [|AdditionalInformation == FileInformationClasses.FileEndOfFileInformation|] FileEndOfFileInformation
    | [|AdditionalInformation == FileInformationClasses.FileAlternateNameInformation|] FileAlternateNameInformation
    | [|AdditionalInformation == FileInformationClasses.FileStreamInformation|] FileStreamInformationList
    | [|AdditionalInformation == FileInformationClasses.FilePipeInformation|] FilePipeInformation
    | [|AdditionalInformation == FileInformationClasses.FilePipeLocalInformation|] FilePipeLocalInformation
    | [|AdditionalInformation == FileInformationClasses.FilePipeRemoteInformation|] FilePipeRemoteInformation
    | [|AdditionalInformation == FileInformationClasses.FileMailslotQueryInformation|] FileMailslotQueryInformation
    | [|AdditionalInformation == FileInformationClasses.FileMailslotSetInformation|] FileMailslotSetInformation
    | [|AdditionalInformation == FileInformationClasses.FileCompressionInformation|] FileCompressionInformation
    | [|AdditionalInformation == FileInformationClasses.FileObjectIdInformation|] FileObjectIdInformationType
    | [|AdditionalInformation == FileInformationClasses.FileQuotaInformation|] FileQuotaInformationList
    | [|AdditionalInformation == FileInformationClasses.FileReparsePointInformation|] FileReparsePointInformation
    | [|AdditionalInformation == FileInformationClasses.FileNetworkOpenInformation|] FileNetworkOpenInformation
    | [|AdditionalInformation == FileInformationClasses.FileAttributeTagInformation|] FileAttributeTagInformation
    | [|AdditionalInformation == FileInformationClasses.FileIdBothDirectoryInformation|] FileIdBothDirectoryInformationList
    | [|AdditionalInformation == FileInformationClasses.FileIdFullDirectoryInformation|] FileIdFullDirectoryInformationList
    | [|AdditionalInformation == FileInformationClasses.FileValidDataLengthInformation|] FileValidDataLengthInformation
    | [|AdditionalInformation == FileInformationClasses.FileShortNameInformation|] FileShortNameInformation
    | [|AdditionalInformation == FileInformationClasses.FileSfioReserveInformation|] FileSfioReserveInformation
    | [|AdditionalInformation == FileInformationClasses.FileHardLinkInformation|] FileHardLinkInformation
    | [|AdditionalInformation == FileInformationClasses.FileIdGlobalTxDirectoryInformation|] FileIdGlobalTxDirectoryInformationList
    | [|AdditionalInformation == FileInformationClasses.FileStandardLinkInformation|] FileStandardLinkInformation
    | [|AdditionalInformation == FileInformationClasses.FileIdInformation|] FileIdInformation) SMB20InfoFile;
}

pattern FileObjectIdInformationType = FileObjectIdInformationType2 | FileObjectIdInformationType1;

type SMB20InfoFilesystemBuffer[byte AdditionalInformation]
{
    ([|AdditionalInformation == FileSystemInformationClasses.FileFsVolumeInformation|] FileFsVolumeInformation
    | [|AdditionalInformation == FileSystemInformationClasses.FileFsLabelInformation|] FileFsLabelInformation
    | [|AdditionalInformation == FileSystemInformationClasses.FileFsSizeInformation|] FileFsSizeInformation
    | [|AdditionalInformation == FileSystemInformationClasses.FileFsDeviceInformation|] FileFsDeviceInformation
    | [|AdditionalInformation == FileSystemInformationClasses.FileFsAttributeInformation|] FileFsAttributeInformation
    | [|AdditionalInformation == FileSystemInformationClasses.FileFsControlInformation|] FileFsControlInformation
    | [|AdditionalInformation == FileSystemInformationClasses.FileFsFullSizeInformation|] FileFsFullSizeInformation
    | [|AdditionalInformation == FileSystemInformationClasses.FileFsObjectIdInformation|] FileFsObjectIdInformation
    | [|AdditionalInformation == FileSystemInformationClasses.FileFsDriverPathInformation|] FileFsDriverPathInformation
    | [|AdditionalInformation == FileSystemInformationClasses.FileFsSectorSizeInformation|] FileFsSectorSizeInformation) SMB20InfoFilesystem;
}

// 2.2.39   SMB2 SET_INFO Request
type SMB2SetInfoRequest
{
    USHORT StructureSize where ValidationCheckValue(value == 33, null, true, ReferenceType.Type, "SMB2", "StructureSize", "SMB2SetInfoRequest", 33, value);

    SMB2SetInfoRequestInfoType InfoType where ValidationCheckEnumValue(InRange<SMB2SetInfoRequestInfoType>(value), null, false, ReferenceType.Type, "SMB2", "InfoType", "SMB2SetInfoRequest", "0x01, 0x02, 0x03, 0x04", value);

    ([|InfoType == SMB2QueryInfoRequestInfoType.SMB20InfoFile|] FileInformationClasses
       | [|InfoType == SMB2QueryInfoRequestInfoType.SMB20InfoFilesystem|] FileSystemInformationClasses
       | BYTE) FileInfoClass where ValidationCheck((InfoType == SMB2SetInfoRequestInfoType.SMB20InfoFile && value in {FileInformationClasses.FileAllocationInformation,
                                                                                                                FileInformationClasses.FileBasicInformation,
                                                                                                                FileInformationClasses.FileDispositionInformation,
                                                                                                                FileInformationClasses.FileEndOfFileInformation,
                                                                                                                FileInformationClasses.FileFullEaInformation,
                                                                                                                FileInformationClasses.FileLinkInformation,
                                                                                                                FileInformationClasses.FileModeInformation,
                                                                                                                FileInformationClasses.FilePipeInformation,
                                                                                                                FileInformationClasses.FilePositionInformation,
                                                                                                                FileInformationClasses.FileRenameInformation,
                                                                                                                FileInformationClasses.FileShortNameInformation,
                                                                                                                FileInformationClasses.FileValidDataLengthInformation}) || 
                                            (InfoType == SMB2SetInfoRequestInfoType.SMB20InfoFilesystem && value in {FileSystemInformationClasses.FileFsControlInformation,
                                                                                                                      FileSystemInformationClasses.FileFsObjectIdInformation}) || 
                                            (InfoType in [SMB2SetInfoRequestInfoType.SMB20InfoQuota, SMB2SetInfoRequestInfoType.SMB20InfoSecurity] && value == 0),
                                null, "SMB2: The FileInfoClass field in type SMB2SetInfoRequest is an undefined value. Please refer to SMB2 SET_INFO Request in Technical Document [MS-SMB2].");

    ULONG BufferLength;

    USHORT BufferOffset;

    USHORT Reserved where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Reserved", "SMB2SetInfoRequest", value);

    ([|InfoType == SMB2SetInfoRequestInfoType.SMB20InfoSecurity|] SMB2SetInfoRequestAdditionalInformation
     | ZeroUint) AdditionalInformation
        with DisplayInfo{ToText = AdditionalInformationToText};

    SMB2Fileid FileId;

    ([|BufferLength == 0|] Empty
     | [|InfoType == SMB2SetInfoRequestInfoType.SMB20InfoFile|] SMB20InfoFileBuffer[FileInfoClass]
     | [|InfoType == SMB2SetInfoRequestInfoType.SMB20InfoFilesystem|] SMB20InfoFilesystemBuffer[FileInfoClass]
     | [|InfoType == SMB2SetInfoRequestInfoType.SMB20InfoSecurity|] SECURITY_DESCRIPTOR_NonRpc
     | [|InfoType == SMB2SetInfoRequestInfoType.SMB20InfoQuota|] FileQuotaInformationList
     | binary) Buffer with BinaryEncoding{MaxLength = BufferLength, LeadPadding = BufferOffset > 96 ? (BufferOffset - 96) * 8 : 0};

    string AdditionalInformationToText(any data)
    {
        if (InfoType == SMB2SetInfoRequestInfoType.SMB20InfoSecurity)
        {
            return EnumToString<SMB2.SMB2SetInfoRequestAdditionalInformation>(data as SMB2.SMB2SetInfoRequestAdditionalInformation);
        }
        else
        {
            return data.ToString();
        }
    }
};

pattern SMB2SetInfoRequestInfoType = enum BYTE
{
    SMB20InfoFile = 0x01,
    SMB20InfoFilesystem = 0x02,
    SMB20InfoSecurity = 0x03,
    SMB20InfoQuota = 0x04,
    ...
};

pattern SMB2SetInfoRequestAdditionalInformation = flags uint
{
    OwnerSecurityInformation = 0x00000001
        with Documentation
            {Description = "The client is setting the owner in the security descriptor of the file or named pipe."},
    GroupSecurityInformation = 0x00000002
        with Documentation
            {Description = "The client is setting the group in the security descriptor of the file or named pipe."},
    DaclSecurityInformation = 0x00000004
        with Documentation
            {Description = "The client is setting the discretionary access control list in the security descriptor of the file or named pipe."},
    SaclSecurityInformation = 0x00000008
        with Documentation
            {Description = "The client is setting the system access control list in the security descriptor of the file or named pipe."},
    LabelSecurityInformation = 0x00000010
        with Documentation
           {Description = "The client is setting the integrity label in the security descriptor of the file or named pipe."},
    ...
}with Documentation {EmbeddedType = true};

// 2.2.40   SMB2 SET_INFO Response 
type SMB2SetInfoResponse
{
    USHORT StructureSize where ValidationCheckValue(value == 2, null, true, ReferenceType.Type, "SMB2", "StructureSize", "SMB2SetInfoResponse", 2, value);
};

// 2.2.41   SMB2 TRANSFORM_HEADER
type SMB2TransformHeader[ushort DialectRevision, ushort CipherId]
{
    ULONG ProtocolId where ValidationCheckValue(value == 0xFD534D42, null, true, ReferenceType.Type, "SMB2", "ProtocolId", "SMB2TransformHeader", "(in network order) 0xFD, 'S', 'M', and 'B'", value)
        with BinaryEncoding {Endian = Endian.Big};

    binary Signature with BinaryEncoding{Length = 16};
 
    (
        [|DialectRevision == SMB2NegotiateResponseDialectRevision.SMB311DialectRevisionNumber && CipherId == SMB2EncryptionCapabilitiesCiphers.AES128CCM|] SMB2EncryptionAES128CCMNonce |
        [|DialectRevision == SMB2NegotiateResponseDialectRevision.SMB311DialectRevisionNumber && CipherId == SMB2EncryptionCapabilitiesCiphers.AES128GCM|] SMB2EncryptionAES128GCMNonce |
        [|DialectRevision != SMB2NegotiateResponseDialectRevision.SMB311DialectRevisionNumber && (PeekUShort(stream, 42 * 8, Endian.Little) == SMB2TransformHeaderEncryptionAlgorithm.SMB2EncryptionAes128Ccm)|] SMB2EncryptionAES128CCMNonce |
        binary
    ) Nonce with BinaryEncoding{Length = 16};
    
    ULONG OriginalMessageSize;

    USHORT Reserved where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Reserved", "SMB2TransformHeader", value);

    optional [|DialectRevision == SMB2NegotiateResponseDialectRevision.SMB311DialectRevisionNumber|] SMB2TransformHeaderFlags Flags
        where ValidationCheckEnumValue(value == nothing || InRange<SMB2TransformHeaderFlags>(value as USHORT), null, true, ReferenceType.Type,
            "SMB2", "Flags", "SMB2TransformHeader", "0x0001", value);
    optional [|DialectRevision != SMB2NegotiateResponseDialectRevision.SMB311DialectRevisionNumber|] SMB2TransformHeaderEncryptionAlgorithm EncryptionAlgorithm
        where ValidationCheck(value == nothing ||
            ((DialectRevision != SMB2NegotiateResponseDialectRevision.SMB30DialectRevisionNumber) && (DialectRevision != SMB2NegotiateResponseDialectRevision.SMB302DialectRevisionNumber)) ||
            InRange<SMB2TransformHeaderEncryptionAlgorithm>(value as USHORT), null, DiagnosisLevel.Error, 
            () => Format(INFRASTRUCTURE_STR_CHECK_VALUE, ["SMB2", "EncryptionAlgorithm", INFRASTRUCTURE_STR_TYPE, "SMB2TransformHeader", INFRASTRUCTURE_STR_MUST, "0x00000001", Utility.DecToHexFormat(value)]));
    
    UINT64 SessionId;
};

pattern SMB2TransformHeaderFlags = enum USHORT
{
    Encrypted = 0x0001,
    ...
};

type SMB2EncryptionAES128CCMNonce
{
    binary AES128CCM_Nonce with BinaryEncoding{Length = 11};

    binary Reserved with BinaryEncoding{Length = 5};
}

type SMB2EncryptionAES128GCMNonce
{
    binary AES128GCM_Nonce with BinaryEncoding{Length = 12};

    binary Reserved with BinaryEncoding{Length = 4};
}
               
pattern SMB2TransformHeaderEncryptionAlgorithm = enum USHORT
{
    SMB2EncryptionAes128Ccm = 0x0001,
    ...
};

// 2.2.42 SMB2 COMPRESSION_TRANSFORM_HEADER
type SMB2CompressedTransformHeader
{
    ULONG ProtocolId where ValidationCheckValue(value == 0xFC534D42, null, true, ReferenceType.Type, "SMB2", "ProtocolId", "SMB2CompressedTransformHeader", "(in network order) 0xFC, 'S', 'M', and 'B'", value)
        with BinaryEncoding {Endian = Endian.Big};
    ULONG OriginalCompressedSegmentSize;
    SMB2CompressionCapabilitiesCompressionAlgorithms CompressionAlgorithm
        where ValidationCheckEnumValue(InRange<SMB2CompressionCapabilitiesCompressionAlgorithms>(value), null, true, ReferenceType.Type,
            "SMB2", "CompressionAlgorithm", "SMB2CompressedTransformHeader", "0x0000, 0x0001, 0x0002, 0x0003", value);
    USHORT Reserved where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB2", "Reserved", "SMB2CompressedTransformHeader", value);
    ULONG Offset;
};

// -------------------------------------------
// Helper function

// Get the binary value of ProtocolId from NBTSS.SessionService message
binary GetProtocolIdBin(NBTSS.SessionService m)
{
    switch (m.Trailer)
    {
        case p: SessionMessagePacket =>
            if (p.UserData.Count > 4)
            {
                return p.UserData.Segment(0, 4);
            }
        default =>;
    }
    return $[];
}

// Get the binary value of ProtocolId from NBTSS.SessionService message
binary GetProtocolIdBin(SMBTransport.TransportPacket m)
{
    if (m.SMBMessage.Count > 4)
    {
        return m.SMBMessage.Segment(0, 4);
    }
    return $[];
}

// List of ignored error code for ErrorCodeIf check
array<uint> IgnoredErrorCode = [Smb2StatusValue.STATUS_MORE_PROCESSING_REQUIRED, // STATUS_MORE_PROCESSING_REQUIRED
                                Smb2StatusValue.STATUS_FS_DRIVER_REQUIRED];  // STATUS_FS_DRIVER_REQUIRED

// Defined for DisplayInfo.
string StatusToText(SMB2PacketHeader header)
{
    if (header.Status is status:ERREF.NTSTATUS)
    {
        return NTStatusLEToString(status);
    }    
    return "";
}

string NTStatusLEToString(ERREF.NTSTATUS status)
{
    return status.Value == 0 ? "Success": NtStatusValuesToText(status.Value);
}

optional uint GetStatusCode(SMB2PacketHeader header)
{
    if (header.Status is nts:ERREF.NTSTATUS)
    {
        return nts.Value;
    }
    return nothing;
}

// Workaround for bug#75557
ERREF.NTSTATUS AddTwoOptionalNTStatus(optional ERREF.NTSTATUS a, optional ERREF.NTSTATUS b)
{
    assert !(a == nothing && b == nothing) && !(a != nothing && b != nothing);
    if (a != nothing)
    {
        return a as ERREF.NTSTATUS;
    }
    else
    {
        return b as ERREF.NTSTATUS;
    }
}

ERREF.NTSTATUS AddThreeOptionalNTStatus(optional ERREF.NTSTATUS a, optional ERREF.NTSTATUS b, optional ERREF.NTSTATUS c)
{
    assert !(a == nothing && b == nothing && c == nothing) && !(a != nothing && b != nothing && c != nothing);
    if (a != nothing)
    {
        return a as ERREF.NTSTATUS;
    }
    else if (b != nothing)
    {
        return b as ERREF.NTSTATUS;
    }
    else
    {
        return c as ERREF.NTSTATUS;
    }
}

optional UINT64 AddTwoOptionalUint64(optional UINT64 a, optional UINT64 b)
{
    if (a == nothing && b == nothing)
    {
        return nothing;
    }
    else if (a == nothing)
    {
        return b as UINT64;
    }
    else if (b == nothing)
    {
        return a as UINT64;
    }
    else
    {
        return (a as UINT64) + (b as UINT64);
    }
}

const map<byte, string> InfoTypeMap =
    {
        0x01 -> "File",
        0x02 -> "FileSystem",
        0x03 -> "Security",
        0x04 -> "Quota",
    };

string InfoTypeToText(byte infoType)
{
    if (infoType in InfoTypeMap)
    {
        return InfoTypeMap[infoType];
    }
    else
    {
        return "Unknown(" + (infoType as string) + ")";
    }
}

string FileInfoClassToText(byte infoType, byte infoClass)
{
    if (infoType == 1) // SMB20InfoFile
    {
        return FileInformationClassesToText(infoClass);
    }
    else if (infoType == 2) // SMB20InfoFile
    {
        return FileSystemInformationClassesToText(infoClass);
    }
    else
    {
        return infoClass as string;
    }
}

const map<uint, string> CtlCodeMap = 
{
    0x00060194 -> "FSCTL_DFS_GET_REFERRALS",
    0x0011400C -> "FSCTL_PIPE_PEEK",
    0x00110018 -> "FSCTL_PIPE_WAIT",
    0x0011C017 -> "FSCTL_PIPE_TRANSCEIVE",
    0x001440F2 -> "FSCTL_SRV_COPYCHUNK",
    0x00144064 -> "FSCTL_SRV_ENUMERATE_SNAPSHOTS",
    0x00140078 -> "FSCTL_SRV_REQUEST_RESUME_KEY",
    0x001441BB -> "FSCTL_SRV_READ_HASH",
    0x001480F2 -> "FSCTL_SRV_COPYCHUNK_WRITE",
    0x001401D4 -> "FSCTL_LMR_REQUEST_RESILIENCY",
    0x001401FC -> "FSCTL_QUERY_NETWORK_INTERFACE_INFO",
    0x000900A4 -> "FSCTL_SET_REPARSE_POINT",
    0x001400EC -> "FSCTL_LMR_SET_LINK_TRACKING_INFORMATION",
    0x000601B0 -> "FSCTL_DFS_GET_REFERRALS_EX",
    0x00090073 -> "FSCTL_GET_RETRIEVAL_POINTERS",
    0x00094264 -> "FSCTL_OFFLOAD_READ",
    0x00098268 -> "FSCTL_OFFLOAD_WRITE",
    0x00098208 -> "FSCTL_FILE_LEVEL_TRIM",
    0x00140204 -> "FSCTL_VALIDATE_NEGOTIATE_INFO",
    0x00090300 -> "FSCTL_QUERY_SHARED_VIRTUAL_DISK_SUPPORT",
    0x00090304 -> "FSCTL_SVHDX_SYNC_TUNNEL_REQUEST",
    0x00090350 -> "FSCTL_STORAGE_QOS_CONTROL",
    0x00090364 -> "FSCTL_SVHDX_ASYNC_TUNNEL_REQUEST"
};

string CtlCodeToText(any ctlCode)
{
    uint code = ctlCode as uint;
    if (code in CtlCodeMap)
    {
        return CtlCodeMap[code];
    }
    else
    {
        return FSCC.CtlCodeToText(code);
    }
}

string DialectRevisionToText(any input)
{
    ushort revision = input as ushort;
    switch (revision)
    {
        case 0x0202 =>
            return "SMB 2.0.2";
        case 0x0210 =>
            return "SMB 2.1";
        case 0x02FF =>
            return Utility.DecToHexFormat(revision);
        case 0x0300 =>
            return "SMB 3.0";
        case 0x0302 =>
            return "SMB 3.0.2";
        case 0x0311 =>
            return "SMB 3.1.1";
        default =>
            return "Unknown(" + DecToHexFormat(revision) + ")";
    }
}
string SMB2LeaseBreakNotificationNewLeaseStateToText(SMB2LeaseBreakNotificationNewLeaseState input)
{
    string summary = "";
    if (input == 0)
    {
        return "None";
    }
    if ((input & SMB2LeaseBreakNotificationNewLeaseState.SMB2LeaseReadCaching) > 0)
    {
        summary += "R";
    }
    if ((input & SMB2LeaseBreakNotificationNewLeaseState.SMB2LeaseHandleCaching) > 0)
    {
        summary += "H";
    }
    if ((input & SMB2LeaseBreakNotificationNewLeaseState.SMB2LeaseWriteCaching) > 0)
    {
        summary += "W";
    }
    return summary;
}
string SMB2LeaseBreakNotificationCurrentLeaseStateToText(SMB2LeaseBreakNotificationCurrentLeaseState input)
{
    string summary = "";
    if ((input & SMB2.SMB2LeaseBreakNotificationCurrentLeaseState.SMB2LeaseReadCaching) > 0)
    {
        summary += "R";
    }
    if ((input & SMB2.SMB2LeaseBreakNotificationCurrentLeaseState.SMB2LeaseHandleCaching) > 0)
    {
        summary += "H";
    }
    if ((input & SMB2.SMB2LeaseBreakNotificationCurrentLeaseState.SMB2LeaseWriteCaching) > 0)
    {
        summary += "W";
    }
    return summary;
}
string SMB2LeaseBreakAcknowledgmentLeaseStateToText(SMB2LeaseBreakAcknowledgmentLeaseState input)
{
    string summary = "";
    if (input == 0)
    {
        return "None";
    }
    if ((input & SMB2.SMB2LeaseBreakAcknowledgmentLeaseState.SMB2LeaseReadCaching) > 0)
    {
        summary += "R";
    }
    if ((input & SMB2.SMB2LeaseBreakAcknowledgmentLeaseState.SMB2LeaseHandleCaching) > 0)
    {
        summary += "H";
    }
    if ((input & SMB2.SMB2LeaseBreakAcknowledgmentLeaseState.SMB2LeaseWriteCaching) > 0)
    {
        summary += "W";
    }
    return summary;
}
string SMB2LeaseBreakResponseLeaseStateToText(SMB2LeaseBreakResponseLeaseState input)
{
    string summary = "";
    if (input == 0)
    {
        return "None";
    }
    if ((input & SMB2.SMB2LeaseBreakResponseLeaseState.SMB2LeaseReadCaching) > 0)
    {
        summary += "R";
    }
    if ((input & SMB2.SMB2LeaseBreakResponseLeaseState.SMB2LeaseHandleCaching) > 0)
    {
        summary += "H";
    }
    if ((input & SMB2.SMB2LeaseBreakResponseLeaseState.SMB2LeaseWriteCaching) > 0)
    {
        summary += "W";
    }
    return summary;
}

string SMB2LeaseStateToText(ULONG leaseState)
{
    if (leaseState == 0)
    {
        return "None";
    }
    string summary = "";
    if ((leaseState & 0x01) > 0) summary += "R";
    if ((leaseState & 0x02) > 0) summary += "H";
    if ((leaseState & 0x04) > 0) summary += "W";
    
    return summary;
}

string SMB2LeaseStateToFullText(any data)
{
    optional any odata = data as (optional any);
    if (odata == nothing) return "";
    ULONG leaseState = odata as ULONG;
    if (leaseState == 0)
    {
        return "SMB2LeaseNone(0)";
    }
    string summary = "";
    if ((leaseState & 0x01) > 0) summary += "SMB2LeaseReadCaching";
    if ((leaseState & 0x02) > 0) summary += "|SMB2LeaseHandleCaching";
    if ((leaseState & 0x04) > 0) summary += "|SMB2LeaseWriteCaching";
    summary += "(" + (leaseState as string) + ")";
    return summary;
}

string get SessionIdName(this SMB2Request msg)
{
    var sessionIdName = msg#SMB2SessionIdName;
    if (sessionIdName is nothing)
    {
        return "";
    }
    return sessionIdName as string;
}
string get SessionIdName(this SMB2Response msg)
{
    var sessionIdName = msg#SMB2SessionIdName;
    if (sessionIdName is nothing)
    {
        return "";
    }
    return sessionIdName as string;
}

string get SessionIdNameReference(this SMB2Request msg)
{
    string userName = msg.SessionIdName;
    int index = userName.LastIndexOf("@");
    if (index < 0)
    {
        return userName;
    }
    else
    {
        return userName.Segment(0, index);
    }
}

string get SessionIdNameReference(this SMB2Response msg)
{
    string userName = msg.SessionIdName;
    int index = userName.LastIndexOf("@");
    if (index < 0)
    {
        return userName;
    }
    else
    {
        return userName.Segment(0, index);
    }
}

string get TreeIdName(this SMB2Request msg)
{
    var treeIdName = msg#SMB2TreeIdName;
    if (treeIdName is nothing)
    {
        return "";
    }
    return treeIdName as string;
}

string get TreeIdName(this SMB2Response msg)
{
    var treeIdName = msg#SMB2TreeIdName;
    if (treeIdName is nothing)
    {
        return "";
    }
    return treeIdName as string;
}

string get TreeIdNameReference(this SMB2Request msg)
{
    string path = msg.TreeIdName;
    int index = path.LastIndexOf("@");
    if (index < 0)
    {
        return path;
    }
    else
    {
        return path.Segment(0, index);
    }
}

string get TreeIdNameReference(this SMB2Response msg)
{
    string path = msg.TreeIdName;
    int index = path.LastIndexOf("@");
    if (index < 0)
    {
        return path;
    }
    else
    {
        return path.Segment(0, index);
    }
}

// Defined for grouping the traffic by using the SMB FileName.
string get FileName(this SMB2Request msg)
{
    var fileName = msg#SMB2FileName;
    if (fileName is nothing)
    {
        return "";
    }
    return fileName as string;
}

string get FileName(this SMB2Response msg)
{
    var fileName = msg#SMB2FileName;
    if (fileName is nothing)
    {
        return "";
    }
    return fileName as string;
}

string get FileNameReference(this SMB2Request msg)
{
    string fileName = msg.FileName;
    int index = fileName.LastIndexOf("@");
    if (index < 0)
    {
        return fileName;
    }
    else
    {
        return fileName.Segment(0, index);
    }
}

string get FileNameReference(this SMB2Response msg)
{
    string fileName = msg.FileName;
    int index = fileName.LastIndexOf("@");
    if (index < 0)
    {
        return fileName;
    }
    else
    {
        return fileName.Segment(0, index);
    }
}

string GetFileNameOrFID(SMB2Request msg)
{
    if (msg#SMB2FileName is reqFileName:string)
    {
        if (reqFileName.IndexOf("0x") == 0) // Assume the real file name doesn't begin with "0x"
        {
            return ", FileID: " + reqFileName;
        }
        else
        {
            return ", FileName: " + reqFileName;
        }
    }
    return "";
}

string GetFileNameOrFID(SMB2Response msg)
{
    if (msg#SMB2FileName is respFileName:string)
    {
        if (respFileName.IndexOf("0x") == 0) // Assume the real file name doesn't begin with "0x"
        {
            return ", FileID: " + respFileName;
        }
        else
        {
            return ", FileName: " + respFileName;
        }
    } 
    return "";
}

// Get the TreeId for the SMB2PacketHeader
uint GetTreeId(SMB2PacketHeader header)
{
    if (header.TreeId is tid:ULONG)
    {
        return tid;
    }
    return 0;
}

ulong GetSMB2FileId(SMB2Request msg)
{
    return (msg#FileId == nothing) ? InvalidFileId : msg#FileId as ulong;
}

ulong GetSMB2FileId(SMB2Response msg)
{
    return (msg#FileId == nothing) ? InvalidFileId : msg#FileId as ulong;
}

// Get the EncryptionAlgorithm field from SMB2TransformMessage message
ushort GetEncryptAlgorithmFromSMB2TransformMessage(binary smbMessage)
{
    return (smbMessage[42] + ((smbMessage[43] as ushort) << 8)) as ushort;
}

string CreateContextNameToText(any val)
{
    if (val is s:string)
    {
        return s;
    }
    else if (val is SMB2_CREATE_APP_INSTANCE_ID)
    {
        return "0x45BCA66AEFA7F74A9008FA462E144D74";
    }
    else if (val is SMB2_CREATE_APP_INSTANCE_VERSION)
    {
        return "0xB982D0B73B56074FA07B524A8116A010";
    }
    else if (val is SVHDX_OPEN_DEVICE_CONTEXT)
    {
        return "0x9CCBCF9E04C1E643980E158DA1F6EC83";
    }
    else
    {
        return val.ToString();
    }
}

// Combine two ulong values as one double value
double CombineAsDouble(ulong u1, ulong u2)
{
    if (u2 == 0)
    {
        return (u1 as double);
    }
    else
    {
        return u1 + (1 / u2 as double);
    }
}

const map<SMB2.SMB2PacketHeaderCommand, string> SmbCmdMapToMessageName =
{
    SMB2.SMB2PacketHeaderCommand.SMB2Negotiate -> "Negotiate",
    SMB2.SMB2PacketHeaderCommand.SMB2SessionSetup -> "SessionSetup",
    SMB2.SMB2PacketHeaderCommand.SMB2Logoff -> "Logoff",
    SMB2.SMB2PacketHeaderCommand.SMB2TreeConnect -> "TreeConnect",
    SMB2.SMB2PacketHeaderCommand.SMB2TreeDisconnect -> "TreeDisconnect",
    SMB2.SMB2PacketHeaderCommand.SMB2Create -> "Create",
    SMB2.SMB2PacketHeaderCommand.SMB2Close -> "Close",
    SMB2.SMB2PacketHeaderCommand.SMB2Flush -> "Flush",
    SMB2.SMB2PacketHeaderCommand.SMB2Read -> "Read",
    SMB2.SMB2PacketHeaderCommand.SMB2Write -> "Write",
    SMB2.SMB2PacketHeaderCommand.SMB2Lock -> "Lock",
    SMB2.SMB2PacketHeaderCommand.SMB2Ioctl -> "Ioctl",
    SMB2.SMB2PacketHeaderCommand.SMB2Cancel -> "Cancel",
    SMB2.SMB2PacketHeaderCommand.SMB2Echo -> "Echo",
    SMB2.SMB2PacketHeaderCommand.SMB2QueryDirectory -> "QueryDirectory",
    SMB2.SMB2PacketHeaderCommand.SMB2ChangeNotify -> "ChangeNotify",
    SMB2.SMB2PacketHeaderCommand.SMB2QueryInfo -> "QueryInfo",
    SMB2.SMB2PacketHeaderCommand.SMB2SetInfo -> "SetInfo"
};

string SMB2HeaderOnlyMessageName(SMB2HeaderOnly msg)
{
    string msgName = "";
    if (msg.Header.Command in SmbCmdMapToMessageName)
    {
        msgName = SmbCmdMapToMessageName[msg.Header.Command];
    }
    else if (SMB2.SMB2PacketHeaderCommand.SMB2OplockBreak == msg.Header.Command)
    {
        msgName = "OplockBreak";
    }

    if (msg.Header.IsRequestMessage())
    {
        return msgName + "Request";
    }
    else
    {
        return msgName + "Response";
    }
}

// Judge an error response message according to section 3.3.4.4 Sending an Error Response
bool IsErrorResponse(ushort commmand, uint status, bool sizeIs49, bool asyncCommand)
{
    // An error code other than one of the following indicates a failure:
    if ((commmand == SMB2.SMB2PacketHeaderCommand.SMB2SessionSetup && status == Smb2StatusValue.STATUS_MORE_PROCESSING_REQUIRED) // STATUS_MORE_PROCESSING_REQUIRED in an SMB2 SESSION_SETUP Response
        || ((commmand == SMB2.SMB2PacketHeaderCommand.SMB2QueryInfo || commmand == SMB2.SMB2PacketHeaderCommand.SMB2Read) && status == Smb2StatusValue.STATUS_BUFFER_OVERFLOW) // STATUS_BUFFER_OVERFLOW in an SMB2 QUERY_INFO Response/SMB2 READ Response
        || (commmand == SMB2.SMB2PacketHeaderCommand.SMB2ChangeNotify && status == Smb2StatusValue.STATUS_NOTIFY_ENUM_DIR) // STATUS_NOTIFY_ENUM_DIR in an SMB2 CHANGE_NOTIFY Response
        || (commmand == SMB2.SMB2PacketHeaderCommand.SMB2Ioctl && status != 0 && sizeIs49)) // Any status other than STATUS_SUCCESS in a FSCTL_SRV_COPYCHUNK or FSCTL_SRV_COPYCHUNK_WRITE Response
    {
        return false;
    }
    return ((status & 0xC0000000) == 0xC0000000) || // Error code
        (asyncCommand && (status == Smb2StatusValue.STATUS_PENDING)) ||  // Interim Response for an Asynchronous Operation
        (status in {Smb2StatusValue.STATUS_STOPPED_ON_SYMLINK, Smb2StatusValue.STATUS_EA_LIST_INCONSISTENT}); // STATUS_STOPPED_ON_SYMLINK, STATUS_EA_LIST_INCONSISTENT
}

pattern Smb2StatusValue = enum uint
{
    STATUS_PENDING                      = 0x00000103,
    STATUS_MORE_PROCESSING_REQUIRED     = 0xC0000016,
    STATUS_BUFFER_OVERFLOW              = 0x80000005,
    STATUS_NOTIFY_ENUM_DIR              = 0x0000010C,
    STATUS_STOPPED_ON_SYMLINK           = 0x8000002D,
    STATUS_BUFFER_TOO_SMALL             = 0xC0000023,
    STATUS_EA_LIST_INCONSISTENT         = 0x80000014,
    STATUS_FS_DRIVER_REQUIRED           = 0xC000019C,
    STATUS_BAD_NETWORK_NAME             = 0xC00000CC,
    ...
};

// Return max value
long Max(long val1, long val2)
{
    return val1 > val2 ? val1 : val2;
}

optional uint get CompoundedMessageNumber(this SMB2Request msg)
{
    if (msg#IsCompounded is cmp:bool && cmp)
    {
        return FrameMessageNumber (msg);
    }
    return nothing;
}

optional uint get CompoundedMessageNumber(this SMB2Response msg)
{
    if (msg#IsCompounded is cmp:bool && cmp)
    {
        return FrameMessageNumber (msg);
    }
    return nothing;
}

string GetCompoundedString(any message msg)
{
    string compoundedStr = "";
    if (msg is req:SMB2.SMB2Request && req#IsCompounded is cmp:bool && cmp)
    {
        compoundedStr = "Compounded, ";
    }
    return compoundedStr;
}
