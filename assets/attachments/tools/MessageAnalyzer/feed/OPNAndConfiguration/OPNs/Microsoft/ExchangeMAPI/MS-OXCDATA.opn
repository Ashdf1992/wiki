module MSOXCDATA with
Documentation
{
    ProtocolName = "Data Structures",
    ShortName = "MS-OXCDATA",
    DocumentName = "MS-OXCDATA",
    ProtocolType = "DTD",
},
OPNAuthoring
{
    Copyright = "(c) 2015 Microsoft Corporation",
    References = 
    [
        new Reference{Name = "MS-OXCDATA", Version = "13.0"},
    ],
    RevisionSummary =    
    [
        new Revision{Class=RevisionClass.Major, Version="1.3.1", Date="08/31/2015"},
    ]
};

using Diagnostics;
using DTYP;
using Utility;
using MSOXPROPS;

// Add this type to represent a name-meaning pair
type NameMeaning
{
    string Name;
    string Meaning;
    
    override string ToString()
    {
        return Name + ": " + Meaning;
    }
}

// Section 2.4    Error Codes
const map<uint, NameMeaning> ErrorCodesMap = 
{
    0x00000000 -> new NameMeaning {Name = "Success", Meaning = "The operation succeeded. (S_OK, SUCCESS_SUCCESS)"},
    0x80004005 -> new NameMeaning {Name = "GeneralFailure", Meaning = "The operation failed for an unspecified reason. (E_FAIL, MAPI_E_CALL_FAILED, ecError, SYNC_E_ERROR)"},
    0x8007000E -> new NameMeaning {Name = "OutOfMemory", Meaning = "Not enough memory was available to complete the operation. (E_NOMEMORY, MAPI_E_NOT_ENOUGH_MEMORY, ecMAPIOOM, ecPropSize)"},
    0x80070057 -> new NameMeaning {Name = "InvalidParameter", Meaning = "An invalid parameter was passed to a remote procedure call (RPC). (E_INVALIDARG, MAPI_E_INVALID_PARAMETER, ecInvalidParam, ecInvalidSession, ecBadBuffer, SYNC_E_INVALID_PARAMETER)"},
    0x80004002 -> new NameMeaning {Name = "NoInterface", Meaning = "The requested interface is not supported. (E_NOINTERFACE, MAPI_E_INTERFACE_NOT_SUPPORTED, ecinterfacenotsupported)"},
    0x80070005 -> new NameMeaning {Name = "AccessDenied", Meaning = "The caller does not have sufficient access rights to perform the operation. (E_ACCESSDENIED, MAPI_E_NO_ACCESS, ecaccessdenied, ecpropsecurityviolation)"},
    0x80030001 -> new NameMeaning {Name = "StorageInvalidFunction", Meaning = "The server was unable to perform the requested operation. (STG_E_INVALIDFUNCTION)"},
    0x80030005 -> new NameMeaning {Name = "StorageAccessDenied", Meaning = "The caller does not have sufficient access rights to perform the operation. (STG_E_ACCESSDENIED)"},
    0x80030008 -> new NameMeaning {Name = "StorageInsufficientMemory", Meaning = "There is insufficient memory available to complete the operation. (STG_E_INSUFFICIENTMEMORY)"},
    0x80030009 -> new NameMeaning {Name = "StorageInvalidPointer", Meaning = "An invalid pointer was passed to the remote procedure call. (STG_E_INVALIDPOINTER)"},
    0x8003001E -> new NameMeaning {Name = "StorageReadFault", Meaning = "A disk error occurred during a read operation. (STG_E_READFAULT)"},
    0x80030021 -> new NameMeaning {Name = "StorageLockViolation", Meaning = "A lock violation has occurred. (STG_E_LOCKVIOLATION)"},
    0x80030057 -> new NameMeaning {Name = "StorageInvalidParameter", Meaning = "An invalid parameter was passed to the remote procedure call. (STG_E_INVALIDPARAMETER)"},
    0x80030070 -> new NameMeaning {Name = "StreamSizeError", Meaning = "There is insufficient disk space to complete the operation. (ecStreamSizeError, STG_E_MEDIUMFULL)"},
    0x800300FF -> new NameMeaning {Name = "StorageInvalidFlag", Meaning = "An invalid flag was passed to a remote procedure call. (STG_E_INVALIDFLAG)"},
    0x80030103 -> new NameMeaning {Name = "StorageCannotSave", Meaning = "A stream could not be saved. (STG_E_CANTSAVE)"},
    0x80040102 -> new NameMeaning {Name = "NotSupported", Meaning = "The server does not support this method call. (MAPI_E_NO_SUPPORT, ecNotSupported, ecNotImplemented)"},
    0x80040103 -> new NameMeaning {Name = "InvalidCharacterWidth", Meaning = "Unicode characters were requested when only 8-bit characters are supported, or vice versa. (MAPI_E_BAD_CHARWIDTH, ecBadCharwidth)"},
    0x80040105 -> new NameMeaning {Name = "StringTooLong", Meaning = "In the context of this method call, a string exceeds the maximum permitted length. (MAPI_E_STRING_TOO_LONG, ecStringTooLarge)"},
    0x80040106 -> new NameMeaning {Name = "InvalidFlag", Meaning = "An unrecognized flag bit was passed to a method call. (MAPI_E_UNKNOWN_FLAGS, ecUnknownFlags, SYNC_E_UNKNOWN_FLAGS)"},
    0x80040107 -> new NameMeaning {Name = "InvalidEntryID", Meaning = "An incorrectly formatted EntryID was passed to a method call. (MAPI_E_INVALID_ENTRYID, ecInvalidEntryId)"},
    0x80040108 -> new NameMeaning {Name = "InvalidObject", Meaning = "A method call was made using a reference to an object that has been destroyed or is not in a viable state. (MAPI_E_INVALID_OBJECT, ecInvalidObject)"},
    0x80040109 -> new NameMeaning {Name = "ObjectChanged", Meaning = "An attempt to commit changes failed because the object was changed separately. (MAPI_E_OBJECT_CHANGED, ecObjectModified)"},
    0x8004010A -> new NameMeaning {Name = "ObjectDeleted", Meaning = "An operation failed because the object was deleted separately. (MAPI_E_OBJECT_DELETED, ecObjectDeleted)"},
    0x8004010B -> new NameMeaning {Name = "ServerBusy", Meaning = "A table operation failed because a separate operation was in progress at the same time. (MAPI_E_BUSY, ecBusy)"},
    0x8004010D -> new NameMeaning {Name = "OutOfDisk", Meaning = "Not enough disk space was available to complete the operation. (MAPI_E_NOT_ENOUGH_DISK, ecDiskFull)"},
    0x8004010E -> new NameMeaning {Name = "OutOfResources", Meaning = "Not enough of an unspecified resource was available to complete the operation. (MAPI_E_NOT_ENOUGH_RESOURCES, ecInsufficientResrc)"},
    0x8004010F -> new NameMeaning {Name = "NotFound", Meaning = "The requested object could not be found at the server. (MAPI_E_NOT_FOUND, ecNotFound, ecAttachNotFound, ecUnknownRecip, ecPropNotExistent)"},
    0x80040110 -> new NameMeaning {Name = "VersionMismatch", Meaning = "Client and server versions are not compatible. (MAPI_E_VERSION, ecVersionMismatch, ecVersion)"},
    0x80040111 -> new NameMeaning {Name = "LogonFailed", Meaning = "A client was unable to log on to the server. (MAPI_E_LOGON_FAILED, ecLoginFailure)"},
    0x80040112 -> new NameMeaning {Name = "TooManySessions", Meaning = "A server or service is unable to create any more sessions. (MAPI_E_SESSION_LIMIT, ecTooManySessions)"},
    0x80040113 -> new NameMeaning {Name = "UserCanceled", Meaning = "An operation failed because a user cancelled it. (MAPI_E_USER_CANCEL, ecUserAbort)"},
    0x80040114 -> new NameMeaning {Name = "AbortFailed", Meaning = "A RopAbort ([MS-OXCROPS] section 2.2.5.5) or RopAbortSubmit ([MS-OXCROPS] section 2.2.7.2) ROP request was unsuccessful. (MAPI_E_UNABLE_TO_ABORT, ecUnableToAbort)"},
    0x80040115 -> new NameMeaning {Name = "NetworkError", Meaning = "An operation was unsuccessful because of a problem with network operations or services. (MAPI_E_NETWORK_ERROR, ecNetwork)"},
    0x80040116 -> new NameMeaning {Name = "DiskError", Meaning = "There was a problem writing to or reading from disk. (MAPI_E_DISK_ERROR, ecWriteFault, ecReadFault)"},
    0x80040117 -> new NameMeaning {Name = "TooComplex", Meaning = "The operation requested is too complex for the server to handle; often applied to restrictions. (MAPI_E_TOO_COMPLEX, ecTooComplex)"},
    0x80040118 -> new NameMeaning {Name = "InvalidColumn", Meaning = "The column requested is not allowed in this type of table. (MAPI_E_BAD_COLUMN)"},
    0x8004011A -> new NameMeaning {Name = "ComputedValue", Meaning = "A property cannot be updated because it is read-only, computed by the server. (MAPI_E_COMPUTED, ecComputed)"},
    0x8004011B -> new NameMeaning {Name = "CorruptData", Meaning = "There is an internal inconsistency in a database, or in a complex property value. (MAPI_E_CORRUPT_DATA, ecCorruptData)"},
    0x8004011E -> new NameMeaning {Name = "InvalidCodepage", Meaning = "The server is not configured to support the code page requested by the client. (MAPI_E_UNKNOWN_CPID)"},
    0x8004011F -> new NameMeaning {Name = "InvalidLocale", Meaning = "The server is not configured to support the locale requested by the client. (MAPI_E_UNKNOWN_LCID)"},
    0x80040123 -> new NameMeaning {Name = "TimeSkew", Meaning = "The operation failed due to clock skew between servers. (MAPI_E_INVALID_ACCESS_TIME, ecTimeSkew)"},
    0x80040200 -> new NameMeaning {Name = "EndOfSession", Meaning = "Indicates that the server session has been destroyed, possibly by a server restart. (MAPI_E_END_OF_SESSION)"},
    0x80040201 -> new NameMeaning {Name = "UnknownEntryId", Meaning = "Indicates that the EntryID passed to OpenEntry was created by a different MAPI provider. (MAPI_E_UNKNOWN_ENTRYID)"},
    0x80040400 -> new NameMeaning {Name = "NotCompleted", Meaning = "A complex operation such as building a table row set could not be completed. (MAPI_E_UNABLE_TO_COMPLETE, ecUnableToComplete)"},
    0x80040401 -> new NameMeaning {Name = "Timeout", Meaning = "An asynchronous operation did not succeed within the specified time-out. (MAPI_E_TIMEOUT, ecTimeout)"},
    0x80040402 -> new NameMeaning {Name = "EmptyTable", Meaning = "A table essential to the operation is empty. (MAPI_E_TABLE_EMPTY, ecTableEmpty)"},
    0x80040403 -> new NameMeaning {Name = "TableTooBig", Meaning = "The table is too big for the requested operation to complete. (MAPI_E_TABLE_TOO_BIG, ecTableTooBig)"},
    0x80040405 -> new NameMeaning {Name = "InvalidBookmark", Meaning = "The bookmark passed to a table operation was not created on the same table. (MAPI_E_INVALID_BOOKMARK, ecInvalidBookmark)"},
    0x80040500 -> new NameMeaning {Name = "ErrorWait", Meaning = "A wait time-out has expired. (MAPI_E_WAIT, ecWait)"},
    0x80040501 -> new NameMeaning {Name = "ErrorCancel", Meaning = "The operation had to be canceled. (MAPI_E_CANCEL, ecCancel)"},
    0x80040602 -> new NameMeaning {Name = "NoSuppress", Meaning = "The server does not support the suppression of read receipts. (MAPI_E_NO_SUPPRESS)"},
    0x80040604 -> new NameMeaning {Name = "CollidingNames", Meaning = "A folder or item cannot be created because one with the same name or other criteria already exists. (MAPI_E_COLLISION, ecDuplicateName)"},
    0x80040605 -> new NameMeaning {Name = "NotInitialized", Meaning = "The subsystem is not ready. (MAPI_E_NOT_INITIALIZED, ecNotInitialized)"},
    0x80040607 -> new NameMeaning {Name = "NoRecipients", Meaning = "A message cannot be sent because it has no recipients (1). (MAPI_E_NO_RECIPIENTS)"},
    0x80040608 -> new NameMeaning {Name = "AlreadySent", Meaning = "A message cannot be opened for modification because it has already been sent. (MAPI_E_SUBMITTED, ecSubmitted)"},
    0x80040609 -> new NameMeaning {Name = "HasFolders", Meaning = "A folder cannot be deleted because it still contains subfolders. (MAPI_E_HAS_FOLDERS, ecFolderHasChildren)"},
    0x8004060A -> new NameMeaning {Name = "HasMessages", Meaning = "A folder cannot be deleted because it still contains messages. (MAPI_E_HAS_MESSAGES, ecFolderHasContents)"},
    0x8004060B -> new NameMeaning {Name = "FolderCycle", Meaning = "A folder move or copy operation would create a cycle (typically when the request is to copy a parent folder to one of its subfolders). (MAPI_E_FOLDER_CYCLE, ecRootFolder)"},
    0x8004060D -> new NameMeaning {Name = "TooManyLocks", Meaning = "Too many locks have been requested. (MAPI_E_LOCKID_LIMIT, ecLockIdLimit)"},
    0x80040700 -> new NameMeaning {Name = "AmbiguousRecipient", Meaning = "An unresolved recipient (2) matches more than one entry in the directory. (MAPI_E_AMBIGUOUS_RECIP, ecAmbiguousRecip)"},
    0x80040800 -> new NameMeaning {Name = "SyncObjectDeleted", Meaning = "The requested object was previously deleted. (SYNC_E_OBJECT_DELETED)"},
    0x80040801 -> new NameMeaning {Name = "IgnoreFailure", Meaning = "An error occurred, but it's safe to ignore the error, perhaps because the change in question has been superseded. (SYNC_E_IGNORE)"},
    0x80040802 -> new NameMeaning {Name = "SyncConflict", Meaning = "Conflicting changes to an object have been detected. (SYNC_E_CONFLICT)"},
    0x80040803 -> new NameMeaning {Name = "NoParentFolder", Meaning = "The parent folder could not be found. (SYNC_E_NO_PARENT)"},
    0x80040804 -> new NameMeaning {Name = "CycleDetected", Meaning = "An operation would create a cycle (for instance, by copying a parent folder to one of its subfolders)."},
    0x80040805 -> new NameMeaning {Name = "NotSynchronized", Meaning = "A sync operation did not take place, possibly due to a conflicting change. (SYNC_E_UNSYNCHRONIZED)"},
    0x80040900 -> new NameMeaning {Name = "NamedPropertyQuota", Meaning = "The Store object cannot store any more named property mappings. (MAPI_E_NAMED_PROP_QUOTA_EXCEEDED, ecNPQuotaExceeded)"},
    0x80040FFF -> new NameMeaning {Name = "NotImplemented", Meaning = "The server does not implement this method call."}
};

// Section 2.4.1   Additional Error Codes
const map<uint, NameMeaning> AdditionalErrorCodesMap = 
{
    0x000003EA -> new NameMeaning {Name = "IsamError", Meaning = "Unspecified database failure. (ecJetError)"},
    0x000003EB -> new NameMeaning {Name = "UnknownUser", Meaning = "Unable to identify a home Store object for this user. (ecUnknownUser)"},
    0x000003ED -> new NameMeaning {Name = "Exiting", Meaning = "The server is in the process of stopping. (ecExiting)"},
    0x000003EE -> new NameMeaning {Name = "BadConfiguration", Meaning = "Protocol settings for this user are incorrect. (ecBadConfig)"},
    0x000003EF -> new NameMeaning {Name = "UnknownCodePage", Meaning = "The specified code page is not installed on the server. (ecUnknownCodePage)"},
    0x000003F0 -> new NameMeaning {Name = "ServerMemory", Meaning = "The server is out of memory. (ecServerOOM, ecMemory)"},
    0x000003F2 -> new NameMeaning {Name = "LoginPermission", Meaning = "This user does not have access rights to the mailbox. (ecLoginPerm)"},
    0x000003F3 -> new NameMeaning {Name = "DatabaseRolledBack", Meaning = "The database has been restored and needs fix-up but cannot be fixed up. (ecDatabaseRolledBack)"},
    0x000003F4 -> new NameMeaning {Name = "DatabaseCopiedError", Meaning = "The database file has been copied from another server. (ecDatabaseCopiedError)"},
    0x000003F5 -> new NameMeaning {Name = "AuditNotAllowed", Meaning = "Auditing of security operations is not permitted. (ecAuditNotAllowed)"},
    0x000003F6 -> new NameMeaning {Name = "ZombieUser", Meaning = "User has no security identifier. (ecZombieUser)"},
    0x000003F7 -> new NameMeaning {Name = "UnconvertableACL", Meaning = "An access control list (ACL) cannot be converted to NTFS format. (ecUnconvertableACL)"},
    0x0000044C -> new NameMeaning {Name = "NoFreeJetSessions", Meaning = "No Jet session is available. (ecNoFreeJses)"},
    0x0000044D -> new NameMeaning {Name = "DifferentJetSession", Meaning = "Warning, a Jet session other than the one requested was returned. (ecDifferentJses)"},
    0x0000044F -> new NameMeaning {Name = "FileRemove", Meaning = "An error occurred when attempting to remove a database file. (ecFileRemove)"},
    0x00000450 -> new NameMeaning {Name = "ParameterOverflow", Meaning = "Parameter value overflow. (ecParameterOverflow)"},
    0x00000451 -> new NameMeaning {Name = "BadVersion", Meaning = "Bad message store database version number. (ecBadVersion)"},
    0x00000452 -> new NameMeaning {Name = "TooManyColumns", Meaning = "Too many columns requested in SetColumns. (ecTooManyCols)"},
    0x00000453 -> new NameMeaning {Name = "HaveMore", Meaning = "A ROP has more data to return. (ecHaveMore)"},
    0x00000454 -> new NameMeaning {Name = "DatabaseError", Meaning = "General database problem. (ecDatabaseError)"},
    0x00000455 -> new NameMeaning {Name = "IndexNameTooBig", Meaning = "An index name is larger than what Jet allows. (ecIndexNameTooBig)"},
    0x00000456 -> new NameMeaning {Name = "UnsupportedProperty", Meaning = "The property data type is not supported. (ecUnsupportedProp)"},
    0x00000457 -> new NameMeaning {Name = "MessageNotSaved", Meaning = "During AbortSubmit, a message was not saved. (ecMsgNotSaved)"},
    0x00000459 -> new NameMeaning {Name = "UnpublishedNotification", Meaning = "A notification could not be published at this time. (ecUnpubNotif)"},
    0x0000045B -> new NameMeaning {Name = "DifferentRoot", Meaning = "Moving or copying folders to a different top-level hierarchy is not supported. (ecDifferentRoot)"},
    0x0000045C -> new NameMeaning {Name = "BadFolderName", Meaning = "Invalid folder name. (ecBadFolderName)"},
    0x0000045D -> new NameMeaning {Name = "AttachmentOpen", Meaning = "The attachment is open. (ecAttachOpen)"},
    0x0000045E -> new NameMeaning {Name = "InvalidCollapseState", Meaning = "The collapse state given to SetCollapseState is invalid. (ecInvClpsState)"},
    0x0000045F -> new NameMeaning {Name = "SkipMyChildren", Meaning = "While walking a folder tree, do not consider children of this folder. (ecSkipMyChildren)"},
    0x00000460 -> new NameMeaning {Name = "SearchFolder", Meaning = "The operation is not supported on a search folder (2). (ecSearchFolder)"},
    0x00000461 -> new NameMeaning {Name = "NotSearchFolder", Meaning = "The operation is valid only on a search folder (2). (ecNotSearchFolder)"},
    0x00000462 -> new NameMeaning {Name = "FolderSetReceive", Meaning = "This is a Receive folder and cannot be deleted. (ecFolderSetReceive)"},
    0x00000463 -> new NameMeaning {Name = "NoReceiveFolder", Meaning = "No Receive folder is available (even no default). (ecNoReceiveFolder)"},
    0x00000465 -> new NameMeaning {Name = "DeleteSubmittedMessage", Meaning = "Deleting a message that has been submitted for sending is not permitted. (ecNoDelSubmitMsg)"},
    0x00000467 -> new NameMeaning {Name = "InvalidRecipients", Meaning = "It was impossible to deliver to this recipient (1). (ecInvalidRecips)"},
    0x00000468 -> new NameMeaning {Name = "NoReplicaHere", Meaning = "No replica (2) of the public folder in this Store object. (ecNoReplicaHere)"},
    0x00000469 -> new NameMeaning {Name = "NoReplicaAvailable", Meaning = "No available Store object has a replica (2) of this public folder. (ecNoReplicaAvailable)"},
    0x0000046A -> new NameMeaning {Name = "PublicDatabase", Meaning = "The operation is invalid on a public Store object. (ecPublicMDB)"},
    0x0000046B -> new NameMeaning {Name = "NotPublicDatabase", Meaning = "The operation is valid only on a public Store object. (ecNotPublicMDB)"},
    0x0000046C -> new NameMeaning {Name = "RecordNotFound", Meaning = "The record was not found. (ecRecordNotFound)"},
    0x0000046D -> new NameMeaning {Name = "ReplicationConflict", Meaning = "A replication conflict was detected. (ecReplConflict)"},
    0x00000470 -> new NameMeaning {Name = "FXBufferOverrun", Meaning = "Prevented an overrun while reading a fast transfer buffer. (ecFxBufferOverrun)"},
    0x00000471 -> new NameMeaning {Name = "FXBufferEmpty", Meaning = "No more in a fast transfer buffer. (ecFxBufferEmpty)"},
    0x00000472 -> new NameMeaning {Name = "FXPartialValue", Meaning = "Partial long value in a fast transfer buffer. (ecFxPartialValue)"},
    0x00000473 -> new NameMeaning {Name = "FxNoRoom", Meaning = "No room for an atomic value in a fast transfer buffer. (ecFxNoRoom)"},
    0x00000474 -> new NameMeaning {Name = "TimeExpired", Meaning = "Housekeeping functions have exceeded their time window. (ecMaxTimeExpired)"},
    0x00000475 -> new NameMeaning {Name = "DestinationError", Meaning = "An error occurred on the destination folder during a copy operation. (ecDstError)"},
    0x00000476 -> new NameMeaning {Name = "DatabaseNotInitialized", Meaning = "The Store object was not properly initialized. (ecMDBNotInit)"},
    0x00000478 -> new NameMeaning {Name = "WrongServer", Meaning = "This server does not host the user's mailbox database. (ecWrongServer)"},
    0x0000047D -> new NameMeaning {Name = "BufferTooSmall", Meaning = "A buffer passed to this function is not big enough. (ecBufferTooSmall)"},
    0x0000047E -> new NameMeaning {Name = "AttachmentResolutionRequired", Meaning = "Linked attachments could not be resolved to actual files. (ecRequiresRefResolve)"},
    0x0000047F -> new NameMeaning {Name = "ServerPaused", Meaning = "The service is in a paused state. (ecServerPaused)"},
    0x00000480 -> new NameMeaning {Name = "ServerBusy", Meaning = "The server is too busy to complete an operation. (ecServerBusy)"},
    0x00000481 -> new NameMeaning {Name = "NoSuchLogon", Meaning = "No such logon exists in the Store object's Logon list. (ecNoSuchLogon)"},
    0x00000482 -> new NameMeaning {Name = "LoadLibraryFailed", Meaning = "Internal error: the service cannot load a required DLL. (ecLoadLibFailed)"},
    0x00000483 -> new NameMeaning {Name = "AlreadyConfigured", Meaning = "A synchronization object has already been configured. (ecObjAlreadyConfig)"},
    0x00000484 -> new NameMeaning {Name = "NotConfigured", Meaning = "A synchronization object has not yet been configured. (ecObjNotConfig)"},
    0x00000485 -> new NameMeaning {Name = "DataLoss", Meaning = "A code page conversion incurred data loss. (ecDataLoss)"},
    0x00000488 -> new NameMeaning {Name = "MaximumSendThreadExceeded", Meaning = "The maximum number of send threads has been exceeded. (ecMaxSendThreadExceeded)"},
    0x00000489 -> new NameMeaning {Name = "FxErrorMarker", Meaning = "A fast transfer error marker was found, and recovery is necessary. (ecFxErrorMarker)"},
    0x0000048A -> new NameMeaning {Name = "NoFreeJtabs", Meaning = "There are no more free Jet tables. (ecNoFreeJtabs)"},
    0x0000048B -> new NameMeaning {Name = "NotPrivateDatabase", Meaning = "The operation is valid only on a private mailbox database. (ecNotPrivateMDB)"},
    0x0000048C -> new NameMeaning {Name = "IsintegMDB", Meaning = "The Store object has been locked by the ISINTEG utility. (ecIsintegMDB)"},
    0x0000048D -> new NameMeaning {Name = "RecoveryMismatch", Meaning = "A recovery storage group operation was attempted on a non-RSG Store object, or vice versa. (ecRecoveryMDBMismatch)"},
    0x0000048E -> new NameMeaning {Name = "TableMayNotBeDeleted", Meaning = "Attempt to delete a critical table, such as the messages or attachments table. (ecTableMayNotBeDeleted)"},
    0x00000490 -> new NameMeaning {Name = "SearchFolderScopeViolation", Meaning = "Attempt to perform a recursive search on a search folder (2). (ecSearchFolderScopeViolation)"},
    0x000004B1 -> new NameMeaning {Name = "RpcRegisterIf", Meaning = "Error in registering RPC interfaces. (ecRpcRegisterIf)"},
    0x000004B2 -> new NameMeaning {Name = "RpcListen", Meaning = "Error in starting the RPC listener. (ecRpcListen)"},
    0x000004B6 -> new NameMeaning {Name = "RpcFormat", Meaning = "A badly formatted RPC buffer was detected. (ecRpcFormat)"},
    0x000004B7 -> new NameMeaning {Name = "NoCopyTo", Meaning = "Single instance storage cannot be used in this case. (ecNoCopyTo)"},
    0x000004B9 -> new NameMeaning {Name = "NullObject", Meaning = "An object handle reference in the RPC buffer could not be resolved. (ecNullObject)"},
    0x000004BC -> new NameMeaning {Name = "RpcAuthentication", Meaning = "Server requests client to use authentication. (ecRpcAuthentication)"},
    0x000004BD -> new NameMeaning {Name = "RpcBadAuthenticationLevel", Meaning = "The server doesn't recognize a client's authentication level. (ecRpcBadAuthenticationLevel)"},
    0x000004BE -> new NameMeaning {Name = "NullCommentRestriction", Meaning = "The subrestriction of a comment restriction is empty. (ecNullCommentRestriction)"},
    0x000004CC -> new NameMeaning {Name = "RulesLoadError", Meaning = "Rule (4) data was unavailable for this folder. (ecRulesLoadError)"},
    0x000004CD -> new NameMeaning {Name = "RulesDeliverErr", Meaning = "Delivery-time failure in rule (4) execution. (ecRulesDeliverErr)"},
    0x000004CE -> new NameMeaning {Name = "RulesParsingErr", Meaning = "Invalid syntax in a stored rule (4) condition or action (3). (ecRulesParsingErr)"},
    0x000004CF -> new NameMeaning {Name = "RulesCreateDAE", Meaning = "Failure creating a deferred rule (4) action (3) error message. (ecRulesCreateDaeErr)"},
    0x000004D0 -> new NameMeaning {Name = "RulesCreateDAM", Meaning = "Failure creating a deferred rule (4) action (3) message. (ecRulesCreateDamErr)"},
    0x000004D1 -> new NameMeaning {Name = "RulesNoMoveCopyFolder", Meaning = "A move or copy rule (4) action (3) could not be performed due to a problem with the target folder. (ecRulesNoMoveCopyFolder)"},
    0x000004D2 -> new NameMeaning {Name = "RulesNoFolderRights", Meaning = "A move or copy rule (4) action (3) could not be performed due to a permissions problem with the target folder. (ecRulesNoFolderRights)"},
    0x000004D4 -> new NameMeaning {Name = "MessageTooBig", Meaning = "A message could not be delivered because it exceeds a size limit. (ecMessageTooBig)"},
    0x000004D5 -> new NameMeaning {Name = "FormNotValid", Meaning = "There is a problem with the form mapped to the message's message class. (ecFormNotValid)"},
    0x000004D6 -> new NameMeaning {Name = "NotAuthorized", Meaning = "Delivery to the desired folder was not authorized. (ecNotAuthorized)"},
    0x000004D7 -> new NameMeaning {Name = "DeleteMessage", Meaning = "The message was deleted by a rule (4) action (3). (ecDeleteMessage)"},
    0x000004D8 -> new NameMeaning {Name = "BounceMessage", Meaning = "Delivery of the message was denied by a rule (4) action (3). (ecBounceMessage)"},
    0x000004D9 -> new NameMeaning {Name = "QuotaExceeded", Meaning = "The operation failed because it would have exceeded a resource quota. (ecQuotaExceeded)"},
    0x000004DA -> new NameMeaning {Name = "MaxSubmissionExceeded", Meaning = "A message could not be submitted because its size exceeds the defined maximum. (ecMaxSubmissionExceeded)"},
    0x000004DB -> new NameMeaning {Name = "MaxAttachmentExceeded", Meaning = "The maximum number of message attachments has been exceeded. (ecMaxAttachmentExceeded)"},
    0x000004DC -> new NameMeaning {Name = "SendAsDenied", Meaning = "The user account does not have permission to send mail as the owner of this mailbox. (ecSendAsDenied)"},
    0x000004DD -> new NameMeaning {Name = "ShutoffQuotaExceeded", Meaning = "The operation failed because it would have exceeded the mailbox's shutoff quota. (ecShutoffQuotaExceeded)"},
    0x000004DE -> new NameMeaning {Name = "TooManyOpenObjects", Meaning = "A client has opened too many objects of a specific type. (ecMaxObjsExceeded)"},
    0x000004DF -> new NameMeaning {Name = "ClientVersionBlocked", Meaning = "The server is configured to block clients of this version. (ecClientVerDisallowed)"},
    0x000004E0 -> new NameMeaning {Name = "RpcHttpDisallowed", Meaning = "The server is configured to block RPC connections via HTTP. (ecRpcHttpDisallowed)"},
    0x000004E1 -> new NameMeaning {Name = "CachedModeRequired", Meaning = "The server is configured to block online mode connections; only cached mode connections are allowed. (ecCachedModeRequired)"},
    0x000004E3 -> new NameMeaning {Name = "FolderNotCleanedUp", Meaning = "The folder has been deleted but not yet cleaned up. (ecFolderNotCleanedUp)"},
    0x000004ED -> new NameMeaning {Name = "FormatError", Meaning = "Part of a ROP buffer was incorrectly formatted. (ecFmtError)"},
    0x000004F7 -> new NameMeaning {Name = "NotExpanded", Meaning = "Error in expanding or collapsing rows in a categorized view. (ecNotExpanded)"},
    0x000004F8 -> new NameMeaning {Name = "NotCollapsed", Meaning = "Error in expanding or collapsing rows in a categorized view. (ecNotCollapsed)"},
    0x000004F9 -> new NameMeaning {Name = "NoExpandLeafRow", Meaning = "Leaf rows cannot be expanded; only category header rows can be expanded. (ecLeaf)"},
    0x000004FA -> new NameMeaning {Name = "UnregisteredNameProp", Meaning = "An operation was attempted on a named property ID for which no name has been registered. (ecUnregisteredNameProp)"},
    0x000004FB -> new NameMeaning {Name = "FolderDisabled", Meaning = "Access to the folder is disabled, perhaps because form design is in progress. (ecFolderDisabled)"},
    0x000004FC -> new NameMeaning {Name = "DomainError", Meaning = "There is an inconsistency in the Store object's association with its server. (ecDomainError)"},
    0x000004FF -> new NameMeaning {Name = "NoCreateRight", Meaning = "The operation requires create access rights that the user does not have. (ecNoCreateRight)"},
    0x00000500 -> new NameMeaning {Name = "PublicRoot", Meaning = "The operation requires create access rights at a public folder root. (ecPublicRoot)"},
    0x00000501 -> new NameMeaning {Name = "NoReadRight", Meaning = "The operation requires read access rights that the user does not have. (ecNoReadRight)"},
    0x00000502 -> new NameMeaning {Name = "NoCreateSubfolderRight", Meaning = "The operation requires create subfolder access rights that the user does not have. (ecNoCreateSubfolderRight)"},
    0x00000504 -> new NameMeaning {Name = "MessageCycle", Meaning = "The source message contains the destination message and cannot be attached to it. (ecMsgCycle)"},
    0x00000503 -> new NameMeaning {Name = "NullDestinationObject", Meaning = "The RPC buffer contains a destination object handle that could not be resolved to a server object. (ecDstNullObject)"},
    0x00000505 -> new NameMeaning {Name = "TooManyRecips", Meaning = "A hard limit on the number of recipients (1) per message was exceeded. (ecTooManyRecips)"},
    0x0000050A -> new NameMeaning {Name = "VirusScanInProgress", Meaning = "The operation failed because the target message is being scanned for viruses. (ecVirusScanInProgress)"},
    0x0000050B -> new NameMeaning {Name = "VirusDetected", Meaning = "The operation failed because the target message is infected with a virus. (ecVirusDetected)"},
    0x0000050C -> new NameMeaning {Name = "MailboxInTransit", Meaning = "The mailbox is in transit and is not accepting mail. (ecMailboxInTransit)"},
    0x0000050D -> new NameMeaning {Name = "BackupInProgress", Meaning = "The operation failed because the Store object is being backed up. (ecBackupInProgress)"},
    0x0000050E -> new NameMeaning {Name = "VirusMessageDeleted", Meaning = "The operation failed because the target message was infected with a virus and has been deleted. (ecVirusMessageDeleted)"},
    0x0000050F -> new NameMeaning {Name = "InvalidBackupSequence", Meaning = "Backup steps were performed out of sequence. (ecInvalidBackupSequence)"},
    0x00000510 -> new NameMeaning {Name = "InvalidBackupType", Meaning = "The requested backup type was not recognized. (ecInvalidBackupType)"},
    0x00000511 -> new NameMeaning {Name = "TooManyBackups", Meaning = "Too many backups are already in progress. (ecTooManyBackupsInProgress)"},
    0x00000512 -> new NameMeaning {Name = "RestoreInProgress", Meaning = "A restore is already in progress. (ecRestoreInProgress)"},
    0x00000579 -> new NameMeaning {Name = "DuplicateObject", Meaning = "The object already exists. (ecDuplicateObject)"},
    0x0000057A -> new NameMeaning {Name = "ObjectNotFound", Meaning = "An internal database object could not be found. (ecObjectNotFound)"},
    0x0000057B -> new NameMeaning {Name = "FixupReplyRule", Meaning = "The template Message ID in a reply rule (4) object is missing or incorrect. (ecFixupReplyRule)"},
    0x0000057C -> new NameMeaning {Name = "TemplateNotFound", Meaning = "The reply template could not be found for a message that triggered an auto-reply rule (4). (ecTemplateNotFound)"},
    0x0000057D -> new NameMeaning {Name = "RuleExecution", Meaning = "An error occurred while executing a rule (4) action (3). (ecRuleExecution)"},
    0x0000057E -> new NameMeaning {Name = "DSNoSuchObject", Meaning = "A server object could not be found in the directory. (ecDSNoSuchObject)"},
    0x0000057F -> new NameMeaning {Name = "AlreadyTombstoned", Meaning = "An attempt to tombstone a message already in the message tombstone list failed. (ecMessageAlreadyTombstoned)"},
    0x00000596 -> new NameMeaning {Name = "ReadOnlyTransaction", Meaning = "A write operation was attempted in a read-only transaction. (ecRequiresRWTransaction)"},
    0x0000060E -> new NameMeaning {Name = "Paused", Meaning = "Attempt to pause a server that is already paused. (ecPaused)"},
    0x0000060F -> new NameMeaning {Name = "NotPaused", Meaning = "Attempt to unpause a server that is not paused. (ecNotPaused)"},
    0x00000648 -> new NameMeaning {Name = "WrongMailbox", Meaning = "The operation was attempted on the wrong mailbox. (ecWrongMailbox)"},
    0x0000064C -> new NameMeaning {Name = "ChangePassword", Meaning = "The account password needs to be changed. (ecChgPassword)"},
    0x0000064D -> new NameMeaning {Name = "PasswordExpired", Meaning = "The account password has expired. (ecPwdExpired)"},
    0x0000064E -> new NameMeaning {Name = "InvalidWorkstation", Meaning = "The account has logged on from the wrong workstation. (ecInvWkstn)"},
    0x0000064F -> new NameMeaning {Name = "InvalidLogonHours", Meaning = "The account has logged on at the wrong time of day. (ecInvLogonHrs)"},
    0x00000650 -> new NameMeaning {Name = "AccountDisabled", Meaning = "The account is disabled. (ecAcctDisabled)"},
    0x000006A4 -> new NameMeaning {Name = "RuleVersion", Meaning = "The rule (4) data contains an invalid rule (4) version. (ecRuleVersion)"},
    0x000006A5 -> new NameMeaning {Name = "RuleFormat", Meaning = "The rule (4) condition or action (3) was incorrectly formatted. (ecRuleFormat)"},
    0x000006A6 -> new NameMeaning {Name = "RuleSendAsDenied", Meaning = "The rule (4) is not authorized to send from this mailbox. (ecRuleSendAsDenied)"},
    0x000006B9 -> new NameMeaning {Name = "NoServerSupport", Meaning = "A newer client requires functionality that an older server does not support. (ecNoServerSupport)"},
    0x000006BA -> new NameMeaning {Name = "LockTimedOut", Meaning = "An attempt to unlock a message failed because the lock had already timed out. (ecLockTimedOut)"},
    0x000006BB -> new NameMeaning {Name = "ObjectLocked", Meaning = "The operation failed because the target object is locked. (ecObjectLocked)"},
    0x000006BD -> new NameMeaning {Name = "InvalidLockNamespace", Meaning = "Attempt to lock a nonexistent object. (ecInvalidLockNamespace)"},
    0x000007D6 -> new NameMeaning {Name = "MessageDeleted", Meaning = "Operation failed because the message has been deleted. (ecMessageDeleted)"},
    0x000007D8 -> new NameMeaning {Name = "ProtocolDisabled", Meaning = "The requested protocol is disabled in the server configuration. (ecProtocolDisabled)"},
    0x000007D9 -> new NameMeaning {Name = "CleartextLogonDisabled", Meaning = "Clear text logons were disabled. (ecCleartextLogonDisabled)"},
    0x000007EE -> new NameMeaning {Name = "Rejected", Meaning = "The operation was rejected, perhaps because it is not supported. (ecRejected)"},
    0x0000089A -> new NameMeaning {Name = "AmbiguousAlias", Meaning = "User account information did not uniquely identify a user. (ecAmbiguousAlias)"},
    0x0000089B -> new NameMeaning {Name = "UnknownMailbox", Meaning = "No mailbox object for this logon exists in the address book. (ecUnknownMailbox)"},
    0x000008FC -> new NameMeaning {Name = "ExpressionReserved", Meaning = "Internal error in evaluating an expression. (ecExpReserved)"},
    0x000008FD -> new NameMeaning {Name = "ExpressionParseDepth", Meaning = "The expression tree exceeds a defined depth limit. (ecExpParseDepth)"},
    0x000008FE -> new NameMeaning {Name = "ExpressionArgumentType", Meaning = "An argument to a function has the wrong type. (ecExpFuncArgType)"},
    0x000008FF -> new NameMeaning {Name = "ExpressionSyntax", Meaning = "Syntax error in expression. (ecExpSyntax)"},
    0x00000900 -> new NameMeaning {Name = "ExpressionBadStringToken", Meaning = "Invalid string token in expression. (ecExpBadStrToken)"},
    0x00000901 -> new NameMeaning {Name = "ExpressionBadColToken", Meaning = "Invalid column name in expression. (ecExpBadColToken)"},
    0x00000902 -> new NameMeaning {Name = "ExpressionTypeMismatch", Meaning = "Property types, for example, in a comparison expression, are incompatible. (ecExpTypeMismatch)"},
    0x00000903 -> new NameMeaning {Name = "ExpressionOperatorNotSupported", Meaning = "The requested operator is not supported. (ecExpOpNotSupported)"},
    0x00000904 -> new NameMeaning {Name = "ExpressionDivideByZero", Meaning = "Divide by zero doesn't work. (ecExpDivByZero)"},
    0x00000905 -> new NameMeaning {Name = "ExpressionUnaryArgument", Meaning = "The argument to a unary expression is of incorrect type. (ecExpUnaryArgType)"},
    0x00000960 -> new NameMeaning {Name = "NotLocked", Meaning = "An attempt to lock a resource failed. (ecNotLocked)"},
    0x00000961 -> new NameMeaning {Name = "ClientEvent", Meaning = "A client-supplied event has fired. (ecClientEvent)"},
    0x00000965 -> new NameMeaning {Name = "CorruptEvent", Meaning = "Data in the event table is bad. (ecCorruptEvent)"},
    0x00000966 -> new NameMeaning {Name = "CorruptWatermark", Meaning = "A watermark in the event table is bad. (ecCorruptWatermark)"},
    0x00000967 -> new NameMeaning {Name = "EventError", Meaning = "General event processing error. (ecEventError)"},
    0x00000968 -> new NameMeaning {Name = "WatermarkError", Meaning = "An event watermark is out of range or otherwise invalid. (ecWatermarkError)"},
    0x00000969 -> new NameMeaning {Name = "NonCanonicalACL", Meaning = "A modification to an ACL failed because the existing ACL is not in canonical format. (ecNonCanonicalACL)"},
    0x0000096C -> new NameMeaning {Name = "MailboxDisabled", Meaning = "Logon was unsuccessful because the mailbox is disabled. (ecMailboxDisabled)"},
    0x0000096D -> new NameMeaning {Name = "RulesFolderOverQuota", Meaning = "A move or copy rule (4) action (3) failed because the destination folder is over quota. (ecRulesFolderOverQuota)"},
    0x0000096E -> new NameMeaning {Name = "AddressBookUnavailable", Meaning = "The address book server could not be reached. (ecADUnavailable)"},
    0x0000096F -> new NameMeaning {Name = "AddressBookError", Meaning = "Unspecified error from the address book server. (ecADError)"},
    0x00000971 -> new NameMeaning {Name = "AddressBookObjectNotFound", Meaning = "An object was not found in the address book. (ecADNotFound)"},
    0x00000972 -> new NameMeaning {Name = "AddressBookPropertyError", Meaning = "A property was not found in the address book. (ecADPropertyError)"},
    0x00000970 -> new NameMeaning {Name = "NotEncrypted", Meaning = "The server is configured to force encrypted connections, but the client requested an unencrypted connection. (ecNotEncrypted)"},
    0x00000973 -> new NameMeaning {Name = "RpcServerTooBusy", Meaning = "An external RPC failed because the server was too busy. (ecRpcServerTooBusy)"},
    0x00000974 -> new NameMeaning {Name = "RpcOutOfMemory", Meaning = "An external RPC failed because the local server was out of memory. (ecRpcOutOfMemory)"},
    0x00000975 -> new NameMeaning {Name = "RpcServerOutOfMemory", Meaning = "An external RPC failed because the remote server was out of memory. (ecRpcServerOutOfMemory)"},
    0x00000976 -> new NameMeaning {Name = "RpcOutOfResources", Meaning = "An external RPC failed because the remote server was out of an unspecified resource. (ecRpcOutOfResources)"},
    0x00000977 -> new NameMeaning {Name = "RpcServerUnavailable", Meaning = "An external RPC failed because the remote server was unavailable. (ecRpcServerUnavailable)"},
    0x0000097A -> new NameMeaning {Name = "SecureSubmitError", Meaning = "A failure occurred while setting the secure submission state of a message. (ecSecureSubmitError)"},
    0x0000097C -> new NameMeaning {Name = "EventsDeleted", Meaning = "Requested events were already deleted from the queue. (ecEventsDeleted)"},
    0x0000097D -> new NameMeaning {Name = "SubsystemStopping", Meaning = "A component service is in the process of shutting down. (ecSubsystemStopping)"},
    0x0000097E -> new NameMeaning {Name = "AttendantUnavailable", Meaning = "The system attendant service is unavailable. (ecSAUnavailable)"},
    0x00000A28 -> new NameMeaning {Name = "CIStopping", Meaning = "The content indexer service is stopping. (ecCIStopping)"},
    0x00000A29 -> new NameMeaning {Name = "FxInvalidState", Meaning = "An internal fast transfer object has invalid state. (ecFxInvalidState)"},
    0x00000A2A -> new NameMeaning {Name = "FxUnexpectedMarker", Meaning = "Fast transfer parsing has hit an invalid marker. (ecFxUnexpectedMarker)"},
    0x00000A2B -> new NameMeaning {Name = "DuplicateDelivery", Meaning = "A copy of this message has already been delivered. (ecDuplicateDelivery)"},
    0x00000A2C -> new NameMeaning {Name = "ConditionViolation", Meaning = "The condition was not met for a conditional operation. (ecConditionViolation)"},
    0x00000A2D -> new NameMeaning {Name = "MaximumConnectionPoolsExceeded", Meaning = "An RPC client has exceeded the defined limit of RPC connection pools. (ecMaxPoolExceeded)"},
    0x00000A2E -> new NameMeaning {Name = "InvalidRpcHandle", Meaning = "The RPC connection is no longer valid. (ecRpcInvalidHandle)"},
    0x00000A2F -> new NameMeaning {Name = "EventNotFound", Meaning = "There are no events in the event table, or the requested event was not found. (ecEventNotFound)"},
    0x00000A30 -> new NameMeaning {Name = "PropertyNotPromoted", Meaning = "A property was not copied from the message table to the message header table. (ecPropNotPromoted)"},
    0x00000A31 -> new NameMeaning {Name = "LowFreeSpaceForDatabase", Meaning = "The drive hosting database files has little or no free space. (ecLowMdbSpace)"},
    0x00000A32 -> new NameMeaning {Name = "LowFreeSpaceForLogs", Meaning = "The drive hosting log files for the database has little or no free space. (ecLowMdbLogSpace)"},
    0x00000A33 -> new NameMeaning {Name = "MailboxIsQuarantined", Meaning = "The mailbox has been placed under quarantine by an administrator. (ecMailboxQuarantined)"},
    0x00000A34 -> new NameMeaning {Name = "DatabaseMountInProgress", Meaning = "The mailbox database is being mounted. (ecMountInProgress)"},
    0x00000A35 -> new NameMeaning {Name = "DatabaseDismountInProgress", Meaning = "The mailbox database is being dismounted. (ecDismountInProgress)"},
    0x00000A36 -> new NameMeaning {Name = "ConnectionsOverBudget", Meaning = "The number of RPC connections in use exceeds the amount budgeted for this client. (ecMaxConnectionsExceeded)"},
    0x00000A37 -> new NameMeaning {Name = "NotFoundInContainer", Meaning = "The mailbox was not found in the mailbox metadata cache. (ecNotFoundInContainer)"},
    0x00000A38 -> new NameMeaning {Name = "CannotRemove", Meaning = "An item cannot be removed from an internal list. (ecCannotRemove)"},
    0x00000A39 -> new NameMeaning {Name = "InvalidConnectionPool", Meaning = "An RPC client has attempted connection using a connection pool unknown to the server. (ecInvalidPool)"},
    0x00000A3A -> new NameMeaning {Name = "VirusScanGeneralFailure", Meaning = "A nonspecified failure occurred while scanning an item. ecVirusScannerError"},
    0xFFFFFF9C -> new NameMeaning {Name = "IsamErrorRfsFailure", Meaning = "The Resource Failure Simulator failed. (JET_errRfsFailure)"},
    0xFFFFFF9B -> new NameMeaning {Name = "IsamErrorRfsNotArmed", Meaning = "The Resource Failure Simulator has not been initialized. (JET_errRfsNotArmed)"},
    0xFFFFFF9A -> new NameMeaning {Name = "IsamErrorFileClose", Meaning = "The file could not be closed. (JET_errFileClose)"},
    0xFFFFFF99 -> new NameMeaning {Name = "IsamErrorOutOfThreads", Meaning = "The thread could not be started. (JET_errOutOfThreads)"},
    0xFFFFFF97 -> new NameMeaning {Name = "IsamErrorTooManyIO", Meaning = "The system is busy due to too many I/Os. (JET_errTooManyIO)"},
    0xFFFFFF96 -> new NameMeaning {Name = "IsamErrorTaskDropped", Meaning = "The requested asynchronous task could not be executed. (JET_errTaskDropped)"},
    0xFFFFFF95 -> new NameMeaning {Name = "IsamErrorInternalError", Meaning = "There was a fatal internal error. (JET_errInternalError)"},
    0xFFFFFF01 -> new NameMeaning {Name = "IsamErrorDatabaseBufferDependenciesCorrupted", Meaning = "The buffer dependencies were set improperly and there was a recovery failure. (JET_errDatabaseBufferDependenciesCorrupted)"},
    0xFFFFFEBE -> new NameMeaning {Name = "IsamErrorPreviousVersion", Meaning = "The version already existed and there was a recovery failure. (JET_errPreviousVersion)"},
    0xFFFFFEBD -> new NameMeaning {Name = "IsamErrorPageBoundary", Meaning = "The page boundary has been reached. (JET_errPageBoundary)"},
    0xFFFFFEBC -> new NameMeaning {Name = "IsamErrorKeyBoundary", Meaning = "The key boundary has been reached. (JET_errKeyBoundary)"},
    0xFFFFFEB9 -> new NameMeaning {Name = "IsamErrorBadPageLink", Meaning = "The database is corrupt. (JET_errBadPageLink)"},
    0xFFFFFEB8 -> new NameMeaning {Name = "IsamErrorBadBookmark", Meaning = "The bookmark has no corresponding address in the database. (JET_errBadBookmark)"},
    0xFFFFFEB2 -> new NameMeaning {Name = "IsamErrorNTSystemCallFailed", Meaning = "The call to the operating system failed. (JET_errNTSystemCallFailed)"},
    0xFFFFFEAE -> new NameMeaning {Name = "IsamErrorBadParentPageLink", Meaning = "A parent database is corrupt. (JET_errBadParentPageLink)"},
    0xFFFFFEAC -> new NameMeaning {Name = "IsamErrorSPAvailExtCacheOutOfSync", Meaning = "The AvailExt cache does not match the B+ tree. (JET_errSPAvailExtCacheOutOfSync)"},
    0xFFFFFEAB -> new NameMeaning {Name = "IsamErrorSPAvailExtCorrupted", Meaning = "The AllAvailExt space tree is corrupt. (JET_errSPAvailExtCorrupted)"},
    0xFFFFFEAA -> new NameMeaning {Name = "IsamErrorSPAvailExtCacheOutOfMemory", Meaning = "An out of memory error occurred while allocating an AvailExt cache node. (JET_errSPAvailExtCacheOutOfMemory)"},
    0xFFFFFEA9 -> new NameMeaning {Name = "IsamErrorSPOwnExtCorrupted", Meaning = "The OwnExt space tree is corrupt. (JET_errSPOwnExtCorrupted)"},
    0xFFFFFEA8 -> new NameMeaning {Name = "IsamErrorDbTimeCorrupted", Meaning = "The Dbtime on the current page is greater than the global database dbtime. (JET_errDbTimeCorrupted)"},
    0xFFFFFEA6 -> new NameMeaning {Name = "IsamErrorKeyTruncated", Meaning = "An attempt to create a key for an index entry failed because the key would have been truncated and the index definition disallows key truncation. (JET_errKeyTruncated)"},
    0xFFFFFE68 -> new NameMeaning {Name = "IsamErrorKeyTooBig", Meaning = "The key is too large. (JET_errKeyTooBig)"},
    0xFFFFFE0C -> new NameMeaning {Name = "IsamErrorInvalidLoggedOperation", Meaning = "The logged operation cannot be redone. (JET_errInvalidLoggedOperation)"},
    0xFFFFFE0B -> new NameMeaning {Name = "IsamErrorLogFileCorrupt", Meaning = "The log file is corrupt. (JET_errLogFileCorrupt)"},
    0xFFFFFE09 -> new NameMeaning {Name = "IsamErrorNoBackupDirectory", Meaning = "A backup directory was not given. (JET_errNoBackupDirectory)"},
    0xFFFFFE08 -> new NameMeaning {Name = "IsamErrorBackupDirectoryNotEmpty", Meaning = "The backup directory is not empty. (JET_errBackupDirectoryNotEmpty)"},
    0xFFFFFE07 -> new NameMeaning {Name = "IsamErrorBackupInProgress", Meaning = "The backup is already active. (JET_errBackupInProgress)"},
    0xFFFFFE06 -> new NameMeaning {Name = "IsamErrorRestoreInProgress", Meaning = "A restore is in progress. (JET_errRestoreInProgress)"},
    0xFFFFFE03 -> new NameMeaning {Name = "IsamErrorMissingPreviousLogFile", Meaning = "The log file is missing for the checkpoint. (JET_errMissingPreviousLogFile)"},
    0xFFFFFE02 -> new NameMeaning {Name = "IsamErrorLogWriteFail", Meaning = "There was a failure writing to the log file. (JET_errLogWriteFail)"},
    0xFFFFFE01 -> new NameMeaning {Name = "IsamErrorLogDisabledDueToRecoveryFailure", Meaning = "The attempt to write to the log after recovery failed. (JET_errLogDisabledDueToRecoveryFailure)"},
    0xFFFFFE00 -> new NameMeaning {Name = "IsamErrorCannotLogDuringRecoveryRedo", Meaning = "The attempt to write to the log during the recovery redo failed. (JET_errCannotLogDuringRecoveryRedo)"},
    0xFFFFFDFF -> new NameMeaning {Name = "IsamErrorLogGenerationMismatch", Meaning = "The name of the log file does not match the internal generation number. (JET_errLogGenerationMismatch)"},
    0xFFFFFDFE -> new NameMeaning {Name = "IsamErrorBadLogVersion", Meaning = "The version of the log file is not compatible with the ESE version. (JET_errBadLogVersion)"},
    0xFFFFFDFD -> new NameMeaning {Name = "IsamErrorInvalidLogSequence", Meaning = "The time stamp in the next log does not match the expected time stamp. (JET_errInvalidLogSequence)"},
    0xFFFFFDFC -> new NameMeaning {Name = "IsamErrorLoggingDisabled", Meaning = "The log is not active. (JET_errLoggingDisabled)"},
    0xFFFFFDFB -> new NameMeaning {Name = "IsamErrorLogBufferTooSmall", Meaning = "The log buffer is too small for recovery. (JET_errLogBufferTooSmall)"},
    0xFFFFFDF9 -> new NameMeaning {Name = "IsamErrorLogSequenceEnd", Meaning = "The maximum log file number has been exceeded. (JET_errLogSequenceEnd)"},
    0xFFFFFDF8 -> new NameMeaning {Name = "IsamErrorNoBackup", Meaning = "There is no backup in progress. (JET_errNoBackup)"},
    0xFFFFFDF7 -> new NameMeaning {Name = "IsamErrorInvalidBackupSequence", Meaning = "The backup call is out of sequence. (JET_errInvalidBackupSequence)"},
    0xFFFFFDF5 -> new NameMeaning {Name = "IsamErrorBackupNotAllowedYet", Meaning = "A backup cannot be done at this time. (JET_errBackupNotAllowedYet)"},
    0xFFFFFDF4 -> new NameMeaning {Name = "IsamErrorDeleteBackupFileFail", Meaning = "A backup file could not be deleted. (JET_errDeleteBackupFileFail)"},
    0xFFFFFDF3 -> new NameMeaning {Name = "IsamErrorMakeBackupDirectoryFail", Meaning = "The backup temporary directory could not be created. (JET_errMakeBackupDirectoryFail)"},
    0xFFFFFDF2 -> new NameMeaning {Name = "IsamErrorInvalidBackup", Meaning = "Circular logging is enabled; an incremental backup cannot be performed. (JET_errInvalidBackup)"},
    0xFFFFFDF1 -> new NameMeaning {Name = "IsamErrorRecoveredWithErrors", Meaning = "The data was restored with errors. (JET_errRecoveredWithErrors)"},
    0xFFFFFDF0 -> new NameMeaning {Name = "IsamErrorMissingLogFile", Meaning = "The current log file is missing. (JET_errMissingLogFile)"},
    0xFFFFFDEF -> new NameMeaning {Name = "IsamErrorLogDiskFull", Meaning = "The log disk is full. (JET_errLogDiskFull)"},
    0xFFFFFDEE -> new NameMeaning {Name = "IsamErrorBadLogSignature", Meaning = "There is a bad signature for a log file. (JET_errBadLogSignature)"},
    0xFFFFFDED -> new NameMeaning {Name = "IsamErrorBadDbSignature", Meaning = "There is a bad signature for a database file. (JET_errBadDbSignature)"},
    0xFFFFFDEC -> new NameMeaning {Name = "IsamErrorBadCheckpointSignature", Meaning = "There is a bad signature for a checkpoint file. (JET_errBadCheckpointSignature)"},
    0xFFFFFDEB -> new NameMeaning {Name = "IsamErrorCheckpointCorrupt", Meaning = "The checkpoint file was not found or was corrupt. (JET_errCheckpointCorrupt)"},
    0xFFFFFDEA -> new NameMeaning {Name = "IsamErrorMissingPatchPage", Meaning = "The database patch file page was not found during recovery. (JET_errMissingPatchPage)"},
    0xFFFFFDE9 -> new NameMeaning {Name = "IsamErrorBadPatchPage", Meaning = "The database patch file page is not valid. (JET_errBadPatchPage)"},
    0xFFFFFDE8 -> new NameMeaning {Name = "IsamErrorRedoAbruptEnded", Meaning = "The redo abruptly ended due to a sudden failure while reading logs from the log file. (JET_errRedoAbruptEnded)"},
    0xFFFFFDE7 -> new NameMeaning {Name = "IsamErrorBadSLVSignature", Meaning = "The signature in the SLV file does not agree with the database. (JET_errBadSLVSignature)"},
    0xFFFFFDE6 -> new NameMeaning {Name = "IsamErrorPatchFileMissing", Meaning = "The hard restore detected that a database patch file is missing from the backup set. (JET_errPatchFileMissing)"},
    0xFFFFFDE5 -> new NameMeaning {Name = "IsamErrorDatabaseLogSetMismatch", Meaning = "The database does not belong with the current set of log files. (JET_errDatabaseLogSetMismatch)"},
    0xFFFFFDE4 -> new NameMeaning {Name = "IsamErrorDatabaseStreamingFileMismatch", Meaning = "This flag is reserved. (JET_errDatabaseStreamingFileMismatch)"},
    0xFFFFFDE3 -> new NameMeaning {Name = "IsamErrorLogFileSizeMismatch", Meaning = "The actual log file size does not match the configured size. (JET_errLogFileSizeMismatch)"},
    0xFFFFFDE2 -> new NameMeaning {Name = "IsamErrorCheckpointFileNotFound", Meaning = "The checkpoint file could not be located. (JET_errCheckpointFileNotFound)"},
    0xFFFFFDE1 -> new NameMeaning {Name = "IsamErrorRequiredLogFilesMissing", Meaning = "The required log files for recovery are missing. (JET_errRequiredLogFilesMissing)"},
    0xFFFFFDE0 -> new NameMeaning {Name = "IsamErrorSoftRecoveryOnBackupDatabase", Meaning = "A soft recovery is about to be used on a backup database when a restore is supposed to be used instead. (JET_errSoftRecoveryOnBackupDatabase)"},
    0xFFFFFDDF -> new NameMeaning {Name = "IsamErrorLogFileSizeMismatchDatabasesConsistent", Meaning = "The databases have been recovered, but the log file size used during recovery does not match JET_paramLogFileSize. (JET_errLogFileSizeMismatchDatabasesConsistent)"},
    0xFFFFFDDE -> new NameMeaning {Name = "IsamErrorLogSectorSizeMismatch", Meaning = "The log file sector size does not match the sector size of the current volume. (JET_errLogSectorSizeMismatch)"},
    0xFFFFFDDD -> new NameMeaning {Name = "IsamErrorLogSectorSizeMismatchDatabasesConsistent", Meaning = "The databases have been recovered, but the log file sector size (used during recovery) does not match the sector size of the current volume. (JET_errLogSectorSizeMismatchDatabasesConsistent)"},
    0xFFFFFDDC -> new NameMeaning {Name = "IsamErrorLogSequenceEndDatabasesConsistent", Meaning = "The databases have been recovered, but all possible log generations in the current sequence have been used. All log files and the checkpoint file is required to be deleted and databases is required to be backed up before continuing. (JET_errLogSequenceEndDatabasesConsistent)"},
    0xFFFFFDDB -> new NameMeaning {Name = "IsamErrorStreamingDataNotLogged", Meaning = "There was an illegal attempt to replay a streaming file operation where the data was not logged. This is probably caused by an attempt to roll forward with circular logging enabled. (JET_errStreamingDataNotLogged)"},
    0xFFFFFDDA -> new NameMeaning {Name = "IsamErrorDatabaseDirtyShutdown", Meaning = "The database was not shut down cleanly. A recovery is required first be run to properly complete database operations for the previous shutdown. (JET_errDatabaseDirtyShutdown)"},
    0xFFFFFDD9 -> new NameMeaning {Name = "IsamErrorConsistentTimeMismatch", Meaning = "The last consistent time for the database has not been matched. (JET_errConsistentTimeMismatch)"},
    0xFFFFFDD8 -> new NameMeaning {Name = "IsamErrorDatabasePatchFileMismatch", Meaning = "The database patch file is not generated from this backup. (JET_errDatabasePatchFileMismatch)"},
    0xFFFFFDD7 -> new NameMeaning {Name = "IsamErrorEndingRestoreLogTooLow", Meaning = "The starting log number is too low for the restore. (JET_errEndingRestoreLogTooLow)"},
    0xFFFFFDD6 -> new NameMeaning {Name = "IsamErrorStartingRestoreLogTooHigh", Meaning = "The starting log number is too high for the restore. (JET_errStartingRestoreLogTooHigh)"},
    0xFFFFFDD5 -> new NameMeaning {Name = "IsamErrorGivenLogFileHasBadSignature", Meaning = "The restore log file has a bad signature. (JET_errGivenLogFileHasBadSignature)"},
    0xFFFFFDD4 -> new NameMeaning {Name = "IsamErrorGivenLogFileIsNotContiguous", Meaning = "The restore log file is not contiguous. (JET_errGivenLogFileIsNotContiguous)"},
    0xFFFFFDD3 -> new NameMeaning {Name = "IsamErrorMissingRestoreLogFiles", Meaning = "Some restore log files are missing. (JET_errMissingRestoreLogFiles)"},
    0xFFFFFDD0 -> new NameMeaning {Name = "IsamErrorMissingFullBackup", Meaning = "The database missed a previous full backup before attempting to perform an incremental backup. (JET_errMissingFullBackup)"},
    0xFFFFFDCF -> new NameMeaning {Name = "IsamErrorBadBackupDatabaseSize", Meaning = "The backup database size is not a multiple of the database page size. (JET_errBadBackupDatabaseSize)"},
    0xFFFFFDCE -> new NameMeaning {Name = "IsamErrorDatabaseAlreadyUpgraded", Meaning = "The current attempt to upgrade a database has been stopped because the database is already current. (JET_errDatabaseAlreadyUpgraded)"},
    0xFFFFFDCD -> new NameMeaning {Name = "IsamErrorDatabaseIncompleteUpgrade", Meaning = "The database was only partially converted to the current format. The database is required to be restored from backup. (JET_errDatabaseIncompleteUpgrade)"},
    0xFFFFFDCB -> new NameMeaning {Name = "IsamErrorMissingCurrentLogFiles", Meaning = "Some current log files are missing for continuous restore. (JET_errMissingCurrentLogFiles)"},
    0xFFFFFDCA -> new NameMeaning {Name = "IsamErrorDbTimeTooOld", Meaning = "The dbtime on a page is smaller than the dbtimeBefore that is in the record. (JET_errDbTimeTooOld)"},
    0xFFFFFDC9 -> new NameMeaning {Name = "IsamErrorDbTimeTooNew", Meaning = "The dbtime on a page is in advance of the dbtimeBefore that is in the record. (JET_errDbTimeTooNew)"},
    0xFFFFFDC7 -> new NameMeaning {Name = "IsamErrorMissingFileToBackup", Meaning = "Some log or database patch files were missing during the backup. (JET_errMissingFileToBackup)"},
    0xFFFFFDC6 -> new NameMeaning {Name = "IsamErrorLogTornWriteDuringHardRestore", Meaning = "A torn write was detected in a backup that was set during a hard restore. (JET_errLogTornWriteDuringHardRestore)"},
    0xFFFFFDC5 -> new NameMeaning {Name = "IsamErrorLogTornWriteDuringHardRecovery", Meaning = "A torn write was detected during a hard recovery (the log was not part of a backup set). (JET_errLogTornWriteDuringHardRecovery)"},
    0xFFFFFDC3 -> new NameMeaning {Name = "IsamErrorLogCorruptDuringHardRestore", Meaning = "Corruption was detected in a backup set during a hard restore. (JET_errLogCorruptDuringHardRestore)"},
    0xFFFFFDC2 -> new NameMeaning {Name = "IsamErrorLogCorruptDuringHardRecovery", Meaning = "Corruption was detected during hard recovery (the log was not part of a backup set). (JET_errLogCorruptDuringHardRecovery)"},
    0xFFFFFDC1 -> new NameMeaning {Name = "IsamErrorMustDisableLoggingForDbUpgrade", Meaning = "Logging cannot be enabled while attempting to upgrade a database. (JET_errMustDisableLoggingForDbUpgrade)"},
    0xFFFFFDBF -> new NameMeaning {Name = "IsamErrorBadRestoreTargetInstance", Meaning = "Either the TargetInstance that was specified for restore has not been found or the log files do not match. (JET_errBadRestoreTargetInstance)"},
    0xFFFFFDBD -> new NameMeaning {Name = "IsamErrorRecoveredWithoutUndo", Meaning = "The database engine successfully replayed all operations in the transaction log to perform a crash recovery but the caller elected to stop recovery without rolling back uncommitted updates. (JET_errRecoveredWithoutUndo)"},
    0xFFFFFDBC -> new NameMeaning {Name = "IsamErrorDatabasesNotFromSameSnapshot", Meaning = "The databases to be restored are not from the same shadow copy backup. (JET_errDatabasesNotFromSameSnapshot)"},
    0xFFFFFDBB -> new NameMeaning {Name = "IsamErrorSoftRecoveryOnSnapshot", Meaning = "There is a soft recovery on a database from a shadow copy backup set. (JET_errSoftRecoveryOnSnapshot)"},
    0xFFFFFDBA -> new NameMeaning {Name = "IsamErrorCommittedLogFilesMissing", Meaning = "One or more logs that were committed to this database are missing. (JET_errCommittedLogFilesMissing)"},
    0xFFFFFDB6 -> new NameMeaning {Name = "IsamErrorCommittedLogFilesCorrupt", Meaning = "One or more logs were found to be corrupt during recovery. (JET_errCommittedLogFilesCorrupt)"},
    0xFFFFFDA7 -> new NameMeaning {Name = "IsamErrorUnicodeTranslationBufferTooSmall", Meaning = "The Unicode translation buffer is too small. (JET_errUnicodeTranslationBufferTooSmall)"},
    0xFFFFFDA6 -> new NameMeaning {Name = "IsamErrorUnicodeTranslationFail", Meaning = "The Unicode normalization failed. (JET_errUnicodeTranslationFail)"},
    0xFFFFFDA5 -> new NameMeaning {Name = "IsamErrorUnicodeNormalizationNotSupported", Meaning = "The operating system does not provide support for Unicode normalization and a normalization callback was not specified. (JET_errUnicodeNormalizationNotSupported)"},
    0xFFFFFD9E -> new NameMeaning {Name = "IsamErrorExistingLogFileHasBadSignature", Meaning = "The existing log file has a bad signature. (JET_errExistingLogFileHasBadSignature)"},
    0xFFFFFD9D -> new NameMeaning {Name = "IsamErrorExistingLogFileIsNotContiguous", Meaning = "An existing log file is not contiguous. (JET_errExistingLogFileIsNotContiguous)"},
    0xFFFFFD9C -> new NameMeaning {Name = "IsamErrorLogReadVerifyFailure", Meaning = "A checksum error was found in the log file during backup. (JET_errLogReadVerifyFailure)"},
    0xFFFFFD9B -> new NameMeaning {Name = "IsamErrorSLVReadVerifyFailure", Meaning = "A checksum error was found in the SLV file during backup. (JET_errSLVReadVerifyFailure)"},
    0xFFFFFD9A -> new NameMeaning {Name = "IsamErrorCheckpointDepthTooDeep", Meaning = "There are too many outstanding generations between the checkpoint and the current generation. (JET_errCheckpointDepthTooDeep)"},
    0xFFFFFD99 -> new NameMeaning {Name = "IsamErrorRestoreOfNonBackupDatabase", Meaning = "A hard recovery was attempted on a database that was not a backup database. (JET_errRestoreOfNonBackupDatabase)"},
    0xFFFFFC7C -> new NameMeaning {Name = "IsamErrorInvalidGrbit", Meaning = "There is an invalid grbit parameter. (JET_errInvalidGrbit)"},
    0xFFFFFC18 -> new NameMeaning {Name = "IsamErrorTermInProgress", Meaning = "Termination is in progress. (JET_errTermInProgress)"},
    0xFFFFFC17 -> new NameMeaning {Name = "IsamErrorFeatureNotAvailable", Meaning = "This API element is not supported. (JET_errFeatureNotAvailable)"},
    0xFFFFFC16 -> new NameMeaning {Name = "IsamErrorInvalidName", Meaning = "An invalid name is being used. (JET_errInvalidName)"},
    0xFFFFFC15 -> new NameMeaning {Name = "IsamErrorInvalidParameter", Meaning = "An invalid API parameter is being used. (JET_errInvalidParameter)"},
    0xFFFFFC10 -> new NameMeaning {Name = "IsamErrorDatabaseFileReadOnly", Meaning = "There was an attempt to attach to a read-only database file for read/write operations. (JET_errDatabaseFileReadOnly)"},
    0xFFFFFC0E -> new NameMeaning {Name = "IsamErrorInvalidDatabaseId", Meaning = "There is an invalid database ID. (JET_errInvalidDatabaseId)"},
    0xFFFFFC0D -> new NameMeaning {Name = "IsamErrorOutOfMemory", Meaning = "The system is out of memory. (JET_errOutOfMemory)"},
    0xFFFFFC0C -> new NameMeaning {Name = "IsamErrorOutOfDatabaseSpace", Meaning = "The maximum database size has been reached. (JET_errOutOfDatabaseSpace)"},
    0xFFFFFC0B -> new NameMeaning {Name = "IsamErrorOutOfCursors", Meaning = "The table is out of cursors. (JET_errOutOfCursors)"},
    0xFFFFFC0A -> new NameMeaning {Name = "IsamErrorOutOfBuffers", Meaning = "The database is out of page buffers. (JET_errOutOfBuffers)"},
    0xFFFFFC09 -> new NameMeaning {Name = "IsamErrorTooManyIndexes", Meaning = "There are too many indexes. (JET_errTooManyIndexes)"},
    0xFFFFFC08 -> new NameMeaning {Name = "IsamErrorTooManyKeys", Meaning = "There are too many columns in an index. (JET_errTooManyKeys)"},
    0xFFFFFC07 -> new NameMeaning {Name = "IsamErrorRecordDeleted", Meaning = "The record has been deleted. (JET_errRecordDeleted)"},
    0xFFFFFC06 -> new NameMeaning {Name = "IsamErrorReadVerifyFailure", Meaning = "There is a checksum error on a database page. (JET_errReadVerifyFailure)"},
    0xFFFFFC05 -> new NameMeaning {Name = "IsamErrorPageNotInitialized", Meaning = "There is a blank database page. (JET_errPageNotInitialized)"},
    0xFFFFFC04 -> new NameMeaning {Name = "IsamErrorOutOfFileHandles", Meaning = "There are no file handles. (JET_errOutOfFileHandles)"},
    0xFFFFFC02 -> new NameMeaning {Name = "IsamErrorDiskIO", Meaning = "There is a disk I/O error. (JET_errDiskIO)"},
    0xFFFFFC01 -> new NameMeaning {Name = "IsamErrorInvalidPath", Meaning = "A file path is invalid. (JET_errInvalidPath)"},
    0xFFFFFC00 -> new NameMeaning {Name = "IsamErrorInvalidSystemPath", Meaning = "A system path is invalid. (JET_errInvalidSystemPath)"},
    0xFFFFFBFF -> new NameMeaning {Name = "IsamErrorInvalidLogDirectory", Meaning = "A log directory is invalid. (JET_errInvalidLogDirectory)"},
    0xFFFFFBFE -> new NameMeaning {Name = "IsamErrorRecordTooBig", Meaning = "The record is larger than maximum size. (JET_errRecordTooBig)"},
    0xFFFFFBFD -> new NameMeaning {Name = "IsamErrorTooManyOpenDatabases", Meaning = "Too many databases are open. (JET_errTooManyOpenDatabases)"},
    0xFFFFFBFC -> new NameMeaning {Name = "IsamErrorInvalidDatabase", Meaning = "This is not a database file. (JET_errInvalidDatabase)"},
    0xFFFFFBFB -> new NameMeaning {Name = "IsamErrorNotInitialized", Meaning = "The database engine has not been initialized. (JET_errNotInitialized)"},
    0xFFFFFBFA -> new NameMeaning {Name = "IsamErrorAlreadyInitialized", Meaning = "The database engine is already initialized. (JET_errAlreadyInitialized)"},
    0xFFFFFBF9 -> new NameMeaning {Name = "IsamErrorInitInProgress", Meaning = "The database engine is being initialized. (JET_errInitInProgress)"},
    0xFFFFFBF8 -> new NameMeaning {Name = "IsamErrorFileAccessDenied", Meaning = "The file cannot be accessed because the file is locked or in use. (JET_errFileAccessDenied)"},
    0xFFFFFBF2 -> new NameMeaning {Name = "IsamErrorBufferTooSmall", Meaning = "The buffer is too small. (JET_errBufferTooSmall)"},
    0xFFFFFBF0 -> new NameMeaning {Name = "IsamErrorTooManyColumns", Meaning = "Too many columns are defined. (JET_errTooManyColumns)"},
    0xFFFFFBED -> new NameMeaning {Name = "IsamErrorContainerNotEmpty", Meaning = "The container is not empty. (JET_errContainerNotEmpty)"},
    0xFFFFFBEC -> new NameMeaning {Name = "IsamErrorInvalidFilename", Meaning = "The file name is invalid. (JET_errInvalidFilename)"},
    0xFFFFFBEB -> new NameMeaning {Name = "IsamErrorInvalidBookmark", Meaning = "A bookmark is invalid. (JET_errInvalidBookmark)"},
    0xFFFFFBEA -> new NameMeaning {Name = "IsamErrorColumnInUse", Meaning = "The column used is in an index. (JET_errColumnInUse)"},
    0xFFFFFBE9 -> new NameMeaning {Name = "IsamErrorInvalidBufferSize", Meaning = "The data buffer does not match the column size. (JET_errInvalidBufferSize)"},
    0xFFFFFBE8 -> new NameMeaning {Name = "IsamErrorColumnNotUpdatable", Meaning = "The column value cannot be set. (JET_errColumnNotUpdatable)"},
    0xFFFFFBE5 -> new NameMeaning {Name = "IsamErrorIndexInUse", Meaning = "The index is in use. (JET_errIndexInUse)"},
    0xFFFFFBE4 -> new NameMeaning {Name = "IsamErrorLinkNotSupported", Meaning = "The link support is unavailable. (JET_errLinkNotSupported)"},
    0xFFFFFBE3 -> new NameMeaning {Name = "IsamErrorNullKeyDisallowed", Meaning = "Null keys are not allowed on an index. (JET_errNullKeyDisallowed)"},
    0xFFFFFBE2 -> new NameMeaning {Name = "IsamErrorNotInTransaction", Meaning = "The operation has to occur within a transaction. (JET_errNotInTransaction)"},
    0xFFFFFBDD -> new NameMeaning {Name = "IsamErrorTooManyActiveUsers", Meaning = "There are too many active database users. (JET_errTooManyActiveUsers)"},
    0xFFFFFBDB -> new NameMeaning {Name = "IsamErrorInvalidCountry", Meaning = "A country/region code is invalid or unknown. (JET_errInvalidCountry)"},
    0xFFFFFBDA -> new NameMeaning {Name = "IsamErrorInvalidLanguageId", Meaning = "A language ID is invalid or unknown. (JET_errInvalidLanguageId)"},
    0xFFFFFBD9 -> new NameMeaning {Name = "IsamErrorInvalidCodePage", Meaning = "A code page is invalid or unknown. (JET_errInvalidCodePage)"},
    0xFFFFFBD8 -> new NameMeaning {Name = "IsamErrorInvalidLCMapStringFlags", Meaning = "Invalid flags are being used for LCMapString. (JET_errInvalidLCMapStringFlags)"},
    0xFFFFFBD7 -> new NameMeaning {Name = "IsamErrorVersionStoreEntryTooBig", Meaning = "There was an attempt to create a version store entry (RCE) that was larger than a version bucket. (JET_errVersionStoreEntryTooBig)"},
    0xFFFFFBD6 -> new NameMeaning {Name = "IsamErrorVersionStoreOutOfMemoryAndCleanupTimedOut", Meaning = "The version store is out of memory and the cleanup attempt failed to complete. (JET_errVersionStoreOutOfMemoryAndCleanupTimedOut)"},
    0xFFFFFBD3 -> new NameMeaning {Name = "IsamErrorVersionStoreOutOfMemory", Meaning = "The version store is out of memory and a cleanup was already attempted. (JET_errVersionStoreOutOfMemory)"},
    0xFFFFFBD1 -> new NameMeaning {Name = "IsamErrorCannotIndex", Meaning = "The escrow and SLV columns cannot be indexed. (JET_errCannotIndex)"},
    0xFFFFFBD0 -> new NameMeaning {Name = "IsamErrorRecordNotDeleted", Meaning = "The record has not been deleted. (JET_errRecordNotDeleted)"},
    0xFFFFFBCF -> new NameMeaning {Name = "IsamErrorTooManyMempoolEntries", Meaning = "Too many mempool entries have been requested. (JET_errTooManyMempoolEntries)"},
    0xFFFFFBCE -> new NameMeaning {Name = "IsamErrorOutOfObjectIDs", Meaning = "The database is out of B+ tree ObjectIDs so an offline defragmentation has to be performed to reclaim freed or unused ObjectIDs. (JET_errOutOfObjectIDs)"},
    0xFFFFFBCD -> new NameMeaning {Name = "IsamErrorOutOfLongValueIDs", Meaning = "The Long-value ID counter has reached the maximum value. An offline defragmentation has to be performed to reclaim free or unused LongValueIDs. (JET_errOutOfLongValueIDs)"},
    0xFFFFFBCC -> new NameMeaning {Name = "IsamErrorOutOfAutoincrementValues", Meaning = "The automatic increment counter has reached the maximum value. An offline defragmentation will not be able to reclaim free or unused automatically increment values. (JET_errOutOfAutoincrementValues)"},
    0xFFFFFBCB -> new NameMeaning {Name = "IsamErrorOutOfDbtimeValues", Meaning = "The Dbtime counter has reached the maximum value. An offline defragmentation is required to be performed to reclaim free or unused Dbtime values. (JET_errOutOfDbtimeValues)"},
    0xFFFFFBCA -> new NameMeaning {Name = "IsamErrorOutOfSequentialIndexValues", Meaning = "A sequential index counter has reached the maximum value. An offline defragmentation has to  be performed to reclaim Free or unused SequentialIndex values. (JET_errOutOfSequentialIndexValues)"},
    0xFFFFFBC8 -> new NameMeaning {Name = "IsamErrorRunningInOneInstanceMode", Meaning = "This multi-instance call has the single-instance mode enabled. (JET_errRunningInOneInstanceMode)"},
    0xFFFFFBC7 -> new NameMeaning {Name = "IsamErrorRunningInMultiInstanceMode", Meaning = "This single-instance call has the multi-instance mode enabled. (JET_errRunningInMultiInstanceMode)"},
    0xFFFFFBC6 -> new NameMeaning {Name = "IsamErrorSystemParamsAlreadySet", Meaning = "The global system parameters have already been set. (JET_errSystemParamsAlreadySet)"},
    0xFFFFFBC5 -> new NameMeaning {Name = "IsamErrorSystemPathInUse", Meaning = "The system path is already being used by another database instance. (JET_errSystemPathInUse)"},
    0xFFFFFBC4 -> new NameMeaning {Name = "IsamErrorLogFilePathInUse", Meaning = "The log file path is already being used by another database instance. (JET_errLogFilePathInUse)"},
    0xFFFFFBC3 -> new NameMeaning {Name = "IsamErrorTempPathInUse", Meaning = "The path to the temporary database is already being used by another database instance. (JET_errTempPathInUse)"},
    0xFFFFFBC2 -> new NameMeaning {Name = "IsamErrorInstanceNameInUse", Meaning = "The instance name is already in use. (JET_errInstanceNameInUse)"},
    0xFFFFFBBE -> new NameMeaning {Name = "IsamErrorInstanceUnavailable", Meaning = "This instance cannot be used because it encountered a fatal error. (JET_errInstanceUnavailable)"},
    0xFFFFFBBD -> new NameMeaning {Name = "IsamErrorDatabaseUnavailable", Meaning = "This database cannot be used because it encountered a fatal error. (JET_errDatabaseUnavailable)"},
    0xFFFFFBBC -> new NameMeaning {Name = "IsamErrorInstanceUnavailableDueToFatalLogDiskFull", Meaning = "This instance cannot be used because it encountered a log-disk-full error while performing an operation (such as a transaction rollback) that could not tolerate failure. (JET_errInstanceUnavailableDueToFatalLogDiskFull)"},
    0xFFFFFBB3 -> new NameMeaning {Name = "IsamErrorOutOfSessions", Meaning = "The database is out of sessions. (JET_errOutOfSessions)"},
    0xFFFFFBB2 -> new NameMeaning {Name = "IsamErrorWriteConflict", Meaning = "The write lock failed due to the existence of an outstanding write lock. (JET_errWriteConflict)"},
    0xFFFFFBB1 -> new NameMeaning {Name = "IsamErrorTransTooDeep", Meaning = "The transactions are nested too deeply. (JET_errTransTooDeep)"},
    0xFFFFFBB0 -> new NameMeaning {Name = "IsamErrorInvalidSesid", Meaning = "A session handle is invalid. (JET_errInvalidSesid)"},
    0xFFFFFBAF -> new NameMeaning {Name = "IsamErrorWriteConflictPrimaryIndex", Meaning = "An update was attempted on an uncommitted primary index. (JET_errWriteConflictPrimaryIndex)"},
    0xFFFFFBAC -> new NameMeaning {Name = "IsamErrorInTransaction", Meaning = "The operation is not allowed within a transaction. (JET_errInTransaction)"},
    0xFFFFFBAB -> new NameMeaning {Name = "IsamErrorRollbackRequired", Meaning = "The current transaction is required to be rolled back. It cannot be committed and a new one cannot be started. (JET_errRollbackRequired)"},
    0xFFFFFBAA -> new NameMeaning {Name = "IsamErrorTransReadOnly", Meaning = "A read-only transaction tried to modify the database. (JET_errTransReadOnly)"},
    0xFFFFFBA9 -> new NameMeaning {Name = "IsamErrorSessionWriteConflict", Meaning = "Two different cursors attempted to replace the same record in the same session. (JET_errSessionWriteConflict)"},
    0xFFFFFBA8 -> new NameMeaning {Name = "IsamErrorRecordTooBigForBackwardCompatibility", Meaning = "The record would be too big if represented in a database format from a previous version of Jet. (JET_errRecordTooBigForBackwardCompatibility)"},
    0xFFFFFBA7 -> new NameMeaning {Name = "IsamErrorCannotMaterializeForwardOnlySort", Meaning = "The temporary table could not be created due to parameters that conflict with JET_bitTTForwardOnly. (JET_errCannotMaterializeForwardOnlySort)"},
    0xFFFFFBA6 -> new NameMeaning {Name = "IsamErrorSesidTableIdMismatch", Meaning = "The session handle cannot be used with the table id because it was not used to create it. (JET_errSesidTableIdMismatch)"},
    0xFFFFFBA5 -> new NameMeaning {Name = "IsamErrorInvalidInstance", Meaning = "The instance handle is invalid or refers to an instance that has been shut down. (JET_errInvalidInstance)"},
    0xFFFFFB4F -> new NameMeaning {Name = "IsamErrorDatabaseDuplicate", Meaning = "The database already exists. (JET_errDatabaseDuplicate)"},
    0xFFFFFB4E -> new NameMeaning {Name = "IsamErrorDatabaseInUse", Meaning = "The database in use. (JET_errDatabaseInUse)"},
    0xFFFFFB4D -> new NameMeaning {Name = "IsamErrorDatabaseNotFound", Meaning = "No such database exists. (JET_errDatabaseNotFound)"},
    0xFFFFFB4C -> new NameMeaning {Name = "IsamErrorDatabaseInvalidName", Meaning = "The database name is invalid. (JET_errDatabaseInvalidName)"},
    0xFFFFFB4B -> new NameMeaning {Name = "IsamErrorDatabaseInvalidPages", Meaning = "The number of pages is invalid. (JET_errDatabaseInvalidPages)"},
    0xFFFFFB4A -> new NameMeaning {Name = "IsamErrorDatabaseCorrupted", Meaning = "There is a nondatabase file or corrupt database. (JET_errDatabaseCorrupted)"},
    0xFFFFFB49 -> new NameMeaning {Name = "IsamErrorDatabaseLocked", Meaning = "The database is exclusively locked. (JET_errDatabaseLocked)"},
    0xFFFFFB48 -> new NameMeaning {Name = "IsamErrorCannotDisableVersioning", Meaning = "The versioning for this database cannot be disabled. (JET_errCannotDisableVersioning)"},
    0xFFFFFB47 -> new NameMeaning {Name = "IsamErrorInvalidDatabaseVersion", Meaning = "The database engine is incompatible with the database. (JET_errInvalidDatabaseVersion)"},
    0xFFFFFB46 -> new NameMeaning {Name = "IsamErrorDatabase200Format", Meaning = "The database is in an older (200) format. (JET_errDatabase200Format)"},
    0xFFFFFB45 -> new NameMeaning {Name = "IsamErrorDatabase400Format", Meaning = "The database is in an older (400) format. (JET_errDatabase400Format)"},
    0xFFFFFB44 -> new NameMeaning {Name = "IsamErrorDatabase500Format", Meaning = "The database is in an older (500) format. (JET_errDatabase500Format)"},
    0xFFFFFB43 -> new NameMeaning {Name = "IsamErrorPageSizeMismatch", Meaning = "The database page size does not match the engine. (JET_errPageSizeMismatch)"},
    0xFFFFFB42 -> new NameMeaning {Name = "IsamErrorTooManyInstances", Meaning = "No more database instances can be started. (JET_errTooManyInstances)"},
    0xFFFFFB41 -> new NameMeaning {Name = "IsamErrorDatabaseSharingViolation", Meaning = "A different database instance is using this database. (JET_errDatabaseSharingViolation)"},
    0xFFFFFB40 -> new NameMeaning {Name = "IsamErrorAttachedDatabaseMismatch", Meaning = "An outstanding database attachment has been detected at the start or end of the recovery, but the database is missing or does not match attachment info. (JET_errAttachedDatabaseMismatch)"},
    0xFFFFFB3F -> new NameMeaning {Name = "IsamErrorDatabaseInvalidPath", Meaning = "The specified path to the database file is illegal. (JET_errDatabaseInvalidPath)"},
    0xFFFFFB3E -> new NameMeaning {Name = "IsamErrorDatabaseIdInUse", Meaning = "A database is being assigned an ID that is already in use. (JET_errDatabaseIdInUse)"},
    0xFFFFFB3D -> new NameMeaning {Name = "IsamErrorForceDetachNotAllowed", Meaning = "The forced detach is allowed only after the normal detach was stopped due to an error. (JET_errForceDetachNotAllowed)"},
    0xFFFFFB3C -> new NameMeaning {Name = "IsamErrorCatalogCorrupted", Meaning = "Corruption was detected in the catalog. (JET_errCatalogCorrupted)"},
    0xFFFFFB3B -> new NameMeaning {Name = "IsamErrorPartiallyAttachedDB", Meaning = "The database is only partially attached and the attach operation cannot be completed. (JET_errPartiallyAttachedDB)"},
    0xFFFFFB3A -> new NameMeaning {Name = "IsamErrorDatabaseSignInUse", Meaning = "The database with the same signature is already in use. (JET_errDatabaseSignInUse)"},
    0xFFFFFB38 -> new NameMeaning {Name = "IsamErrorDatabaseCorruptedNoRepair", Meaning = "The database is corrupted but a repair is not allowed. (JET_errDatabaseCorruptedNoRepair)"},
    0xFFFFFB37 -> new NameMeaning {Name = "IsamErrorInvalidCreateDbVersion", Meaning = "The database engine attempted to replay a Create Database operation from the transaction log but failed due to an incompatible version of that operation. (JET_errInvalidCreateDbVersion)"},
    0xFFFFFAEA -> new NameMeaning {Name = "IsamErrorTableLocked", Meaning = "The table is exclusively locked. (JET_errTableLocked)"},
    0xFFFFFAE9 -> new NameMeaning {Name = "IsamErrorTableDuplicate", Meaning = "The table already exists. (JET_errTableDuplicate)"},
    0xFFFFFAE8 -> new NameMeaning {Name = "IsamErrorTableInUse", Meaning = "The table is in use and cannot be locked. (JET_errTableInUse)"},
    0xFFFFFAE7 -> new NameMeaning {Name = "IsamErrorObjectNotFound", Meaning = "There is no such table or object. (JET_errObjectNotFound)"},
    0xFFFFFAE5 -> new NameMeaning {Name = "IsamErrorDensityInvalid", Meaning = "There is a bad file or index density. (JET_errDensityInvalid)"},
    0xFFFFFAE4 -> new NameMeaning {Name = "IsamErrorTableNotEmpty", Meaning = "The table is not empty. (JET_errTableNotEmpty)"},
    0xFFFFFAE2 -> new NameMeaning {Name = "IsamErrorInvalidTableId", Meaning = "The table ID is invalid. (JET_errInvalidTableId)"},
    0xFFFFFAE1 -> new NameMeaning {Name = "IsamErrorTooManyOpenTables", Meaning = "No more tables can be opened, even after the internal cleanup task has run. (JET_errTooManyOpenTables)"},
    0xFFFFFAE0 -> new NameMeaning {Name = "IsamErrorIllegalOperation", Meaning = "The operation is not supported on the table. (JET_errIllegalOperation)"},
    0xFFFFFADF -> new NameMeaning {Name = "IsamErrorTooManyOpenTablesAndCleanupTimedOut", Meaning = "No more tables can be opened because the cleanup attempt failed to complete. (JET_errTooManyOpenTablesAndCleanupTimedOut)"},
    0xFFFFFADE -> new NameMeaning {Name = "IsamErrorObjectDuplicate", Meaning = "The table or object name is in use. (JET_errObjectDuplicate)"},
    0xFFFFFADC -> new NameMeaning {Name = "IsamErrorInvalidObject", Meaning = "The object is invalid for operation. (JET_errInvalidObject)"},
    0xFFFFFADB -> new NameMeaning {Name = "IsamErrorCannotDeleteTempTable", Meaning = "JetCloseTable is required to be used instead of JetDeleteTable to delete a temporary table. (JET_errCannotDeleteTempTable)"},
    0xFFFFFADA -> new NameMeaning {Name = "IsamErrorCannotDeleteSystemTable", Meaning = "There was an illegal attempt to delete a system table. (JET_errCannotDeleteSystemTable)"},
    0xFFFFFAD9 -> new NameMeaning {Name = "IsamErrorCannotDeleteTemplateTable", Meaning = "There was an illegal attempt to delete a template table. (JET_errCannotDeleteTemplateTable)"},
    0xFFFFFAD6 -> new NameMeaning {Name = "IsamErrorExclusiveTableLockRequired", Meaning = "There has to be an exclusive lock on the table. (JET_errExclusiveTableLockRequired)"},
    0xFFFFFAD5 -> new NameMeaning {Name = "IsamErrorFixedDDL", Meaning = "DDL operations are prohibited on this table. (JET_errFixedDDL)"},
    0xFFFFFAD4 -> new NameMeaning {Name = "IsamErrorFixedInheritedDDL", Meaning = "On a derived table, DDL operations are prohibited on the inherited portion of the DDL. (JET_errFixedInheritedDDL)"},
    0xFFFFFAD3 -> new NameMeaning {Name = "IsamErrorCannotNestDDL", Meaning = "Nesting the hierarchical DDL is not currently supported. (JET_errCannotNestDDL)"},
    0xFFFFFAD2 -> new NameMeaning {Name = "IsamErrorDDLNotInheritable", Meaning = "There was an attempt to inherit a DDL from a table that is not marked as a template table. (JET_errDDLNotInheritable)"},
    0xFFFFFAD0 -> new NameMeaning {Name = "IsamErrorInvalidSettings", Meaning = "The system parameters were set improperly. (JET_errInvalidSettings)"},
    0xFFFFFACF -> new NameMeaning {Name = "IsamErrorClientRequestToStopJetService", Meaning = "The client has requested that the service be stopped. (JET_errClientRequestToStopJetService)"},
    0xFFFFFACE -> new NameMeaning {Name = "IsamErrorCannotAddFixedVarColumnToDerivedTable", Meaning = "The template table was created with the NoFixedVarColumnsInDerivedTables flag set. (JET_errCannotAddFixedVarColumnToDerivedTable)"},
    0xFFFFFA87 -> new NameMeaning {Name = "IsamErrorIndexCantBuild", Meaning = "The index build failed. (JET_errIndexCantBuild)"},
    0xFFFFFA86 -> new NameMeaning {Name = "IsamErrorIndexHasPrimary", Meaning = "The primary index is already defined. (JET_errIndexHasPrimary)"},
    0xFFFFFA85 -> new NameMeaning {Name = "IsamErrorIndexDuplicate", Meaning = "The index is already defined. (JET_errIndexDuplicate)"},
    0xFFFFFA84 -> new NameMeaning {Name = "IsamErrorIndexNotFound", Meaning = "There is no such index. (JET_errIndexNotFound)"},
    0xFFFFFA83 -> new NameMeaning {Name = "IsamErrorIndexMustStay", Meaning = "The clustered index cannot be deleted. (JET_errIndexMustStay)"},
    0xFFFFFA82 -> new NameMeaning {Name = "IsamErrorIndexInvalidDef", Meaning = "The index definition is invalid. (JET_errIndexInvalidDef)"},
    0xFFFFFA7F -> new NameMeaning {Name = "IsamErrorInvalidCreateIndex", Meaning = "The creation of the index description was invalid. (JET_errInvalidCreateIndex)"},
    0xFFFFFA7E -> new NameMeaning {Name = "IsamErrorTooManyOpenIndexes", Meaning = "The database is out of index description blocks. (JET_errTooManyOpenIndexes)"},
    0xFFFFFA7D -> new NameMeaning {Name = "IsamErrorMultiValuedIndexViolation", Meaning = "Non-unique inter-record index keys have been generated for a multivalued index. (JET_errMultiValuedIndexViolation)"},
    0xFFFFFA7C -> new NameMeaning {Name = "IsamErrorIndexBuildCorrupted", Meaning = "A secondary index that properly reflects the primary index failed to build. (JET_errIndexBuildCorrupted)"},
    0xFFFFFA7B -> new NameMeaning {Name = "IsamErrorPrimaryIndexCorrupted", Meaning = "The primary index is corrupt and the database is required be defragmented. (JET_errPrimaryIndexCorrupted)"},
    0xFFFFFA7A -> new NameMeaning {Name = "IsamErrorSecondaryIndexCorrupted", Meaning = "The secondary index is corrupt and the database is required to be defragmented. (JET_errSecondaryIndexCorrupted)"},
    0xFFFFFA78 -> new NameMeaning {Name = "IsamErrorInvalidIndexId", Meaning = "The index ID is invalid. (JET_errInvalidIndexId)"},
    0xFFFFFA6A -> new NameMeaning {Name = "IsamErrorIndexTuplesSecondaryIndexOnly", Meaning = "The tuple index can only be set on a secondary index. (JET_errIndexTuplesSecondaryIndexOnly)"},
    0xFFFFFA69 -> new NameMeaning {Name = "IsamErrorIndexTuplesTooManyColumns", Meaning = "The index definition for the tuple index contains more key columns that the database engine can support. (JET_errIndexTuplesTooManyColumns)"},
    0xFFFFFA68 -> new NameMeaning {Name = "IsamErrorIndexTuplesNonUniqueOnly", Meaning = "The tuple index cannot be a unique index. (JET_errIndexTuplesNonUniqueOnly)"},
    0xFFFFFA67 -> new NameMeaning {Name = "IsamErrorIndexTuplesTextBinaryColumnsOnly", Meaning = "A tuple index definition can only contain key columns that have text or binary column types. (JET_errIndexTuplesTextBinaryColumnsOnly)"},
    0xFFFFFA66 -> new NameMeaning {Name = "IsamErrorIndexTuplesVarSegMacNotAllowed", Meaning = "The tuple index does not allow setting cbVarSegMac. (JET_errIndexTuplesVarSegMacNotAllowed)"},
    0xFFFFFA65 -> new NameMeaning {Name = "IsamErrorIndexTuplesInvalidLimits", Meaning = "The minimum/maximum tuple length or the maximum number of characters that are specified for an index is invalid. (JET_errIndexTuplesInvalidLimits)"},
    0xFFFFFA64 -> new NameMeaning {Name = "IsamErrorIndexTuplesCannotRetrieveFromIndex", Meaning = "JetRetrieveColumn cannot be called with the JET_bitRetrieveFromIndex flag set while retrieving a column on a tuple index. (JET_errIndexTuplesCannotRetrieveFromIndex)"},
    0xFFFFFA63 -> new NameMeaning {Name = "IsamErrorIndexTuplesKeyTooSmall", Meaning = "The specified key does not meet the minimum tuple length. (JET_errIndexTuplesKeyTooSmall)"},
    0xFFFFFA23 -> new NameMeaning {Name = "IsamErrorColumnLong", Meaning = "The column value is long. (JET_errColumnLong)"},
    0xFFFFFA22 -> new NameMeaning {Name = "IsamErrorColumnNoChunk", Meaning = "There is no such chunk in a long value. (JET_errColumnNoChunk)"},
    0xFFFFFA21 -> new NameMeaning {Name = "IsamErrorColumnDoesNotFit", Meaning = "The field will not fit in the record. (JET_errColumnDoesNotFit)"},
    0xFFFFFA20 -> new NameMeaning {Name = "IsamErrorNullInvalid", Meaning = "Null is not valid. (JET_errNullInvalid, JET_errColumnIllegalNull)"},
    0xFFFFFA1F -> new NameMeaning {Name = "IsamErrorColumnIndexed", Meaning = "The column is indexed and cannot be deleted. (JET_errColumnIndexed)"},
    0xFFFFFA1E -> new NameMeaning {Name = "IsamErrorColumnTooBig", Meaning = "The field length is greater than the maximum allowed length. (JET_errColumnTooBig)"},
    0xFFFFFA1D -> new NameMeaning {Name = "IsamErrorColumnNotFound", Meaning = "No such column exists. (JET_errColumnNotFound)"},
    0xFFFFFA1C -> new NameMeaning {Name = "IsamErrorColumnDuplicate", Meaning = "This field is already defined. (JET_errColumnDuplicate)"},
    0xFFFFFA1B -> new NameMeaning {Name = "IsamErrorMultiValuedColumnMustBeTagged", Meaning = "An attempt was made to create a multivalued column, but the column was not tagged. (JET_errMultiValuedColumnMustBeTagged)"},
    0xFFFFFA1A -> new NameMeaning {Name = "IsamErrorColumnRedundant", Meaning = "There is a second automatic increment or version column. (JET_errColumnRedundant)"},
    0xFFFFFA19 -> new NameMeaning {Name = "IsamErrorInvalidColumnType", Meaning = "The column data type is invalid. (JET_errInvalidColumnType)"},
    0xFFFFFA16 -> new NameMeaning {Name = "IsamErrorTaggedNotNULL", Meaning = "There are no non-NULL tagged columns. (JET_errTaggedNotNULL)"},
    0xFFFFFA15 -> new NameMeaning {Name = "IsamErrorNoCurrentIndex", Meaning = "The database is invalid because it does not contain a current index. (JET_errNoCurrentIndex)"},
    0xFFFFFA14 -> new NameMeaning {Name = "IsamErrorKeyIsMade", Meaning = "The key is completely made. (JET_errKeyIsMade)"},
    0xFFFFFA13 -> new NameMeaning {Name = "IsamErrorBadColumnId", Meaning = "The column ID is incorrect. (JET_errBadColumnId)"},
    0xFFFFFA12 -> new NameMeaning {Name = "IsamErrorBadItagSequence", Meaning = "There is a bad itagSequence for the tagged column. (JET_errBadItagSequence)"},
    0xFFFFFA11 -> new NameMeaning {Name = "IsamErrorColumnInRelationship", Meaning = "A column cannot be deleted because it is part of a relationship. (JET_errColumnInRelationship)"},
    0xFFFFFA0F -> new NameMeaning {Name = "IsamErrorCannotBeTagged", Meaning = "The automatic increment and version cannot be tagged. (JET_errCannotBeTagged)"},
    0xFFFFFA0C -> new NameMeaning {Name = "IsamErrorDefaultValueTooBig", Meaning = "The default value exceeds the maximum size. (JET_errDefaultValueTooBig)"},
    0xFFFFFA0B -> new NameMeaning {Name = "IsamErrorMultiValuedDuplicate", Meaning = "A duplicate value was detected on a unique multivalued column. (JET_errMultiValuedDuplicate)"},
    0xFFFFFA0A -> new NameMeaning {Name = "IsamErrorLVCorrupted", Meaning = "Corruption was encountered in a long-value tree. (JET_errLVCorrupted)"},
    0xFFFFFA08 -> new NameMeaning {Name = "IsamErrorMultiValuedDuplicateAfterTruncation", Meaning = "A duplicate value was detected on a unique multivalued column after the data was normalized, and it is normalizing truncated data before comparison. (JET_errMultiValuedDuplicateAfterTruncation)"},
    0xFFFFFA07 -> new NameMeaning {Name = "IsamErrorDerivedColumnCorruption", Meaning = "There is an invalid column in a derived table. (JET_errDerivedColumnCorruption)"},
    0xFFFFFA06 -> new NameMeaning {Name = "IsamErrorInvalidPlaceholderColumn", Meaning = "An attempt was made to convert a column to a primary index placeholder, but the column does not meet the necessary criteria. (JET_errInvalidPlaceholderColumn)"},
    0xFFFFF9BF -> new NameMeaning {Name = "IsamErrorRecordNotFound", Meaning = "The key was not found. (JET_errRecordNotFound)"},
    0xFFFFF9BE -> new NameMeaning {Name = "IsamErrorRecordNoCopy", Meaning = "There is no working buffer. (JET_errRecordNoCopy)"},
    0xFFFFF9BD -> new NameMeaning {Name = "IsamErrorNoCurrentRecord", Meaning = "There is no current record. (JET_errNoCurrentRecord)"},
    0xFFFFF9BC -> new NameMeaning {Name = "IsamErrorRecordPrimaryChanged", Meaning = "The primary key might not change. (JET_errRecordPrimaryChanged)"},
    0xFFFFF9BB -> new NameMeaning {Name = "IsamErrorKeyDuplicate", Meaning = "There is an illegal duplicate key. (JET_errKeyDuplicate)"},
    0xFFFFF9B9 -> new NameMeaning {Name = "IsamErrorAlreadyPrepared", Meaning = "An attempt was made to update a record while a record update was already in progress. (JET_errAlreadyPrepared)"},
    0xFFFFF9B8 -> new NameMeaning {Name = "IsamErrorKeyNotMade", Meaning = "A call was not made to JetMakeKey. (JET_errKeyNotMade)"},
    0xFFFFF9B7 -> new NameMeaning {Name = "IsamErrorUpdateNotPrepared", Meaning = "A call was not made to JetPrepareUpdate. (JET_errUpdateNotPrepared)"},
    0xFFFFF9B5 -> new NameMeaning {Name = "IsamErrorDataHasChanged", Meaning = "The data has changed and the operation was aborted. (JET_errDataHasChanged)"},
    0xFFFFF9AD -> new NameMeaning {Name = "IsamErrorLanguageNotSupported", Meaning = "The operating system does not support the selected language. (JET_errLanguageNotSupported)"},
    0xFFFFF95B -> new NameMeaning {Name = "IsamErrorTooManySorts", Meaning = "There are too many sort processes. (JET_errTooManySorts)"},
    0xFFFFF95A -> new NameMeaning {Name = "IsamErrorInvalidOnSort", Meaning = "An invalid operation occurred during a sort. (JET_errInvalidOnSort)"},
    0xFFFFF8F5 -> new NameMeaning {Name = "IsamErrorTempFileOpenError", Meaning = "The temporary file could not be opened. (JET_errTempFileOpenError)"},
    0xFFFFF8F3 -> new NameMeaning {Name = "IsamErrorTooManyAttachedDatabases", Meaning = "Too many databases are open. (JET_errTooManyAttachedDatabases)"},
    0xFFFFF8F0 -> new NameMeaning {Name = "IsamErrorDiskFull", Meaning = "There is no space left on disk. (JET_errDiskFull)"},
    0xFFFFF8EF -> new NameMeaning {Name = "IsamErrorPermissionDenied", Meaning = "Permission is denied. (JET_errPermissionDenied)"},
    0xFFFFF8ED -> new NameMeaning {Name = "IsamErrorFileNotFound", Meaning = "The file was not found. (JET_errFileNotFound)"},
    0xFFFFF8EC -> new NameMeaning {Name = "IsamErrorFileInvalidType", Meaning = "The file type is invalid. (JET_errFileInvalidType)"},
    0xFFFFF8C6 -> new NameMeaning {Name = "IsamErrorAfterInitialization", Meaning = "A restore cannot be started after initialization. (JET_errAfterInitialization)"},
    0xFFFFF8C4 -> new NameMeaning {Name = "IsamErrorLogCorrupted", Meaning = "The logs could not be interpreted. (JET_errLogCorrupted)"},
    0xFFFFF88E -> new NameMeaning {Name = "IsamErrorInvalidOperation", Meaning = "The operation is invalid. (JET_errInvalidOperation)"},
    0xFFFFF88D -> new NameMeaning {Name = "IsamErrorAccessDenied", Meaning = "Access is denied. (JET_errAccessDenied)"},
    0xFFFFF88B -> new NameMeaning {Name = "IsamErrorTooManySplits", Meaning = "An infinite split. (JET_errTooManySplits)"},
    0xFFFFF88A -> new NameMeaning {Name = "IsamErrorSessionSharingViolation", Meaning = "Multiple threads are using the same session. (JET_errSessionSharingViolation)"},
    0xFFFFF889 -> new NameMeaning {Name = "IsamErrorEntryPointNotFound", Meaning = "An entry point in a required DLL could not be found. (JET_errEntryPointNotFound)"},
    0xFFFFF888 -> new NameMeaning {Name = "IsamErrorSessionContextAlreadySet", Meaning = "The specified session already has a session context set. (JET_errSessionContextAlreadySet)"},
    0xFFFFF887 -> new NameMeaning {Name = "IsamErrorSessionContextNotSetByThisThread", Meaning = "An attempt was made to reset the session context, but the current thread was not the original one that set the session context. (JET_errSessionContextNotSetByThisThread)"},
    0xFFFFF886 -> new NameMeaning {Name = "IsamErrorSessionInUse", Meaning = "An attempt was made to terminate the session currently in use. (JET_errSessionInUse)"},
    0xFFFFF885 -> new NameMeaning {Name = "IsamErrorRecordFormatConversionFailed", Meaning = "An internal error occurred during a dynamic record format conversion. (JET_errRecordFormatConversionFailed)"},
    0xFFFFF884 -> new NameMeaning {Name = "IsamErrorOneDatabasePerSession", Meaning = "Only one open user database per session is allowed. (JET_errOneDatabasePerSession)"},
    0xFFFFF883 -> new NameMeaning {Name = "IsamErrorRollbackError", Meaning = "There was an error during rollback. (JET_errRollbackError)"},
    0xFFFFF7CB -> new NameMeaning {Name = "IsamErrorCallbackFailed", Meaning = "A callback function call failed. (JET_errCallbackFailed)"},
    0xFFFFF7CA -> new NameMeaning {Name = "IsamErrorCallbackNotResolved", Meaning = "A callback function could not be found. (JET_errCallbackNotResolved)"},
    0xFFFFF69F -> new NameMeaning {Name = "IsamErrorOSSnapshotInvalidSequence", Meaning = "The operating system shadow copy API was used in an invalid sequence. (JET_errOSSnapshotInvalidSequence)"},
    0xFFFFF69E -> new NameMeaning {Name = "IsamErrorOSSnapshotTimeOut", Meaning = "The operating system shadow copy ended with a time-out. (JET_errOSSnapshotTimeOut)"},
    0xFFFFF69D -> new NameMeaning {Name = "IsamErrorOSSnapshotNotAllowed", Meaning = "The operating system shadow copy is not allowed because a backup or recovery in is progress. (JET_errOSSnapshotNotAllowed)"},
    0xFFFFF69C -> new NameMeaning {Name = "IsamErrorOSSnapshotInvalidSnapId", Meaning = "The operation failed because the specified operating system shadow copy handle was invalid. (JET_errOSSnapshotInvalidSnapId)"},
    0xFFFFF448 -> new NameMeaning {Name = "IsamErrorLSCallbackNotSpecified", Meaning = "An attempt was made to use local storage without a callback function being specified. (JET_errLSCallbackNotSpecified)"},
    0xFFFFF447 -> new NameMeaning {Name = "IsamErrorLSAlreadySet", Meaning = "An attempt was made to set the local storage for an object that already had it set. (JET_errLSAlreadySet)"},
    0xFFFFF446 -> new NameMeaning {Name = "IsamErrorLSNotSet", Meaning = "An attempt was made to retrieve local storage from an object that did not have it set. (JET_errLSNotSet)"},
    0xFFFFF060 -> new NameMeaning {Name = "IsamErrorFileIOSparse", Meaning = "An I/O operation failed because it was attempted against an unallocated region of a file. (JET_errFileIOSparse)"},
    0xFFFFF05F -> new NameMeaning {Name = "IsamErrorFileIOBeyondEOF", Meaning = "A read was issued to a location beyond the EOF (writes will expand the file). (JET_errFileIOBeyondEOF)"},
    0xFFFFF05B -> new NameMeaning {Name = "IsamErrorFileCompressed", Meaning = "Read/write access is not supported on compressed files. (JET_errFileCompressed)"}
};

// Section 2.4.2   Property Error Codes
const map<uint, NameMeaning> PropertyErrorCodesMap = 
{
    0x8007000E -> new NameMeaning {Name = "NotEnoughMemory", Meaning = "On get, indicates that the property or column value is too large to be retrieved by the request, and the property value needs to be accessed with the RopOpenStream ROP ([MS-OXCROPS] section 2.2.9.1). (E_NOMEMORY, MAPI_E_NOT_ENOUGH_MEMORY)"},
    0x8004010F -> new NameMeaning {Name = "NotFound", Meaning = "On get, indicates that the property or column has no value for this object. (MAPI_E_NOT_FOUND)"},
    0x80040301 -> new NameMeaning {Name = "BadValue", Meaning = "On set, indicates that the property value is not acceptable to the server. (MAPI_E_BAD_VALUE, ecPropBadValue)"},
    0x80040302 -> new NameMeaning {Name = "InvalidType", Meaning = "On get or set, indicates that the data type passed with the property or column is undefined. (MAPI_E_INVALID_TYPE, ecInvalidType)"},
    0x80040303 -> new NameMeaning {Name = "UnsupportedType", Meaning = "On get or set, indicates that the data type passed with the property or column is not acceptable to the server. (MAPI_E_TYPE_NO_SUPPORT, ecTypeNotSupported)"},
    0x80040304 -> new NameMeaning {Name = "UnexpectedType", Meaning = "On get or set, indicates that the data type passed with the property or column is not the type expected by the server. (MAPI_E_UNEXPECTED_TYPE, ecPropType)"},
    0x80040305 -> new NameMeaning {Name = "TooBig", Meaning = "Indicates that the result set of the operation is too big for the server to return. (MAPI_E_TOO_BIG, ecTooBig)"},
    0x80040306 -> new NameMeaning {Name = "DeclineCopy", Meaning = "On a copy operation, indicates that the server cannot copy the object, possibly because the source and destination are on different types of servers, and the server will delegate the copying to client code. (MAPI_E_DECLINE_COPY)"},
    0x80040307 -> new NameMeaning {Name = "UnexpectedId", Meaning = "On get or set, indicates that the server does not support property IDs in this range, usually the named property ID range (from 0x8000 through 0xFFFF). (MAPI_E_UNEXPECTED_ID)"}
};

// Section 2.4.3   Warning Codes
const map<uint, NameMeaning> WarningCodesMap = 
{
    0x00040380 -> new NameMeaning {Name = "ErrorsReturned", Meaning = "A request involving multiple properties failed for one or more individual properties, while succeeding overall. (MAPI_W_ERRORS_RETURNED, ecWarnWithErrors)"},
    0x00040481 -> new NameMeaning {Name = "PositionChanged", Meaning = "A table operation succeeded, but the bookmark specified is no longer set at the same row as when it was last used. (MAPI_W_POSITION_CHANGED, ecWarnPositionChanged)"},
    0x00040482 -> new NameMeaning {Name = "ApproximateCount", Meaning = "The row count returned by a table operation is approximate, not exact. (MAPI_W_APPROX_COUNT, ecWarnApproxCount)"},
    0x00040680 -> new NameMeaning {Name = "PartiallyComplete", Meaning = "A move, copy, or delete operation succeeded for some messages but not for others. (MAPI_W_PARTIAL_COMPLETION, ecPartialCompletion)"},
    0x00040820 -> new NameMeaning {Name = "SyncProgress", Meaning = "The operation succeeded, but there is more to do. (SYNC_W_PROGRESS)"},
    0x00040821 -> new NameMeaning {Name = "NewerClientChange", Meaning = "In a change conflict, the client has the more recent change. (SYNC_W_CLIENT_CHANGE_NEWER)"},
    0x00000141 -> new NameMeaning {Name = "IsamWarningRemainingVersions", Meaning = "The version store is still active. (JET_wrnRemainingVersions)"},
    0x00000159 -> new NameMeaning {Name = "IsamWarningUniqueKey", Meaning = "A seek on an index that is not unique yielded a unique key. (JET_wrnUniqueKey)"},
    0x00000196 -> new NameMeaning {Name = "IsamWarningSeparateLongValue", Meaning = "A database column is a separated long value. (JET_wrnSeparateLongValue)"},
    0x0000022E -> new NameMeaning {Name = "IsamWarningExistingLogFileHasBadSignature", Meaning = "The existing log file has a bad signature. (JET_wrnExistingLogFileHasBadSignature)"},
    0x0000022F -> new NameMeaning {Name = "IsamWarningExistingLogFileIsNotContiguous", Meaning = "The existing log file is not contiguous. (JET_wrnExistingLogFileIsNotContiguous)"},
    0x00000234 -> new NameMeaning {Name = "IsamWarningSkipThisRecord", Meaning = "This error is for internal use only. (JET_wrnSkipThisRecord)"},
    0x00000242 -> new NameMeaning {Name = "IsamWarningTargetInstanceRunning", Meaning = "The TargetInstance specified for the restore is running. (JET_wrnTargetInstanceRunning)"},
    0x00000253 -> new NameMeaning {Name = "IsamWarningDatabaseRepaired", Meaning = "The database corruption has been repaired. (JET_wrnDatabaseRepaired)"},
    0x000003EC -> new NameMeaning {Name = "IsamWarningColumnNull", Meaning = "The column has a null value. (JET_wrnColumnNull)"},
    0x000003EE -> new NameMeaning {Name = "IsamWarningBufferTruncated", Meaning = "The buffer is too small for the data. (JET_wrnBufferTruncated)"},
    0x000003EF -> new NameMeaning {Name = "IsamWarningDatabaseAttached", Meaning = "The database is already attached. (JET_wrnDatabaseAttached)"},
    0x000003F1 -> new NameMeaning {Name = "IsamWarningSortOverflow", Meaning = "The sort that is being attempted does not have enough memory to complete. (JET_wrnSortOverflow)"},
    0x0000040F -> new NameMeaning {Name = "IsamWarningSeekNotEqual", Meaning = "An exact match was not found during a seek. (JET_wrnSeekNotEqual, JET_wrnRecordFoundGreater, JET_wrnRecordFoundLess)"},
    0x0000041F -> new NameMeaning {Name = "IsamWarningNoErrorInfo", Meaning = "There is no extended error information. (JET_wrnNoErrorInfo)"},
    0x00000422 -> new NameMeaning {Name = "IsamWarningNoIdleActivity", Meaning = "No idle activity occurred. (JET_wrnNoIdleActivity)"},
    0x0000042B -> new NameMeaning {Name = "IsamWarningNoWriteLock", Meaning = "There is a no write lock at transaction level 0. (JET_wrnNoWriteLock)"},
    0x0000042C -> new NameMeaning {Name = "IsamWarningColumnSetNull", Meaning = "The column is set to a null value. (JET_wrnColumnSetNull)"},
    0x00000515 -> new NameMeaning {Name = "IsamWarningTableEmpty", Meaning = "An empty table was opened. (JET_wrnTableEmpty)"},
    0x0000052F -> new NameMeaning {Name = "IsamWarningTableInUseBySystem", Meaning = "The system cleanup has a cursor open on the table. (JET_wrnTableInUseBySystem)"},
    0x00000587 -> new NameMeaning {Name = "IsamWarningCorruptIndexDeleted", Meaning = "The out-of-date index is required to be removed. (JET_wrnCorruptIndexDeleted)"},
    0x000005E8 -> new NameMeaning {Name = "IsamWarningColumnMaxTruncated", Meaning = "The maximum length is too large and has been truncated. (JET_wrnColumnMaxTruncated)"},
    0x000005F0 -> new NameMeaning {Name = "IsamWarningCopyLongValue", Meaning = "A binary large object (BLOB) value has been moved from the record into a separate storage of BLOBs. (JET_wrnCopyLongValue)"},
    0x000005FB -> new NameMeaning {Name = "IsamWarningColumnSkipped", Meaning = "The column values were not returned because the corresponding column ID or itagSequence member from the JET_ENUMCOLUMNVALUE structure that was requested for enumeration was null. (JET_wrnColumnSkipped)"},
    0x000005FC -> new NameMeaning {Name = "IsamWarningColumnNotLocal", Meaning = "The column values were not returned because they could not be reconstructed from the existing data. (JET_wrnColumnNotLocal)"},
    0x000005FD -> new NameMeaning {Name = "IsamWarningColumnMoreTags", Meaning = "The existing column values were not requested for enumeration. (JET_wrnColumnMoreTags)"},
    0x000005FE -> new NameMeaning {Name = "IsamWarningColumnTruncated", Meaning = "The column value was truncated at the requested size limit during enumeration. (JET_wrnColumnTruncated)"},
    0x000005FF -> new NameMeaning {Name = "IsamWarningColumnPresent", Meaning = "The column values exist but were not returned by the request. (JET_wrnColumnPresent)"},
    0x00000600 -> new NameMeaning {Name = "IsamWarningColumnSingleValue", Meaning = "The column value was returned in JET_COLUMNENUM as a result of the JET_bitEnumerateCompressOutput being set. (JET_wrnColumnSingleValue)"},
    0x00000601 -> new NameMeaning {Name = "IsamWarningColumnDefault", Meaning = "The column value is set to the default value of the column. (JET_wrnColumnDefault)"},
    0x0000064A -> new NameMeaning {Name = "IsamWarningDataHasChanged", Meaning = "The data has changed. (JET_wrnDataHasChanged)"},
    0x00000652 -> new NameMeaning {Name = "IsamWarningKeyChanged", Meaning = "A new key is being used. (JET_wrnKeyChanged)"},
    0x00000715 -> new NameMeaning {Name = "IsamWarningFileOpenReadOnly", Meaning = "The database file is read-only. (JET_wrnFileOpenReadOnly)"},
    0x00000774 -> new NameMeaning {Name = "IsamWarningIdleFull", Meaning = "The idle registry is full. (JET_wrnIdleFull)"},
    0x000007D0 -> new NameMeaning {Name = "IsamWarningDefragAlreadyRunning", Meaning = "An online defragmentation was already running on the specified database. (JET_wrnDefragAlreadyRunning)"},
    0x000007D1 -> new NameMeaning {Name = "IsamWarningDefragNotRunning", Meaning = "An online defragmentation is not running on the specified database. (JET_wrnDefragNotRunning)"},
    0x00000834 -> new NameMeaning {Name = "IsamWarningCallbackNotRegistered", Meaning = "A nonexistent callback function was unregistered. (JET_wrnCallbackNotRegistered)"},
    0xFFFFFFFF -> new NameMeaning {Name = "IsamWarningNotYetImplemented", Meaning = "The function is not yet implemented. (JET_wrnNyi)"}
};

string FormatErrorCode(any errorCode)
{
    NameMeaning nm = null;
	uint errorCodeUint = errorCode as uint;
    if (errorCodeUint in ErrorCodesMap)
    {
        nm = ErrorCodesMap[errorCodeUint];
    }
    else if (errorCodeUint in AdditionalErrorCodesMap)
    {
        nm = AdditionalErrorCodesMap[errorCodeUint];
    }
	else if (errorCodeUint in WarningCodesMap)
	{
		nm = WarningCodesMap[errorCodeUint];
	}
    
    return (nm == null ? "UnknownError" : nm.Name);
}

// Section 2.2.1.1   Folder ID Structure
type FolderID
{
    ushort ReplicaId;
    ulong GlobalCounter with BinaryEncoding{Endian = Endian.Big, Width = 6 * 8};
    
    override string ToString()
    {
        return Format("{0:X4}", ReplicaId) + "-" + Format("{0:X12}", GlobalCounter);
    }
}

// Section 2.2.1.2   Message ID Structure
type MessageID
{
    ushort ReplicaId;
    ulong GlobalCounter with BinaryEncoding{Endian = Endian.Big, Width = 6 * 8 };

    override string ToString()
    {
        return Format("{0:X4}", ReplicaId) + "-" + Format("{0:X12}", GlobalCounter);
    }
}

// Section 2.2.1.3.1   LongTermID Structure
type LongTermID
{
	guid DatabaseGuid;
	ulong GlobalCounter with BinaryEncoding{Endian = Endian.Big, Width = 6 * 8}, DisplayInfo{ToText = GlobalCounterToString};
	ushort Pad;
}
	
// section 2.2.4.1 Folder EntryID
type FolderEntryID 
{
	uint Flags;
	(guid | FolderOrMessageProviderUID) ProviderUID;
	StoreObjectType FolerType;
	guid DatabaseGuid;
	ulong GlobalCounter with BinaryEncoding {Endian = Endian.Big, Width = 6 * 8}, DisplayInfo{ToText = GlobalCounterToString};
	ushort Pad;
}

pattern FolderOrMessageProviderUID = "1A447390AA6611CD9BC800AA002FC45A";
pattern AdressBookProviderUID = "DCA740C8C042101AB4B908002B2FE182";

pattern StoreObjectType = enum ushort
{
	PrivateFolder 			= 0x0001,
	PublicFolder			= 0x0003,
	MappedPublicFolder		= 0x0005,
	PrivateMessage			= 0x0007,
	PublicMessage			= 0x0009,
	MappedPublicMessage		= 0x000B,
	PublicNewsgroupFolder	= 0x000C,
	...
};
	
// section 2.2.4.2	Message EntryID Structure
type MessageEntryID
{
	uint Flags;
	(guid | FolderOrMessageProviderUID) ProviderUID;
	StoreObjectType MessageType;
	guid FolderDatabaseGuid;
	ulong FolderGlobalCounter with BinaryEncoding{Endian = Endian.Big, Width = 6 * 8}, DisplayInfo{ToText = GlobalCounterToString};
	ushort Pad_1;
	guid MessageDatabaseGuid;
	ulong MessageGlobalCounter with BinaryEncoding{Endian = Endian.Big, Width = 6 * 8}, DisplayInfo{ToText = GlobalCounterToString};
	ushort Pad_2;
}

// section 2.2.4.3	Store Object EntryID Structure
type StoreObjectEntryID
{
	uint Flags;
	array<byte> ProviderUID where ValidationCheck(value == [0x38,0xA1,0xBB,0x10,0x05,0xE5,0x10,0x1A,0xA1,0xBB,0x08,0x00,0x2B,0x2A,0x56,0xC2], null, "This field MUST be %x38.A1.BB.10.05.E5.10.1A.A1.BB.08.00.2B.2A.56.C2") with BinaryEncoding {Length = 16};
	byte Version;
	byte Flag;
	array<byte> DLLFileName where ValidationCheck(value == [0x45,0x4D,0x53,0x4D,0x44,0x42,0x2E,0x44,0x4C,0x4C,0x00,0x00,0x00,0x00], null, "This field MUST be %x45.4D.53.4D.44.42.2E.44.4C.4C.00.00.00.00") with BinaryEncoding {Length = 14};
	uint WrappedFlags;
	array<byte> WrappedProviderUID where ValidationCheck(value == [0x1B,0x55,0xFA,0x20,0xAA,0x66,0x11,0xCD,0x9B,0xC8,0x00,0xAA,0x00,0x2F,0xC4,0x5A] || value == [0x1C,0x83,0x02,0x10,0xAA,0x66,0x11,0xCD,0x9B,0xC8,0x00,0xAA,0x00,0x2F,0xC4,0x5A], null, "This field MUST be %x1B.55.FA.20.AA.66.11.CD.9B.C8.00.AA.00.2F.C4.5A or %x1C.83.02.10.AA.66.11.CD.9B.C8.00.AA.00.2F.C4.5A") with BinaryEncoding {Length = 16};
	uint WrappedType;
	string ServerShortname with BinaryEncoding{TextEncoding= TextEncoding.ASCII};
	optional string MailboxDN with BinaryEncoding{TextEncoding= TextEncoding.ASCII};
}

// section 2.2.5.2  Address Book EntryID Structure
type AddressBookEntryID   
{
	uint Flags;
	AdressBookProviderUID ProviderUID;
	uint Version;
	AddressbookEntryIDtype Type;
	string X500DN with BinaryEncoding{Width = 8}; 
}

pattern AddressbookEntryIDtype = enum uint
{
	Localmailuser                 	= 0x00000000,
	Distributionlist               	= 0x00000001,
	Bulletinboardorpublicfolder 	= 0x00000002,
	Automatedmailbox				= 0x00000003,
	Organizationalmailbox			= 0x00000004,
	Privatedistributionlist		    = 0x00000005,
	Remotemailuser 					= 0x00000006,
	Container						= 0x00000100,
	Template 						= 0x00000101,
	Oneoffuser						= 0x00000102,
	Search							= 0x00000200,
	...
};

// ============================== 2.6 Property Name Structures ==============================
// Section 2.6.1   PropertyName Structure
type PropertyName
{
    byte Kind;
    guid GUID;
    optional [|Kind == 0x00|] uint LID;
    optional [|Kind == 0x01|] byte NameSize;
    optional [|Kind == 0x01|] string Name with BinaryEncoding{TextEncoding = TextEncoding.Unicode, Length = (NameSize as byte)/2};
}

// Section 2.6.2   PropertyName_r Structure
type PropertyName_r
{
    guid GUID;
    uint Reserved;
    uint LID;
}

// Section 2.7   PropertyProblem Structure
type PropertyProblem
{
    ushort Index;
    PropertyTag PropertyTag;
    uint ErrorCode with DisplayInfo{ToText = ErrorCodeToText};
    
    string ErrorCodeToText(any data)
    {
        return FormatErrorCode(data as uint);
    }   
}

// ============================== 2.8.1   PropertyRow Structures ============================== 
// Refer to: 2.8.1.1   StandardPropertyRow Structure & 2.8.1.2   FlaggedPropertyRow Structure
pattern PropRow_PropValue = PropertyValue | TypedPropertyValue | FlaggedPropertyValue | FlaggedPropertyValueWithType;

type PropertyRow[array<PropertyTag> propTags]
{
    byte Flag;
    array<PropRow_PropValue> ValueArray with Encoding{Decoder = ValueArrayDecoder};
    
    optional array<PropRow_PropValue> ValueArrayDecoder(stream payload)
    {
        array<PropRow_PropValue> result = [];
        
        foreach (var propTag in propTags)
        {
            PropRow_PropValue rowPropValue = null;
            
            if (Flag == 0x00)
            {
                if (propTag.PropertyType != PropertyDataType.PtypUnspecified)
                {
                    PropertyValue propValue = BinaryDecoder<PropertyValue[propTag.PropertyType]>(payload) as PropertyValue;
                    propValue.ID = GetPropIdentity(propTag.PropertyId, propTag.PropertyType);
                    rowPropValue = propValue;
                }
                else
                {
                    TypedPropertyValue typePropValue = BinaryDecoder<TypedPropertyValue>(payload) as TypedPropertyValue;
                    typePropValue.ID = GetPropIdentity(propTag.PropertyId, propTag.PropertyType);
                    rowPropValue = typePropValue;
                }
            }
            else if(Flag == 0x01)
            {
                if (propTag.PropertyType != PropertyDataType.PtypUnspecified)
                {
                    FlaggedPropertyValue flagPropValue = BinaryDecoder<FlaggedPropertyValue[propTag.PropertyType]>(payload) as FlaggedPropertyValue;
                    flagPropValue.ID = GetPropIdentity(propTag.PropertyId, propTag.PropertyType);
                    rowPropValue = flagPropValue;
                }
                else
                {
                    FlaggedPropertyValueWithType flagPropValue = BinaryDecoder<FlaggedPropertyValueWithType>(payload) as FlaggedPropertyValueWithType;
                    flagPropValue.ID = GetPropIdentity(propTag.PropertyId, propTag.PropertyType);
                    rowPropValue = flagPropValue;
                }
            }
            
            result += [rowPropValue];
        }
        
        return result;
    }
}

// ============================== 2.8.3   RecipientRow Structure ============================== 
// Section 2.8.3.1   RecipientFlags Field 
pattern AddressTypeEnum = enum int
{
    NoType                    = 0x0,
    X500DN                    = 0x1,
    MsMail                    = 0x2,
    SMTP                      = 0x3,
    Fax                       = 0x4,
    ProfessionalOfficeSystem  = 0x5,
    PersonalDistributionList1 = 0x6,
    PersonalDistributionList2 = 0x7,
    ...
};

type RecipientFlags
{
    int R with BinaryEncoding{Width = 1};
    int S with BinaryEncoding{Width = 1};
    int T with BinaryEncoding{Width = 1};
    int D with BinaryEncoding{Width = 1};
    int E with BinaryEncoding{Width = 1};
    AddressTypeEnum Type with BinaryEncoding{Width = 3};
    int O with BinaryEncoding{Width = 1};
    int Reserved with BinaryEncoding{Width = 4};
    int I with BinaryEncoding{Width = 1};
    int U with BinaryEncoding{Width = 1};
    int N with BinaryEncoding{Width = 1};
}

// Section 2.8.3.2   RecipientRow Structure
pattern DisplayType = enum byte
{
    $"A messaging user"                                         = 0x00,
    $"A distribution list"                                      = 0x01,
    $"A forum"                                                  = 0x02,
    $"An automated agent"                                       = 0x03,
    $"An Address Book object defined for a large group"         = 0x04,
    $"A private, personally administered distribution list"     = 0x05,
    $"An Address Book object known to be from messaging system" = 0x06,
    ...
};

type RecipientRow[array<PropertyTag> propTags]
{
    RecipientFlags RecipientFlags;
    optional [|RecipientFlags.Type == AddressTypeEnum.X500DN|] byte AddressPrefixUsed;
    optional [|RecipientFlags.Type == AddressTypeEnum.X500DN|] DisplayType DisplayType;
    optional [|RecipientFlags.Type == AddressTypeEnum.X500DN|] string X500DN with BinaryEncoding{TextEncoding = TextEncoding.ASCII};
    optional [|IsPersonalDL(RecipientFlags.Type)|] ushort EntryIdSize;
    optional [|IsPersonalDL(RecipientFlags.Type)|] AddressBookEntryID EntryID;
    optional [|IsPersonalDL(RecipientFlags.Type)|] ushort SearchKeySize;
    optional [|IsPersonalDL(RecipientFlags.Type)|] array<byte> SearchKey with BinaryEncoding{Length = SearchKeySize as ushort};
    optional [|(RecipientFlags.Type == AddressTypeEnum.NoType) && RecipientFlags.O == 0x1|] string AddressType with BinaryEncoding{TextEncoding = TextEncoding.ASCII};
    optional [|RecipientFlags.E == 0x1|] string EmailAddress with BinaryEncoding
            {TextEncoding = (RecipientFlags.U == 0x1) ? TextEncoding.Unicode : TextEncoding.ASCII};
    optional [|RecipientFlags.D == 0x1|] string DisplayName with BinaryEncoding
            {TextEncoding = (RecipientFlags.U == 0x1) ? TextEncoding.Unicode : TextEncoding.ASCII};
    optional [|RecipientFlags.I == 0x1|] string SimpleDisplayName with BinaryEncoding
            {TextEncoding = (RecipientFlags.U == 0x1) ? TextEncoding.Unicode : TextEncoding.ASCII};
    optional [|RecipientFlags.T == 0x1|] string TransmittableDisplayName with BinaryEncoding
            {TextEncoding = (RecipientFlags.U == 0x1) ? TextEncoding.Unicode : TextEncoding.ASCII};
    ushort RecipientColumnCount;
    PropertyRow[GetColumn(propTags, RecipientColumnCount)] RecipientProperties;
            
    bool IsPersonalDL(AddressTypeEnum addrType)
    {
        return (addrType == AddressTypeEnum.PersonalDistributionList1) 
               || (addrType == AddressTypeEnum.PersonalDistributionList2);
    }
}

// Section 2.9   PropertyTag Structure
type PropertyTag
{
    ushort PropertyType with DisplayInfo{ToText = PropTypeValueToText};
    ushort PropertyId with DisplayInfo{ToText = (any data) => GetPropNameByTag(data as ushort, PropertyType)};
}

// Section 2.11.1   Property Data Types
pattern PropertyDataType = enum ushort
{
    PtypInteger16            = 0x0002,
    PtypInteger32            = 0x0003,
    PtypFloating32           = 0x0004,
    PtypFloating64           = 0x0005,
    PtypCurrency             = 0x0006,
    PtypFloatingTime         = 0x0007,
    PtypErrorCode            = 0x000A,
    PtypBoolean              = 0x000B,
    PtypInteger64            = 0x0014,
    PtypString               = 0x001F,
    PtypString8              = 0x001E,
    PtypTime                 = 0x0040,
    PtypGuid                 = 0x0048,
    PtypServerId             = 0x00FB,
    PtypRestriction          = 0x00FD,
    PtypRuleAction           = 0x00FE,
    PtypBinary               = 0x0102,
    PtypMultipleInteger16    = 0x1002,
    PtypMultipleInteger32    = 0x1003,
    PtypMultipleFloating32   = 0x1004,
    PtypMultipleFloating64   = 0x1005,
    PtypMultipleCurrency     = 0x1006,
    PtypMultipleFloatingTime = 0x1007,
    PtypMultipleInteger64    = 0x1014,
    PtypMultipleString       = 0x101F,
    PtypMultipleString8      = 0x101E,
    PtypMultipleTime         = 0x1040,
    PtypMultipleGuid         = 0x1048,
    PtypMultipleBinary       = 0x1102,
    PtypUnspecified          = 0x0000,
    PtypNull                 = 0x0001,
    
    // IN FUTURE: How to distinguish PtypObject from PtypEmbeddedTable since they share the same value
    PtypObject_Or_PtypEmbeddedTable  = 0x000D,
    ...
};

PropertyDataType ConvertToPropType(ushort typeValue)
{
    return (typeValue & ~PropertyDataTypeFlag.MultivalueInstance) as PropertyDataType;
}

string PropTypeValueToText(any data)
{
    ushort typeValue = data as ushort;
    bool isMultiInstance = (typeValue & PropertyDataTypeFlag.MultivalueInstance) == PropertyDataTypeFlag.MultivalueInstance;
    string typeSummary = EnumToStringInSummary<PropertyDataType>(ConvertToPropType(typeValue));
    
    if (isMultiInstance)
        return typeSummary + ", MultivalueInstance flag is set";
    
    return typeSummary;
}

// Section 2.11.1.3   Multivalue Property Value Instances
pattern PropertyDataTypeFlag = flags ushort
{
    MutltiValue        = 0x1000,
    MultivalueInstance = 0x2000
};

// Simple PropertyDataType
typedef PtypInteger16     = INT16;
typedef PtypInteger32     = INT32;
typedef PtypFloating32    = FLOAT;
typedef PtypFloating64    = DOUBLE;
typedef PtypCurrency      = LONGLONG;
typedef PtypFloatingTime  = DOUBLE;
typedef PtypErrorCode     = int;
typedef PtypBoolean       = BOOLEAN;
typedef PtypInteger64     = LONGLONG;
typedef PtypTime          = FILETIME;
typedef PtypGuid          = GUID;
pattern PtypString        = string with BinaryEncoding{TextEncoding= TextEncoding.Unicode};
pattern PtypString8       = string with BinaryEncoding{TextEncoding= TextEncoding.ASCII};
pattern PtypNull          = binary with BinaryEncoding{Length = 0};

// PtypMultiple PropertyDataType
// WORKAROUND: A more elegant approach is using generic type. e.g. type PtypMultiple<T>
// But it seems that other module based opn can't reference this. 
// So we just dump all the types here.
type PtypMultipleBase[optional uint countSize]
{
    ([|countSize == nothing|] ushort |
     [|countSize as uint == 2|] ushort |
     [|countSize as uint == 4|] uint) count;
}

uint get Count(this PtypMultipleBase ptypMulti)
{
    if (ptypMulti.count is us:ushort)
        return us as uint;
    if (ptypMulti.count is ui:uint)
        return ui;  
    return 0;
}
    
type PtypBinary: PtypMultipleBase
{
    array<byte> Values with BinaryEncoding{Length = this.Count};
}

type PtypMultipleInteger16: PtypMultipleBase
{
    //Workaround, need to update once the COUNT wide of PtypMultipleBinary is confirmed.
    ushort undefinedCount;
    array<PtypInteger16> Values with BinaryEncoding{Length = this.Count};
}

type PtypMultipleInteger32: PtypMultipleBase
{
    //Workaround, need to update once the COUNT wide of PtypMultipleBinary is confirmed.
    ushort undefinedCount;
    array<PtypInteger32> Values with BinaryEncoding{Length = this.Count};
}

type PtypMultipleInteger64: PtypMultipleBase
{
    array<PtypInteger64> Values with BinaryEncoding{Length = this.Count};
}

type PtypMultipleFloating32: PtypMultipleBase
{
    array<PtypFloating32> Values with BinaryEncoding{Length = this.Count};
}

type PtypMultipleFloating64: PtypMultipleBase
{
    array<PtypFloating64> Values with BinaryEncoding{Length = this.Count};
}

type PtypMultipleFloatingTime: PtypMultipleBase
{
    array<PtypFloatingTime> Values with BinaryEncoding{Length = this.Count};
}

type PtypMultipleCurrency: PtypMultipleBase
{
    array<PtypCurrency> Values with BinaryEncoding{Length = this.Count};
}

type PtypMultipleString: PtypMultipleBase
{
    //Workaround, need to update once the COUNT wide of PtypMultipleBinary is confirmed.
    ushort undefinedCount;
    array<PtypString> Values with BinaryEncoding{Length = this.Count};
}

type PtypMultipleString8: PtypMultipleBase
{
    array<PtypString8> Values with BinaryEncoding{Length = this.Count};
}

type PtypMultipleTime: PtypMultipleBase
{
    array<PtypTime> Values with BinaryEncoding{Length = this.Count};
}

type PtypMultipleGuid: PtypMultipleBase
{
    array<PtypGuid> Values with BinaryEncoding{Length = this.Count};
}

type PtypMultipleBinary: PtypMultipleBase
{
    // NOTE: Not sure if the context is required to applied to the child data structure.
    ushort undefinedCount; //Workaround, need to update once the COUNT wide of PtypMultipleBinary is confirmed.
    array<PtypBinary[countSize]> Values with BinaryEncoding{Length = this.Count};
}

// Not implemented types. 
// NOTE: those types have definition in MS-OXCDATA. Develop later due to the schedule.

type PtypUnspecified
{
    PtypUnspecified()
    {
        throw "MSOXCDATA: Not implemented type definition - PtypUnspecified";
    }
}

type PtypObject_Or_PtypEmbeddedTable
{
    PtypObject_Or_PtypEmbeddedTable()
    {
        throw "MSOXCDATA: Not implemented type definition - PtypObject_Or_PtypEmbeddedTable";
    }
}

// Section 2.11.1.4   PtypServerId Type 
type PtypServerId: PtypMultipleBase
{
    byte Ours;
    optional [|Ours == 0x01|] FolderID FolderID;
    optional [|Ours == 0x01|] MessageID MessageID;
    optional [|Ours == 0x01|] uint Instance;
    optional [|Ours == 0x00|] array<byte> ClientData with BinaryEncoding{Length = this.Count - 1};
}

// Section 2.11.2.1   PropertyValue Structure
type PropertyValue[ushort dataType, optional uint ptypMultiCountSize]
{
   ([|ConvertToPropType(dataType) == PropertyDataType.PtypInteger16|]            PtypInteger16    |
    [|ConvertToPropType(dataType) == PropertyDataType.PtypInteger32|]            PtypInteger32    |
    [|ConvertToPropType(dataType) == PropertyDataType.PtypFloating32|]           PtypFloating32   |
    [|ConvertToPropType(dataType) == PropertyDataType.PtypFloating64|]           PtypFloating64   |
    [|ConvertToPropType(dataType) == PropertyDataType.PtypCurrency|]             PtypCurrency     |
    [|ConvertToPropType(dataType) == PropertyDataType.PtypFloatingTime|]         PtypFloatingTime |
    [|ConvertToPropType(dataType) == PropertyDataType.PtypErrorCode|]            PtypErrorCode    |
    [|ConvertToPropType(dataType) == PropertyDataType.PtypBoolean|]              PtypBoolean      |
    [|ConvertToPropType(dataType) == PropertyDataType.PtypInteger64|]            PtypInteger64    |
    [|ConvertToPropType(dataType) == PropertyDataType.PtypString|]               PtypString       |
    [|ConvertToPropType(dataType) == PropertyDataType.PtypString8|]              PtypString8      |
    [|ConvertToPropType(dataType) == PropertyDataType.PtypTime|]                 PtypTime         |
    [|ConvertToPropType(dataType) == PropertyDataType.PtypGuid|]                 PtypGuid         |
    [|ConvertToPropType(dataType) == PropertyDataType.PtypServerId|]             PtypServerId[ptypMultiCountSize]|
    [|ConvertToPropType(dataType) == PropertyDataType.PtypRestriction|]          PtypRestriction  |
    [|ConvertToPropType(dataType) == PropertyDataType.PtypRuleAction|]           PtypRuleAction   |
    [|ConvertToPropType(dataType) == PropertyDataType.PtypUnspecified|]          PtypUnspecified  |
    [|ConvertToPropType(dataType) == PropertyDataType.PtypNull|]                 PtypNull         |
    [|ConvertToPropType(dataType) == PropertyDataType.PtypBinary|]               PtypBinary[ptypMultiCountSize]              |
    [|ConvertToPropType(dataType) == PropertyDataType.PtypMultipleInteger16|]    PtypMultipleInteger16[ptypMultiCountSize]   |
    [|ConvertToPropType(dataType) == PropertyDataType.PtypMultipleInteger32|]    PtypMultipleInteger32[ptypMultiCountSize]   |
    [|ConvertToPropType(dataType) == PropertyDataType.PtypMultipleFloating32|]   PtypMultipleFloating32[ptypMultiCountSize]  |
    [|ConvertToPropType(dataType) == PropertyDataType.PtypMultipleFloating64|]   PtypMultipleFloating64[ptypMultiCountSize]  |
    [|ConvertToPropType(dataType) == PropertyDataType.PtypMultipleCurrency|]     PtypMultipleCurrency[ptypMultiCountSize]    |
    [|ConvertToPropType(dataType) == PropertyDataType.PtypMultipleFloatingTime|] PtypMultipleFloatingTime[ptypMultiCountSize]|
    [|ConvertToPropType(dataType) == PropertyDataType.PtypMultipleInteger64|]    PtypMultipleInteger64[ptypMultiCountSize]   |
    [|ConvertToPropType(dataType) == PropertyDataType.PtypMultipleString|]       PtypMultipleString[ptypMultiCountSize]      |
    [|ConvertToPropType(dataType) == PropertyDataType.PtypMultipleString8|]      PtypMultipleString8[ptypMultiCountSize]     |
    [|ConvertToPropType(dataType) == PropertyDataType.PtypMultipleTime|]         PtypMultipleTime[ptypMultiCountSize]        |
    [|ConvertToPropType(dataType) == PropertyDataType.PtypMultipleGuid|]         PtypMultipleGuid[ptypMultiCountSize]        |
    [|ConvertToPropType(dataType) == PropertyDataType.PtypMultipleBinary|]       PtypMultipleBinary[ptypMultiCountSize]      |
    [|ConvertToPropType(dataType) == PropertyDataType.PtypObject_Or_PtypEmbeddedTable|] PtypObject_Or_PtypEmbeddedTable) Value;

    string Type with Encoding{Ignore = true} = PropTypeValueToText(dataType);
    optional string ID with Encoding{Ignore = true};
}

type MAPIPropertyValue[PropertyDataType dataType, optional uint ptypMultiCountSize]
{
	([|dataType == PropertyDataType.PtypInteger16|]            PtypInteger16    |
    [|dataType == PropertyDataType.PtypInteger32|]            PtypInteger32    |
    [|dataType == PropertyDataType.PtypFloating32|]           PtypFloating32   |
    [|dataType == PropertyDataType.PtypFloating64|]           PtypFloating64   |
    [|dataType == PropertyDataType.PtypCurrency|]             PtypCurrency     |
    [|dataType == PropertyDataType.PtypFloatingTime|]         PtypFloatingTime |
    [|dataType == PropertyDataType.PtypErrorCode|]            PtypErrorCode    |
    [|dataType == PropertyDataType.PtypBoolean|]              PtypBoolean      |
    [|dataType == PropertyDataType.PtypInteger64|]            PtypInteger64    |
    [|dataType == PropertyDataType.PtypString|]               PtypString       |
    [|dataType == PropertyDataType.PtypString8|]              PtypString8      |
    [|dataType == PropertyDataType.PtypTime|]                 PtypTime         |
    [|dataType == PropertyDataType.PtypGuid|]                 PtypGuid         |
    [|dataType == PropertyDataType.PtypServerId|]             PtypServerId     |
    [|dataType == PropertyDataType.PtypRestriction|]          PtypRestriction  |
    [|dataType == PropertyDataType.PtypRuleAction|]           PtypRuleAction   |
    [|dataType == PropertyDataType.PtypUnspecified|]          PtypUnspecified  |
    [|dataType == PropertyDataType.PtypNull|]                 PtypNull         |
    [|dataType == PropertyDataType.PtypBinary|]               PtypBinary[ptypMultiCountSize]              |
    [|dataType == PropertyDataType.PtypMultipleInteger16|]    PtypMultipleInteger16[ptypMultiCountSize]   |
    [|dataType == PropertyDataType.PtypMultipleInteger32|]    PtypMultipleInteger32[ptypMultiCountSize]   |
    [|dataType == PropertyDataType.PtypMultipleFloating32|]   PtypMultipleFloating32[ptypMultiCountSize]  |
    [|dataType == PropertyDataType.PtypMultipleFloating64|]   PtypMultipleFloating64[ptypMultiCountSize]  |
    [|dataType == PropertyDataType.PtypMultipleCurrency|]     PtypMultipleCurrency[ptypMultiCountSize]    |
    [|dataType == PropertyDataType.PtypMultipleFloatingTime|] PtypMultipleFloatingTime[ptypMultiCountSize]|
    [|dataType == PropertyDataType.PtypMultipleInteger64|]    PtypMultipleInteger64[ptypMultiCountSize]   |
    [|dataType == PropertyDataType.PtypMultipleString|]       PtypMultipleString[ptypMultiCountSize]      |
    [|dataType == PropertyDataType.PtypMultipleString8|]      PtypMultipleString8[ptypMultiCountSize]     |
    [|dataType == PropertyDataType.PtypMultipleTime|]         PtypMultipleTime[ptypMultiCountSize]        |
    [|dataType == PropertyDataType.PtypMultipleGuid|]         PtypMultipleGuid[ptypMultiCountSize]        |
    [|dataType == PropertyDataType.PtypMultipleBinary|]       PtypMultipleBinary[ptypMultiCountSize]      |
    [|dataType == PropertyDataType.PtypObject_Or_PtypEmbeddedTable|] PtypObject_Or_PtypEmbeddedTable) Value;
}

// Section 2.11.3   TypedPropertyValue Structure
type TypedPropertyValue[optional uint ptypMultiCountSize]
{
    ushort PropertyType with DisplayInfo{ToText = PropTypeValueToText};
    PropertyValue[PropertyType, ptypMultiCountSize] PropertyValue;
    optional string ID with Encoding{Ignore = true};
}

// Section 2.11.4   TaggedPropertyValue Structure
type TaggedPropertyValue[optional uint ptypMultiCountSize]
{
   PropertyTag PropertyTag;
   PropertyValue[PropertyTag.PropertyType, ptypMultiCountSize] PropertyValue;
}

// Section  2.11.5   FlaggedPropertyValue Structure
type FlaggedPropertyValue[ushort dataType, optional uint ptypMultiCountSize]
{
    byte Flag;
    optional [|Flag != 0x1|] ([|Flag == 0x0|] PropertyValue[dataType, ptypMultiCountSize] |
                              [|Flag == 0xA|] PropertyValue[PropertyDataType.PtypErrorCode, ptypMultiCountSize]) PropertyValue;
    
    optional string ID with Encoding{Ignore = true};
}

// Section 2.11.6   FlaggedPropertyValueWithType Structure
type FlaggedPropertyValueWithType[optional uint ptypMultiCountSize]
{
    ushort PropertyType with DisplayInfo{ToText = PropTypeValueToText};
    byte Flag;
    optional [|Flag != 0x1|] ([|Flag == 0x0|] PropertyValue[PropertyType, ptypMultiCountSize] |
                              [|Flag == 0xA|] PropertyValue[PropertyDataType.PtypErrorCode, ptypMultiCountSize]) PropertyValue;
    optional string ID with Encoding{Ignore = true};
}

// Section 2.11.7   TypedString Structure
pattern StringTypeEnum = enum byte
{
    NoPresent                     = 0x00,
    Empty                         = 0x01,
    CharacterString               = 0x02,
    ReducedUnicodeCharacterString = 0x03,
    UnicodeCharacterString        = 0x04,
    ...
};

type TypedString
{
    StringTypeEnum StringType;
    optional [|(StringType != StringTypeEnum.NoPresent) && (StringType != StringTypeEnum.Empty)|] string String 
        with BinaryEncoding{
            TextEncoding = (StringType == StringTypeEnum.UnicodeCharacterString) ? TextEncoding.Unicode : TextEncoding.ASCII
        };
    
    override string ToString()
    {
        if (StringType == StringTypeEnum.NoPresent || StringType == StringTypeEnum.Empty)
            return "\"\"";
        return String as string;
    }
}

// Section 2.12   Restrictions
pattern Restriction = [|CurrentByte(stream) == 0x00|] AddRestriction |
                           [|CurrentByte(stream) == 0x01|] OrRestriction |
                           [|CurrentByte(stream) == 0x02|] NotRestriction	|
						   [|CurrentByte(stream) == 0x03|] ContentRestriction	|
						   [|CurrentByte(stream) == 0x04|] PropertyRestriction	|
						   [|CurrentByte(stream) == 0x05|] ComparePropertiesRestriction |
						   [|CurrentByte(stream) == 0x06|] BitmaskRestriction	|
                           [|CurrentByte(stream) == 0x07|] SizeRestriction	|
						   [|CurrentByte(stream) == 0x08|] ExistRestriction	|
						   [|CurrentByte(stream) == 0x09|] SubObjectRestriction	|
						   [|CurrentByte(stream) == 0x0A|] CommentRestriction	|
						   [|CurrentByte(stream) == 0x0B|] CountRestriction;
						   
typedef PtypRestriction = Restriction;
					   
// Section 2.12.1   And Restriction Structures
type AddRestriction
{
	byte RestrictType;
	ushort RestrictCount;
	array<Restriction>Restricts  with BinaryEncoding {Length = RestrictCount};
}

// Section 2.12.2   Or Restriction Structures
type OrRestriction
{
	byte RestrictType;
	ushort RestrictCount;
	array<Restriction>Restricts  with BinaryEncoding {Length = RestrictCount};
}

// Section 2.12.3   Not Restriction Structures
type NotRestriction
{
	byte RestrictType;
	Restriction Restriction;
}

// Section 2.12.4.1   ContentRestriction Structure
type ContentRestriction
{
	byte RestrictType;
	ushort FuzzyLevelLow;
	ushort FuzzyLevelHigh;
	PropertyTag PropertyTag;
	TaggedPropertyValue TaggedValue;
}

// Section 2.12.5.1   PropertyRestriction Structure
type PropertyRestriction
{
	byte RestrictType;
	RelOpType RelOp;
	uint PropTag;
	TaggedPropertyValue TaggedValue;
}

pattern RelOpType= enum byte
{
	RelationalOperatorLessThan = 0x00,
	RelationalOperatorLessThanOrEqual  = 0x01,
	RelationalOperatorGreaterThan  = 0x02,
	RelationalOperatorGreaterThanOrEqual  = 0x03,
	RelationalOperatorEqual  = 0x04,
	RelationalOperatorNotEqual  = 0x5,
	RelationalOperatorMemberOfDL  = 0x64,
	...
};

// Section 2.12.6   Compare Properties Restriction Structures
type ComparePropertiesRestriction
{
	byte RestrictType;
	RelOpType RelOp;
	uint PropTag1;
	uint PropTag2;
}

// Section 2.12.7   Bitmask Restriction Structures
type BitmaskRestriction
{
	byte RestrictType;
	BitmapRelOpType BitmapRelOp;
	PtypInteger32 PropTag;
	uint Mask;
}

pattern BitmapRelOpType = enum byte
{
	BMR_EQZ = 0x00,
	BMR_NEZ = 0x01,
	...
};

// Section 2.12.8.1   SizeRestriction Structure
type SizeRestriction
{
	byte RestrictType;
	RelOpType RelOp;
	uint PropTag;
	uint Size;
}

// Section 2.12.9.1   ExistRestriction Structure
type ExistRestriction
{
	byte RestrictType;
	uint PropTag;
}

// Section 2.12.10.1   SubObjectRestriction Structure
type SubObjectRestriction
{
	byte RestrictType;
	uint Subobject where ValidationCheck(value == 0x0E12000D || value == 0x0E13000D, null, "Invalid SubObjectRestriction property tag.");  		
	Restriction Restriction;
}

// Section 2.12.11   CommentRestriction Structure
type CommentRestriction
{
	byte RestrictType;	
	byte TaggedValuesCount;
	array<TaggedPropertyValue> TaggedValues with BinaryEncoding {Length = TaggedValuesCount};
	byte RestrictionPresent;
	optional [|RestrictionPresent == 1|] Restriction Restriction;
}

// Section 2.12.12   CountRestriction Structure
type CountRestriction
{
	byte RestrictType;
	uint Count;
	Restriction SubRestriction;	
}

// This type is specified in MS-OXORULE section 2.2.5 RuleAction Structure 
type RuleAction[optional uint ptypMultiCountSize]
{
    ([|ptypMultiCountSize == nothing|] ushort |
     [|ptypMultiCountSize as uint == 2|] ushort |
     [|ptypMultiCountSize as uint == 4|] uint) NoOfActions; // Note: This number MUST be greater than zero

	array<ActionBlock[ptypMultiCountSize]> ActionBlocks with BinaryEncoding{Length = CountToUintValue(NoOfActions)};
	
	uint CountToUintValue(any count)
    {
        if (count is us:ushort)
            return us as uint;
        if (count is ui:uint)
            return ui;  
        return 0;
    }
}

typedef PtypRuleAction =  RuleAction;

// This type is specified in MS-OXORULE section 2.2.5.1.1 ActionFlavor structure when ActionType is relate to FORWARD
type ActionFlavor_Forward
{
     int Reserved_bits_0 with BinaryEncoding{Width = 4};
	 int TM with BinaryEncoding{Width = 1};
	 int AT with BinaryEncoding{Width = 1};
	 int NC with BinaryEncoding{Width = 1};
	 int PR with BinaryEncoding{Width = 1};
	 int Reserved_bits_1 with BinaryEncoding{Width = 24};
}

// This type is specified in MS-OXORULE section 2.2.5.1.1 ActionFlavor structure when ActionType is relate to REPLY
type ActionFlavor_Reply
{
     int Reserved_bits_0 with BinaryEncoding{Width = 6};
	 int ST with BinaryEncoding{Width = 1};
	 int NS with BinaryEncoding{Width = 1};
	 int Reserved_bits_1 with BinaryEncoding{Width = 24};
}

// This type is specified in MS-OXORULE section 2.2.5.1.1 ActionFlavor structure when ActionType is not related to REPLY or FORWARD 
type ActionFlavor_Reserved
{
  int Reserved_bits with BinaryEncoding{Width=32};
}

// This type is specified in MS-OXORULE section 2.2.5.1 ActionBlock Structure
type ActionBlock[optional uint ptypMultiCountSize]
{
	 ([|ptypMultiCountSize == nothing|] ushort |
     [|ptypMultiCountSize as uint == 2|] ushort |
     [|ptypMultiCountSize as uint == 4|] uint) ActionLength;
	 
	 ActionType ActionType;
	 
	 ([|ActionType==0x03||ActionType==0x04|]ActionFlavor_Reply | [|ActionType==0x07|]ActionFlavor_Forward | ActionFlavor_Reserved)ActionFlavor;
	 
	 uint ActionFlags;
	 
	 optional ([|( CountToUintValue(ActionLength) >9 ) && (ActionTypeEnum.OP_MOVE == ActionType || ActionTypeEnum.OP_COPY == ActionType) && IsEqual(ptypMultiCountSize, 2)|] OP_MOVE_and_OP_COPY_ActionData_forStandard |
	 [|( CountToUintValue(ActionLength) >9 ) && (ActionTypeEnum.OP_MOVE == ActionType || ActionTypeEnum.OP_COPY == ActionType) && IsEqual(ptypMultiCountSize, nothing)|] OP_MOVE_and_OP_COPY_ActionData_forStandard |
	 [|( CountToUintValue(ActionLength) >9 ) && (ActionTypeEnum.OP_MOVE == ActionType || ActionTypeEnum.OP_COPY == ActionType) && IsEqual(ptypMultiCountSize, 4)|] OP_MOVE_and_OP_COPY_ActionData_forExtended|
	 [|( CountToUintValue(ActionLength) >9 ) && (ActionTypeEnum.OP_REPLY == ActionType || ActionTypeEnum.OP_OOF_REPLY == ActionType) &&  IsEqual(ptypMultiCountSize, 2)|] OP_REPLY_and_OP_OOF_REPLY_ActionData_forStandard|
	 [|( CountToUintValue(ActionLength) >9 ) && (ActionTypeEnum.OP_REPLY == ActionType || ActionTypeEnum.OP_OOF_REPLY == ActionType) &&  IsEqual(ptypMultiCountSize, nothing)|] OP_REPLY_and_OP_OOF_REPLY_ActionData_forStandard|
	 [|( CountToUintValue(ActionLength) >9 ) && (ActionTypeEnum.OP_REPLY == ActionType || ActionTypeEnum.OP_OOF_REPLY == ActionType) &&  IsEqual(ptypMultiCountSize, 4)|] OP_REPLY_and_OP_OOF_REPLY_ActionData_forExtended|
	 [|( CountToUintValue(ActionLength) >9 ) && (ActionTypeEnum.OP_FORWARD == ActionType || ActionTypeEnum.OP_DELEGATE == ActionType) |] OP_FORWARD_and_OP_DELEGATE_ActionData|
	 [|( CountToUintValue(ActionLength) >9 ) && (ActionTypeEnum.OP_BOUNCE == ActionType ) |] OP_BOUNCE_ActionData|
	 [|( CountToUintValue(ActionLength) >9 ) && (ActionTypeEnum.OP_TAG == ActionType ) |] OP_TAG_ActionData |
	 [|( CountToUintValue(ActionLength) >9 ) && (ActionTypeEnum.OP_DEFER_ACTION == ActionType )|] OP_DEFER_ACTION[GetLength()]
	 )ActionData; 
	 
	uint CountToUintValue(any count)
    {
        if (count is us:ushort)
            return us as uint;
        if (count is ui:uint)
            return ui;  
        return 0;
    }
	
	bool IsEqual(any op1,any num)
	{
		if (op1 == nothing && num == nothing)
			return true;
		
		if (op1 == nothing ||  num == nothing)
		{
			return false;
		}
		
		if (op1 as uint == num as uint)
		{
			return true;
		}
		else
			return false;
	}
	
	uint GetLength()
	{
		uint length;
		
		if (ActionLength is us:ushort)
            length =  us as uint;
        if (ActionLength is ui:uint)
            length =  ui;
		
		length = length - 9;
		return length;
	}
};

pattern ActionType = enum byte
{
	OP_MOVE	= 0x01,
	OP_COPY	= 0x02,
	OP_REPLY = 0x03,
	OP_OOF_REPLY =	0x04,
	OP_DEFER_ACTION	= 0x05,
	OP_BOUNCE = 0x06,
	OP_FORWARD = 0x07,
	OP_DELEGATE	= 0x08,
	OP_TAG	= 0x09,
	OP_DELETE = 0x0A,
	OP_MARK_AS_READ	= 0x0B
};

typedef ActionTypeEnum = ActionType;

pattern OP_FORWARD_ActionFlavor = enum uint
{
	PR = 0x00000001,
	NC = 0x00000002,
	AT = 0x00000004,
	TM = 0x00000008
};

pattern OP_REPLY_and_OP_OOF_REPLY_ActionFlavor = enum uint
{
	NS  = 0x00000001,
	ST = 0x00000002
};

// 2.2.5.1.2   ActionData Structure
// This type is specified in MS-OXORULE section 2.2.5.1.2.1 OP_MOVE and OP_COPY ActionData Structure for Standard Rules
type OP_MOVE_and_OP_COPY_ActionData_forStandard
{
	byte FolderInThisStore where value == 0x00 | value == 0x01;
	ushort StoreEIDSize;
	([|FolderInThisStore == 0x00|] StoreObjectEntryID | [|FolderInThisStore == 0x01|] string) StoreEID with BinaryEncoding {Length = StoreEIDSize};
	ushort FolderEIDSize;
	([|FolderInThisStore == 0x00|] array<byte> | [|FolderInThisStore == 0x01|] ServerEid) FolderEID with BinaryEncoding {Length = FolderEIDSize}; 
}

// This type is specified in MS-OXORULE section 2.2.5.1.2.1 OP_MOVE and OP_COPY ActionData Structure for Extended Rules
type OP_MOVE_and_OP_COPY_ActionData_forExtended
{
	uint StoreEIDSize;
	string StoreEID with BinaryEncoding {Length = StoreEIDSize};
	uint FolderEIDSize;
	FolderEntryID FolderEID;
}

// This type is specified in MS-OXORULE Section 2.2.5.1.2.1.1 ServerEid Structure
type ServerEid
{
	byte Ours;
	FolderID FolderId;
	ulong MessageId;
	int Instance;
}

// This type is specified in MS-OXORULE section 2.2.5.1.2.2 OP_REPLY and OP_OOF_REPLY ActionData Structure for Standard Rules
type OP_REPLY_and_OP_OOF_REPLY_ActionData_forStandard
{
	FolderID ReplyTemplateFID;
	MessageID ReplyTemplateMID;
	guid ReplyTemplateGUID;
}

// This type is specified in MS-OXORULE section 2.2.5.1.2.2 OP_REPLY and OP_OOF_REPLY ActionData Structure for Extended Rules
type OP_REPLY_and_OP_OOF_REPLY_ActionData_forExtended
{
	uint MessageEIDSize;
	MessageEntryID ReplyTemplateMessageEID;
	guid ReplyTemplateGUID;
}

// This type is specified in MS-OXORULE section 2.2.5.1.2.4 OP_FORWARD and OP_DELEGATE ActionData Structure
type OP_FORWARD_and_OP_DELEGATE_ActionData
{
	ushort RecipientCount;				
	array<RecipientBlockData> RecipientBlocks with BinaryEncoding {Length = RecipientCount};
}

// This type is specified in MS-OXORULE section 2.2.5.1.2.4.1 RecipientBlockData Structure
type RecipientBlockData
{
	byte Reserved;
	ushort NoOfProperties;				
	array<TaggedPropertyValue> PropertyValues with BinaryEncoding {Length = NoOfProperties};
}

// This type is specified in MS-OXORULE section 2.2.5.1.2.5 OP_BOUNCE ActionData Structure
type OP_BOUNCE_ActionData
{
	uint BounceCode with DisplayInfo{ToText = BounceToString};
	
	string BounceToString(any data)
	{
		uint typeValue = data as uint;
		string typeSummary = "";
    
		if (typeValue==0x0000000D)
		{
			typeSummary = "The message was rejected because it was too large.";
		}
		else if (typeValue == 0x0000001F)
		{
			typeSummary = "The message was rejected because it cannot be displayed to the user.";
		}
		else if (typeValue == 0x00000026)
		{
			typeSummary = "The message delivery was denied for other reasons.";
		}
		return typeSummary;
	}
}

// This type is specified in MS-OXORULE section 2.2.5.1.2.3 OP_DEFER_ACTION ActionData Structure
type OP_DEFER_ACTION[uint size]
{
	binary DeferActionData with BinaryEncoding {Length = size};
}

typedef OP_TAG_ActionData = TaggedPropertyValue;

//  ============================== 2.13   Table Sorting Structures  ==============================
// Section 2.13.1   SortOrder Structure
type SortOrder
{
    ushort PropertyType;
    ushort PropertyId;
    OrderType Order;
}

pattern OrderType = enum byte
{
    Ascending       = 0x00,
    Descending      = 0x01,
    MaximumCategory = 0x04
};

// Section 2.13.2   SortOrderSet Structure
type SortOrderSet
{
    ushort SortOrderCount;
    ushort CategorizedCount where value >= 0 && value <= SortOrderCount;
    ushort ExpandedCount where value >= 0 && value <= CategorizedCount;
    array<SortOrder> SortOrders with BinaryEncoding{Length = SortOrderCount}; 
}

// This function is used to check whether column number between two parameters (RecipientColumns and RecipientRows.RecipientRow.RecipientColumnCount) 
// matched in RopModifyRecipients ROP request.
array<PropertyTag> GetColumn(array<PropertyTag> RecipientColumns, ushort ColumnCountInRecipient)
{
    array<PropertyTag> Result = [];
	if (RecipientColumns.Count >= ColumnCountInRecipient)
	{
	     for (int i = 0; i < ColumnCountInRecipient; i++)
		 {
		    Result += [new PropertyTag{PropertyType = RecipientColumns[i].PropertyType, PropertyId = RecipientColumns[i].PropertyId}];
		 }
	}
    else 
	{
	     ErrorCodeIf(true, null, Format("Request format error: the RecipientColumnCount {0} should be less than RecipientColumns count {1}, check please.",ColumnCountInRecipient, RecipientColumns));
	}
	return Result;
}

// This function is used to convert global counter to string.
string GlobalCounterToString(any data)
{
	ulong globalCounter = data as ulong;
    return Format("{0:X12}", globalCounter);
}