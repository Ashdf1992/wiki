protocol MSOXCMAPIHTTP with
Documentation
{
    ProtocolName = "Messaging Application Programming Interface (MAPI) Extensions for HTTP",
    ShortName = "MS-OXCMAPIHTTP",
    DocumentName = "MS-OXCMAPIHTTP",
    ProtocolType = "HTTP",
},
OPNAuthoring
{
    Copyright = "(c) 2015 Microsoft Corporation",
    References = 
        [
            new Reference{Name = "MS-OXCMAPIHTTP", Version = "5.0"},
        ],
    RevisionSummary = 
        [
            new Revision {Class=RevisionClass.Major, Version="1.3.1", Date="08/31/2015"},
        ]
};

using Diagnostics;
using DTYP;
using HTTP;
using Standard;
using Utility;
using MSOXCDATA;
using MSOXCRPC;
using MSOXPROPS;
using Technologies.IDL;

pattern MapiHttpContentTypePattern = regex {application/mapi-http};
pattern MapiHttpResponseContentTypePattern = regex {text/html | application/mapi-http}; 
pattern ExecuteResponsePlainText = regex {[^\r\n]*[\r\n]{2}};
pattern HeadersType = map<string, HttpHeaderFieldValueType>;

endpoint Server over HTTP.Server
                accepts MapiHttpContract.MapiRequestMessage
                issues  MapiHttpContract.MapiResponseMessage;

client endpoint Client connected to Server;

autostart actor ActorOverHTTP(HTTP.Server httpServer)
{
    process httpServer accepts httpRequest : HttpContract.Request where IsOXCMAPIHTTPRequestMessage(httpRequest.Headers)
    {
		var mapiRequest = new MapiHttpContract.MapiRequestMessage();
		map<string, string> header = {};
		if ("Host" in httpRequest.Headers)
		{
			header += {"Host" -> httpRequest.Headers["Host"] as string};
		}
		if ("Content-Length" in httpRequest.Headers)
		{
			header += {"Content-Length" -> httpRequest.Headers["Content-Length"] as string};
		}
		if ("Content-Type" in httpRequest.Headers)
		{
			header += {"Content-Type" -> httpRequest.Headers["Content-Type"] as string};
		}
		if ("Set-Cookie" in httpRequest.Headers)
		{
			header += {"Set-Cookie" -> httpRequest.Headers["Set-Cookie"] as string};
		}
		if ("Cookie" in httpRequest.Headers)
		{
			header += {"Cookie" -> httpRequest.Headers["Cookie"] as string};
		}
		if ("X-RequestType" in httpRequest.Headers)
		{
			header += {"X-RequestType" -> httpRequest.Headers["X-RequestType"] as string};
		}
		if ("X-RequestId" in httpRequest.Headers) 
		{
			header += {"X-RequestId" -> httpRequest.Headers["X-RequestId"] as string};  
		}
		if ("X-ClientInfo" in httpRequest.Headers)
		{
			header += {"X-ClientInfo" -> httpRequest.Headers["X-ClientInfo"] as string};  
		}
		if ("X-ClientApplication" in httpRequest.Headers)
		{
			header += {"X-ClientApplication" -> httpRequest.Headers["X-ClientApplication"] as string}; 
	    }
		if ("X-DeviceInfo" in httpRequest.Headers)
		{
			header += {"X-DeviceInfo" -> httpRequest.Headers["X-DeviceInfo"] as string};
		}
		mapiRequest.Header = header;
		mapiRequest.InitBody(httpRequest.Payload);
		dispatch (endpoint Server over httpServer) accepts mapiRequest; 
	}
    
    process httpServer issues httpResponse : HttpContract.Response where IsOXCMAPIHTTPResponseMessage(httpResponse.Headers)
    {
        MapiHttpContract.MapiResponseMessage mapiResponse;

        bool isChunked = false;
		map<string, string> header = {};
		string DeviceInfo;
		string ContentType;
		if (("Transfer-Encoding" in httpResponse.Headers) && (httpResponse.Headers["Transfer-Encoding"] != nothing))
        {
            isChunked = true;
            mapiResponse = new MapiHttpContract.MapiChunkedResponseMessage();
			header += {"Transfer-Encoding" -> httpResponse.Headers["Transfer-Encoding"] as string};
		}
        else
        {
            mapiResponse = new MapiHttpContract.MapiNonChunkedResponseMessage();
			header += {"Content-Length" -> httpResponse.Headers["Content-Length"] as string};
        }
		if (httpResponse.Headers["X-ResponseCode"] == "0") 
		{
			ContentType = httpResponse.Headers["Content-Type"] as string; 
			ValidationCheck(ContentType == "application/mapi-http", null, "The Content-Type header MUST contain the string 'application/mapi-http' on responses with X-ResponseCode header of 0.");
			header += {"Content-Type" -> ContentType};  
		}
		else if(httpResponse.Headers["X-ResponseCode"] != "0")
		{
			ContentType = httpResponse.Headers["Content-Type"] as string; 
			ValidationCheck(ContentType == "text/html", null, "The Content-Type header MUST contain the string 'text/html' on responses with X-ResponseCode header of non zero.");
			header += {"Content-Type" -> ContentType};  
		}		
		if ("X-RequestType" in httpResponse.Headers)
		{
			header += {"X-RequestType" -> httpResponse.Headers["X-RequestType"] as string};
		}
		if ("X-PendingPeriod" in httpResponse.Headers)
		{
			header += {"X-PendingPeriod" -> httpResponse.Headers["X-PendingPeriod"] as string};
		}
		if ("X-RequestId" in httpResponse.Headers)
		{
			header += {"X-RequestId" ->  httpResponse.Headers["X-RequestId"] as string}; 
		}
		if ("X-ResponseCode" in httpResponse.Headers)
		{
			header += {"X-ResponseCode" -> httpResponse.Headers["X-ResponseCode"] as string};
		}
		if ("X-ClientInfo" in httpResponse.Headers)
		{
			header += {"X-ClientInfo" -> httpResponse.Headers["X-ClientInfo"] as string};  
		}
		if ("X-ServerApplication" in httpResponse.Headers)
		{
			header += {"X-ServerApplication" -> httpResponse.Headers["X-ServerApplication"] as string};  
		}
		if ("X-ExpirationInfo" in httpResponse.Headers)
		{
			header += {"X-ExpirationInfo" -> httpResponse.Headers["X-ExpirationInfo"] as string};
		}
		if ("X-DeviceInfo" in httpResponse.Headers)
		{
			DeviceInfo = httpResponse.Headers["X-DeviceInfo"] as string;
        }
		mapiResponse.Header = header;
        mapiResponse.InitBody(httpResponse.Payload);
        dispatch (endpoint Server over httpServer) issues mapiResponse;
    }
}

contract MapiHttpContract
{
    message MapiMessageBase
    {
        // Must be set firstly
 		map<string, string> Header;      
    }

    message MapiRequestMessage : MapiMessageBase
    {

        MapiHttpRequestBodyBase RequestBody;
        
        void InitBody(binary data)
        {
			RequestBody = (BinaryDecoder<RequestBodyWrapper[this.Header["X-RequestType"]]>(data) as RequestBodyWrapper).Value as MapiHttpRequestBodyBase;
		}

        override string ToString()
        {
            return this.Header["X-RequestType"] + " Request";
        }
    }

    message MapiResponseMessage : MapiMessageBase
    {
		MapiHttpResponseBodyBase ResponseBody;
		
        void InitBody(binary data)
        {
            ResponseBody = (BinaryDecoder<ResponseBodyWrapper[this.Header["X-RequestType"]]>(data) as ResponseBodyWrapper).Value 
                            as MapiHttpResponseBodyBase;
        }
       
        override string ToString()
        {
            return this.Header["X-RequestType"] + " Response";
        }
    }

    message MapiNonChunkedResponseMessage : MapiResponseMessage
    {
	    override string ToString()
        {
            return this.Header["X-RequestType"] + " Non-chunked Response";
        }
    }

    message MapiChunkedResponseMessage : MapiResponseMessage
    {
		override string ToString()
        {
            return this.Header["X-RequestType"] + " Chunked Response";
        }
    }
}

// ==============================2.2.1   Common Data Types==============================
// Section 2.2.1.1 AddressBookPropertyValue Structure
type AddressBookPropertyValue[MSOXCDATA.PropertyDataType propertyDataType, optional uint ptypMultiCountSize]
{
	optional [| propertyDataType is MSOXCDATA.PropertyDataType.PtypString || propertyDataType is MSOXCDATA.PropertyDataType.PtypString8 || propertyDataType is MSOXCDATA.PropertyDataType.PtypBinary || propertyDataType is MSOXCDATA.PropertyDataType.PtypMultipleInteger16 || propertyDataType is MSOXCDATA.PropertyDataType.PtypMultipleInteger32 || propertyDataType is MSOXCDATA.PropertyDataType.PtypMultipleFloating32 || propertyDataType is MSOXCDATA.PropertyDataType.PtypMultipleFloating64 || propertyDataType is MSOXCDATA.PropertyDataType.PtypMultipleCurrency || propertyDataType is MSOXCDATA.PropertyDataType.PtypMultipleFloatingTime || propertyDataType is MSOXCDATA.PropertyDataType.PtypMultipleInteger64 || propertyDataType is MSOXCDATA.PropertyDataType.PtypMultipleString || propertyDataType is MSOXCDATA.PropertyDataType.PtypMultipleString8 || propertyDataType is MSOXCDATA.PropertyDataType.PtypMultipleTime || propertyDataType is MSOXCDATA.PropertyDataType.PtypMultipleGuid || propertyDataType is MSOXCDATA.PropertyDataType.PtypMultipleBinary |] byte HasValue with DisplayInfo{ToText = HasValueBoolValueToText};
	optional [|HasValue != 0 && HasValue != nothing|] MSOXCDATA.MAPIPropertyValue[propertyDataType, ptypMultiCountSize] PropertyValue;
}

// Section 2.2.1.2 AddressBookTaggedPropertyValue  Structure
type AddressBookTaggedPropertyValue
{
    MSOXCDATA.PropertyDataType PropertyType with DisplayInfo{ToText = MSOXCDATA.PropTypeValueToText};
	ushort PropertyId with DisplayInfo{ToText = (any data) => GetPropNameByTag(data as ushort, PropertyType)};
	AddressBookPropertyValue[PropertyType] PropertyValue;
}

// Section 2.2.1.3   AddressBookPropertyValueList Structure
type AddressBookPropertyValueList[optional uint ptypMultiCountSize]
{
    uint PropertyValueCount;
    array<MapiTaggedPropertyValue[ptypMultiCountSize]> PropertyValues with BinaryEncoding{Length = PropertyValueCount};
}

// Section 2.2.1.4 AddressBookTypedPropertyValue Structure
type AddressBookTypedPropertyValue 
{
	MSOXCDATA.PropertyDataType PropertyType;
	AddressBookPropertyValue[PropertyType] PropertyValue;
}

//2.2.1.5   AddressBookFlaggedPropertyValue Structure
type AddressBookFlaggedPropertyValue[MSOXCDATA.PropertyDataType propertyDataType]
{
	byte Flag;
    optional [|Flag != 0x1|] ([|Flag == 0x0|] AddressBookPropertyValue[propertyDataType] |
                              [|Flag == 0xA|] AddressBookPropertyValue[PropertyDataType.PtypErrorCode]) PropertyValue;
}

//2.2.1.6   AddressBookFlaggedPropertyValueWithType Structure
type AddressBookFlaggedPropertyValueWithType
{
	MSOXCDATA.PropertyDataType PropertyType;
	byte Flag;
    optional [|Flag != 0x1|] ([|Flag == 0x0|] AddressBookPropertyValue[PropertyType] |
                              [|Flag == 0xA|] AddressBookPropertyValue[PropertyDataType.PtypErrorCode]) PropertyValue;
}

// Section 2.2.1.7   AddressBookPropertyRow Structure
type AddressBookPropertyRow[optional LargePropertyTagArray largePropTagArray, optional uint ptypMultiCountSize]
{
    byte Flags;
    array<AddrBookPropValue> ValueArray with Encoding{Decoder = ValueArrayDecoder};
    
    optional array<AddrBookPropValue> ValueArrayDecoder(stream payload)
    {
        array<AddrBookPropValue> result = [];
        
        if (largePropTagArray is lp:LargePropertyTagArray)
        {
            foreach (var propTag in lp.PropertyTags)
            {
                AddrBookPropValue addrRowValue = null;
                if (Flags == 0x00)
                {
                    if (propTag.PropertyType != PropertyDataType.PtypUnspecified)
                    {
                        AddressBookPropertyValue propValue = BinaryDecoder<AddressBookPropertyValue[propTag.PropertyType, ptypMultiCountSize]>
                                    (payload) as AddressBookPropertyValue;
                        addrRowValue = propValue;
                    }
                    else
                    {
                        AddressBookTypedPropertyValue typePropValue  = BinaryDecoder<AddressBookTypedPropertyValue>(payload) as AddressBookTypedPropertyValue;
                        addrRowValue = typePropValue;
                    }
                }
                else if (Flags == 0x01)
                {
                    if (propTag.PropertyType != PropertyDataType.PtypUnspecified)
                    {
                        AddressBookFlaggedPropertyValue flagPropValue = BinaryDecoder<AddressBookFlaggedPropertyValue[propTag.PropertyType]> 
                                    (payload) as AddressBookFlaggedPropertyValue;
                        addrRowValue = flagPropValue;
                    }
                    else
                    {
                        AddressBookFlaggedPropertyValueWithType flagPropValue = BinaryDecoder<AddressBookFlaggedPropertyValueWithType>(payload) as AddressBookFlaggedPropertyValueWithType;
                        addrRowValue = flagPropValue;
                    }
                }
                
                result += [addrRowValue];
            }
        }

        return result;
    }
}

pattern AddrBookPropValue = MapiPropertyValue |
                            MapiTypedPropertyValue | 
                            MapiFlaggedPropertyValue | 
                            MapiFlaggedPropertyValueWithType |
							AddressBookPropertyValue |
							AddressBookTypedPropertyValue |
							AddressBookFlaggedPropertyValue | 
							AddressBookFlaggedPropertyValueWithType;

// Section 2.2.1.3   LargePropertyTagArray Structure
type LargePropertyTagArray 
{
    uint PropertyTagCount;
    array<PropertyTag> PropertyTags with BinaryEncoding{Length = PropertyTagCount};
}

// Section 2.2.3.3.3   X-ResponseCode Header Field
pattern XResponseCodeType = enum uint
{
    $"Success"                = 0,
    $"Unknown Failure"        = 1,
    $"Invalid Verb"           = 2,
    $"Invalid Path"           = 3,
    $"Invalid Header"         = 4,
    $"Invalid Request Type"   = 5,
    $"Invalid Context Cookie" = 6,
    $"Missing Header"         = 7,
    $"Anonymous Not Allowed"  = 8,
    $"Too Large"              = 9,
    $"Context Not Found"      = 10,
    $"No Privilege"           = 11,
    $"Invalid Request Body"   = 12,
    $"Missing Cookie"         = 13,
    $"Reserved"               = 14,
    $"Invalid Sequence"       = 15,
    $"Endpoint Disabled"      = 16,
    $"Invalid Response"       = 17,
    $"Endpoint Shutting Down" = 18
    ...
};

// 
// Supplementary types used to decoding OXCMAPIHTTP body
// NOTE: it should be a workaround to solve BinaryDecoder can't parse A|B pattern correctly. 
//
type RequestBodyWrapper[string requestType]
{
    ([|requestType == "PING"|] PINGRequestBodyType |
     [|requestType == "Connect"|] ConnectRequestBodyType |
     [|requestType == "Execute"|] ExecuteRequestBodyType |
     [|requestType == "Disconnect"|] DisconnectRequestBodyType |
     [|requestType == "NotificationWait"|] NotificationWaitRequestBodyType |
     [|requestType == "Bind"|] BindRequestBodyType |
     [|requestType == "Unbind"|] UnbindRequestBodyType |
     [|requestType == "CompareMIds"|] CompareMinIdsRequestBodyType |
     [|requestType == "DNToMId"|] DnToMinIdRequestBodyType |
     [|requestType == "GetMatches"|] GetMatchesRequestBodyType |
     [|requestType == "GetPropList"|] GetPropListRequestBodyType |
     [|requestType == "GetProps"|] GetPropsRequestBodyType |
     [|requestType == "GetSpecialTable"|] GetSpecialTableRequestBodyType |
     [|requestType == "GetTemplateInfo"|] GetTemplateInfoRequestBodyType |
     [|requestType == "ModLinkAtt"|] ModLinkAttRequestBodyType |
     [|requestType == "ModProps"|] ModPropsRequestBodyType |
     [|requestType == "QueryRows"|] QueryRowsRequestBodyType |
     [|requestType == "QueryColumns"|] QueryColumnsRequestBodyType |
     [|requestType == "ResolveNames"|] ResolveNamesRequestBodyType |
     [|requestType == "ResortRestriction"|] ResortRestrictionRequestBodyType |
     [|requestType == "SeekEntries"|] SeekEntriesRequestBodyType |
     [|requestType == "UpdateStat"|] UpdateStatRequestBodyType |
     [|requestType == "GetMailboxUrl"|] GetMailboxUrlRequestBodyType |
     [|requestType == "GetAddressBookUrl"|] GetAddressBookUrlRequestBodyType) Value;
}

type ResponseBodyWrapper[string requestType]
{
    ([|requestType == "PING"|] PINGResponseBodyType |
     [|requestType == "Connect"|] ConnectResponseBodyType |
     [|requestType == "Execute"|] ExecuteResponseBodyType |
     [|requestType == "Disconnect"|] DisconnectResponseBodyType |
     [|requestType == "NotificationWait"|] NotificationWaitResponseBodyType |
     [|requestType == "Bind"|] BindResponseBodyType |
     [|requestType == "Unbind"|] UnbindResponseBodyType |
     [|requestType == "CompareMIds"|] CompareMinIdsResponseBodyType |
     [|requestType == "DNToMId"|] DnToMinIdResponseBodyType |
     [|requestType == "GetMatches"|] GetMatchesResponseBodyType |
     [|requestType == "GetPropList"|] GetPropListResponseBodyType |
     [|requestType == "GetProps"|] GetPropsResponseBodyType |
     [|requestType == "GetSpecialTable"|] GetSpecialTableResponseBodyType |
     [|requestType == "GetTemplateInfo"|] GetTemplateInfoResponseBodyType |
     [|requestType == "ModLinkAtt"|] ModLinkAttResponseBodyType |
     [|requestType == "ModProps"|] ModPropsResponseBodyType |
     [|requestType == "QueryRows"|] QueryRowsResponseBodyType |
     [|requestType == "QueryColumns"|] QueryColumnsResponseBodyType |
     [|requestType == "ResolveNames"|] ResolveNamesResponseBodyType |
     [|requestType == "ResortRestriction"|] ResortRestrictionResponseBodyType |
     [|requestType == "SeekEntries"|] SeekEntriesResponseBodyType |
     [|requestType == "UpdateStat"|] UpdateStatResponseBodyType |
     [|requestType == "GetMailboxUrl"|] GetMailboxUrlResponseBodyType |
     [|requestType == "GetAddressBookUrl"|] GetAddressBookUrlResponseBodyType) Value;
}

type MapiHttpRequestBodyBase
{
}

type MapiHttpResponseBodyBase
{
    string AdditionalText with BinaryEncoding{TextEncoding = TextEncoding.ASCII, TextTerminator = "\r\n\r\n"};
}

type MapiHttpResponseBody : MapiHttpResponseBodyBase
{
    uint StatusCode;
}

// ==============================2.2.4.1   Connect Request Type==============================
// Section 2.2.4.1.1   Connect Request Type Request Body
type ConnectRequestBodyType : MapiHttpRequestBodyBase
{
    string UserDn with BinaryEncoding{TextEncoding = TextEncoding.ASCII};
    uint Flags;
    uint DefaultCodePage;
    uint LcidSort;
    uint LcidString;
    uint AuxiliaryBufferSize;
    optional [|AuxiliaryBufferSize > 0|] ExtendedBuffer[true] AuxiliaryBuffer with BinaryEncoding{WidthForComposedType = AuxiliaryBufferSize * 8};
}

// Section 2.2.4.1.2   Connect Request Type Success Response Body
type ConnectResponseSuccessBodyType : MapiHttpResponseBody
{
    invariant StatusCode == 0x0;
        
    uint ErrorCode with DisplayInfo{ToText = (any data) => GetReturnValueMeaning(data as uint)};
    uint PollsMax;
    uint RetryCount;
    uint RetryDelay;
    string DnPrefix with BinaryEncoding{TextEncoding = TextEncoding.ASCII};
    string DisplayName with BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    uint AuxiliaryBufferSize;
    optional [|AuxiliaryBufferSize > 0|] ExtendedBuffer[true] AuxiliaryBuffer with BinaryEncoding{WidthForComposedType = AuxiliaryBufferSize * 8};
}

// Section 2.2.4.1.3   Connect Request Type Failure Response Body
type ConnectResponseFailureBodyType : MapiHttpResponseBody
{
    invariant StatusCode != 0x0;

    uint AuxiliaryBufferSize;
    optional [|AuxiliaryBufferSize > 0|] ExtendedBuffer[true] AuxiliaryBuffer with BinaryEncoding{WidthForComposedType = AuxiliaryBufferSize * 8};
}

pattern ConnectResponseBodyType = ConnectResponseFailureBodyType | ConnectResponseSuccessBodyType;

// ==============================2.2.4.2   Execute Request Type==============================
// Section 2.2.4.2.1   Execute Request Type Request Body
type ExecuteRequestBodyType : MapiHttpRequestBodyBase
{
    uint Flags;
    uint RopBufferSize;
    ExtendedBuffer[false] RopBuffer;
    uint MaxRopOut;
    uint AuxiliaryBufferSize;
    optional [|AuxiliaryBufferSize > 0|] ExtendedBuffer[true] AuxiliaryBuffer with BinaryEncoding{WidthForComposedType = AuxiliaryBufferSize * 8};
}

// Section 2.2.4.2.2   Execute Request Type Success Response Body
type ExecuteResponseSuccessBodyType : MapiHttpResponseBody
{
    invariant StatusCode == 0x0;
    
    uint ErrorCode with DisplayInfo{ToText = (any data) => GetReturnValueMeaning(data as uint)};
    uint Flags;
    uint RopBufferSize;
    optional [|RopBufferSize > 0|] ExtendedBuffer[false] RopBuffer with BinaryEncoding{WidthForComposedType = RopBufferSize * 8};
    uint AuxiliaryBufferSize;
    optional [|AuxiliaryBufferSize > 0|] ExtendedBuffer[true] AuxiliaryBuffer with BinaryEncoding{WidthForComposedType = AuxiliaryBufferSize * 8};
}

// Section 2.2.4.2.3   Execute Request Type Failure Response Body
type ExecuteResponseFailureBodyType : MapiHttpResponseBody
{
    invariant StatusCode != 0x0;
    
    uint AuxiliaryBufferSize;
    optional [|AuxiliaryBufferSize > 0|] ExtendedBuffer[true] AuxiliaryBuffer with BinaryEncoding{WidthForComposedType = AuxiliaryBufferSize * 8};
}

pattern ExecuteResponseBodyType = ExecuteResponseFailureBodyType | ExecuteResponseSuccessBodyType;

// ==============================2.2.4.3   Disconnect Request Type==============================
// Section 2.2.4.3.1   Disconnect Request Type Request Body
type DisconnectRequestBodyType : MapiHttpRequestBodyBase
{
    uint AuxiliaryBufferSize;
    optional [|AuxiliaryBufferSize > 0|] ExtendedBuffer[true] AuxiliaryBuffer with BinaryEncoding{WidthForComposedType = AuxiliaryBufferSize * 8};
}

// Section 2.2.4.3.2   Disconnect Request Type Success Response Body
type DisconnectResponseSuccessBodyType : MapiHttpResponseBody
{
    invariant StatusCode == 0x0;
    
    uint ErrorCode with DisplayInfo{ToText = (any data) => GetReturnValueMeaning(data as uint)};
    uint AuxiliaryBufferSize;
    optional [|AuxiliaryBufferSize > 0|] ExtendedBuffer[true] AuxiliaryBuffer with BinaryEncoding{WidthForComposedType = AuxiliaryBufferSize * 8};
}

// Section 2.2.4.3.3   Disconnect Request Type Failure Response Body
type DisconnectResponseFailureBodyType : MapiHttpResponseBody
{
    invariant StatusCode != 0x0;
    
    uint AuxiliaryBufferSize;
    optional [|AuxiliaryBufferSize > 0|] ExtendedBuffer[true] AuxiliaryBuffer with BinaryEncoding{WidthForComposedType = AuxiliaryBufferSize * 8};
}

pattern DisconnectResponseBodyType = DisconnectResponseSuccessBodyType | DisconnectResponseFailureBodyType;

// ==============================2.2.4.4   NotificationWait Request Type==============================
// Section 2.2.4.4.1   NotificationWait Request Type Request Body
type NotificationWaitRequestBodyType : MapiHttpRequestBodyBase
{
    uint Flags;
    uint AuxiliaryBufferSize;
    optional [|AuxiliaryBufferSize > 0|] ExtendedBuffer[true] AuxiliaryBuffer with BinaryEncoding{WidthForComposedType = AuxiliaryBufferSize * 8};
}

// Section 2.2.4.4.2   NotificationWait Request Type Success Response Body
type NotificationWaitResponseSuccessBodyType : MapiHttpResponseBody
{
    invariant StatusCode == 0x0;
	
    uint ErrorCode with DisplayInfo{ToText = (any data) => GetReturnValueMeaning(data as uint)};
    uint EventPending;
    uint AuxiliaryBufferSize;
    optional [|AuxiliaryBufferSize > 0|] ExtendedBuffer[true] AuxiliaryBuffer with BinaryEncoding{WidthForComposedType = AuxiliaryBufferSize * 8};
}

// Section 2.2.4.4.3   NotificationWait Request Type Failure Response Body
type NotificationWaitResponseFailureBodyType : MapiHttpResponseBody
{
	invariant StatusCode != 0x0;

    uint AuxiliaryBufferSize;
    optional [|AuxiliaryBufferSize > 0|] ExtendedBuffer[true] AuxiliaryBuffer with BinaryEncoding{WidthForComposedType = AuxiliaryBufferSize * 8};
}

pattern NotificationWaitResponseBodyType = NotificationWaitResponseFailureBodyType | NotificationWaitResponseSuccessBodyType;

// ==============================2.2.5.1   Bind Request Type==============================
// Section 2.2.5.1.1   Bind Request Type Request Body
type BindRequestBodyType : MapiHttpRequestBodyBase
{
    uint Flags;
    byte HasState with DisplayInfo{ToText = BoolValueToText};
    optional [|HasState != 0|] STAT State;
    uint AuxiliaryBufferSize;
    optional [|AuxiliaryBufferSize > 0|] ExtendedBuffer[true] AuxiliaryBuffer with BinaryEncoding{WidthForComposedType = AuxiliaryBufferSize * 8};
}

// Section 2.2.5.1.2   Bind Request Type Success Response Body
type BindResponseSuccessBodyType : MapiHttpResponseBody
{
    invariant StatusCode == 0x0;

    uint ErrorCode;
    GUID ServerGuid;
    uint AuxiliaryBufferSize;
    optional [|AuxiliaryBufferSize > 0|] ExtendedBuffer[true] AuxiliaryBuffer with BinaryEncoding{WidthForComposedType = AuxiliaryBufferSize * 8};
}

// Section 2.2.5.1.3   Bind Request Type Failure Response Body
type BindResponseFailureBodyType : MapiHttpResponseBody
{
    invariant StatusCode != 0x0;

    uint AuxiliaryBufferSize;
    optional [|AuxiliaryBufferSize > 0|] ExtendedBuffer[true] AuxiliaryBuffer with BinaryEncoding{WidthForComposedType = AuxiliaryBufferSize * 8};
}

pattern BindResponseBodyType = BindResponseFailureBodyType | BindResponseSuccessBodyType;

// ==============================2.2.5.2   Unbind Request Type==============================
// Section 2.2.5.2.1   Unbind Request Type Request Body
type UnbindRequestBodyType : MapiHttpRequestBodyBase
{
    uint Reserved;
    uint AuxiliaryBufferSize;
    optional [|AuxiliaryBufferSize > 0|] ExtendedBuffer[true] AuxiliaryBuffer with BinaryEncoding{WidthForComposedType = AuxiliaryBufferSize * 8};
}

// Section 2.2.5.2.2   Unbind Request Type Success Response Body
type UnbindResponseSuccessBodyType : MapiHttpResponseBody
{
    invariant StatusCode == 0x0;

    uint ErrorCode;
    uint AuxiliaryBufferSize;
    optional [|AuxiliaryBufferSize > 0|] ExtendedBuffer[true] AuxiliaryBuffer with BinaryEncoding{WidthForComposedType = AuxiliaryBufferSize * 8};
}

// Section 2.2.5.2.3   Unbind Request Type Failure Response Body
type UnbindResponseFailureBodyType : MapiHttpResponseBody
{
    invariant StatusCode != 0x0;

    uint AuxiliaryBufferSize;
    optional [|AuxiliaryBufferSize > 0|] ExtendedBuffer[true] AuxiliaryBuffer with BinaryEncoding{WidthForComposedType = AuxiliaryBufferSize * 8};
}

pattern UnbindResponseBodyType = UnbindResponseFailureBodyType | UnbindResponseSuccessBodyType;

// ==============================2.2.5.3   CompareMinIds Request Type==============================
// Section 2.2.5.3.1   CompareMinIds Request Type Request Body
type CompareMinIdsRequestBodyType : MapiHttpRequestBodyBase
{
    uint Reserved;
    byte HasState with DisplayInfo{ToText = BoolValueToText};
    optional [|HasState != 0|] STAT State;
    MinEntryID MinimalId1;
    MinEntryID MinimalId2;
    uint AuxiliaryBufferSize;
    optional [|AuxiliaryBufferSize > 0|] ExtendedBuffer[true] AuxiliaryBuffer with BinaryEncoding{WidthForComposedType = AuxiliaryBufferSize * 8};
}

// Section 2.2.5.3.2   CompareMinIds Request Type Success Response Body
type CompareMinIdsResponseSuccessBodyType : MapiHttpResponseBody
{
    invariant StatusCode == 0x0;

    uint ErrorCode;
    int Result;
    uint AuxiliaryBufferSize;
    optional [|AuxiliaryBufferSize > 0|] ExtendedBuffer[true] AuxiliaryBuffer with BinaryEncoding{WidthForComposedType = AuxiliaryBufferSize * 8};
}

// Section 2.2.5.3.3   CompareMinIds Request Type Failure Response Body
type CompareMinIdsResponseFailureBodyType : MapiHttpResponseBody
{
    invariant StatusCode != 0x0;

    uint AuxiliaryBufferSize;
    optional [|AuxiliaryBufferSize > 0|] ExtendedBuffer[true] AuxiliaryBuffer with BinaryEncoding{WidthForComposedType = AuxiliaryBufferSize * 8};
}

pattern CompareMinIdsResponseBodyType = CompareMinIdsResponseFailureBodyType | CompareMinIdsResponseSuccessBodyType;

// ==============================2.2.5.4   DnToMinId Request Type==============================
// Section 2.2.5.4.1   DnToMinId Request Type Request Body
type DnToMinIdRequestBodyType : MapiHttpRequestBodyBase
{
    uint Reserved;
    byte HasNames with DisplayInfo{ToText = BoolValueToText};
	optional [|HasNames != 0|] uint NameCount;
    optional [|HasNames != 0|] array<string> NameValues with BinaryEncoding{Length = NameCount as uint, TextEncoding = TextEncoding.ASCII};
    uint AuxiliaryBufferSize;
    optional [|AuxiliaryBufferSize > 0|] ExtendedBuffer[true] AuxiliaryBuffer with BinaryEncoding{WidthForComposedType = AuxiliaryBufferSize * 8};
}

// Section 2.2.5.4.2   DnToMinId Request Type Success Response Body
type DnToMinIdResponseSuccessBodyType : MapiHttpResponseBody
{
    invariant StatusCode == 0x0;

    uint ErrorCode;
    byte HasMinimalIds with DisplayInfo{ToText = BoolValueToText};
    uint MinimalIdCount;
    optional [|HasMinimalIds != 0|] array<MinEntryID> MinimalIds with BinaryEncoding{Length = MinimalIdCount};
    uint AuxiliaryBufferSize;
    optional [|AuxiliaryBufferSize > 0|] ExtendedBuffer[true] AuxiliaryBuffer with BinaryEncoding{WidthForComposedType = AuxiliaryBufferSize * 8};
}

// Section 2.2.5.4.3   DnToMinId Request Type Failure Response Body
type DnToMinIdResponseFailureBodyType : MapiHttpResponseBody
{
    invariant StatusCode != 0x0;

    uint AuxiliaryBufferSize;
    optional [|AuxiliaryBufferSize > 0|] ExtendedBuffer[true] AuxiliaryBuffer with BinaryEncoding{WidthForComposedType = AuxiliaryBufferSize * 8};
}

pattern DnToMinIdResponseBodyType = DnToMinIdResponseFailureBodyType | DnToMinIdResponseSuccessBodyType;

// ==============================2.2.5.5   GetMatches Request Type==============================
// Section 2.2.5.5.1   GetMatches Request Type Request Body
type GetMatchesRequestBodyType : MapiHttpRequestBodyBase
{
    uint Reserved;
    byte HasState with DisplayInfo{ToText = BoolValueToText};
    optional [|HasState != 0|] STAT State;
    byte HasMinimalIds with DisplayInfo{ToText = BoolValueToText};
    optional [|HasMinimalIds != 0|] uint MinimalIdCount;
    optional [|HasMinimalIds != 0|] array<MinEntryID> MinimalIds with BinaryEncoding{Length = MinimalIdCount as uint};
    uint InterfaceOptionFlags;
    byte HasFilter with DisplayInfo{ToText = BoolValueToText};
    optional [|HasFilter != 0|] Restriction Filter;
    byte HasPropertyName with DisplayInfo{ToText = BoolValueToText};
    optional [|HasPropertyName != 0|] GUID PropertyNameGuid;
    optional [|HasPropertyName != 0|] uint PropertyNameId;
    uint RowCount;
    byte HasColumns with DisplayInfo{ToText = BoolValueToText};
    optional [|HasColumns != 0|] LargePropertyTagArray Columns;
    uint AuxiliaryBufferSize;
    optional [|AuxiliaryBufferSize > 0|] ExtendedBuffer[true] AuxiliaryBuffer with BinaryEncoding{WidthForComposedType = AuxiliaryBufferSize * 8};
}

// Section 2.2.5.5.2   GetMatches Request Type Success Response Body
type GetMatchesResponseSuccessBodyType : MapiHttpResponseBody
{
    invariant StatusCode == 0x0;

    uint ErrorCode;
    byte HasState with DisplayInfo{ToText = BoolValueToText};
    optional [|HasState != 0|] STAT State;
    byte HasMinimalIds with DisplayInfo{ToText = BoolValueToText};
    optional [|HasMinimalIds != 0|] uint MinimalIdCount;
    optional [|HasMinimalIds != 0|] array<MinEntryID> MinimalIds with BinaryEncoding{Length = MinimalIdCount as uint};
    byte HasColsAndRows with DisplayInfo{ToText = BoolValueToText};
    optional [|HasColsAndRows != 0|] LargePropertyTagArray Columns;
    optional [|HasColsAndRows != 0|] uint RowCount;
    optional [|HasColsAndRows != 0|] array<AddressBookPropertyRow[Columns, MapiVariableCountSize]> RowData with BinaryEncoding{Length = RowCount as uint};
    uint AuxiliaryBufferSize;
    optional [|AuxiliaryBufferSize > 0|] ExtendedBuffer[true] AuxiliaryBuffer with BinaryEncoding{WidthForComposedType = AuxiliaryBufferSize * 8};
}

// Section 2.2.5.5.3   GetMatches Request Type Failure Response Body
type GetMatchesResponseFailureBodyType : MapiHttpResponseBody
{
    invariant StatusCode != 0x0;

    uint AuxiliaryBufferSize;
    optional [|AuxiliaryBufferSize > 0|] ExtendedBuffer[true] AuxiliaryBuffer with BinaryEncoding{WidthForComposedType = AuxiliaryBufferSize * 8};
}

pattern GetMatchesResponseBodyType = GetMatchesResponseFailureBodyType | GetMatchesResponseSuccessBodyType;

// ==============================2.2.5.6   GetPropList Request Type==============================
// Section 2.2.5.6.1   GetPropList Request Type Request Body
type GetPropListRequestBodyType : MapiHttpRequestBodyBase
{
    uint Flags;
    MinEntryID MinimalId;
    uint CodePage;
    uint AuxiliaryBufferSize;
    optional [|AuxiliaryBufferSize > 0|] ExtendedBuffer[true] AuxiliaryBuffer with BinaryEncoding{WidthForComposedType = AuxiliaryBufferSize * 8};
}

// Section 2.2.5.6.2   GetPropList Request Type Success Response Body
type GetPropListResponseSuccessBodyType : MapiHttpResponseBody
{
    invariant StatusCode == 0x0;

    uint ErrorCode;
    byte HasPropertyTags with DisplayInfo{ToText = BoolValueToText};
    optional [|HasPropertyTags != 0|] LargePropertyTagArray PropertyTags;
    uint AuxiliaryBufferSize;
    optional [|AuxiliaryBufferSize > 0|] ExtendedBuffer[true] AuxiliaryBuffer with BinaryEncoding{WidthForComposedType = AuxiliaryBufferSize * 8};
}

// Section 2.2.5.6.3   GetPropList Request Type Failure Response Body
type GetPropListResponseFailureBodyType : MapiHttpResponseBody
{
    invariant StatusCode != 0x0;

    uint AuxiliaryBufferSize;
    optional [|AuxiliaryBufferSize > 0|] ExtendedBuffer[true] AuxiliaryBuffer with BinaryEncoding{WidthForComposedType = AuxiliaryBufferSize * 8};
}

pattern GetPropListResponseBodyType = GetPropListResponseFailureBodyType | GetPropListResponseSuccessBodyType;

// ==============================2.2.5.7   GetProps Request Type==============================
// Section 2.2.5.7.1   GetProps Request Type Request Body
type GetPropsRequestBodyType : MapiHttpRequestBodyBase
{
    uint Flags;
    byte HasState with DisplayInfo{ToText = BoolValueToText};
    optional [|HasState != 0|] STAT State;
    byte HasPropertyTags with DisplayInfo{ToText = BoolValueToText};
    optional [|HasPropertyTags != 0|] LargePropertyTagArray PropertyTags;
    uint AuxiliaryBufferSize;
    optional [|AuxiliaryBufferSize > 0|] ExtendedBuffer[true] AuxiliaryBuffer with BinaryEncoding{WidthForComposedType = AuxiliaryBufferSize * 8};
}

// Section 2.2.5.7.2   GetProps Request Type Success Response Body
type GetPropsResponseSuccessBodyType : MapiHttpResponseBody
{
    invariant StatusCode == 0x0;

    uint ErrorCode;
    uint CodePage;
    byte HasPropertyValues with DisplayInfo{ToText = BoolValueToText};
    optional [|HasPropertyValues != 0|] AddressBookPropertyValueList[MapiVariableCountSize] PropertyValues;
    uint AuxiliaryBufferSize;
    optional [|AuxiliaryBufferSize > 0|] ExtendedBuffer[true] AuxiliaryBuffer with BinaryEncoding{WidthForComposedType = AuxiliaryBufferSize * 8};
}

// Section 2.2.5.7.3   GetProps Request Type Failure Response Body
type GetPropsResponseFailureBodyType : MapiHttpResponseBody
{
    invariant StatusCode != 0x0;

    uint AuxiliaryBufferSize;
    optional [|AuxiliaryBufferSize > 0|] ExtendedBuffer[true] AuxiliaryBuffer with BinaryEncoding{WidthForComposedType = AuxiliaryBufferSize * 8};
}

pattern GetPropsResponseBodyType = GetPropsResponseFailureBodyType | GetPropsResponseSuccessBodyType;

// ==============================2.2.5.8   GetSpecialTable Request Type==============================
// Section 2.2.5.8.1   GetSpecialTable Request Type Request Body
type GetSpecialTableRequestBodyType : MapiHttpRequestBodyBase
{
    uint Flags;
    byte HasState with DisplayInfo{ToText = BoolValueToText};
    optional [|HasState != 0|] STAT State;
    byte HasVersion with DisplayInfo{ToText = BoolValueToText};
    optional [|HasVersion != 0|] uint Version;
    uint AuxiliaryBufferSize;
    optional [|AuxiliaryBufferSize > 0|] ExtendedBuffer[true] AuxiliaryBuffer with BinaryEncoding{WidthForComposedType = AuxiliaryBufferSize * 8};
}

// Section 2.2.5.8.2   GetSpecialTable Request Type Success Response Body
type GetSpecialTableResponseSuccessBodyType : MapiHttpResponseBody
{
    invariant StatusCode == 0x0;

    uint ErrorCode;
    uint CodePage;
    byte HasVersion with DisplayInfo{ToText = BoolValueToText};
    optional [|HasVersion != 0|] uint Version;
    byte HasRows with DisplayInfo{ToText = BoolValueToText};
    optional [|HasRows != 0|] uint RowsCount;
    optional [|HasRows != 0|] array<AddressBookPropertyValueList[MapiVariableCountSize]> Rows with BinaryEncoding{Length = RowsCount as uint};
    uint AuxiliaryBufferSize;
    optional [|AuxiliaryBufferSize > 0|] ExtendedBuffer[true] AuxiliaryBuffer with BinaryEncoding{WidthForComposedType = AuxiliaryBufferSize * 8};
}

// Section 2.2.5.8.3   GetSpecialTable Request Type Failure Response Body
type GetSpecialTableResponseFailureBodyType : MapiHttpResponseBody
{
    invariant StatusCode != 0x0;

    uint AuxiliaryBufferSize;
    optional [|AuxiliaryBufferSize > 0|] ExtendedBuffer[true] AuxiliaryBuffer with BinaryEncoding{WidthForComposedType = AuxiliaryBufferSize * 8};
}

pattern GetSpecialTableResponseBodyType = GetSpecialTableResponseFailureBodyType | GetSpecialTableResponseSuccessBodyType;

// ==============================2.2.5.9   GetTemplateInfo Request Type==============================
// Section 2.2.5.9.1   GetTemplateInfo Request Type Request Body
type GetTemplateInfoRequestBodyType : MapiHttpRequestBodyBase
{
    uint Flags;
    uint DisplayType;
    byte HasTemplateDn with DisplayInfo{ToText = BoolValueToText};
    optional [|HasTemplateDn != 0|] string TemplateDn with BinaryEncoding{TextEncoding = TextEncoding.ASCII};
    uint CodePage;
    uint LocaleId;
    uint AuxiliaryBufferSize;
    optional [|AuxiliaryBufferSize > 0|] ExtendedBuffer[true] AuxiliaryBuffer with BinaryEncoding{WidthForComposedType = AuxiliaryBufferSize * 8};
}

// Section 2.2.5.9.2   GetTemplateInfo Request Type Success Response Body
type GetTemplateInfoResponseSuccessBodyType : MapiHttpResponseBody
{
    invariant StatusCode == 0x0;

    uint ErrorCode;
    uint CodePage;
    byte HasRow with DisplayInfo{ToText = BoolValueToText};
    optional [|HasRow != 0|] AddressBookPropertyValueList[MapiVariableCountSize] Row;
    uint AuxiliaryBufferSize;
    optional [|AuxiliaryBufferSize > 0|] ExtendedBuffer[true] AuxiliaryBuffer with BinaryEncoding{WidthForComposedType = AuxiliaryBufferSize * 8};
}

// Section 2.2.5.9.3   GetTemplateInfo Request Type Failure Response Body
type GetTemplateInfoResponseFailureBodyType : MapiHttpResponseBody
{
    invariant StatusCode != 0x0;

    uint AuxiliaryBufferSize;
    optional [|AuxiliaryBufferSize > 0|] ExtendedBuffer[true] AuxiliaryBuffer with BinaryEncoding{WidthForComposedType = AuxiliaryBufferSize * 8};
}

pattern GetTemplateInfoResponseBodyType = GetTemplateInfoResponseFailureBodyType | GetTemplateInfoResponseSuccessBodyType;

// ==============================2.2.5.10   ModLinkAtt Request Type==============================
// Section 2.2.5.10.1   ModLinkAtt Request Type Request Body
type ModLinkAttRequestBodyType : MapiHttpRequestBodyBase
{
    uint Flags;
    PropertyTag PropertyTag;
    MinEntryID MinimalId;
    byte HasEntryIds with DisplayInfo{ToText = BoolValueToText};
    optional [|HasEntryIds != 0|] uint EntryIdCount;
    optional [|HasEntryIds != 0|] array<([|CurrentByte(stream) == 0x87|] EphemeralEntryID |
                                         [|CurrentByte(stream) == 0x00|] PermanentEntryID)> EntryIds
                                         with BinaryEncoding{Length = EntryIdCount as uint};
    uint AuxiliaryBufferSize;
    optional [|AuxiliaryBufferSize > 0|] ExtendedBuffer[true] AuxiliaryBuffer with BinaryEncoding{WidthForComposedType = AuxiliaryBufferSize * 8};
}

// Section 2.2.5.10.2   ModLinkAtt Request Type Success Response Body
type ModLinkAttResponseSuccessBodyType : MapiHttpResponseBody
{
    invariant StatusCode == 0x0;

    uint ErrorCode;
    uint AuxiliaryBufferSize;
    optional [|AuxiliaryBufferSize > 0|] ExtendedBuffer[true] AuxiliaryBuffer with BinaryEncoding{WidthForComposedType = AuxiliaryBufferSize * 8};
}

// Section 2.2.5.10.3   ModLinkAtt Request Type Failure Response Body
type ModLinkAttResponseFailureBodyType : MapiHttpResponseBody
{
    invariant StatusCode != 0x0;

    uint AuxiliaryBufferSize;
    optional [|AuxiliaryBufferSize > 0|] ExtendedBuffer[true] AuxiliaryBuffer with BinaryEncoding{WidthForComposedType = AuxiliaryBufferSize * 8};
}

pattern ModLinkAttResponseBodyType = ModLinkAttResponseFailureBodyType | ModLinkAttResponseSuccessBodyType;

// ==============================2.2.5.11   ModProps Request Type==============================
// Section 2.2.5.11.1   ModProps Request Type Request Body
type ModPropsRequestBodyType : MapiHttpRequestBodyBase
{
    uint Reserved;
    byte HasState with DisplayInfo{ToText = BoolValueToText};
    optional [|HasState != 0|] STAT State;
    byte HasPropertyTags with DisplayInfo{ToText = BoolValueToText};
    optional [|HasPropertyTags != 0|] LargePropertyTagArray PropertiesTags;
    byte HasPropertyValues with DisplayInfo{ToText = BoolValueToText};
    optional [|HasPropertyValues != 0|] AddressBookPropertyValueList PropertyValues;
    uint AuxiliaryBufferSize;
    optional [|AuxiliaryBufferSize > 0|] ExtendedBuffer[true] AuxiliaryBuffer with BinaryEncoding{WidthForComposedType = AuxiliaryBufferSize * 8};
}

// Section 2.2.5.11.2   ModProps Request Type Success Response Body
type ModPropsResponseSuccessBodyType : MapiHttpResponseBody
{
    invariant StatusCode == 0x0;

    uint ErrorCode;
    uint AuxiliaryBufferSize;
    optional [|AuxiliaryBufferSize > 0|] ExtendedBuffer[true] AuxiliaryBuffer with BinaryEncoding{WidthForComposedType = AuxiliaryBufferSize * 8};
}

// Section 2.2.5.11.3   ModProps Request Type Failure Response Body
type ModPropsResponseFailureBodyType : MapiHttpResponseBody
{
    invariant StatusCode != 0x0;

    uint AuxiliaryBufferSize;
    optional [|AuxiliaryBufferSize > 0|] ExtendedBuffer[true] AuxiliaryBuffer with BinaryEncoding{WidthForComposedType = AuxiliaryBufferSize * 8};
}

pattern ModPropsResponseBodyType = ModPropsResponseFailureBodyType | ModPropsResponseSuccessBodyType;

// ==============================2.2.5.12   QueryRows Request Type==============================
// Section 2.2.5.12.1   QueryRows Request Type Request Body
type QueryRowsRequestBodyType : MapiHttpRequestBodyBase
{
    uint Flags;
    byte HasState with DisplayInfo{ToText = BoolValueToText};
    optional [|HasState != 0|] STAT State;
    uint ExplicitTableCount;
    array<MinEntryID> ExplicitTable with BinaryEncoding{Length = ExplicitTableCount};
    uint RowCount;
    byte HasColumns with DisplayInfo{ToText = BoolValueToText};
    optional [|HasColumns != 0|] LargePropertyTagArray Columns;
    uint AuxiliaryBufferSize;
    optional [|AuxiliaryBufferSize > 0|] ExtendedBuffer[true] AuxiliaryBuffer with BinaryEncoding{WidthForComposedType = AuxiliaryBufferSize * 8};
}

// Section 2.2.5.12.2   QueryRows Request Type Success Response Body
type QueryRowsResponseSuccessBodyType : MapiHttpResponseBody
{
    invariant StatusCode == 0x0;

    uint ErrorCode;
    byte HasState with DisplayInfo{ToText = BoolValueToText};
    optional [|HasState != 0|] STAT State;
    byte HasColsAndRows with DisplayInfo{ToText = BoolValueToText};
    optional [|HasColsAndRows != 0|] LargePropertyTagArray Columns;
    optional [|HasColsAndRows != 0|] uint RowCount;
    optional [|HasColsAndRows != 0|] array<AddressBookPropertyRow[Columns, MapiVariableCountSize]> RowData with BinaryEncoding{Length = RowCount as uint};
    uint AuxiliaryBufferSize;
    optional [|AuxiliaryBufferSize > 0|] ExtendedBuffer[true] AuxiliaryBuffer with BinaryEncoding{WidthForComposedType = AuxiliaryBufferSize * 8};
}

// Section 2.2.5.12.3   QueryRows Request Type Failure Response Body
type QueryRowsResponseFailureBodyType : MapiHttpResponseBody
{
    invariant StatusCode != 0x0;

    uint AuxiliaryBufferSize;
    optional [|AuxiliaryBufferSize > 0|] ExtendedBuffer[true] AuxiliaryBuffer with BinaryEncoding{WidthForComposedType = AuxiliaryBufferSize * 8};
}

pattern QueryRowsResponseBodyType = QueryRowsResponseFailureBodyType | QueryRowsResponseSuccessBodyType;

// ==============================2.2.5.13   QueryColumns Request Type==============================
// Section 2.2.5.13.1   QueryColumns Request Type Request Body
type QueryColumnsRequestBodyType : MapiHttpRequestBodyBase
{
    uint Reserved;
    uint MapiFlags;
    uint AuxiliaryBufferSize;
    optional [|AuxiliaryBufferSize > 0|] ExtendedBuffer[true] AuxiliaryBuffer with BinaryEncoding{WidthForComposedType = AuxiliaryBufferSize * 8};
}

// Section 2.2.5.13.2   QueryColumns Request Type Success Response Body
type QueryColumnsResponseSuccessBodyType : MapiHttpResponseBody
{
    invariant StatusCode == 0x0;

    uint ErrorCode;
    byte HasColumns with DisplayInfo{ToText = BoolValueToText};
    optional [|HasColumns != 0|] LargePropertyTagArray Columns;
    uint AuxiliaryBufferSize;
    optional [|AuxiliaryBufferSize > 0|] ExtendedBuffer[true] AuxiliaryBuffer with BinaryEncoding{WidthForComposedType = AuxiliaryBufferSize * 8};
}

// Section 2.2.5.13.3   QueryColumns Request Type Failure Response Body
type QueryColumnsResponseFailureBodyType : MapiHttpResponseBody
{
    invariant StatusCode != 0x0;

    uint AuxiliaryBufferSize;
    optional [|AuxiliaryBufferSize > 0|] ExtendedBuffer[true] AuxiliaryBuffer with BinaryEncoding{WidthForComposedType = AuxiliaryBufferSize * 8};
}

pattern QueryColumnsResponseBodyType = QueryColumnsResponseFailureBodyType | QueryColumnsResponseSuccessBodyType;

// ==============================2.2.5.14   ResolveNames Request Type==============================
// Section 2.2.5.14.1   ResolveNames Request Type Request Body
type ResolveNamesRequestBodyType : MapiHttpRequestBodyBase
{
    uint Reserved;
    byte HasState with DisplayInfo{ToText = BoolValueToText};
    optional [|HasState != 0|] STAT State;
    byte HasPropertyTags with DisplayInfo{ToText = BoolValueToText};
    optional [|HasPropertyTags != 0|] LargePropertyTagArray PropertyTags;
    byte HasNames with DisplayInfo{ToText = BoolValueToText};
    optional [|HasNames != 0|] WStringArray_r Names;
    uint AuxiliaryBufferSize;
    optional [|AuxiliaryBufferSize > 0|] ExtendedBuffer[true] AuxiliaryBuffer with BinaryEncoding{WidthForComposedType = AuxiliaryBufferSize * 8};
}

// Section 2.2.5.14.2   ResolveNames Request Type Success Response Body
type ResolveNamesResponseSuccessBodyType : MapiHttpResponseBody
{
    invariant StatusCode == 0x0;

    uint ErrorCode;
    uint CodePage;
    byte HasMinimalIds with DisplayInfo{ToText = BoolValueToText};
    optional [|HasMinimalIds != 0|] uint MinimalIdCount;
    optional [|HasMinimalIds != 0|] array<MinEntryID> MinimalIds with BinaryEncoding{Length = MinimalIdCount as uint};
    byte HasRowsAndCols with DisplayInfo{ToText = BoolValueToText};
    optional [|HasRowsAndCols != 0|] LargePropertyTagArray PropertyTags;
    optional [|HasRowsAndCols != 0|] uint RowCount;
    optional [|HasRowsAndCols != 0|] array<AddressBookPropertyRow[PropertyTags, MapiVariableCountSize]> RowData with BinaryEncoding{Length = RowCount as uint};
    uint AuxiliaryBufferSize;
    optional [|AuxiliaryBufferSize > 0|] ExtendedBuffer[true] AuxiliaryBuffer with BinaryEncoding{WidthForComposedType = AuxiliaryBufferSize * 8};
}

// Section 2.2.5.14.3   ResolveNames Request Type Failure Response Body
type ResolveNamesResponseFailureBodyType : MapiHttpResponseBody
{
    invariant StatusCode != 0x0;

    uint AuxiliaryBufferSize;
    optional [|AuxiliaryBufferSize > 0|] ExtendedBuffer[true] AuxiliaryBuffer with BinaryEncoding{WidthForComposedType = AuxiliaryBufferSize * 8};
}

pattern ResolveNamesResponseBodyType = ResolveNamesResponseFailureBodyType | ResolveNamesResponseSuccessBodyType;

// ==============================2.2.5.15   ResortRestriction Request Type==============================
// Section 2.2.5.15.1   ResortRestriction Request Type Request Body
type ResortRestrictionRequestBodyType : MapiHttpRequestBodyBase
{
    uint Reserved;
    byte HasState with DisplayInfo{ToText = BoolValueToText};
    optional [|HasState != 0|] STAT State;
    byte HasMinimalIds with DisplayInfo{ToText = BoolValueToText};
    optional [|HasMinimalIds != 0|] uint MinimalIdCount;
    optional [|HasMinimalIds != 0|] array<MinEntryID> MinimalIds with BinaryEncoding{Length = MinimalIdCount as uint};
    uint AuxiliaryBufferSize;
    optional [|AuxiliaryBufferSize > 0|] ExtendedBuffer[true] AuxiliaryBuffer with BinaryEncoding{WidthForComposedType = AuxiliaryBufferSize * 8};
}

// Section 2.2.5.15.2   ResortRestriction Request Type Success Response Body
type ResortRestrictionResponseSuccessBodyType : MapiHttpResponseBody
{
    invariant StatusCode == 0x0;

    uint ErrorCode;
    byte HasState with DisplayInfo{ToText = BoolValueToText};
    optional [|HasState != 0|] STAT State;
    byte HasMinimalIds with DisplayInfo{ToText = BoolValueToText};
    optional [|HasMinimalIds != 0|] uint MinimalIdCount;
    optional [|HasMinimalIds != 0|] array<MinEntryID> MinimalIds with BinaryEncoding{Length = MinimalIdCount as uint};
    uint AuxiliaryBufferSize;
    optional [|AuxiliaryBufferSize > 0|] ExtendedBuffer[true] AuxiliaryBuffer with BinaryEncoding{WidthForComposedType = AuxiliaryBufferSize * 8};
}

// Section 2.2.5.15.3   ResortRestriction Request Type Failure Response Body
type ResortRestrictionResponseFailureBodyType : MapiHttpResponseBody
{
    invariant StatusCode != 0x0;

    uint AuxiliaryBufferSize;
    optional [|AuxiliaryBufferSize > 0|] ExtendedBuffer[true] AuxiliaryBuffer with BinaryEncoding{WidthForComposedType = AuxiliaryBufferSize * 8};
}

pattern ResortRestrictionResponseBodyType = ResortRestrictionResponseFailureBodyType | ResortRestrictionResponseSuccessBodyType;

// ==============================2.2.5.16   SeekEntries Request Type==============================
// Section 2.2.5.16.1   SeekEntries Request Type Request Body
type SeekEntriesRequestBodyType : MapiHttpRequestBodyBase
{
    uint Reserved;
    byte HasState with DisplayInfo{ToText = BoolValueToText};
    optional [|HasState != 0|] STAT State;
    byte HasTarget with DisplayInfo{ToText = BoolValueToText};
    optional [|HasTarget != 0|] AddressBookTaggedPropertyValue Target;
    byte HasExplicitTable with DisplayInfo{ToText = BoolValueToText};
    optional [|HasExplicitTable != 0|] uint ExplicitTableCount;
    optional [|HasExplicitTable != 0|] array<MinEntryID> ExplicitTable with BinaryEncoding{Length = ExplicitTableCount as uint};
    byte HasColumns with DisplayInfo{ToText = BoolValueToText};
    optional [|HasColumns != 0|] LargePropertyTagArray Columns;
    uint AuxiliaryBufferSize;
    optional [|AuxiliaryBufferSize > 0|] ExtendedBuffer[true] AuxiliaryBuffer with BinaryEncoding{WidthForComposedType = AuxiliaryBufferSize * 8};
}

// Section 2.2.5.16.2   SeekEntries Request Type Success Response Body
type SeekEntriesResponseSuccessBodyType : MapiHttpResponseBody
{
    invariant StatusCode == 0x0;

    uint ErrorCode;
    byte HasState with DisplayInfo{ToText = BoolValueToText};
    optional [|HasState != 0|] STAT State;
    byte HasColsAndRows with DisplayInfo{ToText = BoolValueToText};
    optional [|HasColsAndRows != 0|] LargePropertyTagArray Columns;
    optional [|HasColsAndRows != 0|] uint RowCount;
    optional [|HasColsAndRows != 0|] array<AddressBookPropertyRow[Columns, MapiVariableCountSize]> RowData with BinaryEncoding{Length = RowCount as uint};
    uint AuxiliaryBufferSize;
    optional [|AuxiliaryBufferSize > 0|] ExtendedBuffer[true] AuxiliaryBuffer with BinaryEncoding{WidthForComposedType = AuxiliaryBufferSize * 8};
}

// Section 2.2.5.16.3   SeekEntries Request Type Failure Response Body
type SeekEntriesResponseFailureBodyType : MapiHttpResponseBody
{
    invariant StatusCode != 0x0;

    uint AuxiliaryBufferSize;
    optional [|AuxiliaryBufferSize > 0|] ExtendedBuffer[true] AuxiliaryBuffer with BinaryEncoding{WidthForComposedType = AuxiliaryBufferSize * 8};
}

pattern SeekEntriesResponseBodyType = SeekEntriesResponseFailureBodyType | SeekEntriesResponseSuccessBodyType;

// ==============================2.2.5.17   UpdateStat Request Type==============================
// Section 2.2.5.17.1   UpdateStat Request Type Request Body
type UpdateStatRequestBodyType : MapiHttpRequestBodyBase
{
    uint Reserved;
    byte HasState with DisplayInfo{ToText = BoolValueToText};
    optional [|HasState != 0|] STAT State;
    byte DeltaRequested with DisplayInfo{ToText = BoolValueToText};
    uint AuxiliaryBufferSize;
    optional [|AuxiliaryBufferSize > 0|] ExtendedBuffer[true] AuxiliaryBuffer with BinaryEncoding{WidthForComposedType = AuxiliaryBufferSize * 8};
}

// Section 2.2.5.17.2   UpdateStat Request Type Success Response Body
type UpdateStatResponseSuccessBodyType : MapiHttpResponseBody
{
    invariant StatusCode == 0x0;

    uint ErrorCode;
    byte HasState with DisplayInfo{ToText = BoolValueToText};
    optional [|HasState != 0|] STAT State;
    byte HasDelta with DisplayInfo{ToText = BoolValueToText};
    optional [|HasDelta != 0|] int Delta;
    uint AuxiliaryBufferSize;
    optional [|AuxiliaryBufferSize > 0|] ExtendedBuffer[true] AuxiliaryBuffer with BinaryEncoding{WidthForComposedType = AuxiliaryBufferSize * 8};
}

// Section 2.2.5.17.3   UpdateStat Request Type Failure Response Body
type UpdateStatResponseFailureBodyType : MapiHttpResponseBody
{
    invariant StatusCode != 0x0;

    uint AuxiliaryBufferSize;
    optional [|AuxiliaryBufferSize > 0|] ExtendedBuffer[true] AuxiliaryBuffer with BinaryEncoding{WidthForComposedType = AuxiliaryBufferSize * 8};
}

pattern UpdateStatResponseBodyType = UpdateStatResponseFailureBodyType | UpdateStatResponseSuccessBodyType;

// ==============================2.2.5.18   GetMailboxUrl Request Type==============================
// Section 2.2.5.18.1   GetMailboxUrl Request Type Request Body
type GetMailboxUrlRequestBodyType : MapiHttpRequestBodyBase
{
    uint Flags;
    string ServerDn with BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    uint AuxiliaryBufferSize;
    optional [|AuxiliaryBufferSize > 0|] ExtendedBuffer[true] AuxiliaryBuffer with BinaryEncoding{WidthForComposedType = AuxiliaryBufferSize * 8};
}

// Section 2.2.5.18.2   GetMailboxUrl Request Type Success Response Body
type GetMailboxUrlResponseSuccessBodyType : MapiHttpResponseBody
{
    invariant StatusCode == 0x0;

    uint ErrorCode;
    string ServerUrl with BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    uint AuxiliaryBufferSize;
    optional [|AuxiliaryBufferSize > 0|] ExtendedBuffer[true] AuxiliaryBuffer with BinaryEncoding{WidthForComposedType = AuxiliaryBufferSize * 8};
}

// Section 2.2.5.18.3   GetMailboxUrl Request Type Failure Response Body
type GetMailboxUrlResponseFailureBodyType : MapiHttpResponseBody
{
    invariant StatusCode != 0x0;

    uint AuxiliaryBufferSize;
    optional [|AuxiliaryBufferSize > 0|] ExtendedBuffer[true] AuxiliaryBuffer with BinaryEncoding{WidthForComposedType = AuxiliaryBufferSize * 8};
}

pattern GetMailboxUrlResponseBodyType = GetMailboxUrlResponseFailureBodyType | GetMailboxUrlResponseSuccessBodyType;

// ==============================2.2.5.19   GetAddressBookUrl Request Type==============================
// Section 2.2.5.19.1   GetAddressBookUrl Request Type Request Body
type GetAddressBookUrlRequestBodyType : MapiHttpRequestBodyBase
{
    uint Flags;
    string UserDn with BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    uint AuxiliaryBufferSize;
    optional [|AuxiliaryBufferSize > 0|] ExtendedBuffer[true] AuxiliaryBuffer with BinaryEncoding{WidthForComposedType = AuxiliaryBufferSize * 8};
}

// Section 2.2.5.19.2   GetAddressBookUrl Request Type Success Response Body
type GetAddressBookUrlResponseSuccessBodyType : MapiHttpResponseBody
{
    invariant StatusCode == 0x0;

    uint ErrorCode;
    string ServerUrl with BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    uint AuxiliaryBufferSize;
    optional [|AuxiliaryBufferSize > 0|] ExtendedBuffer[true] AuxiliaryBuffer with BinaryEncoding{WidthForComposedType = AuxiliaryBufferSize * 8};
}

// Section 2.2.5.19.3   GetAddressBookUrl Request Type Failure Response Body
type GetAddressBookUrlResponseFailureBodyType : MapiHttpResponseBody
{
    invariant StatusCode != 0x0;

    uint AuxiliaryBufferSize;
    optional [|AuxiliaryBufferSize > 0|] ExtendedBuffer[true] AuxiliaryBuffer with BinaryEncoding{WidthForComposedType = AuxiliaryBufferSize * 8};
}

pattern GetAddressBookUrlResponseBodyType = GetAddressBookUrlResponseFailureBodyType | GetAddressBookUrlResponseSuccessBodyType;

// Section 2.2.6   PING Request Type
type PINGRequestBodyType : MapiHttpRequestBodyBase
{
}

type PINGResponseBodyType : MapiHttpResponseBodyBase
{
}

// ============================== Utility functions ==============================
bool IsOXCMAPIHTTPRequestMessage(HttpHeadersType httpHeaders)
{
    return "X-RequestType" in httpHeaders && httpHeaders["X-RequestType"] != nothing
        && "Content-Type" in httpHeaders && httpHeaders["Content-Type"] != nothing
        && (httpHeaders["Content-Type"] as string) is MapiHttpContentTypePattern;
}
pattern MapiHttpContentTypePatternI = regex {application/mapi-http};
pattern MapiHttpContentTypePatternII = regex {text/html};

bool IsOXCMAPIHTTPResponseMessage(HttpHeadersType httpHeaders)
{
    if ("Content-Type" in httpHeaders && httpHeaders["Content-Type"] != nothing && "X-ResponseCode" in httpHeaders && httpHeaders["X-ResponseCode"] != nothing)
    {
	if ( (httpHeaders["X-ResponseCode"] == "0" && (httpHeaders["Content-Type"] as string) is MapiHttpContentTypePatternI) || (httpHeaders["X-ResponseCode"] != "0" && (httpHeaders["Content-Type"] as string) is MapiHttpContentTypePatternII))
	{
	    return true;
	}
	else
	{
	    return false;
	}
    }
    else
    {
        return false;
    }
}

bool IsMailboxServerType(string requestType)
{
    if (requestType == null)
	{
	return false;
	}       
    return requestType in ["Connect", "Execute", "Disconnect", "NotificationWait"];
}

// ============================== NSPI Types ================================
// NOTE:
// The below definitions are copied from NSPI.opn but removing all the idl related aspects
// That's because MS-OXCMAPIHTTP use the BinaryDecoder as the core decoder but NSPI.opn is RPC based
// Opn which will use the NdrDecoder by default. Even we use the NdrDecoder explicitly when parsing those types
// the parse result is always fail.
//
// IN FUTURE, it may be better if we can move those duplicated definitions into MS-OXNSPI.opn
type STAT
{
    TableSortOrders SortType 
        with Encoding{Decoder = PatternDecoder<TableSortOrders>, SourcePattern = TypeOf<DWORD>()};
    DWORD ContainerID;
    PositioningMinimalEntryIDs CurrentRec 
        with Encoding{Decoder = PatternDecoder<PositioningMinimalEntryIDs>, SourcePattern = TypeOf<DWORD>()};
    IDLLong Delta;
    DWORD NumPos;
    DWORD TotalRecs;
    DWORD CodePage;
    DWORD TemplateLocale;
    DWORD SortLocale;
}

type FlatUID_r
{
    guid ab with Encoding{Decoder = BinaryDecoder<guid>, SourcePattern = TypeOf<array<BYTE>>()};
        
    override string ToString()
    {
        return ab.ToString();
    }
}

type PropertyValue_r
{
    DWORD ulPropTag;
    PROP_VAL_UNION[(ulPropTag & 0xFFFF) as IDLLong] Value;
    
    override string ToString()
    {
        return Value.ToString();
    }
}

typedef PROP_VAL_UNION = PV_r;

type PV_r[IDLLong tag]
{
    optional [|tag == 0x00000002|] short i;
    optional [|tag == 0x00000003|] IDLLong l;
    optional [|tag == 0x0000000B|] ushort b;
    optional [|tag == 0x0000001E|] String_r lpszA;
    optional [|tag == 0x00000102|] Binary_r bin;
    optional [|tag == 0x0000001F|] WString_r lpszW;
    optional [|tag == 0x00000048|] FlatUID_r lpguid;
    optional [|tag == 0x00000040|] FILETIME ft;
    optional [|tag == 0x0000000A|] IDLLong err;
    optional [|tag == 0x00001002|] ShortArray_r MVi;
    optional [|tag == 0x00001003|] LongArray_r MVl;
    optional [|tag == 0x0000101E|] StringArray_r MVszA;
    optional [|tag == 0x00001102|] BinaryArray_r MVbin;
    optional [|tag == 0x00001048|] FlatUIDArray_r MVguid;
    optional [|tag == 0x0000101F|] WStringArray_r MVszW;
    optional [|tag == 0x00001040|] DateTimeArray_r MVft;
    optional [|tag == 0x00000001 || tag == 0x0000000D|] IDLLong lReserved;
        
    override string ToString()
    {
        if (i is shortI:short)
        {
            return "i: " + (shortI as string);
        }
        else if (l is longL:IDLLong)
        {
            return "l: " + longL.ToString();
        }
        else if (b is shortB:ushort)
        {
            return "b: " + (shortB as string);
        }
        else if (lpszA is lpszAStr:String_r)
        {
            return "lpszA: " + lpszAStr.Value;
        }
        else if (bin is binaryR:Binary_r)
        {
            return "bin: " + (binaryR as string);
        }
        else if (lpszW is lpszWStr:WString_r)
        {
            return "lpszW: " + lpszWStr.Value;
        }
        else if (lpguid is lpguidValue:FlatUID_r)
        {
            return "lpguid: " + (lpguidValue as string);
        }
        else if (ft is fileTime:FILETIME)
        {
            return "ft: " + (fileTime as string);
        }
        else if (err is errValue:IDLLong)
        {
            return "err: " + DecToHexFormat(errValue);
        }
        else if (MVi is mvi:ShortArray_r)
        {
            return "MVi: " + (mvi as string);
        }
        else if (MVl is mvl:LongArray_r)
        {
            return "MVl: " + (mvl as string);
        }
        else if (MVszA is mvsza:StringArray_r)
        {
            return "MVszA: " + (mvsza as string);
        }
        else if (MVbin is mvbin:BinaryArray_r)
        {
            return "MVbin: " + (mvbin as string);
        }
        else if (MVguid is mvguid:FlatUIDArray_r)
        {
            return "MVguid: " + (mvguid as string);
        }
        else if (MVszW is mvszw:WStringArray_r)
        {
            return "MVszW: " + (mvszw as string);
        }
        else if (MVft is mvft:DateTimeArray_r)
        {
            return "MVft: " + (mvft as string);
        }
        else if (lReserved is reserved:IDLLong)
        {
            return "lReserved: " + (reserved as string);
        }
        
        return "";
    }
}

type String_r
{
    optional [|CurrentByte(stream) == 0xFF|] byte MagicNumber;
    string Value with BinaryEncoding{TextEncoding = TextEncoding.ASCII};
}

type WString_r
{
    optional [|CurrentByte(stream) == 0xFF|] byte MagicNumber;
    string Value with BinaryEncoding{TextEncoding = TextEncoding.Unicode};
}

type Binary_r
{
    optional [|CurrentByte(stream) == 0xFF|] byte MagicNumber;
    DWORD cb;
    array<BYTE> lpb with BinaryEncoding{Length = cb};
}

type ShortArray_r
{
    DWORD cValues;
    array<short> lpi with BinaryEncoding{Length = cValues};
}

type LongArray_r
{
    DWORD cValues;
    array<IDLLong> lpl with BinaryEncoding{Length = cValues};
}

type StringArray_r
{
    optional [|CurrentByte(stream) == 0xFF|] byte MagicNumber;
    DWORD cValues;
    array<string> lppszA with BinaryEncoding{Length = cValues, TextEncoding = TextEncoding.ASCII};
}

type BinaryArray_r
{
    optional [|CurrentByte(stream) == 0xFF|] byte MagicNumber;
    DWORD cValues;
    array<Binary_r> lpbin with BinaryEncoding{Length = cValues};
}

type FlatUIDArray_r
{
    DWORD cValues;
    array<FlatUID_r> lpguid with BinaryEncoding{Length = cValues};
}

type WStringArray_r
{
    optional [|CurrentByte(stream) == 0xFF|] byte MagicNumber;
    DWORD cValues;
    array<string> lppszW with BinaryEncoding{Length = cValues, TextEncoding = TextEncoding.Unicode};
}

type DateTimeArray_r
{
    DWORD cValues;
    array<FILETIME> lpft with BinaryEncoding{Length = cValues};
}

typedef StringsArray_r = StringsArray;

type StringsArray
{
    optional [|CurrentByte(stream) == 0xFF|] byte MagicNumber;
    DWORD Count;
    array<string> Strings with BinaryEncoding{Length = Count, TextEncoding = TextEncoding.ASCII};
}

typedef WStringsArray_r = WStringsArray;

type WStringsArray
{
    optional [|CurrentByte(stream) == 0xFF|] byte MagicNumber;
    DWORD Count;
    array<string> Strings with BinaryEncoding{Length = Count, TextEncoding = TextEncoding.Unicode};
}

// --------------------- patterns for display values --------------------
// 2.2.3. Display Type Values
pattern DisplayTypeValues = enum uint
{
    DT_MAILUSER = 0x00000000,
    DT_DISTLIST = 0x00000001,
    DT_FORUM = 0x00000002,
    DT_AGENT = 0x00000003,
    DT_ORGANIZATION = 0x00000004,
    DT_PRIVATE_DISTLIST = 0x00000005,
    DT_REMOTE_MAILUSER = 0x00000006,
    DT_CONTAINER = 0x00000100,
    DT_TEMPLATE = 0x00000101,
    DT_ADDRESS_TEMPLATE = 0x00000102,
    DT_SEARCH = 0x00000200,
    ...
};

// 2.2.8   Positioning Minimal Entry IDs
pattern PositioningMinimalEntryIDs = enum DWORD
{
    MID_BEGINNING_OF_TABLE = 0x00000000,
    MID_END_OF_TABLE = 0x00000002,
    MID_CURRENT = 0x00000001,
    ...
};

// 2.2.10   Table Sort Order
pattern TableSortOrders = enum DWORD
{
    SortTypeDisplayName = 0x00000000, 
    SortTypePhoneticDisplayName = 0x00000003,
    SortTypeDisplayName_RO = 0x000003E8,
    SortTypeDisplayName_W = 0x000003E9,
    ...
};

// --------------------- Binary Structure ----------------------
// 2.3.8.1 MinimalEntryID
typedef MinEntryID = DWORD;

// 2.3.8.2   EphemeralEntryID
type EphemeralEntryID
{
    byte Type;
    byte R1;
    byte R2;
    byte R3;
    guid ProviderUID;
    uint R4;
    DisplayTypeValues DisplayType;
    MinEntryID Mid;
}

// 2.3.8.3   PermanentEntryID
type PermanentEntryID
{
    byte IDType;
    byte R1;
    byte R2;
    byte R3;
    guid ProviderUID;
    uint R4;
    DisplayTypeValues DisplayTypeString;
    string DN with BinaryEncoding{TextEncoding = TextEncoding.ASCII};
}

// ============================== MS-OXCDATA Types ================================
// NOTE:
// The below definitions are copied from MS-OXCDATA.opn but all prefixed with 'Mapi'
// That's because the TDI#76879 will break the original parsing process.
// TDI#76879 tell us the real MapiHttp traffic will add the magic byte 'FF' for the string or binary based 
// property value. The workaround intends to ignore this byte to make the parsing successfully.
//

// NOTE:
// In general, if it's string or binary based property and also it's from response data, then size should be 4.
// Otherwise, it's 2. Unfortunately, we can't find the accurate description from TD [MS-OXCMAPIHTTP] or other
// Exchange RPC related protocols.
optional uint MapiVariableCountSize = 4;

// Section 2.11.2.1   PropertyValue Structure
type MapiPropertyValue[ushort dataType, optional uint ptypMultiCountSize]
{
   ([|ConvertToPropType(dataType) == PropertyDataType.PtypInteger16|]            PtypInteger16     |
    [|ConvertToPropType(dataType) == PropertyDataType.PtypInteger32|]            PtypInteger32     |
    [|ConvertToPropType(dataType) == PropertyDataType.PtypFloating32|]           PtypFloating32    |
    [|ConvertToPropType(dataType) == PropertyDataType.PtypFloating64|]           PtypFloating64    |
    [|ConvertToPropType(dataType) == PropertyDataType.PtypCurrency|]             PtypCurrency      |
    [|ConvertToPropType(dataType) == PropertyDataType.PtypFloatingTime|]         PtypFloatingTime  |
    [|ConvertToPropType(dataType) == PropertyDataType.PtypErrorCode|]            PtypErrorCode     |
    [|ConvertToPropType(dataType) == PropertyDataType.PtypBoolean|]              PtypBoolean       |
    [|ConvertToPropType(dataType) == PropertyDataType.PtypInteger64|]            PtypInteger64     |
    [|ConvertToPropType(dataType) == PropertyDataType.PtypString|]               MapiPtypString    |
    [|ConvertToPropType(dataType) == PropertyDataType.PtypString8|]              MapiPtypString8   |
    [|ConvertToPropType(dataType) == PropertyDataType.PtypTime|]                 PtypTime          |
    [|ConvertToPropType(dataType) == PropertyDataType.PtypGuid|]                 PtypGuid          |
    [|ConvertToPropType(dataType) == PropertyDataType.PtypServerId|]             PtypServerId      |
    [|ConvertToPropType(dataType) == PropertyDataType.PtypRestriction|]          PtypRestriction   |
    [|ConvertToPropType(dataType) == PropertyDataType.PtypRuleAction|]           PtypRuleAction    |
    [|ConvertToPropType(dataType) == PropertyDataType.PtypUnspecified|]          PtypUnspecified   |
    [|ConvertToPropType(dataType) == PropertyDataType.PtypNull|]                 PtypNull          |
    [|ConvertToPropType(dataType) == PropertyDataType.PtypBinary|]               MapiPtypBinary[ptypMultiCountSize]          |
    [|ConvertToPropType(dataType) == PropertyDataType.PtypMultipleInteger16|]    PtypMultipleInteger16[2]                    |
    [|ConvertToPropType(dataType) == PropertyDataType.PtypMultipleInteger32|]    PtypMultipleInteger32[2]                    |
    [|ConvertToPropType(dataType) == PropertyDataType.PtypMultipleFloating32|]   PtypMultipleFloating32[2]                   |
    [|ConvertToPropType(dataType) == PropertyDataType.PtypMultipleFloating64|]   PtypMultipleFloating64[2]                   |
    [|ConvertToPropType(dataType) == PropertyDataType.PtypMultipleCurrency|]     PtypMultipleCurrency[2]                     |
    [|ConvertToPropType(dataType) == PropertyDataType.PtypMultipleFloatingTime|] PtypMultipleFloatingTime[2]                 |
    [|ConvertToPropType(dataType) == PropertyDataType.PtypMultipleInteger64|]    PtypMultipleInteger64[2]                    |
    [|ConvertToPropType(dataType) == PropertyDataType.PtypMultipleString|]       MapiPtypMultiString[ptypMultiCountSize]     |
    [|ConvertToPropType(dataType) == PropertyDataType.PtypMultipleString8|]      MapiPtypMultiString8[ptypMultiCountSize]    |
    [|ConvertToPropType(dataType) == PropertyDataType.PtypMultipleTime|]         PtypMultipleTime[2]                         |
    [|ConvertToPropType(dataType) == PropertyDataType.PtypMultipleGuid|]         PtypMultipleGuid[2]                         |
    [|ConvertToPropType(dataType) == PropertyDataType.PtypMultipleBinary|]       MapiPtypMultiBinary[ptypMultiCountSize]     |
    [|ConvertToPropType(dataType) == PropertyDataType.PtypObject_Or_PtypEmbeddedTable|] PtypObject_Or_PtypEmbeddedTable) Value;

    string Type with Encoding{Ignore = true} = PropTypeValueToText(dataType);
    optional string ID with Encoding{Ignore = true};
}

type MapiPtypString
{
    optional [|CurrentByte(stream) == 0xFF|] byte MagicNumber;
    string Value with BinaryEncoding{TextEncoding= TextEncoding.Unicode};
}

type MapiPtypMultiBase[optional uint countSize]
{
    optional [|CurrentByte(stream) == 0xFF|] byte Reserved;
    ([|countSize == nothing|] ushort |
     [|countSize as uint == 2|] ushort |
     [|countSize as uint == 4|] uint) count;
}

uint get Count(this MapiPtypMultiBase ptypMulti)
{
    if (ptypMulti.count is us:ushort)
	{
        return us as uint;
	}
    if (ptypMulti.count is ui:uint)
	{
        return ui;  
	}
    return 0;
}
  
type MapiPtypString8
{
    optional [|CurrentByte(stream) == 0xFF|] byte MagicNumber;
    string Value with BinaryEncoding{TextEncoding= TextEncoding.ASCII};
}

type MapiPtypMultiString : MapiPtypMultiBase
{
    array<MapiPtypString> Values with BinaryEncoding{Length = this.Count};
}

type MapiPtypMultiString8 : MapiPtypMultiBase
{
    array<MapiPtypString8> Values with BinaryEncoding{Length = this.Count};
}

type MapiPtypBinary : MapiPtypMultiBase
{
    array<byte> Values with BinaryEncoding{Length = this.Count};
}

type MapiPtypMultiBinary : MapiPtypMultiBase
{
    optional [|CurrentByte(stream) == 0xFF|] byte MagicNumber;
    array<MapiPtypBinary[countSize]> Values with BinaryEncoding{Length = this.Count};
}

// Section 2.11.3   TypedPropertyValue Structure
type MapiTypedPropertyValue[optional uint ptypMultiCountSize]
{
    ushort PropertyType with DisplayInfo{ToText = PropTypeValueToText};
    MapiPropertyValue[PropertyType, ptypMultiCountSize] PropertyValue;
    optional string ID with Encoding{Ignore = true};
}

// Section 2.11.4   TaggedPropertyValue Structure
type MapiTaggedPropertyValue[optional uint ptypMultiCountSize]
{
   PropertyTag PropertyTag;
   MapiPropertyValue[PropertyTag.PropertyType, ptypMultiCountSize] PropertyValue;
}

// Section  2.11.5   FlaggedPropertyValue Structure
type MapiFlaggedPropertyValue[ushort dataType, optional uint ptypMultiCountSize]
{
    byte Flag;
    optional [|Flag != 0x1|] ([|Flag == 0x0|] MapiPropertyValue[dataType, ptypMultiCountSize] |
                              [|Flag == 0xA|] MapiPropertyValue[PropertyDataType.PtypErrorCode, ptypMultiCountSize]) PropertyValue;
    
    optional string ID with Encoding{Ignore = true};
}

// Section 2.11.6   FlaggedPropertyValueWithType Structure
type MapiFlaggedPropertyValueWithType[optional uint ptypMultiCountSize]
{
    ushort PropertyType with DisplayInfo{ToText = PropTypeValueToText};
    byte Flag;
    optional [|Flag != 0x1|] ([|Flag == 0x0|] MapiPropertyValue[PropertyType, ptypMultiCountSize] |
                              [|Flag == 0xA|] MapiPropertyValue[PropertyDataType.PtypErrorCode, ptypMultiCountSize]) PropertyValue;
    optional string ID with Encoding{Ignore = true};
}

string BoolValueToText(any data)
{
    return (data as byte) != 0x00? "TRUE" : "FALSE";
}

// This is a work around method to avoid "Parser Error" issue. Moreover, this part will be updated once TDI#76879.
string HasValueBoolValueToText(any data)
{
    return data.ToString() != "0"? "TRUE" : "FALSE";
}
