protocol LSA with 
Documentation
{
    ProtocolName = "Local Security Authority",
    ProtocolType = "rpc",
    ShortName = "LSA",
    Description = ""
},
OPNAuthoring
{
    Copyright = "(c) Microsoft Corporation",
    References = 
    [
        new Reference{Name = "MS-LSAT", Version = "29.0", Date = "09/15/2017", ProgramName = ProgramName.WSPP},
        new Reference{Name = "MS-LSAD", Version = "40.0", Date = "06/01/2017", ProgramName = ProgramName.WSPP}
    ],
    RevisionSummary = 
    [
        new Revision{Class = RevisionClass.Major, Version = "379846", Date = "07/22/2015"}
    ]
};

using Technologies.IDL;
using DTYP;
using ERREF;
using MSRPCE;
using Utility;
using IdentityAndSecurityResources;
using GPEF;

endpoint LsarpcService over MSRPCE.Server provides lsarpc;

contract lsarpc
{
    accepts operation LsarClose
    {
        in out LSAPR_HANDLE ObjectHandle with IDL{IndirectionLevel = 1};
        result DTYP.NTSTATUS ReturnValue;
        
        override string ToString()
        {
            return "LsarClose, ReturnValue: " + NtStatusValuesToText(ReturnValue);
        }
    }
    with IDL{Opnum = 0};
    
    accepts operation Opnum1NotUsedOnWire
    {
        override string ToString()
        { 
            return "Opnum1NotUsedOnWire";
        } 
    } 
    with IDL{Opnum = 1};
    
    accepts operation LsarEnumeratePrivileges
    {
        in LSAPR_HANDLE PolicyHandle;
        in out IDLUlong EnumerationContext with IDL{IndirectionLevel = 1};
        out PLSAPR_PRIVILEGE_ENUM_BUFFER EnumerationBuffer;
        in IDLUlong PreferedMaximumLength;
        result DTYP.NTSTATUS ReturnValue;
        
        override string ToString()
        {
            return "LsarEnumeratePrivileges, ReturnValue: " + ReturnValue.ToString() + 
                ", EnumerationContext: " + EnumerationContext.ToString() + 
                ", PreferedMaximumLength: " + PreferedMaximumLength.ToString() + 
                ", Count of Privileges: " + EnumerationBuffer.Entries.ToString();
        }
    }
    with IDL{Opnum = 2};
    
    accepts operation LsarQuerySecurityObject
    {
        in LSAPR_HANDLE ObjectHandle;
        in SecurityInformationPattern SecurityInformation
            where ValidationCheckCombinationValue(InRange<SecurityInformationPattern>(value), this, true, ReferenceType.Message,
                "LSA", "SecurityInformation", "LsarQuerySecurityObject", "0x00000001, 0x00000002, 0x00000004, 0x00000008", value)
            with Encoding{Decoder = PatternDecoder<SecurityInformationPattern>, SourcePattern = TypeOf<SECURITY_INFORMATION>()};
        out PLSAPR_SR_SECURITY_DESCRIPTOR SecurityDescriptor with IDL{IndirectionLevel = 1};
        result DTYP.NTSTATUS ReturnValue;
        
        override string ToString()
        {
            return "LsarQuerySecurityObject, ReturnValue: " + NtStatusValuesToText(ReturnValue) + 
                ", SecurityInformation: " + EnumToString(SecurityInformation, "LSA.SecurityInformationPattern");
        }
    }
    with IDL{Opnum = 3};
    
    accepts operation LsarSetSecurityObject
    {
        in LSAPR_HANDLE ObjectHandle;
        in SecurityInformationPattern SecurityInformation
            where ValidationCheckCombinationValue(InRange<SecurityInformationPattern>(value), this, true, ReferenceType.Message,
                "LSA", "SecurityInformation", "LsarSetSecurityObject", "0x00000001, 0x00000002, 0x00000004, 0x00000008", value)
            with Encoding{Decoder = PatternDecoder<SecurityInformationPattern>, SourcePattern = TypeOf<SECURITY_INFORMATION>()};
        in PLSAPR_SR_SECURITY_DESCRIPTOR SecurityDescriptor;
        result DTYP.NTSTATUS ReturnValue;
        
        override string ToString()
        {
            return "LsarSetSecurityObject, ReturnValue: " + NtStatusValuesToText(ReturnValue) + 
                ", SecurityInformation: " + EnumToString(SecurityInformation, "LSA.SecurityInformationPattern");
        }
    }
    with IDL{Opnum = 4};
    
    accepts operation Opnum5NotUsedOnWire
    { 
        override string ToString()
        { 
            return "Opnum5NotUsedOnWire";
        } 
    } 
    with IDL{Opnum = 5};
    
    accepts operation LsarOpenPolicy
    {
        in wchar_t SystemName with IDL{PointerType = PointerKind.UniquePtr, IndirectionLevel = 1};
        in PLSAPR_OBJECT_ATTRIBUTES ObjectAttributes;
        in AccessMaskForPolicyObjects DesiredAccess 
            where ValidationCheckCombinationValueTooManyItems(InRange<AccessMaskForPolicyObjects>(value), this, true, ReferenceType.Message,
                    "LSA", "DesiredAccess", "LsarOpenPolicy", "ACCESS_MASK for Policy Objects", "[MS-LSAD]")
            with Encoding{Decoder = PatternDecoder<AccessMaskForPolicyObjects>, SourcePattern = TypeOf<ACCESS_MASK>()};
        out LSAPR_HANDLE PolicyHandle with IDL{IndirectionLevel = 1};
        result DTYP.NTSTATUS ReturnValue;
        
        override string ToString()
        {
            return "LsarOpenPolicy, ReturnValue: " + NtStatusValuesToText(ReturnValue) + 
                ", DesiredAccess: " + EnumToString(DesiredAccess, "LSA.AccessMaskForPolicyObjects");
        }
    }
    with IDL{Opnum = 6};
    
    accepts operation LsarQueryInformationPolicy
    {
        in LSAPR_HANDLE PolicyHandle;
        in POLICY_INFORMATION_CLASS InformationClass;
        out PLSAPR_POLICY_INFORMATION[InformationClass] PolicyInformation
                with IDL{Switch_Is = InformationClass, IndirectionLevel = 1};
        result DTYP.NTSTATUS ReturnValue;
        
        override string ToString()
        {
            return "LsarQueryInformationPolicy, ReturnValue: " + NtStatusValuesToText(ReturnValue) + 
                ", InformationClass: " + EnumToString(InformationClass, "LSA.POLICY_INFORMATION_CLASS");
        }
    }
    with IDL{Opnum = 7};
    
    accepts operation LsarSetInformationPolicy
    {
        in LSAPR_HANDLE PolicyHandle;
        in POLICY_INFORMATION_CLASS InformationClass;
        in LSAPR_POLICY_INFORMATION[InformationClass] PolicyInformation
               with IDL{Switch_Is = InformationClass, IndirectionLevel = 1};
        result DTYP.NTSTATUS ReturnValue;
        
        override string ToString()
        {
            return "LsarSetInformationPolicy, ReturnValue: " + NtStatusValuesToText(ReturnValue) +
                ", InformationClass: " + EnumToString(InformationClass, "LSA.POLICY_INFORMATION_CLASS");
        }
    }
    with IDL{Opnum = 8};
    
    accepts operation Opnum9NotUsedOnWire
    { 
        override string ToString()
        { 
            return "Opnum9NotUsedOnWire";
        } 
    } 
    with IDL{Opnum = 9};
    
    accepts operation LsarCreateAccount
    {
        in LSAPR_HANDLE PolicyHandle;
        in RPC_SID AccountSid with IDL{IndirectionLevel = 1};
        in AccessMaskForAccountObjects DesiredAccess
            where ValidationCheckCombinationValueTooManyItems(InRange<AccessMaskForAccountObjects>(value), this, true, ReferenceType.Message,
                "LSA", "DesiredAccess", "LsarCreateAccount", "ACCESS_MASK for Account Objects", "[MS-LSAD]") 
            with Encoding{Decoder = PatternDecoder<AccessMaskForAccountObjects>, SourcePattern = TypeOf<ACCESS_MASK>()};
        out LSAPR_HANDLE AccountHandle with IDL{IndirectionLevel = 1};
        result DTYP.NTSTATUS ReturnValue;
        
        override string ToString()
        {
            return "LsarCreateAccount, ReturnValue: " + NtStatusValuesToText(ReturnValue) +
                ", DesiredAccess: " + EnumToString(DesiredAccess, "LSA.AccessMaskForAccountObjects");
        }
    }
    with IDL{Opnum = 10};
    
    accepts operation LsarEnumerateAccounts
    {
        in LSAPR_HANDLE PolicyHandle;
        in out IDLUlong EnumerationContext with IDL{IndirectionLevel = 1};
        out PLSAPR_ACCOUNT_ENUM_BUFFER EnumerationBuffer;
        in IDLUlong PreferedMaximumLength;
        result DTYP.NTSTATUS ReturnValue;
        
        override string ToString()
        {
            return "LsarEnumerateAccounts, ReturnValue: " + NtStatusValuesToText(ReturnValue) + 
                ", EnumerationContext: " + EnumerationContext.ToString() + 
                ", Count of EnumerationBuffer: " + EnumerationBuffer.EntriesRead.ToString() + 
                ", PreferedMaximumLength: " + PreferedMaximumLength.ToString();
        }
    }
    with IDL{Opnum = 11};
    
    accepts operation LsarCreateTrustedDomain
    {
        in LSAPR_HANDLE PolicyHandle;
        in LSAPR_TRUSTED_DOMAIN_INFORMATION_BASIC TrustedDomainInformation with IDL{IndirectionLevel = 1};
        in AccessMaskForTrustedDomainObjects DesiredAccess
            where ValidationCheckCombinationValueTooManyItems(InRange<AccessMaskForTrustedDomainObjects>(value), this, true, ReferenceType.Message,
                "LSA", "DesiredAccess", "LsarCreateTrustedDomain", "ACCESS_MASK for Trusted Domain Objects", "[MS-LSAD]")
            with Encoding{Decoder = PatternDecoder<AccessMaskForTrustedDomainObjects>, SourcePattern = TypeOf<ACCESS_MASK>()};
        out LSAPR_HANDLE TrustedDomainHandle with IDL{IndirectionLevel = 1};
        result DTYP.NTSTATUS ReturnValue;
        
        override string ToString()
        {
            return "LsarCreateTrustedDomain, ReturnValue: " + NtStatusValuesToText(ReturnValue) + 
                ", DesiredAccess: " + EnumToString(DesiredAccess, "LSA.AccessMaskForTrustedDomainObjects");
        }
    }
    with IDL{Opnum = 12};
    
    accepts operation LsarEnumerateTrustedDomains
    {
        in LSAPR_HANDLE PolicyHandle;
        in out IDLUlong EnumerationContext with IDL{IndirectionLevel = 1};
        out PLSAPR_TRUSTED_ENUM_BUFFER EnumerationBuffer;
        in IDLUlong PreferedMaximumLength;
        result DTYP.NTSTATUS ReturnValue;
        
        override string ToString()
        {
            return "LsarEnumerateTrustedDomains, ReturnValue: " + NtStatusValuesToText(ReturnValue) + 
                ", EnumerationContext: " + EnumerationContext.ToString() + 
                ", PreferedMaximumLength: " + PreferedMaximumLength.ToString();
        }
    }
    with IDL{Opnum = 13};
    
    accepts operation LsarLookupNames
    {
        in LSAPR_HANDLE PolicyHandle;
        in IDLUlong Count with IDL{Range = new RangePattern{Low = 0, High = 1000}};
        in array<PRPC_UNICODE_STRING> Names with IDL{Size_is = [Count]};
        out PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains with IDL{IndirectionLevel = 1};
        in out PLSAPR_TRANSLATED_SIDS TranslatedSids;
        in LSAP_LOOKUP_LEVEL LookupLevel;
        in out IDLUlong MappedCount with IDL{IndirectionLevel = 1};
        result DTYP.NTSTATUS ReturnValue;
        
        override string ToString()
        {
            return "LsarLookupNames, ReturnValue: " + NtStatusValuesToText(ReturnValue) +
                ", Count: " + (Count as string) +
                ", MappedCount: " + (MappedCount as string);
        }
    }
    with IDL{Opnum = 14};
    
    accepts operation LsarLookupSids
    {
        in LSAPR_HANDLE PolicyHandle;
        in PLSAPR_SID_ENUM_BUFFER SidEnumBuffer;
        out PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains with IDL{IndirectionLevel = 1};
        in out PLSAPR_TRANSLATED_NAMES TranslatedNames;
        in LSAP_LOOKUP_LEVEL LookupLevel;
        in out IDLUlong MappedCount with IDL{IndirectionLevel = 1};
        result DTYP.NTSTATUS ReturnValue;
        
        override string ToString()
        {
            return "LsarLookupSids, ReturnValue: " + NtStatusValuesToText(ReturnValue) +
                ", MappedCount: " + (MappedCount as string);
        }
    }
    with IDL{Opnum = 15};
    
    accepts operation LsarCreateSecret
    {
        in LSAPR_HANDLE PolicyHandle;
        in PLSA_UNICODE_STRING SecretName;
        in AccessMaskForSecretObjects DesiredAccess
            where ValidationCheckCombinationValueTooManyItems(InRange<AccessMaskForSecretObjects>(value), this, true, ReferenceType.Message,
                "LSA", "DesiredAccess", "LsarCreateSecret", "ACCESS_MASK for Secret Objects", "[MS-LSAD]")
            with Encoding{Decoder = PatternDecoder<AccessMaskForSecretObjects>, SourcePattern = TypeOf<ACCESS_MASK>()};
        out LSAPR_HANDLE SecretHandle with IDL{IndirectionLevel = 1};
        result DTYP.NTSTATUS ReturnValue;
        
        override string ToString()
        {
            return "LsarCreateSecret, ReturnValue: " + NtStatusValuesToText(ReturnValue) + 
                ", SecretName: " + SecretName.ToString() +
                ", DesiredAccess: " + EnumToString(DesiredAccess, "LSA.AccessMaskForSecretObjects");
        }
    }
    with IDL{Opnum = 16};
    
    accepts operation LsarOpenAccount
    {
        in LSAPR_HANDLE PolicyHandle;
        in PRPC_SID AccountSid;
        in AccessMaskForAccountObjects DesiredAccess
            where ValidationCheckCombinationValueTooManyItems(InRange<AccessMaskForAccountObjects>(value), this, true, ReferenceType.Message,
                "LSA", "DesiredAccess", "LsarOpenAccount", "ACCESS_MASK for Account Objects", "[MS-LSAD]") 
            with Encoding{Decoder = PatternDecoder<AccessMaskForAccountObjects>, SourcePattern = TypeOf<ACCESS_MASK>()};
        out LSAPR_HANDLE AccountHandle with IDL{IndirectionLevel = 1};
        result DTYP.NTSTATUS ReturnValue;
        
        override string ToString()
        {
            return "LsarOpenAccount, ReturnValue: " + NtStatusValuesToText(ReturnValue) + 
                ", DesiredAccess: " + EnumToString(DesiredAccess, "LSA.AccessMaskForAccountObjects");
        }
    }
    with IDL{Opnum = 17};
    
    accepts operation LsarEnumeratePrivilegesAccount
    {
        in LSAPR_HANDLE AccountHandle;
        out PLSAPR_PRIVILEGE_SET Privileges with IDL{IndirectionLevel = 1};
        result DTYP.NTSTATUS ReturnValue;
        
        override string ToString()
        {
            return "LsarEnumeratePrivilegesAccount, ReturnValue: " + NtStatusValuesToText(ReturnValue);
        }
    }
    with IDL{Opnum = 18};
    
    accepts operation LsarAddPrivilegesToAccount
    {
        in LSAPR_HANDLE AccountHandle;
        in PLSAPR_PRIVILEGE_SET Privileges;
        result DTYP.NTSTATUS ReturnValue;
        
        override string ToString()
        {
            return "LsarAddPrivilegesToAccount, ReturnValue: " + NtStatusValuesToText(ReturnValue) + 
                ", Count of Privileges: " + Privileges.PrivilegeCount.ToString();
        }
    }
    with IDL{Opnum = 19};
    
    accepts operation LsarRemovePrivilegesFromAccount
    {
        in LSAPR_HANDLE AccountHandle;
        in UCHAR AllPrivileges with DisplayInfo{ToText = AllPrivilegesToString};
        in PLSAPR_PRIVILEGE_SET Privileges with IDL{PointerType = PointerKind.UniquePtr};
        result DTYP.NTSTATUS ReturnValue;
        
        override string ToString()
        {
            return "LsarRemovePrivilegesFromAccount, ReturnValue: " + NtStatusValuesToText(ReturnValue) + 
                ", " + AllPrivilegesToString(AllPrivileges);
        }
    }
    with IDL{Opnum = 20};
    
    accepts operation Opnum21NotUsedOnWire
    {
        override string ToString()
        {
            return "Opnum21NotUsedOnWire";
        }     
    }
    with IDL{Opnum = 21};
    
    accepts operation Opnum22NotUsedOnWire
    {
        override string ToString()
        {
            return "Opnum22NotUsedOnWire";
        }     
    }
    with IDL{Opnum = 22};
    
    accepts operation LsarGetSystemAccessAccount
    {
        in LSAPR_HANDLE AccountHandle;
        out AccessMaskForAccountObjects SystemAccess
            where ValidationCheckCombinationValueTooManyItems(InRange<AccessMaskForAccountObjects>(value), this, true, ReferenceType.Message,
                "LSA", "SystemAccess", "LsarGetSystemAccessAccount", "ACCESS_MASK for Account Objects", "[MS-LSAD]") 
            with IDL{IndirectionLevel = 1}
            with Encoding{Decoder = PatternDecoder<AccessMaskForAccountObjects>, SourcePattern = TypeOf<IDLUlong>()};
        result DTYP.NTSTATUS ReturnValue;
        
        override string ToString()
        {
            string summary = "LsarGetSystemAccessAccount, ReturnValue:" + NtStatusValuesToText(ReturnValue) + 
                ", SystemAccess: " + EnumToString(SystemAccess, "LSA.AccessMaskForAccountObjects");
            return summary;
        }
    }
    with IDL{Opnum = 23};
    
    accepts operation LsarSetSystemAccessAccount
    {
        in LSAPR_HANDLE AccountHandle;
        in AccessMaskForAccountObjects SystemAccess
            where ValidationCheckCombinationValueTooManyItems(InRange<AccessMaskForAccountObjects>(value), this, true, ReferenceType.Message,
                "LSA", "SystemAccess", "LsarSetSystemAccessAccount", "ACCESS_MASK for Account Objects", "[MS-LSAD]")
            with Encoding{Decoder = PatternDecoder<AccessMaskForAccountObjects>, SourcePattern = TypeOf<IDLUlong>()};
        result DTYP.NTSTATUS ReturnValue;
        
        override string ToString()
        {
            return "LsarSetSystemAccessAccount, ReturnValue:" + NtStatusValuesToText(ReturnValue) + 
                ", SystemAccess: " + EnumToString(SystemAccess, "LSA.AccessMaskForAccountObjects");
        }
    }
    with IDL{Opnum = 24};
    
    accepts operation LsarOpenTrustedDomain
    {
        in LSAPR_HANDLE PolicyHandle;
        in PRPC_SID TrustedDomainSid;
        in AccessMaskForTrustedDomainObjects DesiredAccess 
            where ValidationCheckCombinationValueTooManyItems(InRange<AccessMaskForTrustedDomainObjects>(value), this, true, ReferenceType.Message,
                "LSA", "DesiredAccess", "LsarOpenTrustedDomain", "ACCESS_MASK for Trusted Domain Objects", "[MS-LSAD]")
            with Encoding{Decoder = PatternDecoder<AccessMaskForTrustedDomainObjects>, SourcePattern = TypeOf<ACCESS_MASK>()};
        out LSAPR_HANDLE TrustedDomainHandle with IDL{IndirectionLevel = 1};
        result DTYP.NTSTATUS ReturnValue;
        
        override string ToString()
        {
            return "LsarOpenTrustedDomain, ReturnValue: " + NtStatusValuesToText(ReturnValue) + 
                ", DesiredAccess: " + EnumToString(DesiredAccess, "LSA.AccessMaskForTrustedDomainObjects");
        }
    }
    with IDL{Opnum = 25};
    
    accepts operation LsarQueryInfoTrustedDomain
    {
        in LSAPR_HANDLE TrustedDomainHandle;
        in TRUSTED_INFORMATION_CLASS InformationClass;
        out PLSAPR_TRUSTED_DOMAIN_INFO[InformationClass] TrustedDomainInformation
                with IDL{Switch_Is = InformationClass, IndirectionLevel = 1};
        result DTYP.NTSTATUS ReturnValue;
        
        override string ToString()
        {
            return "LsarQueryInfoTrustedDomain, ReturnValue: " + NtStatusValuesToText(ReturnValue) +
                ", InformationClass: " + EnumToString(InformationClass, "LSA.TRUSTED_INFORMATION_CLASS");
        }
    }
    with IDL{Opnum = 26};
    
    accepts operation LsarSetInformationTrustedDomain
    {
        in LSAPR_HANDLE TrustedDomainHandle;
        in TRUSTED_INFORMATION_CLASS InformationClass;
        in PLSAPR_TRUSTED_DOMAIN_INFO[InformationClass] TrustedDomainInformation;
        result DTYP.NTSTATUS ReturnValue;
        
        override string ToString()
        {
            return "LsarSetInformationTrustedDomain, ReturnValue: " + NtStatusValuesToText(ReturnValue) +
                ", InformationClass: " + EnumToString(InformationClass, "LSA.TRUSTED_INFORMATION_CLASS");
        }
    }
    with IDL{Opnum = 27};
    
    accepts operation LsarOpenSecret
    {
        in LSAPR_HANDLE PolicyHandle;
        in PLSA_UNICODE_STRING SecretName;
        in AccessMaskForSecretObjects DesiredAccess
            where ValidationCheckCombinationValueTooManyItems(InRange<AccessMaskForSecretObjects>(value), this, true, ReferenceType.Message,
                "LSA", "DesiredAccess", "LsarOpenSecret", "ACCESS_MASK for Secret Objects", "[MS-LSAD]")
            with Encoding{Decoder = PatternDecoder<AccessMaskForSecretObjects>, SourcePattern = TypeOf<ACCESS_MASK>()};
        out LSAPR_HANDLE SecretHandle with IDL{IndirectionLevel = 1};
        result DTYP.NTSTATUS ReturnValue;
        
        override string ToString()
        {
            return "LsarOpenSecret, ReturnValue: " + NtStatusValuesToText(ReturnValue) + 
                ", SecretName: " + SecretName.ToString() +
                ", DesiredAccess: " + EnumToString(DesiredAccess, "LSA.AccessMaskForSecretObjects");
        }
    }
    with IDL{Opnum = 28};
    
    accepts operation LsarSetSecret
    {
        in LSAPR_HANDLE SecretHandle;
        in PLSAPR_CR_CIPHER_VALUE EncryptedCurrentValue with IDL{PointerType = PointerKind.UniquePtr};
        in PLSAPR_CR_CIPHER_VALUE EncryptedOldValue with IDL{PointerType = PointerKind.UniquePtr};
        result DTYP.NTSTATUS ReturnValue;
        
        override string ToString()
        {
            return "LsarSetSecret, ReturnValue: " + NtStatusValuesToText(ReturnValue);
        }
    }
    with IDL{Opnum = 29};
    
    accepts operation LsarQuerySecret
    {
        in LSAPR_HANDLE SecretHandle;
        in out PLSAPR_CR_CIPHER_VALUE EncryptedCurrentValue
                   with IDL{PointerType = PointerKind.UniquePtr, IndirectionLevel = 1};
        in out PLARGE_INTEGER CurrentValueSetTime
                   with IDL{PointerType = PointerKind.UniquePtr};
        in out PLSAPR_CR_CIPHER_VALUE EncryptedOldValue
                   with IDL{PointerType = PointerKind.UniquePtr, IndirectionLevel = 1};
        in out PLARGE_INTEGER OldValueSetTime
                   with IDL{PointerType = PointerKind.UniquePtr};
        result DTYP.NTSTATUS ReturnValue;
        
        override string ToString()
        {
            return "LsarQuerySecret, ReturnValue: " + NtStatusValuesToText(ReturnValue);
        }
    }
    with IDL{Opnum = 30};
    
    accepts operation LsarLookupPrivilegeValue
    {
        in LSAPR_HANDLE PolicyHandle;
        in PLSA_UNICODE_STRING Name;
        out PLUID Value;
        result DTYP.NTSTATUS ReturnValue;
        
        override string ToString()
        {
            return "LsarLookupPrivilegeValue, ReturnValue: " + NtStatusValuesToText(ReturnValue) +
                ", Name: " + Name.ToString() + ", Value: " + Value.ToString();
        }
    }
    with IDL{Opnum = 31};
    
    accepts operation LsarLookupPrivilegeName
    {
        in LSAPR_HANDLE PolicyHandle;
        in PLUID Value;
        out PLSA_UNICODE_STRING Name with IDL{IndirectionLevel = 1};
        result DTYP.NTSTATUS ReturnValue;
        
        override string ToString()
        {
            string summary = "LsarLookupPrivilegeName, ReturnValue: " + NtStatusValuesToText(ReturnValue) +
                ", Value: " + Value.ToString();
            if (Name != null)
            {
                summary += ", Name: " + Name.ToString();
            }
            return summary;
        }
    }
    with IDL{Opnum = 32};
    
    accepts operation LsarLookupPrivilegeDisplayName
    {
        in LSAPR_HANDLE PolicyHandle;
        in PLSA_UNICODE_STRING Name;
        in short ClientLanguage;
        in short ClientSystemDefaultLanguage;
        out PLSA_UNICODE_STRING DisplayName with IDL{IndirectionLevel = 1};
        out ushort LanguageReturned with IDL{IndirectionLevel = 1};
        result DTYP.NTSTATUS ReturnValue;
        
        override string ToString()
        {
            string summaryLine = "LsarLookupPrivilegeDisplayName, ReturnValue: " + NtStatusValuesToText(ReturnValue) +
                ", Name: " + Name.ToString() +
                ", ClientLanguage: " + ClientLanguage.ToString() + 
                ", ClientSystemDefaultLanguage: " + ClientSystemDefaultLanguage.ToString();
            if (DisplayName != null)
            {
                summaryLine += ", DisplayName: " + DisplayName.ToString();
            }
            summaryLine += ", LanguageReturned: " + LanguageReturned.ToString();
            return summaryLine;
        }
    }
    with IDL{Opnum = 33};
    
    accepts operation LsarDeleteObject
    {
        in out LSAPR_HANDLE ObjectHandle with IDL{IndirectionLevel = 1};
        result DTYP.NTSTATUS ReturnValue;
        
        override string ToString()
        {
            return "LsarDeleteObject, ReturnValue: " + NtStatusValuesToText(ReturnValue);
        }
    }
    with IDL{Opnum = 34};
    
    accepts operation LsarEnumerateAccountsWithUserRight
    {
        in LSAPR_HANDLE PolicyHandle;
        in PLSA_UNICODE_STRING UserRight with IDL{PointerType = PointerKind.UniquePtr};
        out PLSAPR_ACCOUNT_ENUM_BUFFER EnumerationBuffer;
        result DTYP.NTSTATUS ReturnValue;
        
        override string ToString()
        {
            string summaryLine = "LsarEnumerateAccountsWithUserRight, ReturnValue: " + NtStatusValuesToText(ReturnValue);
            if (UserRight != null)
            { 
                summaryLine += ", UserRight: " + UserRight.ToString();
            } 
            summaryLine += ", Count of EnumerationBuffer: " + EnumerationBuffer.EntriesRead.ToString();
            return summaryLine;
        }
    }
    with IDL{Opnum = 35};
    
    accepts operation LsarEnumerateAccountRights
    {
        in LSAPR_HANDLE PolicyHandle;
        in PRPC_SID AccountSid;
        out PLSAPR_USER_RIGHT_SET UserRights;
        result DTYP.NTSTATUS ReturnValue;
        
        override string ToString()
        {
            return "LsarEnumerateAccountRights, ReturnValue: " + NtStatusValuesToText(ReturnValue) + 
                ", Count of UserRights: " + UserRights.Entries.ToString();
        }
    }
    with IDL{Opnum = 36};
    
    accepts operation LsarAddAccountRights
    {
        in LSAPR_HANDLE PolicyHandle;
        in PRPC_SID AccountSid;
        in PLSAPR_USER_RIGHT_SET UserRights;
        result DTYP.NTSTATUS ReturnValue;
        
        override string ToString()
        {
            return "LsarAddAccountRights, ReturnValue: " + NtStatusValuesToText(ReturnValue) +
                ", Count of UserRights: " + UserRights.Entries.ToString();
        }
    }
    with IDL{Opnum = 37};
    
    accepts operation LsarRemoveAccountRights
    {
        in LSAPR_HANDLE PolicyHandle;
        in PRPC_SID AccountSid;
        in UCHAR AllRights with DisplayInfo{ToText = AllRightsToString};
        in PLSAPR_USER_RIGHT_SET UserRights;
        result DTYP.NTSTATUS ReturnValue;
        
        override string ToString()
        {
            return "LsarRemoveAccountRights, ReturnValue " + NtStatusValuesToText(ReturnValue) +
                ", " + AllRightsToString(AllRights) + 
                ", Count of UserRights: " + UserRights.Entries.ToString();
        }
    }
    with IDL{Opnum = 38};
    
    accepts operation LsarQueryTrustedDomainInfo
    {
        in LSAPR_HANDLE PolicyHandle;
        in PRPC_SID TrustedDomainSid;
        in TRUSTED_INFORMATION_CLASS InformationClass;
        out PLSAPR_TRUSTED_DOMAIN_INFO[InformationClass] TrustedDomainInformation
                with IDL {Switch_Is = InformationClass, IndirectionLevel = 1};
        result DTYP.NTSTATUS ReturnValue;
        
        override string ToString()
        {
            return "LsarQueryTrustedDomainInfo, ReturnValue: " + NtStatusValuesToText(ReturnValue) + 
                ", InformationClass: " + EnumToString(InformationClass, "LSA.TRUSTED_INFORMATION_CLASS");
        }
    }
    with IDL{Opnum = 39};
    
    accepts operation LsarSetTrustedDomainInfo
    {
        in LSAPR_HANDLE PolicyHandle;
        in PRPC_SID TrustedDomainSid;
        in TRUSTED_INFORMATION_CLASS InformationClass;
        in PLSAPR_TRUSTED_DOMAIN_INFO[InformationClass] TrustedDomainInformation with IDL{Switch_Is = InformationClass};
        result DTYP.NTSTATUS ReturnValue;
        
        override string ToString()
        {
            return "LsarSetTrustedDomainInfo ReturnValue: " + NtStatusValuesToText(ReturnValue) +
                ", InformationClass: " + EnumToString(InformationClass, "LSA.TRUSTED_INFORMATION_CLASS");
        }
    }
    with IDL{Opnum = 40};
    
    accepts operation LsarDeleteTrustedDomain
    {
        in LSAPR_HANDLE PolicyHandle;
        in PRPC_SID TrustedDomainSid;
        result DTYP.NTSTATUS ReturnValue;
        
        override string ToString()
        {
            return "LsarDeleteTrustedDomain, ReturnValue: " + NtStatusValuesToText(ReturnValue);
        }
    }
    with IDL{Opnum = 41};
    
    accepts operation LsarStorePrivateData
    {
        in LSAPR_HANDLE PolicyHandle;
        in PLSA_UNICODE_STRING KeyName;
        in PLSAPR_CR_CIPHER_VALUE EncryptedData with IDL{PointerType = PointerKind.UniquePtr};
        result DTYP.NTSTATUS ReturnValue;
        
        override string ToString()
        {
            return "LsarStorePrivateData, ReturnValue: " + NtStatusValuesToText(ReturnValue) +
                ", KeyName: " + KeyName.ToString();
        }
    }
    with IDL{Opnum = 42};
    
    accepts operation LsarRetrievePrivateData
    {
        in LSAPR_HANDLE PolicyHandle;
        in PLSA_UNICODE_STRING KeyName;
        in out PLSAPR_CR_CIPHER_VALUE EncryptedData with IDL{IndirectionLevel = 1};
        result DTYP.NTSTATUS ReturnValue;
        
        override string ToString()
        {
            return "LsarRetrievePrivateData, ReturnValue: " + NtStatusValuesToText(ReturnValue) +
                ", KeyName: " + KeyName.ToString();
        }
    }
    with IDL{Opnum = 43};
    
    accepts operation LsarOpenPolicy2
    {
        in string SystemName with IDL{PointerType = PointerKind.UniquePtr, BaseStringType = TypeOf<wchar_t>(), IndirectionLevel = 1};
        in PLSAPR_OBJECT_ATTRIBUTES ObjectAttributes;
        in AccessMaskForPolicyObjects DesiredAccess
            where ValidationCheckCombinationValueTooManyItems(InRange<AccessMaskForPolicyObjects>(value), this, true, ReferenceType.Message,
                "LSA", "DesiredAccess", "LsarOpenPolicy2", "ACCESS_MASK for Policy Objects", "[MS-LSAD]")
            with Encoding{Decoder = PatternDecoder<AccessMaskForPolicyObjects>, SourcePattern = TypeOf<ACCESS_MASK>()};
        out LSAPR_HANDLE PolicyHandle with IDL{IndirectionLevel = 1};
        result DTYP.NTSTATUS ReturnValue;
        
        override string ToString()
        {
            return "LsarOpenPolicy2, ReturnValue: " + NtStatusValuesToText(ReturnValue) +
                ", SystemName: " + SystemName.ToString() +
                ", DesiredAccess: " + EnumToString(DesiredAccess, "LSA.AccessMaskForPolicyObjects");
        }
    }
    with IDL{Opnum = 44};
    
    accepts operation LsarGetUserName
    {
        in string SystemName with IDL{PointerType = PointerKind.UniquePtr, BaseStringType = TypeOf<wchar_t>(), IndirectionLevel = 1};
        in out PRPC_UNICODE_STRING UserName with IDL{IndirectionLevel = 1};
        in out PRPC_UNICODE_STRING DomainName with IDL{PointerType = PointerKind.UniquePtr, IndirectionLevel = 1};
        result DTYP.NTSTATUS ReturnValue;
        
        override string ToString()
        {
            return "LsarGetUserName, ReturnValue: " + NtStatusValuesToText(ReturnValue);
        }
    }
    with IDL{Opnum = 45};
    
    accepts operation LsarQueryInformationPolicy2
    {
        in LSAPR_HANDLE PolicyHandle;
        in POLICY_INFORMATION_CLASS InformationClass;
        out PLSAPR_POLICY_INFORMATION[InformationClass] PolicyInformation
                with IDL{Switch_Is = InformationClass, IndirectionLevel = 1};
        result DTYP.NTSTATUS ReturnValue;
        
        override string ToString()
        {
            return "LsarQueryInformationPolicy2, ReturnValue: " + NtStatusValuesToText(ReturnValue) +
                ", InformationClass: " + EnumToString(InformationClass, "LSA.POLICY_INFORMATION_CLASS");
        }
    }
    with IDL{Opnum = 46};
    
    accepts operation LsarSetInformationPolicy2
    {
        in LSAPR_HANDLE PolicyHandle;
        in POLICY_INFORMATION_CLASS InformationClass;
        in PLSAPR_POLICY_INFORMATION[InformationClass] PolicyInformation with IDL{Switch_Is = InformationClass};
        result DTYP.NTSTATUS ReturnValue;
        
        override string ToString()
        {
            return "LsarSetInformationPolicy2, ReturnValue: " + NtStatusValuesToText(ReturnValue) +
                ", InformationClass: " + EnumToString(InformationClass, "LSA.POLICY_INFORMATION_CLASS");
        }
    }
    with IDL{Opnum = 47};
    
    accepts operation LsarQueryTrustedDomainInfoByName
    {
        in LSAPR_HANDLE PolicyHandle;
        in PLSA_UNICODE_STRING TrustedDomainName;
        in TRUSTED_INFORMATION_CLASS InformationClass;
        out PLSAPR_TRUSTED_DOMAIN_INFO[InformationClass] TrustedDomainInformation
                with IDL{Switch_Is = InformationClass, IndirectionLevel = 1};
        result DTYP.NTSTATUS ReturnValue;
        
        override string ToString()
        {
            return "LsarQueryTrustedDomainInfoByName, ReturnValue: " + NtStatusValuesToText(ReturnValue) +
                ", TrustedDomainName: " + TrustedDomainName.ToString() + 
                ", InformationClass: " + EnumToString(InformationClass, "LSA.TRUSTED_INFORMATION_CLASS");
        }
    }
    with IDL{Opnum = 48};
    
    accepts operation LsarSetTrustedDomainInfoByName
    {
        in LSAPR_HANDLE PolicyHandle;
        in PLSA_UNICODE_STRING TrustedDomainName;
        in TRUSTED_INFORMATION_CLASS InformationClass;
        in PLSAPR_TRUSTED_DOMAIN_INFO[InformationClass] TrustedDomainInformation
               with IDL{Switch_Is = InformationClass};
        result DTYP.NTSTATUS ReturnValue;
        
        override string ToString()
        {
            return "LsarSetTrustedDomainInfoByName, ReturnValue: " + NtStatusValuesToText(ReturnValue) +
                ", TrustedDomainName" + TrustedDomainName.ToString() +
                ", InformationClass: " + EnumToString(InformationClass, "LSA.TRUSTED_INFORMATION_CLASS");
        }
    }
    with IDL{Opnum = 49};
    
    accepts operation LsarEnumerateTrustedDomainsEx
    {
        in LSAPR_HANDLE PolicyHandle;
        in out IDLUlong EnumerationContext with IDL{IndirectionLevel = 1};
        out PLSAPR_TRUSTED_ENUM_BUFFER_EX EnumerationBuffer;
        in IDLUlong PreferedMaximumLength;
        result DTYP.NTSTATUS ReturnValue;
        
        override string ToString()
        {
            return "LsarEnumerateTrustedDomainsEx, ReturnValue: " + NtStatusValuesToText(ReturnValue) + 
                ", EnumerationContext: " + EnumerationContext.ToString() +
                ", PreferedMaximumLength: " + PreferedMaximumLength.ToString() +
                ", EnumerationContext: " + EnumerationContext.ToString();
        }
    }
    with IDL{Opnum = 50};
    
    accepts operation LsarCreateTrustedDomainEx
    {
        in LSAPR_HANDLE PolicyHandle;
        in PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX TrustedDomainInformation;
        in PLSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION AuthenticationInformation;
        in AccessMaskForTrustedDomainObjects DesiredAccess
            where ValidationCheckCombinationValueTooManyItems(InRange<AccessMaskForTrustedDomainObjects>(value), this, true, ReferenceType.Message,
                "LSA", "DesiredAccess", "LsarCreateTrustedDomainEx", "ACCESS_MASK for Trusted Domain Objects", "[MS-LSAD]")
            with Encoding{Decoder = PatternDecoder<AccessMaskForTrustedDomainObjects>, SourcePattern = TypeOf<ACCESS_MASK>()};
        out LSAPR_HANDLE TrustedDomainHandle with IDL{IndirectionLevel = 1};
        result DTYP.NTSTATUS ReturnValue;
        
        override string ToString()
        {
            return "LsarCreateTrustedDomainEx, ReturnValue: " + NtStatusValuesToText(ReturnValue) +
                ", DesiredAccess: " + EnumToString(DesiredAccess, "LSA.AccessMaskForTrustedDomainObjects");
        }
    }
    with IDL{Opnum = 51};
    
    accepts operation Opnum52NotUsedOnWire
    {
        override string ToString()
        {
            return "Opnum52NotUsedOnWire";
        }     
    }
    with IDL{Opnum = 52};
    
    accepts operation LsarQueryDomainInformationPolicy
    {
        in LSAPR_HANDLE PolicyHandle;
        in POLICY_DOMAIN_INFORMATION_CLASS InformationClass;
        out PLSAPR_POLICY_DOMAIN_INFORMATION[InformationClass] PolicyDomainInformation
                with IDL {Switch_Is = InformationClass, IndirectionLevel = 1};
        result DTYP.NTSTATUS ReturnValue;
        
        override string ToString()
        {
            return "LsarQueryDomainInformationPolicy, ReturnValue: " + NtStatusValuesToText(ReturnValue) + 
                ", InformationClass: " + EnumToString(InformationClass, "LSA.POLICY_DOMAIN_INFORMATION_CLASS");
        }
    }
    with IDL{Opnum = 53};
    
    accepts operation LsarSetDomainInformationPolicy
    {
        in LSAPR_HANDLE PolicyHandle;
        in POLICY_DOMAIN_INFORMATION_CLASS InformationClass;
        in PLSAPR_POLICY_DOMAIN_INFORMATION[InformationClass] PolicyDomainInformation
               with IDL{Switch_Is = InformationClass, PointerType = PointerKind.UniquePtr};
        result DTYP.NTSTATUS ReturnValue;
        
        override string ToString()
        {
            return "LsarSetDomainInformationPolicy, ReturnValue: " + NtStatusValuesToText(ReturnValue) +
                ", InformationClass: " + EnumToString(InformationClass, "LSA.POLICY_DOMAIN_INFORMATION_CLASS");
        }
    }
    with IDL{Opnum = 54};
    
    accepts operation LsarOpenTrustedDomainByName
    {
        in LSAPR_HANDLE PolicyHandle;
        in PLSA_UNICODE_STRING TrustedDomainName;
        in AccessMaskForTrustedDomainObjects DesiredAccess
            where ValidationCheckCombinationValueTooManyItems(InRange<AccessMaskForTrustedDomainObjects>(value), this, true, ReferenceType.Message,
                "LSA", "DesiredAccess", "LsarOpenTrustedDomainByName", "ACCESS_MASK for Trusted Domain Objects", "[MS-LSAD]")
            with Encoding{Decoder = PatternDecoder<AccessMaskForTrustedDomainObjects>, SourcePattern = TypeOf<ACCESS_MASK>()};
        out LSAPR_HANDLE TrustedDomainHandle with IDL{IndirectionLevel = 1};
        result DTYP.NTSTATUS ReturnValue;
        
        override string ToString()
        {
            return "LsarOpenTrustedDomainByName, ReturnValue: " + NtStatusValuesToText(ReturnValue) +
                ", TrustedDomainName: " + TrustedDomainName.ToString() +
                ", DesiredAccess" + EnumToString(DesiredAccess, "LSA.AccessMaskForTrustedDomainObjects");
        }
    }
    with IDL{Opnum = 55};
    
    accepts operation Opnum56NotUsedOnWire
    {
        override string ToString()
        {
            return "Opnum56NotUsedOnWire";
        }     
    }
    with IDL{Opnum = 56};
    
    accepts operation LsarLookupSids2
    {
        in LSAPR_HANDLE PolicyHandle;
        in PLSAPR_SID_ENUM_BUFFER SidEnumBuffer;
        out PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains with IDL{IndirectionLevel = 1};
        in out PLSAPR_TRANSLATED_NAMES_EX TranslatedNames;
        in LSAP_LOOKUP_LEVEL LookupLevel;
        in out IDLUlong MappedCount with IDL{IndirectionLevel = 1};
        in IDLUlong LookupOptions 
            where ValidationCheckReservedZero(value == 0, this, true, ReferenceType.Message, "LSA", "LookupOptions", "LsarLookupSids2", value);
        in ClientRevisionPattern ClientRevision
            where ValidationCheckEnumValue(InRange<ClientRevisionPattern>(value), this, true, ReferenceType.Message,
                    "LSA", "ClientRevision", "LsarLookupSids2", "0x00000001, 0x00000002", value)
            with Encoding{Decoder = PatternDecoder<ClientRevisionPattern>, SourcePattern = TypeOf<IDLUlong>()};
        result DTYP.NTSTATUS ReturnValue;
        
        override string ToString()
        {
            return "LsarLookupSids2, ReturnValue: " + NtStatusValuesToText(ReturnValue) +
                ", MappedCount: " + MappedCount.ToString() + 
                ", ClientRevision: " + EnumToString(ClientRevision, "LSA.ClientRevisionPattern");
        }
    }
    with IDL{Opnum = 57};
    
    accepts operation LsarLookupNames2
    {
        in LSAPR_HANDLE PolicyHandle;
        in IDLUlong Count with IDL{Range = new RangePattern{Low = 0, High = 1000}};
        in array<PRPC_UNICODE_STRING> Names with IDL{Size_is = [Count]};
        out PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains with IDL{IndirectionLevel = 1};
        in out PLSAPR_TRANSLATED_SIDS_EX TranslatedSids;
        in LSAP_LOOKUP_LEVEL LookupLevel;
        in out IDLUlong MappedCount with IDL{IndirectionLevel = 1};
        in LookupOptionsPattern LookupOptions
            where ValidationCheckEnumValue(InRange<LookupOptionsPattern>(value), this, true, ReferenceType.Message, 
                "LSA", "LookupOptions", "LsarLookupNames2", "0x00000000, 0x80000000", value)
            with Encoding{Decoder = PatternDecoder<LookupOptionsPattern>, SourcePattern = TypeOf<IDLUlong>()};
        in ClientRevisionPattern ClientRevision
            where ValidationCheckEnumValue(InRange<ClientRevisionPattern>(value), this, true, ReferenceType.Message,
                    "LSA", "ClientRevision", "LsarLookupNames2", "0x00000001, 0x00000002", value)
            with Encoding{Decoder = PatternDecoder<ClientRevisionPattern>, SourcePattern = TypeOf<IDLUlong>()};
        result DTYP.NTSTATUS ReturnValue;
        
        override string ToString()
        {
            return "LsarLookupNames2, ReturnValue: " + NtStatusValuesToText(ReturnValue) + 
                ", LookupOptions: " + EnumToString(LookupOptions, "LSA.LookupOptionsPattern") +
                ", ClientRevision: " + EnumToString(ClientRevision, "LSA.ClientRevisionPattern");
        }
    }
    with IDL{Opnum = 58};
    
    accepts operation LsarCreateTrustedDomainEx2
    {
        in LSAPR_HANDLE PolicyHandle;
        in PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX TrustedDomainInformation;
        in PLSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION_INTERNAL AuthenticationInformation;
        in AccessMaskForTrustedDomainObjects DesiredAccess
            where ValidationCheckCombinationValueTooManyItems(InRange<AccessMaskForTrustedDomainObjects>(value), this, true, ReferenceType.Message,
                "LSA", "DesiredAccess", "LsarCreateTrustedDomainEx2", "ACCESS_MASK for Trusted Domain Objects", "[MS-LSAD]")
            with Encoding{Decoder = PatternDecoder<AccessMaskForTrustedDomainObjects>, SourcePattern = TypeOf<ACCESS_MASK>()};
        out LSAPR_HANDLE TrustedDomainHandle with IDL{IndirectionLevel = 1};
        result DTYP.NTSTATUS ReturnValue;
        
        override string ToString()
        {
            return "LsarCreateTrustedDomainEx2, ReturnValue: " + NtStatusValuesToText(ReturnValue) +
                ", DesiredAccess: " + EnumToString(DesiredAccess, "LSA.AccessMaskForTrustedDomainObjects");
        }
    }
    with IDL{Opnum = 59};
    
    accepts operation Opnum60NotUsedOnWire
    {
        override string ToString()
        {
            return "Opnum60NotUsedOnWire";
        }     
    }
    with IDL{Opnum = 60};
    
    accepts operation Opnum61NotUsedOnWire
    {
        override string ToString()
        {
            return "Opnum61NotUsedOnWire";
        }     
    }
    with IDL{Opnum = 61};
    
    accepts operation Opnum62NotUsedOnWire
    {
        override string ToString()
        {
            return "Opnum62NotUsedOnWire";
        }     
    }
    with IDL{Opnum = 62};
    
    accepts operation Opnum63NotUsedOnWire
    {
        override string ToString()
        {
            return "Opnum63NotUsedOnWire";
        }     
    }
    with IDL{Opnum = 63};
    
    accepts operation Opnum64NotUsedOnWire
    {
        override string ToString()
        {
            return base.ToString();
        }     
    }
    with IDL{Opnum = 64};
    
    accepts operation Opnum65NotUsedOnWire
    {
        override string ToString()
        {
            return base.ToString();
        }     
    }
    with IDL{Opnum = 65};
    
    accepts operation Opnum66NotUsedOnWire
    {
        override string ToString()
        {
            return base.ToString();
        }     
    }
    with IDL{Opnum = 66};
    
    accepts operation Opnum67NotUsedOnWire
    {
        override string ToString()
        {
            return base.ToString();
        }     
    }
    with IDL{Opnum = 67};
    
    accepts operation LsarLookupNames3
    {
        in LSAPR_HANDLE PolicyHandle;
        in IDLUlong Count with IDL{Range = new RangePattern{Low = 0, High = 1000}};
        in array<PRPC_UNICODE_STRING> Names with IDL{Size_is = [Count]};
        out PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains with IDL{IndirectionLevel = 1};
        in out PLSAPR_TRANSLATED_SIDS_EX2 TranslatedSids;
        in LSAP_LOOKUP_LEVEL LookupLevel;
        in out IDLUlong MappedCount with IDL{IndirectionLevel = 1};
        in LookupOptionsPattern LookupOptions 
            where ValidationCheckEnumValue(InRange<LookupOptionsPattern>(value), this, true, ReferenceType.Message, 
                "LSA", "LookupOptions", "LsarLookupNames3", "0x00000000, 0x80000000", value)
            with Encoding{Decoder = PatternDecoder<LookupOptionsPattern>, SourcePattern = TypeOf<IDLUlong>()};
        in ClientRevisionPattern ClientRevision
            where ValidationCheckEnumValue(InRange<ClientRevisionPattern>(value), this, true, ReferenceType.Message,
                    "LSA", "ClientRevision", "LsarLookupNames3", "0x00000001, 0x00000002", value)
            with Encoding{Decoder = PatternDecoder<ClientRevisionPattern>, SourcePattern = TypeOf<IDLUlong>()};
        result DTYP.NTSTATUS ReturnValue;
        
        override string ToString()
        {
            return "LsarLookupNames3, ReturnValue: " + NtStatusValuesToText(ReturnValue) +
                ", LookupOptions: " + EnumToString(LookupOptions, "LSA.LookupOptionsPattern") +
                ", ClientRevision: " + EnumToString(ClientRevision, "LSA.ClientRevisionPattern");
        }
    }
    with IDL{Opnum = 68};
    
    accepts operation Opnum69NotUsedOnWire
    {
        override string ToString()
        {
            return base.ToString();
        }     
    }
    with IDL{Opnum = 69};
    
    accepts operation Opnum70NotUsedOnWire
    {
        override string ToString()
        {
            return base.ToString();
        }     
    }
    with IDL{Opnum = 70};
    
    accepts operation Opnum71NotUsedOnWire
    {
        override string ToString()
        {
            return base.ToString();
        }     
    }
    with IDL{Opnum = 71};
    
    accepts operation Opnum72NotUsedOnWire
    {
        override string ToString()
        {
            return base.ToString();
        }     
    }
    with IDL{Opnum = 72};
    
    accepts operation LsarQueryForestTrustInformation
    {
        in LSAPR_HANDLE PolicyHandle;
        in PLSA_UNICODE_STRING TrustedDomainName;
        in LSA_FOREST_TRUST_RECORD_TYPE HighestRecordType;
        out PLSA_FOREST_TRUST_INFORMATION ForestTrustInfo with IDL{IndirectionLevel = 1};
        result DTYP.NTSTATUS ReturnValue;
        
        override string ToString()
        {
            return "LsarQueryForestTrustInformation, ReturnValue: " + NtStatusValuesToText(ReturnValue) +
                ", TrustedDomainName: " + TrustedDomainName.ToString() +
                ", HighestRecordType: " + EnumToString(HighestRecordType, "LSA.LSA_FOREST_TRUST_RECORD_TYPE");
        }
    }
    with IDL{Opnum = 73};
    
    accepts operation LsarSetForestTrustInformation
    {
        in LSAPR_HANDLE PolicyHandle;
        in PLSA_UNICODE_STRING TrustedDomainName;
        in LSA_FOREST_TRUST_RECORD_TYPE HighestRecordType;
        in PLSA_FOREST_TRUST_INFORMATION ForestTrustInfo;
        in UCHAR CheckOnly with DisplayInfo{ToText = CheckOnlyToString};
        out PLSA_FOREST_TRUST_COLLISION_INFORMATION CollisionInfo with IDL{IndirectionLevel = 1};
        result DTYP.NTSTATUS ReturnValue;
        
        override string ToString()
        {
            return "LsarSetForestTrustInformation, ReturnValue: " + NtStatusValuesToText(ReturnValue) +
                ", TrustedDomainName: " + TrustedDomainName.ToString() +
                ", HighestRecordType: " + EnumToString(HighestRecordType, "LSA.LSA_FOREST_TRUST_RECORD_TYPE") +
                ", " + CheckOnlyToString(CheckOnly);
        }
    }
    with IDL{Opnum = 74};
    
    accepts operation Opnum75NotUsedOnWire
    {
        override string ToString()
        {
            return base.ToString();
        }     
    }
    with IDL{Opnum = 75};
    
    accepts operation LsarLookupSids3
    {
        in (optional handle_t) RpcHandle;
        in PLSAPR_SID_ENUM_BUFFER SidEnumBuffer;
        out PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains with IDL{IndirectionLevel = 1};
        in out PLSAPR_TRANSLATED_NAMES_EX TranslatedNames;
        in LSAP_LOOKUP_LEVEL LookupLevel;
        in out IDLUlong MappedCount with IDL{IndirectionLevel = 1};
        in LookupOptionsPattern LookupOptions
            where ValidationCheckReservedZero(value == 0, this, true, ReferenceType.Message,
                    "LSA", "LookupOptions", "LsarLookupSids3", value)
            with Encoding{Decoder = PatternDecoder<LookupOptionsPattern>, SourcePattern = TypeOf<IDLUlong>()};
        in ClientRevisionPattern ClientRevision
            where ValidationCheckEnumValue(InRange<ClientRevisionPattern>(value), this, true, ReferenceType.Message,
                    "LSA", "ClientRevision", "LsarLookupSids3", "0x00000001, 0x00000002", value)
            with Encoding{Decoder = PatternDecoder<ClientRevisionPattern>, SourcePattern = TypeOf<IDLUlong>()};
        result DTYP.NTSTATUS ReturnValue;
        
        override string ToString()
        {
            return "LsarLookupSids3, ReturnValue: " + NtStatusValuesToText(ReturnValue) +
                ", MappedCount: " + MappedCount.ToString() +
                ", LookupOptions: " + EnumToString(LookupOptions, "LSA.LookupOptionsPattern") +
                ", ClientRevision: " + EnumToString(ClientRevision, "LSA.ClientRevisionPattern");
        }
    }
    with IDL{Opnum = 76};
    
    accepts operation LsarLookupNames4
    {
        in (optional handle_t) RpcHandle;
        in IDLUlong Count with IDL{Range = new RangePattern{Low = 0, High = 1000}};
        in array<PRPC_UNICODE_STRING> Names with IDL{Size_is = [Count]};
        out PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains with IDL{IndirectionLevel = 1};
        in out PLSAPR_TRANSLATED_SIDS_EX2 TranslatedSids;
        in LSAP_LOOKUP_LEVEL LookupLevel;
        in out IDLUlong MappedCount with IDL{IndirectionLevel = 1};
        in LookupOptionsPattern LookupOptions
            where ValidationCheckEnumValue(InRange<LookupOptionsPattern>(value), this, true, ReferenceType.Message, 
                "LSA", "LookupOptions", "LsarLookupNames4", "0x00000000, 0x80000000", value)
            with Encoding{Decoder = PatternDecoder<LookupOptionsPattern>, SourcePattern = TypeOf<IDLUlong>()};
        in ClientRevisionPattern ClientRevision
            where ValidationCheckEnumValue(InRange<ClientRevisionPattern>(value), this, true, ReferenceType.Message,
                    "LSA", "ClientRevision", "LsarLookupNames4", "0x00000001, 0x00000002", value)
            with Encoding{Decoder = PatternDecoder<ClientRevisionPattern>, SourcePattern = TypeOf<IDLUlong>()};
        result DTYP.NTSTATUS ReturnValue;

        override string ToString()
        {
            return "LsarLookupNames4, ReturnValue: " + NtStatusValuesToText(ReturnValue) +
                ", Count: " + Count.ToString() + ", MappedCount: " + MappedCount.ToString() +
                ", LookupOptions: " + EnumToString(LookupOptions, "LSA.LookupOptionsPattern") +
                ", ClientRevision: " + EnumToString(ClientRevision, "LSA.ClientRevisionPattern");
        }
    }
    with IDL{Opnum = 77};
} with IDL{
        Uuid = {12345778-1234-abcd-ef00-0123456789ab},
        Version = "0.0",
        Pointer_default = PointerKind.UniquePtr,
        Ms_union = true
    };

typedef LSAPR_HANDLE = ContextHandle;

type LSAPR_OBJECT_ATTRIBUTES
{
    IDLUlong Length;
    UCHAR? RootDirectory with IDL{IndirectionLevel = 1};
    PSTRING ObjectName;
    IDLUlong Attributes;
    PLSAPR_SECURITY_DESCRIPTOR SecurityDescriptor;
    PSECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
}

typedef PLSAPR_OBJECT_ATTRIBUTES = LSAPR_OBJECT_ATTRIBUTES with IDL{IndirectionLevel = 1};

type STRING
{
    ushort Length;
    ushort MaximumLength;
    array<char> Buffer with IDL{Size_is = [MaximumLength], Length_is = [Length], IndirectionLevel = 1};
    
    override string ToString()
    {
        return Buffer as string;
    }
}

typedef PSTRING = STRING with IDL{IndirectionLevel = 1};

type LSAPR_SECURITY_DESCRIPTOR
{
    UCHAR Revision;
    UCHAR Sbz1;
    DTYP.SecurityDescriptorControl Control
        where ValidationCheckCombinationValueTooManyItems(InRange<TrustAttributesPattern>(value), null, false, ReferenceType.Type,
                "LSA", "Control", "LSAPR_SECURITY_DESCRIPTOR", "Control", "[MS-LSAD]")
        with Encoding{Decoder = PatternDecoder<DTYP.SecurityDescriptorControl>, SourcePattern = TypeOf<SECURITY_DESCRIPTOR_CONTROL>()};
    PRPC_SID Owner;
    PRPC_SID Group;
    PLSAPR_ACL Sacl;
    PLSAPR_ACL Dacl;
}

typedef PLSAPR_SECURITY_DESCRIPTOR = LSAPR_SECURITY_DESCRIPTOR with IDL{IndirectionLevel = 1};

typedef SECURITY_DESCRIPTOR_CONTROL = ushort;

typedef PSECURITY_DESCRIPTOR_CONTROL = SECURITY_DESCRIPTOR_CONTROL with IDL{IndirectionLevel = 1};

type LSAPR_ACL
{
    UCHAR AclRevision;
    UCHAR Sbz1;
    ushort AclSize;
    // no decoding because it is ignored and never used
    array<UCHAR> Dummy1 with IDL{Size_is = [AclSize - 4], Dimensions = [null]};
}

typedef PLSAPR_ACL = LSAPR_ACL with IDL{IndirectionLevel = 1};

type SECURITY_QUALITY_OF_SERVICE
{
    IDLUlong Length;
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
    SECURITY_CONTEXT_TRACKING_MODE ContextTrackingMode with DisplayInfo{ToText = ContextTrackingModeToString};
    UCHAR EffectiveOnly with DisplayInfo{ToText = EffectiveOnlyToString};
}

typedef PSECURITY_QUALITY_OF_SERVICE = SECURITY_QUALITY_OF_SERVICE with IDL{IndirectionLevel = 1};

pattern SECURITY_IMPERSONATION_LEVEL = enum 
{
    SecurityAnonymous = 0,
    SecurityIdentification = 1,
    SecurityImpersonation = 2,
    SecurityDelegation = 3,
    ...
};

typedef PSECURITY_IMPERSONATION_LEVEL = SECURITY_IMPERSONATION_LEVEL with IDL{IndirectionLevel = 1};

typedef SECURITY_CONTEXT_TRACKING_MODE = char;

typedef PSECURITY_CONTEXT_TRACKING_MODE = SECURITY_CONTEXT_TRACKING_MODE with IDL{IndirectionLevel = 1};

type LSAPR_REFERENCED_DOMAIN_LIST
{
    IDLUlong Entries;
    array<PLSAPR_TRUST_INFORMATION> Domains with IDL{Size_is = [Entries]};
    IDLUlong MaxEntries;
}

typedef PLSAPR_REFERENCED_DOMAIN_LIST = LSAPR_REFERENCED_DOMAIN_LIST with IDL{IndirectionLevel = 1};

type LSAPR_TRUST_INFORMATION
{
    RPC_UNICODE_STRING Name;
    PRPC_SID Sid;
}

typedef PLSAPR_TRUST_INFORMATION = LSAPR_TRUST_INFORMATION with IDL{IndirectionLevel = 1};

type LSAPR_TRANSLATED_SIDS
{
    IDLUlong Entries with IDL{Range = new RangePattern{Low = 0, High = 1000}};
    array<PLSA_TRANSLATED_SID> Sids with IDL{Size_is = [Entries]};
}

typedef PLSAPR_TRANSLATED_SIDS = LSAPR_TRANSLATED_SIDS with IDL{IndirectionLevel = 1};

type LSA_TRANSLATED_SID
{
    SID_NAME_USE Use;
    IDLUlong RelativeId;
    IDLLong DomainIndex where ValidationCheckGreaterThanOrEqualTo(value >= -1, null, true, ReferenceType.Type,
        "LSA", "DomainIndex", "LSA_TRANSLATED_SID", -1, value);
}

typedef PLSA_TRANSLATED_SID = LSA_TRANSLATED_SID with IDL{IndirectionLevel = 1};

pattern SID_NAME_USE = enum 
{
    SidTypeUser = 1,
    SidTypeGroup,
    SidTypeDomain,
    SidTypeAlias,
    SidTypeWellKnownGroup,
    SidTypeDeletedAccount,
    SidTypeInvalid,
    SidTypeUnknown,
    SidTypeComputer,
    SidTypeLabel,
    ...
};

typedef PSID_NAME_USE = SID_NAME_USE with IDL{IndirectionLevel = 1};

pattern LSAP_LOOKUP_LEVEL = enum 
{
    LsapLookupWksta = 1,
    LsapLookupPDC,
    LsapLookupTDL,
    LsapLookupGC,
    LsapLookupXForestReferral,
    LsapLookupXForestResolve,
    LsapLookupRODCReferralToFullDC
    ...
};

typedef PLSAP_LOOKUP_LEVEL = LSAP_LOOKUP_LEVEL with IDL{IndirectionLevel = 1};

type LSAPR_SID_ENUM_BUFFER
{
    IDLUlong Entries with IDL{Range = new RangePattern{Low = 0, High = 20480}};
    array<PLSAPR_SID_INFORMATION> SidInfo with IDL{Size_is = [Entries]};
}

typedef PLSAPR_SID_ENUM_BUFFER = LSAPR_SID_ENUM_BUFFER with IDL{IndirectionLevel = 1};

type LSAPR_SID_INFORMATION
{
    PRPC_SID Sid where ValidationCheck(value != null, null, DiagnosisLevel.Error, LSA_SID_NOT_NULL);
}

typedef PLSAPR_SID_INFORMATION = LSAPR_SID_INFORMATION with IDL{IndirectionLevel = 1};

type LSAPR_TRANSLATED_NAMES
{
    IDLUlong Entries with IDL{Range = new RangePattern{Low = 0, High = 20480}};
    array<PLSAPR_TRANSLATED_NAME> Names with IDL{Size_is = [Entries]};
}

typedef PLSAPR_TRANSLATED_NAMES = LSAPR_TRANSLATED_NAMES with IDL{IndirectionLevel = 1};

type LSAPR_TRANSLATED_NAME
{
    SID_NAME_USE Use;
    RPC_UNICODE_STRING Name;
    IDLLong DomainIndex where ValidationCheckGreaterThanOrEqualTo(value >= -1, null, true, ReferenceType.Type,
        "LSA", "DomainIndex", "LSAPR_TRANSLATED_NAME", -1, value);
}

typedef PLSAPR_TRANSLATED_NAME = LSAPR_TRANSLATED_NAME with IDL{IndirectionLevel = 1};

type LSAPR_TRANSLATED_NAMES_EX
{
    IDLUlong Entries with IDL{Range = new RangePattern{Low = 0, High = 20480}};
    array<PLSAPR_TRANSLATED_NAME_EX> Names with IDL{Size_is = [Entries]};
}

typedef PLSAPR_TRANSLATED_NAMES_EX = LSAPR_TRANSLATED_NAMES_EX with IDL{IndirectionLevel = 1};

type LSAPR_TRANSLATED_NAME_EX
{
    SID_NAME_USE Use;
    RPC_UNICODE_STRING Name;
    IDLLong DomainIndex where ValidationCheckGreaterThanOrEqualTo(value >= -1, null, true, ReferenceType.Type,
        "LSA", "DomainIndex", "LSAPR_TRANSLATED_NAME_EX", -1, value);
    LSAPR_TRANSLATED_NAME_EX_Flags Flags 
        where ValidationCheckCombinationValue(InRange<LSAPR_TRANSLATED_NAME_EX_Flags>(value), null, true, ReferenceType.Type,
            "LSA", "Flags", "LSAPR_TRANSLATED_NAME_EX", "0x00000001, 0x00000002, 0x00000004", value)
        with Encoding{Decoder = PatternDecoder<LSAPR_TRANSLATED_NAME_EX_Flags>, SourcePattern = TypeOf<IDLUlong>()};
}

typedef PLSAPR_TRANSLATED_NAME_EX = LSAPR_TRANSLATED_NAME_EX with IDL{IndirectionLevel = 1};

type LSAPR_TRANSLATED_SIDS_EX
{
    IDLUlong Entries with IDL{Range = new RangePattern{Low = 0, High = 1000}};
    array<PLSAPR_TRANSLATED_SID_EX> Sids with IDL{Size_is = [Entries]};
}

typedef PLSAPR_TRANSLATED_SIDS_EX = LSAPR_TRANSLATED_SIDS_EX with IDL{IndirectionLevel = 1};

type LSAPR_TRANSLATED_SID_EX
{
    SID_NAME_USE Use;
    IDLUlong RelativeId;
    IDLLong DomainIndex where ValidationCheckGreaterThanOrEqualTo(value >= -1, null, true, ReferenceType.Type,
        "LSA", "DomainIndex", "LSAPR_TRANSLATED_SID_EX", -1, value);
    LSAPR_TRANSLATED_SID_EX_Flags Flags 
        where ValidationCheckCombinationValue(InRange<LSAPR_TRANSLATED_SID_EX_Flags>(value), null, true, ReferenceType.Type,
        "LSA", "Flags", "LSAPR_TRANSLATED_SID_EX", "0x00000001, 0x00000002, 0x00000004", value)
        with Encoding{Decoder = PatternDecoder<LSAPR_TRANSLATED_SID_EX_Flags>, SourcePattern = TypeOf<IDLUlong>()};
}

typedef PLSAPR_TRANSLATED_SID_EX = LSAPR_TRANSLATED_SID_EX with IDL{IndirectionLevel = 1};

type LSAPR_TRANSLATED_SIDS_EX2
{
    IDLUlong Entries with IDL{Range = new RangePattern{Low = 0, High = 1000}};
    array<PLSAPR_TRANSLATED_SID_EX2> Sids with IDL{Size_is = [Entries]};
}

typedef PLSAPR_TRANSLATED_SIDS_EX2 = LSAPR_TRANSLATED_SIDS_EX2 with IDL{IndirectionLevel = 1};

type LSAPR_TRANSLATED_SID_EX2
{
    SID_NAME_USE Use;
    PRPC_SID Sid;
    IDLLong DomainIndex where ValidationCheckGreaterThanOrEqualTo(value >= -1, null, true, ReferenceType.Type,
        "LSA", "DomainIndex", "LSAPR_TRANSLATED_SID_EX", -1, value);
    LSAPR_TRANSLATED_SID_EX2_Flags Flags 
        where ValidationCheckCombinationValue(InRange<LSAPR_TRANSLATED_SID_EX2_Flags>(value), null, true, ReferenceType.Type,
            "LSA", "Flags", "LSAPR_TRANSLATED_SID_EX2", "0x00000001, 0x00000002, 0x00000004", value)
        with Encoding{Decoder = PatternDecoder<LSAPR_TRANSLATED_SID_EX2_Flags>, SourcePattern = TypeOf<IDLUlong>()};
}

typedef PLSAPR_TRANSLATED_SID_EX2 = LSAPR_TRANSLATED_SID_EX2 with IDL{IndirectionLevel = 1};

type RPC_SID_IDENTIFIER_AUTHORITY
{
    // no decoding because it always NULL
    array<UCHAR> Value 
        where ValidationCheck((value as binary) is SidIdentifierAuthorityValue, null, LSA_SID_IDENTIFIER_AUTHORITY) 
        with IDL{Dimensions = [6]};
} with IDL{DoNotGenerate = true};

type LSAPR_PRIVILEGE_ENUM_BUFFER
{
    IDLUlong Entries;
    array<LSAPR_POLICY_PRIVILEGE_DEF> Privileges
        with IDL{Size_is = [Entries], IndirectionLevel = 1};
}

typedef PLSAPR_PRIVILEGE_ENUM_BUFFER = LSAPR_PRIVILEGE_ENUM_BUFFER with IDL{IndirectionLevel = 1, DoNotGenerate = true};

type LSAPR_POLICY_PRIVILEGE_DEF
{
    RPC_UNICODE_STRING Name;
    LUID LocalValue;
}

typedef PLSAPR_POLICY_PRIVILEGE_DEF = LSAPR_POLICY_PRIVILEGE_DEF with IDL{IndirectionLevel = 1, DoNotGenerate = true};

type LSAPR_SR_SECURITY_DESCRIPTOR
{
    IDLUlong Length with IDL{Range = new RangePattern{Low = 0, High = 262144}};
    SECURITY_DESCRIPTOR_NonRpc SecurityDescriptor with IDL{Size_is = [Length], IndirectionLevel = 1},
        Encoding{Decoder = BinaryDecoder<SECURITY_DESCRIPTOR_NonRpc>, SourcePattern = TypeOf<array<UCHAR>>()};
}

typedef PLSAPR_SR_SECURITY_DESCRIPTOR = LSAPR_SR_SECURITY_DESCRIPTOR with IDL{IndirectionLevel = 1, DoNotGenerate = true};

pattern POLICY_INFORMATION_CLASS = enum 
{
    PolicyAuditLogInformation = 1,
    PolicyAuditEventsInformation = 2,
    PolicyPrimaryDomainInformation = 3,
    PolicyPdAccountInformation = 4,
    PolicyAccountDomainInformation = 5,
    PolicyLsaServerRoleInformation = 6,
    PolicyReplicaSourceInformation = 7,
    PolicyInformationNotUsedOnWire = 8,
    PolicyModificationInformation = 9,
    PolicyAuditFullSetInformation = 10,
    PolicyAuditFullQueryInformation = 11,
    PolicyDnsDomainInformation = 12,
    PolicyDnsDomainInformationInt = 13,
    PolicyLocalAccountDomainInformation = 14,
    PolicyLastEntry = 15,
    ...
};

type LSAPR_POLICY_INFORMATION[POLICY_INFORMATION_CLASS InfoClass]
{
    optional [|InfoClass == 1|] POLICY_AUDIT_LOG_INFO PolicyAuditLogInfo
        with IDL{Case = [1]};
    optional [|InfoClass == 2|] LSAPR_POLICY_AUDIT_EVENTS_INFO PolicyAuditEventsInfo
        with IDL{Case = [(2)]};
    optional [|InfoClass == 3|] LSAPR_POLICY_PRIMARY_DOM_INFO PolicyPrimaryDomainInfo
        with IDL{Case = [(3)]};
    optional [|InfoClass == 5|] LSAPR_POLICY_ACCOUNT_DOM_INFO PolicyAccountDomainInfo
        with IDL{Case = [(5)]};
    optional [|InfoClass == 4|] LSAPR_POLICY_PD_ACCOUNT_INFO PolicyPdAccountInfo
        with IDL{Case = [(4)]};
    optional [|InfoClass == 6|] POLICY_LSA_SERVER_ROLE_INFO PolicyServerRoleInfo
        with IDL{Case = [(6)]};
    optional [|InfoClass == 7|] LSAPR_POLICY_REPLICA_SRCE_INFO PolicyReplicaSourceInfo
        with IDL{Case = [(7)]};
    optional [|InfoClass == 9|] POLICY_MODIFICATION_INFO PolicyModificationInfo
        with IDL{Case = [(9)]};
    optional [|InfoClass == 10|] POLICY_AUDIT_FULL_SET_INFO PolicyAuditFullSetInfo
        with IDL{Case = [(10)]};
    optional [|InfoClass == 11|] POLICY_AUDIT_FULL_QUERY_INFO PolicyAuditFullQueryInfo
        with IDL{Case = [(11)]};
    optional [|InfoClass == 12|] LSAPR_POLICY_DNS_DOMAIN_INFO PolicyDnsDomainInfo
        with IDL{Case = [(12)]};
    optional [|InfoClass == 13|] LSAPR_POLICY_DNS_DOMAIN_INFO PolicyDnsDomainInfoInt
        with IDL{Case = [(13)]};
    optional [|InfoClass == 14|] LSAPR_POLICY_ACCOUNT_DOM_INFO PolicyLocalAccountDomainInfo
        with IDL{Case = [(14)]};
}
with IDL{Switch_Type = TypeOf<POLICY_INFORMATION_CLASS>(),
                          UnionKind = UnionKind.NonEncapsulated};

typedef PLSAPR_POLICY_INFORMATION = LSAPR_POLICY_INFORMATION with IDL{IndirectionLevel = 1, DoNotGenerate = true};

type POLICY_AUDIT_LOG_INFO
{
    IDLUlong AuditLogPercentFull;
    IDLUlong MaximumLogSize;
    LARGE_INTEGER AuditRetentionPeriod;
    UCHAR AuditLogFullShutdownInProgress;
    LARGE_INTEGER TimeToShutdown;
    IDLUlong NextAuditRecordId;
}

type LSAPR_POLICY_AUDIT_EVENTS_INFO
{
    UCHAR AuditingMode with DisplayInfo{ToText = LogIsFullToString};
    array<EventAuditingOptionPattern> EventAuditingOptions
        where ValidationCheckEventAuditingOptions(value)
        with Encoding
            {
                Decoder = BinaryDecoder<array<EventAuditingOptionPattern>>,
                SourceConverter = ConvertArrayUint2Binary,
                SourcePattern = TypeOf<array<IDLUlong>>()
            },
            IDL{Size_is = [MaximumAuditEventCount], IndirectionLevel = 1},
            BinaryEncoding{Endian = Endian.Little};
    IDLUlong MaximumAuditEventCount with IDL{Range = new RangePattern{Low = 0, High = 1000}};
}

type LSAPR_POLICY_PRIMARY_DOM_INFO
{
    RPC_UNICODE_STRING Name;
    RPC_SID Sid with IDL{IndirectionLevel = 1};
}

type LSAPR_POLICY_ACCOUNT_DOM_INFO
{
    RPC_UNICODE_STRING DomainName;
    RPC_SID DomainSid
        where ValidationCheck(value != null, null, DiagnosisLevel.Error, LSA_SID_NOT_NULL) 
        with IDL{IndirectionLevel = 1};
}

type LSAPR_POLICY_PD_ACCOUNT_INFO
{
    RPC_UNICODE_STRING Name;
}

type POLICY_LSA_SERVER_ROLE_INFO
{
    POLICY_LSA_SERVER_ROLE LsaServerRole;
}

pattern POLICY_LSA_SERVER_ROLE = enum 
{
    PolicyServerRoleBackup = 2,
    PolicyServerRolePrimary = 3,
    ...
};

type LSAPR_POLICY_REPLICA_SRCE_INFO
{
    RPC_UNICODE_STRING ReplicaSource;
    RPC_UNICODE_STRING ReplicaAccountName;
}

type POLICY_MODIFICATION_INFO
{
    LARGE_INTEGER ModifiedId;
    LARGE_INTEGER DatabaseCreationTime;
}

type POLICY_AUDIT_FULL_SET_INFO
{
    UCHAR ShutDownOnFull with DisplayInfo{ToText = ShutDownOnFullToString};
}

type POLICY_AUDIT_FULL_QUERY_INFO
{
    UCHAR ShutDownOnFull with DisplayInfo{ToText = ShutDownOnFullToString};
    UCHAR LogIsFull with DisplayInfo{ToText = LogIsFullToString};
}

type LSAPR_POLICY_DNS_DOMAIN_INFO
{
    RPC_UNICODE_STRING Name;
    RPC_UNICODE_STRING DnsDomainName;
    RPC_UNICODE_STRING DnsForestName;
    GUID DomainGuid;
    PRPC_SID Sid;
}

type LSAPR_ACCOUNT_ENUM_BUFFER
{
    IDLUlong EntriesRead;
    array<LSAPR_ACCOUNT_INFORMATION> Information
        with IDL{Size_is = [EntriesRead], IndirectionLevel = 1};
}

typedef PLSAPR_ACCOUNT_ENUM_BUFFER = LSAPR_ACCOUNT_ENUM_BUFFER with IDL{IndirectionLevel = 1, DoNotGenerate = true};

type LSAPR_ACCOUNT_INFORMATION
{
    PRPC_SID Sid;
}

typedef LSAPR_TRUSTED_DOMAIN_INFORMATION_BASIC = LSAPR_TRUST_INFORMATION;

type LSAPR_TRUSTED_ENUM_BUFFER
{
    IDLUlong EntriesRead;
    array<LSAPR_TRUSTED_DOMAIN_INFORMATION_BASIC> Information
        with IDL{Size_is = [EntriesRead], IndirectionLevel = 1};
}

typedef PLSAPR_TRUSTED_ENUM_BUFFER = LSAPR_TRUSTED_ENUM_BUFFER with IDL{IndirectionLevel = 1, DoNotGenerate = true};

typedef LSA_UNICODE_STRING = RPC_UNICODE_STRING;
typedef PLSA_UNICODE_STRING = LSA_UNICODE_STRING with IDL{IndirectionLevel = 1, DoNotGenerate = true};

type LSAPR_PRIVILEGE_SET
{
    IDLUlong PrivilegeCount
        with IDL{Range = new RangePattern{Low = 0, High = 1000}};
    ControlPattern Control
        where ValidationCheckCombinationValue(InRange<ControlPattern>(value), null, false, ReferenceType.Type,
            "LSA", "Control", "LSAPR_PRIVILEGE_SET", "0x00000001", value)
        with Encoding{Decoder = PatternDecoder<ControlPattern>, SourcePattern = TypeOf<IDLUlong>()};
    array<LSAPR_LUID_AND_ATTRIBUTES> Privilege
        with IDL{Size_is = [PrivilegeCount], Dimensions = [null]};
}

typedef PLSAPR_PRIVILEGE_SET = LSAPR_PRIVILEGE_SET with IDL{IndirectionLevel = 1, DoNotGenerate = true};

type LSAPR_LUID_AND_ATTRIBUTES
{
    LUID Luid;
    AttributesPattern Attributes 
        where ValidationCheckCombinationValue(InRange<AttributesPattern>(value), null, false, ReferenceType.Type,
                    "LSA", "Attributes", "LSAPR_LUID_AND_ATTRIBUTES", "0x00000001, 0x00000002", value)
        with Encoding{Decoder = PatternDecoder<AttributesPattern>, SourcePattern = TypeOf<IDLUlong>()};
}

pattern TRUSTED_INFORMATION_CLASS = enum 
{
    TrustedDomainNameInformation = 1,
    TrustedControllersInformation = 2,
    TrustedPosixOffsetInformation = 3,
    TrustedPasswordInformation = 4,
    TrustedDomainInformationBasic = 5,
    TrustedDomainInformationEx = 6,
    TrustedDomainAuthInformation = 7,
    TrustedDomainFullInformation = 8,
    TrustedDomainAuthInformationInternal = 9,
    TrustedDomainFullInformationInternal = 10,
    TrustedDomainInformationEx2Internal = 11,
    TrustedDomainFullInformation2Internal = 12,
    TrustedDomainSupportedEncryptionTypes = 13,
    ...
};

type LSAPR_TRUSTED_DOMAIN_INFO[TRUSTED_INFORMATION_CLASS InfoClass]
{
    optional [|InfoClass == 1|] LSAPR_TRUSTED_DOMAIN_NAME_INFO TrustedDomainNameInfo
        with IDL{Case = [1]};
    optional [|InfoClass == 2|] LSAPR_TRUSTED_CONTROLLERS_INFO TrustedControllersInfo
        with IDL{Case = [(2)]};
    optional [|InfoClass == 3|] TRUSTED_POSIX_OFFSET_INFO TrustedPosixOffsetInfo
        with IDL{Case = [(3)]};
    optional [|InfoClass == 4|] LSAPR_TRUSTED_PASSWORD_INFO TrustedPasswordInfo
        with IDL{Case = [(4)]};
    optional [|InfoClass == 5|] LSAPR_TRUSTED_DOMAIN_INFORMATION_BASIC TrustedDomainInfoBasic
        with IDL{Case = [(5)]};
    optional [|InfoClass == 6|] LSAPR_TRUSTED_DOMAIN_INFORMATION_EX TrustedDomainInfoEx
        with IDL{Case = [(6)]};
    optional [|InfoClass == 7|] LSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION TrustedAuthInfo
        with IDL{Case = [(7)]};
    optional [|InfoClass == 8|] LSAPR_TRUSTED_DOMAIN_FULL_INFORMATION TrustedFullInfo
        with IDL{Case = [(8)]};
    optional [|InfoClass == 9|] LSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION_INTERNAL TrustedAuthInfoInternal
        with IDL{Case = [(9)]};
    optional [|InfoClass == 10|] LSAPR_TRUSTED_DOMAIN_FULL_INFORMATION_INTERNAL TrustedFullInfoInternal
        with IDL{Case = [(10)]};
    optional [|InfoClass == 11|] LSAPR_TRUSTED_DOMAIN_INFORMATION_EX2 TrustedDomainInfoEx2
        with IDL{Case = [(11)]};
    optional [|InfoClass == 12|] LSAPR_TRUSTED_DOMAIN_FULL_INFORMATION2 TrustedFullInfo2
        with IDL{Case = [(12)]};
    optional [|InfoClass == 13|] TRUSTED_DOMAIN_SUPPORTED_ENCRYPTION_TYPES TrustedDomainSETs
        with IDL{Case = [(13)]};
}
with IDL{Switch_Type = TypeOf<TRUSTED_INFORMATION_CLASS>(),
                          UnionKind = UnionKind.NonEncapsulated};

typedef PLSAPR_TRUSTED_DOMAIN_INFO = LSAPR_TRUSTED_DOMAIN_INFO with IDL{IndirectionLevel = 1, DoNotGenerate = true};

type LSAPR_TRUSTED_DOMAIN_NAME_INFO
{
    RPC_UNICODE_STRING Name;
}

type LSAPR_TRUSTED_CONTROLLERS_INFO
{
    IDLUlong Entries
        with IDL{Range = new RangePattern{Low = 0, High = 5}};
    array<LSA_UNICODE_STRING> Names
        with IDL{Size_is = [Entries], IndirectionLevel = 1};
}

type TRUSTED_POSIX_OFFSET_INFO
{
    IDLUlong Offset;
}

type LSAPR_TRUSTED_PASSWORD_INFO
{
    LSAPR_CR_CIPHER_VALUE Password
        with IDL{IndirectionLevel = 1};
    LSAPR_CR_CIPHER_VALUE OldPassword
        with IDL{IndirectionLevel = 1};
}

type LSAPR_CR_CIPHER_VALUE
{
    IDLUlong Length with IDL{Range = new RangePattern{Low = 0, High = 131088}};
    IDLUlong MaximumLength with IDL{Range = new RangePattern{Low = 0, High = 131088}};
    // no decoding because data in it is encrypted
    array<UCHAR> Buffer with IDL{Size_is = [MaximumLength], Length_is = [Length], IndirectionLevel = 1};
}

typedef PLSAPR_CR_CIPHER_VALUE = LSAPR_CR_CIPHER_VALUE with IDL{IndirectionLevel = 1, DoNotGenerate = true};

type LSAPR_TRUSTED_DOMAIN_INFORMATION_EX
{
    RPC_UNICODE_STRING Name;
    RPC_UNICODE_STRING FlatName;
    PRPC_SID Sid;
    TrustDirectionPattern TrustDirection 
        where ValidationCheckEnumValue(InRange<TrustDirectionPattern>(value), null, false, ReferenceType.Type,
                    "LSA", "TrustDirection", "LSAPR_TRUSTED_DOMAIN_INFORMATION_EX", "0x00000001, 0x00000002", value)
        with Encoding{Decoder = PatternDecoder<TrustDirectionPattern>, SourcePattern = TypeOf<IDLUlong>()};
    TrustTypePattern TrustType
        where ValidationCheckValueInRange(InRange<TrustTypePattern>(value), null, false, ReferenceType.Type,
            "LSA", "TrustType", "LSAPR_TRUSTED_DOMAIN_INFORMATION_EX", "0x00000001", "0x00000004", value)
        with Encoding{Decoder = PatternDecoder<TrustTypePattern>, SourcePattern = TypeOf<IDLUlong>()};
    TrustAttributesPattern TrustAttributes
        where ValidationCheckCombinationValueTooManyItems(InRange<TrustAttributesPattern>(value), null, false, ReferenceType.Type,
                "LSA", "TrustAttributes", "LSAPR_TRUSTED_DOMAIN_INFORMATION_EX", "TrustAttributes", "[MS-LSAD]")
        with Encoding{Decoder = PatternDecoder<TrustAttributesPattern>, SourcePattern = TypeOf<IDLUlong>()};
}

typedef PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX = LSAPR_TRUSTED_DOMAIN_INFORMATION_EX with IDL{IndirectionLevel = 1, DoNotGenerate = true};

type LSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION
{
    IDLUlong IncomingAuthInfos with IDL{Range = new RangePattern{Low = 0, High = 1}};
    PLSAPR_AUTH_INFORMATION IncomingAuthenticationInformation;
    PLSAPR_AUTH_INFORMATION IncomingPreviousAuthenticationInformation;
    IDLUlong OutgoingAuthInfos
        with IDL{Range = new RangePattern{Low = 0, High = 1}};
    PLSAPR_AUTH_INFORMATION OutgoingAuthenticationInformation;
    PLSAPR_AUTH_INFORMATION OutgoingPreviousAuthenticationInformation;
}

typedef PLSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION = LSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION with IDL{IndirectionLevel = 1, DoNotGenerate = true};

type LSAPR_AUTH_INFORMATION
{
    LARGE_INTEGER LastUpdateTime;
    AuthTypePattern AuthType
        where ValidationCheckValueInRange(InRange<AuthTypePattern>(value), null, false, ReferenceType.Type,
            "LSA", "AuthType", "LSAPR_AUTH_INFORMATION", "0x00000000", "0x00000003", value)
        with Encoding{Decoder = PatternDecoder<AuthTypePattern>, SourcePattern = TypeOf<IDLUlong>()};
    IDLUlong AuthInfoLength
        with IDL{Range = new RangePattern{Low = 0, High = 65536}};
    ([|AuthType == 1 || AuthType == 2|] string 
    | [|AuthType == 3|] uint
    | binary) AuthInfo
        with IDL{Size_is = [AuthInfoLength], IndirectionLevel = 1},
            Encoding{Decoder = BinaryDecoder<string|uint|binary>, SourcePattern = TypeOf<array<UCHAR>>()},
            BinaryEncoding{TextEncoding = TextEncoding.Unicode};
}

typedef PLSAPR_AUTH_INFORMATION = LSAPR_AUTH_INFORMATION with IDL{IndirectionLevel = 1, DoNotGenerate = true};

type LSAPR_TRUSTED_DOMAIN_FULL_INFORMATION
{
    LSAPR_TRUSTED_DOMAIN_INFORMATION_EX Information;
    TRUSTED_POSIX_OFFSET_INFO PosixOffset;
    LSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION AuthInformation;
}

type LSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION_INTERNAL
{
    LSAPR_TRUSTED_DOMAIN_AUTH_BLOB AuthBlob;
}

typedef PLSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION_INTERNAL = LSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION_INTERNAL with IDL{IndirectionLevel = 1, DoNotGenerate = true};

type LSAPR_TRUSTED_DOMAIN_AUTH_BLOB
{
    IDLUlong AuthSize
        with IDL{Range = new RangePattern{Low = 0, High = 65536}};
    // no decoding because data in it is encrypted
    array<UCHAR> AuthBlob with IDL{Size_is = [AuthSize], IndirectionLevel = 1};
}

type LSAPR_TRUSTED_DOMAIN_FULL_INFORMATION_INTERNAL
{
    LSAPR_TRUSTED_DOMAIN_INFORMATION_EX Information;
    TRUSTED_POSIX_OFFSET_INFO PosixOffset;
    LSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION_INTERNAL AuthInformation;
}

type LSAPR_TRUSTED_DOMAIN_INFORMATION_EX2
{
    RPC_UNICODE_STRING Name;
    RPC_UNICODE_STRING FlatName;
    RPC_SID Sid with IDL{IndirectionLevel = 1};
    TrustDirectionPattern TrustDirection
        where ValidationCheckEnumValue(InRange<TrustDirectionPattern>(value), null, false, ReferenceType.Type,
                    "LSA", "TrustDirection", "LSAPR_TRUSTED_DOMAIN_INFORMATION_EX2", "0x00000001, 0x00000002", value)
        with Encoding{Decoder = PatternDecoder<TrustDirectionPattern>, SourcePattern = TypeOf<IDLUlong>()};
    TrustTypePattern TrustType
        where ValidationCheckValueInRange(InRange<TrustTypePattern>(value), null, false, ReferenceType.Type,
            "LSA", "TrustType", "LSAPR_TRUSTED_DOMAIN_INFORMATION_EX2", "0x00000001", "0x00000004", value)
        with Encoding{Decoder = PatternDecoder<TrustTypePattern>, SourcePattern = TypeOf<IDLUlong>()};
    TrustAttributesPattern TrustAttributes
        where ValidationCheckCombinationValueTooManyItems(InRange<TrustAttributesPattern>(value), null, false, ReferenceType.Type,
                "LSA", "TrustAttributes", "LSAPR_TRUSTED_DOMAIN_INFORMATION_EX2", "TrustAttributes", "[MS-LSAD]")
        with Encoding{Decoder = PatternDecoder<TrustAttributesPattern>, SourcePattern = TypeOf<IDLUlong>()};
    IDLUlong ForestTrustLength;
    LSA_FOREST_TRUST_INFORMATION ForestTrustInfo with IDL{Size_is = [ForestTrustLength], IndirectionLevel = 1},
        Encoding{Decoder = NdrDecoderFromStream<LSA_FOREST_TRUST_INFORMATION>, SourcePattern = TypeOf<array<UCHAR>>()};
}

type LSAPR_TRUSTED_DOMAIN_FULL_INFORMATION2
{
    LSAPR_TRUSTED_DOMAIN_INFORMATION_EX2 Information;
    TRUSTED_POSIX_OFFSET_INFO PosixOffset;
    LSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION AuthInformation;
}

type TRUSTED_DOMAIN_SUPPORTED_ENCRYPTION_TYPES
{
    SupportedEncryptionTypesPattern SupportedEncryptionTypes
        where ValidationCheckCombinationValueTooManyItems(InRange<SupportedEncryptionTypesPattern>(value), null, false, ReferenceType.Type,
                    "LSA", "SupportedEncryptionTypes", "TRUSTED_DOMAIN_SUPPORTED_ENCRYPTION_TYPES", "TRUSTED_DOMAIN_SUPPORTED_ENCRYPTION_TYPES", "[MS-LSAD]")
        with Encoding{Decoder = PatternDecoder<SupportedEncryptionTypesPattern>, SourcePattern = TypeOf<IDLUlong>()};
}

type LSAPR_USER_RIGHT_SET
{
    IDLUlong Entries
        with IDL{Range = new RangePattern{Low = 0, High = 256}};
    array<LSA_UNICODE_STRING> UserRights
        with IDL{Size_is = [Entries], IndirectionLevel = 1};
}

typedef PLSAPR_USER_RIGHT_SET = LSAPR_USER_RIGHT_SET with IDL{IndirectionLevel = 1, DoNotGenerate = true};

type LSAPR_TRUSTED_ENUM_BUFFER_EX
{
    IDLUlong EntriesRead;
    array<LSAPR_TRUSTED_DOMAIN_INFORMATION_EX> EnumerationBuffer
        with IDL{Size_is = [EntriesRead], IndirectionLevel = 1};
}

typedef PLSAPR_TRUSTED_ENUM_BUFFER_EX = LSAPR_TRUSTED_ENUM_BUFFER_EX with IDL{IndirectionLevel = 1, DoNotGenerate = true};

pattern POLICY_DOMAIN_INFORMATION_CLASS = enum 
{
    PolicyDomainQualityOfServiceInformation = 1,
    PolicyDomainEfsInformation = 2,
    PolicyDomainKerberosTicketInformation = 3,
    ...
};

type LSAPR_POLICY_DOMAIN_INFORMATION[POLICY_DOMAIN_INFORMATION_CLASS InfoClass]
{
    optional [|InfoClass in {1}|] POLICY_DOMAIN_QUALITY_OF_SERVICE_INFO PolicyDomainQualityOfServiceInfo
        with IDL{Case = [1]};
    optional [|InfoClass in {2}|] LSAPR_POLICY_DOMAIN_EFS_INFO PolicyDomainEfsInfo
        with IDL{Case = [2]};
    optional [|InfoClass in {3}|] POLICY_DOMAIN_KERBEROS_TICKET_INFO PolicyDomainKerbTicketInfo
        with IDL{Case = [3]};
}
with IDL{Switch_Type = TypeOf<POLICY_DOMAIN_INFORMATION_CLASS>(),
                          UnionKind = UnionKind.NonEncapsulated};
                          
typedef PLSAPR_POLICY_DOMAIN_INFORMATION = LSAPR_POLICY_DOMAIN_INFORMATION with IDL{IndirectionLevel = 1, DoNotGenerate = true};

type POLICY_DOMAIN_QUALITY_OF_SERVICE_INFO
{
    IDLUlong QualityOfService
        where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type,
                    "LSA", "QualityOfService", "POLICY_DOMAIN_QUALITY_OF_SERVICE_INFO", value);
}

type LSAPR_POLICY_DOMAIN_EFS_INFO
{
    IDLUlong InfoLength;
    (GPEF.EfsBlob | binary) EfsBlob with IDL{Size_is = [InfoLength], IndirectionLevel = 1},
        Encoding{Decoder = EfsBlobDecoder, SourcePattern = TypeOf<array<UCHAR>>()};
        
    optional (GPEF.EfsBlob | binary) EfsBlobDecoder(binary b)
    {
        if (BinaryDecoder<EfsBlob>(b) is efsBlob:EfsBlob)
        {
            return efsBlob;
        }
        else
        {
            return b;
        }
    }
}

type POLICY_DOMAIN_KERBEROS_TICKET_INFO
{
    AuthenticationOptionsPattern AuthenticationOptions
        where ValidationCheckCombinationValue(InRange<AuthenticationOptionsPattern>(value), null, false, ReferenceType.Type,
                    "LSA", "AuthenticationOptions", "POLICY_DOMAIN_KERBEROS_TICKET_INFO", "0x00000080", value)
        with Encoding{Decoder = PatternDecoder<AuthenticationOptionsPattern>, SourcePattern = TypeOf<IDLUlong>()};
    LARGE_INTEGER MaxServiceTicketAge;
    LARGE_INTEGER MaxTicketAge;
    LARGE_INTEGER MaxRenewAge;
    LARGE_INTEGER MaxClockSkew;
    LARGE_INTEGER Reserved;
}

pattern LSA_FOREST_TRUST_RECORD_TYPE = enum 
{
    ForestTrustTopLevelName = 0,
    ForestTrustTopLevelNameEx = 1,
    ForestTrustDomainInfo = 2,
    ...
};

type LSA_FOREST_TRUST_INFORMATION
{
    IDLUlong RecordCount
        with IDL{Range = new RangePattern{Low = 0, High = 4000}};
    array<LSA_FOREST_TRUST_RECORD> Entries with IDL{Size_is = [RecordCount, null], IndirectionLevel = 2};
}

typedef PLSA_FOREST_TRUST_INFORMATION = LSA_FOREST_TRUST_INFORMATION with IDL{IndirectionLevel = 1, DoNotGenerate = true};

type LSA_FOREST_TRUST_RECORD
{
    IDLUlong Flags with DisplayInfo{ToText = FlagsToString};
    LSA_FOREST_TRUST_RECORD_TYPE ForestTrustType;
    LARGE_INTEGER Time;
    __MIDL_lsarpc_0001[ForestTrustType] ForestTrustData
        with IDL{Switch_Is = ForestTrustType, EmbedType = true};
    
    string FlagsToString(any input)
    {
        if (input is v:IDLUlong && v == 0x0000FFFF)
        {
            return "LSA_FTRECORD_DISABLED_REASONS";
        }
        switch (ForestTrustType)
        {
            case LSA_FOREST_TRUST_RECORD_TYPE.ForestTrustDomainInfo =>
                return EnumToString(input, "LSA.ForestTrustDomainInfoFlagsPattern");
            case LSA_FOREST_TRUST_RECORD_TYPE.ForestTrustTopLevelName =>
                return EnumToString(input, "LSA.ForestTrustTopLevelNameFlagsPattern");
            case LSA_FOREST_TRUST_RECORD_TYPE.ForestTrustTopLevelNameEx =>
                return EnumToString(input, "LSA.ForestTrustTopLevelNameFlagsPattern");
            default =>
                return input as string;
        }
    }
}

type __MIDL_lsarpc_0001[LSA_FOREST_TRUST_RECORD_TYPE Tag]
{
    optional [|Tag in {0, 1}|] LSA_UNICODE_STRING TopLevelName
        with IDL{Case = [0, 1]};
    optional [|Tag in {2}|] LSA_FOREST_TRUST_DOMAIN_INFO DomainInfo
        with IDL{Case = [2]};
    optional [|!(Tag in {0, 1, 2})|] LSA_FOREST_TRUST_BINARY_DATA Data
        with IDL{Default = true};
}
with IDL
{
    Switch_Type = TypeOf<LSA_FOREST_TRUST_RECORD_TYPE>(),
    UnionKind = UnionKind.NonEncapsulated
};

type LSA_FOREST_TRUST_DOMAIN_INFO
{
    RPC_SID Sid with IDL{IndirectionLevel = 1};
    LSA_UNICODE_STRING DnsName;
    LSA_UNICODE_STRING NetbiosName;
}

type LSA_FOREST_TRUST_BINARY_DATA
{
    IDLUlong Length
        with IDL{Range = new RangePattern{Low = 0, High = 131072}};
    // no decoding because the format is not specified in document
    array<UCHAR> Buffer with IDL{Size_is = [Length], IndirectionLevel = 1};
}

type LSA_FOREST_TRUST_COLLISION_INFORMATION
{
    IDLUlong RecordCount;
    array<PLSA_FOREST_TRUST_COLLISION_RECORD> Entries
        with IDL{Size_is = [RecordCount, null], IndirectionLevel = 1};
}

typedef PLSA_FOREST_TRUST_COLLISION_INFORMATION = LSA_FOREST_TRUST_COLLISION_INFORMATION with IDL{IndirectionLevel = 1, DoNotGenerate = true};

type LSA_FOREST_TRUST_COLLISION_RECORD
{
    IDLUlong Index;
    LSA_FOREST_TRUST_COLLISION_RECORD_TYPE Type;
    LsaForeastTrustCollisionRecordFlagsPattern Flags
        where ValidationCheckCombinationValue(InRange<LsaForeastTrustCollisionRecordFlagsPattern>(value), null, false, ReferenceType.Type,
                    "LSA", "Flags", "LSA_FOREST_TRUST_COLLISION_RECORD", "0x00000002, 0x00000004", value)
        with Encoding{Decoder = PatternDecoder<LsaForeastTrustCollisionRecordFlagsPattern>, SourcePattern = TypeOf<IDLUlong>()};
    LSA_UNICODE_STRING Name;
}

typedef PLSA_FOREST_TRUST_COLLISION_RECORD = LSA_FOREST_TRUST_COLLISION_RECORD with IDL{IndirectionLevel = 1, DoNotGenerate = true};

pattern LSA_FOREST_TRUST_COLLISION_RECORD_TYPE = enum 
{
    CollisionTdo = 0,
    CollisionXref = 1,
    CollisionOther = 2,
    ...
};

// ------------------------------------ Pattern for display and validation check ---------------------
pattern LSAPR_TRANSLATED_SID_EX_Flags = flags IDLUlong
{
    $"The name was not found by matching against the Security Principal Name property" = 0x00000001,
    $"The name might be found by traversing a forest trust" = 0x00000002,
    $"The name was found by matching against the last database view" = 0x00000004,
    ...
} with IDL{DoNotGenerate = true};

pattern LSAPR_TRANSLATED_SID_EX2_Flags = flags IDLUlong
{
    $"The name was not found by matching against the Security Principal Name property" = 0x00000001,
    $"The name might be found by traversing a forest trust" = 0x00000002,
    $"The name was found by matching against the last database view" = 0x00000004,
    ...
} with IDL{DoNotGenerate = true};

pattern LSAPR_TRANSLATED_NAME_EX_Flags = flags IDLUlong
{
    $"The SID was not found by matching against the security principal SID property" = 0x00000001,
    $"The SID might be found by traversing a forest trust" = 0x00000002,
    $"The SID was found by matching against the last database view" = 0x00000004,
    ...
} with IDL{DoNotGenerate = true};

pattern AccessMaskForPolicyObjects = flags ACCESS_MASK
{
    GENERIC_READ = 0x80000000,
    GENERIC_WRITE = 0x40000000,
    GENERIC_EXECUTE = 0x20000000,
    GENERIC_ALL = 0x10000000,
    MAXIMUM_ALLOWED = 0x02000000,
    ACCESS_SYSTEM_SECURITY = 0x01000000,
    SYNCHRONIZE = 0x00100000,
    WRITE_OWNER = 0x00080000,
    WRITE_DACL = 0x00040000,
    READ_CONTROL = 0x00020000,
    DELETE = 0x00010000,
    POLICY_VIEW_LOCAL_INFORMATION = 0x00000001,
    POLICY_VIEW_AUDIT_INFORMATION = 0x00000002,
    POLICY_GET_PRIVATE_INFORMATION = 0x00000004,
    POLICY_TRUST_ADMIN = 0x00000008,
    POLICY_CREATE_ACCOUNT = 0x00000010,
    POLICY_CREATE_SECRET = 0x00000020,
    POLICY_CREATE_PRIVILEGE = 0x00000040,
    POLICY_SET_DEFAULT_QUOTA_LIMITS = 0x00000080,
    POLICY_SET_AUDIT_REQUIREMENTS = 0x00000100,
    POLICY_AUDIT_LOG_ADMIN = 0x00000200,
    POLICY_SERVER_ADMIN = 0x00000400,
    POLICY_LOOKUP_NAMES = 0x00000800,
    POLICY_NOTIFICATION = 0x00001000,
    ...
} with IDL{DoNotGenerate = true};

pattern AccessMaskForAccountObjects = flags ACCESS_MASK
{
    GENERIC_READ = 0x80000000,
    GENERIC_WRITE = 0x40000000,
    GENERIC_EXECUTE = 0x20000000,
    GENERIC_ALL = 0x10000000,
    MAXIMUM_ALLOWED = 0x02000000,
    ACCESS_SYSTEM_SECURITY = 0x01000000,
    SYNCHRONIZE = 0x00100000,
    WRITE_OWNER = 0x00080000,
    WRITE_DACL = 0x00040000,
    READ_CONTROL = 0x00020000,
    DELETE = 0x00010000,
    ACCOUNT_VIEW = 0x00000001,
    ACCOUNT_ADJUST_PRIVILEGES = 0x00000002,
    ACCOUNT_ADJUST_QUOTAS = 0x00000004,
    ACCOUNT_ADJUST_SYSTEM_ACCESS = 0x00000008,
    ...
} with IDL{DoNotGenerate = true};

pattern AccessMaskForSecretObjects = flags ACCESS_MASK
{
    GENERIC_READ = 0x80000000,
    GENERIC_WRITE = 0x40000000,
    GENERIC_EXECUTE = 0x20000000,
    GENERIC_ALL = 0x10000000,
    MAXIMUM_ALLOWED = 0x02000000,
    ACCESS_SYSTEM_SECURITY = 0x01000000,
    SYNCHRONIZE = 0x00100000,
    WRITE_OWNER = 0x00080000,
    WRITE_DACL = 0x00040000,
    READ_CONTROL = 0x00020000,
    DELETE = 0x00010000,
    SECRET_SET_VALUE = 0x00000001,
    SECRET_QUERY_VALUE = 0x00000002,
    ...
} with IDL{DoNotGenerate = true};

pattern AccessMaskForTrustedDomainObjects = flags ACCESS_MASK
{
    GENERIC_READ = 0x80000000,
    GENERIC_WRITE = 0x40000000,
    GENERIC_EXECUTE = 0x20000000,
    GENERIC_ALL = 0x10000000,
    MAXIMUM_ALLOWED = 0x02000000,
    ACCESS_SYSTEM_SECURITY = 0x01000000,
    SYNCHRONIZE = 0x00100000,
    WRITE_OWNER = 0x00080000,
    WRITE_DACL = 0x00040000,
    READ_CONTROL = 0x00020000,
    DELETE = 0x00010000,
    TRUSTED_QUERY_DOMAIN_NAME = 0x00000001,
    TRUSTED_QUERY_CONTROLLERS = 0x00000002,
    TRUSTED_SET_CONTROLLERS = 0x00000004,
    TRUSTED_QUERY_POSIX = 0x00000008,
    TRUSTED_SET_POSIX = 0x00000010,
    TRUSTED_SET_AUTH = 0x00000020,
    TRUSTED_QUERY_AUTH = 0x00000040,
    ...
} with IDL{DoNotGenerate = true};

pattern SecurityInformationPattern = flags SECURITY_INFORMATION
{
    OWNER_SECURITY_INFORMATION = 0x00000001,
    GROUP_SECURITY_INFORMATION = 0x00000002,
    DACL_SECURITY_INFORMATION = 0x00000004,
    SACL_SECURITY_INFORMATION = 0x00000008,
    ...
} with IDL{DoNotGenerate = true};

pattern TrustDirectionPattern = enum IDLUlong
{
    InboundTrust = 0x00000001,
    OutboundTrust = 0x00000002,
    ...
} with IDL{DoNotGenerate = true};

pattern TrustAttributesPattern = flags IDLUlong
{
    TRUST_ATTRIBUTE_NON_TRANSITIVE = 0x00000001,
    TRUST_ATTRIBUTE_UPLEVEL_ONLY = 0x00000002,
    TRUST_ATTRIBUTE_QUARANTINED_DOMAIN = 0x00000004,
    TRUST_ATTRIBUTE_FOREST_TRANSITIVE = 0x00000008,
    TRUST_ATTRIBUTE_CROSS_ORGANIZATION = 0x00000010,
    TRUST_ATTRIBUTE_WITHIN_FOREST = 0x00000020,
    TRUST_ATTRIBUTE_TREAT_AS_EXTERNAL = 0x00000040,
    TRUST_ATTRIBUTE_USES_RC4_ENCRYPTION = 0x00000080,
    ...
} with IDL{DoNotGenerate = true};

pattern EventAuditingOptionPattern = enum IDLUlong
{
    POLICY_AUDIT_EVENT_UNCHANGED = 0x00000000,
    POLICY_AUDIT_EVENT_NONE = 0x00000004,
    POLICY_AUDIT_EVENT_SUCCESS = 0x00000001,
    POLICY_AUDIT_EVENT_FAILURE = 0x00000002,
    ...
} with IDL{DoNotGenerate = true};

pattern ControlPattern = flags IDLUlong
{
    O = 0x00000001,
    ...
} with IDL{DoNotGenerate = true};

pattern AuthenticationOptionsPattern = flags IDLUlong
{
    POLICY_KERBEROS_VALIDATE_CLIENT = 0x00000080,
    ...
} with IDL{DoNotGenerate = true};

pattern AttributesPattern = flags IDLUlong
{
    D = 0x00000001,
    E = 0x00000002,
    ...
} with IDL{DoNotGenerate = true};

pattern ClientRevisionPattern = enum IDLUlong
{
    $"The client does not understand DNS domain names and is not aware that it might be part of a forest" = 0x00000001,
    $"The client understands DNS domain names and is aware that it might be part of a forest" = 0x00000002,
    ...
} with IDL{DoNotGenerate = true};

pattern LookupOptionsPattern = enum IDLUlong
{
    $"Isolated names are searched for even when they are not on the local computer" = 0x00000000,
    $"Isolated names are searched for only on the local account database" = 0x80000000,
    ...
} with IDL{DoNotGenerate = true};

pattern SupportedEncryptionTypesPattern = flags IDLUlong
{
    CRC32 = 0x00000001,
    $"RSA-MD5" = 0x00000002,
    $"RC4-HMAC-MD5" = 0x00000004,
    $"HMAC-SHA1-96-AES128" = 0x00000008,
    $"HMAC-SHA1-96-AES256" = 0x00000010,
    ...
} with IDL{DoNotGenerate = true};

pattern ForestTrustDomainInfoFlagsPattern = flags IDLUlong
{
    LSA_SID_DISABLED_ADMIN = 0x00000001,
    LSA_SID_DISABLED_CONFLICT = 0x00000002,
    LSA_NB_DISABLED_ADMIN = 0x00000004,
    LSA_NB_DISABLED_CONFLICT = 0x00000008,
    ...
} with IDL{DoNotGenerate = true};

pattern ForestTrustTopLevelNameFlagsPattern = flags IDLUlong
{
    LSA_TLN_DISABLED_NEW = 0x00000001,
    LSA_TLN_DISABLED_ADMIN = 0x00000002,
    LSA_TLN_DISABLED_CONFLICT = 0x00000004,
    ...
} with IDL{DoNotGenerate = true};

pattern LsaForeastTrustCollisionRecordFlagsPattern = flags IDLUlong
{
    LSA_SID_DISABLED_CONFLICT = 0x00000002,
    LSA_TLN_DISABLED_CONFLICT = 0x00000004,
    ...
} with IDL{DoNotGenerate = true};

pattern TrustTypePattern = enum IDLUlong
{
    $"Trust with a Windows domain that is not running Active Directory" = 0x00000001,
    $"Trust with a Windows domain that is running Active Directory" = 0x00000002,
    $"Trust with a non–Windows-compliant Kerberos distribution" = 0x00000003,
    $"Trust with a distributed computing environment (DCE) realm" = 0x00000004,
    ...
} with IDL{DoNotGenerate = true};

pattern AuthTypePattern = enum IDLUlong
{
    $"This type must be ignored" = 0x00000000,
    $"Derived RC4HMAC key" = 0x00000001,
    $"A plaintext password" = 0x00000002,
    $"A plaintext password version number" = 0x00000003,
    ...
} with IDL{DoNotGenerate = true};

// ------------------------------------- Utilities ---------------------------------------------//
string AllPrivilegesToString(any input)
{
    if (input is c:UCHAR)
    {
        if (c == 0)
        {
            return "All privileges will not be stripped from the account object";
        }
        else
        {
            return "All privileges will be stripped from the account object";
        }
    }
    return "";
}

string AllRightsToString(any input)
{
    if (input is c:UCHAR)
    {
        if (c == 0)
        {
            return "All rights will not be removed";
        }
        else
        {
            return "All rights will be removed";
        }
    }
    return "";
}

string CheckOnlyToString(any input)
{
    if (input is c:UCHAR)
    {
        if (c == 0)
        {
            return "FALSE";
        }
        else
        {
            return "The operation is read-only and does not alter the state of the server's database";
        }
    }
    return "";
}

string ContextTrackingModeToString(any input)
{
    if (input is c:char)
    {
        if (c == 0)
        {
            return "The server is given a snapshot of the client's security context";
        }
        else
        {
            return "The server is continually updated with changes";
        }
    }
    return "";
}

string EffectiveOnlyToString(any input)
{
    if (input is c:UCHAR)
    {
        if (c == 0)
        {
            return "Server disables privileges and groups";
        }
        else
        {
            return "Server enables privileges and groups";
        }
    }
    return "";
}

string ShutDownOnFullToString(any input)
{
    if (input is c:UCHAR)
    {
        if (c == 0)
        {
            return "System must not shut down when the event log is full";
        }
        else
        {
            return "System must shut down when the event log is full";
        }
    }
    return "";
}

string LogIsFullToString(any input)
{
    if (input is c:UCHAR)
    {
        if (c == 0)
        {
            return "Auditing is disabled";
        }
        else
        {
            return "Auditing is disabled";
        }
    }
    return "";
}

string AuditingModeToString(any input)
{
    if (input is c:UCHAR)
    {
        if (c == 0)
        {
            return "The event log is not full";
        }
        else
        {
            return "The event log is full";
        }
    }
    return "";
}

optional binary ConvertArrayUint2Binary(array<IDLUlong> arrayUint)
{
    // ToBinary with LittleEndian and decode also with Little Endian
    return arrayUint.Accumulate<IDLUlong, binary>((IDLUlong i, binary r) => r + i.ToBinary(true));
}

bool ValidationCheckEventAuditingOptions(array<EventAuditingOptionPattern> input)
{
    bool ret = true;
    foreach (var item in input)
    {
        if(!ValidationCheckEnumValueTooManyItems(InRange<EventAuditingOptionPattern>(item), null, true, ReferenceType.Type,
            "LSA", "EventAuditingOptions", "LSAPR_POLICY_AUDIT_EVENTS_INFO", "EventAuditingOptions", "[MS-LSAD]"))
        {
            ret = false;
        }
    }
    return ret;
}
