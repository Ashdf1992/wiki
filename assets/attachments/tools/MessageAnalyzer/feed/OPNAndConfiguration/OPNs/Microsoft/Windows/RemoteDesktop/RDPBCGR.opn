protocol RDPBCGR with
Visualization{AliasName = "RDP"},
Documentation
{
    ProtocolName = "Remote Desktop Protocol: Basic Connectivity and Graphics Remoting Specification",
    ShortName = "RDPBCGR",
    Description = ""
},
OPNAuthoring
{
    Copyright = "(c) Microsoft Corporation",
    References =
        [
            new Reference{Name = "MS-RDPBCGR", Version = "50.0", Date = "03/13/2019", ProgramName = ProgramName.MCPP},
            new Reference{Name = "MS-RDPERP", Version = "23.0", Date = "06/01/2017", ProgramName = ProgramName.MCPP},
        ],
    RevisionSummary =
        [
            new Revision{Class=RevisionClass.Major, Version="383234", Date="12/23/2015"}
        ]
};

using Standard;
using Utility;
using IANA;
using ISOTS;
using TCP;
using DecodingUtility; // WORKAROUND: compiler bug#3131164, When type A inherit from type B, module C use tye A, and A, B, C is in different module file, compiler will give a compilation error
using X224;
using T124;
using T125;
using RDPNSC;
using RemoteDesktopResources;
using Diagnostics;
using EMFPLUS;
using Reassembly;
using InfrastructureResources;
using CSSP;
using Configurations;
using TSGU;
using ERREF;

const string MODULE_NAME = "RDPBCGR";

endpoint Server over X224.Server | over T125.Node | over T124.Node | over TSGU.Server
                accepts ClientX224ConnectionRequestPdu issues ServerX224ConnectionConfirmPdu
                issues EarlyUserAuthorizationResultPdu
                accepts ClientMcsConnectInitialPduWithGccConferenceCreateRequest issues ServerMCSConnectResponsePDUWithGccConferenceCreateResponse
                accepts ClientMCSErectDomainRequestPdu
                accepts ClientMCSAttachUserRequestPdu issues ServerMCSAttachUserConfirmPdu
                accepts ClientMCSChannelJoinRequestPdu issues ServerMCSChannelJoinConfirmPdu
                accepts ClientSecurityExchangePdu
                accepts ClientInfoPdu
                issues ServerLicenseErrorPdu
                issues mutable ServerDemandActivePdu accepts mutable ClientConfirmActivePdu
                accepts ClientSynchronizePdu issues ServerSynchronizePdu
                accepts ClientControlPduCoOperate issues ServerControlPduCoOperate
                accepts ClientControlPduRequestControl issues ServerControlPduGrantedControl
                accepts ClientPersistentKeyListPdu
                accepts ClientFontListPdu
                issues ServerFontMapPdu
                accepts VirtualChannelPdu issues VirtualChannelPdu
                accepts ClientShutdownRequestPdu issues ServerShutdownRequestDeniedPdu
                accepts ClientAutoDetectResponsePdu issues ServerAutoDetectRequestPdu
                issues TS_ENHANCED_SECURITY_SERVER_REDIRECTION
                issues TS_STANDARD_SECURITY_SERVER_REDIRECTION
                issues MonitorLayoutPdu
                accepts ClientSuppressOutputPdu
                accepts ClientRefreshRectPdu
                issues ServerSaveSessionInfoPdu
                issues ServerPlaySoundPdu
                issues TS_POINTER_PDU
                issues TS_GRAPHICS_PDU
                issues ServerSetKeyboardIMEStatusPdu
                issues ServerSetKeyboardIndicatorsPdu
                accepts TS_INPUT_PDU
                issues ServerStatusInfoPdu
                issues ServerSetErrorInfoPdu
                issues ServerAutoReconnectStatusPdu
                issues ServerDeactivateAllPdu
                accepts McsDisconnectProviderUltimatumPdu issues McsDisconnectProviderUltimatumPdu
                accepts EncryptedMessage issues EncryptedMessage
                accepts TS_FP_INPUT_PDU issues mutable TS_FP_UPDATE_PDU
                accepts ClientInitiateMultitransportError issues ServerInitiateMultitransportRequest
                issues TSServerHeartbeatPDU
                issues RDSTLSCapabilitiesPdu
                accepts RDSTLSAuthRequestPduWithPasswordCredentials
                accepts RDSTLSAuthRequestPduWithAutoReconnectCookie
                issues RDSTLSAuthResponsePdu
{
    map<uint, string> channelNameMap = {};
    // Record the keys of multi-transport
    set<binary> multiTransportIdSet = {};

    DummyEndpoint dummyEndpoint = endpoint DummyEndpoint;
    
    // observe rule to deal with multi-transport request
    observe this issues mreq:ServerInitiateMultitransportRequest
    {
        binary id = ConstructId(mreq.requestId, mreq.securityCookie);
        multiTransportIdSet[id] = true;
        dummyEndpoint.multiTransportMap[id] = this;
    }

    ~endpoint(RDPBCGR.Server server)
    {
        ClearKeysForDummyEndpoint();
    }

    void ClearKeysForDummyEndpoint()
    {
        foreach (var id in multiTransportIdSet)
        {
            if (id in dummyEndpoint.multiTransportMap)
            {
                dummyEndpoint.multiTransportMap = 
                    dummyEndpoint.multiTransportMap.Remove(id);
            }
        }
        multiTransportIdSet = {};
    }
};

// Dummy endpoint contains global variable
endpoint DummyEndpoint accepts any message issues any message
{
    // map used by multi-transport.
    // Key: RequestID.ToBinary() + SecurityCookie;
    // Value: RDPBCGR Server;
    map<binary, Server> multiTransportMap = {};
};

// Construct key used by edycEndpointMap
binary ConstructId(uint reqId, binary cookie)
{
    return reqId.ToBinary() + cookie;
}
                
client endpoint Client connected to Server;
annotation string VirtualChannelPdu#ChannelName;

// Record the state for multiple RDP connections, use RDP client port number as index
map<ushort, TSUDSCSec1EncryptionLevel> encryptionLevels = {};
map<ushort, TSUDSCSec1EncryptionMethod> encryptionMethods = {};
map<ushort, bool> ServerMCSConnectResponsePDUReceivedFlags = {};
map<ushort, long> selectedProtocols = {};
map<ushort, array<string>> channelNames = {};
map<ushort, map<long, string>> channelNamesMaps = {};
map<ushort, int> channelCounts = {};
map<ushort, long> mcsChannelIds = {};
map<ushort, long> mcsMessageChannelIds = {};

autostart actor RDPBCGROverX224(X224.Server server)
{
    ushort indexPort = 0;
    
    RDPConfiguration config = GetConfigurableValue<RDPConfiguration>();

    process server accepts tpdu:X224.TPDU
        where tpdu#TpduDestinationPort is desPort:ushort && tpdu#TpduSourcePort is srcPort:ushort && 
            (desPort == Port.RDP || desPort in config.Ports || srcPort == Port.RDP || srcPort in config.Ports)
    {
        // 2.2.1.1   Client X.224 Connection Request PDU
        if (tpdu is req:ConnectionRequest && (req.ClassOption & 0xF0) == 0)
        {
            bool stringPresent = req.LengthIndicator > 14;
            // if req.UserData is nothing and stringPresent is false, it will be decoded to an empty message
            // because fields of ClientX224ConnectionRequestPdu are optional 
            binary payload =  req.UserData is data:binary ? data : Utility.EmptyBinary;
                    
            if (BinaryDecoder<ClientX224ConnectionRequestPdu[stringPresent]>(payload) is msg:ClientX224ConnectionRequestPdu)
            {
                dispatch endpoint Server accepts msg;
            }
            else
            {
                ThrowDecodingException("RDPBCGR", "ClientX224ConnectionRequestPdu");
            }
        }
        else
        {
            reject;
        }
    }

    process server issues tpdu:X224.TPDU
        where tpdu#TpduSourcePort is srcPort:ushort && tpdu#TpduDestinationPort is desPort:ushort &&
            (srcPort == Port.RDP || srcPort in config.Ports || desPort == Port.RDP || desPort in config.Ports)
    {
        // 2.2.1.2   Server X.224 Connection Confirm PDU
        if (tpdu is res:ConnectionConfirm && (res.ClassOption & 0xF0) == 0)
        {
            // if res.UserData is nothing, it will be decoded to an empty message, because fields of ServerX224ConnectionConfirmPdu are optional 
            binary payload = res.UserData is data:binary ? data : Utility.EmptyBinary;
                    
            if (BinaryDecoder<ServerX224ConnectionConfirmPdu>(payload) is msg:ServerX224ConnectionConfirmPdu)
            {
                if (msg.rdpNegData is rdpNegData:RDP_NEG_RSP)
                {
                    indexPort = desPort;
                    selectedProtocols[indexPort] = rdpNegData.selectedProtocol;
                }
                dispatch endpoint Server issues msg;
            }
            else
            {
                ThrowDecodingException("RDPBCGR", "ServerX224ConnectionConfirmPdu");
            }
        }
        else
        {
            reject;
        }
    }
    
    ~endpoint(X224.Server server)
    {
        if (indexPort in selectedProtocols)
        {
            selectedProtocols = selectedProtocols.Remove(indexPort);
        }
    }
}

autostart actor RDPBCGROverT124(T124.Node node)
{   
    ushort indexPort = 0;
     
    process node accepts connectGccPdu:T124.ConnectGccPdu
    {
        T124.ConferenceCreateRequest conferenceCreateRequest;
        indexPort = (connectGccPdu#T124SourcePort is port:ushort) ? port : 0;

        if (connectGccPdu.ConnectPdu is t124Req:T124.ConferenceCreateRequest)
        {
            conferenceCreateRequest = t124Req;
        }
        else
        {
            reject;
        }
        if ((conferenceCreateRequest.UserData is userdata:set<UserDataType>) && userdata.Count == 1)
        {
            binary keyIdentifier = Utility.EmptyBinary;
            binary payload = Utility.EmptyBinary;
            // There's only one element in set<>, but can not use index to retrieve elements in set, so use foreach() instead.
            foreach (UserDataType userDataType in userdata) 
            {
                payload = userDataType.Value as binary;
                keyIdentifier = userDataType.Key as binary;
                if (keyIdentifier == ConferenceCreateRequestKeyIdentifier)
                {
                    switch (payload)
                    {
                        case m:ClientMcsConnectInitialPduWithGccConferenceCreateRequest from BinaryDecoder<ClientMcsConnectInitialPduWithGccConferenceCreateRequest> =>
                            int tempCount = 0;
                            if (!(indexPort in channelNames))
                            {
                                channelNames[indexPort] = [];
                            }
                            while (tempCount < m.TSUD.Count)
                            {
                                if (m.TSUD[tempCount] is tSUdCsNet:TS_UD_CS_NET)
                                {
                                    channelCounts[indexPort] = tSUdCsNet.channelCount as int;
                                    string tempName;
                                    array<CHANNEL_DEF> tempChannelDef = tSUdCsNet.channelDefArray;
                                    int temp = 0;
                                    while (temp < channelCounts[indexPort])
                                    {
                                        tempName = tempChannelDef[temp].name;
                                        channelNames[indexPort] += [tempName];
                                        temp = temp + 1;
                                    }
                                }
                                tempCount += 1;
                            }
                            dispatch endpoint Server accepts m;
                        default => 
                            ThrowDecodingException("RDPBCGR", "ClientMcsConnectInitialPduWithGccConferenceCreateRequest");
                    }
                }
                else
                {
                    reject;
                }
            }
        }
        else 
        {
            reject;
        }
    }
    
    process node issues connectGccPdu:T124.ConnectGccPdu
    {
        T124.ConferenceCreateResponse conferenceCreateResponse;
        indexPort = (connectGccPdu#T124DestinationPort is port:ushort) ? port : 0;
        int channelCount = (indexPort in channelCounts) ? channelCounts[indexPort] : -1;

        if (connectGccPdu.ConnectPdu is t124Resp:T124.ConferenceCreateResponse)
        {
            conferenceCreateResponse = t124Resp;
        }
        else
        {
            reject;
        }
        if ((conferenceCreateResponse.UserData is userdata:set<UserDataType>) && userdata.Count == 1)
        {
            binary keyIdentifier = Utility.EmptyBinary;
            binary payload = Utility.EmptyBinary;
            // There's only one element in set<>, but can not use index to retrieve elements in set, so use foreach() instead.
            foreach (UserDataType userDataType in userdata)
            {
                payload = userDataType.Value as binary;
                keyIdentifier = userDataType.Key as binary;
                if (keyIdentifier == ConferenceCreateResponseKeyIdentifier)
                {
                    switch (payload)
                    {
                        case m:ServerMCSConnectResponsePDUWithGccConferenceCreateResponse from BinaryDecoder<ServerMCSConnectResponsePDUWithGccConferenceCreateResponse> =>
                            int tempCount = 0;
                            // The ServerMCSConnectResponsePDUWithGccConferenceCreateResponse has been recevied
                            ServerMCSConnectResponsePDUReceivedFlags[indexPort] = true;
                            if (!(indexPort in channelNamesMaps))
                            {
                                channelNamesMaps[indexPort] = {};
                            }
                            while (tempCount < m.TSUD.Count)
                            {
                                if (m.TSUD[tempCount] is tSUdCsNet:TS_UD_SC_NET)
                                {
                                    int temp = 0;
                                    while (temp < channelCount)
                                    {
                                        channelNamesMaps[indexPort][tSUdCsNet.channelIdArray[temp]] = channelNames[indexPort][temp];
                                        temp = temp + 1;
                                    }
                                    mcsChannelIds[indexPort] = tSUdCsNet.MCSChannelId;
                                }
                                else if (m.TSUD[tempCount] is tSUdScSec1:TS_UD_SC_SEC1)
                                {
                                    encryptionLevels[indexPort] = tSUdScSec1.encryptionLevel;
                                    encryptionMethods[indexPort] = tSUdScSec1.encryptionMethod;
                                }
                                else if (m.TSUD[tempCount] is tSUdScMcsMsgChannel:TS_UD_SC_MCS_MSGCHANNEL) // If TSUD is a TS_UD_SC_MCS_MSGCHANNEL, record its channel ID
                                {
                                    mcsMessageChannelIds[indexPort] = tSUdScMcsMsgChannel.MCSChannelID;
                                }
                                tempCount += 1;
                            }
                            dispatch endpoint Server issues m;
                        default => 
                            ThrowDecodingException("RDPBCGR", "ServerMCSConnectResponsePDUWithGccConferenceCreateResponse");
                    }
                }
                else
                {
                    reject;
                }
            }
        }
        else 
        {
            reject;
        }
    }
    
    ~endpoint(T124.Node node)
    {
        if (indexPort in ServerMCSConnectResponsePDUReceivedFlags)
        {
            ServerMCSConnectResponsePDUReceivedFlags = ServerMCSConnectResponsePDUReceivedFlags.Remove(indexPort);
        }
        if (indexPort in channelNames)
        {
            channelNames = channelNames.Remove(indexPort);
        }
        if (indexPort in channelNamesMaps)
        {
            channelNamesMaps = channelNamesMaps.Remove(indexPort);
        }
        if (indexPort in channelCounts)
        {
            channelCounts = channelCounts.Remove(indexPort);
        }
        if (indexPort in mcsChannelIds)
        {
            mcsChannelIds = mcsChannelIds.Remove(indexPort);
        }
        if (indexPort in mcsMessageChannelIds)
        {
            mcsMessageChannelIds = mcsMessageChannelIds.Remove(indexPort);
        }
        if (indexPort in encryptionLevels)
        {
            encryptionLevels = encryptionLevels.Remove(indexPort);
        }
        if (indexPort in encryptionMethods)
        {
            encryptionMethods = encryptionMethods.Remove(indexPort);
        }
    }
}

const binary ConferenceCreateRequestKeyIdentifier = $[44756361];
const binary ConferenceCreateResponseKeyIdentifier = $[4D63446E];

autostart actor RDPBCGROverT125(T125.Node node)
{    
    bool initialFlag = true;
    // The initial value for the orderType agreed on by both the server and client is TS_ENC_PATBLT_ORDER(0x01).
    byte OrderType = PrimaryDrawingOrderType.TS_ENC_PATBLT_ORDER;

    RDPBCGRReassemblyHelper acceptsHelper = null;
    RDPBCGRReassemblyHelper issuesHelper = null;

    process node accepts domainMCSPDU:T125.DomainMCSPDU
    {
        ushort indexPort = (domainMCSPDU#T125SourcePort is port:ushort) ? port : 0;
        bool serverMCSConnectResponsePDUReceived = (indexPort in ServerMCSConnectResponsePDUReceivedFlags) ? ServerMCSConnectResponsePDUReceivedFlags[indexPort] : false;
        map<long, string> channelNamesMap = (indexPort in channelNamesMaps) ? channelNamesMaps[indexPort] : {};
        long mcsChannelId = (indexPort in mcsChannelIds) ? mcsChannelIds[indexPort] : -1;
        long mcsMessageChannelId = (indexPort in mcsMessageChannelIds) ? mcsMessageChannelIds[indexPort] : -1;
        uint encryptionLevel = (indexPort in encryptionLevels) ? encryptionLevels[indexPort] : 0;
        uint encryptionMethod = (indexPort in encryptionMethods) ? encryptionMethods[indexPort] : 0;
        
        if (domainMCSPDU.DomainMCSPDU is t125SendDataReqPatt:T125.SendDataRequestPattern && serverMCSConnectResponsePDUReceived)
        {
            binary payload = t125SendDataReqPatt.UserData as binary;
            long channelId = t125SendDataReqPatt.ChannelId;
            // Check whether ChannelId is registered
            if (!(channelId in channelNamesMap.Keys || channelId == mcsChannelId || channelId == mcsMessageChannelId))
            {
                ThrowDecodingException("RDPBCGR", UTILITY_UNDEFINED_DATA, ["ChannelId"]);
            }
            // Encrypted data
            else if (((encryptionLevel != 0) || (encryptionMethod != 0)) && (payload[0] & 0x08) == 0x08)
            {
                var m = BinaryDecoder<EncryptedMessage[encryptionLevel, encryptionMethod]>(payload);
                if (m is msg:EncryptedMessage)
                {
                    dispatch endpoint Server accepts msg;
                }
                else
                {
                    ThrowDecodingException("RDPBCGR", "EncryptedMessage");
                }
            }
            
            // Distinguish message from channelId
            else if (channelId == mcsChannelId)
            {
                // 2.2.1.13.2   Client Confirm Active PDU
                if (GetPduType(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.ClientConfirmActivePdu) == 0x03)
                {
                    var m = BinaryDecoder<ClientConfirmActivePdu[encryptionLevel, encryptionMethod]>(payload);
                    if (m is msg:ClientConfirmActivePdu)
                    {
                        dispatch endpoint Server accepts msg;
                    }
                    else
                    {
                        ThrowDecodingException("RDPBCGR", "ClientConfirmActivePdu");
                    }
                }
                // 2.2.1.14   Client Synchronize PDU
                else if ((GetPduType(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.ClientSynchronizePdu)) == 0x07 &&
                (GetPdu2Type(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.ClientSynchronizePdu) == 0x1F))
                {
                    var m = BinaryDecoder<ClientSynchronizePdu[encryptionLevel, encryptionMethod]>(payload);
                    if (m is msg:ClientSynchronizePdu)
                    {
                        dispatch endpoint Server accepts msg;
                    }
                    else
                    {
                        ThrowDecodingException("RDPBCGR", "ClientSynchronizePdu");
                    }
                }
                // 2.2.1.15   Client Control PDU - Cooperate
                else if ((GetPduType(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.ClientControlPduCoOperate)) == 0x07 &&
                (GetPdu2Type(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.ClientControlPduCoOperate) == 0x14))
                {
                    var m = BinaryDecoder<ClientControlPduCoOperate[encryptionLevel, encryptionMethod]>(payload);
                    if (m is msg:ClientControlPduCoOperate)
                    {
                        dispatch endpoint Server accepts msg;
                    }
                    else
                    {
                        // 2.2.1.16   Client Control PDU - Request Control
                        var m2 = BinaryDecoder<ClientControlPduRequestControl[encryptionLevel, encryptionMethod]>(payload);
                        if (m2 is msg2:ClientControlPduRequestControl)
                        {
                            dispatch endpoint Server accepts msg2;
                        }
                        else
                        {
                            ThrowDecodingException("RDPBCGR", "ClientControlPduCoOperate");
                        }
                    }
                }
                // 2.2.1.17   Client Persistent Key List PDU
                else if ((GetPduType(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.ClientPersistentKeyListPdu)) == 0x07 &&
                (GetPdu2Type(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.ClientPersistentKeyListPdu) == 0x2B))
                {
                    var m = BinaryDecoder<ClientPersistentKeyListPdu[encryptionLevel, encryptionMethod]>(payload);
                    if (m != nothing)
                    {
                        var msg  = m as ClientPersistentKeyListPdu;
                        dispatch endpoint Server accepts msg;
                    }
                    else
                    {
                        ThrowDecodingException("RDPBCGR", "ClientPersistentKeyListPdu");
                    }
                }
                // 2.2.1.18   Client Font List PDU
                else if ((GetPduType(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.ClientFontListPdu)) == 0x07 &&
                (GetPdu2Type(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.ClientFontListPdu) == 0x27))
                {
                    var m = BinaryDecoder<ClientFontListPdu[encryptionLevel, encryptionMethod]>(payload);
                    if (m is msg:ClientFontListPdu)
                    {
                        dispatch endpoint Server accepts msg;
                    }
                    else
                    {
                        ThrowDecodingException("RDPBCGR", "ClientFontListPdu");
                    }
                }
                // 2.2.2.1   Client Shutdown Request PDU
                else if ((GetPduType(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.ClientShutdownRequestPdu)) == 0x07 &&
                (GetPdu2Type(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.ClientShutdownRequestPdu) == 0x24))
                {
                    var m = BinaryDecoder<ClientShutdownRequestPdu[encryptionLevel, encryptionMethod]>(payload);
                    if (m is msg:ClientShutdownRequestPdu)
                    {
                        dispatch endpoint Server accepts msg;
                    }
                    else
                    {
                        ThrowDecodingException("RDPBCGR", "ClientShutdownRequestPdu");
                    }
                }
                // 2.2.8.1.1.3   Client Input Event PDU (TS_INPUT_PDU)
                else if ((GetPduType(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.TS_INPUT_PDU)) == 0x07 &&
                (GetPdu2Type(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.TS_INPUT_PDU) == 0x1C))
                {
                    var m = BinaryDecoder<TS_INPUT_PDU[encryptionLevel, encryptionMethod]>(payload);
                    if (m is msg:TS_INPUT_PDU)
                    {
                        dispatch endpoint Server accepts msg;
                    }
                    else
                    {
                        ThrowDecodingException("RDPBCGR", "TS_INPUT_PDU");
                    }
                }
                // 2.2.11.2   Client Refresh Rect PDU
                else if ((GetPduType(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.ClientRefreshRectPdu)) == 0x07 &&
                (GetPdu2Type(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.ClientRefreshRectPdu) == 0x21))
                {
                    var m = BinaryDecoder<ClientRefreshRectPdu[encryptionLevel, encryptionMethod]>(payload);
                    if (m is msg:ClientRefreshRectPdu)
                    {
                        dispatch endpoint Server accepts msg;
                    }
                    else
                    {
                        ThrowDecodingException("RDPBCGR", "ClientRefreshRectPdu");
                    }
                }
                // 2.2.11.3   Client Suppress Output PDU
                else if ((GetPduType(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.ClientSuppressOutputPdu)) == 0x07 &&
                (GetPdu2Type(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.ClientSuppressOutputPdu) == 0x23))
                {
                    var m = BinaryDecoder<ClientSuppressOutputPdu[encryptionLevel, encryptionMethod]>(payload);
                    if (m is msg:ClientSuppressOutputPdu)
                    {
                        dispatch endpoint Server accepts msg;
                    }
                    else
                    {
                        ThrowDecodingException("RDPBCGR", "ClientSuppressOutputPdu");
                    }
                }                
                // 2.2.1.10   Client Security Exchange PDU
                else if ((payload[0] == 0x01 &&
                payload[1] == 0x02) || 
                (payload[0] == 0x01 &&
                payload[1] == 0x00))
                {
                    switch (payload)
                    {
                        case m:ClientSecurityExchangePdu from BinaryDecoder<ClientSecurityExchangePdu> =>
                            dispatch endpoint Server accepts m;
                        default => 
                            ThrowDecodingException("RDPBCGR", "ClientSecurityExchangePdu");
                    }
                }
                // 2.2.1.11   Client Info PDU
                else if ((payload[0] == 0x40) || (payload[0] == 0x48))
                {
                    var m = BinaryDecoder<ClientInfoPdu[encryptionLevel, encryptionMethod]>(payload);
                    if (m is msg:ClientInfoPdu)
                    {
                        dispatch endpoint Server accepts msg;
                    }
                    else
                    {
                        ThrowDecodingException("RDPBCGR", "ClientInfoPdu");
                    }
                }
                else 
                {
                    reject;
                }      
            }
            else if (channelId == mcsMessageChannelId) // when channel id is mcsMessageChannelId, the pdu is a Client Auto-Detect Response PDU or Client Initiate Multitransport Error
            {
                // 2.2.14.4   Client Auto-Detect Response PDU
                if (IsAutoDetectMsg(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.ClientAutoDetectResponsePdu))
                {
                    var m = BinaryDecoder<ClientAutoDetectResponsePdu[encryptionLevel, encryptionMethod]>(payload);
                    if (m is msg:ClientAutoDetectResponsePdu)
                    {
                        dispatch endpoint Server accepts msg;
                    }
                    else
                    {
                        ThrowDecodingException("RDPBCGR", "ClientAutoDetectResponsePdu");
                    }
                }
                // 2.2.15.2   Client Initiate Multitransport Error
                else if ((payload[0] & 0x04) == 0x04)
                {
                    var m = BinaryDecoder<ClientInitiateMultitransportError[encryptionLevel, encryptionMethod]>(payload);
                    if (m is msg:ClientInitiateMultitransportError)
                    {
                        dispatch endpoint Server accepts msg;
                    }
                    else
                    {
                        ThrowDecodingException("RDPBCGR", "ClientInitiateMultitransportError");
                    }
                }
                
                else 
                {
                    reject;
                }
            }
            else // channelId in channelNamesMap
            {
                // 2.2.6.1   Virtual Channel PDU
                if (channelId in channelNamesMap)
                {
                    var m = BinaryDecoder<VirtualChannelPdu[encryptionLevel, encryptionMethod]>(payload);

                    if (m is msg:VirtualChannelPdu)
                    {
                        msg#ChannelName = channelNamesMap[channelId];
                        if (msg.channelPduHeader.$"flags".CHANNEL_PACKET_COMPRESSED)
                        {
                            // If virtualChannelData is compressed, only show it as top level message
                            DisplayTopLevelMessage(msg);
                        }
                        else
                        {                            
                            if (acceptsHelper == null)
                            {
                                acceptsHelper = new RDPBCGRReassemblyHelper
                                    {
                                        EPT = endpoint Server,
                                        Direction = MessageDirection.Accepts,
                                    };
                            }
                            msg.Origins = [domainMCSPDU];
                            acceptsHelper.Reassemble(msg);
                        }
                    }
                    else
                    {
                        ThrowDecodingException("RDPBCGR", "VirtualChannelPdu");
                    }
                }
            }
        }
        // 2.2.1.5   Client MCS Erect Domain Request PDU
        else if (domainMCSPDU.DomainMCSPDU is T125.ErectDomainRequestPattern)
        {
            ClientMCSErectDomainRequestPdu m = new ClientMCSErectDomainRequestPdu{};
            m.Origins = [domainMCSPDU];
            dispatch endpoint Server accepts m;
        }
        // 2.2.1.6   Client MCS Attach User Request PDU
        else if (domainMCSPDU.DomainMCSPDU is T125.AttachUserRequestPattern)
        {
            ClientMCSAttachUserRequestPdu m = new ClientMCSAttachUserRequestPdu{};
            m.Origins = [domainMCSPDU];
            dispatch endpoint Server accepts m;
        }
        // 2.2.1.8   Client MCS Channel Join Request PDU
        else if (domainMCSPDU.DomainMCSPDU is T125.ChannelJoinRequestPattern)
        {
            ClientMCSChannelJoinRequestPdu m = new ClientMCSChannelJoinRequestPdu{};
            m.Origins = [domainMCSPDU];
            dispatch endpoint Server accepts m;
        }
        // 2.2.2.3   MCS Disconnect Provider Ultimatum PDU
        else if (domainMCSPDU.DomainMCSPDU is T125.DisconnectProviderUltimatumPattern)
        {
            McsDisconnectProviderUltimatumPdu m = new McsDisconnectProviderUltimatumPdu{};
            m.Origins = [domainMCSPDU];
            dispatch endpoint Server accepts m;
        }
        else
        {
            // When ServerMCSConnectResponsePDU is lost, only attach the error message to the first unparsed RDPBCGR message.
            if (initialFlag && !serverMCSConnectResponsePDUReceived)
            {
                ErrorCodeIf(true, domainMCSPDU, DiagnosisLevel.Warning, "RDPBCGR: Lack of MCS channel IDs, encryptionMethod and encryptionLevel due to missing Server MCS Connect Response PDU message.");
                initialFlag = false;
            }
            reject;
        }
    }
    
    process node issues domainMCSPDU:T125.DomainMCSPDU
    {
        ushort indexPort = (domainMCSPDU#T125DestinationPort is port:ushort) ? port : 0;
        bool serverMCSConnectResponsePDUReceived = (indexPort in ServerMCSConnectResponsePDUReceivedFlags) ? ServerMCSConnectResponsePDUReceivedFlags[indexPort] : false;
        map<long, string> channelNamesMap = (indexPort in channelNamesMaps) ? channelNamesMaps[indexPort] : {};
        long mcsChannelId = (indexPort in mcsChannelIds) ? mcsChannelIds[indexPort] : -1;
        long mcsMessageChannelId = (indexPort in mcsMessageChannelIds) ? mcsMessageChannelIds[indexPort] : -1;
        uint encryptionLevel = (indexPort in encryptionLevels) ? encryptionLevels[indexPort] : 0;
        uint encryptionMethod = (indexPort in encryptionMethods) ? encryptionMethods[indexPort] : 0;

        if ((domainMCSPDU.DomainMCSPDU is mcsPDU:T125.SendDataIndicationPattern) && serverMCSConnectResponsePDUReceived)
        {
            binary payload = mcsPDU.UserData as binary;
            long channelId = mcsPDU.ChannelId;
            // Check whether ChannelId is registered
            if (!((channelId in channelNamesMap.Keys) || (channelId == mcsChannelId) || (channelId == mcsMessageChannelId)))
            {
                ThrowDecodingException("RDPBCGR", UTILITY_UNDEFINED_DATA, ["ChannelId"]);
            }
            // Encrypted data
            else if (((encryptionLevel != 0) || (encryptionMethod != 0)) && (payload[0] & 0x08) == 0x08)
            {
                var m = BinaryDecoder<EncryptedMessage[encryptionLevel, encryptionMethod]>(payload);
                if (m is msg:EncryptedMessage)
                {
                    dispatch endpoint Server accepts msg;
                }
                else
                {
                    ThrowDecodingException("RDPBCGR", "EncryptedMessage");
                }
            }
            // Distinguish message from channelId
            else if (channelId == mcsChannelId)
            {
                // 2.2.1.12    Server License Error PDU - Valid Client
                if (payload.Count > 4 && (payload[0] & TSSecurityHeaderFlags.SEC_LICENSE_PKT) == 
                    TSSecurityHeaderFlags.SEC_LICENSE_PKT && payload[4] == 0xFF)
                {
                    var m = BinaryDecoder<ServerLicenseErrorPdu[encryptionLevel, encryptionMethod]>(payload);
                    if (m is msg:ServerLicenseErrorPdu)
                    {
                        dispatch endpoint Server issues msg;
                    }
                    else
                    {
                        ThrowDecodingException("RDPBCGR", "ServerLicenseErrorPdu");
                    }
                }
                // 2.2.1.13.1   Server Demand Active PDU
                else if (GetPduType(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.ServerDemandActivePdu) == 0x01)
                {
                    var m = BinaryDecoder<ServerDemandActivePdu[encryptionLevel, encryptionMethod]>(payload);
                    if (m is msg:ServerDemandActivePdu)
                    {
                        dispatch endpoint Server issues msg;
                    }
                    else
                    {
                        ThrowDecodingException("RDPBCGR", "ServerDemandActivePdu");
                    }
                }
                // 2.2.1.19   Server Synchronize PDU
                else if (((GetPduType(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.ServerSynchronizePdu)) == 0x07 &&
                GetPdu2Type(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.ServerSynchronizePdu) == 0x1F))
                {
                    var m = BinaryDecoder<ServerSynchronizePdu[encryptionLevel, encryptionMethod]>(payload);
                    if (m is msg:ServerSynchronizePdu)
                    {
                        dispatch endpoint Server issues msg;
                    }
                    else
                    {
                        // 2.2.1.21   Server Control PDU - Granted Control
                        var m2 = BinaryDecoder<ServerControlPduGrantedControl[encryptionLevel, encryptionMethod]>(payload);
                        if (m2 is msg2:ServerControlPduGrantedControl)
                        {
                            dispatch endpoint Server issues msg2;
                        }
                        else
                        {
                            ThrowDecodingException("RDPBCGR", "ServerControlPduGrantedControl");
                        }
                    }
                }
                // 2.2.1.20   Server Control PDU - Cooperate
                else if ((GetPduType(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.ClientControlPduCoOperate)) == 0x07 &&
                (GetPdu2Type(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.ClientControlPduCoOperate) == 0x14))
                {
                    var m = BinaryDecoder<ServerControlPduCoOperate[encryptionLevel, encryptionMethod]>(payload);
                    if (m is msg:ServerControlPduCoOperate)
                    {
                        dispatch endpoint Server issues msg;
                    }
                    else
                    {
                        // 2.2.1.21   Server Control PDU - Granted Control
                        var m2 = BinaryDecoder<ServerControlPduGrantedControl[encryptionLevel, encryptionMethod]>(payload);
                        if (m2 is msg2:ServerControlPduGrantedControl)
                        {
                            dispatch endpoint Server issues msg2;
                        }
                        else
                        {
                            ThrowDecodingException("RDPBCGR", "ServerControlPduCoOperate");
                        }
                    }
                }
                // 2.2.1.22   Server Font Map PDU
                else if ((GetPduType(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.ServerFontMapPdu)) == 0x07 &&
                (GetPdu2Type(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.ServerFontMapPdu) == 0x28))
                {
                    var m = BinaryDecoder<ServerFontMapPdu[encryptionLevel, encryptionMethod]>(payload);
                    if (m is msg:ServerFontMapPdu)
                    {
                        dispatch endpoint Server issues msg;
                    }
                    else
                    {
                        ThrowDecodingException("RDPBCGR", "ServerFontMapPdu");
                    }
                }
                // 2.2.2.2   Server Shutdown Request Denied PDU
                else if ((GetPduType(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.ServerShutdownRequestDeniedPdu)) == 0x07 &&
                (GetPdu2Type(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.ServerShutdownRequestDeniedPdu) == 0x25))
                {
                    var m = BinaryDecoder<ServerShutdownRequestDeniedPdu[encryptionLevel, encryptionMethod]>(payload);
                    if (m is msg:ServerShutdownRequestDeniedPdu)
                    {
                        dispatch endpoint Server issues msg;
                    }
                    else
                    {
                        ThrowDecodingException("RDPBCGR", "ServerShutdownRequestDeniedPdu");
                    }
                }
                // 2.2.3.1   Server Deactivate All PDU
                else if (GetPduType(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.ServerDeactivateAllPdu) == 0x06) // coca
                {
                    var m = BinaryDecoder<ServerDeactivateAllPdu[encryptionLevel, encryptionMethod]>(payload);
                    if (m is msg:ServerDeactivateAllPdu)
                    {
                        dispatch endpoint Server issues msg;
                    }
                    else
                    {
                        ThrowDecodingException("RDPBCGR", "ServerDeactivateAllPdu");
                    }
                }
                // 2.2.4.1   Server Auto-Reconnect Status PDU
                else if ((GetPduType(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.ServerAutoReconnectStatusPdu)) == 0x07 &&
                (GetPdu2Type(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.ServerAutoReconnectStatusPdu) == 0x32))
                {
                    var m = BinaryDecoder<ServerAutoReconnectStatusPdu[encryptionLevel, encryptionMethod]>(payload);
                    if (m is msg:ServerAutoReconnectStatusPdu)
                    {
                        dispatch endpoint Server issues msg;
                    }
                    else
                    {
                        ThrowDecodingException("RDPBCGR", "ServerAutoReconnectStatusPdu");
                    }
                }
                // 2.2.5.1   Server Set Error Info PDU
                else if ((GetPduType(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.ServerSetErrorInfoPdu)) == 0x07 &&
                (GetPdu2Type(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.ServerSetErrorInfoPdu) == 0x2F))
                {
                    var m = BinaryDecoder<ServerSetErrorInfoPdu[encryptionLevel, encryptionMethod]>(payload);
                    if (m is msg:ServerSetErrorInfoPdu)
                    {
                        dispatch endpoint Server issues msg;
                    }
                    else
                    {
                        ThrowDecodingException("RDPBCGR", "ServerSetErrorInfoPdu");
                    }
                }
                // 2.2.5.2   Server Status Info PDU
                else if ((GetPduType(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.ServerStatusInfoPdu)) == 0x07 &&
                (GetPdu2Type(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.ServerStatusInfoPdu) == 0x36))
                {
                    var m = BinaryDecoder<ServerStatusInfoPdu[encryptionLevel, encryptionMethod]>(payload);
                    if (m is msg:ServerStatusInfoPdu)
                    {
                        dispatch endpoint Server issues msg;
                    }
                    else
                    {
                        ThrowDecodingException("RDPBCGR", "ServerStatusInfoPdu");
                    }
                }
                // 2.2.8.2.1   Server Set Keyboard Indicators PDU
                else if ((GetPduType(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.ServerSetKeyboardIndicatorsPdu)) == 0x07 &&
                (GetPdu2Type(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.ServerSetKeyboardIndicatorsPdu) == 0x29))
                {
                    var m = BinaryDecoder<ServerSetKeyboardIndicatorsPdu[encryptionLevel, encryptionMethod]>(payload);
                    if (m is msg:ServerSetKeyboardIndicatorsPdu)
                    {
                        dispatch endpoint Server issues msg;
                    }
                    else
                    {
                        ThrowDecodingException("RDPBCGR", "ServerSetKeyboardIndicatorsPdu");
                    }
                }
                // 2.2.8.2.2   Server Set Keyboard IME Status PDU
                else if ((GetPduType(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.ServerSetKeyboardIMEStatusPdu)) == 0x07 &&
                (GetPdu2Type(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.ServerSetKeyboardIMEStatusPdu) == 0x2D))
                {
                    var m = BinaryDecoder<ServerSetKeyboardIMEStatusPdu[encryptionLevel, encryptionMethod]>(payload);
                    if (m is msg:ServerSetKeyboardIMEStatusPdu)
                    {
                        dispatch endpoint Server issues msg;
                    }
                    else
                    {
                        ThrowDecodingException("RDPBCGR", "ServerSetKeyboardIMEStatusPdu");
                    }
                }
                // 2.2.9.1.1.3   Server Graphics Update PDU (TS_GRAPHICS_PDU)
                else if ((GetPduType(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.TS_GRAPHICS_PDU)) == 0x07 &&
                (GetPdu2Type(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.TS_GRAPHICS_PDU) == 0x02))
                {
                    var m = BinaryDecoder<TS_GRAPHICS_PDU[encryptionLevel, encryptionMethod]>(payload);
                    if (m is msg:TS_GRAPHICS_PDU)
                    {
                        // Decode order data
                        foreach (var update in msg.slowPathGraphicsUpdates)
                        {
                            if (update is updateOrder:TS_UPDATE_ORDERS_PDU_DATA)
                            {
                                binary data = updateOrder.orderData as binary;
                                int orderNum = 0;
                                stream str = data;
                                array<any> orders = [];
                                while (orderNum < updateOrder.numberOrders && str.RemainingByteLength > 0)
                                {
                                    var order = DecodingOrderData(str, OrderType);
                                    if (order != nothing)
                                    {
                                        orderNum++;
                                        orders += [order];
                                        if (order is o:PRIMARY_DRAWING_ORDER && o.orderType != nothing)
                                        {
                                            OrderType = o.orderType as byte;
                                        }
                                    }
                                    else
                                    {
                                        uint len = str.RemainingByteLength as uint;
                                        orders += [(BinaryDecoder<Blob[len]>(str) as Blob[len]).Data];
                                        ValidationCheck(false, null, DiagnosisLevel.Error, () => Format(RDPBCGR_ORDER_DECODE_ERROR_STR, ["TS_UPDATE_ORDERS_PDU_DATA"]));
                                        break;
                                    }
                                }
                                updateOrder.orderData = orders;
                                bool decodeSucceed = true;
                                while (str.RemainingByteLength > 0 && decodeSucceed)
                                {
                                    switch (str)
                                    {
                                        case u:TS_UPDATE_BITMAP from BinaryDecoder<TS_UPDATE_BITMAP> =>
                                            msg.slowPathGraphicsUpdates += [u];
                                        case u:TS_UPDATE_PALETTE from BinaryDecoder<TS_UPDATE_PALETTE> =>
                                            msg.slowPathGraphicsUpdates += [u];
                                        case u:TS_UPDATE_SYNC from BinaryDecoder<TS_UPDATE_SYNC> =>
                                            msg.slowPathGraphicsUpdates += [u];
                                        default =>
                                            decodeSucceed = false;
                                    }
                                }
                            }
                        }
                        dispatch endpoint Server issues msg;
                    }
                    else
                    {
                        ThrowDecodingException("RDPBCGR", "TS_GRAPHICS_PDU");
                    }
                }
                // 2.2.9.1.1.4   Server Pointer Update PDU (TS_POINTER_PDU)
                else if ((GetPduType(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.TS_POINTER_PDU)) == 0x07 &&
                (GetPdu2Type(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.TS_POINTER_PDU) == 0x1B))
                {
                    var m = BinaryDecoder<TS_POINTER_PDU[encryptionLevel, encryptionMethod]>(payload);
                    if (m is msg:TS_POINTER_PDU)
                    {
                        dispatch endpoint Server issues msg;
                    }
                    else
                    {
                        ThrowDecodingException("RDPBCGR", "TS_POINTER_PDU");
                    }
                }
                // 2.2.9.1.1.5   Server Play Sound PDU
                else if ((GetPduType(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.ServerPlaySoundPdu)) == 0x07 &&
                (GetPdu2Type(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.ServerPlaySoundPdu) == 0x22))
                {
                    var m = BinaryDecoder<ServerPlaySoundPdu[encryptionLevel, encryptionMethod]>(payload);
                    if (m is msg:ServerPlaySoundPdu)
                    {
                        dispatch endpoint Server issues msg;
                    }
                    else
                    {
                        ThrowDecodingException("RDPBCGR", "ServerPlaySoundPdu");
                    }
                }
                // 2.2.10.1   Server Save Session Info PDU
                else if ((GetPduType(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.ServerSaveSessionInfoPdu)) == 0x07 &&
                (GetPdu2Type(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.ServerSaveSessionInfoPdu) == 0x26))
                {
                    var m = BinaryDecoder<ServerSaveSessionInfoPdu[encryptionLevel, encryptionMethod]>(payload);
                    if (m is msg:ServerSaveSessionInfoPdu)
                    {
                        dispatch endpoint Server issues msg;
                    }
                    else
                    {
                        ThrowDecodingException("RDPBCGR", "ServerSaveSessionInfoPdu");
                    }
                }
                // 2.2.12.1   Monitor Layout PDU
                else if ((GetPduType(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.MonitorLayoutPdu)) == 0x07 &&
                (GetPdu2Type(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.MonitorLayoutPdu) == 0x37))
                {
                    var m = BinaryDecoder<MonitorLayoutPdu[encryptionLevel, encryptionMethod]>(payload);
                    if (m is msg:MonitorLayoutPdu)
                    {
                        dispatch endpoint Server issues msg;
                    }
                    else
                    {
                        ThrowDecodingException("RDPBCGR", "MonitorLayoutPdu");
                    }
                }                
                // 2.2.13.3.1   Enhanced Security Server Redirection PDU (TS_ENHANCED_SECURITY_SERVER_REDIRECTION)
                else if ((GetPduType(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.TS_ENHANCED_SECURITY_SERVER_REDIRECTION)) == 0x0A)
                {
                    var m = BinaryDecoder<TS_ENHANCED_SECURITY_SERVER_REDIRECTION>(payload);
                    if (m is msg:TS_ENHANCED_SECURITY_SERVER_REDIRECTION)
                    {
                        dispatch endpoint Server issues msg;
                    }
                    else
                    {
                        ThrowDecodingException("RDPBCGR", "TS_ENHANCED_SECURITY_SERVER_REDIRECTION");
                    }
                } 
                // 2.2.13.2.1   Standard Security Server Redirection PDU (TS_STANDARD_SECURITY_SERVER_REDIRECTION)
                else if ((GetPdu2Type(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.TS_STANDARD_SECURITY_SERVER_REDIRECTION) & 0x04) == 0x04)
                {
                    var m = BinaryDecoder<TS_STANDARD_SECURITY_SERVER_REDIRECTION[encryptionLevel, encryptionMethod]>(payload);
                    if (m is msg:TS_STANDARD_SECURITY_SERVER_REDIRECTION)
                    {
                        dispatch endpoint Server issues msg;
                    }
                    else
                    {
                        ThrowDecodingException("RDPBCGR", "TS_STANDARD_SECURITY_SERVER_REDIRECTION");
                    }
                }
                else 
                {
                    reject;
                }
            }
            else if (channelId == mcsMessageChannelId) // if channelId is mcsMessageChannelId, the pdu should be Server Auto-Detect Request PDU or Server Initiate Multitransport Request
            {
                // 2.2.14.3   Server Auto-Detect Request PDU
                if (IsAutoDetectMsg(payload, encryptionLevel, encryptionMethod, RDPBCGRMsgType.ServerAutoDetectRequestPdu))
                {
                    var m = BinaryDecoder<ServerAutoDetectRequestPdu[encryptionLevel, encryptionMethod]>(payload);
                    if (m is msg:ServerAutoDetectRequestPdu)
                    {
                        dispatch endpoint Server issues msg;
                    }
                    else
                    {
                        ThrowDecodingException("RDPBCGR", "ServerAutoDetectRequestPdu");
                    }
                }
                // 2.2.15.1   Server Initiate Multitransport Request
                else if ((payload[0] & 0x02) == 0x02)
                {
                    var m = BinaryDecoder<ServerInitiateMultitransportRequest[encryptionLevel, encryptionMethod]>(payload);
                    if (m is msg:ServerInitiateMultitransportRequest)
                    {
                        dispatch endpoint Server issues msg;
                    }
                    else
                    {
                        ThrowDecodingException("RDPBCGR", "ServerInitiateMultitransportRequest");
                    }
                }
                // 2.2.16.1    Server Heartbeat PDU
                else if (payload.Count >= 2 && (PeekUShort(payload, 0, Endian.Little) is tsSecurityHeaderFlags:ushort) && 
                    ((tsSecurityHeaderFlags & TSSecurityHeaderFlags.SEC_HEARTBEAT) == TSSecurityHeaderFlags.SEC_HEARTBEAT))
                {
                    var m = BinaryDecoder<TSServerHeartbeatPDU[encryptionLevel, encryptionMethod]>(payload);
                    if (m is msg:TSServerHeartbeatPDU)
                    {
                        dispatch endpoint Server issues msg;
                    }
                    else
                    {
                        ThrowDecodingException("RDPBCGR", "TSServerHeartbeatPDU");
                    }
                }
                else 
                {
                    reject;
                }
            }
            else // channelId in channelNamesMap.Keys
            {
                // 2.2.6.1   Virtual Channel PDU
                if (channelId in channelNamesMap.Keys)
                {
                    var m = BinaryDecoder<VirtualChannelPdu[encryptionLevel, encryptionMethod]>(payload);
                        
                    if (m is msg:VirtualChannelPdu)
                    {
                        msg#ChannelName = channelNamesMap[channelId];
                        if (msg.channelPduHeader.$"flags".CHANNEL_PACKET_COMPRESSED)
                        {
                           // If virtualChannelData is compressed, only show it as top level message
                            DisplayTopLevelMessage(msg);
                        }
                        else
                        {                            
                            if (issuesHelper == null)
                            {
                                issuesHelper = new RDPBCGRReassemblyHelper
                                    {
                                        EPT = endpoint Server,
                                        Direction = MessageDirection.Issues,
                                    };
                            }
                            msg.Origins = [domainMCSPDU];
                            issuesHelper.Reassemble(msg);
                        }
                    }
                    else
                    {
                        ThrowDecodingException("RDPBCGR", "VirtualChannelPdu");
                    }
                }
            }
        }
        // 2.2.1.7   Server MCS Attach User Confirm PDU
        else if (domainMCSPDU.DomainMCSPDU is T125.AttachUserConfirmPattern)
        {
            ServerMCSAttachUserConfirmPdu m = new ServerMCSAttachUserConfirmPdu{};
            m.Origins = [domainMCSPDU];
            dispatch endpoint Server issues m;
        }
        // 2.2.1.9   Server MCS Channel Join Confirm PDU
        else if (domainMCSPDU.DomainMCSPDU is T125.ChannelJoinConfirmPattern)
        {
            ServerMCSChannelJoinConfirmPdu m = new ServerMCSChannelJoinConfirmPdu{};
            m.Origins = [domainMCSPDU];
            dispatch endpoint Server issues m;
        }
        // 2.2.2.3   MCS Disconnect Provider Ultimatum PDU
        else if (domainMCSPDU.DomainMCSPDU is T125.DisconnectProviderUltimatumPattern)
        {
            McsDisconnectProviderUltimatumPdu m = new McsDisconnectProviderUltimatumPdu{};
            m.Origins = [domainMCSPDU];
            dispatch endpoint Server issues m;
        }
        else
        {
            // When ServerMCSConnectResponsePDU is lost, only attach the error message to the first unparsed RDPBCGR message.
            if (initialFlag && !serverMCSConnectResponsePDUReceived)
            {
                ErrorCodeIf(true, domainMCSPDU, DiagnosisLevel.Warning, "RDPBCGR: Lack of MCS channel IDs, encryptionMethod and encryptionLevel due to missing Server MCS Connect Response PDU message.");
                initialFlag = false;
            }
            reject;
        }
    }

    ~endpoint(T125.Node node)
    {
        if (acceptsHelper != null)
        {
            acceptsHelper.ClearInDestructor();
        }
        if (issuesHelper != null)
        {
            issuesHelper.ClearInDestructor();
        }
    }
}

// This actor is used to handle RDP stream from TCP, dispatch slow-path message to ISOTS, and dispath fast-path message to RDPBCGR
autostart actor RDPStreamOverTCP(TCP.Server server)
{
    RDPBCGRDecodingHelper helper = null;
    CsspDecodingHelper csspDecoderHelper = null;
    RDPConfiguration config = GetConfigurableValue<RDPConfiguration>();

    process server accepts s:TCP.Segment where (s.DestinationPort == Port.RDP || s.DestinationPort in config.Ports)
    {
        if (IsCSSP(s.Payload))
        {
            InitializeCssp();
            csspDecoderHelper.TryDecode(s, MessageDirection.Accepts);
            return;
        }
        else if (IsRDSTLSCapabilitiesPdu(s.Payload, s.SourcePort))
        {
            binary headerBin = s.Payload.PeekBytes(16, 4);
            
            switch(headerBin)
            {
                case $[02000100] =>
                    if (BinaryDecoder<RDSTLSAuthRequestPduWithPasswordCredentials>(s.Payload) is msg:RDSTLSAuthRequestPduWithPasswordCredentials)
                    {
                        dispatch endpoint Server accepts msg;
                        return;
                    }
                case $[02000200] =>
                    if (BinaryDecoder<RDSTLSAuthRequestPduWithAutoReconnectCookie>(s.Payload) is msg:RDSTLSAuthRequestPduWithAutoReconnectCookie)
                    {
                        dispatch endpoint Server accepts msg;
                        return;
                    }
                default =>;
            }
        }
        else {}

        Initialize();
        helper.TryDecode(s, MessageDirection.Accepts);
    }

    process server issues s:TCP.Segment where (s.SourcePort == Port.RDP || s.SourcePort in config.Ports)
    {
        if (IsCSSP(s.Payload))
        {
            InitializeCssp();
            csspDecoderHelper.TryDecode(s, MessageDirection.Issues);
            return;
        }
        else if (TryDecodeEarlyUserAuthorizationResultPdu(s.Payload, s.DestinationPort) is msg:EarlyUserAuthorizationResultPdu)
        {
            dispatch endpoint Server issues msg;
            return;
        }
        else if (IsRDSTLSCapabilitiesPdu(s.Payload, s.DestinationPort))
        {
            binary headerBin = s.Payload.PeekBytes(16, 4);
            
            switch(headerBin)
            {
                case $[01000100] =>
                    if (BinaryDecoder<RDSTLSCapabilitiesPdu>(s.Payload) is m:RDSTLSCapabilitiesPdu)
                    {
                        dispatch endpoint Server issues m;
                        return;
                    }
                case $[04000100] =>
                    if (BinaryDecoder<RDSTLSAuthResponsePdu>(s.Payload) is m:RDSTLSAuthResponsePdu)
                    {
                        dispatch endpoint Server issues m;
                        return;
                    }
                default =>;
            }
        }
        else {}

        Initialize();
        helper.TryDecode(s, MessageDirection.Issues);
    }
    
    process server issues s:TCP.Segment
        where server.isMissingThreeWayHandshake && (s.DestinationPort == Port.RDP || s.DestinationPort in config.Ports)
    {
        if (IsCSSP(s.Payload))
        {
            InitializeCssp();
            csspDecoderHelper.TryDecode(s, MessageDirection.Accepts);
            return;
        }

        Initialize();
        helper.TryDecode(s, MessageDirection.Accepts);
    }

    process server accepts s:TCP.Segment
        where server.isMissingThreeWayHandshake && (s.SourcePort == Port.RDP || s.SourcePort in config.Ports)
    {
        if (IsCSSP(s.Payload))
        {
            InitializeCssp();
            csspDecoderHelper.TryDecode(s, MessageDirection.Issues);
            return;
        }

        if (TryDecodeEarlyUserAuthorizationResultPdu(s.Payload, s.DestinationPort) is msg:EarlyUserAuthorizationResultPdu)
        {
            dispatch endpoint Server issues msg;
            return;
        }

        Initialize();
        helper.TryDecode(s, MessageDirection.Issues);
    }
    
    ~endpoint(TCP.Server server)
    {
        if (helper != null)
        {
            helper.ClearInDestructor();
        }
    }

    void Initialize()
    {
        if (helper == null)
        {
            helper = new RDPBCGRDecodingHelper();
            helper.InitializeForRDP(server);
        }
    }

    void InitializeCssp()
    {
        if (csspDecoderHelper == null)
        {
            csspDecoderHelper = new CsspDecodingHelper();
            csspDecoderHelper.InitializeCsspDecodingHelper(server);
        }
    }
}

autostart actor RDPBCGROverTSGU(TSGU.Server server)
{
    ISOTS.Server isotsEPT = null;
    RDPBCGR.Server bcgrEPT = null;
    CSSP.Server csspEPT = null;
    byte orderType = PrimaryDrawingOrderType.TS_ENC_PATBLT_ORDER;
    binary tsguData;
    TransportTypePatt transportType = TransportTypePatt.Unknown;

    process server accepts tsgu:any message where CheckIfTSGUMsgAndGetData(ref transportType, tsgu, ref tsguData, true)
    {
        stream s = tsguData;
        while (s.RemainingByteLength > 0)
        {
            if (IsCSSP(s))
            {
                if (csspEPT == null)
                {
                    csspEPT = endpoint CSSP.Server over server;
                }
                if (Asn1BerDecoder<TSRequest>(s) is cssp:TSRequest)
                {
                    dispatch csspEPT accepts cssp;
                }
                else
                {
                    ThrowDecodingException("CSSP", "TSRequest");
                }
            }
            else if (IsTPKTStream(s) == true)
            {
                if (isotsEPT == null)
                {
                    isotsEPT = endpoint ISOTS.Server over server;
                }
                if (BinaryDecoder<ISOTS.TPKT>(s) is tpkt:ISOTS.TPKT)
                {
                    tpkt#SourcePort = server.remotePort;
                    tpkt#DestinationPort = server.tunnelPort;
                    dispatch isotsEPT accepts tpkt;
                }
                else
                {
                    ThrowDecodingException("ISOTS", "TPKT");
                }
            }
            else // RDPBCGR
            {
                if (bcgrEPT == null)
                {
                    bcgrEPT = endpoint RDPBCGR.Server over server;
                }
                int msgLength = GetRDPBCGRLength(s); // the tsguData may have more than one RDPBCGR message
                binary data = (BinaryDecoder<Blob[msgLength as uint]>(s) as Blob).Data;
                if (BinaryDecoder<RDPBCGR.TS_FP_INPUT_PDU>(data) is pdu:RDPBCGR.TS_FP_INPUT_PDU)
                {
                    dispatch bcgrEPT accepts pdu;
                }
                else
                {
                    ThrowDecodingException("RDPBCGR", "TS_FP_INPUT_PDU");
                }
            }
        }
    }

    process server issues tsgu:any message where CheckIfTSGUMsgAndGetData(ref transportType, tsgu, ref tsguData, false)
    {
        stream s = tsguData;
        while (s.RemainingByteLength > 0)
        {
            if (IsCSSP(s))
            {
                if (csspEPT == null)
                {
                    csspEPT = endpoint CSSP.Server over server;
                }
                if (Asn1BerDecoder<TSRequest>(s) is cssp:TSRequest)
                {
                    dispatch csspEPT issues cssp;
                }
                else
                {
                    ThrowDecodingException("CSSP", "TSRequest");
                }
            }
            else if (IsTPKTStream(s) == true)
            {
                if (isotsEPT == null)
                {
                    isotsEPT = endpoint ISOTS.Server over server;
                }
                if (BinaryDecoder<ISOTS.TPKT>(s) is tpkt:ISOTS.TPKT)
                {
                    tpkt#SourcePort = server.tunnelPort;
                    tpkt#DestinationPort = server.remotePort;
                    dispatch isotsEPT issues tpkt;
                }
                else
                {
                    ThrowDecodingException("ISOTS", "TPKT");
                }
            }
            else // RDPBCGR
            {
                if (bcgrEPT == null)
                {
                    bcgrEPT = endpoint RDPBCGR.Server over server;
                }
                if (TryDecodeEarlyUserAuthorizationResultPdu(s, server.remotePort) is msg:EarlyUserAuthorizationResultPdu)
                {
                    dispatch bcgrEPT issues msg;
                }
                else
                {
                    int msgLength = GetRDPBCGRLength(s); // the tsguData may have more than one RDPBCGR message
                    binary data = (BinaryDecoder<Blob[msgLength as uint]>(s) as Blob).Data;
                    if (BinaryDecoder<TS_FP_UPDATE_PDU>(data) is updatePdu:TS_FP_UPDATE_PDU)
                    {
                        if (updatePdu.fpOutputUpdates is updates:array<TS_FP_UPDATE>)
                        {
                            foreach (var update in updates)
                            {
                                if (update is orderUpdate:TS_FP_UPDATE_ORDERS)
                                {
                                    if (orderUpdate.orderData is orderDataBin:binary)
                                    {
                                        stream str = orderDataBin;
                                        array<any> orders = [];
                                        while (str.RemainingByteLength > 0)
                                        {
                                            var order = DecodingOrderData(str, orderType);
                                            if (order != nothing)
                                            {
                                                orders += [order];
                                                if (order is o:PRIMARY_DRAWING_ORDER && o.orderType != nothing)
                                                {
                                                    orderType = o.orderType as byte;
                                                }
                                            }
                                            else
                                            {
                                                uint len = str.RemainingByteLength as uint;
                                                orders += [(BinaryDecoder<Blob[len]>(str) as Blob[len]).Data];
                                                ValidationCheck(false, null, DiagnosisLevel.Error, () => Format(RDPBCGR_ORDER_DECODE_ERROR_STR, ["TS_FP_UPDATE_ORDERS"]));
                                                break;
                                            }
                                        }
                                        orderUpdate.orderData = orders;
                                    }
                                    else
                                    {
                                        break;
                                    }
                                }
                            }
                        }
                        dispatch bcgrEPT issues updatePdu;
                    }
                    else
                    {
                        ThrowDecodingException("RDPBCGR", "TS_FP_INPUT_PDU");
                    }
                }
            }
        }
    }
}

optional EarlyUserAuthorizationResultPdu TryDecodeEarlyUserAuthorizationResultPdu(stream data, ushort indexPort)
{
    long selectedProtocol = (indexPort in selectedProtocols) ? selectedProtocols[indexPort] : -1;
    if (selectedProtocol == SelectedProtocol.PROTOCOL_HYBRID_EX &&
        data.RemainingByteLength == 4)
    {
        return BinaryDecoder<EarlyUserAuthorizationResultPdu>(data);
    }
    return nothing;
}

bool IsRDSTLSCapabilitiesPdu(stream s, ushort indexPort)
{
    long selectedProtocol = (indexPort in selectedProtocols) ? selectedProtocols[indexPort] : -1;
    if (selectedProtocol == SelectedProtocol.PROTOCOL_RDSTLS && s.RemainingByteLength >= 8 && // at lease 8 bytes for RDSTLS messages
        s.PeekUShort(0, Endian.Little) == 1) // Version must be set to RDSTLS_VERSION_1 (0x0001).
    {
        return true;
    }

    return false;
}

pattern LowerMsg = enum uint
{
    T125ConnectInitial,
    T125ConnectResponse,
    T124ConnectData,
    T124ConferenceCreateRequest,
    T124ConferenceCreateResponse,
    T125SendDataRequest,
    T125SendDataRequestPer,
    T125SendDataIndication,
    T125SendDataIndicationPer,
    ...
};

pattern RDPBCGRMsgType = enum uint
{
    ClientMcsConnectInitialPduWithGccConferenceCreateRequest,
    ServerMCSConnectResponsePDUWithGccConferenceCreateResponse,
    ClientSecurityExchangePdu,
    ClientInfoPdu,
    ServerDemandActivePdu,
    ClientConfirmActivePdu,
    ClientSynchronizePdu,
    ClientControlPduCoOperate,
    ClientControlPduRequestControl,
    ClientPersistentKeyListPdu,
    ClientFontListPdu,
    ServerSynchronizePdu,
    ServerControlPduCoOperate,
    ServerControlPduGrantedControl,
    ServerFontMapPdu,
    ClientShutdownRequestPdu,
    ServerShutdownRequestDeniedPdu,
    ServerDeactivateAllPdu,
    ServerAutoReconnectStatusPdu,
    VirtualChannelPduRequest,
    VirtualChannelPduResponse,
    TS_INPUT_PDU,
    ServerSetKeyboardIndicatorsPdu,
    ServerSetKeyboardIMEStatusPdu,
    TS_GRAPHICS_PDU,
    TS_POINTER_PDU,
    ServerPlaySoundPdu,
    ServerSaveSessionInfoPdu,
    MonitorLayoutPdu,
    ClientRefreshRectPdu,
    ClientSuppressOutputPdu,
    TS_STANDARD_SECURITY_SERVER_REDIRECTION,
    TS_ENHANCED_SECURITY_SERVER_REDIRECTION,
    ServerAutoDetectRequestPdu,
    ClientAutoDetectResponsePdu,
    ServerSetErrorInfoPdu,
    ServerStatusInfoPdu,
    ServerLicenseErrorPdu,
    ...
};

int GetPduType(binary payload, TSUDSCSec1EncryptionLevel encryptionLevel, TSUDSCSec1EncryptionMethod encryptionMethod, RDPBCGRMsgType msgType)
{
    // Skip RDPELE messages
    if (payload[0] == 0x80)
    {
        return 0xFF;
    }

    int msgOffset = 0;
    
    if (encryptionLevel == TSUDSCSec1EncryptionLevel.ENCRYPTION_LEVEL_LOW)
    {
        msgOffset = msgOffset + 4;
    }
    else if (encryptionMethod in {TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_40BIT,
                                 TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_128BIT,
                                 TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_56BIT})
    {
        msgOffset = msgOffset + 12;
    }
    else if (encryptionMethod == TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_FIPS)
    {
        msgOffset = msgOffset + 16;
    }
    msgOffset = msgOffset + 2;
    // If payload length is not greater than msgOffset, return an invalid pdu type.
    if (payload.Count <= msgOffset)
    {
        return 0x00;
    }
    if (msgType == RDPBCGRMsgType.ServerDeactivateAllPdu)
    {
        if (payload[msgOffset] == 0x16)
        {
            return 0x06;
        }
        else
        {
            return 0x00;
        }
    }
    else
    {
        if ((payload[msgOffset] & 0xF0) != 0x10) // PDUVersion must be 1
        {
            // 2.2.13.3.1: PDUVersion could be 0 for TS_ENHANCED_SECURITY_SERVER_REDIRECTION
            if (msgType != RDPBCGRMsgType.TS_ENHANCED_SECURITY_SERVER_REDIRECTION)
            {
                return 0x00;
            }
        }

        return payload[msgOffset] & 0x0F;
    }
}
    
int GetPdu2Type(binary payload, TSUDSCSec1EncryptionLevel encryptionLevel, TSUDSCSec1EncryptionMethod encryptionMethod, RDPBCGRMsgType msgType)
{
    int msgOffset = 0;
    byte securityFlag = payload[0];
    if (msgType == RDPBCGRMsgType.TS_STANDARD_SECURITY_SERVER_REDIRECTION)
        return securityFlag;
    if (encryptionLevel == TSUDSCSec1EncryptionLevel.ENCRYPTION_LEVEL_LOW)
    {
        msgOffset = msgOffset + 4;
    }
    else if (encryptionMethod in {TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_40BIT,
                                    TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_128BIT,
                                    TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_56BIT})
    {
        msgOffset = msgOffset + 12;
    }
       else if (encryptionMethod == TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_FIPS)
    {
        msgOffset = msgOffset + 16;
    }
    if ((msgType != RDPBCGRMsgType.TS_STANDARD_SECURITY_SERVER_REDIRECTION) && msgType != (RDPBCGRMsgType.ServerAutoDetectRequestPdu))
    {
        msgOffset = msgOffset + 14;
    }
    // If payload length is not greater than msgOffset, return an invalid pdu type.
    if (payload.Count <= msgOffset)
    {
        return 0x00;
    }
    else if (payload.Count == msgOffset + 1)
    {
        return payload[msgOffset];
    }
    if ((msgType == RDPBCGRMsgType.ServerAutoDetectRequestPdu) && 
       ((securityFlag & 0x10) == 0x10) && 
       (payload[msgOffset] == 0x06) && 
       (payload[msgOffset + 1] == 0x00))
        return msgOffset;
    else if ((msgType == RDPBCGRMsgType.ClientAutoDetectResponsePdu) &&
            ((securityFlag & 0x20) == 0x20) && 
            (payload[msgOffset] == 0x06) && 
            (payload[msgOffset + 1] == 0x01))
        return msgOffset;
    else
        return payload[msgOffset];
}

// 2.2.1.1   Client X.224 Connection Request PDU
message ClientX224ConnectionRequestPdu[bool StringPresent]
{
    // Same with cookie
    optional [|StringPresent|] string routingToken 
        with BinaryEncoding{TextEncoding = TextEncoding.ASCII, TextTerminator = "\n"};
    optional [|RemainingByteLength(stream) >= 1 && CurrentByte(stream) == 1|]RDP_NEG_REQ rdpNegReq;
    optional [|(rdpNegReq != nothing) && (((rdpNegReq as RDP_NEG_REQ).$"flags" & 0x08) == 0x08)|] RDP_NEG_CORRELATION_INFO rdpCorrelationInfo;

    override string ToString()
    {
       string summary = "Client X.224 Connection Request PDU";
       if (rdpNegReq is req:RDP_NEG_REQ)
       {
           summary += ", requestedProtocols: " + EnumToStringInSummary<RDPBCGR.RequestedProtocols>(req.requestedProtocols);
       }
       return summary;
    }
}

// 2.2.1.1.1   RDP Negotiation Request (RDP_NEG_REQ)
type RDP_NEG_REQ
{
    byte $"type" where value == 1;
    RDP_NEG_REQ_flags $"flags";
    ushort length where ValidationCheckValue(value == 8, null, true, 
        ReferenceType.Type, "RDPBCGR", "length", "RDP_NEG_REQ", 8, value);
    RequestedProtocols requestedProtocols;
}

pattern RDP_NEG_REQ_flags = flags byte
{
    RESTRICTED_ADMIN_MODE_REQUIRED = 0x01
        with Documentation
            {Description = "The client requires credential-less logon over CredSSP."},
    CORRELATION_INFO_PRESENT = 0x08
        with Documentation
            {Description = "The optional rdpCorrelationInfo field of the 224 Connection Request PDU is present."},
    ...
};

// requestedProtocols
pattern RequestedProtocols = flags uint 
{
    PROTOCOL_RDP = 0x00000000
        with Documentation
            {Description = "Standard RDP Security."},
    PROTOCOL_SSL = 0x00000001
        with Documentation
            {Description = "TLS 1.0, 1.1, or 1.2."},
    PROTOCOL_HYBRID = 0x00000002
        with Documentation
            {Description = "Credential Security Support Provider protocol (CredSSP)."},
    PROTOCOL_RDSTLS = 0x00000004
        with Documentation
            {Description = "RDSTLS protocol."},
    PROTOCOL_HYBRID_EX = 0x00000008
        with Documentation
            {Description = "Credential Security Support Provider protocol (CredSSP) coupled with the Early User Authorization Result PDU."},
    ...
};

// 2.2.1.1.2 RDP Correlation Info (RDP_NEG_CORRELATION_INFO)
type RDP_NEG_CORRELATION_INFO
{
    byte $"type" where ValidationCheckValue(value == 0x06, null, true, ReferenceType.Type, 
        "RDPBCGR", "type", "RDP_NEG_CORRELATION_INFO", "0x06", value);
    byte $"flags" where ValidationCheckZero(value == 0, null, true, ReferenceType.Type, 
        "RDPBCGR", "flags", "RDP_NEG_CORRELATION_INFO", value);
    ushort length where ValidationCheckValue(value == 0x0024, null, true, ReferenceType.Type, 
        "RDPBCGR", "length", "RDP_NEG_CORRELATION_INFO", "0x0024", value);
    binary correlationId with BinaryEncoding{Length = 16};
    binary reserved with BinaryEncoding{Length = 16};
}

// 2.2.1.2   Server X.224 Connection Confirm PDU
message ServerX224ConnectionConfirmPdu
{
    optional ([|RemainingByteLength(stream) >= 1 && CurrentByte(stream) == 2|]RDP_NEG_RSP | 
              [|RemainingByteLength(stream) >= 1 && CurrentByte(stream) == 3|]RDP_NEG_FAILURE) rdpNegData;
    override string ToString()
    {
        string summary = "Server X.224 Connection Confirm PDU";
        if (rdpNegData is res:RDP_NEG_RSP)
        {
            summary += ", selectedProtocol: " + EnumToStringInSummary<RDPBCGR.SelectedProtocol>(res.selectedProtocol);
        }
        else if (rdpNegData is failure:RDP_NEG_FAILURE)
        {
            summary += ", failureCode: " + EnumToStringInSummary<RDPBCGR.RdpNegFailureFailureCode>(failure.failureCode);
        }
        return summary;
    }
};

// 2.2.1.2.1   RDP Negotiation Response (RDP_NEG_RSP)
type RDP_NEG_RSP
{
    (byte where value == 0x02) $"type";
    RdpNegRspFlags $"flags";
    ushort length where ValidationCheckValue(value == 0x0008, null, true, 
        ReferenceType.Type, "RDPBCGR", "length ", "RDP_NEG_RSP", "0x0008", value);
    SelectedProtocol selectedProtocol;
}

pattern RdpNegRspFlags = flags byte
{
    EXTENDED_CLIENT_DATA_SUPPORTED = 0x01
        with Documentation
            {Description = "The server supports Extended Client Data Blocks in the GCC Conference Create Request user data."},
    DYNVC_GFX_PROTOCOL_SUPPORTED = 0x02
        with Documentation
            {Description = "The server supports the Graphics Pipeline Extension Protocol."},
    NEGRSP_FLAG_RESERVED = 0x04
        with Documentation
            {Description = "An unused flag that is reserved for future use."},
    RESTRICTED_ADMIN_MODE_SUPPORTED = 0x08
        with Documentation
            {Description = "The server supports credential-less logon over CredSSP and it is acceptable for the client to send empty credentials in the TSPasswordCreds structure."},
    REDIRECTED_AUTHENTICATION_MODE_SUPPORTED = 0x10
        with Documentation
            {Description = "The server supports credential-less logon over CredSSP with credential redirection. The client can send a redirected logon buffer in the TSRemoteGuardCreds structure."},
    ...
};

pattern SelectedProtocol = enum uint
{
    PROTOCOL_RDP = 0x00000000,
    PROTOCOL_SSL = 0x00000001,
    PROTOCOL_HYBRID = 0x00000002,
    PROTOCOL_RDSTLS = 0x00000004,
    PROTOCOL_HYBRID_EX = 0x00000008,
    ...
};

// 2.2.1.2.2   RDP Negotiation Failure (RDP_NEG_FAILURE)
type RDP_NEG_FAILURE
{
    (byte where value == 0x03) $"type";
    (byte where value == 0x00) $"flags";
    ushort length where ValidationCheckValue(value == 0x0008, null, true, 
        ReferenceType.Type, "RDPBCGR", "length ", "RDP_NEG_FAILURE", "0x0008", value);
    RdpNegFailureFailureCode failureCode;
}

pattern RdpNegFailureFailureCode = enum uint
{
    SSL_REQUIRED_BY_SERVER = 0x00000001,
    SSL_NOT_ALLOWED_BY_SERVER = 0x00000002,
    SSL_CERT_NOT_ON_SERVER = 0x00000003,
    INCONSISTENT_FLAGS = 0x00000004,
    HYBRID_REQUIRED_BY_SERVER = 0x00000005,
    SSL_WITH_USER_AUTH_REQUIRED_BY_SERVER = 0x00000006,
    ...
};

// 2.2.1.3   Client MCS Connect Initial PDU with GCC Conference Create Request
message ClientMcsConnectInitialPduWithGccConferenceCreateRequest
{
    array<TSUDCSType> TSUD;
    
    override string ToString()
    {
        string summary = "Client MCS Connect Initial PDU with GCC Conference Create Request";
        foreach (var tsud in TSUD)
        {
            if (tsud is sec:TS_UD_CS_SEC)
            {
                summary += ", encryptionMethods: " + EnumToStringInSummary<RDPBCGR.TSUDCSSecEncryptionMethods>(sec.encryptionMethods);
            }
            else if (tsud is TS_UD_CS_NET)
            {
                summary += ", " + tsud.ToString();
            }
        }
        return summary;
    }
}

pattern TSUDCSType = [|RemainingBitLength(stream) >= 16|]
(
    [|stream.PeekUShort(stream.BitPosition, Endian.Little) == TSUDHeaderType.CS_CORE|] TS_UD_CS_CORE |
    [|stream.PeekUShort(stream.BitPosition, Endian.Little) == TSUDHeaderType.CS_CLUSTER|] TS_UD_CS_CLUSTER |
    [|stream.PeekUShort(stream.BitPosition, Endian.Little) == TSUDHeaderType.CS_SECURITY|] TS_UD_CS_SEC |
    [|stream.PeekUShort(stream.BitPosition, Endian.Little) == TSUDHeaderType.CS_NET|] TS_UD_CS_NET |
    [|stream.PeekUShort(stream.BitPosition, Endian.Little) == TSUDHeaderType.CS_MONITOR|] TS_UD_CS_MONITOR |
    [|stream.PeekUShort(stream.BitPosition, Endian.Little) == TSUDHeaderType.CS_MCS_MSGCHANNEL|] TS_UD_CS_MCS_MSGCHANNEL |
    [|stream.PeekUShort(stream.BitPosition, Endian.Little) == TSUDHeaderType.CS_MULTITRANSPORT|] TS_UD_CS_MULTITRANSPORT |
    [|stream.PeekUShort(stream.BitPosition, Endian.Little) == TSUDHeaderType.CS_MONITOR_EX|] TS_UD_CS_MONITOR_EX
);

// 2.2.1.3.1   User Data Header (TS_UD_HEADER)
type TS_UD_HEADER
{
    TSUDHeaderType $"type";
    ushort length;
};

pattern TSUDHeaderType = enum ushort
{
    CS_CORE = 0xC001,
    CS_SECURITY = 0xC002,
    CS_NET = 0xC003,
    CS_CLUSTER = 0xC004,
    CS_MONITOR = 0xC005,
    CS_MCS_MSGCHANNEL = 0xC006,
    CS_MONITOR_EX = 0xC008,
    CS_MULTITRANSPORT = 0xC00A,
    SC_CORE = 0x0C01,
    SC_SECURITY = 0x0C02,
    SC_NET = 0x0C03,
    SC_MCS_MSGCHANNEL = 0x0C04,
    SC_MULTITRANSPORT = 0x0C08,
    ...
};

// 2.2.1.3.2   Client Core Data (TS_UD_CS_CORE)
type TS_UD_CS_CORE
{
    TS_UD_HEADER header where value.$"type" == TSUDHeaderType.CS_CORE;
    TSUDCSCoreVersion version;
    ushort desktopWidth;
    ushort desktopHeight;
    TSUDCSCoreColorDepth colorDepth;
    ushort SASSequence where ValidationCheckValue(value == 0xAA03, null, false, ReferenceType.Type, 
        "RDPBCGR", "SASSequence", "TS_UD_CS_CORE", "RNS_UD_SAS_DEL(0xAA03)", value);
    uint keyboardLayout;
    uint clientBuild;
    string clientName with BinaryEncoding{TextEncoding = TextEncoding.Unicode, Length = 16};
    KeyboardType keyboardType;
    uint keyboardSubType;
    uint keyboardFunctionKey;
    string imeFileName with BinaryEncoding{TextEncoding = TextEncoding.Unicode, Length = 32};
    optional ([|header.length > 132|] TSUDCSCorePostBeta2ColorDepth) postBeta2ColorDepth;
    optional ([|header.length > 134|] ushort) clientProductId;
    optional ([|header.length > 136|] uint) serialNumber;
    optional ([|header.length > 140|] TSUDCSCoreHighColorDepth) highColorDepth;
    optional ([|header.length > 142|] TSUDCSCoreSupportedColorDepths) supportedColorDepths;
    optional ([|header.length > 144|] TSUDCSCoreEarlyCapabilityFlags) earlyCapabilityFlags;
    optional ([|header.length > 146|] string) clientDigProductId 
        with BinaryEncoding{TextEncoding = TextEncoding.Unicode, Length = 32};
    optional ([|header.length > 210|] TSUDCSCoreConnectionType) connectionType;
    optional ([|header.length > 211|] byte) pad1octet;
    optional ([|header.length > 212|] SelectedProtocol) serverSelectedProtocol;
    optional ([|header.length > 216|] uint) desktopPhysicalWidth;
    optional ([|header.length > 220|] uint) desktopPhysicalHeight;
    optional ([|header.length > 224|] TSUDCSCoreDesktopOrientation) desktopOrientation;
    optional ([|header.length > 226|] uint) desktopScaleFactor;
    optional ([|header.length > 230|] uint) deviceScaleFactor;
    
    override string ToString()
    {
        return "TS_UD_CS_CORE";
    }
}

pattern TSUDCSCoreVersion = enum uint
{
    RDP_4_0  = 0x00080001,
    RDP_5_0To8_1 = 0x00080004,
    RDP_10_0 = 0x00080005,
    RDP_10_1 = 0x00080006,
    RDP_10_2 = 0x00080007,
    RDP_10_3 = 0x00080008,
    RDP_10_4 = 0x00080009,
    RDP_10_5 = 0x0008000A,
    RDP_10_6 = 0x0008000B,
    RDP_10_7 = 0x0008000C,
    ...
};

pattern TSUDCSCoreColorDepth = enum ushort
{
    RNS_UD_COLOR_4BPP = 0xCA00,
    RNS_UD_COLOR_8BPP = 0xCA01,
    ...
};

pattern TSUDCSCorePostBeta2ColorDepth = enum ushort
{
    RNS_UD_COLOR_4BPP = 0xCA00,
    RNS_UD_COLOR_8BPP = 0xCA01,
    RNS_UD_COLOR_16BPP_555 = 0xCA02,
    RNS_UD_COLOR_16BPP_565 = 0xCA03,
    RNS_UD_COLOR_24BPP = 0xCA04,
    ...
};

pattern TSUDCSCoreHighColorDepth = enum ushort
{
    HIGH_COLOR_4BPP = 0x0004,
    HIGH_COLOR_8BPP = 0x0008,
    HIGH_COLOR_15BPP = 0x000F,
    HIGH_COLOR_16BPP = 0x0010,
    HIGH_COLOR_24BPP = 0x0018,
    ...
};

pattern TSUDCSCoreSupportedColorDepths = flags ushort
{
    RNS_UD_24BPP_SUPPORT = 0x0001
        with Documentation
            {Description = "24-bit RGB mask (8 bits for red, 8 bits for green, and 8 bits for blue)."},
    RNS_UD_16BPP_SUPPORT = 0x0002
        with Documentation
            {Description = "16-bit 565 RGB mask (5 bits for red, 6 bits for green, and 5 bits for blue)."},
    RNS_UD_15BPP_SUPPORT = 0x0004
        with Documentation
            {Description = "15-bit 555 RGB mask (5 bits for red, 5 bits for green, and 5 bits for blue)."},
    RNS_UD_32BPP_SUPPORT = 0x0008
        with Documentation
            {Description = "32-bit RGB mask (8 bits for the alpha channel, 8 bits for red, 8 bits for green, and 8 bits for blue)."},
    ...
};

pattern TSUDCSCoreEarlyCapabilityFlags = flags ushort
{
    RNS_UD_CS_SUPPORT_ERRINFO_PDU = 0x0001
        with Documentation
            {Description = "The client supports the Set Error Info PDU."},
    RNS_UD_CS_WANT_32BPP_SESSION = 0x0002
        with Documentation
            {Description = "The client is requesting a session color depth of 32 bpp."},
    RNS_UD_CS_SUPPORT_STATUSINFO_PDU = 0x0004
        with Documentation
            {Description = "The client supports the Server Status Info PDU."},
    RNS_UD_CS_STRONG_ASYMMETRIC_KEYS = 0x0008
        with Documentation
            {Description = "The client supports asymmetric keys larger than 512 bits for use with the Server Certificate sent in the Server Security Data block."},
    RNS_UD_CS_UNUSED = 0x0010
        with Documentation
            {Description = "An unused flag that MUST be ignored by the server."},
    RNS_UD_CS_VALID_CONNECTION_TYPE = 0x0020
        with Documentation
            {Description = "The connectionType field contains valid data."},
    RNS_UD_CS_SUPPORT_MONITOR_LAYOUT_PDU = 0x0040
        with Documentation
            {Description = "The client supports the Monitor Layout PDU."},
    RNS_UD_CS_SUPPORT_NETCHAR_AUTODETECT = 0x0080
        with Documentation
            {Description = "The client supports network characteristics detection using the structures and PDUs."},
    RNS_UD_CS_SUPPORT_DYNVC_GFX_PROTOCOL = 0x0100
        with Documentation
            {Description = "The client supports the Graphics Pipeline Extension Protocol."},
    RNS_UD_CS_SUPPORT_DYNAMIC_TIME_ZONE = 0x0200
        with Documentation
            {Description = "The client supports Dynamic DST."},
    RNS_UD_CS_SUPPORT_HEARTBEAT_PDU = 0x0400
        with Documentation
            {Description = "The client supports the Heartbeat PDU."},
    ...
};

pattern TSUDCSCoreConnectionType = enum byte
{
    CONNECTION_TYPE_MODEM = 0x01,
    CONNECTION_TYPE_BROADBAND_LOW = 0x02,
    CONNECTION_TYPE_SATELLITE = 0x03,
    CONNECTION_TYPE_BROADBAND_HIGH = 0x04,
    CONNECTION_TYPE_WAN = 0x05,
    CONNECTION_TYPE_LAN = 0x06,
    CONNECTION_TYPE_AUTODETECT = 0x07,
    ...
};

pattern TSUDCSCoreDesktopOrientation = enum ushort
{
    ORIENTATION_LANDSCAPE = 0,
    ORIENTATION_PORTRAIT = 90,
    ORIENTATION_LANDSCAPE_FLIPPED = 180,
    ORIENTATION_PORTRAIT_FLIPPED = 270,
    ...
};

// 2.2.1.3.3   Client Security Data (TS_UD_CS_SEC)
type TS_UD_CS_SEC
{
    TS_UD_HEADER header where value.$"type" == TSUDHeaderType.CS_SECURITY;
    TSUDCSSecEncryptionMethods encryptionMethods 
        where ValidationCheckCombinationValue(InRange<TSUDCSSecEncryptionMethods>(value), null, true, ReferenceType.Type, 
        "RDPBCGR", "encryptionMethods", "TS_UD_CS_SEC", "0x00000001, 0x00000002, 0x00000008, 0x00000010", value);
    TSUDCSSecEncryptionMethods extEncryptionMethods;

    override string ToString()
    {
        return "TS_UD_CS_SEC";
    }
}

pattern TSUDCSSecEncryptionMethods = flags uint
{
    $"40BIT_ENCRYPTION_FLAG" = 0x00000001
        with Documentation
            {Description = "40-bit session keys MUST be used to encrypt data (with RC4) and generate Message Authentication Codes (MAC)."},
    $"128BIT_ENCRYPTION_FLAG" = 0x00000002
        with Documentation
            {Description = "128-bit session keys MUST be used to encrypt data (with RC4) and generate MACs."},
    $"56BIT_ENCRYPTION_FLAG" = 0x00000008
        with Documentation
            {Description = "56-bit session keys MUST be used to encrypt data (with RC4) and generate MACs."},
    FIPS_ENCRYPTION_FLAG = 0x00000010
        with Documentation
            {Description = "All encryption and Message Authentication Code generation routines MUST be Federal Information Processing Standard (FIPS) 140-1 compliant."},
    ...
};

// 2.2.1.3.4   Client Network Data (TS_UD_CS_NET)
type TS_UD_CS_NET
{
    TS_UD_HEADER header where value.$"type" == TSUDHeaderType.CS_NET;
    uint channelCount;
    array<CHANNEL_DEF> channelDefArray with BinaryEncoding{Length = channelCount};

    override string ToString()
    {
        string summary = "channelDefArray: ";
        int cnt = 0;
        if (channelDefArray.Count > 1)
        {
            summary += "[";
        }            
        foreach (var channel in channelDefArray)
        {
            if (cnt > 4)
            {
                summary += " ...";
                break;
            }
            else if (cnt > 0)
            {
                summary += ", ";
            }
            summary += channel.name;
            cnt++;
        }
        if (cnt > 1)
        {
            summary += "]";
        }
        return summary;
    }
};

// 2.2.1.3.4.1   Channel Definition Structure (CHANNEL_DEF)
type CHANNEL_DEF
{
    string name with BinaryEncoding{TextEncoding = TextEncoding.ASCII, Length = 8};
    ChannelDefOptions options;

    override string ToString()
    {
        return name + ", " + EnumToString<ChannelDefOptions>(options);
    }
};

pattern ChannelDefOptions = flags uint
{
    CHANNEL_OPTION_INITIALIZED = 0x80000000
        with Documentation
            {Description = "Absence of this flag indicates that this channel is a placeholder and that the server MUST NOT set it up."},
    CHANNEL_OPTION_ENCRYPT_RDP = 0x40000000
        with Documentation
            {Description = "This flag is unused and its value MUST be ignored by the server."},
    CHANNEL_OPTION_ENCRYPT_SC = 0x20000000
        with Documentation
            {Description = "This flag is unused and its value MUST be ignored by the server."},
    CHANNEL_OPTION_ENCRYPT_CS = 0x10000000
        with Documentation
            {Description = "This flag is unused and its value MUST be ignored by the server."},
    CHANNEL_OPTION_PRI_HIGH = 0x08000000
        with Documentation
            {Description = "Channel data MUST be sent with high MCS priority."},
    CHANNEL_OPTION_PRI_MED = 0x04000000
        with Documentation
            {Description = "Channel data MUST be sent with medium MCS priority."},
    CHANNEL_OPTION_PRI_LOW = 0x02000000
        with Documentation
            {Description = "Channel data MUST be sent with low MCS priority."},
    CHANNEL_OPTION_COMPRESS_RDP = 0x00800000
        with Documentation
            {Description = "Virtual channel data MUST be compressed if RDP data is being compressed."},
    CHANNEL_OPTION_COMPRESS = 0x00400000
        with Documentation
            {Description = "Virtual channel data MUST be compressed, regardless of RDP compression settings."},
    CHANNEL_OPTION_SHOW_PROTOCOL = 0x00200000
        with Documentation
            {Description = "The value of this flag MUST be ignored by the server."},
    REMOTE_CONTROL_PERSISTENT = 0x00100000
        with Documentation
            {Description = "Channel MUST be persistent across remote control transactions."},
    ...
};

// 2.2.1.3.5   Client Cluster Data (TS_UD_CS_CLUSTER)
type TS_UD_CS_CLUSTER
{
    TS_UD_HEADER header where value.$"type" == TSUDHeaderType.CS_CLUSTER;
    TSUDCSClusterFlags Flags;
    uint RedirectedSessionID;
    override string ToString()
    {
        return "TS_UD_CS_CLUSTER";
    }
};

type TSUDCSClusterFlags
{
    uint Reserved with BinaryEncoding{Endian = Endian.Big, Width = 25};
    bool REDIRECTED_SMARTCARD with BinaryEncoding{Width = 1}; // 0x00000040
    TSUDCSClusterRedirectionVersion ServerSessionRedirectionVersionMask
        with BinaryEncoding{Endian = Endian.Big, Width = 4}; // 0x0000003C
    bool REDIRECTED_SESSIONID_FIELD_VALID with BinaryEncoding{Width = 1}; // 0x00000002
    bool REDIRECTION_SUPPORTED with BinaryEncoding{Width = 1}; // 0x00000001
    override string ToString()
    {
        string summary;
        int i = 0;
        if (REDIRECTION_SUPPORTED)
        {
            summary += "REDIRECTION_SUPPORTED";
            i++;
        }
        if (REDIRECTED_SESSIONID_FIELD_VALID)
        {
            summary += (i > 0 ? "|" : "") + "REDIRECTED_SESSIONID_FIELD_VALID";
            i++;
        }
        summary += (i > 0 ? "|" : "") + 
            EnumToStringInSummary<RDPBCGR.TSUDCSClusterRedirectionVersion>(ServerSessionRedirectionVersionMask);
        if (REDIRECTED_SMARTCARD)
        {
            summary += (i > 0 ? "|" : "") + "REDIRECTED_SMARTCARD";
        }
        return summary;
    }
}with BinaryEncoding{Endian = Endian.Little, WidthForComposedType = 32, DecodeAsUnit = true};

pattern TSUDCSClusterRedirectionVersion = enum byte
{
    REDIRECTION_VERSION1 = 0x00,
    REDIRECTION_VERSION2 = 0x01,
    REDIRECTION_VERSION3 = 0x02,
    REDIRECTION_VERSION4 = 0x03,
    REDIRECTION_VERSION5 = 0x04,
    REDIRECTION_VERSION6 = 0x05,
    ...
};

// 2.2.1.3.6   Client Monitor Data (TS_UD_CS_MONITOR)
type TS_UD_CS_MONITOR
{
    TS_UD_HEADER header where value.$"type" == TSUDHeaderType.CS_MONITOR;
    uint $"flags" where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "RDPBCGR", "flags", "TS_UD_CS_MONITOR", value);
    uint monitorCount;
    array<TS_MONITOR_DEF> monitorDefArray with BinaryEncoding{Length = monitorCount};

    override string ToString()
    {
        return "TS_UD_CS_MONITOR";
    }
}

// 2.2.1.3.6.1   Monitor Definition (TS_MONITOR_DEF)
type TS_MONITOR_DEF
{
    uint left;
    uint top;
    uint right;
    uint bottom;
    TsMonitorDefFlags $"flags";

    override string ToString()
    {
        return "TS_MONITOR_DEF, left: " + left.ToString() + ", top: " + top.ToString() + ", right: " + right.ToString() + ", bottom" + bottom.ToString();
    }
}

pattern TsMonitorDefFlags = flags uint
{
    TS_MONITOR_PRIMARY = 0x00000001
        with Documentation
            {Description = "The top, left, right, and bottom fields describe the position of the primary monitor."},
    ...
};

// 2.2.1.3.7   Client Message Channel Data (TS_UD_CS_MCS_MSGCHANNEL)
type TS_UD_CS_MCS_MSGCHANNEL
{
    TS_UD_HEADER header where value.$"type" == TSUDHeaderType.CS_MCS_MSGCHANNEL;
    uint $"flags" where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "RDPBCGR", "flags", "TS_UD_CS_MCS_MSGCHANNEL", value);

    override string ToString()
    {
        return "TS_UD_CS_MCS_MSGCHANNEL";
    }
}

// 2.2.1.3.8   Client Multitransport Channel Data (TS_UD_CS_MULTITRANSPORT)
type TS_UD_CS_MULTITRANSPORT
{
    TS_UD_HEADER header where value.$"type" == TSUDHeaderType.CS_MULTITRANSPORT;
    TSUDCSMultiTransPortFlag $"flags";
    
    override string ToString()
    {
        return "TS_UD_CS_MULTITRANSPORT";
    }
}

pattern TSUDCSMultiTransPortFlag = flags uint
{
    TRANSPORTTYPE_UDPFECR = 0x01
        with Documentation
            {Description = "RDP-UDP Forward Error Correction (FEC) reliable transport."},
    TRANSPORTTYPE_UDPFECL = 0x04
        with Documentation
            {Description = "RDP-UDP FEC lossy transport."},
    TRANSPORTTYPE_UDP_PREFERRED = 0x100
        with Documentation
            {Description = "Tunneling of static virtual channel traffic over UDP is supported."},
    SOFTSYNC_TCP_TO_UDP = 0x200
        with Documentation
            {Description = "Switching dynamic virtual channels from the TCP to UDP transport is supported."},
    ...
};

// 2.2.1.3.9 Client Monitor Extended Data (TS_UD_CS_MONITOR_EX)
type TS_UD_CS_MONITOR_EX
{
    TS_UD_HEADER header where value.$"type" == TSUDHeaderType.CS_MONITOR_EX;
    uint $"flags" where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, 
        "RDPBCGR", "flags", "TS_UD_CS_MONITOR_EX", value);
    uint monitorAttributeSize where ValidationCheckValue(value == 20, null, true, ReferenceType.Type, 
        "RDPBCGR", "monitorAttributeSize", "TS_UD_CS_MONITOR_EX", 20, value);
    uint monitorCount;
    array<TS_MONITOR_ATTRIBUTES> monitorAttributesArray with BinaryEncoding{Length = monitorCount};

    override string ToString()
    {
        return "TS_UD_CS_MONITOR_EX";
    }
}

// 2.2.1.3.9.1    Monitor Attributes (TS_MONITOR_ATTRIBUTES)
type TS_MONITOR_ATTRIBUTES
{
    uint physicalWidth;
    uint physicalHeight;
    TSMonitorAttributesOrientation orientation;
    uint desktopScaleFactor;
    uint deviceScaleFactor;

    override string ToString()
    {
        return "TS_MONITOR_ATTRIBUTES";
    }
}

pattern TSMonitorAttributesOrientation = enum uint
{
    ORIENTATION_LANDSCAPE = 0,
    ORIENTATION_PORTRAIT = 90,
    ORIENTATION_LANDSCAPE_FLIPPED = 180,
    ORIENTATION_PORTRAIT_FLIPPED = 270,
    ...
};

// 2.2.1.4   Server MCS Connect Response PDU with GCC Conference Create Response
message ServerMCSConnectResponsePDUWithGccConferenceCreateResponse
{
    /*TS_UD_SC_CORE ServerCoreData
        with Documentation {Description = "Server Core Data structure."};
  
    TS_UD_SC_NET ServerNetworkData;
  
    TS_UD_SC_SEC1 ServerSecurityData;*/
    array<TSUDSCType> TSUD;
    
    override string ToString()
    {
        string summary = "Server MCS Connect Response PDU with GCC Conference Create Response";
        foreach (var tsud in TSUD)
        {
            if (tsud is sec1:TS_UD_SC_SEC1)
            {
                summary += ", encryptionMethod: " + EnumToStringInSummary<RDPBCGR.TSUDSCSec1EncryptionMethod>(sec1.encryptionMethod);
                summary += ", encryptionLevel: " + EnumToStringInSummary<RDPBCGR.TSUDSCSec1EncryptionLevel>(sec1.encryptionLevel);
            }
            else if (tsud is TS_UD_SC_NET)
            {
                summary += ", " + tsud.ToString();
            }
        }
        return summary;
    }
}

pattern TSUDSCType = [|RemainingBitLength(stream) >= 16|]
(
    [|stream.PeekUShort(stream.BitPosition, Endian.Little) == TSUDHeaderType.SC_CORE|] TS_UD_SC_CORE |
    [|stream.PeekUShort(stream.BitPosition, Endian.Little) == TSUDHeaderType.SC_NET|] TS_UD_SC_NET |
    [|stream.PeekUShort(stream.BitPosition, Endian.Little) == TSUDHeaderType.SC_SECURITY|] TS_UD_SC_SEC1 |
    [|stream.PeekUShort(stream.BitPosition, Endian.Little) == TSUDHeaderType.SC_MCS_MSGCHANNEL|] TS_UD_SC_MCS_MSGCHANNEL |
    [|stream.PeekUShort(stream.BitPosition, Endian.Little) == TSUDHeaderType.SC_MULTITRANSPORT|] TS_UD_SC_MULTITRANSPORT
);

// 2.2stream.PeekUShort(stream.BitPosition, Endian.Little).1.4.2   Server Core Data (TS_UD_SC_CORE)
type TS_UD_SC_CORE
{
    TS_UD_HEADER header where value.$"type" == TSUDHeaderType.SC_CORE;
    TSUDSCCoreVersion version;
    optional [|header.length > 8|] RequestedProtocols clientRequestedProtocols;
    optional [|header.length > 12|] TSUDSCCoreEarlyCapabilityFlags earlyCapabilityFlags;

    override string ToString()
    {
        return "TS_UD_SC_CORE, Version: " + EnumToStringInSummary<RDPBCGR.TSUDSCCoreVersion>(version);
    }
}

pattern TSUDSCCoreVersion = enum uint
{
    RDP_4_0  = 0x00080001,
    RDP_5_0To8_1 = 0x00080004,
    RDP_10_0 = 0x00080005,
    RDP_10_1 = 0x00080006,
    RDP_10_2 = 0x00080007,
    RDP_10_3 = 0x00080008,
    RDP_10_4 = 0x00080009,
    RDP_10_5 = 0x0008000A,
    RDP_10_6 = 0x0008000B,
    RDP_10_7 = 0x0008000C,
    ...
};

pattern TSUDSCCoreEarlyCapabilityFlags = flags uint
{
    RNS_UD_SC_EDGE_ACTIONS_SUPPORTED_V1 = 0x00000001
        with Documentation
            {Description = "The following key combinations are reserved by the server operating system:WIN + Z, WIN + CTRL + TAB, WIN + C, WIN +., WIN + SHIFT +.. In addition, the monitor boundaries of the remote session are employed by the server operating system to trigger user interface elements via touch or mouse gestures."},
    RNS_UD_SC_DYNAMIC_DST_SUPPORTED = 0x00000002
        with Documentation
            {Description = "The server supports Dynamic DST."},
    RNS_UD_SC_EDGE_ACTIONS_SUPPORTED_V2 = 0x00000004
        with Documentation
            {Description = "The following key combinations are reserved by the server operating system:WIN + Z, WIN + TAB, WIN + A. In addition, the monitor boundaries of the remote session are employed by the server operating system to trigger user interface elements via touch."},
    ...
};

// 2.2.1.4.3   Server Security Data (TS_UD_SC_SEC1)
type TS_UD_SC_SEC1
{
    TS_UD_HEADER header where value.$"type" == TSUDHeaderType.SC_SECURITY;
    TSUDSCSec1EncryptionMethod encryptionMethod;
    TSUDSCSec1EncryptionLevel encryptionLevel;
    optional [|(encryptionMethod != 0) || (encryptionLevel != 0)|] uint serverRandomLen 
        where ValidationCheckValue((value == nothing) || (value as uint == 0x20), null, true, ReferenceType.Type, 
            "RDPBCGR", "serverRandomLen", "TS_UD_SC_SEC1", "0x20", ((value is nothing) ? "": (value as uint)));
    optional [|(encryptionMethod != 0) || (encryptionLevel != 0)|] uint serverCertLen;
    optional [|serverRandomLen != nothing|] binary serverRandom with BinaryEncoding{Length = serverRandomLen as uint};
    optional [|serverCertLen != nothing|] SERVER_CERTIFICATE serverCertificate;
        
    override string ToString()
    {
        return "TS_UD_SC_SEC1, " + EnumToString<TSUDSCSec1EncryptionMethod>(encryptionMethod) + 
            ", " + EnumToString<TSUDSCSec1EncryptionLevel>(encryptionLevel);
    }
};

pattern TSUDSCSec1EncryptionMethod = enum uint
{
    ENCRYPTION_METHOD_NONE = 0x00000000,
    ENCRYPTION_METHOD_40BIT = 0x00000001,
    ENCRYPTION_METHOD_128BIT = 0x00000002,
    ENCRYPTION_METHOD_56BIT = 0x00000008,
    ENCRYPTION_METHOD_FIPS = 0x00000010,
    ...
};

pattern TSUDSCSec1EncryptionLevel = enum uint
{
    ENCRYPTION_LEVEL_NONE = 0x00000000,
    ENCRYPTION_LEVEL_LOW = 0x00000001,
    ENCRYPTION_LEVEL_CLIENT_COMPATIBLE = 0x00000002,
    ENCRYPTION_LEVEL_HIGH = 0x00000003,
    ENCRYPTION_LEVEL_FIPS = 0x00000004,
    ...
};

// 2.2.1.4.3.1   Server Certificate (SERVER_CERTIFICATE)
type SERVER_CERTIFICATE
{
    ServerCertificateDwVersion dwVersion;
  
    ([|dwVersion.certChainVersion == ServerCertificateDwVersionCertChainVersion.CERT_CHAIN_VERSION_1|] PROPRIETARYSERVERCERTIFICATE | 
        [|dwVersion.certChainVersion == ServerCertificateDwVersionCertChainVersion.CERT_CHAIN_VERSION_2|] X509CertificateChain) certData;
}

type ServerCertificateDwVersion
{
    uint t with BinaryEncoding{Width = 1};
    ServerCertificateDwVersionCertChainVersion certChainVersion with BinaryEncoding{Endian = Endian.Big, Width = 31};
} with BinaryEncoding{Endian = Endian.Little, WidthForComposedType = 32, DecodeAsUnit = true};

pattern ServerCertificateDwVersionCertChainVersion = enum uint
{
    CERT_CHAIN_VERSION_1 = 0x01,
    CERT_CHAIN_VERSION_2 = 0x02,
    ...
};

// 2.2.1.4.3.1.1   Server Proprietary Certificate (PROPRIETARYSERVERCERTIFICATE)
type PROPRIETARYSERVERCERTIFICATE
{
    uint dwSigAlgId where value == 0x00000001;
    uint dwKeyAlgId where value == 0x00000001;
    ushort wPublicKeyBlobType where value == 0x0006;
    ushort wPublicKeyBlobLen;
    RSA_PUBLIC_KEY PublicKeyBlob;
    ushort wSignatureBlobType where value == 0x0008;
    ushort wSignatureBlobLen;
    binary SignatureBlob with BinaryEncoding{Length = wSignatureBlobLen};
}

// 2.2.1.4.3.1.1.1   RSA Public Key (RSA_PUBLIC_KEY)
type RSA_PUBLIC_KEY
{
    uint magic where value == 0x31415352;
    uint keylen;
    uint bitlen;
    uint datalen;
    uint pubExp;
    binary modulus with BinaryEncoding{Length = keylen};
};

// 2.2.1.4.4   Server Network Data (TS_UD_SC_NET)
type TS_UD_SC_NET
{
    TS_UD_HEADER header where value.$"type" == TSUDHeaderType.SC_NET;
    ushort MCSChannelId;
    ushort channelCount;
    array<ushort> channelIdArray with BinaryEncoding{Length = channelCount};
    optional [|(channelIdArray.Count % 2) == 1|] ushort Pad;

    override string ToString()
    {
        int cnt = 0;
        string summary = "ChannelId: ";
        if (channelIdArray.Count > 1)
        {
            summary += "[";
        }
        foreach (var chanelid in channelIdArray)
        {
            if (cnt > 4)
            {
                summary += " ...";
                break;
            }
            else if (cnt > 0)
            {
                summary += ", ";
            }
            summary += chanelid.ToString();
            cnt++;
        }
        if (cnt > 1)
        {
            summary += "]";
        }
        return summary;
    }
};

// 2.2.1.4.5   Server Message Channel Data (TS_UD_SC_MCS_MSGCHANNEL)
type TS_UD_SC_MCS_MSGCHANNEL
{
    TS_UD_HEADER header where value.$"type" == TSUDHeaderType.SC_MCS_MSGCHANNEL;
    ushort MCSChannelID;

    override string ToString()
    {
        return "TS_UD_SC_MCS_MSGCHANNEL, MCSChannelID: " + MCSChannelID.ToString();
    }
};

// 2.2.1.4.6   Server Multitransport Channel Data (TS_UD_SC_MULTITRANSPORT)
type TS_UD_SC_MULTITRANSPORT
{
    TS_UD_HEADER header where value.$"type" == TSUDHeaderType.SC_MULTITRANSPORT;
    TSUDSCMultiTransportFlag $"flags";

    override string ToString()
    {
        return "TS_UD_SC_MULTITRANSPORT, " + EnumToString<TSUDSCMultiTransportFlag>($"flags");
    }
};

pattern TSUDSCMultiTransportFlag = flags uint
{
    TRANSPORTTYPE_UDPFECR = 0x01
        with Documentation
            {Description = "RDP-UDP Forward Error Correction (FEC) reliable transport."},
    TRANSPORTTYPE_UDPFECL = 0x04
        with Documentation
            {Description = "RDP-UDP FEC lossy transport."},
    TRANSPORTTYPE_UDP_PREFERRED = 0x100
        with Documentation
            {Description = "Tunneling of static virtual channel traffic over UDP is supported."},
    SOFTSYNC_TCP_TO_UDP = 0x200
        with Documentation
            {Description = "Switching dynamic virtual channels from the TCP to UDP transport is supported."},
    ...
};

// 2.2.1.5   Client MCS Erect Domain Request PDU
message ClientMCSErectDomainRequestPdu
{
    override string ToString()
    {
        return "Client MCS Erect Domain Request PDU";
    }
};

// 2.2.1.6   Client MCS Attach User Request PDU
message ClientMCSAttachUserRequestPdu
{
    override string ToString()
    {
        return "Client MCS Attach User Request PDU";
    }
};

// 2.2.1.7   Server MCS Attach User Confirm PDU
message ServerMCSAttachUserConfirmPdu
{
    override string ToString()
    {
        return "Server MCS Attach User Confirm PDU";
    }
};

// 2.2.1.8   Client MCS Channel Join Request PDU
message ClientMCSChannelJoinRequestPdu
{
    override string ToString()
    {
        return "Client MCS Channel Join Request PDU";
    }
};

// 2.2.1.9   Server MCS Channel Join Confirm PDU
message ServerMCSChannelJoinConfirmPdu
{
    override string ToString()
    {
        return "Server MCS Channel Join Confirm PDU";
    }
};

// 2.2.1.10   Client Security Exchange PDU
message ClientSecurityExchangePdu
{
    TS_SECURITY_PACKET securityExchangePduData;
    override string ToString()
    {
        return "Client Security Exchange PDU";
    }
};

// 2.2.1.10.1    Security Exchange PDU Data (TS_SECURITY_PACKET)
type TS_SECURITY_PACKET
{
    TS_SECURITY_HEADER basicSecurityHeader where (value.$"flags" & TSSecurityHeaderFlags.SEC_EXCHANGE_PKT) == 1;
    uint length;
    binary encryptedClientRandom with BinaryEncoding{Length = length};
}

// 2.2.1.11   Client Info PDU
message ClientInfoPdu[TSUDSCSec1EncryptionLevel EncryptionLevel, TSUDSCSec1EncryptionMethod EncryptionMethod]
{
    CLIENT_INFO_PDU[EncryptionLevel, EncryptionMethod] clientInfoPduData;

    override string ToString()
    {
        return "Client Info PDU, UserName: " + clientInfoPduData.infoPacket.UserName + 
            ", Domain: " + clientInfoPduData.infoPacket.Domain + ", clientAddress: " + 
            clientInfoPduData.infoPacket.extraInfo.clientAddress;
    }
}

// 2.2.1.11.1   Client Info PDU Data (CLIENT_INFO_PDU)
type CLIENT_INFO_PDU[TSUDSCSec1EncryptionLevel EncryptionLevel, TSUDSCSec1EncryptionMethod EncryptionMethod]
{
    optional (
              ([|EncryptionLevel == TSUDSCSec1EncryptionLevel.ENCRYPTION_LEVEL_NONE|] TS_SECURITY_HEADER) |
              ([|EncryptionMethod in {TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_40BIT,
                                      TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_128BIT,
                                      TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_56BIT}|] TS_SECURITY_HEADER1) |
              ([|(EncryptionMethod == TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_FIPS)|] TS_SECURITY_HEADER2)
             ) securityHeader;
    TS_INFO_PACKET infoPacket;
}

// 2.2.1.11.1.1   Info Packet (TS_INFO_PACKET)
type TS_INFO_PACKET
{
    uint CodePage;
    TSInfoPacketFlags $"flags";
    ushort cbDomain;
    ushort cbUserName;
    ushort cbPassword;
    ushort cbAlternateShell;
    ushort cbWorkingDir;
    string Domain with BinaryEncoding{TextEncoding = GetTextEncodingAttr(), 
            Length = (GetTextEncodingAttr() == TextEncoding.Unicode ? (cbDomain / 2) : cbDomain) + 1};
    string UserName with BinaryEncoding{TextEncoding = GetTextEncodingAttr(),
            Length = (GetTextEncodingAttr() == TextEncoding.Unicode ? (cbUserName / 2) : cbUserName) + 1};
    string Password with BinaryEncoding{TextEncoding = GetTextEncodingAttr(),
            Length = (GetTextEncodingAttr() == TextEncoding.Unicode ? (cbPassword / 2) : cbPassword) + 1};
    string AlternateShell with BinaryEncoding{TextEncoding = GetTextEncodingAttr(),
            Length = (GetTextEncodingAttr() == TextEncoding.Unicode ? (cbAlternateShell / 2) : cbAlternateShell) + 1};
    string WorkingDir with BinaryEncoding{TextEncoding = GetTextEncodingAttr(),
            Length = (GetTextEncodingAttr() == TextEncoding.Unicode ? (cbWorkingDir / 2) : cbWorkingDir) + 1};
    TS_EXTENDED_INFO_PACKET[GetTextEncodingAttr()] extraInfo;

    TextEncoding GetTextEncodingAttr()
    {
        return ($"flags".TSInfoPacketFlagsLow & TSInfoPacketFlagsLowPatt.INFO_UNICODE) > 0 ? 
            TextEncoding.Unicode : TextEncoding.ASCII;
    }
}

type TSInfoPacketFlags
{
    TSInfoPacketFlagsHighPatt TSInfoPacketFlagsHigh with BinaryEncoding{Endian = Endian.Big, Width = 19};
    TSInfoPacketFlagsCompressionTypeMask CompressionTypeMask with BinaryEncoding{Endian = Endian.Big, Width = 4};
    TSInfoPacketFlagsLowPatt TSInfoPacketFlagsLow with BinaryEncoding{Endian = Endian.Big, Width = 9};
}with BinaryEncoding{Endian = Endian.Little, WidthForComposedType = 32, DecodeAsUnit = true};

pattern TSInfoPacketFlagsLowPatt = flags uint
{
    INFO_MOUSE = 0x00000001
        with Documentation
            {Description = "The client machine has a mouse attached."},
    INFO_DISABLECTRLALTDEL = 0x00000002
        with Documentation
            {Description = "The CTRL+ALT+DEL (or the equivalent) secure access keyboard sequence is not required at the logon prompt."},
    INFO_AUTOLOGON = 0x00000008
        with Documentation
            {Description = "The client requests auto logon using the included user name, password and domain."},
    INFO_UNICODE = 0x00000010
        with Documentation
            {Description = "The character set for strings in the Info Packet and Extended Info Packet is Unicode."},
    INFO_MAXIMIZESHELL = 0x00000020
        with Documentation
            {Description = "The alternate shell (specified in the AlternateShell field of the Info Packet structure) MUST be started in a maximized state."},
    INFO_LOGONNOTIFY = 0x00000040
        with Documentation
            {Description = "The client wants to be informed of the user name and domain used to log on to the server, as well as the ID of the session to which the user connected."},
    INFO_COMPRESSION = 0x00000080
        with Documentation
            {Description = "The CompressionTypeMask is valid and contains the highest compression package type supported by the client."},
    INFO_ENABLEWINDOWSKEY = 0x00000100
        with Documentation
            {Description = "The client uses the Windows key on Windows-compatible keyboards."},
    ...
};

pattern TSInfoPacketFlagsHighPatt = flags uint
{
    INFO_REMOTECONSOLEAUDIO = 0x00001 // 0x00002000 in the whole TSInfoPacketFlags
        with Documentation
            {Description = "Requests that audio played in a session hosted on a remote server be played on the server."},
    INFO_FORCE_ENCRYPTED_CS_PDU = 0x00002 // 0x00004000 in the whole TSInfoPacketFlags
        with Documentation
            {Description = "All client-to-server traffic is encrypted when encryption is in force."},
    INFO_RAIL = 0x00004 // 0x00008000 in the whole TSInfoPacketFlags
        with Documentation
            {Description = "The remote connection being established is for the purpose of launching remote programs using the protocol defined in RDPERP."},
    INFO_LOGONERRORS = 0x0008 // 0x00010000 in the whole TSInfoPacketFlags
        with Documentation
            {Description = "Indicates a request for logon error notifications using the Save Session Info PDU."},
    INFO_MOUSE_HAS_WHEEL = 0x00010 // 0x00020000 in the whole TSInfoPacketFlags
        with Documentation
            {Description = "The mouse which is connected to the client machine has a scroll wheel."},
    INFO_PASSWORD_IS_SC_PIN = 0x00020 // 0x00040000 in the whole TSInfoPacketFlags
        with Documentation
            {Description = "The Password field in the Info Packet contains a smart card personal identification number (PIN)."},
    INFO_NOAUDIOPLAYBACK = 0x00040 // 0x00080000 in the whole TSInfoPacketFlags
        with Documentation
            {Description = "Audio redirection MUST NOT take place."},
    INFO_USING_SAVED_CREDS = 0x00800 // 0x00100000 in the whole TSInfoPacketFlags
        with Documentation
            {Description = "Any user credentials sent on the wire during the RDP Connection Sequence have been retrieved from a credential store and were not obtained directly from the user."},
    INFO_AUDIOCAPTURE = 0x00100 // 0x00200000 in the whole TSInfoPacketFlags
        with Documentation
            {Description = "The redirection of client-side audio input to a session hosted on a remote server is supported using the protocol defined in RDPEAI."},
    INFO_VIDEO_DISABLE = 0x00200 // 0x00400000 in the whole TSInfoPacketFlags
        with Documentation
            {Description = "Video redirection or playback MUST NOT take place."},
    INFO_RESERVED1 = 0x00400 // 0x00800000 in the whole TSInfoPacketFlags
        with Documentation
            {Description = "Reserved for future use."},
    INFO_RESERVED2 = 0x00800 // 0x01000000 in the whole TSInfoPacketFlags
        with Documentation
            {Description = "Reserved for future use."},
    INFO_HIDEF_RAIL_SUPPORTED = 0x01000 // 0x02000000 in the whole TSInfoPacketFlags
        with Documentation
            {Description = "The client supports Enhanced RemoteApp."},
    ...
};

pattern TSInfoPacketFlagsCompressionTypeMask = enum byte
{
    PACKET_COMPR_TYPE_8K = 0x0,
    PACKET_COMPR_TYPE_64K = 0x1,
    PACKET_COMPR_TYPE_RDP6 = 0x2,
    PACKET_COMPR_TYPE_RDP61 = 0x3,
    ...
};

// 2.2.1.11.1.1.1   Extended Info Packet (TS_EXTENDED_INFO_PACKET)
type TS_EXTENDED_INFO_PACKET[TextEncoding TextEncodingAttr]
{
    TSExtendedInfoPacketClientAddressFamily clientAddressFamily;
    ushort cbClientAddress;
    string clientAddress with BinaryEncoding{TextEncoding = TextEncodingAttr,
            Length = (TextEncodingAttr == TextEncoding.UTF16 ? (cbClientAddress / 2) : cbClientAddress)};
    ushort cbClientDir;
    string clientDir with BinaryEncoding{TextEncoding = TextEncodingAttr,
            Length = (TextEncodingAttr == TextEncoding.UTF16 ? (cbClientDir / 2) : cbClientDir)};
    optional [|RemainingByteLength(stream) >= 172|] TS_TIME_ZONE_INFORMATION clientTimeZone; // THe size of TS_TIME_ZONE_INFORMATION is 172
    optional [|RemainingByteLength(stream) >= 4|] uint clientSessionId;
    optional [|RemainingByteLength(stream) >= 4|] TSExtendedInfoPacketPerformanceFlags performanceFlags;
    optional [|RemainingByteLength(stream) >= 2|] ushort cbAutoReconnectCookie;
    optional ([|cbAutoReconnectCookie > 0|] ARC_CS_PRIVATE_PACKET) autoReconnectCookie;
    optional [|RemainingByteLength(stream) >= 2|] ushort reserved1;
    optional [|RemainingByteLength(stream) >= 2|] ushort reserved2;
    optional [|RemainingByteLength(stream) >= 2|] ushort cbDynamicDSTTimeZoneKeyName;
    optional [|cbDynamicDSTTimeZoneKeyName > 0|] string dynamicDSTTimeZoneKeyName 
        with BinaryEncoding{TextEncoding = TextEncoding.UTF16, Length = (cbDynamicDSTTimeZoneKeyName as ushort) / 2};
    optional [|(dynamicDSTTimeZoneKeyName != nothing)|] TSExtInfoDdynamicDaylightTimeDisabled dynamicDaylightTimeDisabled;
}

pattern TSExtendedInfoPacketClientAddressFamily = enum ushort
{
    AF_INET = 0x0002,
    AF_INET6 = 0x0017,
    ...
};

pattern TSExtInfoDdynamicDaylightTimeDisabled = enum ushort
{
    FALSE = 0x0000,
    TRUE = 0x0001,
    ...
};

// 2.2.1.11.1.1.1.1   Time Zone Information (TS_TIME_ZONE_INFORMATION)
type TS_TIME_ZONE_INFORMATION
{
    uint Bias;
    string StandardName with BinaryEncoding{TextEncoding = TextEncoding.Unicode, Length = 32};
    TS_SYSTEMTIME StandardDate;
    uint StandardBias;
    string DaylightName with BinaryEncoding{TextEncoding = TextEncoding.Unicode, Length = 32};
    TS_SYSTEMTIME DaylightDate;
    uint DaylightBias;
}

// 2.2.1.11.1.1.1.1.1   System Time (TS_SYSTEMTIME)
type TS_SYSTEMTIME
{
    ushort wYear where ValidationCheckZero(value == 0, null, true, 
        ReferenceType.Type, "RDPBCGR", "wYear", "TS_SYSTEMTIME", value);
    TSSystemTimeWMonth wMonth;
    TSSystemTimeWDayOfWeek wDayOfWeek;
    TSSystemTimeWDay wDay;
    ushort wHour;
    ushort wMinute;
    ushort wSecond;
    ushort wMilliseconds;
}

pattern TSSystemTimeWMonth = enum ushort
{
    January = 1,
    February = 2,
    March = 3,
    April = 4,
    May = 5,
    June = 6,
    July = 7,
    August = 8,
    September = 9,
    October = 10,
    November = 11,
    December = 12,
    ...
};

pattern TSSystemTimeWDayOfWeek = enum ushort
{
    Sunday = 0,
    Monday = 1,
    Tuesday = 2,
    Wednesday = 3,
    Thursday = 4,
    Friday = 5,
    Saturday = 6,
    ...
};

pattern TSSystemTimeWDay = enum ushort
{
    FirstOccurrence  = 1,
    SecondOccurrence = 2,
    ThirdOccurrence = 3,
    FourthOccurrence = 4,
    LastOccurrence = 5,
    ...
};

pattern TSExtendedInfoPacketPerformanceFlags = flags uint
{
    PERF_DISABLE_WALLPAPER = 0x00000001
        with Documentation
            {Description = "Disable desktop wallpaper."},
    PERF_DISABLE_FULLWINDOWDRAG = 0x00000002
        with Documentation
            {Description = "Disable full-window drag (only the window outline is displayed when the window is moved)."},
    PERF_DISABLE_MENUANIMATIONS = 0x00000004
        with Documentation
            {Description = "Disable menu animations."},
    PERF_DISABLE_THEMING = 0x00000008
        with Documentation
            {Description = "Disable user interface themes."},
    PERF_RESERVED1 = 0x00000010
        with Documentation
            {Description = "Reserved for future use."},
    PERF_DISABLE_CURSOR_SHADOW = 0x00000020
        with Documentation
            {Description = "Disable mouse cursor shadows."},
    PERF_DISABLE_CURSORSETTINGS = 0x00000040
        with Documentation
            {Description = "Disable cursor blinking."},
    PERF_ENABLE_FONT_SMOOTHING = 0x00000080
        with Documentation
            {Description = "Enable font smoothing."},
    PERF_ENABLE_DESKTOP_COMPOSITION = 0x00000100
        with Documentation
            {Description = "Enable Desktop Composition."},
    PERF_RESERVED2 = 0x80000000
        with Documentation
            {Description = "Reserved for future use."},
    ...
};

// 2.2.1.12    Server License Error PDU - Valid Client
message ServerLicenseErrorPdu[TSUDSCSec1EncryptionLevel EncryptionLevel, TSUDSCSec1EncryptionMethod EncryptionMethod]
{
    optional (
              ([|EncryptionLevel in {TSUDSCSec1EncryptionLevel.ENCRYPTION_LEVEL_LOW,
                                     TSUDSCSec1EncryptionLevel.ENCRYPTION_LEVEL_NONE}|] TS_SECURITY_HEADER) |
              ([|EncryptionMethod in {TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_40BIT,
                                      TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_128BIT,
                                      TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_56BIT}|] TS_SECURITY_HEADER1) |
              ([|(EncryptionMethod == TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_FIPS)|] TS_SECURITY_HEADER2)
             ) securityHeader;
    LICENSE_VALID_CLIENT_DATA validClientLicenseData;
    override string ToString()
    {
        return "Server License Error PDU - Valid Client";
    }
}

type LICENSE_VALID_CLIENT_DATA
{
    LICENSE_PREAMBLE preamble where value.bMsgType == LicensePreambleBMsgType.ERROR_ALERT;
    LICENSE_ERROR_MESSAGE validClientMessage;
}

// 2.2.1.12.1.1   Licensing Preamble (LICENSE_PREAMBLE)
type LICENSE_PREAMBLE
{
    ushort wMsgSize with BinaryEncoding{Endian = Endian.Big};
    LicensePreambleFlags $"flags" with BinaryEncoding{Endian = Endian.Big};
    LicensePreambleBMsgType bMsgType with BinaryEncoding{Endian = Endian.Big};
}with BinaryEncoding{Endian = Endian.Little, WidthForComposedType = 32, DecodeAsUnit = true};

pattern LicensePreambleBMsgType = enum byte
{
    // Send by server
    LICENSE_REQUEST = 0x01,
    PLATFORM_CHALLENGE = 0x02,
    NEW_LICENSE = 0x03,
    UPGRADE_LICENSE = 0x04,
             
    // Send by client
    LICENSE_INFO = 0x12,
    NEW_LICENSE_REQUEST = 0x13,
    PLATFORM_CHALLENGE_RESPONSE = 0x15,
             
    // Sent by either client or server
    ERROR_ALERT = 0xFF,
    ...
};

pattern LicenseProtocolVersionMaskValue = enum byte
{
    PREAMBLE_VERSION_2_0 = 0x02,
    PREAMBLE_VERSION_3_0 = 0x03,
    ...
};

type LicensePreambleFlags
{    
    bool  EXTENDED_ERROR_MSG_SUPPORTED with BinaryEncoding{Width = 1};
    byte Reserved with BinaryEncoding{Endian = Endian.Big, Width = 3};
    LicenseProtocolVersionMaskValue LicenseProtocolVersionMask with BinaryEncoding{Endian = Endian.Big, Width = 4};
}with BinaryEncoding{Endian = Endian.Little, WidthForComposedType = 8, DecodeAsUnit = true};

// 2.2.1.12.1.2   Licensing Binary Blob (LICENSE_BINARY_BLOB)
type LICENSE_BINARY_BLOB
{
    LicenseBinaryBlobWBlobType wBlobType;
    ushort wBlobLen;
    // extend RDPBCGR accroding to [MS-RDPELE] section 2.2.2.1, 2.2.2.1.2.1
    optional [|wBlobLen > 0|] 
        ( 
            // [MS-RDPELE] 2.2.2.1 SERVER_LICENSE_REQUEST.KeyExchangeList
            ([|wBlobType == LicenseBinaryBlobWBlobType.BB_KEY_EXCHG_ALG_BLOB|] array<KeyExchangeAlg>) | 
            // [MS-RDPELE] 2.2.2.1 SERVER_LICENSE_REQUEST.SERVER_CERTIFICATE
            ([|wBlobType == LicenseBinaryBlobWBlobType.BB_CERTIFICATE_BLOB|] SERVER_CERTIFICATE) |
            // [MS-RDPELE] 2.2.2.1.2.1 SCOPE.Scope
            // [MS-RDPELE] 2.2.2.2 CLIENT_NEW_LICENSE_REQUEST.ClientUserName and CLIENT_NEW_LICENSE_REQUEST.ClientMachineName 
            ([|wBlobType in {LicenseBinaryBlobWBlobType.BB_SCOPE_BLOB,
                                              LicenseBinaryBlobWBlobType.BB_CLIENT_USER_NAME_BLOB,
                                              LicenseBinaryBlobWBlobType.BB_CLIENT_MACHINE_NAME_BLOB
                                            }|] string) |
            binary
        ) blobData 
            with BinaryEncoding{WidthForComposedType = wBlobLen * 8, TextEncoding = TextEncoding.ASCII};
            
    override string ToString()
    {
        return "LICENSE_BINARY_BLOB, wBlobType: " + EnumToStringInSummary<LicenseBinaryBlobWBlobType>(wBlobType);
    }
}

pattern LicenseBinaryBlobWBlobType = enum ushort
{
    BB_DATA_BLOB = 0x0001,
    BB_RANDOM_BLOB = 0x0002,
    BB_CERTIFICATE_BLOB = 0x0003,
    BB_ERROR_BLOB = 0x0004,
    BB_ENCRYPTED_DATA_BLOB = 0x0009,
    BB_KEY_EXCHG_ALG_BLOB = 0x000D,
    BB_SCOPE_BLOB = 0x000E,
    BB_CLIENT_USER_NAME_BLOB = 0x000F,
    BB_CLIENT_MACHINE_NAME_BLOB = 0x0010,
    ...
};

// 2.2.1.12.1.3   Licensing Error Message (LICENSE_ERROR_MESSAGE)
type LICENSE_ERROR_MESSAGE
{
    LicenseErrorMessageDwErrorCode dwErrorCode;
    LicenseErrorMessageDwStateTransition dwStateTransition;
    LICENSE_BINARY_BLOB bbErrorInfo;
}

pattern LicenseErrorMessageDwErrorCode = enum uint
{
    // Sent by client:
    ERR_INVALID_SERVER_CERTIFICATE = 0x00000001, 
    ERR_NO_LICENSE = 0x00000002,
    
    // Sent by server:
    ERR_INVALID_SCOPE = 0x00000004,
    ERR_NO_LICENSE_SERVER = 0x00000006,
    STATUS_VALID_CLIENT = 0x00000007,
    ERR_INVALID_CLIENT = 0x00000008,
    ERR_INVALID_PRODUCTID = 0x0000000B,
    ERR_INVALID_MESSAGE_LEN = 0x0000000C,
    
    // Sent by client and server:
    ERR_INVALID_MAC = 0x00000003,
    ...
};

pattern LicenseErrorMessageDwStateTransition = enum uint
{
    ST_TOTAL_ABORT = 0x00000001,
    ST_NO_TRANSITION = 0x00000002,
    ST_RESET_PHASE_TO_START = 0x00000003,
    ST_RESEND_LAST_MESSAGE = 0x00000004,
    ...
};

// 2.2.1.13.1   Server Demand Active PDU
message ServerDemandActivePdu[TSUDSCSec1EncryptionLevel EncryptionLevel, TSUDSCSec1EncryptionMethod EncryptionMethod]
{
    optional (
              ([|EncryptionLevel == TSUDSCSec1EncryptionLevel.ENCRYPTION_LEVEL_LOW|] TS_SECURITY_HEADER) |
              ([|EncryptionMethod in {TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_40BIT,
                                      TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_128BIT,
                                      TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_56BIT}|] TS_SECURITY_HEADER1) |
              ([|(EncryptionMethod == TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_FIPS)|] TS_SECURITY_HEADER2)
             ) securityHeader;
        
    TS_DEMAND_ACTIVE_PDU demandActivePduData;
           
    override string ToString()
    {
        return "Server Demand Active PDU";
    }
}

// 2.2.1.13.1.1   Demand Active PDU Data (TS_DEMAND_ACTIVE_PDU)
type TS_DEMAND_ACTIVE_PDU
{
    TS_SHARECONTROLHEADER shareControlHeader where value.pduType.$"type" == TSShareControlHeaderPduTypeType.PDUTYPE_DEMANDACTIVEPDU;
    uint shareId;
    ushort lengthSourceDescriptor;
    ushort lengthCombinedCapabilities;
    array<byte> sourceDescriptor with BinaryEncoding{Length = lengthSourceDescriptor};
    ushort numberCapabilities;
    ushort pad2Octets;
    array<TSCapsSetPattern> capabilitySets with BinaryEncoding{Length = numberCapabilities};
    uint sessionId;
}

// 2.2.1.13.1.1.1   Capability Set (TS_CAPS_SET)
// Adding "| TS_CAPS_SET" for each subtype to make the decoding always succeed.
pattern TSCapsSetPattern = [|RemainingByteLength(stream) >= 2|] 
                        ([|stream.PeekUShort(stream.BitPosition, Endian.Little) == TSCapsSetCapabilitySetType.CAPSTYPE_GENERAL|] (TS_GENERAL_CAPABILITYSET | TS_CAPS_SET)                                  |
                         [|stream.PeekUShort(stream.BitPosition, Endian.Little) == TSCapsSetCapabilitySetType.CAPSTYPE_BITMAP|] (TS_BITMAP_CAPABILITYSET | TS_CAPS_SET)                                    |
                         [|stream.PeekUShort(stream.BitPosition, Endian.Little) == TSCapsSetCapabilitySetType.CAPSTYPE_ORDER|] (TS_ORDER_CAPABILITYSET | TS_CAPS_SET)                                      |
                         [|stream.PeekUShort(stream.BitPosition, Endian.Little) == TSCapsSetCapabilitySetType.CAPSTYPE_BITMAPCACHE|] (TS_BITMAPCACHE_CAPABILITYSET | TS_CAPS_SET)                         |
                         [|stream.PeekUShort(stream.BitPosition, Endian.Little) == TSCapsSetCapabilitySetType.CAPSTYPE_CONTROL|] (TS_CONTROL_CAPABILITYSET | TS_CAPS_SET)                                  |
                         [|stream.PeekUShort(stream.BitPosition, Endian.Little) == TSCapsSetCapabilitySetType.CAPSTYPE_ACTIVATION|] (TS_WINDOWACTIVATION_CAPABILITYSET | TS_CAPS_SET)                      |
                         [|stream.PeekUShort(stream.BitPosition, Endian.Little) == TSCapsSetCapabilitySetType.CAPSTYPE_POINTER|] (TS_POINTER_CAPABILITYSET | TS_CAPS_SET)                                  |
                         [|stream.PeekUShort(stream.BitPosition, Endian.Little) == TSCapsSetCapabilitySetType.CAPSTYPE_SHARE|] (TS_SHARE_CAPABILITYSET | TS_CAPS_SET)                                      |
                         [|stream.PeekUShort(stream.BitPosition, Endian.Little) == TSCapsSetCapabilitySetType.CAPSTYPE_COLORCACHE|] (TS_COLORTABLE_CAPABILITYSET | TS_CAPS_SET)                            |
                         [|stream.PeekUShort(stream.BitPosition, Endian.Little) == TSCapsSetCapabilitySetType.CAPSTYPE_SOUND|] (TS_SOUND_CAPABILITYSET | TS_CAPS_SET)                                      |
                         [|stream.PeekUShort(stream.BitPosition, Endian.Little) == TSCapsSetCapabilitySetType.CAPSTYPE_INPUT|] (TS_INPUT_CAPABILITYSET | TS_CAPS_SET)                                      |
                         [|stream.PeekUShort(stream.BitPosition, Endian.Little) == TSCapsSetCapabilitySetType.CAPSTYPE_FONT|] (TS_FONT_CAPABILITYSET | TS_CAPS_SET)                                        |
                         [|stream.PeekUShort(stream.BitPosition, Endian.Little) == TSCapsSetCapabilitySetType.CAPSTYPE_BRUSH|] (TS_BRUSH_CAPABILITYSET | TS_CAPS_SET)                                      |
                         [|stream.PeekUShort(stream.BitPosition, Endian.Little) == TSCapsSetCapabilitySetType.CAPSTYPE_GLYPHCACHE|] (TS_GLYPHCACHE_CAPABILITYSET | TS_CAPS_SET)                            |
                         [|stream.PeekUShort(stream.BitPosition, Endian.Little) == TSCapsSetCapabilitySetType.CAPSTYPE_OFFSCREENCACHE|] (TS_OFFSCREEN_CAPABILITYSET | TS_CAPS_SET)                         |
                         [|stream.PeekUShort(stream.BitPosition, Endian.Little) == TSCapsSetCapabilitySetType.CAPSTYPE_BITMAPCACHE_HOSTSUPPORT|] (TS_BITMAPCACHE_HOSTSUPPORT_CAPABILITYSET | TS_CAPS_SET)    |
                         [|stream.PeekUShort(stream.BitPosition, Endian.Little) == TSCapsSetCapabilitySetType.CAPSTYPE_BITMAPCACHE_REV2|] (TS_BITMAPCACHE_CAPABILITYSET_REV2 | TS_CAPS_SET)                 |
                         [|stream.PeekUShort(stream.BitPosition, Endian.Little) == TSCapsSetCapabilitySetType.CAPSTYPE_VIRTUALCHANNEL|] (TS_VIRTUALCHANNEL_CAPABILITYSET | TS_CAPS_SET)                    |
                         [|stream.PeekUShort(stream.BitPosition, Endian.Little) == TSCapsSetCapabilitySetType.CAPSTYPE_DRAWNINEGRIDCACHE|] (TS_DRAW_NINEGRID_CAPABILITYSET | TS_CAPS_SET)                   |
                         [|stream.PeekUShort(stream.BitPosition, Endian.Little) == TSCapsSetCapabilitySetType.CAPSTYPE_DRAWGDIPLUS|] (TS_DRAW_GDIPLUS_CAPABILITYSET | TS_CAPS_SET)                          |
                         [|stream.PeekUShort(stream.BitPosition, Endian.Little) == TSCapsSetCapabilitySetType.CAPSTYPE_RAIL|] (TSRemoteProgramsCapabilitySet | TS_CAPS_SET)                              |
                         [|stream.PeekUShort(stream.BitPosition, Endian.Little) == TSCapsSetCapabilitySetType.CAPSTYPE_WINDOW|] (TSWindowListCapabilitySet | TS_CAPS_SET)                                |
                         [|stream.PeekUShort(stream.BitPosition, Endian.Little) == TSCapsSetCapabilitySetType.CAPSETTYPE_COMPDESK|] (TS_COMPDESK_CAPABILITYSET | TS_CAPS_SET)                              |
                         [|stream.PeekUShort(stream.BitPosition, Endian.Little) == TSCapsSetCapabilitySetType.CAPSETTYPE_MULTIFRAGMENTUPDATE|] (TS_MULTIFRAGMENTUPDATE_CAPABILITYSET | TS_CAPS_SET)        |
                         [|stream.PeekUShort(stream.BitPosition, Endian.Little) == TSCapsSetCapabilitySetType.CAPSETTYPE_LARGE_POINTER|] (TS_LARGE_POINTER_CAPABILITYSET | TS_CAPS_SET)                      |
                         [|stream.PeekUShort(stream.BitPosition, Endian.Little) == TSCapsSetCapabilitySetType.CAPSETTYPE_SURFACE_COMMANDS|] (TS_SURFCMDS_CAPABILITYSET | TS_CAPS_SET)                       |
                         [|stream.PeekUShort(stream.BitPosition, Endian.Little) == TSCapsSetCapabilitySetType.CAPSETTYPE_BITMAP_CODECS|] (TS_BITMAPCODECS_CAPABILITYSET | TS_CAPS_SET)                      |
                         UnKnownTSCapsSet);
pattern UnKnownTSCapsSet = TS_CAPS_SET | any;

type TS_CAPS_SET
{
    TSCapsSetCapabilitySetType capabilitySetType;
    ushort lengthCapability;
    binary capabilityData with BinaryEncoding{Length = lengthCapability - 4};

    override string ToString()
    {
        return "TS_CAPS_SET, capabilitySetType: " + 
            EnumToString<TSCapsSetCapabilitySetType>(capabilitySetType) + 
            ", lengthCapability: " + lengthCapability.ToString();
    }
}

pattern TSCapsSetCapabilitySetType = enum ushort
{
    CAPSTYPE_GENERAL = 0x0001,
    CAPSTYPE_BITMAP = 0x0002,
    CAPSTYPE_ORDER = 0x0003,
    CAPSTYPE_BITMAPCACHE = 0x0004,
    CAPSTYPE_CONTROL = 0x0005,
    CAPSTYPE_ACTIVATION = 0x0007,
    CAPSTYPE_POINTER = 0x0008,
    CAPSTYPE_SHARE = 0x0009,
    CAPSTYPE_COLORCACHE = 0x000A,
    CAPSTYPE_SOUND = 0x000C,
    CAPSTYPE_INPUT = 0x000D,
    CAPSTYPE_FONT = 0x000E,
    CAPSTYPE_BRUSH = 0x000F,
    CAPSTYPE_GLYPHCACHE = 0x0010,
    CAPSTYPE_OFFSCREENCACHE = 0x0011,
    CAPSTYPE_BITMAPCACHE_HOSTSUPPORT = 0x0012,
    CAPSTYPE_BITMAPCACHE_REV2 = 0x0013,
    CAPSTYPE_VIRTUALCHANNEL = 0x0014,
    CAPSTYPE_DRAWNINEGRIDCACHE = 0x0015,
    CAPSTYPE_DRAWGDIPLUS = 0x0016,
    CAPSTYPE_RAIL = 0x0017,
    CAPSTYPE_WINDOW = 0x0018,
    CAPSETTYPE_COMPDESK = 0x0019,
    CAPSETTYPE_MULTIFRAGMENTUPDATE = 0x001A,
    CAPSETTYPE_LARGE_POINTER = 0x001B,
    CAPSETTYPE_SURFACE_COMMANDS = 0x001C,
    CAPSETTYPE_BITMAP_CODECS = 0x001D,
    CAPSSETTYPE_FRAME_ACKNOWLEDGE = 0x001E,
    ...
};

// 2.2.1.13.2   Client Confirm Active PDU
message ClientConfirmActivePdu [TSUDSCSec1EncryptionLevel EncryptionLevel, TSUDSCSec1EncryptionMethod EncryptionMethod]
{
    optional (
              ([|EncryptionMethod in {TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_40BIT,
                                      TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_128BIT,
                                      TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_56BIT}|] TS_SECURITY_HEADER1) |
              ([|(EncryptionMethod == TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_FIPS)|] TS_SECURITY_HEADER2)
             ) securityHeader;

    TS_CONFIRM_ACTIVE_PDU confirmActivePduData;
           
    override string ToString()
    {
        return "Client Confirm Active PDU";
    }
}

// 2.2.1.13.2.1   Confirm Active PDU Data (TS_CONFIRM_ACTIVE_PDU)
type TS_CONFIRM_ACTIVE_PDU
{
    TS_SHARECONTROLHEADER shareControlHeader where value.pduType.$"type" == TSShareControlHeaderPduTypeType.PDUTYPE_CONFIRMACTIVEPDU;
    uint shareId;
    ushort originatorId where ValidationCheckValue(value == 0x03EA, null, true, 
        ReferenceType.Type, "RDPBCGR", "originatorId", "TS_CONFIRM_ACTIVE_PDU", "0x03EA", value); // TDI
    ushort lengthSourceDescriptor;
    ushort lengthCombinedCapabilities;
    array<byte> SourceDescriptor with BinaryEncoding{Length = lengthSourceDescriptor};
    ushort numberCapabilities;
    ushort pad2Octets;
    array<TSCapsSetPattern> capabilitySets with BinaryEncoding{Length = numberCapabilities};
}

// 2.2.1.14   Client Synchronize PDU
message ClientSynchronizePdu[TSUDSCSec1EncryptionLevel EncryptionLevel, TSUDSCSec1EncryptionMethod EncryptionMethod]
{
    optional (
              ([|EncryptionMethod in {TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_40BIT,
                                      TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_128BIT,
                                      TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_56BIT}|] TS_SECURITY_HEADER1) |
              ([|(EncryptionMethod == TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_FIPS)|] TS_SECURITY_HEADER2)
             ) securityHeader;

    TS_SYNCHRONIZE_PDU synchronizePduData;
           
    override string ToString()
    {
        return "Client Synchronize PDU";
    }
};

// 2.2.1.14.1   Synchronize PDU Data (TS_SYNCHRONIZE_PDU)
type TS_SYNCHRONIZE_PDU
{
    TS_SHAREDATAHEADER shareDataHeader where value.shareControlHeader.pduType.$"type" == TSShareControlHeaderPduTypeType.PDUTYPE_DATAPDU;
    ushort messageType where value == 1;
    ushort targetUser;
}

// 2.2.1.15   Client Control PDU - Cooperate
message ClientControlPduCoOperate[TSUDSCSec1EncryptionLevel EncryptionLevel, TSUDSCSec1EncryptionMethod EncryptionMethod]
{
    optional (
              ([|EncryptionMethod in {TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_40BIT,
                                      TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_128BIT,
                                      TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_56BIT}|] TS_SECURITY_HEADER1) |
              ([|(EncryptionMethod == TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_FIPS)|] TS_SECURITY_HEADER2)
             ) securityHeader;
    TS_CONTROL_PDU controlPduData where value.action == TSControlPduAction.CTRLACTION_COOPERATE;
    
    override string ToString()
    {
        return "Client Control PDU - Cooperate";
    }
}

// 2.2.1.15.1   Control PDU Data (TS_CONTROL_PDU)
type TS_CONTROL_PDU
{
    TS_SHAREDATAHEADER shareDataHeader;
    TSControlPduAction action;
    ushort grantId;
    uint controlId;
}

pattern TSControlPduAction = enum ushort
{
    CTRLACTION_REQUEST_CONTROL = 0x0001,
    CTRLACTION_GRANTED_CONTROL = 0x0002,
    CTRLACTION_DETACH = 0x0003,
    CTRLACTION_COOPERATE = 0x0004,
    ...
};

// 2.2.1.16   Client Control PDU - Request Control
message ClientControlPduRequestControl[TSUDSCSec1EncryptionLevel EncryptionLevel, TSUDSCSec1EncryptionMethod EncryptionMethod]
{
    optional (
              ([|EncryptionMethod in {TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_40BIT,
                                      TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_128BIT,
                                      TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_56BIT}|] TS_SECURITY_HEADER1) |
              ([|(EncryptionMethod == TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_FIPS)|] TS_SECURITY_HEADER2)
             ) securityHeader;
        
    TS_CONTROL_PDU controlPduData where value.action == TSControlPduAction.CTRLACTION_REQUEST_CONTROL;
    
    override string ToString()
    {
        return "Client Control PDU - Request";
    }
}

// 2.2.1.17   Client Persistent Key List PDU
message ClientPersistentKeyListPdu[TSUDSCSec1EncryptionLevel EncryptionLevel, TSUDSCSec1EncryptionMethod EncryptionMethod]
{
    optional (
              ([|EncryptionMethod in {TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_40BIT,
                                      TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_128BIT,
                                      TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_56BIT}|] TS_SECURITY_HEADER1) |
              ([|(EncryptionMethod == TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_FIPS)|] TS_SECURITY_HEADER2)
             ) securityHeader;

    TS_BITMAPCACHE_PERSISTENT_LIST_PDU persistentKeyListPduData;
           
    override string ToString()
    {
        return "Client Persistent Key List PDU";
    }
}

// 2.2.1.17.1   Persistent Key List PDU Data (TS_BITMAPCACHE_PERSISTENT_LIST_PDU)
type TS_BITMAPCACHE_PERSISTENT_LIST_PDU
{
    TS_SHAREDATAHEADER shareDataHeader;
    ushort numEntriesCache0;
    ushort numEntriesCache1;
    ushort numEntriesCache2;
    ushort numEntriesCache3;
    ushort numEntriesCache4;
    ushort totalEntriesCache0;
    ushort totalEntriesCache1;
    ushort totalEntriesCache2;
    ushort totalEntriesCache3;
    ushort totalEntriesCache4;
    TSBitmapcachePersistentListPduBBitMask bBitMask;
    byte Pad2;
    ushort Pad3;
    optional [|(numEntriesCache0 + numEntriesCache1 + numEntriesCache2 + numEntriesCache3 + numEntriesCache4) > 0|]
        array<TS_BITMAPCACHE_PERSISTENT_LIST_ENTRY> entries 
        with BinaryEncoding{Length = ((numEntriesCache0 + numEntriesCache1 + numEntriesCache2 + numEntriesCache3 + numEntriesCache4))};
}

pattern TSBitmapcachePersistentListPduBBitMask = flags byte
{
    PERSIST_FIRST_PDU = 0x01
        with Documentation
            {Description = "The PDU is the first in a sequence of Persistent Key List PDUs."},
    PERSIST_LAST_PDU = 0x02
        with Documentation
            {Description = "The PDU is the last in a sequence of Persistent Key List PDUs."},
    ...
};

// 2.2.1.17.1.1   Persistent List Entry (TS_BITMAPCACHE_PERSISTENT_LIST_ENTRY)
type TS_BITMAPCACHE_PERSISTENT_LIST_ENTRY
{
    uint Key1;
    uint Key2;

    override string ToString()
    {
        return "Key1: " + Key1.ToString() + ", Key2: " + Key2.ToString();
    }
}

// 2.2.1.18   Client Font List PDU
message ClientFontListPdu[TSUDSCSec1EncryptionLevel EncryptionLevel, TSUDSCSec1EncryptionMethod EncryptionMethod]
{
    optional (
              ([|EncryptionMethod in {TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_40BIT,
                                      TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_128BIT,
                                      TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_56BIT}|] TS_SECURITY_HEADER1) |
              ([|(EncryptionMethod == TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_FIPS)|] TS_SECURITY_HEADER2)
             ) securityHeader;

    TS_FONT_LIST_PDU fontListPduData;
           
    override string ToString()
    {
        return "Client Font List PDU";
    }
}

// 2.2.1.18.1   Font List PDU Data (TS_FONT_LIST_PDU)
type TS_FONT_LIST_PDU
{
    TS_SHAREDATAHEADER shareDataHeader where value.shareControlHeader.pduType.$"type" == TSShareControlHeaderPduTypeType.PDUTYPE_DATAPDU;
    ushort numberFonts where ValidationCheckZero(value == 0, null, false, 
        ReferenceType.Type, "RDPBCGR", "numberFonts", "TS_FONT_LIST_PDU", value);
    ushort totalNumFonts where ValidationCheckZero(value == 0, null, false, 
        ReferenceType.Type, "RDPBCGR", "totalNumFonts", "TS_FONT_LIST_PDU", value);
    ushort listFlags where ValidationCheckValue(value == 0x0003, null, false, 
        ReferenceType.Type, "RDPBCGR", "listFlags", "TS_FONT_LIST_PDU", "0x0003", value);
    ushort entrySize where ValidationCheckValue(value == 0x0032, null, false, 
        ReferenceType.Type, "RDPBCGR", "EntrySize", "TS_FONT_LIST_PDU", "0x0032", value);
}

// 2.2.1.19   Server Synchronize PDU
message ServerSynchronizePdu[TSUDSCSec1EncryptionLevel EncryptionLevel, TSUDSCSec1EncryptionMethod EncryptionMethod]
{
    optional (
              ([|EncryptionLevel == TSUDSCSec1EncryptionLevel.ENCRYPTION_LEVEL_LOW|] TS_SECURITY_HEADER) |
              ([|EncryptionMethod in {TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_40BIT,
                                      TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_128BIT,
                                      TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_56BIT}|] TS_SECURITY_HEADER1) |
              ([|(EncryptionMethod == TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_FIPS)|] TS_SECURITY_HEADER2)
             ) securityHeader;

    TS_SYNCHRONIZE_PDU synchronizePduData;
           
    override string ToString()
    {
        return "Server Synchronize PDU";
    }
}

// 2.2.1.20   Server Control PDU - Cooperate
message ServerControlPduCoOperate[TSUDSCSec1EncryptionLevel EncryptionLevel, TSUDSCSec1EncryptionMethod EncryptionMethod]
{
    optional (
              ([|EncryptionLevel == TSUDSCSec1EncryptionLevel.ENCRYPTION_LEVEL_LOW|] TS_SECURITY_HEADER) |
              ([|EncryptionMethod in {TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_40BIT,
                                      TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_128BIT,
                                      TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_56BIT}|] TS_SECURITY_HEADER1) |
              ([|(EncryptionMethod == TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_FIPS)|] TS_SECURITY_HEADER2)
             ) securityHeader;

    TS_CONTROL_PDU controlPduData where value.action == TSControlPduAction.CTRLACTION_COOPERATE;
    
    override string ToString()
    {
        return "Server Control PDU - Cooperate";
    }
}

// 2.2.1.21   Server Control PDU - Granted Control
message ServerControlPduGrantedControl[TSUDSCSec1EncryptionLevel EncryptionLevel, TSUDSCSec1EncryptionMethod EncryptionMethod]
{
    optional (
              ([|EncryptionLevel == TSUDSCSec1EncryptionLevel.ENCRYPTION_LEVEL_LOW|] TS_SECURITY_HEADER) |
              ([|EncryptionMethod in {TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_40BIT,
                                      TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_128BIT,
                                      TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_56BIT}|] TS_SECURITY_HEADER1) |
              ([|(EncryptionMethod == TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_FIPS)|] TS_SECURITY_HEADER2)
             ) securityHeader;

    TS_CONTROL_PDU controlPduData where value.action == TSControlPduAction.CTRLACTION_GRANTED_CONTROL;
    
    override string ToString()
    {
        return "Server Control PDU - Granted Control";
    }
}

// 2.2.1.22   Server Font Map PDU
message ServerFontMapPdu[TSUDSCSec1EncryptionLevel EncryptionLevel, TSUDSCSec1EncryptionMethod EncryptionMethod]
{
    optional (
              ([|EncryptionLevel == TSUDSCSec1EncryptionLevel.ENCRYPTION_LEVEL_LOW|] TS_SECURITY_HEADER) |
              ([|EncryptionMethod in {TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_40BIT,
                                      TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_128BIT,
                                      TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_56BIT}|] TS_SECURITY_HEADER1) |
              ([|(EncryptionMethod == TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_FIPS)|] TS_SECURITY_HEADER2)
             ) securityHeader;

    TS_FONT_MAP_PDU fontMapPduData;
           
    override string ToString()
    {
        return "Server Font Map PDU";
    }
}

// 2.2.1.22.1   Font Map PDU Data (TS_FONT_MAP_PDU)
type TS_FONT_MAP_PDU
{
    TS_SHAREDATAHEADER shareDataHeader where value.shareControlHeader.pduType.$"type" == TSShareControlHeaderPduTypeType.PDUTYPE_DATAPDU;
    ushort numberEntries where ValidationCheckZero(value == 0, null, false, 
        ReferenceType.Type, "RDPBCGR", "NumberEntries", "TS_FONT_MAP_PDU", value);
    ushort totalNumEntries  where ValidationCheckZero(value == 0, null, false, 
        ReferenceType.Type, "RDPBCGR", "TotalNumEntries", "TS_FONT_MAP_PDU", value);
    ushort mapFlags where ValidationCheckValue(value == 0x0003, null, false, 
        ReferenceType.Type, "RDPBCGR", "MapFlags", "TS_FONT_MAP_PDU", "0x0003", value);
    ushort entrySize  where ValidationCheckValue(value == 0x0004, null, false, 
        ReferenceType.Type, "RDPBCGR", "EntrySize", "TS_FONT_MAP_PDU", "0x0004", value);
}

// 2.2.2.1   Client Shutdown Request PDU
message ClientShutdownRequestPdu[TSUDSCSec1EncryptionLevel EncryptionLevel, TSUDSCSec1EncryptionMethod EncryptionMethod]
{
    optional (
              ([|EncryptionMethod in {TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_40BIT,
                                      TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_128BIT,
                                      TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_56BIT}|] TS_SECURITY_HEADER1) |
              ([|(EncryptionMethod == TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_FIPS)|] TS_SECURITY_HEADER2)
             ) securityHeader;
  
    TS_SHUTDOWN_REQ_PDU shutdownRequestPduData;
           
    override string ToString()
    {
        return "Client Shutdown Request PDU";
    }
}

// 2.2.2.1.1   Shutdown Request PDU Data (TS_SHUTDOWN_REQ_PDU)
type TS_SHUTDOWN_REQ_PDU
{
    TS_SHAREDATAHEADER shareDataHeader;
}

// 2.2.2.2   Server Shutdown Request Denied PDU
message ServerShutdownRequestDeniedPdu[TSUDSCSec1EncryptionLevel EncryptionLevel, TSUDSCSec1EncryptionMethod EncryptionMethod]
{
    optional (
              ([|EncryptionLevel == TSUDSCSec1EncryptionLevel.ENCRYPTION_LEVEL_LOW|] TS_SECURITY_HEADER) |
              ([|EncryptionMethod in {TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_40BIT,
                                      TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_128BIT,
                                      TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_56BIT}|] TS_SECURITY_HEADER1) |
              ([|(EncryptionMethod == TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_FIPS)|] TS_SECURITY_HEADER2)
             ) securityHeader;
  
    TS_SHUTDOWN_DENIED_PDU shutdownRequestDeniedPduData;
           
    override string ToString()
    {
        return "Server Shutdown Request Denied PDU";
    }
}

// 2.2.2.2.1   Shutdown Request Denied PDU Data (TS_SHUTDOWN_DENIED_PDU)
type TS_SHUTDOWN_DENIED_PDU
{
    TS_SHAREDATAHEADER shareDataHeader;
}

// 2.2.2.3   MCS Disconnect Provider Ultimatum PDU
message McsDisconnectProviderUltimatumPdu
{
    override string ToString()
    {
        return "MCS Disconnect Provider Ultimatum PDU";
    }
}

// 2.2.3
// 2.2.3.1   Server Deactivate All PDU
message ServerDeactivateAllPdu[TSUDSCSec1EncryptionLevel EncryptionLevel, TSUDSCSec1EncryptionMethod EncryptionMethod]
{
    optional (
              ([|EncryptionLevel == TSUDSCSec1EncryptionLevel.ENCRYPTION_LEVEL_LOW|] TS_SECURITY_HEADER) |
              ([|EncryptionMethod in {TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_40BIT,
                                      TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_128BIT,
                                      TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_56BIT}|] TS_SECURITY_HEADER1) |
              ([|(EncryptionMethod == TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_FIPS)|] TS_SECURITY_HEADER2)
             ) securityHeader;
  
    TS_DEACTIVATE_ALL_PDU deactivateAllPduData;

    override string ToString()
    {
        return "Server Deactivate All PDU";
    }
}

// 2.2.3.1.1   Deactivate All PDU Data (TS_DEACTIVATE_ALL_PDU)
type TS_DEACTIVATE_ALL_PDU
{
    TS_SHARECONTROLHEADER shareControlHeader where value.pduType.$"type" == TSShareControlHeaderPduTypeType.PDUTYPE_DEACTIVATEALLPDU;
    uint shareId;
    ushort lengthSourceDescriptor;
    binary sourceDescriptor with BinaryEncoding{Length = lengthSourceDescriptor};
}

// 2.2.4
// 2.2.4.1   Server Auto-Reconnect Status PDU
message ServerAutoReconnectStatusPdu[TSUDSCSec1EncryptionLevel EncryptionLevel, TSUDSCSec1EncryptionMethod EncryptionMethod]
{
    optional (
              ([|EncryptionLevel == TSUDSCSec1EncryptionLevel.ENCRYPTION_LEVEL_LOW|] TS_SECURITY_HEADER) |
              ([|EncryptionMethod in {TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_40BIT,
                                      TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_128BIT,
                                      TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_56BIT}|] TS_SECURITY_HEADER1) |
              ([|(EncryptionMethod == TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_FIPS)|] TS_SECURITY_HEADER2)
             ) securityHeader;
  
    TS_AUTORECONNECT_STATUS_PDU arcStatusPduData;
           
    override string ToString()
    {
        return "Server Auto-Reconnect Status PDU";
    }
}

// 2.2.4.1.1   Auto-Reconnect Status PDU Data (TS_AUTORECONNECT_STATUS_PDU)
type TS_AUTORECONNECT_STATUS_PDU
{
    TS_SHAREDATAHEADER shareDataHeader;
    uint arcStatus where ValidationCheckZero(value == 0, null, true, ReferenceType.Type, "RDPBCGR", "ArcStatus", "TS_AUTORECONNECT_STATUS_PDU", value);
}

// 2.2.4.2   Server Auto-Reconnect Packet (ARC_SC_PRIVATE_PACKET)
type ARC_SC_PRIVATE_PACKET
{
    uint cbLen where ValidationCheckValue(value == 0x0000001C, null, true, ReferenceType.Type, 
        "RDPBCGR", "cbLen", "ARC_SC_PRIVATE_PACKET", "0x0000001C", value);
    ArcSCPrivatePacketVersion Version 
        where ValidationCheckValue(value == ArcSCPrivatePacketVersion.AUTO_RECONNECT_VERSION_1, 
        null, false, ReferenceType.Type, "RDPBCGR", "Version", "ARC_SC_PRIVATE_PACKET", "0x00000001", value);
    uint LogonId;
    binary ArcRandomBits with BinaryEncoding{Length = 16};
}

// 2.2.4.2   Server Auto-Reconnect Packet (ARC_SC_PRIVATE_PACKET)
pattern ArcSCPrivatePacketVersion = enum uint
{
    AUTO_RECONNECT_VERSION_1 = 0x00000001,
    ...
};
  
// 2.2.4.3   Client Auto-Reconnect Packet (ARC_CS_PRIVATE_PACKET)
type ARC_CS_PRIVATE_PACKET
{
    uint cbLen where ValidationCheckValue(value == 0x0000001C, null, true, 
        ReferenceType.Type, "RDPBCGR", "cbLen", "ARC_CS_PRIVATE_PACKET", 0x0000001C, value);
    ArcCSPrivatePacketVersion Version 
        where ValidationCheckValue(value == ArcCSPrivatePacketVersion.AUTO_RECONNECT_VERSION_1 , 
        null, false, ReferenceType.Type, "RDPBCGR", "Version", "ARC_CS_PRIVATE_PACKET", "0x00000001", value);
    uint LogonId;
    binary SecurityVerifier with BinaryEncoding{Length = 16};
}

// 2.2.4.3   Client Auto-Reconnect Packet (ARC_CS_PRIVATE_PACKET)
pattern ArcCSPrivatePacketVersion = enum uint
{
    AUTO_RECONNECT_VERSION_1 = 0x00000001,
    ...   
};

// 2.2.5
// 2.2.5.1   Server Set Error Info PDU
message ServerSetErrorInfoPdu[TSUDSCSec1EncryptionLevel EncryptionLevel, TSUDSCSec1EncryptionMethod EncryptionMethod]
{
    optional (
              ([|EncryptionLevel == TSUDSCSec1EncryptionLevel.ENCRYPTION_LEVEL_LOW|] TS_SECURITY_HEADER) |
              ([|EncryptionMethod in {TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_40BIT,
                                      TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_128BIT,
                                      TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_56BIT}|] TS_SECURITY_HEADER1) |
              ([|(EncryptionMethod == TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_FIPS)|] TS_SECURITY_HEADER2)
             ) securityHeader;
    TS_SET_ERROR_INFO_PDU errorInfoPduData;
           
    override string ToString()
    {
        return "Server Set Error Info PDU, ErrorInfo: " + EnumToStringInSummary<RDPBCGR.TSSetErrorInfoPduErrorInfo>(errorInfoPduData.errorInfo);
    }
}

// 2.2.5.1.1   Set Error Info PDU Data (TS_SET_ERROR_INFO_PDU)
type TS_SET_ERROR_INFO_PDU
{
    TS_SHAREDATAHEADER shareDataHeader;
    TSSetErrorInfoPduErrorInfo errorInfo;
}

// 2.2.5.1.1   Set Error Info PDU Data (TS_SET_ERROR_INFO_PDU)
pattern TSSetErrorInfoPduErrorInfo = enum uint
{
    // Protocol-independent codes
    ERRINFO_NONE = 0x00000000,
    ERRINFO_RPC_INITIATED_DISCONNECT = 0x00000001,
    ERRINFO_RPC_INITIATED_LOGOFF = 0x00000002,
    ERRINFO_IDLE_TIMEOUT = 0x00000003,
    ERRINFO_LOGON_TIMEOUT = 0x00000004,
    ERRINFO_DISCONNECTED_BY_OTHERCONNECTION = 0x00000005,
    ERRINFO_OUT_OF_MEMORY = 0x00000006,
    ERRINFO_SERVER_DENIED_CONNECTION = 0x00000007,
    ERRINFO_SERVER_INSUFFICIENT_PRIVILEGES = 0x00000009,
    ERRINFO_SERVER_FRESH_CREDENTIALS_REQUIRED = 0x0000000A,
    ERRINFO_RPC_INITIATED_DISCONNECT_BYUSER = 0x0000000B,
    ERRINFO_LOGOFF_BY_USER = 0x0000000C,

    // Protocol-independent licensing codes
    ERRINFO_LICENSE_INTERNAL = 0x00000100,
    ERRINFO_LICENSE_NO_LICENSE_SERVER = 0x00000101,
    ERRINFO_LICENSE_NO_LICENSE = 0x00000102,
    ERRINFO_LICENSE_BAD_CLIENT_MSG = 0x00000103,
    ERRINFO_LICENSE_HWID_DOESNT_MATCH_LICENSE = 0x00000104,
    ERRINFO_LICENSE_BAD_CLIENT_LICENSE = 0x00000105,
    ERRINFO_LICENSE_CANT_FINISH_PROTOCOL = 0x00000106,
    ERRINFO_LICENSE_CLIENT_ENDED_PROTOCOL = 0x00000107,
    ERRINFO_LICENSE_BAD_CLIENT_ENCRYPTION = 0x00000108,
    ERRINFO_LICENSE_CANT_UPGRADE_LICENSE = 0x00000109,
    ERRINFO_LICENSE_NO_REMOTE_CONNECTIONS = 0x0000010A,

    // Protocol-independent codes generated by Connection Broker
    ERRINFO_CB_DESTINATION_NOT_FOUND = 0x00000400,
    ERRINFO_CB_LOADING_DESTINATION = 0x00000402,
    ERRINFO_CB_REDIRECTING_TO_DESTINATION = 0x00000404,
    ERRINFO_CB_SESSION_ONLINE_VM_WAKE = 0x00000405,
    ERRINFO_CB_SESSION_ONLINE_VM_BOOT = 0x00000406,
    ERRINFO_CB_SESSION_ONLINE_VM_NO_DNS = 0x00000407,
    ERRINFO_CB_DESTINATION_POOL_NOT_FREE = 0x00000408,
    ERRINFO_CB_CONNECTION_CANCELLED = 0x00000409,
    ERRINFO_CB_CONNECTION_ERROR_INVALID_SETTINGS = 0x00000410,
    ERRINFO_CB_SESSION_ONLINE_VM_BOOT_TIMEOUT = 0x00000411,
    ERRINFO_CB_SESSION_ONLINE_VM_SESSMON_FAILED = 0x00000412,

    // RDP specific codes
    ERRINFO_UNKNOWNPDUTYPE2 = 0x000010C9,
    ERRINFO_UNKNOWNPDUTYPE = 0x000010CA,
    ERRINFO_DATAPDUSEQUENCE = 0x000010CB,
    ERRINFO_CONTROLPDUSEQUENCE = 0x000010CD,
    ERRINFO_INVALIDCONTROLPDUACTION = 0x000010CE,
    ERRINFO_INVALIDINPUTPDUTYPE = 0x000010CF,
    ERRINFO_INVALIDINPUTPDUMOUSE = 0x000010D0,
    ERRINFO_INVALIDREFRESHRECTPDU = 0x000010D1,
    ERRINFO_CREATEUSERDATAFAILED = 0x000010D2,
    ERRINFO_CONNECTFAILED = 0x000010D3,
    ERRINFO_CONFIRMACTIVEWRONGSHAREID = 0x000010D4,
    ERRINFO_CONFIRMACTIVEWRONGORIGINATOR = 0x000010D5,
    ERRINFO_PERSISTENTKEYPDUBADLENGTH = 0x000010DA,
    ERRINFO_PERSISTENTKEYPDUILLEGALFIRST = 0x000010DB,
    ERRINFO_PERSISTENTKEYPDUTOOMANYTOTALKEYS = 0x000010DC,
    ERRINFO_PERSISTENTKEYPDUTOOMANYCACHEKEYS = 0x000010DD,
    ERRINFO_INPUTPDUBADLENGTH = 0x000010DE,
    ERRINFO_BITMAPCACHEERRORPDUBADLENGTH = 0x000010DF,
    ERRINFO_SECURITYDATATOOSHORT = 0x000010E0,
    ERRINFO_VCHANNELDATATOOSHORT = 0x000010E1,
    ERRINFO_SHAREDATATOOSHORT = 0x000010E2,
    ERRINFO_BADSUPRESSOUTPUTPDU = 0x000010E3,
    ERRINFO_CONFIRMACTIVEPDUTOOSHORT = 0x000010E5,
    ERRINFO_CAPABILITYSETTOOSMALL = 0x000010E7,
    ERRINFO_CAPABILITYSETTOOLARGE = 0x000010E8,
    ERRINFO_NOCURSORCACHE = 0x000010E9,
    ERRINFO_BADCAPABILITIES = 0x000010EA,
    ERRINFO_VIRTUALCHANNELDECOMPRESSIONERR = 0x000010EC,
    ERRINFO_INVALIDVCCOMPRESSIONTYPE = 0x000010ED,
    ERRINFO_INVALIDCHANNELID = 0x000010EF,
    ERRINFO_VCHANNELSTOOMANY = 0x000010F0,
    ERRINFO_REMOTEAPPSNOTENABLED = 0x000010F3,
    ERRINFO_CACHECAPNOTSET = 0x000010F4,
    ERRINFO_BITMAPCACHEERRORPDUBADLENGTH2 = 0x000010F5,
    ERRINFO_OFFSCRCACHEERRORPDUBADLENGTH = 0x000010F6,
    ERRINFO_DNGCACHEERRORPDUBADLENGTH = 0x000010F7,
    ERRINFO_GDIPLUSPDUBADLENGTH = 0x000010F8,
    ERRINFO_SECURITYDATATOOSHORT2 = 0x00001111,
    ERRINFO_SECURITYDATATOOSHORT3 = 0x00001112,
    ERRINFO_SECURITYDATATOOSHORT4 = 0x00001113,
    ERRINFO_SECURITYDATATOOSHORT5 = 0x00001114,
    ERRINFO_SECURITYDATATOOSHORT6 = 0x00001115,
    ERRINFO_SECURITYDATATOOSHORT7 = 0x00001116,
    ERRINFO_SECURITYDATATOOSHORT8 = 0x00001117,
    ERRINFO_SECURITYDATATOOSHORT9 = 0x00001118,
    ERRINFO_SECURITYDATATOOSHORT10 = 0x00001119,
    ERRINFO_SECURITYDATATOOSHORT11 = 0x0000111A,
    ERRINFO_SECURITYDATATOOSHORT12 = 0x0000111B,
    ERRINFO_SECURITYDATATOOSHORT13 = 0x0000111C,
    ERRINFO_SECURITYDATATOOSHORT14 = 0x0000111D,
    ERRINFO_SECURITYDATATOOSHORT15 = 0x0000111E,
    ERRINFO_SECURITYDATATOOSHORT16 = 0x0000111F,
    ERRINFO_SECURITYDATATOOSHORT17 = 0x00001120,
    ERRINFO_SECURITYDATATOOSHORT18 = 0x00001121,
    ERRINFO_SECURITYDATATOOSHORT19 = 0x00001122,
    ERRINFO_SECURITYDATATOOSHORT20 = 0x00001123,
    ERRINFO_SECURITYDATATOOSHORT21 = 0x00001124,
    ERRINFO_SECURITYDATATOOSHORT22 = 0x00001125,
    ERRINFO_SECURITYDATATOOSHORT23 = 0x00001126,
    ERRINFO_BADMONITORDATA = 0x00001129,
    ERRINFO_VCDECOMPRESSEDREASSEMBLEFAILED = 0x0000112A,
    ERRINFO_VCDATATOOLONG = 0x0000112B,
    ERRINFO_BAD_FRAME_ACK_DATA = 0x0000112C,
    ERRINFO_GRAPHICSMODENOTSUPPORTED = 0x0000112D,
    ERRINFO_GRAPHICSSUBSYSTEMRESETFAILED = 0x0000112E,
    ERRINFO_GRAPHICSSUBSYSTEMFAILED = 0x0000112F,
    ERRINFO_TIMEZONEKEYNAMELENGTHTOOSHORT = 0x00001130,
    ERRINFO_TIMEZONEKEYNAMELENGTHTOOLONG = 0x00001131,
    ERRINFO_DYNAMICDSTDISABLEDFIELDMISSING = 0x00001132,
    ERRINFO_VCDECODINGERROR = 0x00001133,
    ERRINFO_UPDATESESSIONKEYFAILED = 0x00001191,
    ERRINFO_DECRYPTFAILED = 0x00001192,
    ERRINFO_ENCRYPTFAILED = 0x00001193,
    ERRINFO_ENCPKGMISMATCH = 0x00001194,
    ERRINFO_DECRYPTFAILED2 = 0x00001195,
    ...
};

// 2.2.5.2   Server Status Info PDU
message ServerStatusInfoPdu[TSUDSCSec1EncryptionLevel EncryptionLevel, TSUDSCSec1EncryptionMethod EncryptionMethod]
{
    optional (
              ([|EncryptionLevel == TSUDSCSec1EncryptionLevel.ENCRYPTION_LEVEL_LOW|] TS_SECURITY_HEADER) |
              ([|EncryptionMethod in {TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_40BIT,
                                      TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_128BIT,
                                      TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_56BIT}|] TS_SECURITY_HEADER1) |
              ([|(EncryptionMethod == TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_FIPS)|] TS_SECURITY_HEADER2)
             ) securityHeader;
  
    TS_SHAREDATAHEADER shareDataHeader;
    ServerStatusInfoPduStatusCode statusCode;
        
    override string ToString()
    {
        return "Server Status Info PDU, StatusCode: " + EnumToStringInSummary<RDPBCGR.ServerStatusInfoPduStatusCode>(statusCode);
    }
}

// 2.2.5.2   Server Status Info PDU
pattern ServerStatusInfoPduStatusCode = enum uint
{
    TS_STATUS_FINDING_DESTINATION = 0x00000401,
    TS_STATUS_LOADING_DESTINATION = 0x00000402,
    TS_STATUS_BRINGING_SESSION_ONLINE = 0x00000403,
    TS_STATUS_REDIRECTING_TO_DESTINATION = 0x00000404,
    TS_STATUS_VM_LOADING = 0x00000501,
    TS_STATUS_VM_WAKING = 0x00000502,
    TS_STATUS_VM_STARTING = 0x00000503,
    TS_STATUS_VM_STARTING_MONITORING = 0x00000504,
    TS_STATUS_VM_RETRYING_MONITORING = 0x00000505,
    ...
};

// 2.2.6
// 2.2.6.1   Virtual Channel PDU
message VirtualChannelPdu[TSUDSCSec1EncryptionLevel EncryptionLevel, TSUDSCSec1EncryptionMethod EncryptionMethod]
{    
    optional (
              ([|EncryptionLevel == TSUDSCSec1EncryptionLevel.ENCRYPTION_LEVEL_LOW|] TS_SECURITY_HEADER) |
              ([|EncryptionMethod in {TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_40BIT,
                                      TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_128BIT,
                                      TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_56BIT}|] TS_SECURITY_HEADER1) |
              ([|(EncryptionMethod == TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_FIPS)|] TS_SECURITY_HEADER2)
             ) securityHeader;
    
    CHANNEL_PDU_HEADER channelPduHeader;
    binary virtualChannelData;
    
    override string ToString()
    {
        string summary = "Virtual Channel PDU";
        if (channelPduHeader.$"flags".CHANNEL_PACKET_COMPRESSED)
        {
            summary += ", Compressed";
        }
        return summary;
    }
}

// 2.2.6.1.1   Channel PDU Header (CHANNEL_PDU_HEADER)
type CHANNEL_PDU_HEADER
{
    uint length;
    ChannelPduHeaderFlags $"flags";
}

// 2.2.6.1.1   Channel PDU Header (CHANNEL_PDU_HEADER)
type ChannelPduHeaderFlags
{
    ushort Reserverd4 with BinaryEncoding{Endian = Endian.Big, Width = 8}; // 24-31
    bool CHANNEL_PACKET_FLUSHED with BinaryEncoding{Endian = Endian.Big, Width = 1}; // 23
    bool CHANNEL_PACKET_AT_FRONT with BinaryEncoding{Width = 1}; // 22
    bool CHANNEL_PACKET_COMPRESSED with BinaryEncoding{Width = 1}; // 21
    bool Reserved3 with BinaryEncoding{Width = 1}; // 20-21
    CompressionTypeMaskPatt CompressionTypeMask with BinaryEncoding{Endian = Endian.Big, Width = 4}; // 16-19
    ushort Reserved2 with BinaryEncoding{Endian = Endian.Big, Width = 8}; // 8-15
    bool CHANNEL_FLAG_SHADOW_PERSISTENT with BinaryEncoding{Width = 1}; // 7
    bool CHANNEL_FLAG_RESUME with BinaryEncoding{Width = 1}; // 6
    bool CHANNEL_FLAG_SUSPEND with BinaryEncoding{Width = 1}; // 5
    bool CHANNEL_FLAG_SHOW_PROTOCOL with BinaryEncoding{Width = 1}; // 4
    byte Reserved1 with BinaryEncoding{Endian = Endian.Big, Width = 2}; // 2-3
    bool CHANNEL_FLAG_LAST with BinaryEncoding{Width = 1}; // 1
    bool CHANNEL_FLAG_FIRST with BinaryEncoding{Width = 1}; // 0
}with BinaryEncoding{Endian = Endian.Little, WidthForComposedType = 32, DecodeAsUnit = true};

pattern CompressionTypeMaskPatt = enum ushort
{
    PACKET_COMPR_TYPE_8K = 0x0,
    PACKET_COMPR_TYPE_64K = 0x1,
    PACKET_COMPR_TYPE_RDP6 = 0x2,
    PACKET_COMPR_TYPE_RDP61 = 0x3,
    ...
};
// patterns of section 2.2.7.1.1
pattern TSGeneralCapabilitySetOSMajorType = enum ushort
{
    OSMAJORTYPE_UNSPECIFIED = 0x0000,
    OSMAJORTYPE_WINDOWS = 0x0001,
    OSMAJORTYPE_OS2 = 0x0002,
    OSMAJORTYPE_MACINTOSH = 0x0003,
    OSMAJORTYPE_UNIX = 0x0004,
    OSMAJORTYPE_IOS = 0x0005,
    OSMAJORTYPE_OSX = 0x0006,
    OSMAJORTYPE_ANDROID = 0x0007,
    ...
};

pattern TSGeneralCapabilitySetOSMinorType = enum ushort
{
    OSMINORTYPE_UNSPECIFIED = 0x0000,
    OSMINORTYPE_WINDOWS_31X = 0x0001,
    OSMINORTYPE_WINDOWS_95 = 0x0002,
    OSMINORTYPE_WINDOWS_NT = 0x0003,
    OSMINORTYPE_OS2_V21 = 0x0004,
    OSMINORTYPE_POWER_PC = 0x0005,
    OSMINORTYPE_MACINTOSH = 0x0006,
    OSMINORTYPE_NATIVE_XSERVER = 0x0007,
    OSMINORTYPE_PSEUDO_XSERVER = 0x0008,
    OSMINORTYPE_WINDOWS_RT = 0x0009,
    ...
};

pattern TSGeneralCapabilitySetExtraFlags = flags ushort
{
    FASTPATH_OUTPUT_SUPPORTED = 0x0001
        with Documentation
            {Description = "Advertiser supports fast-path output."},
    NO_BITMAP_COMPRESSION_HDR = 0x0400
        with Documentation
            {Description = "Advertiser supports excluding the 8-byte Compressed Data Header from the Bitmap Data structure or the Cache Bitmap (Revision 2) Secondary Drawing Order."},
    LONG_CREDENTIALS_SUPPORTED = 0x0004
        with Documentation
            {Description = "Advertiser supports long-length credentials for the user name, password, or domain name in the Save Session Info PDU."},
    AUTORECONNECT_SUPPORTED = 0x0008
        with Documentation
            {Description = "Advertiser supports auto-reconnection."},
    ENC_SALTED_CHECKSUM = 0x0010
        with Documentation
            {Description = "Advertiser supports salted MAC generation."},
    ...
};

// 2.2.7.1.1   General Capability Set (TS_GENERAL_CAPABILITYSET)
type TS_GENERAL_CAPABILITYSET
{
    ushort capabilitySetType where value == TSCapsSetCapabilitySetType.CAPSTYPE_GENERAL;
    ushort lengthCapability;
    TSGeneralCapabilitySetOSMajorType osMajorType;
    TSGeneralCapabilitySetOSMinorType osMinorType;
    ushort protocolVersion 
        where ValidationCheckValue(value == 0x0200, null, true, 
        ReferenceType.Type, "RDPBCGR", "protocolVersion", 
        "TS_GENERAL_CAPABILITYSET", "TS_CAPS_PROTOCOLVERSION (0x0200)", value);
    ushort pad2octetsA;
    ushort generalCompressionTypes 
        where ValidationCheckZero(value == 0x0, null, true, 
        ReferenceType.Type, "RDPBCGR", "generalCompressionTypes", "TS_GENERAL_CAPABILITYSET", value);
    TSGeneralCapabilitySetExtraFlags extraFlags;
    ushort updateCapabilityFlag
        where ValidationCheckZero(value == 0x0, null, true, 
        ReferenceType.Type, "RDPBCGR", "updateCapabilityFlag", "TS_GENERAL_CAPABILITYSET", value);
    ushort remoteUnshareFlag
        where ValidationCheckZero(value == 0x0, null, true, 
        ReferenceType.Type, "RDPBCGR", "remoteUnshareFlag", "TS_GENERAL_CAPABILITYSET", value);
    ushort generalCompressionLevel
        where ValidationCheckZero(value == 0x0, null, true, 
        ReferenceType.Type, "RDPBCGR", "generalCompressionLevel", "TS_GENERAL_CAPABILITYSET", value);
    TrueFalseByte refreshRectSupport;
    TrueFalseByte suppressOutputSupport;

    override string ToString()
    {
        return "TS_GENERAL_CAPABILITYSET" + 
            (refreshRectSupport == TrueFalseByte.TRUE ? ", Refresh Rect PDU supported" : "") +
            (suppressOutputSupport == TrueFalseByte.TRUE ? ", Suppress Output PDU supported" : "");
    }
}

pattern TSBitmapCapabilitySetDrawingFlags = flags byte
{
    DRAW_ALLOW_DYNAMIC_COLOR_FIDELITY = 0x02
        with Documentation
            {Description = "Indicates support for lossy compression of 32 bpp bitmaps by reducing color-fidelity on a per-pixel basis."},
    DRAW_ALLOW_COLOR_SUBSAMPLING = 0x04
        with Documentation
            {Description = "Indicates support for chroma subsampling when compressing 32 bpp bitmaps."},
    DRAW_ALLOW_SKIP_ALPHA = 0x08
        with Documentation
            {Description = "The client supports the removal of the alpha-channel when compressing 32 bpp bitmaps."},
    DRAW_UNUSED_FLAG = 0x10
        with Documentation
            {Description = "An unused flag that MUST be ignored by the client if it is present in the server-to-client Bitmap Capability Set."},
    ...         
};

// 2.2.7.1.2   Bitmap Capability Set (TS_BITMAP_CAPABILITYSET)
type TS_BITMAP_CAPABILITYSET
{
    ushort capabilitySetType where value == TSCapsSetCapabilitySetType.CAPSTYPE_BITMAP;
    ushort lengthCapability;
    ushort preferredBitsPerPixel;
    TrueFalseUshort receive1BitPerPixel 
        where ValidationCheckValue(value == 0x0001, null, false, 
        ReferenceType.Type, "RDPBCGR", "receive1BitPerPixel", 
        "TS_BITMAP_CAPABILITYSET", "0x0001", value);
    TrueFalseUshort receive4BitsPerPixel 
        where ValidationCheckValue(value == 0x0001, null, false, 
        ReferenceType.Type, "RDPBCGR", "receive4BitsPerPixel", 
        "TS_BITMAP_CAPABILITYSET", "0x0001", value);
    TrueFalseUshort receive8BitsPerPixel 
        where ValidationCheckValue(value == 0x0001, null, false, 
        ReferenceType.Type, "RDPBCGR", "receive8BitsPerPixel", 
        "TS_BITMAP_CAPABILITYSET", "0x0001", value);
    ushort desktopWidth;
    ushort desktopHeight;
    ushort pad2octets;
    TrueFalseUshort desktopResizeFlag;
    TrueFalseUshort bitmapCompressionFlag 
        where ValidationCheckValue(value == 0x0001, null, true, 
        ReferenceType.Type, "RDPBCGR", "bitmapCompressionFlag", 
        "TS_BITMAP_CAPABILITYSET", "0x0001", value);
    byte highColorFlags
        where ValidationCheckZero(value == 0x00, null, false, ReferenceType.Type, 
        "RDPBCGR", "highColorFlags", "TS_BITMAP_CAPABILITYSET", value);
    TSBitmapCapabilitySetDrawingFlags drawingFlags;
    TrueFalseUshort multipleRectangleSupport 
        where ValidationCheckValue(value == 0x0001, null, true, 
        ReferenceType.Type, "RDPBCGR", "multipleRectangleSupport", 
        "TS_BITMAP_CAPABILITYSET", "0x0001", value);
    ushort pad2octetsB;

    override string ToString()
    {
        return "TS_BITMAP_CAPABILITYSET, preferredBitsPerPixel: " + preferredBitsPerPixel.ToString();
    }
}

// patterns of section 2.2.7.1.3
pattern TSOrderCapabilitySetOrderFlags = flags ushort
{
    NEGOTIATEORDERSUPPORT = 0x0002
        with Documentation
            {Description = "Indicates support for specifying supported drawing orders in the orderSupport field."},
    ZEROBOUNDSDELTASSUPPORT = 0x0008
        with Documentation
            {Description = "Indicates support for the TS_ZERO_BOUNDS_DELTAS (0x20) flag."},
    COLORINDEXSUPPORT = 0x0020
        with Documentation
            {Description = "Indicates support for sending color indices (not RGB values) in orders."},
    SOLIDPATTERNBRUSHONLY = 0x0040
        with Documentation
            {Description = "This party can receive only solid and pattern brushes."},
    ORDERFLAGS_EXTRA_FLAGS = 0x0080
        with Documentation
            {Description = "The orderSupportExFlags field contains valid data."},
    ...
};

type TSOrderCapabilitySetOrderSupport
{
    byte TS_NEG_DSTBLT_INDEX;
    byte TS_NEG_PATBLT_INDEX;
    byte TS_NEG_SCRBLT_INDEX;
    byte TS_NEG_MEMBLT_INDEX;
    byte TS_NEG_MEM3BLT_INDEX;
    byte UnusedIndex1;
    byte UnusedIndex2;
    byte TS_NEG_DRAWNINEGRID_INDEX;
    byte TS_NEG_LINETO_INDEX;
    byte TS_NEG_MULTI_DRAWNINEGRID_INDEX;
    byte UnusedIndex3;
    byte TS_NEG_SAVEBITMAP_INDEX;
    byte UnusedIndex4;
    byte UnusedIndex5;
    byte UnusedIndex6;
    byte TS_NEG_MULTIDSTBLT_INDEX;
    byte TS_NEG_MULTIPATBLT_INDEX;
    byte TS_NEG_MULTISCRBLT_INDEX;
    byte TS_NEG_MULTIOPAQUERECT_INDEX;
    byte TS_NEG_FAST_INDEX_INDEX;
    byte TS_NEG_POLYGON_SC_INDEX;
    byte TS_NEG_POLYGON_CB_INDEX;
    byte TS_NEG_POLYLINE_INDEX;
    byte UnusedIndex7;
    byte TS_NEG_FAST_GLYPH_INDEX;
    byte TS_NEG_ELLIPSE_SC_INDEX;
    byte TS_NEG_ELLIPSE_CB_INDEX;
    byte TS_NEG_INDEX_INDEX;
    byte UnusedIndex8;
    byte UnusedIndex9;
    byte UnusedIndex10;
    byte UnusedIndex11;
};

pattern TSOrderCapabilitySetOrderSupportExFlags = flags ushort
{
    ORDERFLAGS_EX_CACHE_BITMAP_REV3_SUPPORT = 0x0002
        with Documentation
            {Description = "The Cache Bitmap (Revision 3) Secondary Drawing Order is supported."},
    ORDERFLAGS_EX_ALTSEC_FRAME_MARKER_SUPPORT = 0x0004
        with Documentation
            {Description = "The Frame Marker Alternate Secondary Drawing Order is supported."},
};

// 2.2.7.1.3   Order Capability Set (TS_ORDER_CAPABILITYSET)
type TS_ORDER_CAPABILITYSET
{
    ushort capabilitySetType where value == TSCapsSetCapabilitySetType.CAPSTYPE_ORDER;
    ushort lengthCapability;
    binary terminalDescriptor with BinaryEncoding{Length = 16};
    uint pad4octetsA;
    ushort desktopSaveXGranularity;
    ushort desktopSaveYGranularity;
    ushort pad2octetsA;
    ushort maximumOrderLevel;
    ushort numberFonts;
    TSOrderCapabilitySetOrderFlags orderFlags;
    TSOrderCapabilitySetOrderSupport orderSupport;
    ushort textFlags;
    TSOrderCapabilitySetOrderSupportExFlags orderSupportExFlags;
    uint pad4octetsB;
    uint desktopSaveSize;
    ushort pad2octetsC;
    ushort pad2octetsD;
    ushort textANSICodePage;
    ushort pad2octetsE;

    override string ToString()
    {
        return "TS_ORDER_CAPABILITYSET";
    }
}

// 2.2.7.1.4   Bitmap Cache Capability Set
// 2.2.7.1.4.1   Revision 1 (TS_BITMAPCACHE_CAPABILITYSET)
type TS_BITMAPCACHE_CAPABILITYSET
{
    ushort capabilitySetType where value == TSCapsSetCapabilitySetType.CAPSTYPE_BITMAPCACHE;
    ushort lengthCapability;
    uint pad1;
    uint pad2;
    uint pad3;
    uint pad4;
    uint pad5;
    uint pad6;
    ushort Cache0Entries;
    ushort Cache0MaximumCellSize;
    ushort Cache1Entries;
    ushort Cache1MaximumCellSize;
    ushort Cache2Entries;
    ushort Cache2MaximumCellSize;

    override string ToString()
    {
        return "TS_BITMAPCACHE_CAPABILITYSET";
    }
}

// pattern of section 2.2.7.1.4.2
pattern TSBitmapCacheCapabilitySetRev2CacheFlags = flags ushort
{
    PERSISTENT_KEYS_EXPECTED_FLAG = 0x0001
        with Documentation
            {Description = "The client will send a Persistent Key List PDU during the Connection Finalization phase of the RDP Connection Sequence."},
    ALLOW_CACHE_WAITING_LIST_FLAG = 0x0002
        with Documentation
            {Description = "The client supports a cache waiting list."},
    ...
};

// 2.2.7.1.4.2   Revision 2 (TS_BITMAPCACHE_CAPABILITYSET_REV2)
type TS_BITMAPCACHE_CAPABILITYSET_REV2
{
    ushort capabilitySetType where value == TSCapsSetCapabilitySetType.CAPSTYPE_BITMAPCACHE_REV2;
    ushort lengthCapability;
    TSBitmapCacheCapabilitySetRev2CacheFlags CacheFlags;
    byte pad2;
    byte NumCellCaches;
    TS_BITMAPCACHE_CELL_CACHE_INFO BitmapCache0CellInfo;
    TS_BITMAPCACHE_CELL_CACHE_INFO BitmapCache1CellInfo;
    TS_BITMAPCACHE_CELL_CACHE_INFO BitmapCache2CellInfo;
    TS_BITMAPCACHE_CELL_CACHE_INFO BitmapCache3CellInfo;
    TS_BITMAPCACHE_CELL_CACHE_INFO BitmapCache4CellInfo;
    binary Pad3 with BinaryEncoding{Length = 12};

    override string ToString()
    {
        return "TS_BITMAPCACHE_CAPABILITYSET_REV2, " + EnumToString<TSBitmapCacheCapabilitySetRev2CacheFlags>(CacheFlags);
    }
}

type TS_BITMAPCACHE_CELL_CACHE_INFO
{
    TsBitmapCacheCapabilitySetRev2CellInfo CellInfo;
}

type TsBitmapCacheCapabilitySetRev2CellInfo
{
    byte k with BinaryEncoding {Width = 1};
    uint NumEntries with BinaryEncoding {Width = 31, Endian = Endian.Big};
} with BinaryEncoding {Endian = Endian.Little, WidthForComposedType = 32, DecodeAsUnit = true};

// 2.2.7.1.5   Pointer Capability Set (TS_POINTER_CAPABILITYSET)
type TS_POINTER_CAPABILITYSET
{
    ushort capabilitySetType where value == TSCapsSetCapabilitySetType.CAPSTYPE_POINTER;
    ushort lengthCapability;
    TrueFalseUshort colorPointerFlag;
    ushort colorPointerCacheSize;
    optional ushort pointerCacheSize;

    override string ToString()
    {
        string summary = "TS_POINTER_CAPABILITYSET, colorPointerCacheSize: " + colorPointerCacheSize.ToString();
        if (pointerCacheSize is size:ushort)
        {
            summary += ", pointerCacheSize" + size.ToString();
        }
        return summary;
    }
}

// pattern of section 2.2.7.1.6
pattern TSInputCapabilitySetInputFlags = flags ushort
{
    INPUT_FLAG_SCANCODES = 0x0001
        with Documentation
            {Description = "Indicates support for using scancodes in the Keyboard Event notifications."},
    INPUT_FLAG_MOUSEX = 0x0004
        with Documentation
            {Description = "Indicates support for Extended Mouse Event notifications."},
    INPUT_FLAG_FASTPATH_INPUT = 0x0008
        with Documentation
            {Description = "Advertised by RDP 5.0 and 5.1 servers."},
    INPUT_FLAG_UNICODE = 0x0010
        with Documentation
            {Description = "Indicates support for Unicode Keyboard Event notifications."},
    INPUT_FLAG_FASTPATH_INPUT2 = 0x0020
        with Documentation
            {Description = "Advertised by RDP 5.2, 6.0, 6.1, 7.0, 7.1, and 8.0 servers."},
    INPUT_FLAG_UNUSED1 = 0x0040
        with Documentation
            {Description = "An unused flag that MUST be ignored by the client if it is present in the server-to-client Input Capability Set."},
    INPUT_FLAG_UNUSED2 = 0x0080
        with Documentation
            {Description = "An unused flag that MUST be ignored by the server if it is present in the client-to-server Input Capability Set."},
    TS_INPUT_FLAG_MOUSE_HWHEEL = 0x0100
        with Documentation
            {Description = "Indicates support for horizontal mouse wheel notifications."},
    TS_INPUT_FLAG_QOE_TIMESTAMPS = 0x0200
        with Documentation
            {Description = "Indicates support for Quality of Experience (QoE) timestamp notifications."},
    ...
};

pattern KeyboardType = enum uint
{
    // Sent by Client
    IBMPCXTorCompatible83keyKeyboard = 0x00000001,
    OlivettiICO102keyKeyboard = 0x00000002,
    IBMPCAT84keyorSimilarKeyboard = 0x00000003,
    IBMEnhanced101or102keyKeyboard = 0x00000004,
    Nokia1050andSimilarKeyboards = 0x00000005,
    Nokia9140andSimilarKeyboards = 0x00000006,
    JapaneseKeyboard = 0x00000007,
      
    // Sent by Server
    None = 0x00000000,
    ...
};

// 2.2.7.1.6   Input Capability Set (TS_INPUT_CAPABILITYSET)
type TS_INPUT_CAPABILITYSET
{
    ushort capabilitySetType where value == TSCapsSetCapabilitySetType.CAPSTYPE_INPUT;
    ushort lengthCapability;
    TSInputCapabilitySetInputFlags inputFlags;
    ushort pad2octetsA;
    uint keyboardLayout;
    KeyboardType keyboardType;
    uint keyboardSubType;
    uint keyboardFunctionKey;
    string imeFileName with BinaryEncoding{TextEncoding = TextEncoding.Unicode, Length = 32};

    override string ToString()
    {
        return "TS_INPUT_CAPABILITYSET, " + EnumToString<TSInputCapabilitySetInputFlags>(inputFlags);
    }
}

// pattern of section 2.2.7.1.7
pattern TSBrushCapabilitySetBrushSupportLevel = enum uint
{
    BRUSH_DEFAULT = 0x00000000,
    BRUSH_COLOR_8x8 = 0x00000001,
    BRUSH_COLOR_FULL = 0x00000002,
    ...
};

// 2.2.7.1.7   Brush Capability Set (TS_BRUSH_CAPABILITYSET)
type TS_BRUSH_CAPABILITYSET
{
    ushort capabilitySetType where value == TSCapsSetCapabilitySetType.CAPSTYPE_BRUSH;
    ushort lengthCapability;
    TSBrushCapabilitySetBrushSupportLevel brushSupportLevel;

    override string ToString()
    {
        return "TS_BRUSH_CAPABILITYSET, " + EnumToString<TSBrushCapabilitySetBrushSupportLevel>(brushSupportLevel);
    }
}

// pattern of section 2.2.7.1.8
pattern TSGlyphCacheCapabilitySetGlyphSupportLevel = enum ushort
{
    GLYPH_SUPPORT_NONE = 0x0000,
    GLYPH_SUPPORT_PARTIAL = 0x0001,
    GLYPH_SUPPORT_FULL = 0x0002,
    GLYPH_SUPPORT_ENCODE = 0x0003,
    ...
};

// 2.2.7.1.8   Glyph Cache Capability Set (TS_GLYPHCACHE_CAPABILITYSET)
type TS_GLYPHCACHE_CAPABILITYSET
{
    ushort capabilitySetType where value == TSCapsSetCapabilitySetType.CAPSTYPE_GLYPHCACHE;
    ushort lengthCapability;
    array<TS_CACHE_DEFINITION> GlyphCache with BinaryEncoding{Length = 10};
    uint FragCache;
    TSGlyphCacheCapabilitySetGlyphSupportLevel GlyphSupportLevel;
    ushort pad2octets;

    override string ToString()
    {
        return "TS_GLYPHCACHE_CAPABILITYSET, " + 
            EnumToString<TSGlyphCacheCapabilitySetGlyphSupportLevel>(GlyphSupportLevel);
    }
}

type TS_CACHE_DEFINITION
{
    ushort CacheEntries;
    ushort CacheMaximumCellSize;

    override string ToString()
    {
        return "CacheEntries: " + CacheEntries.ToString() + 
            ", CacheMaximumCellSize: " + CacheMaximumCellSize.ToString();
    }
}

// pattern of section 2.2.7.1.9
pattern TSOffscreenCapabilitySetOffscreenSupportLevel = enum uint
{
    FALSE = 0x00000000,
    TRUE = 0x00000001,
    ...
};

// 2.2.7.1.9   Offscreen Bitmap Cache Capability Set (TS_OFFSCREEN_CAPABILITYSET)
type TS_OFFSCREEN_CAPABILITYSET
{
    ushort capabilitySetType where value == TSCapsSetCapabilitySetType.CAPSTYPE_OFFSCREENCACHE;
    ushort lengthCapability;
    TSOffscreenCapabilitySetOffscreenSupportLevel offscreenSupportLevel;
    ushort offscreenCacheSize;
    ushort offscreenCacheEntries;

    override string ToString()
    {
        return "TS_OFFSCREEN_CAPABILITYSET, TSOffscreenCapabilitySetOffscreenSupportLevel: " + 
            EnumToString<TSOffscreenCapabilitySetOffscreenSupportLevel>(offscreenSupportLevel);
    }
}

// pattern of section 2.2.7.1.10
pattern TSVirtualChannelCapabilitySetFlags = flags uint
{
    VCCAPS_NO_COMPR = 0x00000000
        with Documentation
            {Description = "Virtual channel compression is not supported."},
    VCCAPS_COMPR_SC = 0x00000001
        with Documentation
            {Description = "Indicates to the server that virtual channel compression is supported by the client for server-to-client traffic."},
    VCCAPS_COMPR_CS_8K = 0x00000002
        with Documentation
            {Description = "Indicates to the client that virtual channel compression is supported by the server for client-to-server traffic (the compression level is limited to RDP 4.0 bulk compression)."},
    ...
};

// 2.2.7.1.10   Virtual Channel Capability Set (TS_VIRTUALCHANNEL_CAPABILITYSET)
type TS_VIRTUALCHANNEL_CAPABILITYSET
{
    ushort capabilitySetType where value == TSCapsSetCapabilitySetType.CAPSTYPE_VIRTUALCHANNEL;
    ushort lengthCapability;
    TSVirtualChannelCapabilitySetFlags $"flags";
    optional [|lengthCapability > 8|] uint VCChunkSize;

    override string ToString()
    {
        return "TS_VIRTUALCHANNEL_CAPABILITYSET, flags: " + 
            EnumToString<TSOffscreenCapabilitySetOffscreenSupportLevel>($"flags");
    }
}

// pattern of section 2.2.7.1.11
pattern TSSoundCapabilitySetSoundFlags = flags ushort
{
    SOUND_BEEPS_FLAG = 0x0001
        with Documentation
            {Description = "Playing a beep sound is supported."},
    ...
};

// 2.2.7.1.11   Sound Capability Set (TS_SOUND_CAPABILITYSET)
type TS_SOUND_CAPABILITYSET
{
    ushort capabilitySetType where value == TSCapsSetCapabilitySetType.CAPSTYPE_SOUND;
    ushort lengthCapability;
    TSSoundCapabilitySetSoundFlags soundFlags;
    ushort pad2octetsA;

    override string ToString()
    {
        return "TS_SOUND_CAPABILITYSET" + 
            (soundFlags == TSSoundCapabilitySetSoundFlags.SOUND_BEEPS_FLAG ? ", Beep supported" : "");
    }
}

// 2.2.7.2   Optional Capability Sets
// 2.2.7.2.1   Bitmap Cache Host Support Capability Set (TS_BITMAPCACHE_HOSTSUPPORT_CAPABILITYSET)
type TS_BITMAPCACHE_HOSTSUPPORT_CAPABILITYSET
{
    ushort capabilitySetType where value == TSCapsSetCapabilitySetType.CAPSTYPE_BITMAPCACHE_HOSTSUPPORT;
    ushort lengthCapability;
    TSBitmapCacheHostSupportCapabilitySetCacheVersion cacheVersion 
        where ValidationCheckEnumValue(InRange<TSBitmapCacheHostSupportCapabilitySetCacheVersion>(value), 
        null, false, ReferenceType.Type, "RDPBCGR", "cacheVersion", 
        "TS_BITMAPCACHE_HOSTSUPPORT_CAPABILITYSET", "0x01", value);
    byte pad1;
    ushort pad2;

    override string ToString()
    {
        return "TS_BITMAPCACHE_HOSTSUPPORT_CAPABILITYSET";
    }
}

pattern TSBitmapCacheHostSupportCapabilitySetCacheVersion = enum byte
{
    TS_BITMAPCACHE_REV2 = 0x01,
    ...
};

// 2.2.7.2.2   Control Capability Set (TS_CONTROL_CAPABILITYSET)
type TS_CONTROL_CAPABILITYSET
{
    ushort capabilitySetType where value == TSCapsSetCapabilitySetType.CAPSTYPE_CONTROL;
    ushort lengthCapability;
    ushort controlFlags
        where ValidationCheckZero(value == 0x0, null, false, 
        ReferenceType.Type, "RDPBCGR", "controlFlags", 
        "TS_CONTROL_CAPABILITYSET", value);
    TrueFalseUshort remoteDetachFlag
        where ValidationCheckZero(value == 0x0, null, false, 
        ReferenceType.Type, "RDPBCGR", "remoteDetachFlag", 
        "TS_CONTROL_CAPABILITYSET", value);
    TSControlCapabilitySetInterest controlInterest
        where ValidationCheckValue(value == 0x0002, null, false, 
        ReferenceType.Type, "RDPBCGR", "controlInterest", 
        "TS_CONTROL_CAPABILITYSET", "0x0002", value);
    TSControlCapabilitySetInterest detachInterest
        where ValidationCheckValue(value == 0x0002, null, false, 
        ReferenceType.Type, "RDPBCGR", "detachInterest", 
        "TS_CONTROL_CAPABILITYSET", "0x0002", value);

    override string ToString()
    {
        return "TS_CONTROL_CAPABILITYSET";
    }
}

pattern TSControlCapabilitySetInterest = enum ushort
{
    CONTROLPRIORITY_NEVER = 0x0002,
    ...
};

// 2.2.7.2.3   Window Activation Capability Set (TS_WINDOWACTIVATION_CAPABILITYSET)
type TS_WINDOWACTIVATION_CAPABILITYSET
{
    ushort capabilitySetType where value == TSCapsSetCapabilitySetType.CAPSTYPE_ACTIVATION;
    ushort lengthCapability;
    TrueFalseUshort helpKeyFlag
        where ValidationCheckZero(value == 0x0, null, false, 
        ReferenceType.Type, "RDPBCGR", "helpKeyFlag", 
        "TS_WINDOWACTIVATION_CAPABILITYSET", value);
    TrueFalseUshort helpKeyIndexFlag
        where ValidationCheckZero(value == 0x0, null, false, 
        ReferenceType.Type, "RDPBCGR", "helpKeyIndexFlag", 
        "TS_WINDOWACTIVATION_CAPABILITYSET", value);
    TrueFalseUshort helpExtendedKeyFlag
        where ValidationCheckZero(value == 0x0, null, false, 
        ReferenceType.Type, "RDPBCGR", "helpExtendedKeyFlag", 
        "TS_WINDOWACTIVATION_CAPABILITYSET", value);
    TrueFalseUshort windowManagerKeyFlag
        where ValidationCheckZero(value == 0x0, null, false, 
        ReferenceType.Type, "RDPBCGR", "windowManagerKeyFlag", 
        "TS_WINDOWACTIVATION_CAPABILITYSET", value);

    override string ToString()
    {
        return "TS_WINDOWACTIVATION_CAPABILITYSET";
    }
}

// 2.2.7.2.4   Share Capability Set (TS_SHARE_CAPABILITYSET)
type TS_SHARE_CAPABILITYSET
{
    ushort capabilitySetType where value == TSCapsSetCapabilitySetType.CAPSTYPE_SHARE;
    ushort lengthCapability;
    ushort nodeId;
    ushort pad2octets;

    override string ToString()
    {
        return "TS_SHARE_CAPABILITYSET";
    }
}

// 2.2.7.2.5   Font Capability Set (TS_FONT_CAPABILITYSET)
type TS_FONT_CAPABILITYSET
{
    ushort capabilitySetType where value == TSCapsSetCapabilitySetType.CAPSTYPE_FONT;
    ushort lengthCapability where value == 8;
    FontCapabilitySetFontSupportFlags fontSupportFlags
        where ValidationCheckValue(value == 0x0001, null, false, 
        ReferenceType.Type, "RDPBCGR", "fontSupportFlags", 
        "TS_FONT_CAPABILITYSET", "0x0001", value);
    ushort pad2octets;

    override string ToString()
    {
        return "TS_FONT_CAPABILITYSET";
    }
}

pattern FontCapabilitySetFontSupportFlags = enum ushort
{
    FONTSUPPORT_FONTLIST = 0x0001,
    ...
};

// 2.2.7.2.6   Multifragment Update Capability Set (TS_MULTIFRAGMENTUPDATE_CAPABILITYSET)
type TS_MULTIFRAGMENTUPDATE_CAPABILITYSET
{
    ushort capabilitySetType where value == TSCapsSetCapabilitySetType.CAPSETTYPE_MULTIFRAGMENTUPDATE;
    ushort lengthCapability;
    uint MaxRequestSize;

    override string ToString()
    {
        return "TS_MULTIFRAGMENTUPDATE_CAPABILITYSET, MaxRequestSize: " + MaxRequestSize.ToString();
    }
}

// pattern of section 2.2.7.2.7
pattern TSLargePointerCapabilitySetLargePointerSupportFlags = flags ushort
{
    LARGE_POINTER_FLAG_96x96 = 0x0001
        with Documentation
            {Description = "96-pixel by 96-pixel mouse pointer shapes are supported."},
    LARGE_POINTER_FLAG_384x384 = 0x0002
        with Documentation
            {Description = "384-pixel by 384-pixel mouse pointer shapes and the Fast-Path Large Pointer Update are supported."},
    ...
};

// 2.2.7.2.7   Large Pointer Capability Set (TS_LARGE_POINTER_CAPABILITYSET)
type TS_LARGE_POINTER_CAPABILITYSET
{
    ushort capabilitySetType where value == TSCapsSetCapabilitySetType.CAPSETTYPE_LARGE_POINTER;
    ushort lengthCapability;
    TSLargePointerCapabilitySetLargePointerSupportFlags largePointerSupportFlags;

    override string ToString()
    {
        return "TS_LARGE_POINTER_CAPABILITYSET" + 
            (largePointerSupportFlags == 
            TSLargePointerCapabilitySetLargePointerSupportFlags.LARGE_POINTER_FLAG_96x96 ? 
            ", Large Pointer supported" : "");
    }
}

// pattern of section 2.2.7.2.8
pattern TSCompdeskCapabilitySetCompDeskSupportLevel = enum ushort
{
    COMPDESK_NOT_SUPPORTED = 0x0000,
    COMPDESK_SUPPORTED = 0x0001,
    ...
};

// 2.2.7.2.8   Desktop Composition Capability Set (TS_COMPDESK_CAPABILITYSET)
type TS_COMPDESK_CAPABILITYSET
{
    ushort capabilitySetType where value == TSCapsSetCapabilitySetType.CAPSETTYPE_COMPDESK;
    ushort lengthCapability;
    TSCompdeskCapabilitySetCompDeskSupportLevel CompDeskSupportLevel;

    override string ToString()
    {
        return "TS_COMPDESK_CAPABILITYSET, " + EnumToString<TSCompdeskCapabilitySetCompDeskSupportLevel>(CompDeskSupportLevel);
    }
}

// pattern of section 2.2.7.2.9
pattern TSSurfCmdsCapabilitySetCmdFlags = flags uint
{
    SURFCMDS_SETSURFACEBITS = 0x00000002
        with Documentation
            {Description = "The Set Surface Bits Command is supported."},
    SURFCMDS_FRAMEMARKER = 0x00000010
        with Documentation
            {Description = "The Frame Marker Command is supported."},
    SURFCMDS_STREAMSURFACEBITS = 0x00000040
        with Documentation
            {Description = "The Stream Surface Bits Command is supported."},
    ...
};

// 2.2.7.2.9   Surface Commands Capability Set (TS_SURFCMDS_CAPABILITYSET)
type TS_SURFCMDS_CAPABILITYSET
{
    ushort capabilitySetType where value == TSCapsSetCapabilitySetType.CAPSETTYPE_SURFACE_COMMANDS;
    ushort lengthCapability;
    TSSurfCmdsCapabilitySetCmdFlags cmdFlags;
    uint reserved where ValidationCheckReservedZero(value == 0, null, true, 
        ReferenceType.Type, "RDPBCGR", "reserved", "TS_SURFCMDS_CAPABILITYSET", value);

    override string ToString()
    {
        return "TS_SURFCMDS_CAPABILITYSET, " + EnumToString<TSSurfCmdsCapabilitySetCmdFlags>(cmdFlags);
    }
}

// 2.2.7.2.10   Bitmap Codecs Capability Set (TS_BITMAPCODECS_CAPABILITYSET)
type TS_BITMAPCODECS_CAPABILITYSET
{
    ushort capabilitySetType where value == TSCapsSetCapabilitySetType.CAPSETTYPE_BITMAP_CODECS;
    ushort lengthCapability;
    TS_BITMAPCODECS supportedBitmapCodecs;

    override string ToString()
    {
        return "TS_BITMAPCODECS_CAPABILITYSET, " + supportedBitmapCodecs.ToString();
    }
}

// 2.2.7.2.10.1   Bitmap Codecs (TS_BITMAPCODECS)
type TS_BITMAPCODECS
{
    byte bitmapCodecCount;
    array<TS_BITMAPCODEC> bitmapCodecArray with BinaryEncoding{Length = bitmapCodecCount};

    override string ToString()
    {
        return bitmapCodecArray.ToString();
    }
}

// 2.2.7.2.10.1.1   Bitmap Codec (TS_BITMAPCODEC)
type IgnoredCodecProperties[ushort CodecPropertiesLength]
{ 
    binary Data with BinaryEncoding{Length = CodecPropertiesLength};
}

type TS_BITMAPCODEC
{
    guid codecGUID;
    byte codecID;
    ushort codecPropertiesLength;
    ([|codecGUID == CODEC_GUID_NSCODEC|] RDPNSC.TS_NSCODEC_CAPABILITYSET | 
     [|codecGUID == CODEC_GUID_IGNORE|] IgnoredCodecProperties[codecPropertiesLength] | 
     [|(codecGUID == CODEC_GUID_REMOTEFX || codecGUID == CODEC_GUID_IMAGE_REMOTEFX)|] (binary | any)
     ) codecProperties with BinaryEncoding{Length = codecPropertiesLength};

    override string ToString()
    {
        return "TS_BITMAPCODEC, codecID: " + codecGUID.ToString();
    }
}

// 2.2.8.1.1.1.1   Share Control Header (TS_SHARECONTROLHEADER)
type TS_SHARECONTROLHEADER
{
    ushort totalLength;
    TSShareControlHeaderPduType pduType;
    ushort PDUSource;
}

type TSShareControlHeaderPduType
{
    TSShareControlHeaderPduTypePDUVersion PDUVersion 
        where ValidationCheckValue(value == 0x1, null, true, 
        ReferenceType.Type, "RDPBCGR", "PDUVersion", "TSShareControlHeaderPduType", "0x1", value)
        with BinaryEncoding{Width = 12, Endian = Endian.Big};
    TSShareControlHeaderPduTypeType $"type" with BinaryEncoding{Endian = Endian.Big, Width = 4};
}with BinaryEncoding{Endian = Endian.Little, WidthForComposedType = 16, DecodeAsUnit = true};

pattern TSShareControlHeaderPduTypePDUVersion = enum ushort
{
    TS_PROTOCOL_VERSION = 0x1,
    ...
};

pattern TSShareControlHeaderPduTypeType = enum byte
{
    PDUTYPE_DEMANDACTIVEPDU = 0x1,
    PDUTYPE_CONFIRMACTIVEPDU = 0x3,
    PDUTYPE_DEACTIVATEALLPDU = 0x6,
    PDUTYPE_DATAPDU = 0x7,
    PDUTYPE_SERVER_REDIR_PKT = 0xA,
    ...
};

// 2.2.8.1.1.1.2   Share Data Header (TS_SHAREDATAHEADER)
type TS_SHAREDATAHEADER
{
    TS_SHARECONTROLHEADER shareControlHeader;
    uint shareId;
    byte pad1;
    TSShareDataHeaderStreamId streamId;
    ushort uncompressedLength;
    TSShareControlHeaderPduType2Type pduType2;
    TSShareDataHeaderCompressedType compressedType;
    ushort compressedLength;
}

pattern TSShareDataHeaderStreamId = enum byte
{
    STREAM_UNDEFINED = 0x00,
    STREAM_LOW = 0x01,
    STREAM_MED = 0x02,
    STREAM_HI = 0x04,
    ...
};

pattern TSShareControlHeaderPduType2Type = enum byte
{
    PDUTYPE2_UPDATE = 0x02,
    PDUTYPE2_CONTROL = 0x14,
    PDUTYPE2_POINTER = 0x1B,
    PDUTYPE2_INPUT = 0x1C,
    PDUTYPE2_SYNCHRONIZE = 0x1F,
    PDUTYPE2_REFRESH_RECT = 0x21,
    PDUTYPE2_PLAY_SOUND = 0x22,
    PDUTYPE2_SUPPRESS_OUTPUT = 0x23,
    PDUTYPE2_SHUTDOWN_REQUEST = 0x24,
    PDUTYPE2_SHUTDOWN_DENIED = 0x25,
    PDUTYPE2_SAVE_SESSION_INFO = 0x26,
    PDUTYPE2_FONTLIST = 0x27,
    PDUTYPE2_FONTMAP = 0x28,
    PDUTYPE2_SET_KEYBOARD_INDICATORS = 0x29,
    PDUTYPE2_BITMAPCACHE_PERSISTENT_LIST = 0x2B,
    PDUTYPE2_BITMAPCACHE_ERROR_PDU = 0x2C,
    PDUTYPE2_SET_KEYBOARD_IME_STATUS = 0x2D,
    PDUTYPE2_OFFSCRCACHE_ERROR_PDU = 0x2E,
    PDUTYPE2_SET_ERROR_INFO_PDU = 0x2F,
    PDUTYPE2_DRAWNINEGRID_ERROR_PDU = 0x30,
    PDUTYPE2_DRAWGDIPLUS_ERROR_PDU = 0x31,
    PDUTYPE2_ARC_STATUS_PDU = 0x32,
    PDUTYPE2_STATUS_INFO_PDU = 0x36,
    PDUTYPE2_MONITOR_LAYOUT_PDU = 0x37,
    ...
};

// flags pattern
pattern TSShareDataHeaderCompressedFlags = flags byte
{
    PACKET_COMPRESSED = 0x2
        with Documentation
            {Description = "The payload data is compressed."},
    PACKET_AT_FRONT = 0x4
        with Documentation
            {Description = "The decompressed packet MUST be placed at the beginning of the history buffer."},
    PACKET_FLUSHED = 0x8
        with Documentation
            {Description = "The decompressor MUST reinitialize the history buffer (by filling it with zeros) and reset the HistoryOffset to zero."},
    ...
};

type TSShareDataHeaderCompressedType
{
    TSShareDataHeaderCompressedFlags compressedFlags with BinaryEncoding{Width = 4};
    TSShareDataHeaderCompressionTypeMask CompressionTypeMask with BinaryEncoding{Width = 4};
}

pattern TSShareDataHeaderCompressionTypeMask = enum byte
{
    PACKET_COMPR_TYPE_8K = 0x0,
    PACKET_COMPR_TYPE_64K = 0x1,
    PACKET_COMPR_TYPE_RDP6 = 0x2,
    PACKET_COMPR_TYPE_RDP61 = 0x3,
    ...
};

// 2.2.8.1.1.2.1   Basic (TS_SECURITY_HEADER)
type TS_SECURITY_HEADER
{
    TSSecurityHeaderFlags $"flags";
    ushort flagsHi;
}

pattern TSSecurityHeaderFlags = flags ushort
 {
    SEC_EXCHANGE_PKT = 0x0001
        with Documentation
            {Description = "The packet is a Security Exchange PDU."},
    SEC_TRANSPORT_REQ = 0x0002
        with Documentation
            {Description = "The packet is an Initiate Multitransport Request PDU."},
    RDP_SEC_TRANSPORT_RSP = 0x0004
        with Documentation
            {Description = "The packet is an Initiate Multitransport Response PDU."},
    SEC_ENCRYPT = 0x0008
        with Documentation
            {Description = "The packet is encrypted."},
    SEC_RESET_SEQNO = 0x0010
        with Documentation
            {Description = "This flag is not processed by any RDP clients or servers and MUST be ignored."},
    SEC_IGNORE_SEQNO = 0x0020
        with Documentation
            {Description = "This flag is not processed by any RDP clients or servers and MUST be ignored."},
    SEC_INFO_PKT = 0x0040
        with Documentation
            {Description = "The packet is a Client Info PDU."},
    SEC_LICENSE_PKT = 0x0080
        with Documentation
            {Description = "The packet is a Licensing PDU."},
    SEC_LICENSE_ENCRYPT_CS = 0x0100
        with Documentation
            {Description = "Indicates to the client that the server is capable of processing encrypted licensing packets."},
    SEC_LICENSE_ENCRYPT_SC = 0x0200
        with Documentation
            {Description = "Indicates to the server that the client is capable of processing encrypted licensing packets."},
    SEC_REDIRECTION_PKT = 0x0400
        with Documentation
            {Description = "The packet is a Standard Security Server Redirection PDU and that the PDU is encrypted."},
    SEC_SECURE_CHECKSUM = 0x0800
        with Documentation
            {Description = "The MAC for the PDU was generated using the \"salted MAC generation\" technique."},
    SEC_AUTODETECT_REQ = 0x1000
        with Documentation
            {Description = "The packet is an Auto-Detect Request PDU."},
    SEC_AUTODETECT_RSP = 0x2000
        with Documentation
            {Description = "The packet is an Auto-Detect Response PDU."},
    SEC_HEARTBEAT = 0x4000
        with Documentation
            {Description = "The packet is a Heartbeat PDU."},
    SEC_FLAGSHI_VALID = 0x8000
        with Documentation
            {Description = "The flagsHi field contains valid data."},
    ...
};

// 2.2.8.1.1.2.2   Non-FIPS (TS_SECURITY_HEADER1)
type TS_SECURITY_HEADER1
{
    TSSecurityHeaderFlags $"flags";
    ushort flagsHi;
    ulong dataSignature;
}

// 2.2.8.1.1.2.3   FIPS (TS_SECURITY_HEADER2)
type TS_SECURITY_HEADER2
{
    TSSecurityHeaderFlags $"flags";
    ushort flagsHi;
    ushort length where ValidationCheckValue(value == 0x0010, null, true, 
        ReferenceType.Type, "RDPBCGR", "length", "TS_SECURITY_HEADER2", "0x0010", value);
    TsSecurityHeader2Version version where ValidationCheckValue(value == 0x01, null, true, 
        ReferenceType.Type, "RDPBCGR", "version", 
        "TS_SECURITY_HEADER2", "0x01", value);
    byte padlen;
    ulong dataSignature;
}

pattern TsSecurityHeader2Version = enum byte
{
    TSFIPS_VERSION1 = 0x01,
    ...
};

// 2.2.8.1.1.3   Client Input Event PDU (TS_INPUT_PDU)
message TS_INPUT_PDU[TSUDSCSec1EncryptionLevel EncryptionLevel, TSUDSCSec1EncryptionMethod EncryptionMethod]
{
    optional (
              ([|EncryptionMethod in {TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_40BIT,
                                      TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_128BIT,
                                      TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_56BIT}|] TS_SECURITY_HEADER1) |
              ([|(EncryptionMethod == TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_FIPS)|] TS_SECURITY_HEADER2)
             ) securityHeader;

    TS_INPUT_PDU_DATA clientInputEventData;
            
    override string ToString()
    {
        string summary = "Client Input Event PDU, numEvents: " + clientInputEventData.numEvents.ToString();
        int cnt = 0;
        foreach (var inpdu in clientInputEventData.slowPathInputEvents)
        {
            if (cnt == 0)
            {
                summary += ", TS_INPUT_EVENT: ";
                if (clientInputEventData.slowPathInputEvents.Count > 1)
                {
                    summary += "[";
                }
            }
            else if (cnt > 4)
            {
                summary += " ...";
                break;
            }
            else
            {
                summary += ", ";
            }
            summary += EnumToStringInSummary<RDPBCGR.TSInputEventMessageType>(inpdu.messageType);
            cnt++;
        }
        if (cnt > 1)
        {
            summary += "]";
        }
        return summary;
    }
}

// 2.2.8.1.1.3.1   Client Input Event PDU Data (TS_INPUT_PDU_DATA)
type TS_INPUT_PDU_DATA
{
    TS_SHAREDATAHEADER shareDataHeader;
    ushort numEvents;
    ushort pad2Octets;
    array<TS_INPUT_EVENT> slowPathInputEvents with BinaryEncoding{Length = numEvents};
}

// 2.2.8.1.1.3.1.1   Slow-Path Input Event (TS_INPUT_EVENT)
type TS_INPUT_EVENT
{
    uint eventTime;
    TSInputEventMessageType messageType;
    ([|messageType == TSInputEventMessageType.INPUT_EVENT_SCANCODE|] TS_KEYBOARD_EVENT | 
    [|messageType == TSInputEventMessageType.INPUT_EVENT_UNICODE|] TS_UNICODE_KEYBOARD_EVENT | 
    [|messageType == TSInputEventMessageType.INPUT_EVENT_MOUSE|] TS_POINTER_EVENT | 
    [|messageType == TSInputEventMessageType.INPUT_EVENT_MOUSEX|] TS_POINTERX_EVENT | 
    [|messageType == TSInputEventMessageType.INPUT_EVENT_SYNC|] TS_SYNC_EVENT | 
    [|messageType == TSInputEventMessageType.INPUT_EVENT_UNUSED|] TS_UNUSED_EVENT) slowPathInputData;

    override string ToString()
    {
        return EnumToString<TSInputEventMessageType>(messageType);
    }
}

pattern TSInputEventMessageType = enum ushort
{
    INPUT_EVENT_SYNC = 0x0000,
    INPUT_EVENT_UNUSED = 0x0002,
    INPUT_EVENT_SCANCODE = 0x0004,
    INPUT_EVENT_UNICODE = 0x0005,
    INPUT_EVENT_MOUSE = 0x8001,
    INPUT_EVENT_MOUSEX = 0x8002,
    ...
};

// 2.2.8.1.1.3.1.1.1   Keyboard Event (TS_KEYBOARD_EVENT)
type TS_KEYBOARD_EVENT
{
    TSKeyboadrEventkeyboardFlags keyboardFlags;
    ushort keyCode;
    ushort pad2Octets;
}

pattern TSKeyboadrEventkeyboardFlags = flags ushort
{
    KBDFLAGS_EXTENDED = 0x0100
        with Documentation
            {Description = "The keystroke message contains an extended scancode."},
    KBDFLAGS_EXTENDED1 = 0x0200
        with Documentation
            {Description = "Used to send keyboard events triggered by the PAUSE key."},
    KBDFLAGS_DOWN = 0x4000
        with Documentation
            {Description = "The key was down prior to this event."},
    KBDFLAGS_RELEASE = 0x8000
        with Documentation
            {Description = "The absence of this flag indicates a key-down event, while its presence indicates a key-release event."},
    ...
};

// 2.2.8.1.1.3.1.1.2   Unicode Keyboard Event (TS_UNICODE_KEYBOARD_EVENT)
type TS_UNICODE_KEYBOARD_EVENT
{
    TSUnicodeKeyboadrEventkeyboardFlags keyboardFlags;
    ushort unicodeCode;
    ushort pad2Octets;
}

pattern TSUnicodeKeyboadrEventkeyboardFlags = flags ushort
{
    KBDFLAGS_RELEASE = 0x8000
        with Documentation
            {Description = "The absence of this flag indicates a key-down event, whereas its presence indicates a key-release event."},
    ...
};

// 2.2.8.1.1.3.1.1.3   Mouse Event (TS_POINTER_EVENT)
type TS_POINTER_EVENT
{
    TSPointerEventPointerFlags pointerFlags;
    ushort xPos;
    ushort yPos;
}

type TSPointerEventPointerFlags
{
    TSPointerEventPointerFlagsPart PointerFlags;
    byte WheelRotationMask; // 0x01FF in TD, but 0x0100 is the PTRFLAGS_WHEEL_NEGATIVE, means WheelRotationMask is a negative value

    override string ToString()
    {
        return EnumToString<TSPointerEventPointerFlagsPart>(PointerFlags);
    }
}with BinaryEncoding{Endian = Endian.Little, WidthForComposedType = 16, DecodeAsUnit = true};

pattern TSPointerEventPointerFlagsPart = flags byte
{
    PTRFLAGS_HWHEEL = 0x04
        with Documentation
            {Description = "The event is a horizontal mouse wheel rotation."},
    PTRFLAGS_WHEEL = 0x02
        with Documentation
            {Description = "The event is a vertical mouse wheel rotation."},
    PTRFLAGS_WHEEL_NEGATIVE = 0x01
        with Documentation
            {Description = "The wheel rotation value (contained in the WheelRotationMask bit field) is negative and MUST be sign-extended before injection at the server."},
    PTRFLAGS_MOVE = 0x08
        with Documentation
            {Description = "The mouse position MUST be updated to the location specified by the xPos and yPos fields."},
    PTRFLAGS_DOWN = 0x80
        with Documentation
            {Description = "A click event has occurred at the position specified by the xPos and yPos fields."},
    PTRFLAGS_BUTTON1 = 0x10
        with Documentation
            {Description = "Mouse button 1 (left button) was clicked or released."},
    PTRFLAGS_BUTTON2 = 0x20
        with Documentation
            {Description = "Mouse button 2 (right button) was clicked or released."},
    PTRFLAGS_BUTTON3 = 0x40
        with Documentation
            {Description = "Mouse button 3 (middle button or wheel) was clicked or released."},
    ...
};

// 2.2.8.1.1.3.1.1.4   Extended Mouse Event (TS_POINTERX_EVENT)
type TS_POINTERX_EVENT
{
    TSPointerXEventPointerFlags pointerFlags;
    ushort xPos;
    ushort yPos;
}

pattern TSPointerXEventPointerFlags = flags ushort 
{
    PTRXFLAGS_DOWN = 0x8000
        with Documentation
            {Description = "A click event has occurred at the position specified by the xPos and yPos fields."},
    PTRXFLAGS_BUTTON1 = 0x1000
        with Documentation
            {Description = "Extended mouse button 1 (also referred to as button 4) was clicked or released."},
    PTRXFLAGS_BUTTON2 = 0x2000
        with Documentation
            {Description = "Extended mouse button 2 (also referred to as button 5) was clicked or released."},
    ...
};

// 2.2.8.1.1.3.1.1.5   Synchronize Event (TS_SYNC_EVENT)
type TS_SYNC_EVENT
{
    ushort pad2Octets;
    TSSyncEventToggleFlags toggleFlags;
}

pattern TSSyncEventToggleFlags = flags uint
{
    TS_SYNC_SCROLL_LOCK = 0x00000001
        with Documentation
            {Description = "The Scroll Lock indicator light SHOULD be on."},
    TS_SYNC_NUM_LOCK = 0x00000002
        with Documentation
            {Description = "The Num Lock indicator light SHOULD be on."},
    TS_SYNC_CAPS_LOCK = 0x00000004
        with Documentation
            {Description = "The Caps Lock indicator light SHOULD be on."},
    TS_SYNC_KANA_LOCK = 0x00000008
        with Documentation
            {Description = "The Kana Lock indicator light SHOULD be on."},
    ...
};

// 2.2.8.1.1.3.1.1.6   Unused Event (TS_UNUSED_EVENT)
type TS_UNUSED_EVENT
{
    uint pad4Octets;
    ushort pad2Octets;
}

// 2.2.8.1.2   Client Fast-Path Input Event PDU (TS_FP_INPUT_PDU)
message TS_FP_INPUT_PDU
{
    TSFPInputPduInputHeader fpInputHeader;
    byte length1;
    optional ([|(length1 & 0x80) == 0x80|] byte) length2;
    optional TS_FP_FIPS_INFO fipsInformation;
    optional ([|(fpInputHeader.secFlags & TSFPInputPduInputHeaderSecurityFlags.FAST_PATH_INPUT_ENCRYPTED) == 
        TSFPInputPduInputHeaderSecurityFlags.FAST_PATH_INPUT_ENCRYPTED|] ulong) dataSignature;
    optional ([|((fpInputHeader.secFlags & TSFPInputPduInputHeaderSecurityFlags.FAST_PATH_INPUT_ENCRYPTED) == 0) && 
        (fpInputHeader.numEvents == 0)|] byte) numEvents;
    optional ([|(fpInputHeader.secFlags & TSFPInputPduInputHeaderSecurityFlags.FAST_PATH_INPUT_ENCRYPTED) == 
        TSFPInputPduInputHeaderSecurityFlags.FAST_PATH_INPUT_ENCRYPTED|] binary) EncryptedData;
    optional ([|(fpInputHeader.secFlags & TSFPInputPduInputHeaderSecurityFlags.FAST_PATH_INPUT_ENCRYPTED) == 0|] 
        array<TS_FP_INPUT_EVENT>) fpInputEvents;
           
    override string ToString()
    {
        string summary = "Client Fast-Path Input Event PDU";
        if ((fpInputHeader.secFlags & TSFPInputPduInputHeaderSecurityFlags.FAST_PATH_INPUT_ENCRYPTED) == 
            TSFPInputPduInputHeaderSecurityFlags.FAST_PATH_INPUT_ENCRYPTED)
        {
            summary += ", Encrypted";
        }
        else
        {
            if (numEvents != nothing)
            {
                summary += ", numEvents: " + numEvents.ToString();
                if ((numEvents as uint) > 0 && (fpInputEvents is inputEventsArr:array<TS_FP_INPUT_EVENT>))
                {
                    summary += ", fpInputEvents: ";
                    if (inputEventsArr.Count > 1)
                    {
                        summary += "[";
                    }
                    int cnt = 0;
                    foreach (var e in inputEventsArr)
                    {
                        if (cnt > 4)
                        {
                            summary += " ...";
                            break;
                        }
                        else if (cnt > 0)
                        {
                            summary += ", ";
                        }
                        if (e is TS_FP_KEYBOARD_EVENT)
                        {
                            summary += "TS_FP_KEYBOARD_EVENT";
                        }
                        else if (e is TS_FP_UNICODE_KEYBOARD_EVENT)
                        {
                            summary += "TS_FP_UNICODE_KEYBOARD_EVENT";
                        }
                        else if (e is TS_FP_POINTER_EVENT)
                        {
                            summary += "TS_FP_POINTER_EVENT";
                        }
                        else if (e is TS_FP_POINTERX_EVENT)
                        {
                            summary += "TS_FP_POINTERX_EVENT";
                        }
                        else if (e is TS_FP_SYNC_EVENT)
                        {
                            summary += "TS_FP_SYNC_EVENT";
                        }
                        cnt++;
                    }
                    if (cnt > 1)
                    {
                        summary += "]";
                    }
                }
            }
        }
        int length = (length2 is l:byte) ? ((((length1 & 0x7F) as ushort) << 8) | (l as ushort)) : length1;
        return summary + ", Length: " + length.ToString();
    }
}

type TSFPInputPduInputHeader
{
    TSFPInputPduInputHeaderSecurityFlags secFlags with BinaryEncoding{Width = 2};
    byte numEvents with BinaryEncoding{Width = 4};
    TSFPInputPduInputHeaderAction action with BinaryEncoding{Width = 2};
}

pattern TSFPInputPduInputHeaderAction = enum byte
{
    FASTPATH_INPUT_ACTION_FASTPATH = 0x0,
    FASTPATH_INPUT_ACTION_X224 = 0x3,
    ...
};

pattern TSFPInputPduInputHeaderSecurityFlags = flags byte
{
    FASTPATH_INPUT_SECURE_CHECKSUM = 0x1
        with Documentation
            {Description = "The MAC signature for the PDU was generated using the \"salted MAC generation\" technique."},
    FAST_PATH_INPUT_ENCRYPTED = 0x2
        with Documentation
            {Description = "The PDU contains an 8-byte MAC signature after the optional length2 field and the contents of the PDU are encrypted using the negotiated encryption package."},
    ...
};

// 2.2.8.1.2.1   Fast-Path FIPS Information (TS_FP_FIPS_INFO)
type TS_FP_FIPS_INFO
{
    ushort length where value == 0x0010;
    TsSecurityHeader2Version version where ValidationCheckValue(value == 0x01, null, true, 
        ReferenceType.Type, "RDPBCGR", "version", "TS_FP_FIPS_INFO", "0x01", value);
    byte padlen;
}

// 2.2.8.1.2.2   Fast-Path Input Event (TS_FP_INPUT_EVENT)
pattern TS_FP_INPUT_EVENT = [|RemainingBitLength(stream) >= 8|]
(
    [|(CurrentByte(stream) >> 5) == TSFPInputEventEventHeaderEventCode.FASTPATH_INPUT_EVENT_SCANCODE|] TS_FP_KEYBOARD_EVENT |
    [|(CurrentByte(stream) >> 5) == TSFPInputEventEventHeaderEventCode.FASTPATH_INPUT_EVENT_UNICODE|] TS_FP_UNICODE_KEYBOARD_EVENT |
    [|(CurrentByte(stream) >> 5) == TSFPInputEventEventHeaderEventCode.FASTPATH_INPUT_EVENT_MOUSE|] TS_FP_POINTER_EVENT |
    [|(CurrentByte(stream) >> 5) == TSFPInputEventEventHeaderEventCode.FASTPATH_INPUT_EVENT_MOUSEX|] TS_FP_POINTERX_EVENT |
    [|(CurrentByte(stream) >> 5) == TSFPInputEventEventHeaderEventCode.FASTPATH_INPUT_EVENT_SYNC|] TS_FP_SYNC_EVENT
);

pattern TSFPInputEventEventHeaderEventCode = enum byte
{
    FASTPATH_INPUT_EVENT_SCANCODE = 0x0,
    FASTPATH_INPUT_EVENT_MOUSE = 0x1,
    FASTPATH_INPUT_EVENT_MOUSEX = 0x2,
    FASTPATH_INPUT_EVENT_SYNC = 0x3,
    FASTPATH_INPUT_EVENT_UNICODE = 0x4,
    FASTPATH_INPUT_EVENT_QOE_TIMESTAMP = 0x6,
    ...
};

type TSFPInputEventEventHeader
{
     TSFPInputEventEventHeaderEventCode eventCode with BinaryEncoding{Width = 3};
     ([|eventCode == TSFPInputEventEventHeaderEventCode.FASTPATH_INPUT_EVENT_SCANCODE|] TSFPKeyboardEventEventHeaderEventFlags | 
      [|eventCode == TSFPInputEventEventHeaderEventCode.FASTPATH_INPUT_EVENT_MOUSE|] byte | 
      [|eventCode == TSFPInputEventEventHeaderEventCode.FASTPATH_INPUT_EVENT_MOUSEX|] byte | 
      [|eventCode == TSFPInputEventEventHeaderEventCode.FASTPATH_INPUT_EVENT_SYNC|] TSFPSyncEventEventHeaderEventFlags | 
      [|eventCode == TSFPInputEventEventHeaderEventCode.FASTPATH_INPUT_EVENT_UNICODE|] TSFPUnicodeKeyboardEventEventHeaderEventFlags |
      [|eventCode == TSFPInputEventEventHeaderEventCode.FASTPATH_INPUT_EVENT_QOE_TIMESTAMP|] byte) 
        eventFlags with BinaryEncoding{Width = 5};
}

// 2.2.8.1.2.2.1   Fast-Path Keyboard Event (TS_FP_KEYBOARD_EVENT)
type TS_FP_KEYBOARD_EVENT
{
    TSFPInputEventEventHeader eventHeader 
        where value.eventCode == TSFPInputEventEventHeaderEventCode.FASTPATH_INPUT_EVENT_SCANCODE;
    byte keyCode;

    override string ToString()
    {
        return "TS_FP_KEYBOARD_EVENT, keyCode: " + keyCode.ToString();
    }
}

pattern TSFPKeyboardEventEventHeaderEventFlags = flags byte
{
    FASTPATH_INPUT_KBDFLAGS_RELEASE = 0x01
        with Documentation
            {Description = "The absence of this flag indicates a key-down event, while its presence indicates a key-release event."},
    FASTPATH_INPUT_KBDFLAGS_EXTENDED = 0x02
        with Documentation
            {Description = "The keystroke message contains an extended scancode."},
    FASTPATH_INPUT_KBDFLAGS_EXTENDED1 = 0x04
        with Documentation
            {Description = "Used to send keyboard events triggered by the PAUSE key."},
    ...
}with BinaryEncoding{Width = 5};

// 2.2.8.1.2.2.2   Fast-Path Unicode Keyboard Event (TS_FP_UNICODE_KEYBOARD_EVENT)
type TS_FP_UNICODE_KEYBOARD_EVENT
{
    TSFPInputEventEventHeader eventHeader 
        where value.eventCode == TSFPInputEventEventHeaderEventCode.FASTPATH_INPUT_EVENT_UNICODE;
    ushort unicodeCode;

    override string ToString()
    {
        return "TS_FP_UNICODE_KEYBOARD_EVENT, unicodeCode: " + unicodeCode.ToString();
    }
}

pattern TSFPUnicodeKeyboardEventEventHeaderEventFlags = flags byte
{
    FASTPATH_INPUT_KBDFLAGS_RELEASE = 0x01
        with Documentation
            {Description = "The absence of this flag indicates a key-down event, whereas its presence indicates a key-release event."},
    ...
}with BinaryEncoding{Width = 5};

// 2.2.8.1.2.2.3   Fast-Path Mouse Event (TS_FP_POINTER_EVENT)
type TS_FP_POINTER_EVENT
{
    TSFPInputEventEventHeader eventHeader 
        where value.eventCode == TSFPInputEventEventHeaderEventCode.FASTPATH_INPUT_EVENT_MOUSE;
    TSPointerEventPointerFlags pointerFlags;
    ushort xPos;
    ushort yPos;

    override string ToString()
    {
        return "TS_FP_POINTER_EVENT, " + pointerFlags.ToString() + ", (" + xPos.ToString() + ", " + yPos.ToString() + ")";
    }
}

// 2.2.8.1.2.2.4   Fast-Path Extended Mouse Event (TS_FP_POINTERX_EVENT)
type TS_FP_POINTERX_EVENT
{
    TSFPInputEventEventHeader eventHeader 
        where value.eventCode == TSFPInputEventEventHeaderEventCode.FASTPATH_INPUT_EVENT_MOUSEX;
    TSPointerEventPointerFlags pointerFlags;
    ushort xPos;
    ushort yPos;

    override string ToString()
    {
        return "TS_FP_POINTERX_EVENT, " + pointerFlags.ToString() + ", (" + xPos.ToString() + ", " + yPos.ToString() + ")";
    }
}

// 2.2.8.1.2.2.5   Fast-Path Synchronize Event (TS_FP_SYNC_EVENT)
type TS_FP_SYNC_EVENT
{
    TSFPInputEventEventHeader eventHeader where value.eventCode == TSFPInputEventEventHeaderEventCode.FASTPATH_INPUT_EVENT_SYNC;

    override string ToString()
    {
        return "TS_FP_SYNC_EVENT";
    }
}

pattern TSFPSyncEventEventHeaderEventFlags = flags byte
{
    FASTPATH_INPUT_SYNC_SCROLL_LOCK = 0x01
        with Documentation
            {Description = "The Scroll Lock indicator light SHOULD be on."},
    FASTPATH_INPUT_SYNC_NUM_LOCK = 0x02
        with Documentation
            {Description = "The Num Lock indicator light SHOULD be on."},
    FASTPATH_INPUT_SYNC_CAPS_LOCK = 0x04
        with Documentation
            {Description = "The Caps Lock indicator light SHOULD be on."},
    FASTPATH_INPUT_SYNC_KANA_LOCK = 0x08
        with Documentation
            {Description = "The Kana Lock indicator light SHOULD be on."},
    ...
}with BinaryEncoding{Width = 5};

// 2.2.8.1.2.2.6    Fast-Path Quality of Experience (QoE) Timestamp Event (TS_FP_QOETIMESTAMP_EVENT)
type TS_FP_QOETIMESTAMP_EVENT
{
    TSFPInputEventEventHeader eventHeader 
        where value.eventCode == TSFPInputEventEventHeaderEventCode.FASTPATH_INPUT_EVENT_QOE_TIMESTAMP;
    uint timestamp;

    override string ToString()
    {
        return "TS_FP_QOETIMESTAMP_EVENT";
    }
}

// 2.2.8.2.1   Server Set Keyboard Indicators PDU
message ServerSetKeyboardIndicatorsPdu[TSUDSCSec1EncryptionLevel EncryptionLevel, TSUDSCSec1EncryptionMethod EncryptionMethod]
{
    optional (
              ([|EncryptionLevel == TSUDSCSec1EncryptionLevel.ENCRYPTION_LEVEL_LOW|] TS_SECURITY_HEADER) |
              ([|EncryptionMethod in {TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_40BIT,
                                      TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_128BIT,
                                      TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_56BIT}|] TS_SECURITY_HEADER1) |
              ([|(EncryptionMethod == TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_FIPS)|] TS_SECURITY_HEADER2)
             ) securityHeader;
  
    TS_SET_KEYBOARD_INDICATORS_PDU setKeyBdIndicatorsPduData;
           
    override string ToString()
    {
        return "Server Set Keyboard Indicators PDU, LedFlags: " + 
            EnumToString(setKeyBdIndicatorsPduData.LedFlags, 
            "RDPBCGR.TSSetKeyboardIndicatorsPDULedFlags");
    }
}

// 2.2.8.2.1.1   Set Keyboard Indicators PDU Data (TS_SET_KEYBOARD_INDICATORS_PDU)
type TS_SET_KEYBOARD_INDICATORS_PDU
{
    TS_SHAREDATAHEADER shareDataHeader;
    ushort UnitId;
    TSSetKeyboardIndicatorsPDULedFlags LedFlags;
}

pattern TSSetKeyboardIndicatorsPDULedFlags = flags ushort
{
    TS_SYNC_SCROLL_LOCK = 0x0001
        with Documentation
            {Description = "The Scroll Lock indicator light SHOULD be on."},
    TS_SYNC_NUM_LOCK = 0x0002
        with Documentation
            {Description = "The Num Lock indicator light SHOULD be on."},
    TS_SYNC_CAPS_LOCK = 0x0004
        with Documentation
            {Description = "The Caps Lock indicator light SHOULD be on."},
    TS_SYNC_KANA_LOCK = 0x0008
        with Documentation
            {Description = "The Kana Lock indicator light SHOULD be on."},
    ...
};

// 2.2.8.2.2   Server Set Keyboard IME Status PDU
message ServerSetKeyboardIMEStatusPdu[TSUDSCSec1EncryptionLevel EncryptionLevel, TSUDSCSec1EncryptionMethod EncryptionMethod]
{
    optional (
              ([|EncryptionLevel == TSUDSCSec1EncryptionLevel.ENCRYPTION_LEVEL_LOW|] TS_SECURITY_HEADER) |
              ([|EncryptionMethod in {TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_40BIT,
                                      TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_128BIT,
                                      TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_56BIT}|] TS_SECURITY_HEADER1) |
              ([|(EncryptionMethod == TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_FIPS)|] TS_SECURITY_HEADER2)
             ) securityHeader;

    TS_SET_KEYBOARD_IME_STATUS_PDU setKeyBdImeStatusPduData;
            
    override string ToString()
    {
        return "Server Set Keyboard IME Status PDU, ImeState: " + 
            EnumToStringInSummary<RDPBCGR.TSSetKeyboardIMEStatusPDUImeState>(setKeyBdImeStatusPduData.ImeState) + 
            ", ImeConvMode: " + EnumToStringInSummary<RDPBCGR.TSSetKeyboardIMEStatusPDUImeConvMode>(setKeyBdImeStatusPduData.ImeConvMode);
    }
}

// 2.2.8.2.2.1   Set Keyboard IME Status PDU Data (TS_SET_KEYBOARD_IME_STATUS_PDU)
type TS_SET_KEYBOARD_IME_STATUS_PDU
{
    TS_SHAREDATAHEADER shareDataHeader;
    ushort UnitId;
    TSSetKeyboardIMEStatusPDUImeState ImeState;
    TSSetKeyboardIMEStatusPDUImeConvMode ImeConvMode;
}

pattern TSSetKeyboardIMEStatusPDUImeState = enum uint
{
    IME_STATE_CLOSED = 0x00000000,
    IME_STATE_OPEN = 0x00000001,
    ...
};

pattern TSSetKeyboardIMEStatusPDUImeConvMode = flags uint
{
    IME_CMODE_NATIVE = 0x00000001
        with Documentation
            {Description = "The input mode is native."},
    IME_CMODE_KATAKANA = 0x00000002
        with Documentation
            {Description = "The input mode is Katakana."},
    IME_CMODE_FULLSHAPE = 0x00000008
        with Documentation
            {Description = "The input mode is full-width."},
    IME_CMODE_ROMAN = 0x00000010
        with Documentation
            {Description = "The input mode is Roman."},
    IME_CMODE_CHARCODE = 0x00000020
        with Documentation
            {Description = "Character-code input is in effect."},
    IME_CMODE_HANJACONVERT = 0x00000040
        with Documentation
            {Description = "Hanja conversion mode is in effect."},
    IME_CMODE_SOFTKBD = 0x00000080
        with Documentation
            {Description = "A soft (on-screen) keyboard is being used."},
    IME_CMODE_NOCONVERSION = 0x00000100
        with Documentation
            {Description = "IME conversion is inactive (that is, the IME is closed)."},
    IME_CMODE_EUDC = 0x00000200
        with Documentation
            {Description = "End-User Defined Character (EUDC) conversion mode is in effect."},
    IME_CMODE_SYMBOL = 0x00000400
        with Documentation
            {Description = "Symbol conversion mode is in effect."},
    IME_CMODE_FIXED = 0x00000800
        with Documentation
            {Description = "Fixed conversion mode is in effect."},
    ...
};

//  2.2.9
// 2.2.9.1.1.3   Server Graphics Update PDU (TS_GRAPHICS_PDU)
message TS_GRAPHICS_PDU[TSUDSCSec1EncryptionLevel EncryptionLevel, TSUDSCSec1EncryptionMethod EncryptionMethod]
{
    optional (
              ([|EncryptionLevel == TSUDSCSec1EncryptionLevel.ENCRYPTION_LEVEL_LOW|] TS_SECURITY_HEADER) |
              ([|EncryptionMethod in {TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_40BIT,
                                      TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_128BIT,
                                      TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_56BIT}|] TS_SECURITY_HEADER1) |
              ([|(EncryptionMethod == TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_FIPS)|] TS_SECURITY_HEADER2)
             ) securityHeader;
  
    array<TS_GRAPHICS_UPDATE> slowPathGraphicsUpdates;
           
    override string ToString()
    {
        string summary = "Server Graphics Update PDU";
        if (slowPathGraphicsUpdates.Count > 0)
        {
            summary += ", slowPathGraphicsUpdates: ";
            if (slowPathGraphicsUpdates.Count > 1)
            {
                summary += "[";
            }
            int cnt = 0;
            foreach (var up in slowPathGraphicsUpdates)
            {
                if (cnt > 0)
                {
                    summary += ", ";
                }
                if (up is TS_UPDATE_BITMAP)
                {
                    summary += "TS_UPDATE_BITMAP";
                }
                else if (up is TS_UPDATE_PALETTE)
                {
                    summary += "TS_UPDATE_PALETTE";
                }
                else if (up is TS_UPDATE_SYNC)
                {
                    summary += "TS_UPDATE_SYNC";
                }
                else if (up is TS_UPDATE_ORDERS_PDU_DATA)
                {
                    summary += "TS_UPDATE_ORDERS_PDU_DATA";
                }
                cnt++;
            }
            if (cnt > 1)
            {
                summary += "]";
            }
        }
        return summary;
    }
}

// 2.2.9.1.1.3.1   Slow-Path Graphics Update (TS_GRAPHICS_UPDATE)
pattern TS_GRAPHICS_UPDATE = [|RemainingByteLength(stream) >= 20|] 
(
    [|stream.PeekUShort(stream.BitPosition + 144, Endian.Little) == TSGraphicsUpdateUpdateType.UPDATETYPE_BITMAP|] TS_UPDATE_BITMAP | 
    [|stream.PeekUShort(stream.BitPosition + 144, Endian.Little) == TSGraphicsUpdateUpdateType.UPDATETYPE_PALETTE|] TS_UPDATE_PALETTE |
    [|stream.PeekUShort(stream.BitPosition + 144, Endian.Little) == TSGraphicsUpdateUpdateType.UPDATETYPE_SYNCHRONIZE|] TS_UPDATE_SYNC |
    [|stream.PeekUShort(stream.BitPosition + 144, Endian.Little) == TSGraphicsUpdateUpdateType.UPDATETYPE_ORDERS|] TS_UPDATE_ORDERS_PDU_DATA
);

pattern TSGraphicsUpdateUpdateType = enum ushort
{
    UPDATETYPE_ORDERS = 0x0000,
    UPDATETYPE_BITMAP = 0x0001,
    UPDATETYPE_PALETTE = 0x0002,
    UPDATETYPE_SYNCHRONIZE = 0x0003,
    ...
};

// 2.2.9.1.1.3.1.1   Palette Update (TS_UPDATE_PALETTE)
type TS_UPDATE_PALETTE
{
    TS_SHAREDATAHEADER shareDataHeader;
    TS_UPDATE_PALETTE_DATA paletteData;

    override string ToString()
    {
        return "TS_UPDATE_PALETTE, NumberColors: " + paletteData.numberColors.ToString();
    }
}

// 2.2.9.1.1.3.1.1.1   Palette Update Data (TS_UPDATE_PALETTE_DATA)
type TS_UPDATE_PALETTE_DATA
{
    TSGraphicsUpdateUpdateType updateType where value == TSGraphicsUpdateUpdateType.UPDATETYPE_PALETTE;
    ushort pad2Octets;
    uint numberColors 
        where ValidationCheckValue(value == 256, null, true, ReferenceType.Type, 
        "RDPBCGR", "numberColors", "TS_UPDATE_PALETTE_DATA", 256, value);
    array<TS_PALETTE_ENTRY> paletteEntries with BinaryEncoding{Length = numberColors};
}

// 2.2.9.1.1.3.1.1.2   RGB Palette Entry (TS_PALETTE_ENTRY)
type TS_PALETTE_ENTRY
{
    byte red;
    byte green;
    byte blue;

    override string ToString()
    {
        return "TS_PALETTE_ENTRY, RGB: (" + red.ToString() + ", " + green.ToString() + ", " + blue.ToString() + ")";
    }
}

// 2.2.9.1.1.3.1.2   Bitmap Update (TS_UPDATE_BITMAP)
type TS_UPDATE_BITMAP
{
  TS_SHAREDATAHEADER shareDataHeader;
  TS_UPDATE_BITMAP_DATA bitmapData;

    override string ToString()
    {
        return "TS_UPDATE_BITMAP, NumberRectangles: " + bitmapData.numberRectangles.ToString();
    }
}

// 2.2.9.1.1.3.1.2.1   Bitmap Update Data (TS_UPDATE_BITMAP_DATA)
type TS_UPDATE_BITMAP_DATA
{
    TSGraphicsUpdateUpdateType updateType where value == TSGraphicsUpdateUpdateType.UPDATETYPE_BITMAP;
    ushort numberRectangles;
    array<TS_BITMAP_DATA> rectangles with BinaryEncoding{Length = numberRectangles};
}

// 2.2.9.1.1.3.1.2.2   Bitmap Data (TS_BITMAP_DATA)
type TS_BITMAP_DATA
{
    ushort destLeft;
    ushort destTop;
    ushort destRight;
    ushort destBottom;
    ushort width;
    ushort height;
    ushort bitsPerPixel;
    TSBitmapDataFlags $"flags";
    ushort bitmapLength;
    optional [|($"flags" & TSBitmapDataFlags.BITMAP_COMPRESSION) == TSBitmapDataFlags.BITMAP_COMPRESSION && 
        ($"flags" & TSBitmapDataFlags.NO_BITMAP_COMPRESSION_HDR) != TSBitmapDataFlags.NO_BITMAP_COMPRESSION_HDR|] 
        TS_CD_HEADER bitmapComprHdr;
    binary bitmapDataStream
        with BinaryEncoding{Length = bitmapComprHdr == nothing ? (bitmapLength) : ((bitmapLength - 8))};
}

pattern TSBitmapDataFlags = flags ushort
{
    BITMAP_COMPRESSION = 0x0001
        with Documentation
            {Description = "The bitmap data is compressed."},
    NO_BITMAP_COMPRESSION_HDR = 0x0400
        with Documentation
            {Description = "The bitmapComprHdr field is not present (removed for bandwidth efficiency to save 8 bytes)."},
    ...
};

// 2.2.9.1.1.3.1.2.3   Compressed Data Header (TS_CD_HEADER)
type TS_CD_HEADER
{
    ushort cbCompFirstRowSize 
        where ValidationCheckZero(value == 0x0000, null, true, ReferenceType.Type, 
        "RDPBCGR", "CBCompFirstRowSize", "TS_CD_HEADER", value);
    ushort cbCompMainBodySize;
    ushort cbScanWidth;
    ushort cbUncompressedSize;
}

// 2.2.9.1.1.3.1.2.4   RLE Compressed Bitmap Stream (RLE_BITMAP_STREAM)
type RLE_BITMAP_STREAM[uint Length]
{
    RleBitmapStreamRleCompressedBitmapStream rleCompressedBitmapStream with BinaryEncoding{Length = Length};
}

// 2.2.9.1.1.3.1.2.4   RLE Compressed Bitmap Stream (RLE_BITMAP_STREAM)
pattern RleBitmapStreamRleCompressedBitmapStream = enum binary
{
    REGULAR_BG_RUN = $[00],
    MEGA_MEGA_BG_RUN = $[F0],
    REGULAR_FG_RUN = $[01],
    MEGA_MEGA_FG_RUN = $[F1],
    LITE_SET_FG_FG_RUN = $[0C],
    MEGA_MEGA_SET_FG_RUN = $[F6],
    LITE_DITHERED_RUN = $[0E],
    MEGA_MEGA_DITHERED_RUN = $[F8],
    REGULAR_COLOR_RUN = $[03],
    MEGA_MEGA_COLOR_RUN = $[F3],
    REGULAR_FGBG_IMAGE = $[02],
    MEGA_MEGA_FGBG_IMAGE = $[F2],
    LITE_SET_FG_FGBG_IMAGE = $[0D],
    MEGA_MEGA_SET_FGBG_IMAGE = $[F7],
    REGULAR_COLOR_IMAGE = $[04],
    MEGA_MEGA_COLOR_IMAGE = $[F4],
    SPECIAL_FGBG_1 = $[F9],
    SPECIAL_FGBG_2 = $[FA],
    WHITE = $[FD],
    BLACK = $[FE],
    ...
};

// 2.2.9.1.1.3.1.3   Synchronize Update (TS_UPDATE_SYNC)
type TS_UPDATE_SYNC
{
    TS_SHAREDATAHEADER shareDataHeader;
    TSGraphicsUpdateUpdateType updateType where value == TSGraphicsUpdateUpdateType.UPDATETYPE_SYNCHRONIZE;
    ushort pad2Octets;

    override string ToString()
    {
        return "TS_UPDATE_SYNC";
    }
}

// 2.2.9.1.1.4   Server Pointer Update PDU (TS_POINTER_PDU)
message TS_POINTER_PDU[TSUDSCSec1EncryptionLevel EncryptionLevel, TSUDSCSec1EncryptionMethod EncryptionMethod]
{
    optional (
              ([|EncryptionLevel == TSUDSCSec1EncryptionLevel.ENCRYPTION_LEVEL_LOW|] TS_SECURITY_HEADER) |
              ([|EncryptionMethod in {TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_40BIT,
                                      TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_128BIT,
                                      TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_56BIT}|] TS_SECURITY_HEADER1) |
              ([|(EncryptionMethod == TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_FIPS)|] TS_SECURITY_HEADER2)
             ) securityHeader;
    TS_SHAREDATAHEADER shareDataHeader;
    TSPointerPduMessageType messageType;
    ushort pad2Octets;
    ([|messageType == TSPointerPduMessageType.TS_PTRMSGTYPE_SYSTEM|] TS_SYSTEMPOINTERATTRIBUTE |
    [|messageType == TSPointerPduMessageType.TS_PTRMSGTYPE_POSITION|] TS_POINTERPOSATTRIBUTE |
    [|messageType == TSPointerPduMessageType.TS_PTRMSGTYPE_COLOR|] TS_COLORPOINTERATTRIBUTE |
    [|messageType == TSPointerPduMessageType.TS_PTRMSGTYPE_CACHED|] TS_CACHEDPOINTERATTRIBUTE |
    [|messageType == TSPointerPduMessageType.TS_PTRMSGTYPE_POINTER|] TS_POINTERATTRIBUTE)
        pointerAttributeData;
                
    override string ToString()
    {
        return "Server Pointer Update PDU, messageType: " + EnumToStringInSummary<RDPBCGR.TSPointerPduMessageType>(messageType);
    }
}

// 2.2.9.1.1.4   Server Pointer Update PDU (TS_POINTER_PDU)
pattern TSPointerPduMessageType = enum ushort
{
    TS_PTRMSGTYPE_SYSTEM = 0x0001,
    TS_PTRMSGTYPE_POSITION = 0x0003,
    TS_PTRMSGTYPE_COLOR = 0x0006,
    TS_PTRMSGTYPE_CACHED = 0x0007,
    TS_PTRMSGTYPE_POINTER = 0x0008,
    ...
};
        
// 2.2.9.1.1.4.1   Point (TS_POINT16)
type TS_POINT16
{
    ushort xPos;
    ushort yPos;
}

// 2.2.9.1.1.4.2   Pointer Position Update (TS_POINTERPOSATTRIBUTE)
type TS_POINTERPOSATTRIBUTE
{
    TS_POINT16 position;
}

// 2.2.9.1.1.4.3   System Pointer Update (TS_SYSTEMPOINTERATTRIBUTE)
pattern TSSystemPointerAttributeSystemPointerType = enum uint
{
    SYSPTR_NULL = 0x00000000,
    SYSPTR_DEFAULT = 0x00007F00,
    ...
};

// 2.2.9.1.1.4.3   System Pointer Update (TS_SYSTEMPOINTERATTRIBUTE)
type TS_SYSTEMPOINTERATTRIBUTE
{
    TSSystemPointerAttributeSystemPointerType systemPointerType;
}

// 2.2.9.1.1.4.4   Color Pointer Update (TS_COLORPOINTERATTRIBUTE)
type TS_COLORPOINTERATTRIBUTE
{
    ushort cacheIndex;
    TS_POINT16 hotSpot;
    ushort width;
    ushort height;
    ushort lengthAndMask;
    ushort lengthXorMask;
    binary xorMaskData with BinaryEncoding{Length = (lengthXorMask)};
    binary andMaskData with BinaryEncoding{Length = (lengthAndMask)};
    optional byte pad;
}

// 2.2.9.1.1.4.5   New Pointer Update (TS_POINTERATTRIBUTE)
type TS_POINTERATTRIBUTE
{
    ushort xorBpp;
    TS_COLORPOINTERATTRIBUTE colorPtrAttr;
}

// 2.2.9.1.1.4.6   Cached Pointer Update (TS_CACHEDPOINTERATTRIBUTE)
type TS_CACHEDPOINTERATTRIBUTE
{
    ushort cacheIndex;
}

// 2.2.9.1.1.5   Server Play Sound PDU
message ServerPlaySoundPdu[TSUDSCSec1EncryptionLevel EncryptionLevel, TSUDSCSec1EncryptionMethod EncryptionMethod]
{
    optional (
              ([|EncryptionLevel == TSUDSCSec1EncryptionLevel.ENCRYPTION_LEVEL_LOW|] TS_SECURITY_HEADER) |
              ([|EncryptionMethod in {TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_40BIT,
                                      TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_128BIT,
                                      TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_56BIT}|] TS_SECURITY_HEADER1) |
              ([|(EncryptionMethod == TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_FIPS)|] TS_SECURITY_HEADER2)
             ) securityHeader;
    TS_PLAY_SOUND_PDU_DATA playSoundPduData;

    override string ToString()
    {
        return "Server Play Sound PDU";
    }
}

// 2.2.9.1.1.5.1   Play Sound PDU Data (TS_PLAY_SOUND_PDU_DATA)
type TS_PLAY_SOUND_PDU_DATA
{
    TS_SHAREDATAHEADER shareDataHeader;
    uint duration;
    uint frequency;
}

// 2.2.9.1.2   Server Fast-Path Update PDU (TS_FP_UPDATE_PDU)
message TS_FP_UPDATE_PDU
{
    TSFPUpdatePduFPOutputHeader fpOutputHeader;
    byte length1;
    optional ([|(length1 & 0x80) == 0x80|] byte) length2;
    optional TS_FP_FIPS_INFO fipsInformation;
    optional ([|(fpOutputHeader.secFlags & SecurityFlags.FASTPATH_OUTPUT_ENCRYPTED) == 
        SecurityFlags.FASTPATH_OUTPUT_ENCRYPTED|] binary) dataSignature with BinaryEncoding{Length = 8};
    optional ([|(fpOutputHeader.secFlags & SecurityFlags.FASTPATH_OUTPUT_ENCRYPTED) == 
        SecurityFlags.FASTPATH_OUTPUT_ENCRYPTED|] binary) EncryptedData;
    optional ([|(fpOutputHeader.secFlags & SecurityFlags.FASTPATH_OUTPUT_ENCRYPTED) != 
        SecurityFlags.FASTPATH_OUTPUT_ENCRYPTED|] array<TS_FP_UPDATE>) fpOutputUpdates;
         
    override string ToString()
    {
        string summary = "Server Fast-Path Update PDU";
        if ((fpOutputHeader.secFlags & SecurityFlags.FASTPATH_OUTPUT_ENCRYPTED) == SecurityFlags.FASTPATH_OUTPUT_ENCRYPTED)
        {
            summary += ", Encrypted";
        }
        else
        {
            if ((fpOutputUpdates is updateArr:array<TS_FP_UPDATE>) && updateArr.Count > 0)
            {
                summary += ", fpOutputUpdates: ";
                if (updateArr.Count > 1)
                {
                    summary += "[";
                }
                int cnt = 0;
                foreach (var up in updateArr)
                {
                    if (cnt > 4)
                    {
                        summary += " ...";
                        break;
                    }
                    else if (cnt > 0)
                    {
                        summary += ", ";
                    }
                    if (up is TS_FP_UPDATE_ORDERS)
                    {
                        summary += "TS_FP_UPDATE_ORDERS";
                    }
                    else if (up is TS_FP_UPDATE_PALETTE)
                    {
                        summary += "TS_FP_UPDATE_PALETTE";
                    }
                    else if (up is TS_FP_UPDATE_BITMAP)
                    {
                        summary += "TS_FP_UPDATE_BITMAP";
                    }
                    else if (up is TS_FP_UPDATE_SYNCHRONIZE)
                    {
                        summary += "TS_FP_UPDATE_SYNCHRONIZE";
                    }
                    else if (up is TS_FP_POINTERPOSATTRIBUTE)
                    {
                        summary += "TS_FP_POINTERPOSATTRIBUTE";
                    }
                    else if (up is TS_FP_SYSTEMPOINTERHIDDENATTRIBUTE)
                    {
                        summary += "TS_FP_SYSTEMPOINTERHIDDENATTRIBUTE";
                    }
                    else if (up is TS_FP_SYSTEMPOINTERDEFAULTATTRIBUTE)
                    {
                        summary += "TS_FP_SYSTEMPOINTERDEFAULTATTRIBUTE";
                    }
                    else if (up is TS_FP_COLORPOINTERATTRIBUTE)
                    {
                        summary += "TS_FP_COLORPOINTERATTRIBUTE";
                    }
                    else if (up is TS_FP_POINTERATTRIBUTE)
                    {
                        summary += "TS_FP_POINTERATTRIBUTE";
                    }
                    else if (up is TS_FP_CACHEDPOINTERATTRIBUTE)
                    {
                        summary += "TS_FP_CACHEDPOINTERATTRIBUTE";
                    }
                    else if (up is TS_FP_SURFCMDS)
                    {
                        summary += "TS_FP_SURFCMDS";
                    }
                    cnt++;
                }
                if (cnt > 1)
                {
                    summary += "]";
                }
                var update = updateArr[0];
                byte compression;
                switch (update)
                {
                    case d:TS_FP_UPDATE_ORDERS =>
                        compression = d.updateHeader.compression;
                    case d:TS_FP_UPDATE_PALETTE =>
                        compression = d.updateHeader.compression;
                    case d:TS_FP_UPDATE_BITMAP =>
                        compression = d.updateHeader.compression;
                    case d:TS_FP_UPDATE_SYNCHRONIZE =>
                        compression = d.updateHeader.compression;
                    case d:TS_FP_POINTERPOSATTRIBUTE =>
                        compression = d.updateHeader.compression;
                    case d:TS_FP_SYSTEMPOINTERHIDDENATTRIBUTE =>
                        compression = d.updateHeader.compression;
                    case d:TS_FP_SYSTEMPOINTERDEFAULTATTRIBUTE =>
                        compression = d.updateHeader.compression;
                    case d:TS_FP_COLORPOINTERATTRIBUTE =>
                        compression = d.updateHeader.compression;
                    case d:TS_FP_POINTERATTRIBUTE =>
                        compression = d.updateHeader.compression;
                    case d:TS_FP_CACHEDPOINTERATTRIBUTE =>
                        compression = d.updateHeader.compression;
                    case d:TS_FP_SURFCMDS =>
                        compression = d.updateHeader.compression;
                    default =>
                        compression = 0;
                }
                if (compression == TSFPUpdateUpdateHeaderCompression.FASTPATH_OUTPUT_COMPRESSION_USED)
                {
                    summary += ", Compressed";
                }          
            }
        }
        int length = (length2 is l:byte) ? ((((length1 & 0x7F) as ushort) << 8) | (l as ushort)) : length1;
        return summary + ", Length: " + length.ToString();
    }
}

// 2.2.9.1.2   Server Fast-Path Update PDU (TS_FP_UPDATE_PDU)
type TSFPUpdatePduFPOutputHeader
{
    SecurityFlags secFlags with BinaryEncoding{Width = 2};
    byte reserved where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, 
        "RDPBCGR", "reserved", "TSFPUpdatePduFPOutputHeader", value)
        with BinaryEncoding{Width = 4};
    TSFPUpdatePduFPOutputHeaderAction action with BinaryEncoding{Width = 2};
}

pattern SecurityFlags = flags byte
{
    FASTPATH_OUTPUT_SECURE_CHECKSUM = 0x01
        with Documentation
            {Description = "The MAC signature for the PDU was generated using the \"salted MAC generation\" technique."},
    FASTPATH_OUTPUT_ENCRYPTED = 0x2
        with Documentation
            {Description = "The PDU contains an 8-byte MAC signature after the optional length2 field, and the contents of the PDU are encrypted using the negotiated encryption package."},
    ...
};

pattern TSFPUpdatePduFPOutputHeaderAction = enum byte
{
    FASTPATH_OUTPUT_ACTION_FASTPATH = 0x0,
    FASTPATH_OUTPUT_ACTION_X224 = 0x3,
    ...
};

// 2.2.9.1.2.1   Fast-Path Update (TS_FP_UPDATE)
pattern TS_FP_UPDATE = [|RemainingBitLength(stream) >= 8|]
(
    [|(CurrentByte(stream) & 0xF) == TSFPUpdateUpdateHeaderUpdateCode.FASTPATH_UPDATETYPE_ORDERS|] TS_FP_UPDATE_ORDERS |
    [|(CurrentByte(stream) & 0xF) == TSFPUpdateUpdateHeaderUpdateCode.FASTPATH_UPDATETYPE_BITMAP|] TS_FP_UPDATE_BITMAP |
    [|(CurrentByte(stream) & 0xF) == TSFPUpdateUpdateHeaderUpdateCode.FASTPATH_UPDATETYPE_PALETTE|] TS_FP_UPDATE_PALETTE |
    [|(CurrentByte(stream) & 0xF) == TSFPUpdateUpdateHeaderUpdateCode.FASTPATH_UPDATETYPE_SYNCHRONIZE|] TS_FP_UPDATE_SYNCHRONIZE |
    [|(CurrentByte(stream) & 0xF) == TSFPUpdateUpdateHeaderUpdateCode.FASTPATH_UPDATETYPE_SURFCMDS|] TS_FP_SURFCMDS |
    [|(CurrentByte(stream) & 0xF) == TSFPUpdateUpdateHeaderUpdateCode.FASTPATH_UPDATETYPE_PTR_NULL|] TS_FP_SYSTEMPOINTERHIDDENATTRIBUTE |
    [|(CurrentByte(stream) & 0xF) == TSFPUpdateUpdateHeaderUpdateCode.FASTPATH_UPDATETYPE_PTR_DEFAULT|] TS_FP_SYSTEMPOINTERDEFAULTATTRIBUTE |
    [|(CurrentByte(stream) & 0xF) == TSFPUpdateUpdateHeaderUpdateCode.FASTPATH_UPDATETYPE_PTR_POSITION|] TS_FP_POINTERPOSATTRIBUTE |
    [|(CurrentByte(stream) & 0xF) == TSFPUpdateUpdateHeaderUpdateCode.FASTPATH_UPDATETYPE_COLOR|] TS_FP_COLORPOINTERATTRIBUTE |
    [|(CurrentByte(stream) & 0xF) == TSFPUpdateUpdateHeaderUpdateCode.FASTPATH_UPDATETYPE_CACHED|] TS_FP_CACHEDPOINTERATTRIBUTE |
    [|(CurrentByte(stream) & 0xF) == TSFPUpdateUpdateHeaderUpdateCode.FASTPATH_UPDATETYPE_POINTER|] TS_FP_POINTERATTRIBUTE |
    [|(CurrentByte(stream) & 0xF) == TSFPUpdateUpdateHeaderUpdateCode.FASTPATH_UPDATETYPE_LARGE_POINTER|] TS_FP_LARGEPOINTERATTRIBUTE
);

// 2.2.9.1.2.1   Fast-Path Update (TS_FP_UPDATE)
type TSFPUpdateUpdateHeader
{
    TSFPUpdateUpdateHeaderCompression compression with BinaryEncoding{Width = 2};
    TSFPUpdateUpdateHeaderFragmentation fragmentation with BinaryEncoding{Width = 2};
    TSFPUpdateUpdateHeaderUpdateCode updateCode with BinaryEncoding{Width = 4};
};

type TS_FP_UPDATE_Base
{
    TSFPUpdateUpdateHeader updateHeader;
}

// 2.2.9.1.2.1   Fast-Path Update (TS_FP_UPDATE)
pattern TSFPUpdateUpdateHeaderUpdateCode = enum byte
{
    FASTPATH_UPDATETYPE_ORDERS = 0x0,
    FASTPATH_UPDATETYPE_BITMAP = 0x1,
    FASTPATH_UPDATETYPE_PALETTE = 0x2,
    FASTPATH_UPDATETYPE_SYNCHRONIZE = 0x3,
    FASTPATH_UPDATETYPE_SURFCMDS = 0x4,
    FASTPATH_UPDATETYPE_PTR_NULL = 0x5,
    FASTPATH_UPDATETYPE_PTR_DEFAULT = 0x6,
    FASTPATH_UPDATETYPE_PTR_POSITION = 0x8,
    FASTPATH_UPDATETYPE_COLOR = 0x9,
    FASTPATH_UPDATETYPE_CACHED = 0xA,
    FASTPATH_UPDATETYPE_POINTER = 0xB,
    FASTPATH_UPDATETYPE_LARGE_POINTER = 0xC,
    ...
};
             
// 2.2.9.1.2.1   Fast-Path Update (TS_FP_UPDATE)
pattern TSFPUpdateUpdateHeaderFragmentation = enum byte
{
    FASTPATH_FRAGMENT_SINGLE = 0x0,
    FASTPATH_FRAGMENT_LAST = 0x1,
    FASTPATH_FRAGMENT_FIRST = 0x2,
    FASTPATH_FRAGMENT_NEXT = 0x3,
    ...
};

// 2.2.9.1.2.1   Fast-Path Update (TS_FP_UPDATE)
pattern TSFPUpdateUpdateHeaderCompression = flags byte
{
    FASTPATH_OUTPUT_COMPRESSION_USED = 0x2
        with Documentation
            {Description = "The compressionFlags field is present."},
    ...
};

// 2.2.9.1.2.1.1   Fast-Path Palette Update (TS_FP_UPDATE_PALETTE)
type TS_FP_UPDATE_PALETTE : TS_FP_UPDATE_Base
{
    //  2.2.8.1.1.1.2
    (optional [|updateHeader.compression == TSFPUpdateUpdateHeaderCompression.FASTPATH_OUTPUT_COMPRESSION_USED|] 
        TSShareDataHeaderCompressedType) compressionFlags;
    ushort size;
    optional [|compressionFlags != nothing && ((compressionFlags as TSShareDataHeaderCompressedType).compressedFlags & 
        TSShareDataHeaderCompressedFlags.PACKET_COMPRESSED) == TSShareDataHeaderCompressedFlags.PACKET_COMPRESSED|] 
        binary CompressedData with BinaryEncoding{Length = size};
       
    optional [|CompressedData is nothing|] TS_UPDATE_PALETTE_DATA paletteUpdateData;

    override string ToString()
    {
        return "TS_FP_UPDATE_PALETTE";
    }
}

// 2.2.9.1.2.1.2   Fast-Path Bitmap Update (TS_FP_UPDATE_BITMAP)
type TS_FP_UPDATE_BITMAP : TS_FP_UPDATE_Base
{
    //  2.2.8.1.1.1.2
    (optional [|updateHeader.compression == TSFPUpdateUpdateHeaderCompression.FASTPATH_OUTPUT_COMPRESSION_USED|] 
        TSShareDataHeaderCompressedType) compressionFlags;
    ushort size;
    optional [|compressionFlags != nothing && ((compressionFlags as TSShareDataHeaderCompressedType).compressedFlags & 
        TSShareDataHeaderCompressedFlags.PACKET_COMPRESSED) == TSShareDataHeaderCompressedFlags.PACKET_COMPRESSED|] 
        binary CompressedData with BinaryEncoding{Length = size};
       
    optional [|CompressedData is nothing|] TS_UPDATE_BITMAP_DATA bitmapUpdateData;

    override string ToString()
    {
        return "TS_FP_UPDATE_BITMAP";
    }
}

// 2.2.9.1.2.1.3   Fast-Path Synchronize Update (TS_FP_UPDATE_SYNCHRONIZE)
type TS_FP_UPDATE_SYNCHRONIZE : TS_FP_UPDATE_Base
{
    //  2.2.8.1.1.1.2
    (optional [|updateHeader.compression == TSFPUpdateUpdateHeaderCompression.FASTPATH_OUTPUT_COMPRESSION_USED|] 
        TSShareDataHeaderCompressedType) compressionFlags;
  
    ushort size where ValidationCheckZero(value == 0, null, true, ReferenceType.Type, 
        "RDPBCGR", "size", "TS_FP_UPDATE_SYNCHRONIZE", value);

    override string ToString()
    {
        return "TS_FP_UPDATE_SYNCHRONIZE";
    }
}

// 2.2.9.1.2.1.4   Fast-Path Pointer Position Update (TS_FP_POINTERPOSATTRIBUTE)
type TS_FP_POINTERPOSATTRIBUTE : TS_FP_UPDATE_Base
{
    //  2.2.8.1.1.1.2
    (optional [|updateHeader.compression == TSFPUpdateUpdateHeaderCompression.FASTPATH_OUTPUT_COMPRESSION_USED|] 
        TSShareDataHeaderCompressedType) compressionFlags;
    ushort size;
    optional [|compressionFlags != nothing && ((compressionFlags as TSShareDataHeaderCompressedType).compressedFlags & 
        TSShareDataHeaderCompressedFlags.PACKET_COMPRESSED) == TSShareDataHeaderCompressedFlags.PACKET_COMPRESSED|] 
        binary CompressedData with BinaryEncoding{Length = size};
    optional [|CompressedData is nothing|] TS_POINTERPOSATTRIBUTE pointerPositionUpdateData;

    override string ToString()
    {
        return "TS_FP_POINTERPOSATTRIBUTE";
    }
}

// 2.2.9.1.2.1.5   Fast-Path System Pointer Hidden Update (TS_FP_SYSTEMPOINTERHIDDENATTRIBUTE)
type TS_FP_SYSTEMPOINTERHIDDENATTRIBUTE : TS_FP_UPDATE_Base
{
    //  2.2.8.1.1.1.2
    (optional [|updateHeader.compression == TSFPUpdateUpdateHeaderCompression.FASTPATH_OUTPUT_COMPRESSION_USED|] 
        TSShareDataHeaderCompressedType) compressionFlags;
    ushort size where ValidationCheckZero(value == 0, null, true, ReferenceType.Type, 
        "RDPBCGR", "size", "TS_FP_SYSTEMPOINTERHIDDENATTRIBUTE", value);

    override string ToString()
    {
        return "TS_FP_SYSTEMPOINTERHIDDENATTRIBUTE";
    }
}

// 2.2.9.1.2.1.6   Fast-Path System Pointer Default Update (TS_FP_SYSTEMPOINTERDEFAULTATTRIBUTE)
type TS_FP_SYSTEMPOINTERDEFAULTATTRIBUTE : TS_FP_UPDATE_Base
{
    //  2.2.8.1.1.1.2
    (optional [|updateHeader.compression == TSFPUpdateUpdateHeaderCompression.FASTPATH_OUTPUT_COMPRESSION_USED|] 
        TSShareDataHeaderCompressedType) compressionFlags;
    ushort size where ValidationCheckZero(value == 0, null, true, ReferenceType.Type, 
        "RDPBCGR", "size", "TS_FP_SYSTEMPOINTERDEFAULTATTRIBUTE", value);

    override string ToString()
    {
        return "TS_FP_SYSTEMPOINTERDEFAULTATTRIBUTE";
    }
}

// 2.2.9.1.2.1.7   Fast-Path Color Pointer Update (TS_FP_COLORPOINTERATTRIBUTE)
type TS_FP_COLORPOINTERATTRIBUTE : TS_FP_UPDATE_Base
{
    //  2.2.8.1.1.1.2
    (optional [|updateHeader.compression == TSFPUpdateUpdateHeaderCompression.FASTPATH_OUTPUT_COMPRESSION_USED|] 
        TSShareDataHeaderCompressedType) compressionFlags;
    ushort size;
    optional [|compressionFlags != nothing && ((compressionFlags as TSShareDataHeaderCompressedType).compressedFlags & 
        TSShareDataHeaderCompressedFlags.PACKET_COMPRESSED) == TSShareDataHeaderCompressedFlags.PACKET_COMPRESSED|] 
        binary CompressedData with BinaryEncoding{Length = size};
    optional [|CompressedData is nothing|] TS_COLORPOINTERATTRIBUTE colorPointerUpdateData;

    override string ToString()
    {
        return "TS_FP_COLORPOINTERATTRIBUTE";
    }
}

// 2.2.9.1.2.1.8   Fast-Path New Pointer Update (TS_FP_POINTERATTRIBUTE)
type TS_FP_POINTERATTRIBUTE : TS_FP_UPDATE_Base
{
    //  2.2.8.1.1.1.2
    (optional [|updateHeader.compression == TSFPUpdateUpdateHeaderCompression.FASTPATH_OUTPUT_COMPRESSION_USED|] 
        TSShareDataHeaderCompressedType) compressionFlags;
    ushort size;
    optional [|compressionFlags != nothing && ((compressionFlags as TSShareDataHeaderCompressedType).compressedFlags & 
        TSShareDataHeaderCompressedFlags.PACKET_COMPRESSED) == TSShareDataHeaderCompressedFlags.PACKET_COMPRESSED|] 
        binary CompressedData with BinaryEncoding{Length = size};
    optional [|CompressedData is nothing|] TS_POINTERATTRIBUTE newPointerUpdateData;

    override string ToString()
    {
        return "TS_FP_POINTERATTRIBUTE";
    }
}

// 2.2.9.1.2.1.9   Fast-Path Cached Pointer Update (TS_FP_CACHEDPOINTERATTRIBUTE)
type TS_FP_CACHEDPOINTERATTRIBUTE : TS_FP_UPDATE_Base
{
    //  2.2.8.1.1.1.2
    (optional [|updateHeader.compression == TSFPUpdateUpdateHeaderCompression.FASTPATH_OUTPUT_COMPRESSION_USED|] 
        TSShareDataHeaderCompressedType) compressionFlags;
    ushort size;
    optional [|compressionFlags != nothing && ((compressionFlags as TSShareDataHeaderCompressedType).compressedFlags & 
        TSShareDataHeaderCompressedFlags.PACKET_COMPRESSED) == TSShareDataHeaderCompressedFlags.PACKET_COMPRESSED|] 
        binary CompressedData with BinaryEncoding{Length = size};
    optional [|CompressedData is nothing|] TS_CACHEDPOINTERATTRIBUTE cachedPointerUpdateData;

    override string ToString()
    {
        return "TS_FP_CACHEDPOINTERATTRIBUTE";
    }
}

// 2.2.9.1.2.1.10   Fast-Path Surface Commands Update (TS_FP_SURFCMDS)
type TS_FP_SURFCMDS : TS_FP_UPDATE_Base
{
    //  2.2.8.1.1.1.2
    optional ([|updateHeader.compression == TSFPUpdateUpdateHeaderCompression.FASTPATH_OUTPUT_COMPRESSION_USED|] 
        TSShareDataHeaderCompressedType) compressionFlags;
    ushort size;
    optional [|compressionFlags != nothing && ((compressionFlags as TSShareDataHeaderCompressedType).compressedFlags & 
        TSShareDataHeaderCompressedFlags.PACKET_COMPRESSED) == TSShareDataHeaderCompressedFlags.PACKET_COMPRESSED|] 
        binary CompressedData with BinaryEncoding{Length = size};
    optional [|CompressedData is nothing|] array<TS_SURFCMD> surfaceCommands;

    override string ToString()
    {
        return "TS_FP_SURFCMDS";
    }
}

// 2.2.9.1.2.1.10.1   Surface Command (TS_SURFCMD)
type TS_SURFCMD
{
    TSSurfcmdCmdType cmdType;
  
    ([|cmdType == TSSurfcmdCmdType.CMDTYPE_SET_SURFACE_BITS|] TS_SURFCMD_SET_SURF_BITS |
    [|cmdType == TSSurfcmdCmdType.CMDTYPE_FRAME_MARKER|] TS_FRAME_MARKER |
    [|cmdType == TSSurfcmdCmdType.CMDTYPE_STREAM_SURFACE_BITS|] TS_SURFCMD_STREAM_SURF_BITS) cmdData;

    override string ToString()
    {
        return "TS_SURFCMD, " + EnumToString<TSSurfcmdCmdType>(cmdType);
    }
}

// 2.2.9.1.2.1.10.1   Surface Command (TS_SURFCMD)
pattern TSSurfcmdCmdType = enum ushort
{
    CMDTYPE_SET_SURFACE_BITS = 0x0001,
    CMDTYPE_FRAME_MARKER = 0x0004,
    CMDTYPE_STREAM_SURFACE_BITS = 0x0006,
    ...
};

// 2.2.9.1.2.1.11   Fast-Path Large Pointer Update (TS_FP_LARGEPOINTERATTRIBUTE)
type TS_FP_LARGEPOINTERATTRIBUTE : TS_FP_UPDATE_Base
{
    optional ([|updateHeader.compression == TSFPUpdateUpdateHeaderCompression.FASTPATH_OUTPUT_COMPRESSION_USED|] 
        TSShareDataHeaderCompressedType) compressionFlags;
    ushort size;
    ushort xorBpp;
    ushort cacheIndex;
    TS_POINT16 hotSpot;
    ushort width;
    ushort height;
    uint lengthAndMask;
    uint lengthXorMask;
    binary xorMaskData with BinaryEncoding{Length = (lengthXorMask)};
    binary andMaskData with BinaryEncoding{Length = (lengthAndMask)};
    optional byte pad;
}

// 2.2.9.2.1   Set Surface Bits Command (TS_SURFCMD_SET_SURF_BITS)
type TS_SURFCMD_SET_SURF_BITS
{
    // cmdType TDI
    ushort destLeft;
    ushort destTop;
    ushort destRight;
    ushort destBottom;
    TS_BITMAP_DATA_EX bitmapData;
}

// 2.2.9.2.1.1   Extended Bitmap Data (TS_BITMAP_DATA_EX)
type TS_BITMAP_DATA_EX
{
    byte bpp;
    TS_BITMAP_DATA_EX_Flags $"flags";
    byte reserved where ValidationCheckReservedZero(value == 0, null, true, 
        ReferenceType.Type, "RDPBCGR", "reserved", "TS_BITMAP_DATA_EX", value);
    byte codecID;
    ushort width;
    ushort height;
    uint bitmapDataLength;
    optional [|($"flags" & TS_BITMAP_DATA_EX_Flags.EX_COMPRESSED_BITMAP_HEADER_PRESENT) == TS_BITMAP_DATA_EX_Flags.EX_COMPRESSED_BITMAP_HEADER_PRESENT|] TS_COMPRESSED_BITMAP_HEADER_EX exBitmapDataHeader;
    ([|codecID == 0x01|] RDPNSC.NSCODEC_BITMAP_STREAM[width, height] | binary | any) bitmapData 
        with BinaryEncoding{Length = bitmapDataLength};
}

pattern TS_BITMAP_DATA_EX_Flags = flags byte
{
    EX_COMPRESSED_BITMAP_HEADER_PRESENT = 0x01
        with Documentation{Description = "The optional exBitmapDataHeader field is present."},
    ...
};

type TS_COMPRESSED_BITMAP_HEADER_EX
{
    uint highUniqueId;
    uint lowUniqueId;
    ulong tmMilliseconds;
    ulong tmSeconds;
}

// 2.2.9.2.2   Stream Surface Bits Command (TS_SURFCMD_STREAM_SURF_BITS)
type TS_SURFCMD_STREAM_SURF_BITS
{
    // cmdType TDI
    ushort destLeft;
    ushort destTop;
    ushort destRight;
    ushort destBottom;
    TS_BITMAP_DATA_EX bitmapData;
}

// 2.2.9.2.3   Frame Marker Command (TS_FRAME_MARKER)
pattern TSFrameMarkerFrameAction = enum ushort
{
    SURFACECMD_FRAMEACTION_BEGIN = 0x0000,
    SURFACECMD_FRAMEACTION_END = 0x0001,
    ...
};

// 2.2.9.2.3   Frame Marker Command (TS_FRAME_MARKER)
type TS_FRAME_MARKER
{
  TSFrameMarkerFrameAction frameAction;
  uint frameId;
}

// 2.2.10.1   Server Save Session Info PDU
message ServerSaveSessionInfoPdu[TSUDSCSec1EncryptionLevel EncryptionLevel, TSUDSCSec1EncryptionMethod EncryptionMethod]
{
    optional (
              ([|EncryptionLevel == TSUDSCSec1EncryptionLevel.ENCRYPTION_LEVEL_LOW|] TS_SECURITY_HEADER) |
              ([|EncryptionMethod in {TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_40BIT,
                                      TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_128BIT,
                                      TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_56BIT}|] TS_SECURITY_HEADER1) |
              ([|(EncryptionMethod == TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_FIPS)|] TS_SECURITY_HEADER2)
             ) securityHeader;
    TS_SAVE_SESSION_INFO_PDU_DATA saveSessionInfoPduData;

    override string ToString()
    {
        return "Server Save Session Info PDU";
    }
}

// 2.2.10.1.1   Save Session Info PDU Data (TS_SAVE_SESSION_INFO_PDU_DATA)
type TS_SAVE_SESSION_INFO_PDU_DATA
{
    TS_SHAREDATAHEADER shareDataHeader;
    TSSaveSessionInfoPduDataInfoType infoType;
    ([|infoType == TSSaveSessionInfoPduDataInfoType.INFOTYPE_LOGON|] TS_LOGON_INFO // Logon Info Version 1
       | [|infoType == TSSaveSessionInfoPduDataInfoType.INFOTYPE_LOGON_LONG|] TS_LOGON_INFO_VERSION_2 // Logon Info Version 2
       | [|infoType == TSSaveSessionInfoPduDataInfoType.INFOTYPE_LOGON_PLAINNOTIFY|] TS_PLAIN_NOTIFY // Plain Notify
       | [|infoType == TSSaveSessionInfoPduDataInfoType.INFOTYPE_LOGON_EXTENDED_INFO|] TS_LOGON_INFO_EXTENDED) infoData; // Logon Info Extended
}

pattern TSSaveSessionInfoPduDataInfoType = enum uint
{
    INFOTYPE_LOGON = 0x00000000,
    INFOTYPE_LOGON_LONG = 0x00000001,
    INFOTYPE_LOGON_PLAINNOTIFY = 0x00000002,
    INFOTYPE_LOGON_EXTENDED_INFO = 0x00000003,
    ...
};

// 2.2.10.1.1.1   Logon Info Version 1 (TS_LOGON_INFO)
// pattern String16 = string with BinaryEncoding{TextEncoding = TextEncoding.UTF16};
type TS_LOGON_INFO
{
    uint cbDomain;
    string Domain with BinaryEncoding{TextEncoding = TextEncoding.Unicode, Length = 26};
    uint cbUserName;
    string UserName with BinaryEncoding{TextEncoding = TextEncoding.Unicode, Length = 256};
    uint SessionId;
}

// 2.2.10.1.1.2   Logon Info Version 2 (TS_LOGON_INFO_VERSION_2)
type TS_LOGON_INFO_VERSION_2
{
    TSLogonInfoVersion2Version Version;
    uint Size;
    uint SessionId;
    uint cbDomain;
    uint cbUserName;
    binary Pad with BinaryEncoding {Length = 558};
    string Domain with BinaryEncoding{TextEncoding = TextEncoding.Unicode, Length = cbDomain / 2};
    string UserName with BinaryEncoding{TextEncoding = TextEncoding.Unicode, Length = cbUserName / 2};
}

pattern TSLogonInfoVersion2Version = enum ushort
{
    SAVE_SESSION_PDU_VERSION_ONE = 0x0001,
    ...
};

// 2.2.10.1.1.3   Plain Notify (TS_PLAIN_NOTIFY)
type TS_PLAIN_NOTIFY
{
    binary Pad with BinaryEncoding {Length = 576};
}
        
// 2.2.10.1.1.4   Logon Info Extended (TS_LOGON_INFO_EXTENDED)
type TS_LOGON_INFO_EXTENDED
{
    ushort Length;
    TSLogonInfoExtendedFieldsPresent FieldsPresent;
    TS_LogonInfoExtendedLogonFields[FieldsPresent] LogonFields;
    binary Pad with BinaryEncoding {Length = 570};
};

type TS_LogonInfoExtendedLogonFields[TSLogonInfoExtendedFieldsPresent FieldsPresent]
{
    optional [|(FieldsPresent & TSLogonInfoExtendedFieldsPresent.LOGON_EX_AUTORECONNECTCOOKIE) > 0|] 
        TS_LOGON_INFO_FIELD[1] AutoReconnectCookieData;
    optional [|(FieldsPresent & TSLogonInfoExtendedFieldsPresent.LOGON_EX_LOGONERRORS) > 0|] 
        TS_LOGON_INFO_FIELD[2] LogonNotificationData;
};
        
// 2.2.10.1.1.4   Logon Info Extended (TS_LOGON_INFO_EXTENDED)
pattern TSLogonInfoExtendedFieldsPresent = flags uint
{
    LOGON_EX_AUTORECONNECTCOOKIE = 0x00000001
        with Documentation
            {Description = "An auto-reconnect cookie field is present."},
    LOGON_EX_LOGONERRORS = 0x00000002
        with Documentation
            {Description = "A logon error field is present."},
};

// 2.2.10.1.1.4.1   Logon Info Field (TS_LOGON_INFO_FIELD)
// ARC_SC_PRIVATE_PACKET or Error 
type TS_LOGON_INFO_FIELD[uint FieldPresent]
{
    uint cbFieldData;
    ([|FieldPresent == 1|] ARC_SC_PRIVATE_PACKET | [|FieldPresent == 2|] TS_LOGON_ERRORS_INFO) FieldData;
}

// 2.2.10.1.1.4.1.1   Logon Errors Info (TS_LOGON_ERRORS_INFO)
type TS_LOGON_ERRORS_INFO
{    
    (NTSTATUS | TSLogonErrorsInfoErrorNotificationType) ErrorNotificationType;
    TSLogonErrorsInfoErrorNotificationData ErrorNotificationData;
}

// 2.2.10.1.1.4.1.1   Logon Errors Info (TS_LOGON_ERRORS_INFO)
pattern TSLogonErrorsInfoErrorNotificationType = enum uint
{
    LOGON_MSG_DISCONNECT_REFUSED = 0xFFFFFFF9,
    LOGON_MSG_NO_PERMISSION = 0xFFFFFFFA,
    LOGON_MSG_BUMP_OPTIONS = 0xFFFFFFFB,
    LOGON_MSG_RECONNECT_OPTIONS = 0xFFFFFFFC,
    LOGON_MSG_SESSION_TERMINATE = 0xFFFFFFFD,
    LOGON_MSG_SESSION_CONTINUE = 0xFFFFFFFE,
    ...
};

pattern TSLogonErrorsInfoErrorNotificationData = enum uint
{
    LogonFailedBadPassword = 0x00000000,
    LogonFailedUpdatePassword = 0x00000001,
    LogonFailedOther = 0x00000002,
    LogonWarning = 0x00000003,
    ...
};

// 2.2.10.2   Early User Authorization Result PDU

message EarlyUserAuthorizationResultPdu
{
    AuthorizationResult authorizationResult;
    override string ToString()
    {
        return "EarlyUserAuthorizationResultPdu, authorizationResult: " + 
            EnumToStringInSummary<RDPBCGR.AuthorizationResult>(authorizationResult);
    }
}

pattern AuthorizationResult = enum uint
{
    AUTHZ_SUCCESS = 0x00000000,
    AUTHZ_ACCESS_DENIED = 0x000005,
    ...
};

// 2.2.11.1   Inclusive Rectangle (TS_RECTANGLE16)
type TS_RECTANGLE16
{
    ushort left;
    ushort top;
    ushort right;
    ushort bottom;

    override string ToString()
    {
        return "TS_RECTANGLE16, left: " + left.ToString() + 
            ", top: " + top.ToString() + ", right: " + right.ToString() + 
            ", bottom" + bottom.ToString();
    }
}

// 2.2.11.2   Client Refresh Rect PDU
message ClientRefreshRectPdu[TSUDSCSec1EncryptionLevel EncryptionLevel, TSUDSCSec1EncryptionMethod EncryptionMethod]
{
    optional (
              ([|EncryptionMethod in {TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_40BIT,
                                      TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_128BIT,
                                      TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_56BIT}|] TS_SECURITY_HEADER1) |
              ([|(EncryptionMethod == TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_FIPS)|] TS_SECURITY_HEADER2)
             ) securityHeader;
    TS_REFRESH_RECT_PDU refreshRectPduData;
           
    override string ToString()
    {
        return "Client Refresh Rect PDU";
    }
}

// 2.2.11.2.1   Refresh Rect PDU Data (TS_REFRESH_RECT_PDU)
type TS_REFRESH_RECT_PDU
{
    TS_SHAREDATAHEADER shareDataHeader;
    byte numberOfAreas;
    binary pad3Octects with BinaryEncoding{Length = 3};
    array<TS_RECTANGLE16> areasToRefresh with BinaryEncoding{Length = numberOfAreas};
}

// 2.2.11.3   Client Suppress Output PDU
message ClientSuppressOutputPdu[TSUDSCSec1EncryptionLevel EncryptionLevel, TSUDSCSec1EncryptionMethod EncryptionMethod]
{
    optional (
              ([|EncryptionMethod in {TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_40BIT,
                                      TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_128BIT,
                                      TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_56BIT}|] TS_SECURITY_HEADER1) |
              ([|(EncryptionMethod == TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_FIPS)|] TS_SECURITY_HEADER2)
             ) securityHeader;
    TS_SUPPRESS_OUTPUT_PDU suppressOutputPduData;
           
    override string ToString()
    {
        return "Client Suppress Output PDU";
    }
}

// 2.2.11.3.1   Suppress Output PDU Data (TS_SUPPRESS_OUTPUT_PDU)
type TS_SUPPRESS_OUTPUT_PDU
{
    TS_SHAREDATAHEADER shareDataHeader;
    TSSuppressOutputPduAllowDisplayUpdates allowDisplayUpdates;
    binary pad3Octets with BinaryEncoding{Length = 3};
    optional [|allowDisplayUpdates == TSSuppressOutputPduAllowDisplayUpdates.ALLOW_DISPLAY_UPDATES|] TS_RECTANGLE16 desktopRect;
}

pattern TSSuppressOutputPduAllowDisplayUpdates = enum byte
{
    SUPPRESS_DISPLAY_UPDATES = 0x00,
    ALLOW_DISPLAY_UPDATES = 0x01,
    ...
};

// 2.2.12.1   Monitor Layout PDU
message MonitorLayoutPdu[TSUDSCSec1EncryptionLevel EncryptionLevel, TSUDSCSec1EncryptionMethod EncryptionMethod]
{
    optional (
              ([|EncryptionLevel == TSUDSCSec1EncryptionLevel.ENCRYPTION_LEVEL_LOW|] TS_SECURITY_HEADER) |
              ([|EncryptionMethod in {TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_40BIT,
                                      TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_128BIT,
                                      TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_56BIT}|] TS_SECURITY_HEADER1) |
              ([|(EncryptionMethod == TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_FIPS)|] TS_SECURITY_HEADER2)
             ) securityHeader;
    TS_SHAREDATAHEADER shareDataHeader;
    uint monitorCount;
    array<TS_MONITOR_DEF> monitorDefArray with BinaryEncoding{Length = monitorCount};

    override string ToString()
    {
        return "Monitor Layout PDU";
    }
}

// 2.2.13.1   Server Redirection Packet (RDP_SERVER_REDIRECTION_PACKET)
type RDP_SERVER_REDIRECTION_PACKET
{
    ushort Flags where value == 0x0400;
    ushort Length;
    uint SessionID;
    RdpServerRedirectionPacketRedirFlags RedirFlags;
    optional ([|(RedirFlags & RdpServerRedirectionPacketRedirFlags.LB_TARGET_NET_ADDRESS) == RdpServerRedirectionPacketRedirFlags.LB_TARGET_NET_ADDRESS|] uint) TargetNetAddressLength;
    optional ([|!(TargetNetAddressLength is nothing)|] string) TargetNetAddress with BinaryEncoding{TextEncoding = TextEncoding.UTF16};
    optional [|(RedirFlags & RdpServerRedirectionPacketRedirFlags.LB_LOAD_BALANCE_INFO) == RdpServerRedirectionPacketRedirFlags.LB_LOAD_BALANCE_INFO|] uint LoadBalanceInfoLength;
    optional ([|!(LoadBalanceInfoLength is nothing)|] binary) LoadBalanceInfo with BinaryEncoding{Length = LoadBalanceInfoLength as uint};
    optional [|(RedirFlags & RdpServerRedirectionPacketRedirFlags.LB_USERNAME) == RdpServerRedirectionPacketRedirFlags.LB_USERNAME|] uint UserNameLength;
    optional ([|!(UserNameLength is nothing)|] string) UserName with BinaryEncoding{TextEncoding = TextEncoding.UTF16, WidthForComposedType = (UserNameLength is nothing ? 0 : UserNameLength  as uint) * 8};
    optional [|(RedirFlags & RdpServerRedirectionPacketRedirFlags.LB_DOMAIN) == RdpServerRedirectionPacketRedirFlags.LB_DOMAIN|] uint DomainLength;
    optional ([|!(DomainLength is nothing)|] string) Domain with BinaryEncoding{TextEncoding = TextEncoding.UTF16, WidthForComposedType = (DomainLength is nothing ? 0 : DomainLength  as uint) * 8};
    optional [|(RedirFlags & RdpServerRedirectionPacketRedirFlags.LB_PASSWORD) == RdpServerRedirectionPacketRedirFlags.LB_PASSWORD|] uint PasswordLength;
    optional ([|!(PasswordLength is nothing)|] string) Password with BinaryEncoding{TextEncoding = TextEncoding.UTF16, WidthForComposedType = (PasswordLength is nothing ? 0 : PasswordLength  as uint) * 8};
    optional [|(RedirFlags & RdpServerRedirectionPacketRedirFlags.LB_TARGET_FQDN) == RdpServerRedirectionPacketRedirFlags.LB_TARGET_FQDN|] uint TargetFQDNLength;
    optional ([|!(TargetFQDNLength is nothing)|] string) TargetFQDN with BinaryEncoding{TextEncoding = TextEncoding.UTF16, WidthForComposedType = (TargetFQDNLength is nothing ? 0 : TargetFQDNLength  as uint) * 8};
    optional [|(RedirFlags & RdpServerRedirectionPacketRedirFlags.LB_TARGET_NETBIOS_NAME) == RdpServerRedirectionPacketRedirFlags.LB_TARGET_NETBIOS_NAME|] uint TargetNetBiosNameLength;
    optional ([|!(TargetNetBiosNameLength is nothing)|] string) TargetNetBiosName with BinaryEncoding{TextEncoding = TextEncoding.UTF16, WidthForComposedType = (TargetNetBiosNameLength is nothing ? 0 : TargetNetBiosNameLength  as uint) * 8};
    optional [|(RedirFlags & RdpServerRedirectionPacketRedirFlags.LB_CLIENT_TSV_URL) == RdpServerRedirectionPacketRedirFlags.LB_CLIENT_TSV_URL|] uint TsvUrlLength;
    optional ([|!(TsvUrlLength is nothing)|] string) TsvUrl with BinaryEncoding{TextEncoding = TextEncoding.UTF16, WidthForComposedType = (TsvUrlLength is nothing ? 0 : TsvUrlLength as uint) * 8};
    optional [|(RedirFlags & RdpServerRedirectionPacketRedirFlags.LB_REDIRECTION_GUID) == RdpServerRedirectionPacketRedirFlags.LB_REDIRECTION_GUID|] uint RedirectionGuidLength;
    optional ([|!(RedirectionGuidLength is nothing)|] binary) RedirectionGuid with BinaryEncoding{Length = RedirectionGuidLength as uint};
    optional [|(RedirFlags & RdpServerRedirectionPacketRedirFlags.LB_TARGET_CERTIFICATE) == RdpServerRedirectionPacketRedirFlags.LB_TARGET_CERTIFICATE|] uint TargetCertificateLength;
    optional ([|!(TargetCertificateLength is nothing)|] TARGET_CERTIFICATE_CONTAINER) TargetCertificateContainer;
    optional [|(RedirFlags & RdpServerRedirectionPacketRedirFlags.LB_TARGET_NET_ADDRESS) == RdpServerRedirectionPacketRedirFlags.LB_TARGET_NET_ADDRESS|] uint TargetNetAddressesLength;
    optional ([|!(TargetNetAddressesLength is nothing)|] TARGET_NET_ADDRESSES) TargetNetAddresses;
    optional binary Pad with BinaryEncoding{Length = 8};
};

// 2.2.13.1   Server Redirection Packet (RDP_SERVER_REDIRECTION_PACKET)
pattern RdpServerRedirectionPacketRedirFlags = flags uint
{
    LB_TARGET_NET_ADDRESS = 0x00000001
        with Documentation
            {Description = "The TargetNetAddressLength and TargetNetAddress fields are present."},
    LB_LOAD_BALANCE_INFO = 0x00000002
        with Documentation
            {Description = "The LoadBalanceInfoLength and LoadBalanceInfo fields are present."},
    LB_USERNAME = 0x00000004
        with Documentation
            {Description = "The UserNameLength and UserName fields are present."},
    LB_DOMAIN = 0x00000008
        with Documentation
            {Description = "The DomainLength and Domain fields are present."},
    LB_PASSWORD = 0x00000010
        with Documentation
            {Description = "The PasswordLength and Password fields are present."},
    LB_DONTSTOREUSERNAME = 0x00000020
        with Documentation
            {Description = "When reconnecting, the client MUST send the username specified in the UserName field to the server in the Client Info PDU."},
    LB_SMARTCARD_LOGON = 0x00000040
        with Documentation
            {Description = "The user can use a smart card for authentication."},
    LB_NOREDIRECT = 0x00000080
        with Documentation
            {Description = "The contents of the PDU are for informational purposes only."},
    LB_TARGET_FQDN = 0x00000100
        with Documentation
            {Description = "The TargetFQDNLength and TargetFQDN fields are present."},
    LB_TARGET_NETBIOS_NAME = 0x00000200
        with Documentation
            {Description = "The TargetNetBiosNameLength and TargetNetBiosName fields are present."},
    LB_TARGET_NET_ADDRESSES = 0x00000800
        with Documentation
            {Description = "The TargetNetAddressesLength and TargetNetAddresses fields are present."},
    LB_CLIENT_TSV_URL = 0x00001000
        with Documentation
            {Description = "The TsvUrlLength and TsvUrl fields are present."},
    LB_SERVER_TSV_CAPABLE = 0x00002000
        with Documentation
            {Description = "The server supports redirection based on the TsvUrl present in the LoadBalanceInfo sent by the client."},
    LB_PASSWORD_IS_PK_ENCRYPTED = 0x00004000
        with Documentation
            {Description = "The data in the Password field is encrypted and contains data that SHOULD be used in the RDS Authentication Request PDU with Password Credentials."},
    LB_REDIRECTION_GUID = 0x00008000
        with Documentation
            {Description = "The RedirectionGuidLength and RedirectionGuid fields are present."},
    LB_TARGET_CERTIFICATE = 0x00010000
        with Documentation
            {Description = "The TargetCertificateLength and TargetCertificate fields are present."},
};

// 2.2.13.1.1   Target Net Addresses (TARGET_NET_ADDRESSES)
type TARGET_NET_ADDRESSES
{
    uint addressCount;
    array<TARGET_NET_ADDRESS> addresses with BinaryEncoding{Length = addressCount};
}

// 2.2.13.1.1.1   Target Net Address (TARGET_NET_ADDRESS)
type TARGET_NET_ADDRESS
{
    uint addressLength;
    string address with BinaryEncoding{TextEncoding = TextEncoding.Unicode};

    override string ToString()
    {
        return address;
    }
}

// 2.2.13.1.2 Target Certificate Container (TARGET_CERTIFICATE_CONTAINER)
type TARGET_CERTIFICATE_CONTAINER
{
    array<CERTIFICATE_META_ELEMENT> CertificateMeteElements;
}

// 2.2.13.1.2.1   Certificate Meta Element (CERTIFICATE_META_ELEMENT)
type CERTIFICATE_META_ELEMENT
{
    uint elementType;
    uint encoding;
    uint elementSize;
    array<byte> elementData with BinaryEncoding{Length = elementSize};
}

// 2.2.13.2.1   Standard Security Server Redirection PDU (TS_STANDARD_SECURITY_SERVER_REDIRECTION)
message TS_STANDARD_SECURITY_SERVER_REDIRECTION[TSUDSCSec1EncryptionLevel EncryptionLevel, TSUDSCSec1EncryptionMethod EncryptionMethod]
{
    optional (
              ([|EncryptionMethod in {TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_40BIT,
                                      TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_128BIT,
                                      TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_56BIT}|] TS_SECURITY_HEADER1) |
              ([|(EncryptionMethod == TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_FIPS)|] TS_SECURITY_HEADER2)
             ) securityHeader;
    RDP_SERVER_REDIRECTION_PACKET serverRedirectionPDU;
           
    override string ToString()
    {
        return "Standard Security Server Redirection PDU";
    }
}

// 2.2.13.3.1   Enhanced Security Server Redirection PDU (TS_ENHANCED_SECURITY_SERVER_REDIRECTION)
message TS_ENHANCED_SECURITY_SERVER_REDIRECTION
{
    TS_SHARECONTROLHEADER shareControlHeader;
    ushort pad2Octets;
    RDP_SERVER_REDIRECTION_PACKET serverRedirectionPDU;
    byte pad1Octet;
           
    override string ToString()
    {
        return "Enhanced Security Server Redirection PDU";
    }
}

//  2.2.14.1.1   RTT Measure Request (RDP_RTT_REQUEST)
type RDP_RTT_REQUEST
{
    byte headerLength where value == 0x06;
    byte headerTypeId where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, 
        "RDPBCGR", "headerTypeId", "RDP_RTT_REQUEST", value);
    ushort sequenceNumber;
    RdpRttRequestType requestType;
           
    override string ToString()
    {
        return "RTT Measure Request, sequenceNumber: " + sequenceNumber.ToString() + 
            ", requestType: " + EnumToStringInSummary<RDPBCGR.RdpRttRequestType>(requestType);
    }
}

pattern RdpRttRequestType = enum ushort
{
    RttRequestInSecurityHeaderOrTunnalSubHeader = 0x0001,
    RttRequestInAutoDetectRequestPdu = 0x1001
}; // do not add ...

//  2.2.14.1.2   Bandwidth Measure Start (RDP_BW_START)
type RDP_BW_START
{
    byte headerLength where value == 0x06;
    byte headerTypeId where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, 
        "RDPBCGR", "headerTypeId", "RDP_RTT_REQUEST", value);
    ushort sequenceNumber;
    RdpBWStartRequestType requestType;
    
    override string ToString()
    {
        return "Bandwidth Measure Start, sequenceNumber: " + sequenceNumber.ToString() + 
            ", requestType: " + EnumToStringInSummary<RDPBCGR.RdpBWStartRequestType>(requestType);
    }
}

pattern RdpBWStartRequestType = enum ushort
{
    RdpBWStartInSecurityHeaderOrReliableTunnalSubHeader = 0x0014,
    RdpBWStartInLossyTunnalSubHeader = 0x0114,
    RdpBWStartInAutoDetectRequestPdu = 0x1014
}; // do not add ...

//  2.2.14.1.3   Bandwidth Measure Payload (RDP_BW_PAYLOAD)
type RDP_BW_PAYLOAD
{
    byte headerLength where value == 0x08;
    byte headerTypeId where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, 
        "RDPBCGR", "headerTypeId", "RDP_BW_PAYLOAD", value);
    ushort sequenceNumber;
    ushort requestType where value == 0x0002;
    ushort payloadLength;
    binary payload with BinaryEncoding{Length = payloadLength};
           
    override string ToString()
    {
        return "Bandwidth Measure Payload,sequenceNumber: " + sequenceNumber.ToString();
    }
}

//  2.2.14.1.4   Bandwidth Measure Stop (RDP_BW_STOP)
type RDP_BW_STOP
{
    byte headerLength where value == 0x06 || value == 0x08;
    byte headerTypeId where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, 
        "RDPBCGR", "headerTypeId", "RDP_BW_STOP", value);
    ushort sequenceNumber;
    RdpBWStopRequestType requestType;
    optional [|requestType == RdpBWStopRequestType.RdpBWStopInAutoDetectRequestPdu|] 
        ushort payloadLength;
    optional [|payloadLength != nothing|] binary payload 
        with BinaryEncoding{Length = payloadLength as ushort};
    
    override string ToString()
    {
        return "Bandwidth Measure Stop, sequenceNumber: " + sequenceNumber.ToString() + 
            ", requestType: " + EnumToStringInSummary<RDPBCGR.RdpBWStopRequestType>(requestType);
    }
}

pattern RdpBWStopRequestType = enum ushort
{
    RdpBWStopInSecurityHeaderOrReliableTunnalSubHeader = 0x0429,
    RdpBWStopInLossyTunnalSubHeader = 0x0629,
    RdpBWStopInAutoDetectRequestPdu = 0x002B,
}; // do not add ...

// 2.2.14.1.5   Network Characteristics Result (RDP_NETCHAR_RESULT)
type RDP_NETCHAR_RESULT
{
    byte headerLength where value == 0x0E || value == 0x12;
    byte headerTypeId where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, 
        "RDPBCGR", "headerTypeId", "RDP_NETCHAR_RESULT", value);
    ushort sequenceNumber;
    RdpNetcharResultRequestType requestType where ValidationCheckEnumValue(InRange<RdpNetcharResultRequestType>(value), 
        null, true, ReferenceType.Type, "RDPBCGR", "requestType", "RDP_NETCHAR_RESULT", "0x0840, 0x0880, 0x08C0", value);
    optional [|(requestType == RdpNetcharResultRequestType.BaseRTTAndAverageRTT || 
            requestType == RdpNetcharResultRequestType.BaseRTTAndBandwidthAndAverageRTT
            )|] uint baseRTT;
    optional [|(requestType == RdpNetcharResultRequestType.BandwidthAndAverageRTT || 
            requestType == RdpNetcharResultRequestType.BaseRTTAndBandwidthAndAverageRTT
            )|] uint bandwidth;
    optional [|requestType in {RdpNetcharResultRequestType.BaseRTTAndAverageRTT, RdpNetcharResultRequestType.BandwidthAndAverageRTT, 
        RdpNetcharResultRequestType.BaseRTTAndBandwidthAndAverageRTT}|] uint averageRTT;
           
    override string ToString()
    {
        string summary = "Network Characteristics Result, requestType: " + EnumToStringInSummary<RDPBCGR.RdpNetcharResultRequestType>(requestType);
        if (baseRTT != nothing)
        {
            summary += ", baseRTT: " + baseRTT.ToString();
        }
        if (bandwidth != nothing)
        {
            summary += ", bandwidth: " + bandwidth.ToString();
        }
        if (averageRTT != nothing)
        {
            summary += ", averageRTT: " + averageRTT.ToString();
        }
        return summary;
    }
}

pattern RdpNetcharResultRequestType = enum ushort
{
    BaseRTTAndAverageRTT   = 0x0840,
    BandwidthAndAverageRTT  = 0x0880,
    BaseRTTAndBandwidthAndAverageRTT = 0x08C0,
    ...
};

//  2.2.14.2.1   RTT Measure Response (RDP_RTT_RESPONSE)
type RDP_RTT_RESPONSE
{
    byte headerLength where value == 0x06;
    byte headerTypeId where ValidationCheckValue(value == 0x01, null, true, ReferenceType.Type, 
        "RDPBCGR", "headerTypeId", "RDP_RTT_RESPONSE", "0x01", value);
    ushort sequenceNumber;
    ushort responseType where value == 0;
               
    override string ToString()
    {
        return "RTT Measure Response, sequenceNumber: " + sequenceNumber.ToString();
    }
}

//  2.2.14.2.2   Bandwidth Measure Results (RDP_BW_RESULTS)
type RDP_BW_RESULTS
{
    byte headerLength where value == 0x0E;
    byte headerTypeId where ValidationCheckValue(value == 0x01, null, true, ReferenceType.Type, 
        "RDPBCGR", "headerLength", "RDP_BW_RESULTS", "0x01", value);
    ushort sequenceNumber;
    RdpBWResultsResponseType responseType;
    uint timeDelta;
    uint byteCount;
            
    override string ToString()
    {
        return "Bandwidth Measure Results, sequenceNumber: " + sequenceNumber.ToString() + 
            ", responseType: " + EnumToStringInSummary<RDPBCGR.RdpBWResultsResponseType>(responseType) + 
            ", timeDelta: " + timeDelta.ToString() + ", byteCount: " + byteCount.ToString();
    }
}

pattern RdpBWResultsResponseType = enum ushort
{
    RdpBWResultsInConnectionPhase    = 0x0003,
    RdpBWResultsAfterConnectionPhase  = 0x000B
}; // do not add ...

// 2.2.14.2.3   Network Characteristics Sync (RDP_NETCHAR_SYNC)
type RDP_NETCHAR_SYNC
{
    byte headerLength where value == 0x0E;
    byte headerTypeId where ValidationCheckValue(value == 0x01, null, true, ReferenceType.Type, 
        "RDPBCGR", "headerLength", "RDP_NETCHAR_SYNC", "0x01", value);
    ushort sequenceNumber;
    ushort responseType where value == 0x0018;
    uint bandwidth;
    uint rtt;
           
    override string ToString()
    {
        return "Network Characteristics Sync, sequenceNumber: " + sequenceNumber.ToString() + 
            ", bandwidth: " + bandwidth.ToString() + ", rtt: " + rtt.ToString();
    }
}

// 2.2.14.3 Server Auto-Detect Request PDU
message ServerAutoDetectRequestPdu[TSUDSCSec1EncryptionLevel EncryptionLevel, TSUDSCSec1EncryptionMethod EncryptionMethod]
{
    optional (
              ([|(EncryptionLevel == TSUDSCSec1EncryptionLevel.ENCRYPTION_LEVEL_LOW) |
                 (EncryptionLevel == TSUDSCSec1EncryptionLevel.ENCRYPTION_LEVEL_NONE)|] TS_SECURITY_HEADER) |
              ([|EncryptionMethod in {TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_40BIT,
                                      TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_128BIT,
                                      TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_56BIT}|] TS_SECURITY_HEADER1) |
              ([|(EncryptionMethod == TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_FIPS)|] TS_SECURITY_HEADER2)
             ) securityHeader;

    ([|CurrentByte(stream) == 0x06|] (RDP_RTT_REQUEST | RDP_BW_START | RDP_BW_STOP) | 
    [|CurrentByte(stream) == 0x08|] (RDP_BW_PAYLOAD | RDP_BW_STOP) | 
    [|CurrentByte(stream) == 0x0E || CurrentByte(stream) == 0x12|] RDP_NETCHAR_RESULT
    ) autoDetectReqPduData;
           
    override string ToString()
    {
        return "Server Auto-Detect Request PDU, AutoDetectReqPduData: " + autoDetectReqPduData.ToString();
    }
}

//  2.2.14.4    Client Auto-Detect Response PDU
message ClientAutoDetectResponsePdu[TSUDSCSec1EncryptionLevel EncryptionLevel, TSUDSCSec1EncryptionMethod EncryptionMethod]
{
    optional (([|EncryptionLevel == TSUDSCSec1EncryptionLevel.ENCRYPTION_LEVEL_NONE|] TS_SECURITY_HEADER) |
              ([|EncryptionMethod in {TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_40BIT,
                                      TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_128BIT,
                                      TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_56BIT}|] TS_SECURITY_HEADER1) |
              ([|(EncryptionMethod == TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_FIPS)|] TS_SECURITY_HEADER2)
             ) SecurityHeader;

    ([|CurrentByte(stream) == 0x06|] RDP_RTT_RESPONSE | 
    [|CurrentByte(stream) == 0x0E|] (RDP_BW_RESULTS | RDP_NETCHAR_SYNC)
    ) autoDetectRspPduData;
           
    override string ToString()
    {
        return "Client Auto-Detect Response PDU, autoDetectRspPduData: " + autoDetectRspPduData.ToString();
    }
}

// Encrypted message
message EncryptedMessage[TSUDSCSec1EncryptionLevel EncryptionLevel, TSUDSCSec1EncryptionMethod EncryptionMethod]
{
    optional (
              ([|EncryptionLevel == TSUDSCSec1EncryptionLevel.ENCRYPTION_LEVEL_LOW|] TS_SECURITY_HEADER) |
              ([|EncryptionMethod in {TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_40BIT,
                                      TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_128BIT,
                                      TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_56BIT}|] TS_SECURITY_HEADER1) |
              ([|(EncryptionMethod == TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_FIPS)|] TS_SECURITY_HEADER2)
             ) SecurityHeader;
    
    binary EncryptedData;
           
    override string ToString()
    {
        ushort flag;
        if (SecurityHeader is header:TS_SECURITY_HEADER)
        {
            flag = header.$"flags";
        }
        else if (SecurityHeader is header1:TS_SECURITY_HEADER1)
        {
            flag = header1.$"flags";
        }
        else 
        {
            flag = (SecurityHeader as TS_SECURITY_HEADER2).$"flags";
        }
        if ((flag & TSSecurityHeaderFlags.SEC_EXCHANGE_PKT) == TSSecurityHeaderFlags.SEC_EXCHANGE_PKT)
        {
            return "Client Security Exchange PDU, Encrypted";
        }
        else if ((flag & TSSecurityHeaderFlags.SEC_TRANSPORT_REQ) == TSSecurityHeaderFlags.SEC_TRANSPORT_REQ)
        {
            return "Server Initiate Multitransport Request PDU, Encrypted";
        }
        else if ((flag & TSSecurityHeaderFlags.RDP_SEC_TRANSPORT_RSP) == TSSecurityHeaderFlags.RDP_SEC_TRANSPORT_RSP)
        {
            return "Client Initiate Multitransport Error PDU, Encrypted";
        }
        else if ((flag & TSSecurityHeaderFlags.SEC_INFO_PKT) == TSSecurityHeaderFlags.SEC_INFO_PKT)
        {
            return "Client Info PDU, Encrypted";
        }
        else if ((flag & TSSecurityHeaderFlags.SEC_LICENSE_PKT) == TSSecurityHeaderFlags.SEC_LICENSE_PKT)
        {
            return "Server License Error PDU - Valid Client, Encrypted";
        }
        else if ((flag & TSSecurityHeaderFlags.SEC_REDIRECTION_PKT) == TSSecurityHeaderFlags.SEC_REDIRECTION_PKT)
        {
            return "Standard Security Server Redirection PDU, Encrypted";
        }
        else if ((flag & TSSecurityHeaderFlags.SEC_AUTODETECT_REQ) == TSSecurityHeaderFlags.SEC_AUTODETECT_REQ)
        {
            return "Server Auto-Detect Request PDU, Encrypted";
        }
        else if ((flag & TSSecurityHeaderFlags.SEC_AUTODETECT_RSP) == TSSecurityHeaderFlags.SEC_AUTODETECT_RSP)
        {
            return "Client Auto-Detect Response PDU, Encrypted";
        }
        return "Encrypted Message";
    }
}

// 2.2.15.1   Server Initiate Multitransport Request
message ServerInitiateMultitransportRequest[TSUDSCSec1EncryptionLevel EncryptionLevel, TSUDSCSec1EncryptionMethod EncryptionMethod]
{
    optional (
              ([|EncryptionLevel in {TSUDSCSec1EncryptionLevel.ENCRYPTION_LEVEL_LOW,
                                     TSUDSCSec1EncryptionLevel.ENCRYPTION_LEVEL_NONE}|] TS_SECURITY_HEADER) |
              ([|EncryptionMethod in {TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_40BIT,
                                      TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_128BIT,
                                      TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_56BIT}|] TS_SECURITY_HEADER1) |
              ([|(EncryptionMethod == TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_FIPS)|] TS_SECURITY_HEADER2)
             ) securityHeader;
     uint requestId;
     RequestedProtocolType requestedProtocol;
     ushort reserved where ValidationCheckReservedZero(value == 0, this, true, 
        ReferenceType.Message, "RDPBCGR", "reserved", "ServerInitiateMultitransportRequest", value);

     binary securityCookie with BinaryEncoding{Length = 16};

    override string ToString()
    {
        return "Server Initiate Multitransport Request, requestId: " + requestId.ToString() + 
            ", requestedProtocol: " + EnumToStringInSummary<RDPBCGR.RequestedProtocolType>(requestedProtocol);
    }
}

pattern RequestedProtocolType = enum ushort
{
    INITITATE_REQUEST_PROTOCOL_UDPFECR = 0x0001,
    INITITATE_REQUEST_PROTOCOL_UDPFECL = 0x0002,
    ...
};

pattern HrResponseType = enum uint
{
    E_ABORT = 0x80004004,
    S_OK = 0x00000000,
    ...
};

// 2.2.15.2   Client Initiate Multitransport Error
message ClientInitiateMultitransportError[TSUDSCSec1EncryptionLevel EncryptionLevel, TSUDSCSec1EncryptionMethod EncryptionMethod]
{
    optional (
              ([|EncryptionLevel == TSUDSCSec1EncryptionLevel.ENCRYPTION_LEVEL_NONE|] TS_SECURITY_HEADER) |
              ([|EncryptionMethod in {TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_40BIT,
                                      TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_128BIT,
                                      TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_56BIT}|] TS_SECURITY_HEADER1) |
              ([|(EncryptionMethod == TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_FIPS)|] TS_SECURITY_HEADER2)
             ) securityHeader;
     uint requestId;
     HrResponseType hrResponse;
           
    override string ToString()
    {
        return "Client Initiate Multitransport Error, requestId: " + requestId.ToString() + 
            ", hrResponse: " + EnumToStringInSummary<RDPBCGR.HrResponseType>(hrResponse);
    }
}

// 2.2.16.1  Server Heartbeat PDU
message TSServerHeartbeatPDU[TSUDSCSec1EncryptionLevel EncryptionLevel, TSUDSCSec1EncryptionMethod EncryptionMethod]
{
    optional (
              ([|EncryptionLevel in {TSUDSCSec1EncryptionLevel.ENCRYPTION_LEVEL_LOW,
                                     TSUDSCSec1EncryptionLevel.ENCRYPTION_LEVEL_NONE}|] TS_SECURITY_HEADER) |
              ([|EncryptionMethod in {TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_40BIT,
                                      TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_128BIT,
                                      TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_56BIT}|] TS_SECURITY_HEADER1) |
              ([|(EncryptionMethod == TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_FIPS)|] TS_SECURITY_HEADER2)
             ) securityHeader;
    byte reserved where ValidationCheckReservedZero(value == 0, this, true, 
        ReferenceType.Message, "RDPBCGR", "reserved", "TSServerHeartbeatPDU", value);
    byte period;
    byte count1;
    byte count2;
    override string ToString()
    {
        return "Server Heartbeat PDU, period: " + period.ToString();
    }
}

//2.2.17.1 RDSTLS Capabilities PDU
message RDSTLSCapabilitiesPdu
{
    ushort Version where ValidationCheckReservedZero(value == 1, null, true, ReferenceType.Type, 
        "RDPBCGR", "Version", "RDSTLSCapabilitiesPDU", value);
    ushort PduType where ValidationCheckReservedZero(value == 1, null, true, ReferenceType.Type, 
        "RDPBCGR", "PduType", "RDSTLSCapabilitiesPDU", value);
    ushort DataType where ValidationCheckReservedZero(value == 1, null, true, ReferenceType.Type, 
        "RDPBCGR", "DataType", "RDSTLSCapabilitiesPDU", value);
    ushort SupportedVersions where ValidationCheckReservedZero(value == 1, null, true, ReferenceType.Type, 
        "RDPBCGR", "SupportedVersions", "RDSTLSCapabilitiesPDU", value);

    override string ToString()
    {
        return "RDSTLS Capabilities PDU, SupportedVersions: " + SupportedVersions.ToString();
    }
}

// 2.2.17.2 RDSTLS Authentication Request PDU with Password Credentials
message RDSTLSAuthRequestPduWithPasswordCredentials
{
    ushort Version where ValidationCheckReservedZero(value == 1, null, true, ReferenceType.Type, 
        "RDPBCGR", "Version", "RDSTLSCapabilitiesPDU", value);
    ushort PduType where ValidationCheckReservedZero(value == 2, null, true, ReferenceType.Type, 
        "RDPBCGR", "PduType", "RDSTLSCapabilitiesPDU", value);
    ushort DataType where ValidationCheckReservedZero(value == 1, null, true, ReferenceType.Type, 
        "RDPBCGR", "DataType", "RDSTLSCapabilitiesPDU", value);
    ushort RedirectionGuidLength;
    binary RedirectionGuid with BinaryEncoding{Length = RedirectionGuidLength};
    ushort UserNameLength;
    string UserName with BinaryEncoding{TextEncoding = TextEncoding.Unicode, Length = UserNameLength / 2};
    ushort DomainLength;
    string Domain with BinaryEncoding{TextEncoding = TextEncoding.Unicode, Length = DomainLength / 2};
    ushort PasswordLength;
    binary Password with BinaryEncoding{Length = PasswordLength};

    override string ToString()
    {
        return "RDSTLS Authentication Request PDU with Password Credentials, UserName: " + 
            UserName.ToString() + ", Domain: " + Domain.ToString();
    }
}

// 2.2.17.3 RDSTLS Authentication Request PDU with Auto-Reconnect Cookie
message RDSTLSAuthRequestPduWithAutoReconnectCookie
{
    ushort Version where ValidationCheckReservedZero(value == 1, null, true, ReferenceType.Type, 
        "RDPBCGR", "Version", "RDSTLSCapabilitiesPDU", value);
    ushort PduType where ValidationCheckReservedZero(value == 2, null, true, ReferenceType.Type, 
        "RDPBCGR", "PduType", "RDSTLSCapabilitiesPDU", value);
    ushort DataType where ValidationCheckReservedZero(value == 2, null, true, ReferenceType.Type, 
        "RDPBCGR", "DataType", "RDSTLSCapabilitiesPDU", value);
    uint SessionID;
    ushort AutoReconnectCookieLength;
    binary AutoReconnectCookie with BinaryEncoding{Length = AutoReconnectCookieLength};

    override string ToString()
    {
        return "RDSTLS Authentication Request PDU with Auto-Reconnect Cookie, SessionID: " + SessionID.ToString();
    }
}

// 2.2.17.4 RDSTLS Authentication Response PDU
message RDSTLSAuthResponsePdu
{
    ushort Version where ValidationCheckReservedZero(value == 1, null, true, ReferenceType.Type, 
        "RDPBCGR", "Version", "RDSTLSCapabilitiesPDU", value);
    ushort PduType where ValidationCheckReservedZero(value == 4, null, true, ReferenceType.Type, 
        "RDPBCGR", "PduType", "RDSTLSCapabilitiesPDU", value);
    ushort DataType where ValidationCheckReservedZero(value == 1, null, true, ReferenceType.Type, 
        "RDPBCGR", "DataType", "RDSTLSCapabilitiesPDU", value);
    RDSTLSResultCode ResultCode;

    override string ToString()
    {
        return "RDSTLS Authentication Response PDU, ResultCode: " + EnumToString<RDSTLSResultCode>(ResultCode);
    }
}

pattern RDSTLSResultCode = enum uint
{
    RDSTLS_RESULT_SUCCESS = 0x00000000
        with Documentation
            {Description = "User authentication succeeded."},
    RDSTLS_RESULT_ACCESS_DENIED = 0x00000005
        with Documentation
            {Description = "The user does not have permission to access the server."},
    RDSTLS_RESULT_LOGON_FAILURE = 0x0000052e
        with Documentation
            {Description = "The username is unknown or the supplied password is incorrect."},
    RDSTLS_RESULT_INVALID_LOGON_HOURS = 0x00000530
        with Documentation
            {Description = "The user account has time restrictions and cannot be accessed at this time."},
    RDSTLS_RESULT_PASSWORD_EXPIRED = 0x00000532
        with Documentation
            {Description = "The password associated with the user account has expired."},
    RDSTLS_RESULT_ACCOUNT_DISABLED = 0x00000533
        with Documentation
            {Description = "The user account is currently disabled."},
    RDSTLS_RESULT_PASSWORD_MUST_CHANGE = 0x00000773
        with Documentation
            {Description = "The password associated with the user account has to be changed."},
    RDSTLS_RESULT_ACCOUNT_LOCKED_OUT = 0x00000775
        with Documentation
            {Description = "The user account is currently locked out and cannot be accessed."},
    ...
};


// Structures in [MS-RDPEGDI]
// [MS-RDPEGDI] 2.2.1.1   Color Table Cache Capability Set (TS_COLORTABLE_CAPABILITYSET) 
type TS_COLORTABLE_CAPABILITYSET
{
    ushort capabilitySetType where value == 0x000A;
  
    ushort lengthCapability;
  
    ushort colorTableCacheSize;
           
    ushort pad2octets;

    override string ToString()
    {
        return "TS_COLORTABLE_CAPABILITYSET, ColorTableCacheSize:" + colorTableCacheSize.ToString();
    }
}
with Documentation
       {Applicability = "2.2.1.1",
        Description = "The TS_COLORTABLE_CAPABILITYSET structure is an unused capability set that advertises the size of the color table cache used in conjunction with the Cache Color Table Secondary Drawing Order (see section 2.2.2.2.1.2.4) and is based on the capability set in [T128] section 8.2.8. This capability is sent by both client and server."};

// [MS-RDPEGDI] 2.2.1.2   DrawNineGrid Cache Capability Set (TS_DRAW_NINEGRID_CAPABILITYSET)
pattern DrawNineGridSupportLevelValue = enum uint
{
    DRAW_NINEGRID_NO_SUPPORT = 0x00000000,
    DRAW_NINEGRID_SUPPORTED = 0x00000001,
    DRAW_NINEGRID_SUPPORTED_REV2 = 0x00000002,
    ...
};
        
type TS_DRAW_NINEGRID_CAPABILITYSET
{
    ushort capabilitySetType  where value == 0x0015;
     
    ushort lengthCapability;
           
    DrawNineGridSupportLevelValue drawNineGridSupportLevel;
           
    ushort drawNineGridCacheSize;
           
    ushort drawNineGridCacheEntries;

    override string ToString()
    {
        return "TS_DRAW_NINEGRID_CAPABILITYSET, " + EnumToString<DrawNineGridSupportLevelValue>(drawNineGridSupportLevel);
    }
}        
with Documentation
       {Applicability = "2.2.1.2",
        Description = "The TS_DRAW_NINEGRID_CAPABILITYSET structure is used to advertise support for NineGrid bitmap caching and rendering (see sections 2.2.2.2.1.1.2.21, 2.2.2.2.1.1.2.22, and 2.2.2.2.1.3.4). This capability set is sent only from client to server."};

// [MS-RDPEGDI] 2.2.1.3   Draw GDI+ Capability Set (TS_DRAW_GDIPLUS_CAPABILITYSET)
pattern DrawGDIPlusSupportLevelValue = enum uint
{
    TS_DRAW_GDIPLUS_DEFAULT = 0x00000000,
    TS_DRAW_GDIPLUS_SUPPORTED = 0x00000001,
    ...
};

pattern DrawGdiplusCacheLevelValue = enum uint
{
    TS_DRAW_GDIPLUS_CACHE_LEVEL_DEFAULT = 0x00000000,
    TS_DRAW_GDIPLUS_CACHE_LEVEL_ONE = 0x00000001,
    ...
};
          
type TS_DRAW_GDIPLUS_CAPABILITYSET
{
    ushort capabilitySetType where value == 0x0016;
           
    ushort lengthCapability;
    
    DrawGDIPlusSupportLevelValue drawGDIPlusSupportLevel;
           
    uint GdipVersion;
   
    DrawGdiplusCacheLevelValue drawGdiplusCacheLevel;
      
    TS_GDIPLUS_CACHE_ENTRIES GdipCacheEntries;
     
    TS_GDIPLUS_CACHE_CHUNK_SIZE GdipCacheChunkSize;
   
    TS_GDIPLUS_IMAGE_CACHE_PROPERTIES GdipImageCacheProperties;

    override string ToString()
    {
        return "TS_DRAW_GDIPLUS_CAPABILITYSET, " + EnumToString<DrawGDIPlusSupportLevelValue>(drawGDIPlusSupportLevel) + ", " + EnumToString<DrawGdiplusCacheLevelValue>(drawGdiplusCacheLevel);
    }
}    
with Documentation
       {Applicability = "2.2.1.3",
        Description = "The TS_DRAW_GDIPLUS_CAPABILITYSET structure is used to advertise the level of GDI+ 1.1 rendering and caching support and the GDI+ cache configuration. This capability is sent by both client and server. However, only the client initializes the GdipVersion, GdipCacheEntries, GdipCacheChunkSize, and GdipImageCacheProperties fields. The server uses this capability set only to advertise its level of GDI+ 1.1 rendering and caching support."};
    
// [MS-RDPEGDI] 2.2.1.3.1   GDI+ Cache Entries (TS_GDIPLUS_CACHE_ENTRIES)
type TS_GDIPLUS_CACHE_ENTRIES
{
    ushort GdipGraphicsCacheEntries;
           
    ushort GdipBrushCacheEntries;
           
    ushort GdipPenCacheEntries;
           
    ushort GdipImageCacheEntries;
           
    ushort GdipImageAttributesCacheEntries;
}
with Documentation
       {Applicability = "2.2.1.3.1",
        Description = "The TS_GDIPLUS_CACHE_ENTRIES structure specifies the total number of cache entries for the GDI+ Graphics, Brush, Pen, Image, and Image Attributes caches."};
        
// [MS-RDPEGDI] 2.2.1.3.2   GDI+ Cache Chunk Size (TS_GDIPLUS_CACHE_CHUNK_SIZE)
type TS_GDIPLUS_CACHE_CHUNK_SIZE
{
    ushort GdipGraphicsCacheChunkSize;
           
    ushort GdipObjectBrushCacheChunkSize;
           
    ushort GdipObjectPenCacheChunkSize;
           
    ushort GdipObjectImageAttributesCacheChunkSize;
}  
with Documentation
       {Applicability = "2.2.1.3.2",
        Description = "The TS_GDIPLUS_CACHE_CHUNK_SIZE structure specifies the maximum size of individual entries in the GDI+ Graphics, Brush, Pen, and Image Attributes caches."};
       
// [MS-RDPEGDI] 2.2.1.3.3   GDI+ Image Cache Properties (TS_GDIPLUS_IMAGE_CACHE_PROPERTIES)                        
type TS_GDIPLUS_IMAGE_CACHE_PROPERTIES
{
    ushort GdipObjectImageCacheChunkSize;
         
    ushort GdipObjectImageCacheTotalSize;
         
    ushort GdipObjectImageCacheMaxSize;
}
with Documentation
       {Applicability = "2.2.1.3.3",
        Description = "The TS_GDIPLUS_IMAGE_CACHE_PROPERTIES structure contains sizing information for the GDI+ Image cache."};
        
// [MS-RDPEGDI] 2.2.2.1   Orders Update (TS_UPDATE_ORDERS_PDU_DATA)       
type TS_UPDATE_ORDERS_PDU_DATA
{
    TS_SHAREDATAHEADER shareDataHeader;
  
    TSGraphicsUpdateUpdateType updateType where value == TSGraphicsUpdateUpdateType.UPDATETYPE_ORDERS;
           
    ushort pad2OctetsA;
           
    ushort numberOrders;
           
    ushort pad2OctetsB;
           
    (binary | any) orderData;

    override string ToString()
    {
        return "TS_UPDATE_ORDERS_PDU_DATA, NumberOrders: " + numberOrders.ToString();
    }
}
with Documentation
       {Applicability = "2.2.2.1",
        Description = "The TS_UPDATE_ORDERS_PDU_DATA structure contains primary, secondary, and alternate secondary drawing orders aligned on byte boundaries. "};
        
// [MS-RDPEGDI] 2.2.2.2   Fast-Path Orders Update (TS_FP_UPDATE_ORDERS)
type TS_FP_UPDATE_ORDERS : TS_FP_UPDATE_Base
{
    (optional [|updateHeader.compression == TSFPUpdateUpdateHeaderCompression.FASTPATH_OUTPUT_COMPRESSION_USED|] TSShareDataHeaderCompressedType) compressionFlags;
    ushort size;
    optional [|compressionFlags != nothing && ((compressionFlags as TSShareDataHeaderCompressedType).
        compressedFlags & TSShareDataHeaderCompressedFlags.PACKET_COMPRESSED) != 0|] binary CompressedData with BinaryEncoding{Length = size};
    optional [|compressionFlags == nothing || ((compressionFlags as TSShareDataHeaderCompressedType).
        compressedFlags & TSShareDataHeaderCompressedFlags.PACKET_COMPRESSED) == 0|] ushort numberOrders;
    optional [|compressionFlags == nothing || ((compressionFlags as TSShareDataHeaderCompressedType).
        compressedFlags & TSShareDataHeaderCompressedFlags.PACKET_COMPRESSED) == 0|] (binary | any) orderData with BinaryEncoding{Length = (size - 2)};

    override string ToString()
    {
        return "TS_FP_UPDATE_ORDERS";
    }
}  

// [MS-RDPEGDI] 2.2.2.2.1.1 Primary Drawing Orders
// [MS-RDPEGDI] 2.2.2.2.1.1.1 Common Data Types
type COORD_FIELD[ControlFlags ControlFlagsValue]
{
    ([|(ControlFlagsValue & ControlFlags.TS_DELTA_COORDINATES) != 0|] sbyte | short) signedValue;
}
        
type VARIABLE1_FIELD
{
    byte cbData;
    binary rgbData with BinaryEncoding{Length = cbData};
}

type VARIABLE2_FIELD
{
    ushort cbData;
    binary rgbData with BinaryEncoding{Length = cbData};
}

type VARIABLE2_DELTA_RECTS_FIELD[optional byte Number]
{
    ushort cbData;
    ([|Number != nothing|] DELTA_RECTS_FIELD[Number as byte] | binary) rgbData with BinaryEncoding{WidthForComposedType = cbData * 8 as int, Length = cbData};
}

type DELTA_PTS_FIELD[byte NumOfPoints]
{
    binary zeroBits with BinaryEncoding{Length = (NumOfPoints + 3) / 4};
    array<PackedSignedFormat> deltaEncodedPoints;
}

type VARIABLE1_DELTA_PTS_FIELD[optional byte Number]
{
    byte cbData;
    ([|Number != nothing|] DELTA_PTS_FIELD[Number as byte] | binary) rgbData with BinaryEncoding{WidthForComposedType = cbData * 8 as int, Length = cbData};
}

type PackedSignedFormat
{
    byte First;
    optional [|(First & 0x80) != 0|] byte Second;
    
    any Value()
    {
        if ((First & 0x80) == 0)
        {
            sbyte result = (First << 1) as sbyte;
            return (result >> 1) as sbyte;
        }
        else
        {
            short result = (First & 0x7F) as short;
            result = (((result << 8) | (Second as byte)) << 1) as short;
            return (result >> 1) as short;
        }
    }
    
    override string ToString()
    {
        return Value().ToString();
    }
}

type DELTA_RECTS_FIELD[byte NumOfRects]
{
    binary zeroBits with BinaryEncoding{Length = (NumOfRects + 1) / 2};
    array<PackedSignedFormat> deltaEncodedRectangles;
}

type ROP2_OPERATION
{
    Rop2Operation rop2Operation where ValidationCheckEnumValueTooManyItems(InRange<Rop2Operation>(value), null, false, ReferenceType.Type, "RDPBCGR", "rop2Operation", "ROP2_OPERATION", "ROP2_OPERATION", "[MS-RDPEGDI]");
}

pattern Rop2Operation = enum byte
{
    R2_BLACK            = 0x01,
    R2_NOTMERGEPEN      = 0x02,
    R2_MASKNOTPEN       = 0x03,
    R2_NOTCOPYPEN       = 0x04,
    R2_MASKPENNOT       = 0x05,
    R2_NOT              = 0x06,
    R2_XORPEN           = 0x07,
    R2_NOTMASKPEN       = 0x08,
    R2_MASKPEN          = 0x09,
    R2_NOTXORPEN        = 0x0A,
    R2_NOP              = 0x0B,
    R2_MERGENOTPEN      = 0x0C,
    R2_COPYPEN          = 0x0D,
    R2_MERGEPENNOT      = 0x0E,
    R2_MERGEPEN         = 0x0F,
    R2_WHITE            = 0x10,
    ...
};

type ROP3_OPERATION_INDEX
{
    byte rop3Index;
}

type TS_COLOR
{
    byte RedOrPaletteIndex;
    byte Green;
    byte Blue;
}

type FILL_MODE
{
    FillModeValue FillMode where ValidationCheckEnumValue(InRange<FillModeValue>(value), null, true, ReferenceType.Type, "RDPBCGR", "FillMode", "FILL_MODE", "0x01, 0x02", value);
}

pattern FillModeValue = enum byte
{
    ALTERNATE   = 0x01,
    WINDING     = 0x02,
    ...
};

// [MS-RDPEGDI] 2.2.2.2.1.1.2 Primary Drawing Order 
type PRIMARY_DRAWING_ORDER[byte Type]
{
    ControlFlags controlFlags where ((value & ControlFlags.TS_STANDARD) != 0 && (value & ControlFlags.TS_SECONDARY) == 0);
    optional [|(controlFlags & ControlFlags.TS_TYPE_CHANGE) != 0|] PrimaryDrawingOrderType orderType where ValidationCheckValid((value == nothing || InRange<PrimaryDrawingOrderType>(value as byte)), null, false, ReferenceType.Type, "RDPBCGR", "orderType", "PRIMARY_DRAWING_ORDER", "type of primary drawing order");
    array<byte> fieldFlags with BinaryEncoding{Length = CountFieldFlagsBytesNum(controlFlags, (orderType != nothing ? (orderType as PrimaryDrawingOrderType) : Type))};
    optional [|(controlFlags & ControlFlags.TS_BOUNDS) != 0 && (controlFlags & ControlFlags.TS_ZERO_BOUNDS_DELTAS) == 0|] Bounds bounds;
    ([|orderType == 0x00 || (orderType == nothing && Type == 0x00)|] DSTBLT_ORDER[controlFlags, fieldFlags] |
     [|orderType == 0x01 || (orderType == nothing && Type == 0x01)|] PATBLT_ORDER[controlFlags, fieldFlags] |
     [|orderType == 0x02 || (orderType == nothing && Type == 0x02)|] SCRBLT_ORDER[controlFlags, fieldFlags] |
     [|orderType == 0x07 || (orderType == nothing && Type == 0x07)|] DRAWNINEGRID_ORDER[controlFlags, fieldFlags] |
     [|orderType == 0x08 || (orderType == nothing && Type == 0x08)|] MULTI_DRAWNINEGRID_ORDER[controlFlags, fieldFlags] |
     [|orderType == 0x09 || (orderType == nothing && Type == 0x09)|] LINETO_ORDER[controlFlags, fieldFlags] |
     [|orderType == 0x0A || (orderType == nothing && Type == 0x0A)|] OPAQUERECT_ORDER[controlFlags, fieldFlags] |
     [|orderType == 0x0B || (orderType == nothing && Type == 0x0B)|] SAVEBITMAP_ORDER[controlFlags, fieldFlags] |
     [|orderType == 0x0D || (orderType == nothing && Type == 0x0D)|] MEMBLT_ORDER[controlFlags, fieldFlags] |
     [|orderType == 0x0E || (orderType == nothing && Type == 0x0E)|] MEM3BLT_ORDER[controlFlags, fieldFlags] |
     [|orderType == 0x0F || (orderType == nothing && Type == 0x0F)|] MULTI_DSTBLT_ORDER[controlFlags, fieldFlags] |
     [|orderType == 0x10 || (orderType == nothing && Type == 0x10)|] MULTI_PATBLT_ORDER[controlFlags, fieldFlags] |
     [|orderType == 0x11 || (orderType == nothing && Type == 0x11)|] MULTI_SCRBLT_ORDER[controlFlags, fieldFlags] |
     [|orderType == 0x12 || (orderType == nothing && Type == 0x12)|] MULTI_OPAQUERECT_ORDER[controlFlags, fieldFlags] |
     [|orderType == 0x13 || (orderType == nothing && Type == 0x13)|] FASTINDEX_ORDER[controlFlags, fieldFlags] |
     [|orderType == 0x14 || (orderType == nothing && Type == 0x14)|] POLYGON_SC_ORDER[controlFlags, fieldFlags] |
     [|orderType == 0x15 || (orderType == nothing && Type == 0x15)|] POLYGON_CB_ORDER[controlFlags, fieldFlags] |
     [|orderType == 0x16 || (orderType == nothing && Type == 0x16)|] POLYLINE_ORDER[controlFlags, fieldFlags] |
     [|orderType == 0x18 || (orderType == nothing && Type == 0x18)|] FASTGLYPH_ORDER[controlFlags, fieldFlags] |
     [|orderType == 0x19 || (orderType == nothing && Type == 0x19)|] ELLIPSE_SC_ORDER[controlFlags, fieldFlags] |
     [|orderType == 0x1A || (orderType == nothing && Type == 0x1A)|] ELLIPSE_CB_ORDER[controlFlags, fieldFlags] |
     [|orderType == 0x1B || (orderType == nothing && Type == 0x1B)|] GLYPHINDEX_ORDER[controlFlags, fieldFlags] |
     binary) primaryOrderData;
     
     override string ToString()
     {
         byte primaryOrderType = (orderType != nothing) ? (orderType as byte) : Type;
         switch (primaryOrderType)
         {
             case 0x00 =>
                return "DSTBLT_ORDER";
             case 0x01 =>
                return "PATBLT_ORDER";
             case 0x02 =>
                return "SCRBLT_ORDER";
             case 0x07 =>
                return "DRAWNINEGRID_ORDER";
             case 0x08 =>
                return "MULTI_DRAWNINEGRID_ORDER";
             case 0x09 =>
                return "LINETO_ORDER";
             case 0x0A =>
                return "OPAQUERECT_ORDER";
             case 0x0B =>
                return "SAVEBITMAP_ORDER";
             case 0x0D =>
                return "MEMBLT_ORDER";
             case 0x0E =>
                return "MEM3BLT_ORDER";
             case 0x0F =>
                return "MULTI_DSTBLT_ORDER";
             case 0x10 =>
                return "MULTI_PATBLT_ORDER";
             case 0x11 =>
                return "MULTI_SCRBLT_ORDER";
             case 0x12 =>
                return "MULTI_OPAQUERECT_ORDER";
             case 0x13 =>
                return "FASTINDEX_ORDER";
             case 0x14 =>
                return "POLYGON_SC_ORDER";
             case 0x15 =>
                return "POLYGON_CB_ORDER";
             case 0x16 =>
                return "POLYLINE_ORDER";
             case 0x18 =>
                return "FASTGLYPH_ORDER";
             case 0x19 =>
                return "ELLIPSE_SC_ORDER";
             case 0x1A =>
                return "ELLIPSE_CB_ORDER";
             case 0x1B =>
                return "GLYPHINDEX_ORDER";
             default =>
                return "Unknown PRIMARY_DRAWING_ORDER";
         }
     }
}

pattern ControlFlags = flags byte
{
    TS_STANDARD             = 0x01
        with Documentation
            {Description = "The order is a primary drawing order."},
    TS_SECONDARY            = 0x02, // No such flag definition in TD
    TS_BOUNDS               = 0x04
        with Documentation
            {Description = "The order has a bounding rectangle."},
    TS_TYPE_CHANGE          = 0x08
        with Documentation
            {Description = "The order type has changed and that the orderType field is present."},
    TS_DELTA_COORDINATES    = 0x10
        with Documentation
            {Description = "All of the Coord-type fields in the order are specified as 1-byte signed deltas from their previous values."},
    TS_ZERO_BOUNDS_DELTAS   = 0x20
        with Documentation
            {Description = "The previous bounding rectangle MUST be used, as the bounds have not changed."},
    TS_ZERO_FIELD_BYTE_BIT0 = 0x40
        with Documentation
            {Description = "Used in conjunction with the TS_ZERO_FIELD_BYTE_BIT1 (0x80) flag to form a 2-bit count (so maximum of 3) of the number of field flag bytes (present in the fieldFlags field) that are zero and not present, counted from the end of the set of field flag bytes."},
    TS_ZERO_FIELD_BYTE_BIT1 = 0x80
        with Documentation
            {Description = "Used in conjunction with the TS_ZERO_FIELD_BYTE_BIT0 (0x40) flag to form a 2-bit count (so maximum of 3) of the number of field flag bytes (present in the fieldFlags field) that are zero and not present, counted from the end of the set of field flag bytes."},
};

pattern PrimaryDrawingOrderType = enum byte
{
    TS_ENC_DSTBLT_ORDER             = 0x00,
    TS_ENC_PATBLT_ORDER             = 0x01,
    TS_ENC_SCRBLT_ORDER             = 0x02,
    TS_ENC_DRAWNINEGRID_ORDER       = 0x07,
    TS_ENC_MULTI_DRAWNINEGRID_ORDER = 0x08,
    TS_ENC_LINETO_ORDER             = 0x09,
    TS_ENC_OPAQUERECT_ORDER         = 0x0A,
    TS_ENC_SAVEBITMAP_ORDER         = 0x0B,
    TS_ENC_MEMBLT_ORDER             = 0x0D,
    TS_ENC_MEM3BLT_ORDER            = 0x0E,
    TS_ENC_MULTIDSTBLT_ORDER        = 0x0F,
    TS_ENC_MULTIPATBLT_ORDER        = 0x10,
    TS_ENC_MULTISCRBLT_ORDER        = 0x11,
    TS_ENC_MULTIOPAQUERECT_ORDER    = 0x12,
    TS_ENC_FAST_INDEX_ORDER         = 0x13,
    TS_ENC_POLYGON_SC_ORDER         = 0x14,
    TS_ENC_POLYGON_CB_ORDER         = 0x15,
    TS_ENC_POLYLINE_ORDER           = 0x16,
    TS_ENC_FAST_GLYPH_ORDER         = 0x18,
    TS_ENC_ELLIPSE_SC_ORDER         = 0x19,
    TS_ENC_ELLIPSE_CB_ORDER         = 0x1A,
    TS_ENC_INDEX_ORDER              = 0x1B,
    ...
};

// Mapping the number of fields of each primary drawing order
const map<byte, int> PrimaryDrawingOrderNumOfFieldsMap = 
{
    0x00 -> 5,
    0x01 -> 12,
    0x02 -> 7,
    0x07 -> 5,
    0x08 -> 7,
    0x09 -> 10,
    0x0A -> 7,
    0x0B -> 6,
    0x0D -> 9,
    0x0E -> 16,
    0x0F -> 7,
    0x10 -> 14,
    0x11 -> 9,
    0x12 -> 9,
    0x13 -> 15,
    0x14 -> 7,
    0x15 -> 13,
    0x16 -> 7,
    0x18 -> 15,
    0x19 -> 7,
    0x1A -> 13,
    0x1B -> 22,
};

uint CountFieldFlagsBytesNum(ControlFlags controlFlags, byte orderType)
{
    if (!InRange<PrimaryDrawingOrderType>(orderType))
    {
        return 0;
    }
    uint maxFieldFlagsBytes = (PrimaryDrawingOrderNumOfFieldsMap[orderType] + 8) / 8 as uint;
    uint zeroBitsCount = 0;
    if ((controlFlags & ControlFlags.TS_ZERO_FIELD_BYTE_BIT1) != 0)
    {
        zeroBitsCount += 2;
    }
    if ((controlFlags & ControlFlags.TS_ZERO_FIELD_BYTE_BIT0) != 0)
    {
        zeroBitsCount += 1;
    }
    if (maxFieldFlagsBytes < zeroBitsCount)
    {
         return 0;
    }
    return (maxFieldFlagsBytes - zeroBitsCount) as uint;
}

pattern BoundsFlag = flags byte
{
    TS_BOUND_LEFT           = 0x01
        with Documentation
            {Description = "The left bound is present and encoded as a 2-byte, little-endian ordered value."},
    TS_BOUND_TOP            = 0x02
        with Documentation
            {Description = "The top bound is present and encoded as a 2-byte, little-endian ordered value."},
    TS_BOUND_RIGHT          = 0x04
        with Documentation
            {Description = "The right bound is present and encoded as a 2-byte, little-endian ordered value."},
    TS_BOUND_BOTTOM         = 0x08
        with Documentation
            {Description = "The bottom bound is present and encoded as a 2-byte, little-endian ordered value."},
    TS_BOUND_DELTA_LEFT     = 0x10
        with Documentation
            {Description = "The left bound is present and encoded as a 1-byte signed value used as an offset (-128 to 127) from the previous value."},
    TS_BOUND_DELTA_TOP      = 0x20
        with Documentation
            {Description = "The top bound is present and encoded as a 1-byte signed value used as an offset (-128 to 127) from the previous value."},
    TS_BOUND_DELTA_RIGHT    = 0x40
        with Documentation
            {Description = "The right bound is present and encoded as a 1-byte, signed value used as an offset (-128 to 127) from the previous value."},
    TS_BOUND_DELTA_BOTTOM   = 0x80
        with Documentation
            {Description = "The bottom bound is present and encoded as a 1-byte, signed value used as an offset (-128 to 127) from the previous value."},
};

type Bounds
{
    BoundsFlag Description;
    optional ([|(Description & BoundsFlag.TS_BOUND_DELTA_LEFT) != 0|] sbyte | 
              [|(Description & BoundsFlag.TS_BOUND_DELTA_LEFT) == 0 && (Description & BoundsFlag.TS_BOUND_LEFT) != 0|] short) Left;
    optional ([|(Description & BoundsFlag.TS_BOUND_DELTA_TOP) != 0|] sbyte | 
              [|(Description & BoundsFlag.TS_BOUND_DELTA_TOP) == 0 && (Description & BoundsFlag.TS_BOUND_TOP) != 0|] short) Top;
    optional ([|(Description & BoundsFlag.TS_BOUND_DELTA_RIGHT) != 0|] sbyte | 
              [|(Description & BoundsFlag.TS_BOUND_DELTA_RIGHT) == 0 && (Description & BoundsFlag.TS_BOUND_RIGHT) != 0|] short) Right;
    optional ([|(Description & BoundsFlag.TS_BOUND_DELTA_BOTTOM) != 0|] sbyte | 
              [|(Description & BoundsFlag.TS_BOUND_DELTA_BOTTOM) == 0 && (Description & BoundsFlag.TS_BOUND_BOTTOM) != 0|] short) Bottom;
}
  
type DSTBLT_ORDER[ControlFlags ControlFlagsValue, array<byte> FieldFlags]
{
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x01) != 0|] COORD_FIELD[ControlFlagsValue] nLeftRect;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x02) != 0|] COORD_FIELD[ControlFlagsValue] nTopRect;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x04) != 0|] COORD_FIELD[ControlFlagsValue] nWidth;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x08) != 0|] COORD_FIELD[ControlFlagsValue] nHeight;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x10) != 0|] byte bRop;
}       

type MULTI_DSTBLT_ORDER[ControlFlags ControlFlagsValue, array<byte> FieldFlags]
{
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x01) != 0|] COORD_FIELD[ControlFlagsValue] nLeftRect;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x02) != 0|] COORD_FIELD[ControlFlagsValue] nTopRect;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x04) != 0|] COORD_FIELD[ControlFlagsValue] nWidth;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x08) != 0|] COORD_FIELD[ControlFlagsValue] nHeight;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x10) != 0|] byte bRop;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x20) != 0|] byte nDeltaEntries;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x40) != 0|] VARIABLE2_DELTA_RECTS_FIELD[nDeltaEntries] CodedDeltaList;
}

type PATBLT_ORDER[ControlFlags ControlFlagsValue, array<byte> FieldFlags]
{
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x01) != 0|] COORD_FIELD[ControlFlagsValue] nLeftRect;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x02) != 0|] COORD_FIELD[ControlFlagsValue] nTopRect;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x04) != 0|] COORD_FIELD[ControlFlagsValue] nWidth;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x08) != 0|] COORD_FIELD[ControlFlagsValue] nHeight;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x10) != 0|] byte bRop;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x20) != 0|] TS_COLOR BackColor;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x40) != 0|] TS_COLOR ForeColor;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x80) != 0|] sbyte BrushOrgX;
    optional [|FieldFlags.Count > 1 && (FieldFlags[1] & 0x01) != 0|] sbyte BrushOrgY;
    optional [|FieldFlags.Count > 1 && (FieldFlags[1] & 0x02) != 0|] byte BrushStyle with DisplayInfo{ToText = BrushStyleToString};
    optional [|FieldFlags.Count > 1 && (FieldFlags[1] & 0x04) != 0|] byte BrushHatch with DisplayInfo{ToText = GetToTextForBrushHatch(BrushStyle)};
    optional [|FieldFlags.Count > 1 && (FieldFlags[1] & 0x08) != 0|] array<byte> BrushExtra with BinaryEncoding{Length = 7};
}

static string BrushStyleToString(any data)
{
    var d = data as (optional byte);
    if (d == nothing)
    {
        return "";
    }
    byte brushStyle = d as byte;
    byte lowNibble = (brushStyle & 0x0F) as byte;
    if ((brushStyle & 0x80) != 0)
    {
        if (InRange<BrushColorDepth>(lowNibble))
        {
            return EnumToStringInSummary<RDPBCGR.BrushColorDepth>(lowNibble);
        }
    }
    else
    {
        if (InRange<BrushStyle>(brushStyle))
        {
            return EnumToStringInSummary<RDPBCGR.BrushStyle>(brushStyle);
        }
    }
    return brushStyle.ToString() + " (" + Utility.DecToHexFormat(brushStyle) + ")";
}

pattern BrushColorDepth = enum byte
{
    BMF_1BPP    = 0x1,
    BMF_8BPP    = 0x3,
    BMF_16BPP   = 0x4,
    BMF_24BPP   = 0x5,
    BMF_32BPP   = 0x6,
    ...
};

pattern BrushStyle  = enum byte
{
    BS_SOLID    = 0x00,
    BS_NULL     = 0x01,
    BS_HATCHED  = 0x02,
    BS_PATTERN  = 0x03,
    ...
};

pattern BrushHatch = enum byte
{
    HS_HORIZONTAL   = 0x00,
    HS_VERTICAL     = 0x01,
    HS_FDIAGONAL    = 0x02,
    HS_BDIAGONAL    = 0x03,
    HS_CROSS        = 0x04,
    HS_DIAGCROSS    = 0x05,
    ...
};

string(any) GetToTextForBrushHatch(optional byte brushStyle)
{
    switch (brushStyle)
    {
        case 0x02 =>
            return BrushHatchToString;
        default =>
            return OptionalByteToString;
    }
}

static string BrushHatchToString(any data)
{
    var d = data as (optional byte);
    if (d == nothing)
    {
        return "";
    }
    byte brushHatch = d as byte;
    if (InRange<BrushHatch>(brushHatch))
    {
        return EnumToStringInSummary<RDPBCGR.BrushHatch>(brushHatch);
    }
    return brushHatch.ToString() + " (" + Utility.DecToHexFormat(brushHatch) + ")";
}

static string OptionalByteToString(any data)
{
    var d = data as (optional byte);
    if (d == nothing)
    {
        return "";
    }
    byte b = d as byte;
    return b.ToString() + " (" + Utility.DecToHexFormat(b) + ")";
}

type MULTI_PATBLT_ORDER[ControlFlags ControlFlagsValue, array<byte> FieldFlags]
{
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x01) != 0|] COORD_FIELD[ControlFlagsValue] nLeftRect;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x02) != 0|] COORD_FIELD[ControlFlagsValue] nTopRect;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x04) != 0|] COORD_FIELD[ControlFlagsValue] nWidth;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x08) != 0|] COORD_FIELD[ControlFlagsValue] nHeight;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x10) != 0|] byte bRop;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x20) != 0|] TS_COLOR BackColor;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x40) != 0|] TS_COLOR ForeColor;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x80) != 0|] sbyte BrushOrgX;
    optional [|FieldFlags.Count > 1 && (FieldFlags[1] & 0x01) != 0|] sbyte BrushOrgY;
    optional [|FieldFlags.Count > 1 && (FieldFlags[1] & 0x02) != 0|] byte BrushStyle with DisplayInfo{ToText = BrushStyleToString};
    optional [|FieldFlags.Count > 1 && (FieldFlags[1] & 0x04) != 0|] byte BrushHatch with DisplayInfo{ToText = GetToTextForBrushHatch(BrushStyle)};
    optional [|FieldFlags.Count > 1 && (FieldFlags[1] & 0x08) != 0|] array<byte> BrushExtra with BinaryEncoding{Length = 7};
    optional [|FieldFlags.Count > 1 && (FieldFlags[1] & 0x10) != 0|] byte nDeltaEntries;
    optional [|FieldFlags.Count > 1 && (FieldFlags[1] & 0x20) != 0|] VARIABLE2_DELTA_RECTS_FIELD[nDeltaEntries] CodedDeltaList;
}

type OPAQUERECT_ORDER[ControlFlags ControlFlagsValue, array<byte> FieldFlags]
{
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x01) != 0|] COORD_FIELD[ControlFlagsValue] nLeftRect;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x02) != 0|] COORD_FIELD[ControlFlagsValue] nTopRect;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x04) != 0|] COORD_FIELD[ControlFlagsValue] nWidth;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x08) != 0|] COORD_FIELD[ControlFlagsValue] nHeight;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x10) != 0|] byte RedOrPaletteIndex;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x20) != 0|] byte Green;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x40) != 0|] byte Blue;
}

type MULTI_OPAQUERECT_ORDER[ControlFlags ControlFlagsValue, array<byte> FieldFlags]
{
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x01) != 0|] COORD_FIELD[ControlFlagsValue] nLeftRect;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x02) != 0|] COORD_FIELD[ControlFlagsValue] nTopRect;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x04) != 0|] COORD_FIELD[ControlFlagsValue] nWidth;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x08) != 0|] COORD_FIELD[ControlFlagsValue] nHeight;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x10) != 0|] byte RedOrPaletteIndex;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x20) != 0|] byte Green;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x40) != 0|] byte Blue;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x80) != 0|] byte nDeltaEntries;
    optional [|FieldFlags.Count > 1 && (FieldFlags[1] & 0x01) != 0|] VARIABLE2_DELTA_RECTS_FIELD[nDeltaEntries] CodedDeltaList;
}

type SCRBLT_ORDER[ControlFlags ControlFlagsValue, array<byte> FieldFlags]
{
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x01) != 0|] COORD_FIELD[ControlFlagsValue] nLeftRect;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x02) != 0|] COORD_FIELD[ControlFlagsValue] nTopRect;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x04) != 0|] COORD_FIELD[ControlFlagsValue] nWidth;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x08) != 0|] COORD_FIELD[ControlFlagsValue] nHeight;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x10) != 0|] byte bRop;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x20) != 0|] COORD_FIELD[ControlFlagsValue] nXSrc;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x40) != 0|] COORD_FIELD[ControlFlagsValue] nYSrc;
}

type MULTI_SCRBLT_ORDER[ControlFlags ControlFlagsValue, array<byte> FieldFlags]
{
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x01) != 0|] COORD_FIELD[ControlFlagsValue] nLeftRect;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x02) != 0|] COORD_FIELD[ControlFlagsValue] nTopRect;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x04) != 0|] COORD_FIELD[ControlFlagsValue] nWidth;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x08) != 0|] COORD_FIELD[ControlFlagsValue] nHeight;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x10) != 0|] byte bRop;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x20) != 0|] COORD_FIELD[ControlFlagsValue] nXSrc;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x40) != 0|] COORD_FIELD[ControlFlagsValue] nYSrc;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x80) != 0|] byte nDeltaEntries;
    optional [|FieldFlags.Count > 1 && (FieldFlags[1] & 0x01) != 0|] VARIABLE2_DELTA_RECTS_FIELD[nDeltaEntries] CodedDeltaList;
}

type MEMBLT_ORDER[ControlFlags ControlFlagsValue, array<byte> FieldFlags]
{
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x01) != 0|] ushort cacheId;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x02) != 0|] COORD_FIELD[ControlFlagsValue] nLeftRect;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x04) != 0|] COORD_FIELD[ControlFlagsValue] nTopRect;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x08) != 0|] COORD_FIELD[ControlFlagsValue] nWidth;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x10) != 0|] COORD_FIELD[ControlFlagsValue] nHeight;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x20) != 0|] byte bRop;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x40) != 0|] COORD_FIELD[ControlFlagsValue] nXSrc;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x80) != 0|] COORD_FIELD[ControlFlagsValue] nYSrc;
    optional [|FieldFlags.Count > 1 && (FieldFlags[1] & 0x01) != 0|] ushort cacheIndex;
}

type MEM3BLT_ORDER[ControlFlags ControlFlagsValue, array<byte> FieldFlags]
{
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x01) != 0|] ushort cacheId;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x02) != 0|] COORD_FIELD[ControlFlagsValue] nLeftRect;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x04) != 0|] COORD_FIELD[ControlFlagsValue] nTopRect;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x08) != 0|] COORD_FIELD[ControlFlagsValue] nWidth;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x10) != 0|] COORD_FIELD[ControlFlagsValue] nHeight;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x20) != 0|] byte bRop;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x40) != 0|] COORD_FIELD[ControlFlagsValue] nXSrc;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x80) != 0|] COORD_FIELD[ControlFlagsValue] nYSrc;
    optional [|FieldFlags.Count > 1 && (FieldFlags[1] & 0x01) != 0|] TS_COLOR BackColor;
    optional [|FieldFlags.Count > 1 && (FieldFlags[1] & 0x02) != 0|] TS_COLOR ForeColor;
    optional [|FieldFlags.Count > 1 && (FieldFlags[1] & 0x04) != 0|] sbyte BrushOrgX;
    optional [|FieldFlags.Count > 1 && (FieldFlags[1] & 0x08) != 0|] sbyte BrushOrgY;
    optional [|FieldFlags.Count > 1 && (FieldFlags[1] & 0x10) != 0|] byte BrushStyle with DisplayInfo{ToText = BrushStyleToString};
    optional [|FieldFlags.Count > 1 && (FieldFlags[1] & 0x20) != 0|] byte BrushHatch with DisplayInfo{ToText = GetToTextForBrushHatch(BrushStyle)};
    optional [|FieldFlags.Count > 1 && (FieldFlags[1] & 0x40) != 0|] array<byte> BrushExtra with BinaryEncoding{Length = 7};
    optional [|FieldFlags.Count > 1 && (FieldFlags[1] & 0x80) != 0|] ushort cacheIndex;
}

type LINETO_ORDER[ControlFlags ControlFlagsValue, array<byte> FieldFlags]
{
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x01) != 0|] BackModeValue BackMode where ValidationCheckEnumValue((value == nothing || InRange<BackModeValue>(value as ushort)), null, true, ReferenceType.Type, "RDPBCGR", "BackMode", "LINETO_ORDER", "0x0001, 0x0002", value);
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x02) != 0|] COORD_FIELD[ControlFlagsValue] nXStart;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x04) != 0|] COORD_FIELD[ControlFlagsValue] nYStart;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x08) != 0|] COORD_FIELD[ControlFlagsValue] nXEnd;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x10) != 0|] COORD_FIELD[ControlFlagsValue] nYEnd;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x20) != 0|] TS_COLOR BackColor;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x40) != 0|] byte bRop2;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x80) != 0|] byte PenStyle where ValidationCheckZero(value == nothing || (value as byte) == 0x00, null, true, ReferenceType.Type, "RDPBCGR", "PenStyle", "LINETO_ORDER", value);
    optional [|FieldFlags.Count > 1 && (FieldFlags[1] & 0x01) != 0|] byte PenWidth where ValidationCheckValue(value == nothing || (value as byte) == 0x01, null, true, ReferenceType.Type, "RDPBCGR", "PenWidth", "LINETO_ORDER", 1, value);
    optional [|FieldFlags.Count > 1 && (FieldFlags[1] & 0x02) != 0|] TS_COLOR PenColor;
}

pattern BackModeValue = enum ushort
{
    TRANSPARENT = 0x0001,
    OPAQUE      = 0x0002,
    ...
};

type SAVEBITMAP_ORDER[ControlFlags ControlFlagsValue, array<byte> FieldFlags]
{
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x01) != 0|] uint SavedBitmapPosition;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x02) != 0|] COORD_FIELD[ControlFlagsValue] nLeftRect;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x04) != 0|] COORD_FIELD[ControlFlagsValue] nTopRect;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x08) != 0|] COORD_FIELD[ControlFlagsValue] nRightRect;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x10) != 0|] COORD_FIELD[ControlFlagsValue] nBottomRect;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x20) != 0|] OperationValue Operation where ValidationCheckEnumValue((value == nothing || InRange<OperationValue>(value as byte)), null, true, ReferenceType.Type, "RDPBCGR", "Operation", "SAVEBITMAP_ORDER", "0x00, 0x01", value);
}

pattern OperationValue = enum byte
{
    SV_SAVEBITS     = 0x00,
    SV_RESTOREBITS  = 0x01,
    ...
};

type GLYPHINDEX_ORDER[ControlFlags ControlFlagsValue, array<byte> FieldFlags]
{
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x01) != 0|] byte cacheId where ValidationCheckValueInRange((value == nothing || (value as byte <= 9 && value as byte >= 0)), null, true, ReferenceType.Type, "RDPBCGR", "cacheId", "GLYPHINDEX_ORDER", 0, 9, value);
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x02) != 0|] AcceleratorFlags flAccel where ValidationCheckCombinationValueTooManyItems((value == nothing || InRange<AcceleratorFlags>(value as byte)), null, true, ReferenceType.Type, "RDPBCGR", "flAccel", "GLYPHINDEX_ORDER", "GLYPHINDEX_ORDER", "[MS-RDPEGDI]");
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x04) != 0|] byte ulCharInc;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x08) != 0|] bool fOpRedundant;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x10) != 0|] TS_COLOR BackColor;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x20) != 0|] TS_COLOR ForeColor;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x40) != 0|] short BkLeft;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x80) != 0|] short BkTop;
    optional [|FieldFlags.Count > 1 && (FieldFlags[1] & 0x01) != 0|] short BkRight;
    optional [|FieldFlags.Count > 1 && (FieldFlags[1] & 0x02) != 0|] short BkBottom;
    optional [|FieldFlags.Count > 1 && (FieldFlags[1] & 0x04) != 0|] short OpLeft where ValidationCheck(value == nothing || fOpRedundant == nothing || !(fOpRedundant as bool) || ((fOpRedundant as bool) && (value as short == 0)), null, DiagnosisLevel.Error, () => Format(RDPBCGR_RDPEGDI_GLYPHINDEX_STR, ["OpLeft", value]));
    optional [|FieldFlags.Count > 1 && (FieldFlags[1] & 0x08) != 0|] short OpTop where ValidationCheck(value == nothing || fOpRedundant == nothing || !(fOpRedundant as bool) || ((fOpRedundant as bool) && (value as short == 0)), null, DiagnosisLevel.Error, () => Format(RDPBCGR_RDPEGDI_GLYPHINDEX_STR, ["OpTop", value]));
    optional [|FieldFlags.Count > 1 && (FieldFlags[1] & 0x10) != 0|] short OpRight where ValidationCheck(value == nothing || fOpRedundant == nothing || !(fOpRedundant as bool) || ((fOpRedundant as bool) && (value as short == 0)), null, DiagnosisLevel.Error, () => Format(RDPBCGR_RDPEGDI_GLYPHINDEX_STR, ["OpRight", value]));
    optional [|FieldFlags.Count > 1 && (FieldFlags[1] & 0x20) != 0|] short OpBottom where ValidationCheck(value == nothing || fOpRedundant == nothing || !(fOpRedundant as bool) || ((fOpRedundant as bool) && (value as short == 0)), null, DiagnosisLevel.Error, () => Format(RDPBCGR_RDPEGDI_GLYPHINDEX_STR, ["OpBottom", value]));
    optional [|FieldFlags.Count > 1 && (FieldFlags[1] & 0x40) != 0|] sbyte BrushOrgX;
    optional [|FieldFlags.Count > 1 && (FieldFlags[1] & 0x80) != 0|] sbyte BrushOrgY;
    optional [|FieldFlags.Count > 2 && (FieldFlags[2] & 0x01) != 0|] byte BrushStyle where ValidationCheckZero(value == nothing || (value as byte) == 0x00, null, true, ReferenceType.Type, "RDPBCGR", "BrushStyle", "GLYPHINDEX_ORDER", value);
    optional [|FieldFlags.Count > 2 && (FieldFlags[2] & 0x02) != 0|] byte BrushHatch where ValidationCheckZero(value == nothing || (value as byte) == 0x00, null, true, ReferenceType.Type, "RDPBCGR", "BrushHatch", "GLYPHINDEX_ORDER", value);
    optional [|FieldFlags.Count > 2 && (FieldFlags[2] & 0x04) != 0|] array<byte> BrushExtra with BinaryEncoding{Length = 7};
    optional [|FieldFlags.Count > 2 && (FieldFlags[2] & 0x08) != 0|] short X;
    optional [|FieldFlags.Count > 2 && (FieldFlags[2] & 0x10) != 0|] short Y;
    optional [|FieldFlags.Count > 2 && (FieldFlags[2] & 0x20) != 0|] VARIABLE1_FIELD VariableBytes;
}

pattern AcceleratorFlags = flags byte
{
    SO_FLAG_DEFAULT_PLACEMENT   = 0x01
        with Documentation
            {Description = "This flag MUST be set."},
    SO_HORIZONTAL               = 0x02
        with Documentation
            {Description = "Text is horizontal, left-to-right or right-to-left, depending on SO_REVERSED."},
    SO_VERTICAL                 = 0x04
        with Documentation
            {Description = "Text is vertical, top-to-bottom or bottom-to-top, depending on SO_REVERSED."},
    SO_REVERSED                 = 0x08
        with Documentation
            {Description = "Set if horizontal text is right-to-left or vertical text is bottom-to-top."},
    SO_ZERO_BEARINGS            = 0x10
        with Documentation
            {Description = "For a given glyph in the font, the A-width (left-side bearing) and C-width (right-side bearing) associated with the glyph have a value of zero."},
    SO_CHAR_INC_EQUAL_BM_BASE   = 0x20
        with Documentation
            {Description = "For a given glyph in the font, the B-width associated with the glyph equals the advance width of the glyph."},
    SO_MAXEXT_EQUAL_BM_SIDE     = 0x40
        with Documentation
            {Description = "The height of the bitmap associated with a given glyph in the font is always equal to the sum of the ascent and descent."},
    ...
};

type FASTINDEX_ORDER[ControlFlags ControlFlagsValue, array<byte> FieldFlags]
{
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x01) != 0|] byte cacheId where ValidationCheckValueInRange((value == nothing || (value as byte <= 9 && value as byte >= 0)), null, true, ReferenceType.Type, "RDPBCGR", "cacheId", "FASTINDEX_ORDER", 0, 9, value);
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x02) != 0|] FDrawing fDrawing;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x04) != 0|] TS_COLOR BackColor;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x08) != 0|] TS_COLOR ForeColor;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x10) != 0|] COORD_FIELD[ControlFlagsValue] BkLeft;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x20) != 0|] COORD_FIELD[ControlFlagsValue] BkTop;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x40) != 0|] COORD_FIELD[ControlFlagsValue] BkRight;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x80) != 0|] COORD_FIELD[ControlFlagsValue] BkBottom;
    optional [|FieldFlags.Count > 1 && (FieldFlags[1] & 0x01) != 0|] COORD_FIELD[ControlFlagsValue] OpLeft;
    optional [|FieldFlags.Count > 1 && (FieldFlags[1] & 0x02) != 0|] COORD_FIELD[ControlFlagsValue] OpTop;
    optional [|FieldFlags.Count > 1 && (FieldFlags[1] & 0x04) != 0|] COORD_FIELD[ControlFlagsValue] OpRight;
    optional [|FieldFlags.Count > 1 && (FieldFlags[1] & 0x08) != 0|] COORD_FIELD[ControlFlagsValue] OpBottom;
    optional [|FieldFlags.Count > 1 && (FieldFlags[1] & 0x10) != 0|] COORD_FIELD[ControlFlagsValue] X;
    optional [|FieldFlags.Count > 1 && (FieldFlags[1] & 0x20) != 0|] COORD_FIELD[ControlFlagsValue] Y;
    optional [|FieldFlags.Count > 1 && (FieldFlags[1] & 0x40) != 0|] VARIABLE1_FIELD VariableBytes;
}

type FDrawing
{
    AcceleratorFlags flAccel;
    byte ulCharInc;
}

type FASTGLYPH_ORDER[ControlFlags ControlFlagsValue, array<byte> FieldFlags]
{
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x01) != 0|] byte cacheId where ValidationCheckValueInRange((value == nothing || (value as byte <= 9 && value as byte >= 0)), null, true, ReferenceType.Type, "RDPBCGR", "cacheId", "FASTGLYPH_ORDER", 0, 9, value);
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x02) != 0|] FDrawing fDrawing;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x04) != 0|] TS_COLOR BackColor;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x08) != 0|] TS_COLOR ForeColor;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x10) != 0|] COORD_FIELD[ControlFlagsValue] BkLeft;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x20) != 0|] COORD_FIELD[ControlFlagsValue] BkTop;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x40) != 0|] COORD_FIELD[ControlFlagsValue] BkRight;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x80) != 0|] COORD_FIELD[ControlFlagsValue] BkBottom;
    optional [|FieldFlags.Count > 1 && (FieldFlags[1] & 0x01) != 0|] COORD_FIELD[ControlFlagsValue] OpLeft;
    optional [|FieldFlags.Count > 1 && (FieldFlags[1] & 0x02) != 0|] COORD_FIELD[ControlFlagsValue] OpTop;
    optional [|FieldFlags.Count > 1 && (FieldFlags[1] & 0x04) != 0|] COORD_FIELD[ControlFlagsValue] OpRight;
    optional [|FieldFlags.Count > 1 && (FieldFlags[1] & 0x08) != 0|] COORD_FIELD[ControlFlagsValue] OpBottom;
    optional [|FieldFlags.Count > 1 && (FieldFlags[1] & 0x10) != 0|] COORD_FIELD[ControlFlagsValue] X;
    optional [|FieldFlags.Count > 1 && (FieldFlags[1] & 0x20) != 0|] COORD_FIELD[ControlFlagsValue] Y;
    optional [|FieldFlags.Count > 1 && (FieldFlags[1] & 0x40) != 0|] VARIABLE1_FIELD VariableBytes;
}

type POLYGON_SC_ORDER[ControlFlags ControlFlagsValue, array<byte> FieldFlags]
{
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x01) != 0|] COORD_FIELD[ControlFlagsValue] xStart;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x02) != 0|] COORD_FIELD[ControlFlagsValue] yStart;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x04) != 0|] byte bRop2;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x08) != 0|] FILL_MODE FillMode;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x10) != 0|] TS_COLOR BrushColor;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x20) != 0|] byte NumDeltaEntries;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x40) != 0|] VARIABLE1_DELTA_PTS_FIELD[NumDeltaEntries] CodedDeltaList;
}

type POLYGON_CB_ORDER[ControlFlags ControlFlagsValue, array<byte> FieldFlags]
{
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x01) != 0|] COORD_FIELD[ControlFlagsValue] xStart;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x02) != 0|] COORD_FIELD[ControlFlagsValue] yStart;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x04) != 0|] byte bRop2;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x08) != 0|] FILL_MODE FillMode;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x10) != 0|] TS_COLOR BackColor;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x20) != 0|] TS_COLOR ForeColor;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x40) != 0|] sbyte BrushOrgX;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x80) != 0|] sbyte BrushOrgY;
    optional [|FieldFlags.Count > 1 && (FieldFlags[1] & 0x01) != 0|] byte BrushStyle with DisplayInfo{ToText = BrushStyleToString};
    optional [|FieldFlags.Count > 1 && (FieldFlags[1] & 0x02) != 0|] byte BrushHatch with DisplayInfo{ToText = GetToTextForBrushHatch(BrushStyle)};
    optional [|FieldFlags.Count > 1 && (FieldFlags[1] & 0x04) != 0|] array<byte> BrushExtra with BinaryEncoding{Length = 7};
    optional [|FieldFlags.Count > 1 && (FieldFlags[1] & 0x08) != 0|] byte NumDeltaEntries;
    optional [|FieldFlags.Count > 1 && (FieldFlags[1] & 0x10) != 0|] VARIABLE1_DELTA_PTS_FIELD[NumDeltaEntries] CodedDeltaList;
}

type POLYLINE_ORDER[ControlFlags ControlFlagsValue, array<byte> FieldFlags]
{
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x01) != 0|] COORD_FIELD[ControlFlagsValue] xStart;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x02) != 0|] COORD_FIELD[ControlFlagsValue] yStart;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x04) != 0|] byte bRop2;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x08) != 0|] ushort BrushCacheEntry where ValidationCheckZero(value == nothing || value as ushort == 0, null, false, ReferenceType.Type, "RDPBCGR", "BrushCacheEntry", "POLYLINE_ORDER", value);
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x10) != 0|] TS_COLOR PenColor;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x20) != 0|] byte NumDeltaEntries;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x40) != 0|] VARIABLE1_DELTA_PTS_FIELD[NumDeltaEntries] CodedDeltaList;
}

type ELLIPSE_SC_ORDER[ControlFlags ControlFlagsValue, array<byte> FieldFlags]
{
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x01) != 0|] COORD_FIELD[ControlFlagsValue] LeftRect;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x02) != 0|] COORD_FIELD[ControlFlagsValue] TopRect;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x04) != 0|] COORD_FIELD[ControlFlagsValue] RightRect;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x08) != 0|] COORD_FIELD[ControlFlagsValue] BottomRect;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x10) != 0|] byte bRop2;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x20) != 0|] EllipseSCFillMode FillMode where ValidationCheckEnumValue(value == nothing || InRange<EllipseSCFillMode>(value as byte), null, true, ReferenceType.Type, "RDPBCGR", "FillMode", "ELLIPSE_SC_ORDER", "0x00, 0x01, 0x02", value);
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x40) != 0|] TS_COLOR Color;
}

pattern EllipseSCFillMode = enum byte
{
    NOFILL      = 0x00,
    ALTERNATE   = 0x01,
    WINDING     = 0x02,
    ...
};

type ELLIPSE_CB_ORDER[ControlFlags ControlFlagsValue, array<byte> FieldFlags]
{
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x01) != 0|] COORD_FIELD[ControlFlagsValue] LeftRect;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x02) != 0|] COORD_FIELD[ControlFlagsValue] TopRect;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x04) != 0|] COORD_FIELD[ControlFlagsValue] RightRect;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x08) != 0|] COORD_FIELD[ControlFlagsValue] BottomRect;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x10) != 0|] byte bRop2;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x20) != 0|] FILL_MODE FillMode;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x40) != 0|] TS_COLOR BackColor;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x80) != 0|] TS_COLOR ForeColor;
    optional [|FieldFlags.Count > 1 && (FieldFlags[1] & 0x01) != 0|] sbyte BrushOrgX;
    optional [|FieldFlags.Count > 1 && (FieldFlags[1] & 0x02) != 0|] sbyte BrushOrgY;
    optional [|FieldFlags.Count > 1 && (FieldFlags[1] & 0x04) != 0|] byte BrushStyle with DisplayInfo{ToText = BrushStyleToString};
    optional [|FieldFlags.Count > 1 && (FieldFlags[1] & 0x08) != 0|] byte BrushHatch with DisplayInfo{ToText = GetToTextForBrushHatch(BrushStyle)};
    optional [|FieldFlags.Count > 1 && (FieldFlags[1] & 0x10) != 0|] array<byte> BrushExtra with BinaryEncoding{Length = 7};
}

type DRAWNINEGRID_ORDER[ControlFlags ControlFlagsValue, array<byte> FieldFlags]
{
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x01) != 0|] COORD_FIELD[ControlFlagsValue] srcLeft;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x02) != 0|] COORD_FIELD[ControlFlagsValue] srcTop;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x04) != 0|] COORD_FIELD[ControlFlagsValue] srcRight;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x08) != 0|] COORD_FIELD[ControlFlagsValue] srcBottom;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x10) != 0|] ushort bitmapId;
}

type MULTI_DRAWNINEGRID_ORDER[ControlFlags ControlFlagsValue, array<byte> FieldFlags]
{
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x01) != 0|] COORD_FIELD[ControlFlagsValue] srcLeft;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x02) != 0|] COORD_FIELD[ControlFlagsValue] srcTop;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x04) != 0|] COORD_FIELD[ControlFlagsValue] srcRight;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x08) != 0|] COORD_FIELD[ControlFlagsValue] srcBottom;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x10) != 0|] ushort bitmapId;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x20) != 0|] byte nDeltaEntries;
    optional [|FieldFlags.Count > 0 && (FieldFlags[0] & 0x40) != 0|] VARIABLE2_DELTA_RECTS_FIELD[nDeltaEntries] CodedDeltaList;
}

// [MS-RDPEGDI] 2.2.2.2.1.2 Secondary Drawing Orders
// Put the field "extraFlags" and "orderType" in each secondary drawing order definition, as "extraFlags" is specific to each secondary drawing order.
type SECONDARY_DRAWING_ORDER_HEADER
{
    ControlFlags controlFlags where ((value & ControlFlags.TS_STANDARD) != 0 && (value & ControlFlags.TS_SECONDARY) != 0);
    short orderLength;
}

pattern SecondaryDrawingOrderType = enum byte
{
    TS_CACHE_BITMAP_UNCOMPRESSED        = 0x00,
    TS_CACHE_COLOR_TABLE                = 0x01,
    TS_CACHE_BITMAP_COMPRESSED          = 0x02,
    TS_CACHE_GLYPH                      = 0x03,
    TS_CACHE_BITMAP_UNCOMPRESSED_REV2   = 0x04,
    TS_CACHE_BITMAP_COMPRESSED_REV2     = 0x05,
    TS_CACHE_BRUSH                      = 0x07,
    TS_CACHE_BITMAP_COMPRESSED_REV3     = 0x08,
    ...
};

type TWO_BYTE_UNSIGNED_ENCODING
{
    TWO_BYTE_ENCODING_C c with BinaryEncoding{Width = 1};
    byte val1 with BinaryEncoding{Width = 7};
    optional [|c == 1|] byte val2;

    ushort Value()
    {
        ushort v = val1;
        if (c == 1)
        {
            v = (v << 8) + (val2 as byte) as ushort;
        }
        return v;
    }
    
    override string ToString()
    {
        ushort v = Value();
        return v.ToString();
    }
}

pattern TWO_BYTE_ENCODING_C = enum byte
{
    ONE_BYTE_VAL    = 0,
    TWO_BYTE_VAL    = 1,
    ...
};

type TWO_BYTE_SIGNED_ENCODING
{
    TWO_BYTE_ENCODING_C c with BinaryEncoding{Width = 1};
    TWO_BYTE_SIGNED_ENCODING_S s with BinaryEncoding{Width = 1};
    byte val1 with BinaryEncoding{Width = 6};
    optional [|c == 1|] byte val2;

    override string ToString()
    {
        int v = val1;
        if (c == 1)
        {
            v = (v << 8) + (val2 as byte);
        }
        if (s == 1)
        {
            v = -v;
        }
        return v.ToString();
    }
}

pattern TWO_BYTE_SIGNED_ENCODING_S = enum byte
{
    POSITIVE_VAL    = 0,
    NEGATIVE_VAL    = 1,
    ...
};

type FOUR_BYTE_UNSIGNED_ENCODING
{
    FOUR_BYTE_ENCODING_C c with BinaryEncoding{Width = 2};
    byte val1 with BinaryEncoding{Width = 6};
    optional [|c >= 1|] byte val2;
    optional [|c >= 2|] byte val3;
    optional [|c == 3|] byte val4;
    
    uint Value()
    {
        uint v = val1;
        if (c >= 1)
        {
            v = (v << 8) + (val2 as byte) as uint;
        }
        if (c >= 2)
        {
            v = (v << 8) + (val3 as byte) as uint;
        }
        if (c == 3)
        {
            v = (v << 8) + (val4 as byte) as uint;
        }
        return v;
    }
    
    override string ToString()
    {
        uint v = Value();
        return v.ToString();
    }
}

pattern FOUR_BYTE_ENCODING_C = enum byte
{
    ONE_BTYE_VAL    = 0,
    TWO_BYTE_VAL    = 1,
    THREE_BYTE_VAL  = 2,
    FOUR_BYTE_VAL   = 3,
    ...
};

// [MS-RDPEGDI] 2.2.2.2.1.2.2. Cache Bitmap - Revision 1 (CACHE_BITMAP_ORDER)
type CACHE_BITMAP_ORDER : SECONDARY_DRAWING_ORDER_HEADER
{
    CacheBitmapOrderExtraFlags extraFlags;
    SecondaryDrawingOrderType orderType where (value == SecondaryDrawingOrderType.TS_CACHE_BITMAP_UNCOMPRESSED || value == SecondaryDrawingOrderType.TS_CACHE_BITMAP_COMPRESSED);
    byte cacheId;
    byte pad1Octet;
    byte bitmapWidth;
    byte bitmapHeight;
    BitmapBitsPerPel bitmapBitsPerPel where ValidationCheckEnumValue(InRange<BitmapBitsPerPel>(value), null, true, ReferenceType.Type, "RDPBCGR", "bitmapBitsPerPel", "CACHE_BITMAP_ORDER", "0x08, 0x10, 0x18, 0x20", value);
    ushort bitmapLength;
    ushort cacheIndex;
    optional [|orderType == SecondaryDrawingOrderType.TS_CACHE_BITMAP_COMPRESSED && (extraFlags & CacheBitmapOrderExtraFlags.NO_BITMAP_COMPRESSION_HDR) == 0|] TS_CD_HEADER bitmapComprHdr;
    binary bitmapDataStream with BinaryEncoding{Length = bitmapComprHdr == nothing ? (bitmapLength) : ((bitmapLength - 8))};
}

pattern BitmapBitsPerPel = enum byte
{
    CBR_8BPP   = 0x08,
    CBR_16BPP  = 0x10,
    CBR_24BPP  = 0x18,
    CBR_32BPP  = 0x20,
    ...
};

pattern CacheBitmapOrderExtraFlags = flags ushort
{
    NO_BITMAP_COMPRESSION_HDR   = 0x0400
        with Documentation
            {Description = "The bitmapComprHdr field is not present (removed for bandwidth efficiency to save 8 bytes)."},
    ...
};

// [MS-RDPEGDI] 2.2.2.2.1.2.2. Cache Bitmap - Revision 2 (CACHE_BITMAP_REV2_ORDER)
type CACHE_BITMAP_REV2_ORDER : SECONDARY_DRAWING_ORDER_HEADER
{
    CacheBitmapRev2OrderExtraFlags extraFlags;
    SecondaryDrawingOrderType orderType where (value == SecondaryDrawingOrderType.TS_CACHE_BITMAP_UNCOMPRESSED_REV2 || value == SecondaryDrawingOrderType.TS_CACHE_BITMAP_COMPRESSED_REV2);
    optional [|(extraFlags.$"flags" & OperationalFlags.CBR2_PERSISTENT_KEY_PRESENT) != 0|] uint key1;
    optional [|(extraFlags.$"flags" & OperationalFlags.CBR2_PERSISTENT_KEY_PRESENT) != 0|] uint key2;
    TWO_BYTE_UNSIGNED_ENCODING bitmapWidth;
    optional [|(extraFlags.$"flags" & OperationalFlags.CBR2_HEIGHT_SAME_AS_WIDTH) == 0|] TWO_BYTE_UNSIGNED_ENCODING bitmapHeight;
    FOUR_BYTE_UNSIGNED_ENCODING bitmapLength;
    TWO_BYTE_UNSIGNED_ENCODING cacheIndex;
    optional [|orderType == SecondaryDrawingOrderType.TS_CACHE_BITMAP_COMPRESSED_REV2 && (extraFlags.$"flags" & OperationalFlags.CBR2_NO_BITMAP_COMPRESSION_HDR) == 0|] TS_CD_HEADER bitmapComprHdr;
    binary bitmapDataStream with BinaryEncoding{Length = bitmapComprHdr == nothing ? bitmapLength.Value() : ((bitmapLength.Value() - 8))};
}

type CacheBitmapRev2OrderExtraFlags
{
    OperationalFlags $"flags" where ValidationCheckCombinationValueIncludeZero(InRange<OperationalFlags>(value), null, false, ReferenceType.Type, "RDPBCGR", "flags", "CacheBitmapRev2OrderExtraFlags", "0x01, 0x02, 0x08, 0x10", value) 
        with BinaryEncoding{Endian = Endian.Big, Width = 9};
    BitsPerPixelId2 bitsPerPixelId where ValidationCheckEnumValue(InRange<BitsPerPixelId2>(value), null, true, ReferenceType.Type, "RDPBCGR", "bitsPerPixelId", "CacheBitmapRev2OrderExtraFlags", "0x3, 0x4, 0x5, 0x6", value) 
        with BinaryEncoding{Endian = Endian.Big, Width = 4};
    byte cacheId with BinaryEncoding{Endian = Endian.Big, Width = 3};
} with BinaryEncoding{Endian = Endian.Little, WidthForComposedType = 16, DecodeAsUnit = true};

pattern BitsPerPixelId2 = enum byte
{
    CBR2_8BPP   = 0x3,
    CBR2_16BPP  = 0x4,
    CBR2_24BPP  = 0x5,
    CBR2_32BPP  = 0x6,
    ...
};

pattern OperationalFlags = flags ushort
{
    CBR2_HEIGHT_SAME_AS_WIDTH       = 0x01
        with Documentation
            {Description = "The bitmap height is the same as the bitmap width."},
    CBR2_PERSISTENT_KEY_PRESENT     = 0x02
        with Documentation
            {Description = "The bitmap is intended to be persisted, and the key1 and key2 fields MUST be present."},
    CBR2_NO_BITMAP_COMPRESSION_HDR  = 0x08
        with Documentation
            {Description = "The bitmapComprHdr field is not present (removed for bandwidth efficiency to save 8 bytes)."},
    CBR2_DO_NOT_CACHE               = 0x10
        with Documentation
            {Description = "The cacheIndex field MUST be ignored, and the bitmap MUST be placed in the last entry of the bitmap cache specified by cacheId field."},
    ...
};

// [MS-RDPEGDI] 2.2.2.2.1.2.4 Cache Color Table (CACHE_COLOR_TABLE_ORDER)
type CACHE_COLOR_TABLE_ORDER : SECONDARY_DRAWING_ORDER_HEADER
{
    ushort extraFlags;
    SecondaryDrawingOrderType orderType where (value == SecondaryDrawingOrderType.TS_CACHE_COLOR_TABLE);
    byte cacheIndex;
    ushort numberColors where ValidationCheckValue(value == 256, null, true, ReferenceType.Type, "RDPBCGR", "numberColors", "CACHE_COLOR_TABLE_ORDER", 256, value);
    array<TS_COLOR_QUAD> colorTable with BinaryEncoding{Length = numberColors};
}

type TS_COLOR_QUAD
{
    byte blue;
    byte green;
    byte red;
    byte pad1Octet;

    override string ToString()
    {
        return "RGB: (" + red.ToString() + ", " + green.ToString() + ", " + blue.ToString() + ")";
    }
}

// [MS-RDPEGDI] 2.2.2.2.1.2.5 Cache Glyph - Revision 1 (CACHE_GLYPH_ORDER)
type CACHE_GLYPH_ORDER : SECONDARY_DRAWING_ORDER_HEADER
{
    CacheGlyphOrderExtraFlags extraFlags;
    SecondaryDrawingOrderType orderType where (value == SecondaryDrawingOrderType.TS_CACHE_GLYPH);
    byte cacheId;
    byte cGlyphs;
    array<TS_CACHE_GLYPH_DATA> glyphData with BinaryEncoding{Length = cGlyphs};
    string unicodeCharacters with BinaryEncoding{TextEncoding= TextEncoding.Unicode, Length = cGlyphs};
}

pattern CacheGlyphOrderExtraFlags = flags ushort
{
    CG_GLYPH_UNICODE_PRESENT    = 0x0100
        with Documentation
            {Description = "The unicodeCharacters field is present."},
    ...
};

type TS_CACHE_GLYPH_DATA
{
    ushort cacheIndex;
    short x;
    short y;
    ushort cx;
    ushort cy;
    array<byte> aj with BinaryEncoding{Length = ((((cx + 7) / 8) * cy + 3) / 4) * 4};

    override string ToString()
    {
        return "cacheIndex: " + cacheIndex.ToString() + ", x: " + x.ToString() + ", y: " + y.ToString() + ", cx: " + cx.ToString() + ", cy: " + cy.ToString();
    }
}

// [MS-RDPEGDI] 2.2.2.2.1.2.6 Cache Glyph - Revision 2 (CACHE_GLYPH_REV2_ORDER)
type CACHE_GLYPH_REV2_ORDER : SECONDARY_DRAWING_ORDER_HEADER
{
    CacheClyphRev2OrderExtraFlags extraFlags;
    SecondaryDrawingOrderType orderType where (value == SecondaryDrawingOrderType.TS_CACHE_GLYPH);
    array<TS_CACHE_GLYPH_DATA_REV2> glyphDataRev2 with BinaryEncoding{Length = extraFlags.cGlyphs};
    string unicodeCharaters with BinaryEncoding{TextEncoding= TextEncoding.Unicode, Length = extraFlags.cGlyphs};
}

type CacheClyphRev2OrderExtraFlags
{
    OperationalFlags2 $"flags" where (ValidationCheckCombinationValueIncludeZero(InRange<OperationalFlags2>(value), null, false, ReferenceType.Type, "RDPBCGR", "flags", "CacheClyphRev2OrderExtraFlags", "0x1, 0x2", value) && (value & OperationalFlags2.GLY_ORDER_REV2) != 0)
         with BinaryEncoding{Width = 4};
    byte cacheId with BinaryEncoding{Width = 4};
    byte cGlyphs;
}

pattern OperationalFlags2 = flags byte
{
    CG2_GLYPH_UNICODE_PRESENT   = 0x1
        with Documentation
            {Description = "The unicodeCharacters field is present."},
    GLY_ORDER_REV2              = 0x2
        with Documentation
            {Description = "This is a Cache Glyph - Revision 2 Order; the Cache Glyph - Revision 1 extraFlags header field does not contain a flag with this value."},
    ...
};

type TS_CACHE_GLYPH_DATA_REV2
{
    byte cacheIndex;
    TWO_BYTE_SIGNED_ENCODING x;
    TWO_BYTE_SIGNED_ENCODING y;
    TWO_BYTE_UNSIGNED_ENCODING cx;
    TWO_BYTE_UNSIGNED_ENCODING cy;
    array<byte> aj with BinaryEncoding{Length = ((((cx.Value() + 7) / 8) * cy.Value() + 3) / 4) * 4};

    override string ToString()
    {
        return "cacheIndex: " + cacheIndex.ToString() + ", x: " + x.ToString() + ", y: " + y.ToString() + ", cx: " + cx.ToString() + ", cy: " + cy.ToString();
    }
}

// [MS-RDPEGDI] 2.2.2.2.1.2.7 Cache Brush (CACHE_BRUSH_ORDER)
type CACHE_BRUSH_ORDER : SECONDARY_DRAWING_ORDER_HEADER
{
    ushort extraFlags;
    SecondaryDrawingOrderType orderType where (value == SecondaryDrawingOrderType.TS_CACHE_BRUSH);
    byte cacheEntry where ValidationCheckValueInRange(value >= 0 && value <= 63, null, true, ReferenceType.Type, "RDPBCGR", "cacheEntry", "CACHE_BRUSH_ORDER", 0, 63, value);
    CacheBrushOrderIBitmapFormat iBitmapFormat where ValidationCheckEnumValue(InRange<CacheBrushOrderIBitmapFormat>(value), null, true, ReferenceType.Type, "RDPBCGR", "iBitmapFormat", "CACHE_BRUSH_ORDER", "0x01, 0x03, 0x04, 0x05, 0x06", value);
    byte cx;
    byte cy;
    byte Style where ValidationCheckZero(value == 0, null, false, ReferenceType.Type, "RDPBCGR", "Style", "CACHE_BRUSH_ORDER", value);
    byte iBytes;
    array<byte> brushData with BinaryEncoding{Length = iBytes};
}

pattern CacheBrushOrderIBitmapFormat = enum byte
{
    BMF_1BPP        = 0x01,
    BMF_8BPP        = 0x03,
    BMF_16BPP       = 0x04,
    BMF_24BPP       = 0x05,
    BMF_32BPP       = 0x06,
    ...
};

// [MS-RDPEGDI] 2.2.2.2.1.2.8 Cache Bitmap - Revision 3 (CACHE_BITMAP_REV3_ORDER)
type CACHE_BITMAP_REV3_ORDER : SECONDARY_DRAWING_ORDER_HEADER
{
    CacheBitmapRev3OrderExtraFlags extraFlags;
    SecondaryDrawingOrderType orderType where (value == SecondaryDrawingOrderType.TS_CACHE_BITMAP_COMPRESSED_REV3);
    ushort cacheIndex;
    uint key1;
    uint key2;
    TS_BITMAP_DATA_EX bitmapDataStream;
}

type CacheBitmapRev3OrderExtraFlags
{
    OperationalFlags3 $"flags" where ValidationCheckCombinationValueIncludeZero(InRange<OperationalFlags3>(value), null, false, ReferenceType.Type, "RDPBCGR", "flags", "CacheBitmapRev3OrderExtraFlags", "0x08, 0x10", value)
        with BinaryEncoding{Width = 9, Endian = Endian.Big};
    BitsPerPixelId3 bitsPerPixelId where ValidationCheckEnumValue(InRange<BitsPerPixelId3>(value), null, true, ReferenceType.Type, "RDPBCGR", "bitsPerPixelId", "CacheBitmapRev3OrderExtraFlags", "0x3, 0x4, 0x5, 0x6", value)
        with BinaryEncoding{Endian = Endian.Big, Width = 4};
    byte cacheId with BinaryEncoding{Endian = Endian.Big, Width = 3};
} with BinaryEncoding{Endian = Endian.Little, WidthForComposedType = 16, DecodeAsUnit = true};

pattern OperationalFlags3 = flags ushort
{
    CBR3_IGNORABLE_FLAG = 0x08
        with Documentation
            {Description = "This flag has no meaning and its value is ignored by the client."},
    CBR3_DO_NOT_CACHE   = 0x10
        with Documentation
            {Description = "The cacheIndex field MUST be ignored, and the bitmap MUST be placed in the last entry of the bitmap cache specified by the cacheId field."},
    ...
};

pattern BitsPerPixelId3 = enum byte
{
    CBR23_8BPP  = 0x3,
    CBR23_16BPP = 0x4,
    CBR23_24BPP = 0x5,
    CBR23_32BPP = 0x6,
    ...
};

// [MS-RDPEGDI] 2.2.2.2.1.3 Alternate Secondary Drawing Orders
type AltSecDrawingOrderControlFlags
{
    AltSecDrawingOrderType orderType with BinaryEncoding{Width = 6};
    byte class where value == 0x02 with BinaryEncoding{Width = 2};
}

pattern AltSecDrawingOrderType = enum byte
{
    TS_ALTSEC_SWITCH_SURFACE            = 0x00,
    TS_ALTSEC_CREATE_OFFSCR_BITMAP      = 0x01,
    TS_ALTSEC_STREAM_BITMAP_FIRST       = 0x02,
    TS_ALTSEC_STREAM_BITMAP_NEXT        = 0x03,
    TS_ALTSEC_CREATE_NINEGRID_BITMAP    = 0x04,
    TS_ALTSEC_GDIP_FIRST                = 0x05,
    TS_ALTSEC_GDIP_NEXT                 = 0x06,
    TS_ALTSEC_GDIP_END                  = 0x07,
    TS_ALTSEC_GDIP_CACHE_FIRST          = 0x08,
    TS_ALTSEC_GDIP_CACHE_NEXT           = 0x09,
    TS_ALTSEC_GDIP_CACHE_END            = 0x0A,
    TS_ALTSEC_WINDOW                    = 0x0B,
    TS_ALTSEC_COMPDESK_FIRST            = 0x0C,
    TS_ALTSEC_FRAME_MARKER              = 0x0D,
    ...
};

// [MS-RDPEGDI] 2.2.2.2.1.3.2 Create Offscreen Bitmap (CREATE_OFFSCR_BITMAP_ORDER)
type CREATE_OFFSCR_BITMAP_ORDER
{
    AltSecDrawingOrderControlFlags header where value.orderType == AltSecDrawingOrderType.TS_ALTSEC_CREATE_OFFSCR_BITMAP;
    CreateOffscrBitmapOrderFlags $"flags";
    ushort cx;
    ushort cy;
    optional [|$"flags".d != 0|] OFFSRC_DELETE_LIST deleteList;
}

type CreateOffscrBitmapOrderFlags
{
    byte d with BinaryEncoding{Width = 1};
    ushort offscreenBitmapId with BinaryEncoding{Width = 15, Endian = Endian.Big};
} with BinaryEncoding{Endian = Endian.Little, WidthForComposedType = 16, DecodeAsUnit = true};

type OFFSRC_DELETE_LIST
{
    ushort cIndices;
    array<ushort> indices with BinaryEncoding{Length = cIndices};
}

// [MS-RDPEGDI] 2.2.2.2.1.3.3 Switch Surface (SWITCH_SURFACE_ORDER)
type SWITCH_SURFACE_ORDER
{
    AltSecDrawingOrderControlFlags header where value.orderType == AltSecDrawingOrderType.TS_ALTSEC_SWITCH_SURFACE;
    ushort bitmapId;
}

// [MS-RDPEGDI] 2.2.2.2.1.3.4 Create NineGrid Bitmap (CREATE_NINEGRID_BITMAP_ORDER)
type CREATE_NINEGRID_BITMAP_ORDER
{
    AltSecDrawingOrderControlFlags header where value.orderType == AltSecDrawingOrderType.TS_ALTSEC_CREATE_NINEGRID_BITMAP;
    byte BitmapBpp where ValidationCheckValue(value == 0x20, null, true, ReferenceType.Type, "RDPBCGR", "BitmapBpp", "CREATE_NINEGRID_BITMAP_ORDER", 0x20, value);
    ushort BitmapId;
    ushort cx;
    ushort cy;
    NINEGRID_BITMAP_INFO nineGridInfo;
}

type NINEGRID_BITMAP_INFO
{
    NineGridBitmapInfoFlags flFlags where ValidationCheckCombinationValueTooManyItems(InRange<NineGridBitmapInfoFlags>(value), null, false, ReferenceType.Type, "RDPBCGR", "flFlags", "NINEGRID_BITMAP_INFO", "NINEGRID_BITMAP_INFO", "[MS-RDPEGDI]");
    ushort ulLeftWidth;
    ushort ulRightWidth;
    ushort ulTopHeight;
    ushort ulBottomHeight;
    TS_COLORREF crTransparent;
}

pattern NineGridBitmapInfoFlags = flags uint
{
    DSDNG_STRETCH           = 0x00000001
        with Documentation
            {Description = "The center portion of the source bitmap MUST be stretched to fill the center of the destination NineGrid."},
    DSDNG_TILE              = 0x00000002
        with Documentation
            {Description = "The center portion source bitmap MUST be tiled to fill the center of the destination NineGrid."},
    DSDNG_PERPIXELALPHA    = 0x00000004
        with Documentation
            {Description = "An AlphaBlend operation MUST be used to compose the destination NineGrid."},
    DSDNG_TRANSPARENT       = 0x00000008
        with Documentation
            {Description = "A TransparentBlt operation MUST be used to compose the destination NineGrid."},
    DSDNG_MUSTFLIP          = 0x00000010
        with Documentation
            {Description = "The source NineGrid MUST be flipped on a vertical axis."},
    DSDNG_TRUESIZE          = 0x00000020
        with Documentation
            {Description = "The source bitmap MUST be transferred without stretching or tiling."},
    ...
};

type TS_COLORREF
{
    byte red;
    byte green;
    byte blue;
    byte zeroPad;
}

// [MS-RDPEGDI] 2.2.2.2.1.3.5 Stream Bitmap Orders
// [MS-RDPEGDI] 2.2.2.2.1.3.5.1 Stream Bitmap First (STREAM_BITMAP_FIRST_ORDER)
type STREAM_BITMAP_FIRST_ORDER
{
    AltSecDrawingOrderControlFlags header where value.orderType == AltSecDrawingOrderType.TS_ALTSEC_STREAM_BITMAP_FIRST;
    StreamBitmapFirstOrderBitmapFlags BitmapFlags where ValidationCheckCombinationValueIncludeZero(InRange<StreamBitmapFirstOrderBitmapFlags>(value), null, false, ReferenceType.Type, "RDPBCGR", "BitmapFlags", "STREAM_BITMAP_FIRST_ORDER", "0x01, 0x02, 0x04", value);
    byte BitmapBpp;
    StreamBitmapFirstOrderBitmapType BitmapType where ValidationCheckValue(value == 0x0001, null, false, ReferenceType.Type, "RDPBCGR", "BitmapType", "STREAM_BITMAP_FIRST_ORDER", 0x0001, value);
    ushort BitmapWidth;
    ushort BitmapHeight;
    ([|(BitmapFlags & StreamBitmapFirstOrderBitmapFlags.STREAM_BITMAP_REV2) != 0|] uint | ushort) BitmapSize;
    ushort BitmapBlockSize;
    array<byte> BitmapBlock with BinaryEncoding{Length = BitmapBlockSize};
}

pattern StreamBitmapFirstOrderBitmapFlags = flags byte
{
    STREAM_BITMAP_END           = 0x01
        with Documentation
            {Description = "The bitmap fits into one stream bitmap block (4,096 bytes)."},
    STREAM_BITMAP_COMPRESSED    = 0x02
        with Documentation
            {Description = "The bitmap data is compressed."},
    STREAM_BITMAP_REV2          = 0x04
        with Documentation
            {Description = "The BitmapSize field is 4 bytes."},
    ...
};

pattern StreamBitmapFirstOrderBitmapType = enum ushort
{
    TS_DRAW_NINEGRID_BITMAP_CACHE   = 0x0001,
    ...
};

// [MS-RDPEGDI] 2.2.2.2.1.3.5.2 Stream Bitmap Next (STREAM_BITMAP_NEXT_ORDER)
type STREAM_BITMAP_NEXT_ORDER
{
    AltSecDrawingOrderControlFlags header where value.orderType == AltSecDrawingOrderType.TS_ALTSEC_STREAM_BITMAP_NEXT;
    StreamBitmapNextOrderBitmapFlags BitmapFlags where ValidationCheckCombinationValueIncludeZero(InRange<StreamBitmapNextOrderBitmapFlags>(value), null, false, ReferenceType.Type, "RDPBCGR", "BitmapFlags", "STREAM_BITMAP_NEXT_ORDER", "0x01, 0x02", value);
    StreamBitmapNextOrderBitmapType BitmapType where ValidationCheckValue(value == 0x0001, null, false, ReferenceType.Type, "RDPBCGR", "BitmapType", "STREAM_BITMAP_NEXT_ORDER", 0x0001, value);
    ushort BitmapBlockSize;
    array<byte> BitmapBlock with BinaryEncoding{Length = BitmapBlockSize};
}

pattern StreamBitmapNextOrderBitmapFlags = flags byte
{
    STREAM_BITMAP_END           = 0x01
        with Documentation
            {Description = "This packet contains the final stream bitmap block."},
    STREAM_BITMAP_COMPRESSED    = 0x02
        with Documentation
            {Description = "The bitmap data is compressed."},
    ...
};

pattern StreamBitmapNextOrderBitmapType = enum ushort
{
    TS_DRAW_NINEGRID_BITMAP_CACHE   = 0x0001,
    ...
};

// [MS-RDPEGDI] 2.2.2.2.1.3.6 GDI+ Orders
type DRAW_GDIPLUS_CACHE_TYPE
{
    DrawGDIPlusCacheType cacheType where ValidationCheckEnumValue(InRange<DrawGDIPlusCacheType>(value), null, false, ReferenceType.Type, "RDPBCGR", "cacheType", "DRAW_GDIPLUS_CACHE_TYPE", "0x0001, 0x0002, 0x0003, 0x0004, 0x0005", value);
}

pattern DrawGDIPlusCacheType = enum ushort
{
    GDIP_CACHE_GRAPHICS_DATA            = 0x0001,
    GDIP_CACHE_OBJECT_BRUSH             = 0x0002,
    GDIP_CACHE_OBJECT_PEN               = 0x0003,
    GDIP_CACHE_OBJECT_IMAGE             = 0x0004,
    GDIP_CACHE_OBJECT_IMAGEATTRIBUTES   = 0x0005,
    ...
};

// [MS-RDPEGDI] 2.2.2.2.1.3.6.2 Draw GDI+ Cache First (DRAW_GDIPLUS_CACHE_FIRST_ORDER)
type DRAW_GDIPLUS_CACHE_FIRST_ORDER
{
    AltSecDrawingOrderControlFlags header where value.orderType == AltSecDrawingOrderType.TS_ALTSEC_GDIP_CACHE_FIRST;
    DrawGDIPlusCacheOrderFlags Flags where ValidationCheckCombinationValueIncludeZero(InRange<DrawGDIPlusCacheOrderFlags>(value), null, false, ReferenceType.Type, "RDPBCGR", "Flags", "DRAW_GDIPLUS_CACHE_FIRST_ORDER", "0x01", value);
    DRAW_GDIPLUS_CACHE_TYPE CacheType;
    ushort CacheIndex;
    ushort cbSize;
    uint cbTotalSize;
    array<EMFRecord> emfRecords with BinaryEncoding{WidthForComposedType = cbSize * 8};
}

pattern DrawGDIPlusCacheOrderFlags = flags byte
{
    GDIP_REMOVE_CACHEENTRY  = 0x01
        with Documentation
            {Description = "Remove the cache entry item at the index specified by CacheIndex before caching the one contained in this order."},
    ...
};

// [MS-RDPEGDI] 2.2.2.2.1.3.6.3 Draw GDI+ Cache Next (DRAW_GDIPLUS_CACHE_NEXT_ORDER)
type DRAW_GDIPLUS_CACHE_NEXT_ORDER
{
    AltSecDrawingOrderControlFlags header where value.orderType == AltSecDrawingOrderType.TS_ALTSEC_GDIP_CACHE_NEXT;
    DrawGDIPlusCacheOrderFlags Flags;
    DRAW_GDIPLUS_CACHE_TYPE CacheType;
    ushort CacheIndex;
    ushort cbSize;
    array<EMFRecord> emfRecords with BinaryEncoding{WidthForComposedType = cbSize * 8};
}

// [MS-RDPEGDI] 2.2.2.2.1.3.6.4 Draw GDI+ Cache End (DRAW_GDIPLUS_CACHE_END_ORDER)
type DRAW_GDIPLUS_CACHE_END_ORDER
{
    AltSecDrawingOrderControlFlags header where value.orderType == AltSecDrawingOrderType.TS_ALTSEC_GDIP_CACHE_END;
    DrawGDIPlusCacheOrderFlags Flags;
    DRAW_GDIPLUS_CACHE_TYPE CacheType;
    ushort CacheIndex;
    ushort cbSize;
    uint cbTotalSize;
    array<EMFRecord> emfRecords with BinaryEncoding{WidthForComposedType = cbSize * 8};
}

// [MS-RDPEGDI] 2.2.2.2.1.3.6.5 Draw GDI+ First (DRAW_GDIPLUS_FIRST_ORDER)
type DRAW_GDIPLUS_FIRST_ORDER
{
    AltSecDrawingOrderControlFlags header where value.orderType == AltSecDrawingOrderType.TS_ALTSEC_GDIP_FIRST;
    byte pad1Octet;
    ushort cbSize;
    uint cbTotalSize;
    uint cbTotalEmfSize;
    array<DRAW_GDIPLUS_EMF_Record | EMFRecord> emfRecords with BinaryEncoding{WidthForComposedType = cbSize * 8};
}

type DRAW_GDIPLUS_EMF_Record
{
    RecordType Type;
    ushort Flags;
    uint Size where ((value & 0x80000000) != 0);
    uint DataSize;
    ushort CacheIndex;

    override string ToString()
    {
        return "DRAW_GDIPLUS_EMF_Record, CacheIndex: " + CacheIndex.ToString();
    }
}

// [MS-RDPEGDI] 2.2.2.2.1.3.6.6 Draw GDI+ Next (DRAW_GDIPLUS_NEXT_ORDER)
type DRAW_GDIPLUS_NEXT_ORDER
{
    AltSecDrawingOrderControlFlags header where value.orderType == AltSecDrawingOrderType.TS_ALTSEC_GDIP_NEXT;
    byte pad1Octet;
    ushort cbSize;
    array<DRAW_GDIPLUS_EMF_Record | EMFRecord> emfRecords with BinaryEncoding{WidthForComposedType = cbSize * 8};
}

// [MS-RDPEGDI] 2.2.2.2.1.3.6.7 Draw GDI+ End (DRAW_GDIPLUS_END_ORDER)
type DRAW_GDIPLUS_END_ORDER
{
    AltSecDrawingOrderControlFlags header where value.orderType == AltSecDrawingOrderType.TS_ALTSEC_GDIP_END;
    byte pad1Octet;
    ushort cbSize;
    uint cbTotalSize;
    uint cbTotalEmfSize;
    array<DRAW_GDIPLUS_EMF_Record | EMFRecord> emfRecords with BinaryEncoding{WidthForComposedType = cbSize * 8};
}

// [MS-RDPEGDI] 2.2.2.2.1.3.7 Frame Marker
type FRAME_MARKER_ORDER
{
    AltSecDrawingOrderControlFlags header where value.orderType == AltSecDrawingOrderType.TS_ALTSEC_FRAME_MARKER;
    FrameMarkerAction action where ValidationCheckEnumValue(InRange<FrameMarkerAction>(value), null, false, ReferenceType.Type, "RDPBCGR", "action", "FRAME_MARKER_ORDER", "0x00000000, 0x00000001", value);
}

pattern FrameMarkerAction = enum uint
{
    TS_FRAME_START  = 0x00000000,
    TS_FRAME_END    = 0x00000001,
    ...
};

optional any DecodingOrderData(stream data, byte orderType)
{
    byte controlFlags = data.PeekByte(data.BitPosition);
    // Primary Drawing Orders
    if ((controlFlags & ControlFlags.TS_STANDARD) != 0 && (controlFlags & ControlFlags.TS_SECONDARY) == 0)
    {
        return BinaryDecoder<PRIMARY_DRAWING_ORDER[orderType]>(data);
    }
    // Secondary Drawing Orders
    else if ((controlFlags & ControlFlags.TS_STANDARD) != 0 && (controlFlags & ControlFlags.TS_SECONDARY) != 0)
    {
        if (data.RemainingByteLength < 6)
        {
            return nothing;
        }
        byte secOrderType = data.PeekByte(data.BitPosition + 40);
        switch (secOrderType)
        {
            case SecondaryDrawingOrderType.TS_CACHE_BITMAP_UNCOMPRESSED =>
                return BinaryDecoder<CACHE_BITMAP_ORDER>(data);
            case SecondaryDrawingOrderType.TS_CACHE_COLOR_TABLE =>
                return BinaryDecoder<CACHE_COLOR_TABLE_ORDER>(data);
            case SecondaryDrawingOrderType.TS_CACHE_BITMAP_COMPRESSED =>
                return BinaryDecoder<CACHE_BITMAP_ORDER>(data);
            case SecondaryDrawingOrderType.TS_CACHE_GLYPH =>
                switch (data)
                {
                    case order:CACHE_GLYPH_REV2_ORDER from BinaryDecoder<CACHE_GLYPH_REV2_ORDER> =>
                        return order;
                    case order:CACHE_GLYPH_ORDER from BinaryDecoder<CACHE_GLYPH_ORDER> =>
                        return order;
                    default =>
                        return nothing;
                }
            case SecondaryDrawingOrderType.TS_CACHE_BITMAP_UNCOMPRESSED_REV2 =>
                return BinaryDecoder<CACHE_BITMAP_REV2_ORDER>(data);
            case SecondaryDrawingOrderType.TS_CACHE_BITMAP_COMPRESSED_REV2 =>
                return BinaryDecoder<CACHE_BITMAP_REV2_ORDER>(data);
            case SecondaryDrawingOrderType.TS_CACHE_BRUSH =>
                return BinaryDecoder<CACHE_BRUSH_ORDER>(data);
            case SecondaryDrawingOrderType.TS_CACHE_BITMAP_COMPRESSED_REV3 =>
                return BinaryDecoder<CACHE_BITMAP_REV3_ORDER>(data);
            default =>
                return nothing;
        }
    }
    // Alternate Secondary Drawing Orders
    else
    {
        byte altOrderType = (controlFlags >> 2) as byte;
        switch (altOrderType)
        {
            case AltSecDrawingOrderType.TS_ALTSEC_CREATE_OFFSCR_BITMAP =>
                return BinaryDecoder<CREATE_OFFSCR_BITMAP_ORDER>(data);
            case AltSecDrawingOrderType.TS_ALTSEC_SWITCH_SURFACE =>
                return BinaryDecoder<SWITCH_SURFACE_ORDER>(data);
            case AltSecDrawingOrderType.TS_ALTSEC_CREATE_NINEGRID_BITMAP =>
                return BinaryDecoder<CREATE_NINEGRID_BITMAP_ORDER>(data);
            case AltSecDrawingOrderType.TS_ALTSEC_STREAM_BITMAP_FIRST =>
                return BinaryDecoder<STREAM_BITMAP_FIRST_ORDER>(data);
            case AltSecDrawingOrderType.TS_ALTSEC_STREAM_BITMAP_NEXT =>
                return BinaryDecoder<STREAM_BITMAP_NEXT_ORDER>(data);
            case AltSecDrawingOrderType.TS_ALTSEC_GDIP_CACHE_FIRST =>
                return BinaryDecoder<DRAW_GDIPLUS_CACHE_FIRST_ORDER>(data);
            case AltSecDrawingOrderType.TS_ALTSEC_GDIP_CACHE_NEXT =>
                return BinaryDecoder<DRAW_GDIPLUS_CACHE_NEXT_ORDER>(data);
            case AltSecDrawingOrderType.TS_ALTSEC_GDIP_CACHE_END =>
                return BinaryDecoder<DRAW_GDIPLUS_CACHE_END_ORDER>(data);
            case AltSecDrawingOrderType.TS_ALTSEC_GDIP_FIRST =>
                return BinaryDecoder<DRAW_GDIPLUS_FIRST_ORDER>(data);
            case AltSecDrawingOrderType.TS_ALTSEC_GDIP_NEXT =>
                return BinaryDecoder<DRAW_GDIPLUS_NEXT_ORDER>(data);
            case AltSecDrawingOrderType.TS_ALTSEC_GDIP_END =>
                return BinaryDecoder<DRAW_GDIPLUS_END_ORDER>(data);
            case AltSecDrawingOrderType.TS_ALTSEC_FRAME_MARKER =>
                return BinaryDecoder<FRAME_MARKER_ORDER>(data);
            case AltSecDrawingOrderType.TS_ALTSEC_WINDOW =>
                int remLen = data.RemainingByteLength;
                if (remLen < 7)
                {
                    return nothing;
                }

                // The following structures may not consume all the length of bytes specified in Hdr.OrderSize.
                // We need to comsume it manunally here.
                uint orderSize = data.PeekUShort(data.BitPosition + 8, Endian.Little);
                if (remLen < orderSize)
                {
                    return nothing;
                }
                binary bin = (BinaryDecoder<Blob[orderSize]>(data) as Blob).Data;

                uint flag = MakeDWord(bin[6], bin[5], bin[4], bin[3]);

                if ((flag & WindowInfo_FieldsPresentFlags.WINDOW_ORDER_TYPE_WINDOW) > 0)
                {
                    if ((flag & WindowInfo_FieldsPresentFlags.WINDOW_ORDER_ICON) > 0)
                    {
                        return BinaryDecoder<WindowIcon>(bin);
                    }
                    else if ((flag & WindowInfo_FieldsPresentFlags.WINDOW_ORDER_CACHEDICON) > 0)
                    {
                        return BinaryDecoder<CachedIcon>(bin);
                    }
                    else if ((flag & WindowInfo_FieldsPresentFlags.WINDOW_ORDER_STATE_DELETED) > 0)
                    {
                        return BinaryDecoder<DeletedWindow>(bin);
                    }
                    else
                    {
                        return BinaryDecoder<NewOrExistingWindow>(bin);
                    }
                }
                else if ((flag & NotificationIcon_FieldsPresentFlags.WINDOW_ORDER_TYPE_NOTIFY) > 0)
                {
                    if ((flag & NotificationIcon_FieldsPresentFlags.WINDOW_ORDER_STATE_DELETED) > 0)
                    {
                        return BinaryDecoder<DeletedNotificationIcons>(bin);
                    }
                    else
                    {
                        return BinaryDecoder<NewOrExistingNotificationIcons>(bin);
                    }
                }
                else if ((flag & DesktopInfo_FieldsPresentFlags.WINDOW_ORDER_TYPE_DESKTOP) > 0)
                {
                    if ((flag & DesktopInfo_FieldsPresentFlags.WINDOW_ORDER_FIELD_DESKTOP_NONE) > 0)
                    {
                        return BinaryDecoder<NonMonitoredDesktop>(bin);
                    }
                    else
                    {
                        return BinaryDecoder<ActivelyMonitoredDesktop>(bin);
                    }
                }
                else
                {
                    return nothing;
                }
            default =>
                return nothing;
        }
    }
}

// Types in [MS-RDPERP], This should be removed after RDPERP is implemented
// [MS-RDPERP] 2.2.1.1.1   Remote Programs Capability Set
type TSRemoteProgramsCapabilitySet
{
    ushort CapabilitySetType where value == 0x0017;
           
    ushort LengthCapability;
           
    RailSupportLevel RailSupportLevel;

    override string ToString()
    {
        return "TSRemoteProgramsCapabilitySet, " + EnumToString<RailSupportLevel>(RailSupportLevel);
    }
}               
with Documentation
       {Applicability = "2.2.1.1.1",
        Description = "The Remote Programs Capability Set is sent by the server in the Demand Active PDU and by the client in the Confirm Active PDU, as specified in [MS-RDPBCGR] section 2.2.1.13. It indicates that the client and server are capable of communicating RAIL PDUs over the RAIL static virtual channel."};

pattern RailSupportLevel = flags uint
{
    TS_RAIL_LEVEL_SUPPORTED                   = 0x00000001
        with Documentation
            {Description = "The client/server is capable of supporting Remote Programs."},
    TS_RAIL_LEVEL_DOCKED_LANGBAR_SUPPORTED    = 0x00000002
        with Documentation
            {Description = "The client/server is capable of supporting Docked Language Bar for Remote Programs."},
    TS_RAIL_LEVEL_SHELL_INTEGRATION_SUPPORTED = 0x00000004
        with Documentation
            {Description = "Set to 1 if the client/server is capable of supporting extended shell integration like tabbed windows and overlay icons for Remote Programs; set to 0 otherwise. This flag MUST be set to 0 if TS_RAIL_LEVEL_SUPPORTED is 0."},
    TS_RAIL_LEVEL_LANGUAGE_IME_SYNC_SUPPORTED = 0x00000008
        with Documentation
            {Description = "The client/server is capable of supporting syncing language/IME changes for Remote Programs."},
    TS_RAIL_LEVEL_SERVER_TO_CLIENT_IME_SYNC_SUPPORTED = 0x00000010
        with Documentation
            {Description = "Set to 1 if the client/server is capable of supporting syncing IME changes originating at the server for Remote Programs; set to 0 otherwise. This flag MUST be set to 0 if TS_RAIL_LEVEL_SUPPORTED is 0."},
    TS_RAIL_LEVEL_HIDE_MINIMIZED_APPS_SUPPORTED = 0x00000020
        with Documentation
            {Description = "Set to 1 if the client/server supports hiding minimized windows of Remote Programs on the server; set to 0 otherwise. This flag MUST be set to 0 if TS_RAIL_LEVEL_SUPPORTED is 0."},
    TS_RAIL_LEVEL_WINDOW_CLOAKING_SUPPORTED = 0x00000040
        with Documentation
            {Description = "Set to 1 if the client/server supports syncing per-window cloak state changes originating on the client for Remote Programs; set to 0 otherwise. This flag MUST be set to 0 if TS_RAIL_LEVEL_SUPPORTED is 0."},
    TS_RAIL_LEVEL_HANDSHAKE_EX_SUPPORTED = 0x00000080
        with Documentation
            {Description = "Set to 1 if the client/server supports the HandshakeEx PDU; set to 0 otherwise. This flag MUST be set to 0 if TS_RAIL_LEVEL_SUPPORTED is 0."},
    ...
};

// [MS-RDPERP] 2.2.1.1.2   Window List Capability Set
pattern WndSupportLevelValue = enum uint
{
    TS_WINDOW_LEVEL_NOT_SUPPORTED = 0x00000000,
    TS_WINDOW_LEVEL_SUPPORTED = 0x00000001,
    TS_WINDOW_LEVEL_SUPPORTED_EX = 0x00000002,
    ...
};
         
type TSWindowListCapabilitySet
{
    ushort CapabilitySetType where value == 0x0018;
           
    ushort LengthCapability;
    
    WndSupportLevelValue WndSupportLevel;
            
    byte NumIconCaches;
           
    ushort NumIconCacheEntries;

    override string ToString()
    {
        return "TSWindowListCapabilitySet, " + EnumToString<WndSupportLevelValue>(WndSupportLevel);
    }
}
with Documentation
       {Applicability = "2.2.1.1.2",
        Description = "The Window List Capability Set is sent by the server in the Demand Active PDU and by the client in the Confirm Active PDU, as specified in [MS-RDPBCGR] section 2.2.1.13. It indicates that the client and server are capable of communicating Windowing Alternate Secondary Drawing Orders as extensions to the core RDP protocol drawing orders (see section 2.2.1.3)."};

// [MS-RDPERP] 2.2.1.2.1   Unicode String
type UNICODE_STRING
{
    ushort CbString;
    optional [|CbString > 0|] string String with BinaryEncoding{Length = CbString / 2};

    override string ToString()
    {
        return CbString > 0 ? (String as string) : "";
    }
}

// [MS-RDPERP] 2.2.1.2.2   Rectangle 
type TS_RECTANGLE_16
{
    ushort Left;
    ushort Top;
    ushort Right;
    ushort Bottom;

    override string ToString()
    {
        return "TS_RECTANGLE_16, Left: " + Left.ToString() + ", Top: " + Top.ToString() + ", Right: " + Right.ToString() + ", Bottom" + Bottom.ToString();
    }
}

// [MS-RDPERP] 2.2.1.2.3   Icon Info
type TS_ICON_INFO
{
    ushort CacheEntry;
    byte CacheId;
    byte Bpp;
    ushort Width;
    ushort Height;
    optional [|Bpp in {1, 4, 8}|] ushort CbColorTable;
    ushort CbBitsMask;
    ushort CbBitsColor;
    optional [|CbBitsMask > 0|] binary BitsMask with BinaryEncoding{Length = CbBitsMask};
    optional [|Bpp in {1, 4, 8}|] binary ColorTable with BinaryEncoding{Length = CbColorTable == nothing ? 0 : (CbColorTable as ushort)};
    optional [|CbBitsColor > 0|] binary BitsColor with BinaryEncoding{Length = CbBitsColor};
}

// [MS-RDPERP] 2.2.1.2.4   Cached Icon Info
type TS_CACHED_ICON_INFO
{
    ushort CacheEntry;
    byte CacheId;
}

// [MS-RDPERP] 2.2.1.3.1.1   Common Header
type TS_WINDOW_ORDER_HEADER
{
    AltSecDrawingOrderControlFlags Header where value.orderType == AltSecDrawingOrderType.TS_ALTSEC_WINDOW;
    ushort OrderSize;
    WindowInfo_FieldsPresentFlags FieldsPresentFlags where (value & WindowInfo_FieldsPresentFlags.WINDOW_ORDER_TYPE_WINDOW) > 0;
    uint WindowId;
}

// re-sort the flags in value order instead of doc order
pattern WindowInfo_FieldsPresentFlags = flags uint
{
    WINDOW_ORDER_FIELD_APPBAR_EDGE           = 0x00000001
        with Documentation
            {Description = "The AppBarEdge field is present."},
    WINDOW_ORDER_FIELD_OWNER                 = 0x00000002
        with Documentation
            {Description = "The OwnerWindowId field is present."},
    WINDOW_ORDER_FIELD_TITLE                 = 0x00000004
        with Documentation
            {Description = "The TitleInfo field is present."},
    WINDOW_ORDER_FIELD_STYLE                 = 0x00000008
        with Documentation
            {Description = "The Style and ExtendedStyle fields are present."},
    WINDOW_ORDER_FIELD_SHOW                  = 0x00000010
        with Documentation
            {Description = "The ShowState field is present."},
    WINDOW_ORDER_FIELD_RESIZE_MARGIN_X       = 0x00000080
        with Documentation
            {Description = "The WindowLeftResizeMargin and WindowRightResizeMargin fields are present."},
    WINDOW_ORDER_FIELD_WNDRECTS              = 0x00000100
        with Documentation
            {Description = "The NumWindowRects and WindowRects fields are present."},
    WINDOW_ORDER_FIELD_VISIBILITY            = 0x00000200
        with Documentation
            {Description = "The NumVisibilityRects and VisibilityRects fields are present."},
    WINDOW_ORDER_FIELD_WNDSIZE               = 0x00000400
        with Documentation
            {Description = "The WindowWidth and WindowHeight fields are present."},
    WINDOW_ORDER_FIELD_WNDOFFSET             = 0x00000800
        with Documentation
            {Description = "The WindowOffsetX and WindowOffsetY fields are present."},
    WINDOW_ORDER_FIELD_VISOFFSET             = 0x00001000
        with Documentation
            {Description = "The VisibleOffsetX and VisibleOffsetY fields are present."},
    WINDOW_ORDER_FIELD_ICON_BIG              = 0x00002000
        with Documentation
            {Description = "The large version of the icon is being referred to."},
    WINDOW_ORDER_FIELD_CLIENTAREAOFFSET      = 0x00004000
        with Documentation
            {Description = "The ClientOffsetX and ClientOffsetY fields are present."},
    WINDOW_ORDER_FIELD_WNDCLIENTDELTA        = 0x00008000
        with Documentation
            {Description = "The WindowClientDeltaX and WindowClientDeltaY fields are present."},
    WINDOW_ORDER_FIELD_CLIENTAREASIZE        = 0x00010000
        with Documentation
            {Description = "The ClientAreaWidth and ClientAreaHeight fields are present."},
    WINDOW_ORDER_FIELD_RPCONTENT             = 0x00020000
        with Documentation
            {Description = "The RPContent field is present."},
    WINDOW_ORDER_FIELD_ROOTPARENT            = 0x00040000
        with Documentation
            {Description = "The RootParentHandle field is present."},
    WINDOW_ORDER_FIELD_ENFORCE_SERVER_ZORDER = 0x00080000
        with Documentation
            {Description = "The EnforceServerZOrder field is present."},
    WINDOW_ORDER_FIELD_ICON_OVERLAY          = 0x00100000
        with Documentation
            {Description = "The overlay icon for the window is being sent. If this flag is not present, the icon is an application icon."},
    WINDOW_ORDER_FIELD_ICON_OVERLAY_NULL     = 0x00200000
        with Documentation
            {Description = "The large version of the icon is being referred to."},
    WINDOW_ORDER_FIELD_OVERLAY_DESCRIPTION   = 0x00400000
        with Documentation
            {Description = "The OverlayDescription field is present."},
    WINDOW_ORDER_FIELD_TASKBAR_BUTTON        = 0x00800000
        with Documentation
            {Description = "A taskbar overlay icon previously set by the window has been removed."},
    WINDOW_ORDER_TYPE_WINDOW                 = 0x01000000
        with Documentation
            {Description = "Indicates a Windowing Alternate Secondary Drawing Order that describes a window."},
    WINDOW_ORDER_FIELD_APPBAR_STATE          = 0x04000000
        with Documentation
            {Description = "The AppBarState field is present."},
    WINDOW_ORDER_FIELD_RESIZE_MARGIN_Y       = 0x08000000
        with Documentation
            {Description = "The WindowTopResizeMargin and WindowBottomResizeMargin fields are present."},
    WINDOW_ORDER_STATE_NEW                   = 0x10000000
        with Documentation
            {Description = "The Windowing Alternate Secondary Drawing Order contains information for a new window."},
    WINDOW_ORDER_STATE_DELETED               = 0x20000000
        with Documentation
            {Description = "The window is deleted."},
    WINDOW_ORDER_ICON                        = 0x40000000
        with Documentation
            {Description = "The Icon field is present."},
    WINDOW_ORDER_CACHEDICON                  = 0x80000000
        with Documentation
            {Description = "The order contains cached icon information for the window."},
    ...
};

// [MS-RDPERP] 2.2.1.3.1.2.1   New or Existing Window
type NewOrExistingWindow 
{
    TS_WINDOW_ORDER_HEADER Hdr;
    optional [|(Hdr.FieldsPresentFlags & WindowInfo_FieldsPresentFlags.WINDOW_ORDER_FIELD_OWNER) > 0|] uint OwnerWindowId;
    optional [|(Hdr.FieldsPresentFlags & WindowInfo_FieldsPresentFlags.WINDOW_ORDER_FIELD_STYLE) > 0|] uint Style;
    optional [|(Hdr.FieldsPresentFlags & WindowInfo_FieldsPresentFlags.WINDOW_ORDER_FIELD_STYLE) > 0|] uint ExtendedStyle;
    optional [|(Hdr.FieldsPresentFlags & WindowInfo_FieldsPresentFlags.WINDOW_ORDER_FIELD_SHOW) > 0|] ShowState ShowState;
    optional [|(Hdr.FieldsPresentFlags & WindowInfo_FieldsPresentFlags.WINDOW_ORDER_FIELD_TITLE) > 0|] UNICODE_STRING TitleInfo;
    optional [|(Hdr.FieldsPresentFlags & WindowInfo_FieldsPresentFlags.WINDOW_ORDER_FIELD_CLIENTAREAOFFSET) > 0|] uint ClientOffsetX;
    optional [|(Hdr.FieldsPresentFlags & WindowInfo_FieldsPresentFlags.WINDOW_ORDER_FIELD_CLIENTAREAOFFSET) > 0|] uint ClientOffsetY;
    optional [|(Hdr.FieldsPresentFlags & WindowInfo_FieldsPresentFlags.WINDOW_ORDER_FIELD_CLIENTAREASIZE) > 0|] uint ClientAreaWidth;
    optional [|(Hdr.FieldsPresentFlags & WindowInfo_FieldsPresentFlags.WINDOW_ORDER_FIELD_CLIENTAREASIZE) > 0|] uint ClientAreaHeight;
    optional [|(Hdr.FieldsPresentFlags & WindowInfo_FieldsPresentFlags.WINDOW_ORDER_FIELD_RESIZE_MARGIN_X) > 0|] uint WindowLeftResizeMargin;
    optional [|(Hdr.FieldsPresentFlags & WindowInfo_FieldsPresentFlags.WINDOW_ORDER_FIELD_RESIZE_MARGIN_X) > 0|] uint WindowRightResizeMargin;
    optional [|(Hdr.FieldsPresentFlags & WindowInfo_FieldsPresentFlags.WINDOW_ORDER_FIELD_RESIZE_MARGIN_Y) > 0|] uint WindowTopResizeMargin;
    optional [|(Hdr.FieldsPresentFlags & WindowInfo_FieldsPresentFlags.WINDOW_ORDER_FIELD_RESIZE_MARGIN_Y) > 0|] uint WindowBottomResizeMargin;
    optional [|(Hdr.FieldsPresentFlags & WindowInfo_FieldsPresentFlags.WINDOW_ORDER_FIELD_RPCONTENT) > 0|] RPContent RPContent;
    optional [|(Hdr.FieldsPresentFlags & WindowInfo_FieldsPresentFlags.WINDOW_ORDER_FIELD_ROOTPARENT) > 0|] uint RootParentHandle;
    optional [|(Hdr.FieldsPresentFlags & WindowInfo_FieldsPresentFlags.WINDOW_ORDER_FIELD_WNDOFFSET) > 0|] uint WindowOffsetX;
    optional [|(Hdr.FieldsPresentFlags & WindowInfo_FieldsPresentFlags.WINDOW_ORDER_FIELD_WNDOFFSET) > 0|] uint WindowOffsetY;
    optional [|(Hdr.FieldsPresentFlags & WindowInfo_FieldsPresentFlags.WINDOW_ORDER_FIELD_WNDCLIENTDELTA) > 0|] uint WindowClientDeltaX;
    optional [|(Hdr.FieldsPresentFlags & WindowInfo_FieldsPresentFlags.WINDOW_ORDER_FIELD_WNDCLIENTDELTA) > 0|] uint WindowClientDeltaY;
    optional [|(Hdr.FieldsPresentFlags & WindowInfo_FieldsPresentFlags.WINDOW_ORDER_FIELD_WNDSIZE) > 0|] uint WindowWidth;
    optional [|(Hdr.FieldsPresentFlags & WindowInfo_FieldsPresentFlags.WINDOW_ORDER_FIELD_WNDSIZE) > 0|] uint WindowHeight;
    optional [|(Hdr.FieldsPresentFlags & WindowInfo_FieldsPresentFlags.WINDOW_ORDER_FIELD_WNDRECTS) > 0|] ushort NumWindowRects;
    optional [|(Hdr.FieldsPresentFlags & WindowInfo_FieldsPresentFlags.WINDOW_ORDER_FIELD_WNDRECTS) > 0|] array<TS_RECTANGLE_16> WindowRects 
        with BinaryEncoding{Length = NumWindowRects == nothing ? 0 : (NumWindowRects as ushort)};
    optional [|(Hdr.FieldsPresentFlags & WindowInfo_FieldsPresentFlags.WINDOW_ORDER_FIELD_VISOFFSET) > 0|] uint VisibleOffsetX;
    optional [|(Hdr.FieldsPresentFlags & WindowInfo_FieldsPresentFlags.WINDOW_ORDER_FIELD_VISOFFSET) > 0|] uint VisibleOffsetY;
    optional [|(Hdr.FieldsPresentFlags & WindowInfo_FieldsPresentFlags.WINDOW_ORDER_FIELD_VISIBILITY) > 0|] ushort NumVisibilityRects;
    optional [|(Hdr.FieldsPresentFlags & WindowInfo_FieldsPresentFlags.WINDOW_ORDER_FIELD_VISIBILITY) > 0|] array<TS_RECTANGLE_16> VisibilityRects 
        with BinaryEncoding{Length = NumVisibilityRects == nothing ? 0 : (NumVisibilityRects as ushort)};
    optional [|(Hdr.FieldsPresentFlags & WindowInfo_FieldsPresentFlags.WINDOW_ORDER_FIELD_OVERLAY_DESCRIPTION) > 0|] UNICODE_STRING OverlayDescription;
    optional [|(Hdr.FieldsPresentFlags & WindowInfo_FieldsPresentFlags.WINDOW_ORDER_FIELD_TASKBAR_BUTTON) > 0|] byte TaskbarButton;
    optional [|(Hdr.FieldsPresentFlags & WindowInfo_FieldsPresentFlags.WINDOW_ORDER_FIELD_ENFORCE_SERVER_ZORDER) > 0|] byte EnforceServerZOrder;
    optional [|(Hdr.FieldsPresentFlags & WindowInfo_FieldsPresentFlags.WINDOW_ORDER_FIELD_APPBAR_STATE) > 0|] byte AppBarState;
    optional [|(Hdr.FieldsPresentFlags & WindowInfo_FieldsPresentFlags.WINDOW_ORDER_FIELD_APPBAR_EDGE) > 0|] AppBarEdge AppBarEdge;
}

pattern ShowState = enum byte
{
    NotShow                = 0x00,
    Minimized              = 0x02,
    Maximized              = 0x03,
    CurrentSizeAndPosition = 0x05,
    ...
};

pattern RPContent = enum byte
{
    NotUsedByRenderPlugin = 0x00,
    UsedByRenderPlugin    = 0x01,
    ...
};

pattern AppBarEdge = enum byte
{
    Left   = 0x00,
    Top    = 0x01,
    Right  = 0x02,
    Bottom = 0x03
    ...
};



// [MS-RDPERP] 2.2.1.3.1.2.2   Window Icon
type WindowIcon
{
    TS_WINDOW_ORDER_HEADER Hdr;
    invariant (Hdr.FieldsPresentFlags & WindowInfo_FieldsPresentFlags.WINDOW_ORDER_ICON) > 0;
    TS_ICON_INFO IconInfo;
}

// [MS-RDPERP] 2.2.1.3.1.2.3   Cached Icon
type CachedIcon
{
    TS_WINDOW_ORDER_HEADER Hdr;
    invariant (Hdr.FieldsPresentFlags & WindowInfo_FieldsPresentFlags.WINDOW_ORDER_CACHEDICON) > 0;
    TS_CACHED_ICON_INFO CachedIcon;
}

// [MS-RDPERP] 2.2.1.3.1.2.4   Deleted Window
type DeletedWindow
{
    TS_WINDOW_ORDER_HEADER Hdr;
    invariant (Hdr.FieldsPresentFlags & WindowInfo_FieldsPresentFlags.WINDOW_ORDER_STATE_DELETED) > 0;
}

// [MS-RDPERP] 2.2.1.3.2.1   Common Header
type TS_NOTIFYICON_ORDER_HEADER
{
    AltSecDrawingOrderControlFlags Header where value.orderType == AltSecDrawingOrderType.TS_ALTSEC_WINDOW;
    ushort OrderSize;
    NotificationIcon_FieldsPresentFlags FieldsPresentFlags where (value & NotificationIcon_FieldsPresentFlags.WINDOW_ORDER_TYPE_NOTIFY) > 0;
    uint WindowId;
    uint NotifyIconId;
}

pattern NotificationIcon_FieldsPresentFlags = flags uint
{
    WINDOW_ORDER_TYPE_NOTIFY           = 0x02000000
        with Documentation
            {Description = "Indicates a Windowing Alternate Secondary Drawing Order specifying a notification icon."},
    WINDOW_ORDER_STATE_NEW             = 0x10000000
        with Documentation
            {Description = "The Windowing Alternate Secondary Drawing Order contains information for a new notification icon."},
    WINDOW_ORDER_STATE_DELETED         = 0x20000000
        with Documentation
            {Description = "The window is deleted."},
    WINDOW_ORDER_FIELD_NOTIFY_VERSION  = 0x00000008
        with Documentation
            {Description = "The Version field is present."},
    WINDOW_ORDER_FIELD_NOTIFY_TIP      = 0x00000001
        with Documentation
            {Description = "The ToolTip field is present."},
    WINDOW_ORDER_FIELD_NOTIFY_INFO_TIP = 0x00000002
        with Documentation
            {Description = "The InfoTip field is present."},
    WINDOW_ORDER_FIELD_NOTIFY_STATE    = 0x00000004
        with Documentation
            {Description = "The State field is present."},
    WINDOW_ORDER_ICON                  = 0x40000000
        with Documentation
            {Description = "The Icon field is present."},
    WINDOW_ORDER_CACHED_ICON           = 0x80000000
        with Documentation
            {Description = "The CachedIcon field is present."},
    ...
};

// [MS-RDPERP] 2.2.1.3.2.2.1   New or Existing Notification Icons
type NewOrExistingNotificationIcons
{
    TS_NOTIFYICON_ORDER_HEADER Hdr;
    optional [|(Hdr.FieldsPresentFlags & NotificationIcon_FieldsPresentFlags.WINDOW_ORDER_FIELD_NOTIFY_VERSION) > 0|] NewOrExistingNotificationIcons_Version Version;
    optional [|(Hdr.FieldsPresentFlags & NotificationIcon_FieldsPresentFlags.WINDOW_ORDER_FIELD_NOTIFY_TIP) > 0|] UNICODE_STRING ToolTip;
    optional [|(Hdr.FieldsPresentFlags & NotificationIcon_FieldsPresentFlags.WINDOW_ORDER_FIELD_NOTIFY_INFO_TIP) > 0|] TS_NOTIFY_ICON_INFOTIP InfoTip;
    optional [|(Hdr.FieldsPresentFlags & NotificationIcon_FieldsPresentFlags.WINDOW_ORDER_FIELD_NOTIFY_STATE) > 0|] NewOrExistingNotificationIcons_State State;
    optional [|(Hdr.FieldsPresentFlags & NotificationIcon_FieldsPresentFlags.WINDOW_ORDER_ICON) > 0|] TS_ICON_INFO Icon;
    optional [|(Hdr.FieldsPresentFlags & NotificationIcon_FieldsPresentFlags.WINDOW_ORDER_CACHED_ICON) > 0|] TS_CACHED_ICON_INFO CachedIcon;
}

pattern NewOrExistingNotificationIcons_Version = enum uint
{
    WindowsNT4 = 0,
    Windows2000 = 3,
    CurrentWindows = 4,
    ...
};

pattern NewOrExistingNotificationIcons_State = enum uint
{
    Hidden = 1,
    ...
};

// [MS-RDPERP] 2.2.1.3.2.2.2   Deleted Notification Icons
type DeletedNotificationIcons
{
    TS_NOTIFYICON_ORDER_HEADER Hdr;
    invariant (Hdr.FieldsPresentFlags & NotificationIcon_FieldsPresentFlags.WINDOW_ORDER_STATE_DELETED) > 0;
}

// [MS-RDPERP] 2.2.1.3.2.2.3   Notification Icon Balloon Tooltip 
type TS_NOTIFY_ICON_INFOTIP
{
    uint Timeout;
    InfoFlags InfoFlags;
    UNICODE_STRING InfoTipText;
    UNICODE_STRING Title;
}

pattern InfoFlags = enum uint
{
    NIIF_NONE       = 0x00000000,
    NIIF_INFO       = 0x00000001,
    NIIF_WARNING    = 0x00000002,
    NIIF_ERROR      = 0x00000003,
    NIIF_NOSOUND    = 0x00000010,
    NIIF_LARGE_ICON = 0x00000020,
    ...
};

// [MS-RDPERP] 2.2.1.3.3.1   Common Header
type TS_DESKTOP_ORDER_HEADER
{
    AltSecDrawingOrderControlFlags Header where value.orderType == AltSecDrawingOrderType.TS_ALTSEC_WINDOW;
    ushort OrderSize;
    DesktopInfo_FieldsPresentFlags FieldsPresentFlags where (value & DesktopInfo_FieldsPresentFlags.WINDOW_ORDER_TYPE_DESKTOP) > 0;
}

pattern DesktopInfo_FieldsPresentFlags = flags uint
{
    WINDOW_ORDER_TYPE_DESKTOP                = 0x04000000
        with Documentation
            {Description = "Indicates an order specifying a desktop."},
    WINDOW_ORDER_FIELD_DESKTOP_HOOKED        = 0x00000002
        with Documentation
            {Description = "The server will be sending information for the server's current input desktop."},
    WINDOW_ORDER_FIELD_DESKTOP_ARC_BEGAN     = 0x00000008
        with Documentation
            {Description = "The server is beginning to synchronize information with the client after the client has auto-reconnected or the server has just begun monitoring a new desktop."},
    WINDOW_ORDER_FIELD_DESKTOP_ARC_COMPLETED = 0x00000004
        with Documentation
            {Description = "The server has finished synchronizing data after the client has auto-reconnected or the server has just begun monitoring a new desktop."},
    WINDOW_ORDER_FIELD_DESKTOP_ACTIVEWND     = 0x00000020
        with Documentation
            {Description = "The ActiveWindowId field is present."},
    WINDOW_ORDER_FIELD_DESKTOP_ZORDER        = 0x00000010
        with Documentation
            {Description = "The NumWindowIds field is present."},
    WINDOW_ORDER_FIELD_DESKTOP_NONE          = 0x00000001
        with Documentation
            {Description = "Indicates an order specifying a desktop."},
    ...
};

// [MS-RDPERP] 2.2.1.3.3.2.1   Actively Monitored Desktop
type ActivelyMonitoredDesktop
{
    TS_DESKTOP_ORDER_HEADER Hdr;
    optional [|(Hdr.FieldsPresentFlags & DesktopInfo_FieldsPresentFlags.WINDOW_ORDER_FIELD_DESKTOP_ACTIVEWND) > 0|] uint ActiveWindowId;
    optional [|(Hdr.FieldsPresentFlags & DesktopInfo_FieldsPresentFlags.WINDOW_ORDER_FIELD_DESKTOP_ZORDER) > 0|] byte NumWindowIds;
    optional [|(Hdr.FieldsPresentFlags & DesktopInfo_FieldsPresentFlags.WINDOW_ORDER_FIELD_DESKTOP_ZORDER) > 0 && (NumWindowIds as byte) > 0|] array<uint> WindowIds
        with BinaryEncoding{Length = NumWindowIds == nothing ? 0 : (NumWindowIds as byte)};
}

// [MS-RDPERP] 2.2.1.3.3.2.2   Non-Monitored Desktop
type NonMonitoredDesktop
{
    TS_DESKTOP_ORDER_HEADER Hdr;
    invariant (Hdr.FieldsPresentFlags & DesktopInfo_FieldsPresentFlags.WINDOW_ORDER_FIELD_DESKTOP_NONE) > 0;
}

message IncompleteFastPathPDU
{
    TSFPUpdatePduFPOutputHeader FPOutputHeader;
    byte Length1;
    optional ([|(Length1 & 0x80) == 0x80|] byte) Length2;
    binary Data;

    override string ToString()
    {
        return "Incomplete Fast-Path PDU";
    }
} with Documentation{Ignore = true};

type RDPBCGRDecodingHelper : TCPDecodingHelper
{
    void InitializeForRDP(TCP.Server tcpEPT)
    {
        var acceptsCache = new RDPBCGRDecodingCache();
        acceptsCache.InitializeRDPCache(tcpEPT, MessageDirection.Accepts);
        var issuesCache = new RDPBCGRDecodingCache();
        issuesCache.InitializeRDPCache(tcpEPT, MessageDirection.Issues);

        AcceptsCache = acceptsCache;
        IssuesCache = issuesCache;
    }
}

type RDPBCGRDecodingCache: TCP.TCPDecodingCache
{
    internal ProtocolOnRDPPort protocolType;
    internal ISOTS.Server tpktEPT;
    internal Server bcgrEPT;
    internal int msgLength;

    // The initial value for the orderType agreed on by both the server and client is TS_ENC_PATBLT_ORDER(0x01).
    internal byte OrderType = PrimaryDrawingOrderType.TS_ENC_PATBLT_ORDER;

    void InitializeRDPCache(TCP.Server tcpEPT, MessageDirection direct)
    {
        this.tpktEPT = endpoint ISOTS.Server over tcpEPT;
        this.bcgrEPT = endpoint Server over tcpEPT;
        this.protocolType = ProtocolOnRDPPort.RDPBCGR;
        this.msgLength = 0;
        
        Initialize(
            MODULE_NAME,
            this.bcgrEPT,
            direct,
            IsProtoclOnRDPPort,
            IsSufficient,
            Decode,
            DecodeIncomplete);
    }

    bool? IsProtoclOnRDPPort(binary bin)
    {
        if (bin.Count < 4)
        {
            protocolType = ProtocolOnRDPPort.RDPBCGR;
            EPT = bcgrEPT;
            return null;
        }

        if (IsTPKTStream(bin) == true)
        {
            protocolType = ProtocolOnRDPPort.ISOTS;
            EPT = tpktEPT;
        }
        else
        {
            protocolType = ProtocolOnRDPPort.RDPBCGR;
            EPT = bcgrEPT;
        }

        return true;
    }

    uint? IsSufficient(binary bin)
    {
        msgLength = 0;

        switch (protocolType)
        {
            case ProtocolOnRDPPort.ISOTS =>
                msgLength = GetTPKTLength(bin);
            default =>
                msgLength = GetRDPBCGRLength(bin);
        }

        return msgLength < 0 ? null : (msgLength > bin.Count ? (msgLength as uint) : 0);
    }

    optional any message Decode(stream s)
    {
        optional any message res = nothing;

        switch (protocolType)
        {
            case ProtocolOnRDPPort.ISOTS =>
                var msg = BinaryDecoder<ISOTS.TPKT>(s);
                if (msg is tpkt:ISOTS.TPKT)
                {
                    if (Origins.Count > 0 &&
                        Origins[0] is seg:Segment)
                    {
                        tpkt#SourcePort = seg.SourcePort;
                        tpkt#DestinationPort = seg.DestinationPort;
                    }
                }
                res = msg;
            default =>
                binary data = (BinaryDecoder<Blob[msgLength as uint]>(s) as Blob).Data;
                if (Direction == MessageDirection.Accepts)
                {
                    res = BinaryDecoder<TS_FP_INPUT_PDU>(data);
                }
                else
                {
                    var msg = BinaryDecoder<TS_FP_UPDATE_PDU>(data);
                    if (msg is updatePdu:TS_FP_UPDATE_PDU)
                    {
                        if (updatePdu.fpOutputUpdates is updates:array<TS_FP_UPDATE>)
                        {
                            foreach (var update in updates)
                            {
                                if (update is orderUpdate:TS_FP_UPDATE_ORDERS)
                                {
                                    if (orderUpdate.orderData == nothing)
                                    {
                                        break;
                                    }                                        
                                    binary orderDatabin = orderUpdate.orderData as binary;
                                    stream str = orderDatabin;
                                    array<any> orders = [];
                                    while (str.RemainingByteLength > 0)
                                    {
                                        var order = DecodingOrderData(str, OrderType);
                                        if (order != nothing)
                                        {
                                            orders += [order];
                                            if (order is o:PRIMARY_DRAWING_ORDER && o.orderType != nothing)
                                            {
                                                OrderType = o.orderType as byte;
                                            }
                                        }
                                        else
                                        {
                                            uint len = str.RemainingByteLength as uint;
                                            orders += [(BinaryDecoder<Blob[len]>(str) as Blob[len]).Data];
                                            ValidationCheck(false, null, DiagnosisLevel.Error, () => Format(RDPBCGR_ORDER_DECODE_ERROR_STR, ["TS_FP_UPDATE_ORDERS"]));
                                            break;
                                        }
                                    }
                                    orderUpdate.orderData = orders;
                                }
                            }
                        }
                    }
                    res = msg;
                }
        }

        return res;
    }

    optional any message DecodeIncomplete(binary bin)
    {
        optional any message res = nothing;

        switch (protocolType)
        {
            case ProtocolOnRDPPort.ISOTS =>
                res = BinaryDecoder<ISOTS.IncompleteTPKT>(bin);
            default =>
                res = BinaryDecoder<IncompleteFastPathPDU>(bin);
        }

        return res;
    }
}with Encoding{Ignore = true};

int GetRDPBCGRLength((binary|stream) data)
{
    stream s;
    if (data is bin:binary)
        s = bin;
    else
        s = data as stream;
    if (s.RemainingByteLength < 3)
    {
        return -1;
    }

    int msgLength = 0;
    byte b = s.PeekByte(s.BitPosition + 8);
    int length1 = b & 0x7F;
    if ((b & 0x80) == 0x00)
        msgLength = length1;
    else
        msgLength = (length1 << 8) + s.PeekByte(s.BitPosition + 16);
        
    return msgLength;
}

pattern ProtocolOnRDPPort = enum
{
    RDPBCGR,
    ISOTS,
    ...
};

bool IsAutoDetectMsg(binary payload, TSUDSCSec1EncryptionLevel encryptionLevel, TSUDSCSec1EncryptionMethod encryptionMethod, RDPBCGRMsgType msgType)
{
    int msgOffset = 0;
    byte securityFlag = payload[msgOffset + 1];
    if (encryptionLevel == TSUDSCSec1EncryptionLevel.ENCRYPTION_LEVEL_LOW || encryptionLevel == TSUDSCSec1EncryptionLevel.ENCRYPTION_LEVEL_NONE)
    {
        msgOffset = msgOffset + 4;
    }
    else if (encryptionMethod in {TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_40BIT,
                                    TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_128BIT,
                                    TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_56BIT})
    {
        msgOffset = msgOffset + 12;
    }
    else if (encryptionMethod == TSUDSCSec1EncryptionMethod.ENCRYPTION_METHOD_FIPS)
    {
        msgOffset = msgOffset + 16;
    }
    if (((msgType == RDPBCGRMsgType.ServerAutoDetectRequestPdu) && 
            ((securityFlag & 0x10) == 0x10)) ||
       ((msgType == RDPBCGRMsgType.ClientAutoDetectResponsePdu) &&
            ((securityFlag & 0x20) == 0x20)))
        return true;
    else
        return false;
}

pattern Unicode = string with BinaryEncoding{TextEncoding = TextEncoding.UTF16};
string BinaryToUnicode(any input)
{
    binary b = input as binary;

    switch (b)
    {
        case s:Unicode from BinaryDecoder=>
            return s;
        default=>
            return b.ToString();
    }
}

// To decode extention for [MS-RDPELE], define some RDPELE type in RDPBCGR
// [MS-RDPELE] section 2.2.2.1   Server License Request (SERVER_LICENSE_REQUEST)
pattern KeyExchangeAlg = enum uint
{
    KEY_EXCHANGE_ALG_RSA = 0x00000001,
    ...
};

// [MS-RDPELE]:2.2.1.4.2   X.509 Certificate Chain (X509 _CERTIFICATE_CHAIN)
type X509CertificateChain
{
    uint NumCertBlobs;
    array<CertBlob> CertBlobArray with BinaryEncoding{Length = NumCertBlobs};
    array<byte> Padding with BinaryEncoding{Length = ((8 + (4 * NumCertBlobs)))};
}

// [MS-RDPELE]:2.2.1.4.2.1   CertBlob (CERT_BLOB)
type CertBlob
{
    uint CbCert;
    array<byte> AbCert with BinaryEncoding{Length = CbCert};
}

int GetbMsgType(binary payload, TSUDSCSec1EncryptionLevel encryptionLevel, TSUDSCSec1EncryptionMethod encryptionMethod, bool clientToServer, bool isSecEncrypt)
{
    int msgOffset = 0;
    // If the PDU is being sent from the server to the client
    if (!clientToServer)
    {
        if (!isSecEncrypt || encryptionLevel in {TSUDSCSec1EncryptionLevel.ENCRYPTION_LEVEL_NONE,
                                TSUDSCSec1EncryptionLevel.ENCRYPTION_LEVEL_LOW})
            msgOffset = msgOffset + 4;
        else if (isSecEncrypt && (encryptionLevel in {TSUDSCSec1EncryptionLevel.ENCRYPTION_LEVEL_CLIENT_COMPATIBLE,
                                                     TSUDSCSec1EncryptionLevel.ENCRYPTION_LEVEL_HIGH}))
            msgOffset = msgOffset + 12;
        else if (isSecEncrypt && encryptionLevel == TSUDSCSec1EncryptionLevel.ENCRYPTION_LEVEL_FIPS)
            msgOffset = msgOffset + 16;
    }
    // If the PDU is being sent from the client to the server
    else
    {
        if (isSecEncrypt && (encryptionLevel in {TSUDSCSec1EncryptionLevel.ENCRYPTION_LEVEL_LOW,
                                                    TSUDSCSec1EncryptionLevel.ENCRYPTION_LEVEL_CLIENT_COMPATIBLE,
                                                    TSUDSCSec1EncryptionLevel.ENCRYPTION_LEVEL_HIGH}))
            msgOffset = msgOffset + 12;
        else
            msgOffset = msgOffset + 4;
    }

    if((msgOffset != 0) && (payload.Count > msgOffset))
        return payload[msgOffset];
    else
        return 0;
}

// Reassemble VirtualChannelPdu
type RDPBCGRReassemblyHelper : ReassemblyHelper<VirtualChannelPdu>
{
    array<VirtualChannelPdu> fragments = [];

    override bool IsCompleteMessage(VirtualChannelPdu msg)
    {
        if(msg.channelPduHeader.$"flags".CHANNEL_PACKET_COMPRESSED || // Not reassemble the compressed messages
            msg.channelPduHeader.$"flags".CHANNEL_FLAG_FIRST && 
            msg.channelPduHeader.$"flags".CHANNEL_FLAG_LAST)
        {
            ClearExceptionally();
            return true;
        }
        
        return false;
    }

    override void Add(VirtualChannelPdu msg)
    {
        if (msg.channelPduHeader.$"flags".CHANNEL_FLAG_FIRST)
        {
            ClearExceptionally();
            fragments = [msg];
        }
        else if (fragments.Count > 0)
        {
            fragments += [msg];
        }
        else
        {
            DisplayTopLevelMessage(msg);
        }
    }

    override void ClearExceptionally()
    {
        if (fragments.Count > 0)
        {
            foreach (var frag in fragments)
            {
                ValidationCheck(false, frag, DiagnosisLevel.Warning, RDPBCGR_REASSEMBLE_FAILURE);
                DisplayTopLevelMessage(frag);
            }
            fragments = [];
        }
    }

    override bool IsAllFragmentsArrived(VirtualChannelPdu msg)
    {
        return fragments.Count > 0 && msg.channelPduHeader.$"flags".CHANNEL_FLAG_LAST;
    }

    override array<VirtualChannelPdu> GetSorted(VirtualChannelPdu msg)
    {
        return fragments;
    }

    override optional VirtualChannelPdu GetMessageFromFragments(array<VirtualChannelPdu> sortedMsg)
    {
        VirtualChannelPdu msg = null;
        foreach (var frag in sortedMsg)
        {
            if (msg == null)
            {
                msg = new VirtualChannelPdu{};
                msg.securityHeader = frag.securityHeader;
                msg.channelPduHeader = new CHANNEL_PDU_HEADER
                {
                    length = frag.channelPduHeader.length,
                    $"flags" = frag.channelPduHeader.$"flags",
                };
                msg.channelPduHeader.$"flags".CHANNEL_FLAG_FIRST = false;
                msg.channelPduHeader.$"flags".Reserved1 = 0x0;
                msg.channelPduHeader.$"flags".CHANNEL_FLAG_SHOW_PROTOCOL = false;
                msg.channelPduHeader.$"flags".CHANNEL_FLAG_SUSPEND = false;
                msg.channelPduHeader.$"flags".CHANNEL_FLAG_RESUME = false;
                msg.channelPduHeader.$"flags".CHANNEL_FLAG_SHADOW_PERSISTENT = false;
                msg.channelPduHeader.$"flags".Reserved2 = 0x0;
                msg.channelPduHeader.$"flags".CompressionTypeMask = 0x0;
                msg.channelPduHeader.$"flags".Reserved3 = false;
                msg.channelPduHeader.$"flags".CHANNEL_PACKET_COMPRESSED = false;
                msg.channelPduHeader.$"flags".CHANNEL_PACKET_AT_FRONT = false;
                msg.channelPduHeader.$"flags".CHANNEL_PACKET_FLUSHED = false;
                msg.channelPduHeader.$"flags".Reserverd4 = 0x0;
                msg.virtualChannelData = frag.virtualChannelData;
                msg#ChannelName = frag#ChannelName;
            }
            else
            {
                msg.virtualChannelData += frag.virtualChannelData;
            }
            msg.Origins += [frag];
        }
        msg.SourceData = msg.virtualChannelData;
            
        // set fields offset
        msg.AssignFieldEncodingInfo("virtualChannelData", 0, msg.virtualChannelData.Count * 8);
        return msg;
    }

    override void ClearAfterSuccess(VirtualChannelPdu msg)
    {
        fragments = [];
    }

    override void ClearInDestructor()
    {
        ClearExceptionally();
    }
}

const int CHANNEL_CHUNK_LENGTH = 1600;

// 2.2.7.2.10.1.1   Bitmap Codec (TS_BITMAPCODEC)
const guid CODEC_GUID_NSCODEC = {CA8D1BB9-000F-154F-589F-AE2D1A87E2D6};
const guid CODEC_GUID_REMOTEFX = {76772F12-BD72-4463-AFB3-B73C9C6F7886};
const guid CODEC_GUID_IMAGE_REMOTEFX = {2744CCD4-9D8A-4E74-803C-0ECBEEA19C54};
const guid CODEC_GUID_IGNORE = {9C4351A6-3535-42AE-910C-CDFCE5760B58};

pattern TrueFalseUshort = enum ushort
{
    FALSE = 0x0000,
    TRUE = 0x0001,
    ...
};

pattern TrueFalseByte = enum byte
{
    FALSE = 0x00,
    TRUE = 0x01,
    ...
};
