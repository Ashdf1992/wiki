protocol ECS with 
Documentation
{
    ProtocolName = "Enterprise Client Synchronization Protocol",
    ShortName = "ECS",
    Description = ""
},
OPNAuthoring
{
    Copyright = "(c) Microsoft Corporation",
    References = 
        [
            new Reference{Name = "MS-ECS", Version = "4.0", Date = "06/30/2015", ProgramName = ProgramName.WSPP},
        ],
    RevisionSummary = 
        [
            new Revision{Class = RevisionClass.Major, Version = "", Date = "07/24/2015"}
        ]
};

using Standard;
using Utility;
using DTYP;
using HTTP;
using FSVCA;
using OthersResources;
using Diagnostics;

// --------------------------endpoints------------------------------------------ //
endpoint Server 
    over HTTP.Server
    provides EcsContract;

client endpoint Client connected to Server;

// --------------------------actors--------------------------------------------- //
autostart actor EcsOverHttp(HTTP.Server server)
{
    EcsMessageKind requestMessageKind = EcsMessageKind.None; // cache request message kind
    process server accepts req:HTTP.HttpContract.Request where IsEcsMessage(req.Uri, req.Method, out requestMessageKind)
    {
        switch (requestMessageKind)
        {
            case EcsMessageKind.ServerDiscovery =>
                EcsContract.ServerDiscoveryRequest request = new EcsContract.ServerDiscoveryRequest{};
                if ("x-ecs-devicename" in req.Headers)
                {
                    string str = req.Headers["x-ecs-devicename"] as string;
                    request.XEcsDevicename = XEcsDevicenameFormatSyntax(str);
                }
                dispatch (endpoint Server over server) accepts request;
            case EcsMessageKind.ShareDiscovery =>
                EcsContract.ShareDiscoveryRequest request = new EcsContract.ShareDiscoveryRequest{};
                if ("x-ecs-share-type" in req.Headers)
                {
                    request.XEcsShareType = req.Headers["x-ecs-share-type"] as string;
                    ValidationCheckValue(request.XEcsShareType == "User Data", request, true, ReferenceType.Type, "ECS", "XEcsShareType ", "ShareDiscoveryRequest", "User Data", request.XEcsShareType);
                }
                dispatch (endpoint Server over server) accepts request;
            case EcsMessageKind.ServerCapabilities =>
                EcsContract.ServerCapabilitiesRequest request = new EcsContract.ServerCapabilitiesRequest{};
                if ("x-ecs-devicename" in req.Headers)
                {
                    string str = req.Headers["x-ecs-devicename"] as string;
                    request.XEcsDevicename = XEcsDevicenameFormatSyntax(str);
                }
                dispatch (endpoint Server over server) accepts request;
            case EcsMessageKind.DetectServerChanges =>
                EcsContract.DetectServerChangesRequest request = new EcsContract.DetectServerChangesRequest{};
                if ("If-None-Match" in req.Headers)
                {
                    request.IfNoneMatch = req.Headers["If-None-Match"] as string;
                }
                if ("x-ecs-partnershipId" in req.Headers)
                {
                    request.XEcsPartnershipID = DecodeXEcsPartnershipID(req.Headers["x-ecs-partnershipId"] as string, request, "DetectServerChangesRequest");
                }
                else
                {
                    ReportRequiredHeaderMissing(request, "x-ecs-partnershipId", "DetectServerChangesRequest");
                }
                dispatch (endpoint Server over server) accepts request;
            case EcsMessageKind.UserConfiguration =>
                EcsContract.UserConfigurationRequest request = new EcsContract.UserConfigurationRequest{};
                if ("x-ecs-partnershipId" in req.Headers)
                {
                    request.XEcsPartnershipID = DecodeXEcsPartnershipID(req.Headers["x-ecs-partnershipId"] as string, request, "UserConfigurationRequest");
                }
                else
                {
                    ReportRequiredHeaderMissing(request, "x-ecs-partnershipId", "UserConfigurationRequest");
                }
                if ("x-ecs-domain" in req.Headers)
                {
                    request.XEcsDomain = req.Headers["x-ecs-domain"] as string;
                }
                dispatch (endpoint Server over server) accepts request;
            case EcsMessageKind.CreateSession =>
                EcsContract.CreateSessionRequest request = new EcsContract.CreateSessionRequest{};
                if ("x-ecs-partnershipId" in req.Headers)
                {
                    request.XEcsPartnershipID = DecodeXEcsPartnershipID(req.Headers["x-ecs-partnershipId"] as string, request, "CreateSessionRequest");
                }
                else
                {
                    ReportRequiredHeaderMissing(request, "x-ecs-partnershipId", "CreateSessionRequest");
                }
                if ("x-ecs-devicename" in req.Headers)
                {
                    string str = req.Headers["x-ecs-devicename"] as string;
                    request.XEcsDevicename = XEcsDevicenameFormatSyntax(str);
                }
                if (BinaryDecoder<CreateSessionRequestBody>(req.Payload) is body:CreateSessionRequestBody)
                {
                    request.Request = body;
                }
                else
                {
                    ThrowDecodingException("ECS", "CreateSessionRequest");
                }
                dispatch (endpoint Server over server) accepts request;
            case EcsMessageKind.GetSyncBatchParameters =>
                EcsContract.GetSyncBatchParametersRequest request = new EcsContract.GetSyncBatchParametersRequest{};
                if ("x-ecs-partnershipId" in req.Headers)
                {
                    request.XEcsPartnershipID = DecodeXEcsPartnershipID(req.Headers["x-ecs-partnershipId"] as string, request, "GetSyncBatchParametersRequest");
                }
                else
                {
                    ReportRequiredHeaderMissing(request, "x-ecs-partnershipId", "GetSyncBatchParametersRequest");
                }
                dispatch (endpoint Server over server) accepts request;
            case EcsMessageKind.PutSyncBatchParameters =>
                EcsContract.PutSyncBatchParametersRequest request = new EcsContract.PutSyncBatchParametersRequest{};
                if ("x-ecs-partnershipId" in req.Headers)
                {
                    request.XEcsPartnershipID = DecodeXEcsPartnershipID(req.Headers["x-ecs-partnershipId"] as string, request, "PutSyncBatchParametersRequest");
                }
                else
                {
                    ReportRequiredHeaderMissing(request, "x-ecs-partnershipId", "PutSyncBatchParametersRequest");
                }
                if (BinaryDecoder<SyncBatchParametersPutRequestBody>(req.Payload) is body:SyncBatchParametersPutRequestBody)
                {
                    request.Request = body;
                }
                else
                {
                    ThrowDecodingException("ECS", "PutSyncBatchParametersRequest");
                }
                dispatch (endpoint Server over server) accepts request;
            case EcsMessageKind.PrepareBatch =>
                EcsContract.PrepareBatchRequest request = new EcsContract.PrepareBatchRequest{};
                if ("x-ecs-partnershipId" in req.Headers)
                {
                    request.XEcsPartnershipID = DecodeXEcsPartnershipID(req.Headers["x-ecs-partnershipId"] as string, request, "PrepareBatchRequest");
                }
                else
                {
                    ReportRequiredHeaderMissing(request, "x-ecs-partnershipId", "PrepareBatchRequest");
                }
                if (BinaryDecoder<PrepareBatchRequestBody>(req.Payload) is body:PrepareBatchRequestBody)
                {
                    request.Request = body;
                }
                else
                {
                    ThrowDecodingException("ECS", "PrepareBatchRequest");
                }
                dispatch (endpoint Server over server) accepts request;
            case EcsMessageKind.UploadBatch =>
                EcsContract.UploadBatchRequest request = new EcsContract.UploadBatchRequest{};
                if ("x-ecs-partnershipId" in req.Headers)
                {
                    request.XEcsPartnershipID = DecodeXEcsPartnershipID(req.Headers["x-ecs-partnershipId"] as string, request, "UploadBatchRequest");
                }
                else
                {
                    ReportRequiredHeaderMissing(request, "x-ecs-partnershipId", "UploadBatchRequest");
                }
                if (BinaryDecoder<UploadBatchRequestBody>(req.Payload) is body:UploadBatchRequestBody)
                {
                    request.Request = body;
                }
                else
                {
                    ThrowDecodingException("ECS", "UploadBatchRequest");
                }
                dispatch (endpoint Server over server) accepts request;
            case EcsMessageKind.DeleteSession =>
                EcsContract.DeleteSessionRequest request = new EcsContract.DeleteSessionRequest{};
                if ("x-ecs-partnershipId" in req.Headers)
                {
                    request.XEcsPartnershipID = DecodeXEcsPartnershipID(req.Headers["x-ecs-partnershipId"] as string, request, "DeleteSessionRequest");
                }
                else
                {
                    ReportRequiredHeaderMissing(request, "x-ecs-partnershipId", "DeleteSessionRequest");
                }
                dispatch (endpoint Server over server) accepts request;
            case EcsMessageKind.DownloadBatch =>
                EcsContract.DownloadBatchRequest request = new EcsContract.DownloadBatchRequest{};
                if ("x-ecs-partnershipId" in req.Headers)
                {
                    request.XEcsPartnershipID = DecodeXEcsPartnershipID(req.Headers["x-ecs-partnershipId"] as string, request, "DownloadBatchRequest");
                }
                else
                {
                    ReportRequiredHeaderMissing(request, "x-ecs-partnershipId", "DownloadBatchRequest");
                }
                if ("x-ecs-continue" in req.Headers)
                {
                    request.XEcsContinue = req.Headers["x-ecs-continue"] as string;
                }
                dispatch (endpoint Server over server) accepts request;
            case EcsMessageKind.UploadData =>
                EcsContract.UploadDataRequest request = new EcsContract.UploadDataRequest{};
                if ("x-ecs-partnershipId" in req.Headers)
                {
                    request.XEcsPartnershipID = DecodeXEcsPartnershipID(req.Headers["x-ecs-partnershipId"] as string, request, "UploadDataRequest");
                }
                else
                {
                    ReportRequiredHeaderMissing(request, "x-ecs-partnershipId", "UploadDataRequest");
                }
                if (BinaryDecoder<UploadDataRequestBody>(req.Payload) is body:UploadDataRequestBody)
                {
                    request.Request = body;
                }
                else
                {
                    ThrowDecodingException("ECS", "UploadDataRequest");
                }
                dispatch (endpoint Server over server) accepts request;
            case EcsMessageKind.DownloadData =>
                EcsContract.DownloadDataRequest request = new EcsContract.DownloadDataRequest{};
                if ("x-ecs-partnershipId" in req.Headers)
                {
                    request.XEcsPartnershipID = DecodeXEcsPartnershipID(req.Headers["x-ecs-partnershipId"] as string, request, "DownloadDataRequest");
                }
                else
                {
                    ReportRequiredHeaderMissing(request, "x-ecs-partnershipId", "DownloadDataRequest");
                }
                if (BinaryDecoder<DownloadDataRequestBody>(req.Payload) is body:DownloadDataRequestBody)
                {
                    request.Request = body;
                }
                else
                {
                    ThrowDecodingException("ECS", "UploadDataRequest");
                }
                dispatch (endpoint Server over server) accepts request;
            default =>
        }
    }

    process server issues res:HTTP.HttpContract.Response where requestMessageKind != EcsMessageKind.None
    {
        if (res.StatusCode in SuccessStatusCodeSet)
        {
            switch (requestMessageKind)
            {
                case EcsMessageKind.ServerDiscovery =>
                    EcsContract.ServerDiscoveryResponse response = new EcsContract.ServerDiscoveryResponse{};
                    if ("x-ecs-request-error" in res.Headers)
                    {
                        response.XEcsRequestError = res.Headers["x-ecs-request-error"] as string;
                    }
                    if (BinaryDecoder<ServerDiscoveryResponseBody>(res.Payload) is body:ServerDiscoveryResponseBody)
                    {
                        response.Response = body;
                    }
                    else
                    {
                        ThrowDecodingException("ECS", "ServerDiscoveryResponse");
                    }
                    dispatch (endpoint Server over server) issues response;
                case EcsMessageKind.ShareDiscovery =>
                    EcsContract.ShareDiscoveryResponse response = new EcsContract.ShareDiscoveryResponse{};
                    if ("x-ecs-request-error" in res.Headers)
                    {
                        response.XEcsRequestError = res.Headers["x-ecs-request-error"] as string;
                    }
                    if (BinaryDecoder<ShareDiscoveryResponseBody>(res.Payload) is body:ShareDiscoveryResponseBody)
                    {
                        response.Response = body;
                    }
                    else
                    {
                        ThrowDecodingException("ECS", "ShareDiscoveryResponse");
                    }
                    dispatch (endpoint Server over server) issues response;
                case EcsMessageKind.ServerCapabilities =>
                    EcsContract.ServerCapabilitiesResponse response = new EcsContract.ServerCapabilitiesResponse{};
                    if ("x-ecs-request-error" in res.Headers)
                    {
                        response.XEcsRequestError = res.Headers["x-ecs-request-error"] as string;
                    }
                    if (BinaryDecoder<ServerCapabilitiesResponseBody>(res.Payload) is body:ServerCapabilitiesResponseBody)
                    {
                        response.Response = body;
                    }
                    else
                    {
                        ThrowDecodingException("ECS", "ServerCapabilities");
                    }
                    dispatch (endpoint Server over server) issues response;
                case EcsMessageKind.DetectServerChanges =>
                    EcsContract.DetectServerChangesResponse response = new EcsContract.DetectServerChangesResponse{};
                    if ("ETag" in res.Headers)
                    {
                        response.ETag = res.Headers["ETag"] as string;
                    }
                    dispatch (endpoint Server over server) issues response;
                case EcsMessageKind.UserConfiguration =>
                    EcsContract.UserConfigurationResponse response = new EcsContract.UserConfigurationResponse{};
                    if (BinaryDecoder<UserConfigurationResponseBody>(res.Payload) is body:UserConfigurationResponseBody)
                    {
                        response.Response = body;
                    }
                    else
                    {
                        ThrowDecodingException("ECS", "UserConfigurationResponse");
                    }
                    dispatch (endpoint Server over server) issues response;
                case EcsMessageKind.CreateSession =>
                    EcsContract.CreateSessionResponse response = new EcsContract.CreateSessionResponse{};
                    if ("x-ecs-request-error" in res.Headers)
                    {
                        response.XEcsRequestError = res.Headers["x-ecs-request-error"] as string;
                    }
                    if ("x-ecs-admin-contact" in res.Headers)
                    {
                        response.XEcsAdminContact = res.Headers["x-ecs-admin-contact"] as string;
                    }
                    if ("x-ecs-metadata-version" in res.Headers)
                    {
                        response.XEcsMetadataVersion = res.Headers["x-ecs-metadata-version"] as string;
                    }
                    if ("x-ecs-session-id" in res.Headers)
                    {
                        response.XEcsSessionId = res.Headers["x-ecs-session-id"] as string;
                    }
                    dispatch (endpoint Server over server) issues response;
                case EcsMessageKind.GetSyncBatchParameters =>
                    EcsContract.GetSyncBatchParametersResponse response = new EcsContract.GetSyncBatchParametersResponse{};
                    if ("x-ecs-request-error" in res.Headers)
                    {
                        response.XEcsRequestError = res.Headers["x-ecs-request-error"] as string;
                    }
                    if (BinaryDecoder<GetSyncBatchParametersResponseBody>(res.Payload) is body:GetSyncBatchParametersResponseBody)
                    {
                        response.Response = body;
                    }
                    else
                    {
                        ThrowDecodingException("ECS", "GetSyncBatchParametersResponse");
                    }
                    dispatch (endpoint Server over server) issues response;
                case EcsMessageKind.PutSyncBatchParameters =>
                    EcsContract.PutSyncBatchParametersResponse response = new EcsContract.PutSyncBatchParametersResponse{};
                    if (BinaryDecoder<SyncBatchParametersPutResponseBody>(res.Payload) is body:SyncBatchParametersPutResponseBody)
                    {
                        response.Response = body;
                    }
                    else
                    {
                        ThrowDecodingException("ECS", "PutSyncBatchParametersResponse");
                    }
                    dispatch (endpoint Server over server) issues response;
                case EcsMessageKind.PrepareBatch =>
                    EcsContract.PrepareBatchResponse response = new EcsContract.PrepareBatchResponse{};
                    if ("x-ecs-request-error" in res.Headers)
                    {
                        response.XEcsRequestError = res.Headers["x-ecs-request-error"] as string;
                    }
                    if (BinaryDecoder<PrepareBatchResponseBody>(res.Payload) is body:PrepareBatchResponseBody)
                    {
                        response.Response = body;
                    }
                    else
                    {
                        ThrowDecodingException("ECS", "PrepareBatchResponse");
                    }
                    dispatch (endpoint Server over server) issues response;
                case EcsMessageKind.UploadBatch =>
                    EcsContract.UploadBatchResponse response = new EcsContract.UploadBatchResponse{};
                    if ("x-ecs-request-error" in res.Headers)
                    {
                        response.XEcsRequestError = res.Headers["x-ecs-request-error"] as string;
                    }
                    if (BinaryDecoder<UploadBatchResponseBody>(res.Payload) is body:UploadBatchResponseBody)
                    {
                        response.Response = body;
                    }
                    else
                    {
                        ThrowDecodingException("ECS", "UploadBatchResponse");
                    }
                    dispatch (endpoint Server over server) issues response;
                case EcsMessageKind.DeleteSession =>
                    EcsContract.DeleteSessionResponse response = new EcsContract.DeleteSessionResponse{};
                    dispatch (endpoint Server over server) issues response;
                case EcsMessageKind.DownloadBatch =>
                    EcsContract.DownloadBatchResponse response = new EcsContract.DownloadBatchResponse{};
                    if ("x-ecs-continue" in res.Headers)
                    {
                        response.XEcsContinue = res.Headers["x-ecs-continue"] as string;
                    }
                    if (BinaryDecoder<DownloadBatchResponseBody>(res.Payload) is body:DownloadBatchResponseBody)
                    {
                        response.Response = body;
                    }
                    else
                    {
                        ThrowDecodingException("ECS", "DownloadBatchResponse");
                    }
                    dispatch (endpoint Server over server) issues response;
                case EcsMessageKind.UploadData =>
                    EcsContract.UploadDataResponse response = new EcsContract.UploadDataResponse{};
                    if (BinaryDecoder<UploadDataResponseBody>(res.Payload) is body:UploadDataResponseBody)
                    {
                        response.Response = body;
                    }
                    else
                    {
                        ThrowDecodingException("ECS", "UploadDataResponse");
                    }
                    dispatch (endpoint Server over server) issues response;
                case EcsMessageKind.DownloadData =>
                    EcsContract.DownloadDataResponse response = new EcsContract.DownloadDataResponse{};
                    if (BinaryDecoder<DownloadDataResponseBody>(res.Payload) is body:DownloadDataResponseBody)
                    {
                        response.Response = body;
                    }
                    else
                    {
                        ThrowDecodingException("ECS", "DownloadDataResponse");
                    }
                    dispatch (endpoint Server over server) issues response;
                default =>
            }
        }
        else // ECS Error Response
        {
            EcsContract.ErrorResponse response = new EcsContract.ErrorResponse
                {
                    StatusCode = res.StatusCode,
                    ReasonPhrase = res.ReasonPhrase
                };
            dispatch (endpoint Server over server) issues response;
        }
        requestMessageKind = EcsMessageKind.None; // reset
    }
    
    // Determine if a HTTP message is an ECS message by checking the URI
    bool IsEcsMessage(HTTP.UriType uri, string httpMethod, out EcsMessageKind kind)
    {
        if (uri != null && uri.AbsPath != nothing && uri.AbsPath != null)
        {
            if (EcsUriStartSyntax(uri.AbsPath as stream) is str:string)
            {
                switch (str as string)
                {
                    case s:string from ServerDiscoveryUriSyntax =>
                        kind = EcsMessageKind.ServerDiscovery;
                    case s:string from ShareDiscoveryUriSyntax =>
                        kind = EcsMessageKind.ShareDiscovery;
                    case s:string from ServerCapabilitiesUriSyntax =>
                        kind = EcsMessageKind.ServerCapabilities;
                    case s:string from DetectServerChangesUriSyntax =>
                        kind = EcsMessageKind.DetectServerChanges;
                    case s:string from UserConfigurationUriSyntax =>
                        kind = EcsMessageKind.UserConfiguration;
                    case session:string from EcsSessionUriStartSyntax =>
                        switch (session)
                        {
                            case s:string from CreateSessionSyntax =>
                                kind = EcsMessageKind.CreateSession;
                            case s:string from SyncBatchParametersSyntax =>
                                if (httpMethod == "GET")
                                {
                                    kind = EcsMessageKind.GetSyncBatchParameters;
                                }
                                else if (httpMethod == "PUT")
                                {
                                    kind = EcsMessageKind.PutSyncBatchParameters;
                                }
                                else
                                {
                                    kind = EcsMessageKind.None;
                                    return false;
                                }
                            case s:string from PrepareBatchSyntax =>
                                kind = EcsMessageKind.PrepareBatch;
                            case s:string from UploadBatchSyntax =>
                                kind = EcsMessageKind.UploadBatch;
                            case s:string from DeleteSessionSyntax =>
                                kind = EcsMessageKind.DeleteSession;
                            case s:string from DownloadBatchSyntax =>
                                kind = EcsMessageKind.DownloadBatch;
                            case s:string from UploadDataSyntax =>
                                kind = EcsMessageKind.UploadData;
                            case s:string from DownloadDataSyntax =>
                                kind = EcsMessageKind.DownloadData;
                            default =>
                                kind = EcsMessageKind.None;
                                return false;
                        }
                    default =>
                        kind = EcsMessageKind.None;
                        return false;
                }
                return true;
            }
        }
        kind = EcsMessageKind.None;
        return false;
    }
}

// --------------------------messages------------------------------------------- //
contract EcsContract
{
    // 3.1.5.1   Server Discovery 
    accepts message ServerDiscoveryRequest
    {
        optional XEcsDevicenameFormat XEcsDevicename;
        
        override string ToString()
        {
            return "Server Discovery Request";
        }
    }
    
    issues message ServerDiscoveryResponse
    {
        optional string XEcsRequestError;
        ServerDiscoveryResponseBody Response;
        
        override string ToString()
        {
            return "Server Discovery Response" + AddOptionalFieldToSummary(XEcsRequestError, "Error");
        }
    }
    
    // 3.1.5.2   Share Discovery
    accepts message ShareDiscoveryRequest
    {
        optional string XEcsShareType;
        
        override string ToString()
        {
            return "Share Discovery Request" + AddOptionalFieldToSummary(XEcsShareType, "ShareType");
        }
    }
    
    issues message ShareDiscoveryResponse
    {
        optional string XEcsRequestError;
        ShareDiscoveryResponseBody Response;
        
        override string ToString()
        {
            return "Share Discovery Response" + AddOptionalFieldToSummary(XEcsRequestError, "Error");
        }
    }
    
    // 3.1.5.3   Server Capabilities
    accepts message ServerCapabilitiesRequest
    {
        optional XEcsDevicenameFormat XEcsDevicename;
        
        override string ToString()
        {
            return "Server Capabilities Request";
        }
    }
    
    issues message ServerCapabilitiesResponse
    {
        optional string XEcsRequestError;
        ServerCapabilitiesResponseBody Response;
        
        override string ToString()
        {
            return "Server Capabilities Response" + AddOptionalFieldToSummary(XEcsRequestError, "Error") +
                ", ProtocolType: " + EnumToString(Response.ProtocolType, "ECS.ServerCapabilitiesResponse_ProtocolType");
        }
    }
    
    // 3.2.5.4   Detect Server Changes
    accepts message DetectServerChangesRequest
    {
        optional string IfNoneMatch;
        string XEcsPartnershipID;
        
        override string ToString()
        {
            return "Detect Server Changes Request" + AddOptionalFieldToSummary(IfNoneMatch, "IfNoneMatch");
        }
    }
    
    issues message DetectServerChangesResponse
    {
        optional string ETag;
        
        override string ToString()
        {
            return "Detect Server Changes Response" + AddOptionalFieldToSummary(ETag, "ETag");
        }
    }
    
    // 3.3.5.5   User Configuration
    accepts message UserConfigurationRequest
    {
        string XEcsPartnershipID;
        optional string XEcsDomain;
        
        override string ToString()
        {
            return "User Configuration Request";
        }
    }
    
    issues message UserConfigurationResponse
    {
        UserConfigurationResponseBody Response;
        
        override string ToString()
        {
            return "User Configuration Response, UserDataFreeSpace: " + Response.QuotaUsage.UserDataFreeSpace.ToString() + ", UserUsage: " + Response.QuotaUsage.UserUsage.ToString();
        }
    }
    
    // 3.4.5.1   Create Session
    accepts message CreateSessionRequest
    {
        string XEcsPartnershipID;
        optional XEcsDevicenameFormat XEcsDevicename;
        CreateSessionRequestBody Request;
        
        override string ToString()
        {
            return "Create Session Request, Type: " + EnumToString(Request.Type, "ECS.CreateSessionRequest_Type");
        }
    }
    
    issues message CreateSessionResponse
    {
        optional string XEcsRequestError;
        optional string XEcsAdminContact;
        optional string XEcsMetadataVersion;
        optional string XEcsSessionId;
        
        override string ToString()
        {
            return "Create Session Response" + AddOptionalFieldToSummary(XEcsRequestError, "Error") + AddOptionalFieldToSummary(XEcsSessionId, "SessionId");
        }
    }
    
    // 3.4.5.2   Sync Batch Parameters 
    accepts message GetSyncBatchParametersRequest
    {
        string XEcsPartnershipID;
        
        override string ToString()
        {
            return "Get Sync Batch Parameters Request";
        }
    }
    
    issues message GetSyncBatchParametersResponse
    {
        optional string XEcsRequestError;
        GetSyncBatchParametersResponseBody Response;
        
        override string ToString()
        {
            return "Get Sync Batch Parameters Response" + AddOptionalFieldToSummary(XEcsRequestError, "Error");
        }
    }
    
    accepts message PutSyncBatchParametersRequest
    {
        string XEcsPartnershipID;
        SyncBatchParametersPutRequestBody Request;
        
        override string ToString()
        {
            return "Put Sync Batch Parameters Request";
        }
    }
    
    issues message PutSyncBatchParametersResponse
    {
        SyncBatchParametersPutResponseBody Response;
        
        override string ToString()
        {
            return "Put Sync Batch Parameters Response, TotalFileCount: " + Response.TotalFileCount.ToString();
        }
    }
    
    // 3.4.5.3   Prepare Batch
    accepts message PrepareBatchRequest
    {
        string XEcsPartnershipID;
        PrepareBatchRequestBody Request;
        
        override string ToString()
        {
            return "Prepare Batch Request";
        }
    }
    
    issues message PrepareBatchResponse
    {
        optional string XEcsRequestError;
        PrepareBatchResponseBody Response;
        
        override string ToString()
        {
            return "Prepare Batch Response" + AddOptionalFieldToSummary(XEcsRequestError, "Error");
        }
    }
    
    // 3.4.5.4   Upload Batch
    accepts message UploadBatchRequest
    {
        string XEcsPartnershipID;
        UploadBatchRequestBody Request;
        
        override string ToString()
        {
            return "Upload Batch Request";
        }
    }
    
    issues message UploadBatchResponse
    {
        optional string XEcsRequestError;
        UploadBatchResponseBody Response;
        
        override string ToString()
        {
            return "Upload Batch Response" + AddOptionalFieldToSummary(XEcsRequestError, "Error");
        }
    }
    
    // 3.4.5.5   Delete Session
    accepts message DeleteSessionRequest
    {
        string XEcsPartnershipID;
        
        override string ToString()
        {
            return "Delete Session Request";
        }
    }
    
    issues message DeleteSessionResponse
    {
        override string ToString()
        {
            return "Delete Session Response";
        }
    }
    
    // 3.4.5.6   Download Batch
    accepts message DownloadBatchRequest
    {
        string XEcsPartnershipID;
        optional string XEcsContinue;
        
        override string ToString()
        {
            return "Download Batch Request" + AddOptionalFieldToSummary(XEcsContinue, "Continuation Token");
        }
    }
    
    issues message DownloadBatchResponse
    {
        optional string XEcsContinue;
        DownloadBatchResponseBody Response;
        
        override string ToString()
        {
            return "Download Batch Response" + AddOptionalFieldToSummary(XEcsContinue, "Continuation Token");
        }
    }
    
    // 3.5.5.1   Upload Data
    accepts message UploadDataRequest
    {
        string XEcsPartnershipID;
        UploadDataRequestBody Request;
        
        override string ToString()
        {
            return "Upload Data Request";
        }
    }
    
    issues message UploadDataResponse
    {
        UploadDataResponseBody Response;
        
        override string ToString()
        {
            return "Upload Data Response";
        }
    }
    
    // 3.5.5.2   Download Data
    accepts message DownloadDataRequest
    {
        string XEcsPartnershipID;
        DownloadDataRequestBody Request;
        
        override string ToString()
        {
            return "Download Data Request";
        }
    }
    
    issues message DownloadDataResponse
    {
        DownloadDataResponseBody Response;
        
        override string ToString()
        {
            return "Download Data Response";
        }
    }
    
    // Error Response
    issues message ErrorResponse
    {
        uint StatusCode;
        string ReasonPhrase;
        
        override string ToString()
        {
            return "Error Response, Status: " + ReasonPhrase + " (" + StatusCode.ToString() + ")";
        }
    }
}

//--------------------------structures-------------------------------------------//
// [MS-FSVCA] section 2.1.
// Because FSVCA is big-endian and ECS is little-endian, copy the type definition here.
type SYNC_GID
{
    ulong GidPrefix;
    GUID UniqueId;
};

// [MS-FSVCA] section 2.9
// Because FSVCA is big-endian and ECS is little-endian, copy the type definition here.
type CLOCK_VECTOR_ELEMENT
{
    uint ReplicaKey;
    ulong TickCount;
}

// 2.2.2.3   SYNC_BLOB
type SYNC_BLOB[BlobType Type]
{
    ULONG BlobSize;
    ([|Type == BlobType.SYNC_KNOWLEDGE|] SYNC_KNOWLEDGE |
        [|Type == BlobType.SYNC_CHANGE_INFORMATION|] SYNC_CHANGE_INFORMATION |
        binary) BlobData with BinaryEncoding{Length = BlobSize};
};

// 2.2.2.4   QUOTA_USAGE_ENTRY
type QUOTA_USAGE_ENTRY
{
    ULONG64 UserUsage;
    ULONG64 UserDataFreeSpace;
};

// 2.2.2.5   POLICY_ENTRY
type POLICY_ENTRY
{
    POLICY_ENTRY_PolicyName PolicyName where ValidationCheckEnumValue(InRange<POLICY_ENTRY_PolicyName>(value), null, true, ReferenceType.Type,
        "ECS", "PolicyName", "POLICY_ENTRY", "0x01, 0x02, 0x03", value);
    BOOLEAN PolicyType;
};

pattern POLICY_ENTRY_PolicyName = enum byte
{
    Encryption  = 0x01,
    Password    = 0x02,
    AutoLock    = 0x03,
    ...
};

// 2.2.2.6   BATCH_LIMITS_ENTRY
type BATCH_LIMITS_ENTRY
{
    ULONG MaxFileDataSize;
    ULONG MaxFileCount;
};

// 2.2.2.7   FILE_METADATA_ENTRY
type FILE_METADATA_ENTRY
{
    ECS.SYNC_GID FileId;
    ECS.CLOCK_VECTOR_ELEMENT SyncVersion;
    GUID FileStreamVersion;
    ECS.SYNC_GID ParentId;
    FileAttribute FileAttributes where ValidationCheckEnumValueTooManyItems(InRange<FileAttribute>(value), null, true, 
            ReferenceType.Type, "ECS", "FileAttributes", "FILE_METADATA_ENTRY", "FILE_METADATA_ENTRY","MS-ECS");
    FILETIME NamespaceChangeTime;
    FILETIME AttributeChangeTime;
    FILETIME CreatedTime;
    FILETIME ModifiedTime;
    ULONGLONG ContentSize;
    USHORT Length;
    string Name with Encoding{Decoder = DecodeOctetStringAsUTF8, SourcePattern = TypeOf<binary>()},
                                BinaryEncoding{Length = Length}; // WORKAROUND for UTF8 decoding
    // string Name with BinaryEncoding{Length = Length, TextEncoding = TextEncoding.UTF8}; 
    USHORT OriginatingDeviceNameIndex;
};

// [MSDN-FSA] (http://go.microsoft.com/fwlink/?LinkId=309761)
// File Attribute Constants
pattern FileAttribute = flags DWORD
{
    FILE_ATTRIBUTE_READONLY             = 0x00000001,
    FILE_ATTRIBUTE_HIDDEN               = 0x00000002,
    FILE_ATTRIBUTE_SYSTEM               = 0x00000004,
    FILE_ATTRIBUTE_DIRECTORY            = 0x00000010,
    FILE_ATTRIBUTE_ARCHIVE              = 0x00000020,
    FILE_ATTRIBUTE_DEVICE               = 0x00000040,
    FILE_ATTRIBUTE_NORMAL               = 0x00000080,
    FILE_ATTRIBUTE_TEMPORARY            = 0x00000100,
    FILE_ATTRIBUTE_SPARSE_FILE          = 0x00000200,
    FILE_ATTRIBUTE_REPARSE_POINT        = 0x00000400,
    FILE_ATTRIBUTE_COMPRESSED           = 0x00000800,
    FILE_ATTRIBUTE_OFFLINE              = 0x00001000,
    FILE_ATTRIBUTE_NOT_CONTENT_INDEXED  = 0x00002000,
    FILE_ATTRIBUTE_ENCRYPTED            = 0x00004000,
    FILE_ATTRIBUTE_INTEGRITY_STREAM     = 0x00008000,
    FILE_ATTRIBUTE_VIRTUAL              = 0x00010000,
    FILE_ATTRIBUTE_NO_SCRUB_DATA        = 0x00020000,
    FILE_ATTRIBUTE_EA                   = 0x00040000,
    ...
};
 
// 2.2.2.8   FILE_INFO_INPUT_ENTRY
type FILE_INFO_INPUT_ENTRY
{
    USHORT Length;
    string FileExtension with BinaryEncoding{TextEncoding = TextEncoding.ASCII, Length = Length};
    ECS.SYNC_GID SyncItemId;
    GUID StreamId;
    ULONGLONG FileSize;
};

// 2.2.2.9   FILE_INFO_ENTRY
type FILE_INFO_ENTRY
{
    ECS.SYNC_GID SyncItemId;
    USHORT Length;
    string Uri where ValidationCheck(ProtocolType != 1 || value.Count == 0, null, DiagnosisLevel.Error, OthersResources.ECS_FILE_INFO_ENTRY_URI_CHECK)
                with BinaryEncoding{TextEncoding = TextEncoding.ASCII, Length = Length};
    FILE_INFO_ENTRY_ProtocolType ProtocolType where ValidationCheckEnumValue(InRange<FILE_INFO_ENTRY_ProtocolType>(value), null, true, ReferenceType.Type,
        "ECS", "ProtocolType", "FILE_INFO_ENTRY", "0x00, 0x01", value);
    HRESULT PrepareResult;
};

pattern FILE_INFO_ENTRY_ProtocolType = enum UCHAR
{
    NoUpload        = 0x00,
    FileBatching    = 0x01,
    ...  
};

// 2.2.2.10   FILE_STATUS_ENTRY
type FILE_STATUS_ENTRY
{
    ECS.SYNC_GID SyncItemId;
    HRESULT Status;
};

// 2.2.2.11   UPLOAD_ENTRY
type UPLOAD_ENTRY
{
    ECS.SYNC_GID SyncItemId;
    ULONGLONG  FileSize;
    ULONG64 Offset;
    ULONG Length;
    ULONGLONG Reserved where ValidationCheckReservedZero(value == 0, null, false, ReferenceType.Type, "ECS", "Reserved", "UPLOAD_ENTRY", value);
    SYNC_BLOB[BlobType.Other] UploadData;
};

// 2.2.2.12   UPLOAD_RESPONSE_ENTRY
type UPLOAD_RESPONSE_ENTRY
{
    ECS.SYNC_GID SyncItemId;
    HRESULT Result;
};

// 2.2.2.13   DOWNLOAD_ENTRY
type DOWNLOAD_ENTRY
{
    ECS.SYNC_GID SyncItemId;
    SYNC_BLOB[BlobType.Other] FileVersion;
};

// 2.2.2.14   DOWNLOAD_RESPONSE_ENTRY
type DOWNLOAD_RESPONSE_ENTRY
{
    ECS.SYNC_GID SyncItemId;
    ULONGLONG DataLength;
    binary Data with BinaryEncoding{Length = DataLength as long};
    HRESULT Result;
    SYNC_MD5HASH FileHash;
};

// 2.2.2.15   FILE_DOWNLOAD_INFO_ENTRY
type FILE_DOWNLOAD_INFO_ENTRY
{
    ECS.SYNC_GID SyncId;
    USHORT Length;
    string Uri where ValidationCheckValue(value.Count == 0, null, true, ReferenceType.Type, "ECS", "Uri ", "FILE_DOWNLOAD_INFO_ENTRY", "empty", value)
                with BinaryEncoding{TextEncoding = TextEncoding.ASCII, Length = Length};
    FILE_DOWNLOAD_INFO_ENTRY_ProtocolType ProtocolType where ValidationCheckEnumValue(InRange<FILE_DOWNLOAD_INFO_ENTRY_ProtocolType>(value), null, true, ReferenceType.Type,
        "ECS", "ProtocolType", "FILE_DOWNLOAD_INFO_ENTRY", "0x01", value);
};

pattern FILE_DOWNLOAD_INFO_ENTRY_ProtocolType = enum UCHAR
{
    FileBatching    = 0x01,
    ...    
};

// 2.2.2.16   SYNC_CHANGE_BATCH
type SYNC_CHANGE_BATCH
{
    VECTOR_FILE_METADATA_ENTRY Files;
    uint Length;
    array<VECTOR_STRING> DeviceNames with BinaryEncoding{Length = Length};
    SYNC_BLOB[BlobType.SYNC_CHANGE_INFORMATION] SyncMetadata;
};

// 2.2.2.17   SYNC_MD5HASH
type SYNC_MD5HASH
{
    ULONGLONG High;
    ULONGLONG Low;
};

// 2.2.2.18   VECTOR_POLICY_ENTRY
type VECTOR_POLICY_ENTRY
{
    ULONG NumEntries;
    array<POLICY_ENTRY> EntryStream with BinaryEncoding{Length = NumEntries};
};

// 2.2.2.19   VECTOR_FILE_METADATA_ENTRY
type VECTOR_FILE_METADATA_ENTRY
{
    ULONG NumEntries;
    array<FILE_METADATA_ENTRY> EntryStreamBytes with BinaryEncoding{Length = NumEntries};
};

// 2.2.2.20   VECTOR_FILE_INFO_INPUT_ENTRY
type VECTOR_FILE_INFO_INPUT_ENTRY
{
    ULONG NumEntries;
    array<FILE_INFO_INPUT_ENTRY> EntryStreamBytes with BinaryEncoding{Length = NumEntries};
};

// 2.2.2.21   VECTOR_FILE_INFO_ENTRY
type VECTOR_FILE_INFO_ENTRY
{
    ULONG NumEntries;
    array<FILE_INFO_ENTRY> EntryStreamBytes with BinaryEncoding{Length = NumEntries};
};

// 2.2.2.22   VECTOR_FILE_STATUS_ENTRY
type VECTOR_FILE_STATUS_ENTRY
{
    ULONG NumEntries;
    array<FILE_STATUS_ENTRY> EntryStream with BinaryEncoding{Length = NumEntries};
};

// 2.2.2.23   VECTOR_UPLOAD_ENTRY
type VECTOR_UPLOAD_ENTRY
{
    ULONG NumEntries;
    array<UPLOAD_ENTRY> EntryStreamBytes with BinaryEncoding{Length = NumEntries};
};

// 2.2.2.24   VECTOR_UPLOAD_RESPONSE_ENTRY
type VECTOR_UPLOAD_RESPONSE_ENTRY
{
    ULONG NumEntries;
    array<UPLOAD_RESPONSE_ENTRY> EntryStream with BinaryEncoding{Length = NumEntries};
};

// 2.2.2.25   VECTOR_DOWNLOAD_ENTRY
type VECTOR_DOWNLOAD_ENTRY
{
    ULONG NumEntries;
    array<DOWNLOAD_ENTRY> EntryStreamBytes with BinaryEncoding{Length = NumEntries};
};

// 2.2.2.26   VECTOR_DOWNLOAD_RESPONSE_ENTRY
type VECTOR_DOWNLOAD_RESPONSE_ENTRY
{
    array<DOWNLOAD_RESPONSE_ENTRY> EntryStreamBytes;
};

// 2.2.2.27   VECTOR_FILE_DOWNLOAD_INFO_ENTRY
type VECTOR_FILE_DOWNLOAD_INFO_ENTRY
{
    ULONG NumEntries;
    array<FILE_DOWNLOAD_INFO_ENTRY> EntryStreamBytes with BinaryEncoding{Length = NumEntries};
};

// 2.2.2.28   VECTOR_STRING
type VECTOR_STRING
{
    USHORT NumEntries;
    string EntryStreamBytes with Encoding{Decoder = DecodeOctetStringAsUTF8, SourcePattern = TypeOf<binary>()},
        BinaryEncoding{Length = NumEntries}; // WORKAROUND for UTF8 decoding
    // string EntryStreamBytes with BinaryEncoding{Length = Length, TextEncoding = TextEncoding.UTF8};
};

// 3.1.5.1   Server Discovery
type XEcsDevicenameFormat
{
    string DeviceName;
    string OsFamily;
    string OsMajorVersion;
    string OsMinorVersion;
    string UserAgentName;
}

type ServerDiscoveryResponseBody
{
    uint Length;
    array<string> ServerUrls with BinaryEncoding{Length = Length};
}

syntax StringExcludeComma = s:regex{[\x20-\x2B\x2E-\x7E]*} => s; // exclude ',' (0x2F)

syntax XEcsDevicenameFormatSyntax = dn:StringExcludeComma "," f:StringExcludeComma "," major:StringExcludeComma "," min:StringExcludeComma "," sync:StringExcludeComma regex{$} 
    => new XEcsDevicenameFormat
    {
        DeviceName      = dn,
        OsFamily        = f,
        OsMajorVersion  = major,
        OsMinorVersion  = min,
        UserAgentName   = sync
    };

// 3.1.5.2   Share Discovery
type ShareDiscoveryResponseBody
{
    VECTOR_STRING PartnershipId;
    VECTOR_STRING EnterpriseId;
    ULONG64 DataSize;
}

// 3.1.5.3   Server Capabilities
type ServerCapabilitiesResponseBody
{
    ServerCapabilitiesResponse_ProtocolType ProtocolType where ValidationCheckEnumValue(InRange<ServerCapabilitiesResponse_ProtocolType>(value), null, true, ReferenceType.Type,
        "ECS", "ProtocolType", "ServerCapabilitiesResponseBody", "0x01", value);
}

pattern ServerCapabilitiesResponse_ProtocolType = enum UCHAR
{
    FileBatching    = 0x01,
    ...    
};

// 3.3.5.1   User Configuration
type UserConfigurationResponseBody
{
    QUOTA_USAGE_ENTRY QuotaUsage;
    VECTOR_POLICY_ENTRY PolicyList;
    WORD Length;
    string AdminInfo with BinaryEncoding{Length = Length};
}

// 3.4.5.1   Create Session
type CreateSessionRequestBody
{
    CreateSessionRequest_Type Type where ValidationCheckEnumValue(InRange<CreateSessionRequest_Type>(value), null, true, ReferenceType.Type,
        "ECS", "Type", "CreateSessionRequest", "0x01, 0x02, 0x03, 0x04", value);
    GUID ReplicaId;
}

pattern CreateSessionRequest_Type = enum UCHAR
{
    Upload                      = 0x01,
    Download                    = 0x02,
    UploadWithFullEnumeration   = 0x03,
    DownloadWithFullEnumeration = 0x04,
    ...
};

// 3.4.5.2   Sync Batch Parameters
// 3.4.5.2.1   GET
type GetSyncBatchParametersResponseBody
{
    SYNC_BLOB[BlobType.SYNC_KNOWLEDGE] SyncKnowledge;
    BATCH_LIMITS_ENTRY BatchLimits;
}
pattern SYNC_SERIALIZATION_VERSION = enum uint
{ 
    SYNC_SERIALIZATION_VERSION_V1,
    SYNC_SERIALIZATION_VERSION_V2,
    ...
};

// 3.4.5.2.2   PUT
type SyncBatchParametersPutRequestBody
{
    SYNC_BLOB[BlobType.SYNC_KNOWLEDGE] SyncKnowledge;
    BATCH_LIMITS_ENTRY BatchLimits;
    ECS.SYNC_GID FullEnumerationLowerBound;
}

type SyncBatchParametersPutResponseBody
{
    ULONG TotalFileCount;
    ULONGLONG TotalFileSize;
}

// 3.4.5.3   Prepare Batch
type PrepareBatchRequestBody
{
    VECTOR_FILE_INFO_INPUT_ENTRY FileVector;
}

type PrepareBatchResponseBody
{
    VECTOR_FILE_INFO_ENTRY FileList;
}

// 3.4.5.4   Upload Batch
type UploadBatchRequestBody
{
    SYNC_CHANGE_BATCH SerializedSyncBatch;
}

type UploadBatchResponseBody
{
    VECTOR_FILE_STATUS_ENTRY FileStatusList;
}
// 3.4.5.6   Download Batch
type DownloadBatchResponseBody
{
    SYNC_CHANGE_BATCH BatchMetadata;
    VECTOR_FILE_DOWNLOAD_INFO_ENTRY DownloadInfo;
}

// 3.5.5.1   Upload Data
type UploadDataRequestBody
{
    VECTOR_UPLOAD_ENTRY UploadEntryVector;
}

type UploadDataResponseBody
{
    VECTOR_UPLOAD_RESPONSE_ENTRY UploadResponseEntryVector;
}
    
// 3.5.5.2   Download Data
type DownloadDataRequestBody
{
    VECTOR_DOWNLOAD_ENTRY DownloadEntryVector;
}
    
type DownloadDataResponseBody
{
    VECTOR_DOWNLOAD_RESPONSE_ENTRY DownloadResponseEntryVector;
}

// --------------------------Other structures-------------------------------------- //
pattern EcsMessageKind = enum byte
{
    None                    = 0,
    ServerDiscovery         = 1,
    ShareDiscovery          = 2,
    ServerCapabilities      = 3,
    DetectServerChanges     = 4,
    UserConfiguration       = 5,
    CreateSession           = 6,
    GetSyncBatchParameters  = 7,
    PutSyncBatchParameters  = 8,
    PrepareBatch            = 9,
    UploadBatch             = 10,
    DownloadBatch           = 11,
    DeleteSession           = 12,
    UploadData              = 13,
    DownloadData            = 14,
    ...
};

// --------------------------Uri Syntax-------------------------------------- //
pattern String = regex{[\x20-\x7E]*};
syntax XEcsSessionId = s:regex{[\x20-\x2E\x30-\x7E]*} => s; // exclude '/' (0x2F)
pattern BatchIndex = regex{([1-9][0-9]*|0)}; // BatchIndex is unsigned integer
syntax EcsUriStartSyntax = s1:regex{[^ \r\n]*(?i)/Sync/} s2:"1.0" restPart:HTTP.PrimitiveUri => restPart; // Only support Ecs Protocol Version "1.0"
// match the rest string after matching the EcsUriStartSyntax
syntax ServerDiscoveryUriSyntax = s:(regex{^(?i)/Discover/ServerUrl$}) => s;
syntax ShareDiscoveryUriSyntax = s:(regex{^(?i)/Discover/Share$}) => s;
syntax ServerCapabilitiesUriSyntax = s:(regex{^(?i)/Capabilities$}) => s;
syntax DetectServerChangesUriSyntax = s:(regex{^(?i)/Changes$}) => s;
syntax UserConfigurationUriSyntax = s:(regex{^(?i)/Configuration$}) => s;
syntax EcsSessionUriStartSyntax = s1:regex{^(?i)/Session} restPart:HTTP.PrimitiveUri => restPart;
// match the rest string after matching the EcsSessionUriStartSyntax
syntax CreateSessionSyntax = s:(regex{^$}) => s;
syntax SyncBatchParametersSyntax = s:("/" XEcsSessionId regex{(?i)/SyncBatchParameters$}) => s;
syntax PrepareBatchSyntax = s:("/" XEcsSessionId regex{(?i)/PrepareBatch/} BatchIndex regex{$}) => s;
syntax UploadBatchSyntax = s:("/" XEcsSessionId regex{(?i)/UploadBatch/} BatchIndex regex{$}) => s;
syntax DeleteSessionSyntax = s:("/" XEcsSessionId regex{$}) => s;
syntax DownloadBatchSyntax = s:("/" XEcsSessionId regex{(?i)/DownloadBatch$} regex{$}) => s;
syntax UploadDataSyntax = s:("/" XEcsSessionId regex{(?i)/UploadData$} regex{$}) => s;
syntax DownloadDataSyntax = s:("/" XEcsSessionId regex{(?i)/DownloadData$} regex{$}) => s;

// --------------------------Utility Functions------------------------------------ //
string AddOptionalFieldToSummary(optional string input, string fileDisplayName)
{
    return input != nothing ? ", " + fileDisplayName + ": " + (input as string) : "";
}

void ReportRequiredHeaderMissing(any message context, string headerName, string messageName)
{
    ValidationCheck(false, context, DiagnosisLevel.Error, () => Format(ECS_HTTP_HEADER_MISSING, "ECS", headerName, messageName));
}

// WORKAROUND for feature#64443:Support Encoding related attributes on patterns
type AsciiStringWrapper
{
    string Content with BinaryEncoding{TextEncoding = TextEncoding.ASCII};
}

string DecodeXEcsPartnershipID(string input, any message context, string messageName)
{
    if (Base64StringToBinary(input as string) is data:binary)
    {
        if (BinaryDecoder<AsciiStringWrapper>(data) is wrapper:AsciiStringWrapper)
        {
            return wrapper.Content;
        }
    }
    // decode base64 fail, report diagnostic message and return original string.
    ValidationCheck(false, context, DiagnosisLevel.Error, () => Format(ECS_DECODE_BASE64_FAIL, messageName));
    return input;
}

// WORKAROUND for UTF8 decoding
optional string DecodeOctetStringAsUTF8(any a)
{
    assert a is binary;
    var s = BinaryDecoder<UTF8StringWrapper>(a as binary);
    return s is nothing ? a.ToString() : (s as UTF8StringWrapper).Text;
}
 
type UTF8StringWrapper
{
    string Text;
} with BinaryEncodingDefaults{TextEncoding = TextEncoding.UTF8};

// --------------------------Global Variable-------------------------------------- //
// HTTP Response status code that indicates it's not an error response.
const set<uint> SuccessStatusCodeSet = {200, 201, 202};

pattern BlobType = enum byte
{
    Other = 0,
    SYNC_KNOWLEDGE = 1,
    SYNC_CHANGE_INFORMATION = 2,
    ...
};
