protocol DFSNM with 
Documentation{
    ProtocolName = "Distributed File System (DFS): Namespace Management Protocol",
    ProtocolType = "rpc",
    ShortName = "DFSNM",
    Description = ""
},
OPNAuthoring
{
    Copyright = "(c) Microsoft Corporation",
    References = 
        [
            new Reference {Name = "MS-DFSNM", Version = "26.0", Date = "08/08/2013", ProgramName = ProgramName.WSPP}
        ],
   RevisionSummary = 
        [
            new Revision {Class = RevisionClass.Major, Version = "383625", Date = "01/08/2016"}
        ]
};

using Technologies.IDL;
using DTYP;
using Utility;
using ERREF;
using MSRPCE;

endpoint Server over MSRPCE.Server provides netdfs;

contract netdfs
{
    accepts operation NetrDfsManagerGetVersion
    {
        result NetrDfsManagerGetVersion_ReturnValue ReturnValue where ValidationCheckEnumValue(InRange<NetrDfsManagerGetVersion_ReturnValue>(value), this, false, 
            ReferenceType.Message, "DFSNM", "ReturnValue", "NetrDfsManagerGetVersion", "0x00000001, 0x00000002, 0x00000004, 0x00000006", value)
            with Encoding{Decoder = PatternDecoder<NetrDfsManagerGetVersion_ReturnValue>, SourcePattern = TypeOf<DWORD>()};
        
        override string ToString()
        {
            return "NetrDfsManagerGetVersion, ReturnValue: " + Win32ErrorCodesToText(ReturnValue);
        }
    }
    with Technologies.IDL.IDL{Opnum = 0};
    
    accepts operation NetrDfsAdd
    {
        in optional handle_t IDL_handle;
        in string DfsEntryPath
               with Technologies.IDL.IDL
                        {BaseStringType = TypeOf<WCHAR>(), IndirectionLevel = 1};
        in string ServerName
               with Technologies.IDL.IDL
                        {BaseStringType = TypeOf<WCHAR>(), IndirectionLevel = 1};
        in string ShareName
               with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                         BaseStringType = TypeOf<WCHAR>(),
                                         IndirectionLevel = 1};
        in string Comment
               with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                         BaseStringType = TypeOf<WCHAR>(),
                                         IndirectionLevel = 1};
        in NetrDfsAdd_Flags Flags where ValidationCheckCombinationValueIncludeZero(InRange<NetrDfsAdd_Flags>(value), this, false, 
            ReferenceType.Message, "DFSNM", "Flags", "NetrDfsAdd", "0x00000001, 0x00000002", value)
            with Encoding{Decoder = PatternDecoder<NetrDfsAdd_Flags>, SourcePattern = TypeOf<DWORD>()};
        result NET_API_STATUS ReturnValue with DisplayInfo{ToText = (any x) => Win32ErrorCodesToText(x as uint)};
        
        override string ToString()
        {
            return "NetrDfsAdd, ReturnValue: " + Win32ErrorCodesToText(ReturnValue) + ", DfsEntryPath: " + DfsEntryPath + 
                ", ShareName: " + ShareName  + ", ServerName: " + ServerName;
        }
    }
    with Technologies.IDL.IDL{Opnum = 1};
    
    accepts operation NetrDfsRemove
    {
        in optional handle_t IDL_handle;
        in string DfsEntryPath
               with Technologies.IDL.IDL
                        {BaseStringType = TypeOf<WCHAR>(), IndirectionLevel = 1};
        in string ServerName
               with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                         BaseStringType = TypeOf<WCHAR>(),
                                         IndirectionLevel = 1};
        in string ShareName
               with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                         BaseStringType = TypeOf<WCHAR>(),
                                         IndirectionLevel = 1};
        result NET_API_STATUS ReturnValue with DisplayInfo{ToText = (any x) => Win32ErrorCodesToText(x as uint)};
        
        override string ToString()
        {
            return "NetrDfsRemove, ReturnValue: " + Win32ErrorCodesToText(ReturnValue) + ", DfsEntryPath: " + 
                DfsEntryPath + ", ShareName: " + ShareName + ", ServerName: " + ServerName;
        }
    }
    with Technologies.IDL.IDL{Opnum = 2};
    
    accepts operation NetrDfsSetInfo
    {
        in optional handle_t IDL_handle;
        in string DfsEntryPath
               with Technologies.IDL.IDL
                        {BaseStringType = TypeOf<WCHAR>(), IndirectionLevel = 1};
        in string ServerName
               with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                         BaseStringType = TypeOf<WCHAR>(),
                                         IndirectionLevel = 1};
        in string ShareName
               with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                         BaseStringType = TypeOf<WCHAR>(),
                                         IndirectionLevel = 1};
        in NetrDfsSetInfo_Level Level where ValidationCheckEnumValueTooManyItems(InRange<NetrDfsSetInfo_Level>(value), this, true, 
            ReferenceType.Message, "DFSNM", "Level", "NetrDfsSetInfo", "NetrDfsSetInfo","MS-DFSNM")
            with Encoding{Decoder = PatternDecoder<NetrDfsSetInfo_Level>, SourcePattern = TypeOf<DWORD>()};
        in DFS_INFO_STRUCT[Level] DfsInfo
               with Technologies.IDL.IDL{Switch_Is = Level, IndirectionLevel = 1};
        result NET_API_STATUS ReturnValue with DisplayInfo{ToText = (any x) => Win32ErrorCodesToText(x as uint)};
        
        override string ToString()
        {
            return "NetrDfsSetInfo, ReturnValue: " + Win32ErrorCodesToText(ReturnValue) + ", DfsEntryPath: " + DfsEntryPath + 
                ", ShareName: " + ShareName + ", ServerName: " + ServerName + ", Level: " + 
                EnumToString(Level, "DFSNM.NetrDfsSetInfo_Level");
        }
    }
    with Technologies.IDL.IDL{Opnum = 3};
    
    accepts operation NetrDfsGetInfo
    {
        in optional handle_t IDL_handle;
        in string DfsEntryPath
               with Technologies.IDL.IDL
                        {BaseStringType = TypeOf<WCHAR>(), IndirectionLevel = 1};
        in string ServerName
               with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                         BaseStringType = TypeOf<WCHAR>(),
                                         IndirectionLevel = 1};
        in string ShareName
               with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                         BaseStringType = TypeOf<WCHAR>(),
                                         IndirectionLevel = 1};
        in NetrDfsGetInfo_Level Level where ValidationCheckEnumValueTooManyItems(InRange<NetrDfsGetInfo_Level>(value), this, true, 
            ReferenceType.Message, "DFSNM", "Level", "NetrDfsGetInfo", "NetrDfsGetInfo","MS-DFSNM")
            with Encoding{Decoder = PatternDecoder<NetrDfsGetInfo_Level>, SourcePattern = TypeOf<DWORD>()};
        out DFS_INFO_STRUCT[Level] DfsInfo
                with Technologies.IDL.IDL{Switch_Is = Level, IndirectionLevel = 1};
        result NET_API_STATUS ReturnValue with DisplayInfo{ToText = (any x) => Win32ErrorCodesToText(x as uint)};
        
        override string ToString()
        {
            return "NetrDfsGetInfo, ReturnValue: " + Win32ErrorCodesToText(ReturnValue) + ", DfsEntryPath: " + DfsEntryPath  + 
                ", ShareName: " + ShareName + ", ServerName: " + ServerName + ", Level: " + 
                EnumToString(Level, "DFSNM.NetrDfsGetInfo_Level");
        }
    }
    with Technologies.IDL.IDL{Opnum = 4};
    
    accepts operation NetrDfsEnum
    {
        in optional handle_t IDL_handle;
        in NetrDfsEnum_Level Level where ValidationCheckEnumValueTooManyItems(InRange<NetrDfsEnum_Level>(value), this, true, 
            ReferenceType.Message, "DFSNM", "Level", "NetrDfsEnum", "NetrDfsEnum","MS-DFSNM")
            with Encoding{Decoder = PatternDecoder<NetrDfsEnum_Level>, SourcePattern = TypeOf<DWORD>()};
        in DWORD PrefMaxLen;
        in out DFS_INFO_ENUM_STRUCT DfsEnum
                   with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                             IndirectionLevel = 1};
        in out DWORD ResumeHandle
                   with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                             IndirectionLevel = 1};
        result NET_API_STATUS ReturnValue with DisplayInfo{ToText = (any x) => Win32ErrorCodesToText(x as uint)};
        
        override string ToString()
        {
            return "NetrDfsEnum, ReturnValue: " + Win32ErrorCodesToText(ReturnValue) + ", Level: " + 
                    EnumToString(Level, "DFSNM.NetrDfsEnum_Level");
        }
    }
    with Technologies.IDL.IDL{Opnum = 5};
    
    accepts operation NetrDfsMove
    {
        in optional handle_t IDL_handle;
        in string DfsEntryPath
               with Technologies.IDL.IDL
                        {BaseStringType = TypeOf<WCHAR>(), IndirectionLevel = 1};
        in string NewDfsEntryPath
               with Technologies.IDL.IDL
                        {BaseStringType = TypeOf<WCHAR>(), IndirectionLevel = 1};
        in NetrDfsMove_Flags Flags where ValidationCheckCombinationValueIncludeZero(InRange<NetrDfsMove_Flags>(value), this, false, 
            ReferenceType.Message, "DFSNM", "Flags", "NetrDfsMove", "0x00000001", value)
            with Encoding{Decoder = PatternDecoder<NetrDfsMove_Flags>, SourcePattern = TypeOf<IDLUlong>()};
        result NET_API_STATUS ReturnValue with DisplayInfo{ToText = (any x) => Win32ErrorCodesToText(x as uint)};
        
        override string ToString()
        {
            return "NetrDfsMove, ReturnValue: " + Win32ErrorCodesToText(ReturnValue) + ", DfsEntryPath: " + DfsEntryPath + 
                ", NewDfsEntryPath: " + NewDfsEntryPath;
        }
    }
    with Technologies.IDL.IDL{Opnum = 6};
    
    accepts operation Opnum7NotUsedOnWire
    {
    }
    with Technologies.IDL.IDL{Opnum = 7};
    
    accepts operation Opnum8NotUsedOnWire
    {
    }
    with Technologies.IDL.IDL{Opnum = 8};
    
    accepts operation Opnum9NotUsedOnWire
    {
    }
    with Technologies.IDL.IDL{Opnum = 9};
    
    accepts operation NetrDfsAddFtRoot
    {
        in optional handle_t IDL_handle;
        in string ServerName
               with Technologies.IDL.IDL
                        {BaseStringType = TypeOf<WCHAR>(), IndirectionLevel = 1};
        in string DcName
               with Technologies.IDL.IDL
                        {BaseStringType = TypeOf<WCHAR>(), IndirectionLevel = 1};
        in string RootShare
               with Technologies.IDL.IDL
                        {BaseStringType = TypeOf<WCHAR>(), IndirectionLevel = 1};
        in string FtDfsName
               with Technologies.IDL.IDL
                        {BaseStringType = TypeOf<WCHAR>(), IndirectionLevel = 1};
        in string Comment
               with Technologies.IDL.IDL
                        {BaseStringType = TypeOf<WCHAR>(), IndirectionLevel = 1};
        in string ConfigDN
               with Technologies.IDL.IDL
                        {BaseStringType = TypeOf<WCHAR>(), IndirectionLevel = 1};
        in BOOLEAN NewFtDfs;
        in DWORD ApiFlags where ValidationCheckZero(value == 0x00, this, true, ReferenceType.Message, "DFSNM", 
            "ApiFlags", "NetrDfsAddFtRoot", value);
        in out DFSM_ROOT_LIST ppRootList
                   with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                             IndirectionLevel = 2};
        result NET_API_STATUS ReturnValue with DisplayInfo{ToText = (any x) => Win32ErrorCodesToText(x as uint)};
        
        override string ToString()
        {
            return "NetrDfsAddFtRoot, ReturnValue: " + Win32ErrorCodesToText(ReturnValue) + ", RootShare: " + RootShare + 
                ", FtDfsName: " + FtDfsName + ", ServerName: " + ServerName + ", NewFtDfs: " + NewFtDfs.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 10};
    
    accepts operation NetrDfsRemoveFtRoot
    {
        in optional handle_t IDL_handle;
        in string ServerName
               with Technologies.IDL.IDL
                        {BaseStringType = TypeOf<WCHAR>(), IndirectionLevel = 1};
        in string DcName
               with Technologies.IDL.IDL
                        {BaseStringType = TypeOf<WCHAR>(), IndirectionLevel = 1};
        in string RootShare
               with Technologies.IDL.IDL
                        {BaseStringType = TypeOf<WCHAR>(), IndirectionLevel = 1};
        in string FtDfsName
               with Technologies.IDL.IDL
                        {BaseStringType = TypeOf<WCHAR>(), IndirectionLevel = 1};
        in NetrDfsRemoveFtRoot_ApiFlags ApiFlags where ValidationCheckCombinationValueIncludeZero(InRange<NetrDfsRemoveFtRoot_ApiFlags>(value), this, false, 
            ReferenceType.Message, "DFSNM", "ApiFlags", "NetrDfsRemoveFtRoot", "0x80000000", value)
            with Encoding{Decoder = PatternDecoder<NetrDfsRemoveFtRoot_ApiFlags>, SourcePattern = TypeOf<DWORD>()};
        in out DFSM_ROOT_LIST ppRootList
                   with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                             IndirectionLevel = 2};
        result NET_API_STATUS ReturnValue with DisplayInfo{ToText = (any x) => Win32ErrorCodesToText(x as uint)};
        
        override string ToString()
        {
            return "NetrDfsRemoveFtRoot, ReturnValue: " + Win32ErrorCodesToText(ReturnValue) + ", RootShare: " + RootShare + 
                ", FtDfsName: " + FtDfsName + ", ServerName: " + ServerName + ", ApiFlags: " + 
                EnumToString(ApiFlags, "DFSNM.NetrDfsRemoveFtRoot_ApiFlags");
        }
    }
    with Technologies.IDL.IDL{Opnum = 11};
    
    accepts operation NetrDfsAddStdRoot
    {
        in optional handle_t IDL_handle;
        in string ServerName
               with Technologies.IDL.IDL
                        {BaseStringType = TypeOf<WCHAR>(), IndirectionLevel = 1};
        in string RootShare
               with Technologies.IDL.IDL
                        {BaseStringType = TypeOf<WCHAR>(), IndirectionLevel = 1};
        in string Comment
               with Technologies.IDL.IDL
                        {BaseStringType = TypeOf<WCHAR>(), IndirectionLevel = 1};
        in DWORD ApiFlags where ValidationCheckZero(value == 0x00, this, true, ReferenceType.Message, "DFSNM", 
            "ApiFlags", "NetrDfsAddStdRoot", value);
        result NET_API_STATUS ReturnValue with DisplayInfo{ToText = (any x) => Win32ErrorCodesToText(x as uint)};
        
        override string ToString()
        {
            return "NetrDfsAddStdRoot, ReturnValue: " + Win32ErrorCodesToText(ReturnValue) + ", RootShare: " + RootShare + 
                ", ServerName: " + ServerName;
        }
    }
    with Technologies.IDL.IDL{Opnum = 12};
    
    accepts operation NetrDfsRemoveStdRoot
    {
        in optional handle_t IDL_handle;
        in string ServerName
               with Technologies.IDL.IDL
                        {BaseStringType = TypeOf<WCHAR>(), IndirectionLevel = 1};
        in string RootShare
               with Technologies.IDL.IDL
                        {BaseStringType = TypeOf<WCHAR>(), IndirectionLevel = 1};
        in DWORD ApiFlags;
        result NET_API_STATUS ReturnValue with DisplayInfo{ToText = (any x) => Win32ErrorCodesToText(x as uint)};
        
        override string ToString()
        {
            return "NetrDfsRemoveStdRoot, ReturnValue: " + Win32ErrorCodesToText(ReturnValue)+ ", RootShare: " + RootShare + 
                    ", ServerName: " + ServerName;
        }
    }
    with Technologies.IDL.IDL{Opnum = 13};
    
    accepts operation NetrDfsManagerInitialize
    {
        in optional handle_t IDL_handle;
        in string ServerName
               with Technologies.IDL.IDL
                        {BaseStringType = TypeOf<WCHAR>(), IndirectionLevel = 1};
        in DWORD Flags where ValidationCheckZero(value == 0x00, this, true, ReferenceType.Message, "DFSNM", "Flags", 
            "NetrDfsManagerInitialize", value);
        result NET_API_STATUS ReturnValue with DisplayInfo{ToText = (any x) => Win32ErrorCodesToText(x as uint)};
        
        override string ToString()
        {
            return "NetrDfsManagerInitialize, ReturnValue: " + Win32ErrorCodesToText(ReturnValue) + ", ServerName: " + ServerName;
        }
    }
    with Technologies.IDL.IDL{Opnum = 14};
    
    accepts operation NetrDfsAddStdRootForced
    {
        in optional handle_t IDL_handle;
        in string ServerName
               with Technologies.IDL.IDL
                        {BaseStringType = TypeOf<WCHAR>(), IndirectionLevel = 1};
        in string RootShare
               with Technologies.IDL.IDL
                        {BaseStringType = TypeOf<WCHAR>(), IndirectionLevel = 1};
        in string Comment
               with Technologies.IDL.IDL
                        {BaseStringType = TypeOf<WCHAR>(), IndirectionLevel = 1};
        in string Share
               with Technologies.IDL.IDL
                        {BaseStringType = TypeOf<WCHAR>(), IndirectionLevel = 1};
        result NET_API_STATUS ReturnValue with DisplayInfo{ToText = (any x) => Win32ErrorCodesToText(x as uint)};
        
        override string ToString()
        {
            return "NetrDfsAddStdRootForced, ReturnValue: " + Win32ErrorCodesToText(ReturnValue) + ", RootShare: " + RootShare + 
                ", ServerName: " + ServerName + ", Share: " + Share;
        }
    }
    with Technologies.IDL.IDL{Opnum = 15};
    
    accepts operation NetrDfsGetDcAddress
    {
        in optional handle_t IDL_handle;
        in string ServerName
               with Technologies.IDL.IDL
                        {BaseStringType = TypeOf<WCHAR>(), IndirectionLevel = 1};
        in out string DcName
                   with Technologies.IDL.IDL
                            {BaseStringType = TypeOf<WCHAR>(), IndirectionLevel = 2};
        in out BOOLEAN IsRoot with Technologies.IDL.IDL{IndirectionLevel = 1};
        in out IDLUlong Timeout with Technologies.IDL.IDL{IndirectionLevel = 1};
        result NET_API_STATUS ReturnValue with DisplayInfo{ToText = (any x) => Win32ErrorCodesToText(x as uint)};
        
        override string ToString()
        {
            return "NetrDfsGetDcAddress, ReturnValue: " + Win32ErrorCodesToText(ReturnValue) + ", ServerName: " + ServerName + 
                ", DcName: " + DcName + ", IsRoot: " + IsRoot.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 16};
    
    accepts operation NetrDfsSetDcAddress
    {
        in optional handle_t IDL_handle;
        in string ServerName
               with Technologies.IDL.IDL
                        {BaseStringType = TypeOf<WCHAR>(), IndirectionLevel = 1};
        in string DcName
               with Technologies.IDL.IDL
                        {BaseStringType = TypeOf<WCHAR>(), IndirectionLevel = 1};
        in DWORD Timeout;
        in NetrDfsSetDcAddress_Flags Flags where ValidationCheckCombinationValueIncludeZero(InRange<NetrDfsSetDcAddress_Flags>(value), this, false, 
            ReferenceType.Message, "DFSNM", "Flags", "NetrDfsSetDcAddress", "0x00000001, 0x00000002", value)
            with Encoding{Decoder = PatternDecoder<NetrDfsSetDcAddress_Flags>, SourcePattern = TypeOf<DWORD>()};
        result NET_API_STATUS ReturnValue with DisplayInfo{ToText = (any x) => Win32ErrorCodesToText(x as uint)};
        
        override string ToString()
        {
            return "NetrDfsSetDcAddress, ReturnValue: " + Win32ErrorCodesToText(ReturnValue) + ", ServerName: " + ServerName + 
                ", DcName: " + DcName + ", Flags: " + EnumToString(Flags, "DFSNM.NetrDfsSetDcAddress_Flags");
        }
    }
    with Technologies.IDL.IDL{Opnum = 17};
    
    accepts operation NetrDfsFlushFtTable
    {
        in optional handle_t IDL_handle;
        in string DcName
               with Technologies.IDL.IDL
                        {BaseStringType = TypeOf<WCHAR>(), IndirectionLevel = 1};
        in string wszFtDfsName
               with Technologies.IDL.IDL
                        {BaseStringType = TypeOf<WCHAR>(), IndirectionLevel = 1};
        result NET_API_STATUS ReturnValue with DisplayInfo{ToText = (any x) => Win32ErrorCodesToText(x as uint)};
        
        override string ToString()
        {
            return "NetrDfsFlushFtTable, ReturnValue: " + Win32ErrorCodesToText(ReturnValue) +
                ", wszFtDfsName: " + wszFtDfsName + ", DcName: " + DcName;
        }
    }
    with Technologies.IDL.IDL{Opnum = 18};
    
    accepts operation NetrDfsAdd2
    {
        in optional handle_t IDL_handle;
        in string DfsEntryPath
               with Technologies.IDL.IDL
                        {BaseStringType = TypeOf<WCHAR>(), IndirectionLevel = 1};
        in string DcName
               with Technologies.IDL.IDL
                        {BaseStringType = TypeOf<WCHAR>(), IndirectionLevel = 1};
        in string ServerName
               with Technologies.IDL.IDL
                        {BaseStringType = TypeOf<WCHAR>(), IndirectionLevel = 1};
        in string ShareName
               with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                         BaseStringType = TypeOf<WCHAR>(),
                                         IndirectionLevel = 1};
        in string Comment
               with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                         BaseStringType = TypeOf<WCHAR>(),
                                         IndirectionLevel = 1};
        in NetrDfsAdd2_Flags Flags where ValidationCheckCombinationValueIncludeZero(InRange<NetrDfsAdd2_Flags>(value), this, false, 
            ReferenceType.Message, "DFSNM", "Flags", "NetrDfsAdd2", "0x00000001, 0x00000002", value)
            with Encoding{Decoder = PatternDecoder<NetrDfsAdd2_Flags>, SourcePattern = TypeOf<DWORD>()};
        in out DFSM_ROOT_LIST ppRootList
                   with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                             IndirectionLevel = 2};
        result NET_API_STATUS ReturnValue with DisplayInfo{ToText = (any x) => Win32ErrorCodesToText(x as uint)};
        
        override string ToString()
        {
            return "NetrDfsAdd2, ReturnValue: " + Win32ErrorCodesToText(ReturnValue) + ", DfsEntryPath: " + DfsEntryPath + 
                ", ShareName: " + ShareName + ", ServerName: " + ServerName + ", DcName: " + DcName;
        }
    }
    with Technologies.IDL.IDL{Opnum = 19};
    
    accepts operation NetrDfsRemove2
    {
        in optional handle_t IDL_handle;
        in string DfsEntryPath
               with Technologies.IDL.IDL
                        {BaseStringType = TypeOf<WCHAR>(), IndirectionLevel = 1};
        in string DcName
               with Technologies.IDL.IDL
                        {BaseStringType = TypeOf<WCHAR>(), IndirectionLevel = 1};
        in string ServerName
               with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                         BaseStringType = TypeOf<WCHAR>(),
                                         IndirectionLevel = 1};
        in string ShareName
               with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                         BaseStringType = TypeOf<WCHAR>(),
                                         IndirectionLevel = 1};
        in out DFSM_ROOT_LIST ppRootList
                   with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                             IndirectionLevel = 2};
        result NET_API_STATUS ReturnValue with DisplayInfo{ToText = (any x) => Win32ErrorCodesToText(x as uint)};
        
        override string ToString()
        {
            return "NetrDfsRemove2, ReturnValue: " + Win32ErrorCodesToText(ReturnValue) + ", DfsEntryPath: " + DfsEntryPath + 
                ", ShareName: " + ShareName  + ", ServerName: " + ServerName + ", DcName: " + DcName;
        }
    }
    with Technologies.IDL.IDL{Opnum = 20};
    
    accepts operation NetrDfsEnumEx
    {
        in optional handle_t IDL_handle;
        in string DfsEntryPath
               with Technologies.IDL.IDL
                        {BaseStringType = TypeOf<WCHAR>(), IndirectionLevel = 1};
        in NetrDfsEnumEx_Level Level where ValidationCheckEnumValueTooManyItems(InRange<NetrDfsEnumEx_Level>(value), this, true, 
            ReferenceType.Message, "DFSNM", "Level", "NetrDfsEnumEx", "NetrDfsEnumEx","MS-DFSNM")
            with Encoding{Decoder = PatternDecoder<NetrDfsEnumEx_Level>, SourcePattern = TypeOf<DWORD>()};
        in DWORD PrefMaxLen;
        in out DFS_INFO_ENUM_STRUCT DfsEnum
                   with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                             IndirectionLevel = 1};
        in out DWORD ResumeHandle
                   with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                             IndirectionLevel = 1};
        result NET_API_STATUS ReturnValue with DisplayInfo{ToText = (any x) => Win32ErrorCodesToText(x as uint)};
        
        override string ToString()
        {
            return "NetrDfsEnumEx, ReturnValue: " + Win32ErrorCodesToText(ReturnValue) + ", DfsEntryPath: " + DfsEntryPath + 
                ", Level: " + EnumToString(Level, "DFSNM.NetrDfsEnumEx_Level");
        }
    }
    with Technologies.IDL.IDL{Opnum = 21};
    
    accepts operation NetrDfsSetInfo2
    {
        in optional handle_t IDL_handle;
        in string DfsEntryPath
               with Technologies.IDL.IDL
                        {BaseStringType = TypeOf<WCHAR>(), IndirectionLevel = 1};
        in string DcName
               with Technologies.IDL.IDL
                        {BaseStringType = TypeOf<WCHAR>(), IndirectionLevel = 1};
        in string ServerName
               with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                         BaseStringType = TypeOf<WCHAR>(),
                                         IndirectionLevel = 1};
        in string ShareName
               with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                         BaseStringType = TypeOf<WCHAR>(),
                                         IndirectionLevel = 1};
        in NetrDfsSetInfo2_Level Level where ValidationCheckEnumValueTooManyItems(InRange<NetrDfsSetInfo2_Level>(value), this, true, 
            ReferenceType.Message, "DFSNM", "Level", "NetrDfsSetInfo2", "NetrDfsSetInfo2","MS-DFSNM")
            with Encoding{Decoder = PatternDecoder<NetrDfsSetInfo2_Level>, SourcePattern = TypeOf<DWORD>()};
        in DFS_INFO_STRUCT[Level] pDfsInfo
               with Technologies.IDL.IDL{Switch_Is = Level, IndirectionLevel = 1};
        in out DFSM_ROOT_LIST ppRootList
                   with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                             IndirectionLevel = 2};
        result NET_API_STATUS ReturnValue with DisplayInfo{ToText = (any x) => Win32ErrorCodesToText(x as uint)};
        
        override string ToString()
        {
            return "NetrDfsSetInfo2, ReturnValue: " + Win32ErrorCodesToText(ReturnValue) + ", DfsEntryPath: " + DfsEntryPath + 
                ", ShareName: " + ShareName + ", ServerName: " + ServerName + ", Level: " + EnumToString(Level, "DFSNM.NetrDfsSetInfo2_Level");
        }
    }
    with Technologies.IDL.IDL{Opnum = 22};
    
    accepts operation NetrDfsAddRootTarget
    {
        in optional handle_t IDL_handle;
        in string DfsPath
               with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                         BaseStringType = TypeOf<wchar_t>(),
                                         IndirectionLevel = 1};
        in string TargetPath
               with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                         BaseStringType = TypeOf<wchar_t>(),
                                         IndirectionLevel = 1};
        in ULONG MajorVersion;
        in string Comment
               with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                         BaseStringType = TypeOf<wchar_t>(),
                                         IndirectionLevel = 1};
        in BOOLEAN NewNamespace;
        in ULONG Flags;
        result NET_API_STATUS ReturnValue with DisplayInfo{ToText = (any x) => Win32ErrorCodesToText(x as uint)};
        
        override string ToString()
        {
            return "NetrDfsAddRootTarget, ReturnValue: " + Win32ErrorCodesToText(ReturnValue) + ", DfsPath: " + DfsPath +
                ", TargetPath: " + TargetPath;
        }
    }
    with Technologies.IDL.IDL{Opnum = 23};
    
    accepts operation NetrDfsRemoveRootTarget
    {
        in optional handle_t IDL_handle;
        in string pDfsPath
               with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                         BaseStringType = TypeOf<wchar_t>(),
                                         IndirectionLevel = 1};
        in string pTargetPath
               with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                         BaseStringType = TypeOf<wchar_t>(),
                                         IndirectionLevel = 1};
        in NetrDfsRemoveRootTarget_Flags Flags where ValidationCheckCombinationValueIncludeZero(InRange<NetrDfsRemoveRootTarget_Flags>(value), this, false, 
            ReferenceType.Message, "DFSNM", "Flags", "NetrDfsRemoveRootTarget", "0x80000000", value)
            with Encoding{Decoder = PatternDecoder<NetrDfsRemoveRootTarget_Flags>, SourcePattern = TypeOf<ULONG>()};
        result NET_API_STATUS ReturnValue with DisplayInfo{ToText = (any x) => Win32ErrorCodesToText(x as uint)};
        
        override string ToString()
        {
            return "NetrDfsRemoveRootTarget, ReturnValue: " + Win32ErrorCodesToText(ReturnValue) + ", pDfsPath: " + pDfsPath +
                ", pTargetPath: " + pTargetPath + ", Flags: " + EnumToString(Flags, "DFSNM.NetrDfsRemoveRootTarget_Flags");
        }
    }
    with Technologies.IDL.IDL{Opnum = 24};
    
    accepts operation NetrDfsGetSupportedNamespaceVersion
    {
        in optional handle_t IDL_handle;
        in DFS_NAMESPACE_VERSION_ORIGIN Origin;
        in string pName
               with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                         BaseStringType = TypeOf<WCHAR>(),
                                         IndirectionLevel = 1};
        out DFS_SUPPORTED_NAMESPACE_VERSION_INFO pVersionInfo
                with Technologies.IDL.IDL{IndirectionLevel = 1};
        result NET_API_STATUS ReturnValue with DisplayInfo{ToText = (any x) => Win32ErrorCodesToText(x as uint)};
        
        override string ToString()
        {
            return "NetrDfsGetSupportedNamespaceVersion, ReturnValue: " +  Win32ErrorCodesToText(ReturnValue) + ", Origin: " + 
                EnumToString(Origin, "DFSNM.DFS_NAMESPACE_VERSION_ORIGIN");
        }
    }
    with Technologies.IDL.IDL{Opnum = 25};
}
with Technologies.IDL.IDL{Uuid = {4fc742e0-4a10-11cf-8273-00aa004ae673},
                          Version = "3.0",
                          Pointer_default = PointerKind.UniquePtr,
                          Ms_union = true};

typedef NET_API_STATUS = DWORD ;

type DFS_INFO_STRUCT[IDLUlong tag]
{
    optional [|tag == 1|] DFS_INFO_1 DfsInfo1
        with Technologies.IDL.IDL{Case = [1], IndirectionLevel = 1};
    optional [|tag == 2|] DFS_INFO_2 DfsInfo2
        with Technologies.IDL.IDL{Case = [2], IndirectionLevel = 1};
    optional [|tag == 3|] DFS_INFO_3 DfsInfo3
        with Technologies.IDL.IDL{Case = [3], IndirectionLevel = 1};
    optional [|tag == 4|] DFS_INFO_4 DfsInfo4
        with Technologies.IDL.IDL{Case = [4], IndirectionLevel = 1};
    optional [|tag == 5|] DFS_INFO_5 DfsInfo5
        with Technologies.IDL.IDL{Case = [5], IndirectionLevel = 1};
    optional [|tag == 6|] DFS_INFO_6 DfsInfo6
        with Technologies.IDL.IDL{Case = [6], IndirectionLevel = 1};
    optional [|tag == 7|] DFS_INFO_7 DfsInfo7
        with Technologies.IDL.IDL{Case = [7], IndirectionLevel = 1};
    optional [|tag == 8|] DFS_INFO_8 DfsInfo8
        with Technologies.IDL.IDL{Case = [8], IndirectionLevel = 1};
    optional [|tag == 9|] DFS_INFO_9 DfsInfo9
        with Technologies.IDL.IDL{Case = [9], IndirectionLevel = 1};
    optional [|tag == 50|] DFS_INFO_50 DfsInfo50
        with Technologies.IDL.IDL{Case = [50], IndirectionLevel = 1};
    optional [|tag == 100|] DFS_INFO_100 DfsInfo100
        with Technologies.IDL.IDL{Case = [100], IndirectionLevel = 1};
    optional [|tag == 101|] DFS_INFO_101 DfsInfo101
        with Technologies.IDL.IDL{Case = [101], IndirectionLevel = 1};
    optional [|tag == 102|] DFS_INFO_102 DfsInfo102
        with Technologies.IDL.IDL{Case = [102], IndirectionLevel = 1};
    optional [|tag == 103|] DFS_INFO_103 DfsInfo103
        with Technologies.IDL.IDL{Case = [103], IndirectionLevel = 1};
    optional [|tag == 104|] DFS_INFO_104 DfsInfo104
        with Technologies.IDL.IDL{Case = [104], IndirectionLevel = 1};
    optional [|tag == 105|] DFS_INFO_105 DfsInfo105
        with Technologies.IDL.IDL{Case = [105], IndirectionLevel = 1};
    optional [|tag == 106|] DFS_INFO_106 DfsInfo106
        with Technologies.IDL.IDL{Case = [106], IndirectionLevel = 1};
    optional [|tag == 107|] DFS_INFO_107 DfsInfo107
        with Technologies.IDL.IDL{Case = [107], IndirectionLevel = 1};
    optional [|tag == 150|] DFS_INFO_150 DfsInfo150
        with Technologies.IDL.IDL{Case = [150], IndirectionLevel = 1};
}
with Technologies.IDL.IDL{EmptyDefault = true,
                          Switch_Type = TypeOf<IDLUlong>(),
                          UnionKind = UnionKind.NonEncapsulated};

type DFS_INFO_1
{
    string EntryPath
        with Technologies.IDL.IDL
                 {BaseStringType = TypeOf<WCHAR>(), IndirectionLevel = 1};
}

type DFS_INFO_2
{
    string EntryPath
        with Technologies.IDL.IDL
                 {BaseStringType = TypeOf<WCHAR>(), IndirectionLevel = 1};
    string Comment
        with Technologies.IDL.IDL
                 {BaseStringType = TypeOf<WCHAR>(), IndirectionLevel = 1};
    DWORD State;
    DWORD NumberOfStorages;
}

type DFS_INFO_3
{
    string EntryPath
        with Technologies.IDL.IDL
                 {BaseStringType = TypeOf<WCHAR>(), IndirectionLevel = 1};
    string Comment
        with Technologies.IDL.IDL
                 {BaseStringType = TypeOf<WCHAR>(), IndirectionLevel = 1};
    DWORD State;
    DWORD NumberOfStorages;
    array<DFS_STORAGE_INFO> Storage
        with Technologies.IDL.IDL{Size_is = [NumberOfStorages], IndirectionLevel = 1};
}

type DFS_STORAGE_INFO
{
    IDLUlong State;
    string ServerName
        with Technologies.IDL.IDL
                 {BaseStringType = TypeOf<WCHAR>(), IndirectionLevel = 1};
    string ShareName
        with Technologies.IDL.IDL
                 {BaseStringType = TypeOf<WCHAR>(), IndirectionLevel = 1};
}

type DFS_INFO_4
{
    string EntryPath
        with Technologies.IDL.IDL
                 {BaseStringType = TypeOf<WCHAR>(), IndirectionLevel = 1};
    string Comment
        with Technologies.IDL.IDL
                 {BaseStringType = TypeOf<WCHAR>(), IndirectionLevel = 1};
    DWORD State;
    IDLUlong Timeout;
    GUID Guid;
    DWORD NumberOfStorages;
    array<DFS_STORAGE_INFO> Storage
        with Technologies.IDL.IDL{Size_is = [NumberOfStorages], IndirectionLevel = 1};
}

type DFS_INFO_5
{
    string EntryPath
        with Technologies.IDL.IDL
                 {BaseStringType = TypeOf<WCHAR>(), IndirectionLevel = 1};
    string Comment
        with Technologies.IDL.IDL
                 {BaseStringType = TypeOf<WCHAR>(), IndirectionLevel = 1};
    DWORD State;
    IDLUlong Timeout;
    GUID Guid;
    IDLUlong PropertyFlags;
    IDLUlong MetadataSize;
    DWORD NumberOfStorages;
}

type DFS_INFO_6
{
    string EntryPath
        with Technologies.IDL.IDL
                 {BaseStringType = TypeOf<WCHAR>(), IndirectionLevel = 1};
    string Comment
        with Technologies.IDL.IDL
                 {BaseStringType = TypeOf<WCHAR>(), IndirectionLevel = 1};
    DWORD State;
    IDLUlong Timeout;
    GUID Guid;
    IDLUlong PropertyFlags;
    IDLUlong MetadataSize;
    DWORD NumberOfStorages;
    array<DFS_STORAGE_INFO_1> Storage
        with Technologies.IDL.IDL{Size_is = [NumberOfStorages], IndirectionLevel = 1};
}

type DFS_STORAGE_INFO_1
{
    IDLUlong State;
    string ServerName
        with Technologies.IDL.IDL
                 {BaseStringType = TypeOf<WCHAR>(), IndirectionLevel = 1};
    string ShareName
        with Technologies.IDL.IDL
                 {BaseStringType = TypeOf<WCHAR>(), IndirectionLevel = 1};
    DFS_TARGET_PRIORITY TargetPriority;
}

type DFS_TARGET_PRIORITY
{
    DFS_TARGET_PRIORITY_CLASS TargetPriorityClass;
    ushort TargetPriorityRank;
    ushort Reserved;
}

pattern DFS_TARGET_PRIORITY_CLASS = enum 
{
    DfsInvalidPriorityClass = -1,
    DfsSiteCostNormalPriorityClass = 0,
    DfsGlobalHighPriorityClass = 1,
    DfsSiteCostHighPriorityClass = 2,
    DfsSiteCostLowPriorityClass = 3,
    DfsGlobalLowPriorityClass = 4
} with Technologies.IDL.IDL{V1_enum = true};

type DFS_INFO_7
{
    GUID GenerationGuid;
}

type DFS_INFO_8
{
    string EntryPath
        with Technologies.IDL.IDL
                 {BaseStringType = TypeOf<WCHAR>(), IndirectionLevel = 1};
    string Comment
        with Technologies.IDL.IDL
                 {BaseStringType = TypeOf<WCHAR>(), IndirectionLevel = 1};
    DWORD State;
    IDLUlong Timeout;
    GUID Guid;
    IDLUlong PropertyFlags;
    IDLUlong MetadataSize;
    ULONG SecurityDescriptorLength;
    // Make the field as optional since the pointer to SecurityDescriptorPattern could be null 
    optional DTYP.SECURITY_DESCRIPTOR_NonRpc pSecurityDescriptor
        with 
        Encoding 
            {
                Decoder = BinaryDecoder<DTYP.SECURITY_DESCRIPTOR_NonRpc>,
                SourceConverter = (array<byte> arr) => ((arr as binary) as optional binary),
                SourcePattern = TypeOf<array<byte>>()
            },
            Technologies.IDL.IDL {Size_is = [SecurityDescriptorLength], IndirectionLevel = 1};
    DWORD NumberOfStorages;
}

type DFS_INFO_9
{
    string EntryPath
        with Technologies.IDL.IDL
                 {BaseStringType = TypeOf<WCHAR>(), IndirectionLevel = 1};
    string Comment
        with Technologies.IDL.IDL
                 {BaseStringType = TypeOf<WCHAR>(), IndirectionLevel = 1};
    DWORD State;
    IDLUlong Timeout;
    GUID Guid;
    IDLUlong PropertyFlags;
    IDLUlong MetadataSize;
    ULONG SecurityDescriptorLength;
    optional DTYP.SECURITY_DESCRIPTOR_NonRpc pSecurityDescriptor
        with 
        Encoding 
            {
                Decoder = BinaryDecoder<DTYP.SECURITY_DESCRIPTOR_NonRpc>,
                SourceConverter = (array<byte> arr) => ((arr as binary) as optional binary),
                SourcePattern = TypeOf<array<byte>>()
            },
            Technologies.IDL.IDL {Size_is = [SecurityDescriptorLength], IndirectionLevel = 1};
    DWORD NumberOfStorages;
    array<DFS_STORAGE_INFO_1> Storage
        with Technologies.IDL.IDL{Size_is = [NumberOfStorages], IndirectionLevel = 1};
}

type DFS_INFO_50
{
    IDLUlong NamespaceMajorVersion;
    IDLUlong NamespaceMinorVersion;
    __uint64 NamespaceCapabilities;
}

type DFS_INFO_100
{
    string Comment
        with Technologies.IDL.IDL
                 {BaseStringType = TypeOf<WCHAR>(), IndirectionLevel = 1};
}

type DFS_INFO_101
{
    IDLUlong State;
}

type DFS_INFO_102
{
    IDLUlong Timeout;
}

type DFS_INFO_103
{
    IDLUlong PropertyFlagMask;
    IDLUlong PropertyFlags;
}

type DFS_INFO_104
{
    DFS_TARGET_PRIORITY TargetPriority;
}

type DFS_INFO_105
{
    string Comment
        with Technologies.IDL.IDL
                 {BaseStringType = TypeOf<WCHAR>(), IndirectionLevel = 1};
    DWORD State;
    IDLUlong Timeout;
    IDLUlong PropertyFlagMask;
    IDLUlong PropertyFlags;
}

type DFS_INFO_106
{
    DWORD State;
    DFS_TARGET_PRIORITY TargetPriority;
}

type DFS_INFO_107
{
    string Comment
        with Technologies.IDL.IDL
                 {BaseStringType = TypeOf<WCHAR>(), IndirectionLevel = 1};
    DWORD State;
    IDLUlong Timeout;
    IDLUlong PropertyFlagMask;
    IDLUlong PropertyFlags;
    ULONG SecurityDescriptorLength;    
    optional DTYP.SECURITY_DESCRIPTOR_NonRpc pSecurityDescriptor
        with 
        Encoding 
            {
                Decoder = BinaryDecoder<DTYP.SECURITY_DESCRIPTOR_NonRpc>,
                SourceConverter = (array<byte> arr) => ((arr as binary) as optional binary),
                SourcePattern = TypeOf<array<byte>>()
            },
            Technologies.IDL.IDL {Size_is = [SecurityDescriptorLength], IndirectionLevel = 1};
}

type DFS_INFO_150
{
    ULONG SecurityDescriptorLength;
    optional DTYP.SECURITY_DESCRIPTOR_NonRpc pSecurityDescriptor
        with 
        Encoding 
            {
                Decoder = BinaryDecoder<DTYP.SECURITY_DESCRIPTOR_NonRpc>,
                SourceConverter = (array<byte> arr) => ((arr as binary) as optional binary),
                SourcePattern = TypeOf<array<byte>>()
            },
            Technologies.IDL.IDL {Size_is = [SecurityDescriptorLength], IndirectionLevel = 1};
}

type DFS_INFO_ENUM_STRUCT
{
    DWORD Level;
    DFS_INFO_ENUM_STRUCT_UnionType[Level] DfsInfoContainer
        with Technologies.IDL.IDL{Switch_Is = Level, EmbedType = true};
}

type DFS_INFO_ENUM_STRUCT_UnionType[DWORD tag]
{
    optional [|tag == 1|] DFS_INFO_1_CONTAINER DfsInfo1Container
        with Technologies.IDL.IDL{Case = [1], IndirectionLevel = 1};
    optional [|tag == 2|] DFS_INFO_2_CONTAINER DfsInfo2Container
        with Technologies.IDL.IDL{Case = [2], IndirectionLevel = 1};
    optional [|tag == 3|] DFS_INFO_3_CONTAINER DfsInfo3Container
        with Technologies.IDL.IDL{Case = [3], IndirectionLevel = 1};
    optional [|tag == 4|] DFS_INFO_4_CONTAINER DfsInfo4Container
        with Technologies.IDL.IDL{Case = [4], IndirectionLevel = 1};
    optional [|tag == 5|] DFS_INFO_5_CONTAINER DfsInfo5Container
        with Technologies.IDL.IDL{Case = [5], IndirectionLevel = 1};
    optional [|tag == 6|] DFS_INFO_6_CONTAINER DfsInfo6Container
        with Technologies.IDL.IDL{Case = [6], IndirectionLevel = 1};
    optional [|tag == 8|] DFS_INFO_8_CONTAINER DfsInfo8Container
        with Technologies.IDL.IDL{Case = [8], IndirectionLevel = 1};
    optional [|tag == 9|] DFS_INFO_9_CONTAINER DfsInfo9Container
        with Technologies.IDL.IDL{Case = [9], IndirectionLevel = 1};
    optional [|tag == 200|] DFS_INFO_200_CONTAINER DfsInfo200Container
        with Technologies.IDL.IDL{Case = [200], IndirectionLevel = 1};
    optional [|tag == 300|] DFS_INFO_300_CONTAINER DfsInfo300Container
        with Technologies.IDL.IDL{Case = [300], IndirectionLevel = 1};
}
with Technologies.IDL.IDL
         {Switch_Type = TypeOf<DWORD>(), UnionKind = UnionKind.NonEncapsulated};

type DFS_INFO_1_CONTAINER
{
    DWORD EntriesRead;
    array<DFS_INFO_1> Buffer
        with Technologies.IDL.IDL{Size_is = [EntriesRead], IndirectionLevel = 1};
}

type DFS_INFO_2_CONTAINER
{
    DWORD EntriesRead;
    array<DFS_INFO_2> Buffer
        with Technologies.IDL.IDL{Size_is = [EntriesRead], IndirectionLevel = 1};
}

type DFS_INFO_3_CONTAINER
{
    DWORD EntriesRead;
    array<DFS_INFO_3> Buffer
        with Technologies.IDL.IDL{Size_is = [EntriesRead], IndirectionLevel = 1};
}

type DFS_INFO_4_CONTAINER
{
    DWORD EntriesRead;
    array<DFS_INFO_4> Buffer
        with Technologies.IDL.IDL{Size_is = [EntriesRead], IndirectionLevel = 1};
}

type DFS_INFO_5_CONTAINER
{
    DWORD EntriesRead;
    array<DFS_INFO_5> Buffer
        with Technologies.IDL.IDL{Size_is = [EntriesRead], IndirectionLevel = 1};
}

type DFS_INFO_6_CONTAINER
{
    DWORD EntriesRead;
    array<DFS_INFO_6> Buffer
        with Technologies.IDL.IDL{Size_is = [EntriesRead], IndirectionLevel = 1};
}

type DFS_INFO_8_CONTAINER
{
    DWORD EntriesRead;
    array<DFS_INFO_8> Buffer
        with Technologies.IDL.IDL{Size_is = [EntriesRead], IndirectionLevel = 1};
}

type DFS_INFO_9_CONTAINER
{
    DWORD EntriesRead;
    array<DFS_INFO_9> Buffer
        with Technologies.IDL.IDL{Size_is = [EntriesRead], IndirectionLevel = 1};
}

type DFS_INFO_200_CONTAINER
{
    DWORD EntriesRead;
    array<DFS_INFO_200> Buffer
        with Technologies.IDL.IDL{Size_is = [EntriesRead], IndirectionLevel = 1};
}

type DFS_INFO_200
{
    string FtDfsName
        with Technologies.IDL.IDL
                 {BaseStringType = TypeOf<WCHAR>(), IndirectionLevel = 1};
}

type DFS_INFO_300_CONTAINER
{
    DWORD EntriesRead;
    array<DFS_INFO_300> Buffer
        with Technologies.IDL.IDL{Size_is = [EntriesRead], IndirectionLevel = 1};
}

type DFS_INFO_300
{
    DWORD Flags;
    string DfsName
        with Technologies.IDL.IDL
                 {BaseStringType = TypeOf<WCHAR>(), IndirectionLevel = 1};
}

type DFSM_ROOT_LIST
{
    DWORD cEntries;
    array<DFSM_ROOT_LIST_ENTRY> Entry
        with Technologies.IDL.IDL{Size_is = [cEntries], Dimensions = [null]};
}

type DFSM_ROOT_LIST_ENTRY
{
    string ServerShare
        with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                  BaseStringType = TypeOf<WCHAR>(),
                                  IndirectionLevel = 1};
}

pattern DFS_NAMESPACE_VERSION_ORIGIN = enum 
{
    DFS_NAMESPACE_VERSION_ORIGIN_COMBINED = 0,
    DFS_NAMESPACE_VERSION_ORIGIN_SERVER = 1,
    DFS_NAMESPACE_VERSION_ORIGIN_DOMAIN = 2
};

type DFS_SUPPORTED_NAMESPACE_VERSION_INFO
{
    IDLUlong DomainDfsMajorVersion;
    IDLUlong DomainDfsMinorVersion;
    ULONGLONG DomainDfsCapabilities;
    IDLUlong StandaloneDfsMajorVersion;
    IDLUlong StandaloneDfsMinorVersion;
    ULONGLONG StandaloneDfsCapabilities;
}

// 3.1.4.1.2
pattern NetrDfsManagerGetVersion_ReturnValue = enum DWORD
{
    SupportStandalone       = 0x00000001,
    SupportDomainV1         = 0x00000002,
    SupportMultiNamespace   = 0x00000004,
    SupportDomainV2         = 0x00000006,
    ...
} with Technologies.IDL.IDL{DoNotGenerate = true};

// 3.1.4.1.3
pattern NetrDfsAdd_Flags = flags DWORD
{
    DFS_ADD_VOLUME = 0x00000001,
    DFS_RESTORE_VOLUME = 0x00000002,
    ...
} with Technologies.IDL.IDL{DoNotGenerate = true};

// 3.1.4.1.5
pattern NetrDfsSetInfo_Level = enum DWORD
{
    Level_100 = 0x00000064,
    Level_101 = 0x00000065,
    Level_102 = 0x00000066,
    Level_103 = 0x00000067,
    Level_104 = 0x00000068,
    Level_105 = 0x00000069,
    Level_106 = 0x0000006A,
    Level_107 = 0x0000006B,
    Level_150 = 0x00000096,
    ...
} with Technologies.IDL.IDL{DoNotGenerate = true};

// 3.1.4.1.6
pattern NetrDfsGetInfo_Level = enum DWORD
{
    Level_1 = 0x00000001,
    Level_2 = 0x00000002,
    Level_3 = 0x00000003,
    Level_4 = 0x00000004,
    Level_5 = 0x00000005,
    Level_6 = 0x00000006,
    Level_7 = 0x00000007,
    Level_8 = 0x00000008,
    Level_9 = 0x00000009,
    Level_50 = 0x00000032,
    Level_100 = 0x00000064,
    Level_150 = 0x00000096,
    ...
} with Technologies.IDL.IDL{DoNotGenerate = true};

// 3.1.4.1.7
pattern NetrDfsEnum_Level = enum DWORD
{
    Level_1 = 0x00000001,
    Level_2 = 0x00000002,
    Level_3 = 0x00000003,
    Level_4 = 0x00000004,
    Level_5 = 0x00000005,
    Level_6 = 0x00000006,
    Level_7 = 0x00000007,
    Level_8 = 0x00000008,
    Level_9 = 0x00000009,
    ...
} with Technologies.IDL.IDL{DoNotGenerate = true};

// 3.1.4.1.8
pattern NetrDfsMove_Flags = flags IDLUlong
{
    DFS_MOVE_FLAG_REPLACE_IF_EXISTS = 0x00000001,
    ...
} with Technologies.IDL.IDL{DoNotGenerate = true};

// 3.1.4.3.2
pattern NetrDfsRemoveFtRoot_ApiFlags = flags DWORD
{
    DFS_FORCE_REMOVE = 0x80000000,
    ...
} with Technologies.IDL.IDL{DoNotGenerate = true};

// 3.1.4.5.2
pattern NetrDfsSetDcAddress_Flags = flags DWORD
{
    NET_DFS_SETDC_TIMEOUT   = 0x00000001,
    NET_DFS_SETDC_INIT_PKT  = 0x00000002,
    ...
} with Technologies.IDL.IDL{DoNotGenerate = true};

// 3.1.4.2.1
pattern NetrDfsAdd2_Flags = flags DWORD
{
    DFS_ADD_VOLUME = 0x00000001,
    DFS_RESTORE_VOLUME = 0x00000002,
    ...
} with Technologies.IDL.IDL{DoNotGenerate = true};

// 3.1.4.1.7
pattern NetrDfsEnumEx_Level = enum DWORD
{
    Level_1     = 0x00000001,
    Level_2     = 0x00000002,
    Level_3     = 0x00000003,
    Level_4     = 0x00000004,
    Level_5     = 0x00000005,
    Level_6     = 0x00000006,
    Level_7     = 0x00000007,
    Level_8     = 0x00000008,
    Level_9     = 0x00000009,
    Level_200   = 0x000000C8,
    Level_300   = 0x0000012C,
    ...
} with Technologies.IDL.IDL{DoNotGenerate = true};

// 3.1.4.2.4
pattern NetrDfsSetInfo2_Level = enum DWORD
{
    Level_100 = 0x00000064,
    Level_101 = 0x00000065,
    Level_102 = 0x00000066,
    Level_103 = 0x00000067,
    Level_104 = 0x00000068,
    Level_105 = 0x00000069,
    Level_106 = 0x0000006A,
    Level_107 = 0x0000006B,
    Level_150 = 0x00000096,
    ...
} with Technologies.IDL.IDL{DoNotGenerate = true};

// 3.1.4.1.10
pattern NetrDfsRemoveRootTarget_Flags = flags DWORD
{
    DFS_FORCE_REMOVE = 0x80000000,
    ...
} with Technologies.IDL.IDL{DoNotGenerate = true};
