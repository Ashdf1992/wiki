protocol LDAP with
Asn1EncodingDefaults{EncodingRule = Asn1EncodingRule.BER},
// Future Reference: Enable it when the feature is ready
// Asn1ModuleEncoding {ExtensionDefault = Asn1Extensibility.Implied, TagDefault = Asn1Tagging.Implicit},
BinaryEncodingDefaults{Endian = Endian.Big, TextEncoding = TextEncoding.UTF8},
Documentation
{
    ProtocolName = "Lightweight Directory Access Protocol",
    ShortName = "LDAP",
    Description = ""
},
OPNAuthoring
{
    Copyright = "(c) Microsoft Corporation",
    References = 
    [
        new Reference{Name = "RFC 4511"},
        new Reference{Name = "RFC 2891"},
        new Reference{Name = "RFC 2696"},
        new Reference{Name = "RFC 2589"},
        new Reference{Name = "RFC 3352"},
    ],
    RevisionSummary =
    [
        new Revision{Class = RevisionClass.Major, Version = "381979", Date = "10/10/2015"},
    ]
};

using Standard;
using Technologies.ASN1;
using IANA;
using Utility;
using GSSAPI;
using GSSAPIKRB5;
using NLMP;
using Digest;
using TCP;
using DecodingUtility; // WORKAROUND: compiler bug#3131164, When type A inherit from type B, module C use tye A, and A, B, C is in different module file, compiler will give a compilation error
using CoreNetworkingResources;
using MicrosoftCommonResources;
using InfrastructureResources;
using Diagnostics;
using SASL;
using DTYP;
using Configurations;

endpoint Server over TCP.Server
    issues mutable LdapMessage accepts mutable LdapMessage
    provides VirtualOperations;

client endpoint Client connected to Server;

annotation string LdapMessage#KeyInformation;

const set<ushort> DefaultPorts = {IANA.Port.LDAP, IANA.Port.LDAPS};

autostart actor LdapSegOverTcp(TCP.Server server)
{
    LdapDecodingHelper ldapDecodingHelper;
    LdapConfiguration config = GetConfigurableValue<LdapConfiguration>();

    process server accepts seg:TCP.Segment where (seg.DestinationPort in DefaultPorts || seg.DestinationPort in config.LdapPorts || seg.DestinationPort in config.LdapsPorts)
    {
        if (ldapDecodingHelper == null)
        {
            ldapDecodingHelper = new LdapDecodingHelper();
            ldapDecodingHelper.InitializeLdapDecodingHelper(new LdapDecodingCache(), new LdapDecodingCache(), endpoint LDAP.Server over server);
        }
        ldapDecodingHelper.TryDecode(seg, MessageDirection.Accepts);
    }
    
    process server issues seg:TCP.Segment where (seg.SourcePort in DefaultPorts || seg.SourcePort in config.LdapPorts || seg.SourcePort in config.LdapsPorts)
    {
        if (ldapDecodingHelper == null)
        {
            ldapDecodingHelper = new LdapDecodingHelper();
            ldapDecodingHelper.InitializeLdapDecodingHelper(new LdapDecodingCache(), new LdapDecodingCache(), endpoint LDAP.Server over server);
        }
        ldapDecodingHelper.TryDecode(seg, MessageDirection.Issues);
    }
    
    // destructor
    ~endpoint(TCP.Server server)
    {
        if (ldapDecodingHelper != null)
        {
            ldapDecodingHelper.ClearInDestructor();
        }
    }
}

type LdapDecodingHelper : TCPDecodingHelper
{
    // share the decoding parameter between request cache and response cache
    LdapDecodingContext DecodingContext;
    
    void InitializeLdapDecodingHelper(LdapDecodingCache acceptsCache, LdapDecodingCache issuesCache, LDAP.Server server)
    {
        DecodingContext = new LdapDecodingContext();
        
        AcceptsCache = acceptsCache;
        acceptsCache.InitializeLdapDecodingCache(server, MessageDirection.Accepts, IsLDAPOrSasl,
            IsSufficientForSingleLdapOrSaslMsg, DecodingContext.DecodeLdapSingleMessage,
            DecodingContext.DecodeSaslSingleMessage,
            GetLdapMessageDirection);
        IssuesCache = issuesCache;
        issuesCache.InitializeLdapDecodingCache(server, MessageDirection.Issues, IsLDAPOrSasl,
            IsSufficientForSingleLdapOrSaslMsg, DecodingContext.DecodeLdapSingleMessage,
            DecodingContext.DecodeSaslSingleMessage,
            GetLdapMessageDirection);
    }
} with Encoding{EncodingKind = EncodingKind.Binary};

pattern SicilyType = enum byte
{
    SicilyPackageDiscovery = 0,
    SicilyNegotiate = 1,
    SicilyResponse = 2,
};

type LdapDecodingContext
{
    string authenticationMechanism = "";
    // bind request cache for decoding sicily bind response
    map<long, SicilyType> bindRequestCache = {};
    
    // decode one LDAP message
    optional any message DecodeLdapSingleMessage(stream s)
    {
        switch (s)
        {
            case ldap:LdapMessage from Asn1BerDecoder<LdapMessage[this.bindRequestCache]> =>
                switch (ldap.ProtocolOp)
                {
                    case op:SicilyPackageDiscoveryType =>
                        // add cache for bind request, for sicily request
                        this.bindRequestCache += {ldap.MessageID -> SicilyType.SicilyPackageDiscovery};
                        ldap#KeyInformation = op.GetKeyInformation();
                    case op:SicilyNegotiateType =>
                        // add cache for bind request, for sicily request
                        this.bindRequestCache += {ldap.MessageID -> SicilyType.SicilyNegotiate};
                        ldap#KeyInformation = op.GetKeyInformation();
                    case op:SicilyResponseType =>
                        // add cache for bind request, for sicily request
                        this.bindRequestCache += {ldap.MessageID -> SicilyType.SicilyResponse};
                        ldap#KeyInformation = op.GetKeyInformation();
                    case op:BindRequest =>
                        if (op.Authentication is saslCredentials:SaslCredentials)
                        {
                            this.authenticationMechanism = saslCredentials.Mechanism as string;
                        }
                        ldap#KeyInformation = op.GetKeyInformation();
                    case op:BindResponse =>
                        // clear cache
                        if (this.bindRequestCache.Keys[ldap.MessageID])
                        {
                            this.bindRequestCache = this.bindRequestCache.Remove(ldap.MessageID);
                        }
                    
                        // get the binary of the cred
                        binary credBinary = null;
                        RawGssApiWrapper rawGssApiWrapper = null;
                        if (op.ServerSaslCredsOctetString is binaryValue:binary && binaryValue.Count > 0)
                        {
                            credBinary = binaryValue;
                        }
                        else if (op.ServerSaslCredsOctetString is r:RawGssApiWrapper &&
                            r.Gss.TokenOctetString is tokenBin:binary && tokenBin.Count > 0)
                        {
                            rawGssApiWrapper = r;
                            credBinary = tokenBin;
                        }
                        
                        // decoding the cred from the binary
                        if (credBinary != null)
                        {
                            optional (GssapiType | NlmpMessage | Digest.DigestChallenge) cred = nothing;
                            if (op.ResultCode == ResultCode.Success)
                            {
                                cred = AuthenticationResponseDecoder(this.authenticationMechanism, credBinary, ldap);
                            }
                            else
                            {
                                cred = AuthenticationChallengesDecoder(this.authenticationMechanism, credBinary, ldap);
                            }
                            
                            // update Server SASL Creds
                            if (cred != nothing)
                            {
                                if (rawGssApiWrapper != null)
                                {
                                    rawGssApiWrapper.Gss.Token = cred;
                                    rawGssApiWrapper.Gss.TokenOctetString = nothing;
                                    op.ServerSaslCreds = rawGssApiWrapper.Gss;
                                    op.ServerSaslCredsOctetString = nothing;
                                }
                                else
                                {
                                    op.ServerSaslCreds = cred;
                                    op.ServerSaslCredsOctetString = nothing;
                                }
                            }
                        }
                    default =>
                        // do nothing
                }
                return ldap;
            default =>
                return nothing;
        }
    }
    
    // decode one SASL message
    // also return plain data binary and length of SASL mechanism used to decode wrapped LDAP messages
    optional SaslMessageResult DecodeSaslSingleMessage(stream s, bool isDecodeIncompleteMessage)
    {
        int startPosition = s.BytePosition;
        
        switch (s)
        {
            case sasl:SaslMessage from BinaryDecoder<SaslMessage[this.authenticationMechanism, isDecodeIncompleteMessage]> =>
                // set mechanism
                if (sasl#AuthMechanism == nothing || sasl#AuthMechanism == "")
                {
                    sasl#AuthMechanism = "Unknown";
                }
                else if (this.authenticationMechanism == null || this.authenticationMechanism.Count == 0)
                {
                    // update authentication mechanism
                    this.authenticationMechanism = sasl#AuthMechanism as string;
                }
                
                SaslMessageResult saslMessageResult = new SaslMessageResult
                {
                    SaslMessage = sasl,
                    PlainDataFromSasl = null,
                    SaslTotalLength = s.BytePosition - startPosition,
                };
                
                if (sasl#PlainDataFromSasl is plainDataFromSasl:binary)
                {
                    saslMessageResult.PlainDataFromSasl = plainDataFromSasl;
                    sasl#PlainDataFromSasl = nothing;
                }

                return saslMessageResult;
            default =>
                return nothing;
        }
    }
}

MessageDirection GetLdapMessageDirection(any message msg)
{
    // assert that it is always LDAP message
    LdapMessage ldapMessage = msg as LdapMessage;
    
    // decide the direction for LDAP message
    if (ldapMessage.ProtocolOp is SearchRequest || ldapMessage.ProtocolOp is AddRequest || ldapMessage.ProtocolOp is DelRequest || 
        ldapMessage.ProtocolOp is ModifyRequest || ldapMessage.ProtocolOp is ModifyDNRequest || ldapMessage.ProtocolOp is CompareRequest || 
        ldapMessage.ProtocolOp is AbandonRequest || ldapMessage.ProtocolOp is BindRequest || ldapMessage.ProtocolOp is UnbindRequest ||
        ldapMessage.ProtocolOp is ExtendedRequest)
    {
        return MessageDirection.Accepts;
    }
    return MessageDirection.Issues;
}

// Used in ADTS to check whether it is LDAP message
bool? IsLdap(binary binaryValue)
{
    // first tag starts with 0x3084/0x3082/0x3081, second tag is for MessageID, should start with 0x02, third tag is Application Tag, should start with value in range of all LDAP operation application ID 
    if (binaryValue.Count() <= 2)
    {
        return null;
    }
    
    if (binaryValue[0] == 0x30 && binaryValue[1] > 0)
    {
        int firstTagLen = (binaryValue[1] & 0x80) == 0x80 ? (binaryValue[1] & 0x7F) as byte : 0;
        if (firstTagLen < 0 || firstTagLen > 4) // it should be 0 ~ 4
        {
            return false;
        }

        // check message ID
        if (binaryValue.Count() <= 3 + firstTagLen)
        {
            return null;
        }
        
        if (binaryValue[2 + firstTagLen] == 2)
        {
            int opCodePosition = binaryValue[3 + firstTagLen] + 4 + firstTagLen;
            // check OpCode
            if (binaryValue.Count <= opCodePosition)
            {
                return null;
            }
            
            byte tagClass = (binaryValue[opCodePosition] >> 6) as byte;
            byte tagNumber = (binaryValue[opCodePosition] & 0x1F) as byte;
            return tagClass == Asn1TagClass.Application && tagNumber >= 0 && tagNumber <= 24;
        }
    }
    return false;
}

uint? IsSufficientForSingleLdapOrSaslMsg(binary binaryValue)
{
    if (binaryValue[0] == 0x30)
    {
        // LDAP
        if (CalculateAsn1BerLength(binaryValue) is ldapLength:uint)
        {
            return ldapLength <= binaryValue.Count ? 0 : ldapLength;
        }
        return null;
    }
    // SASL Message Decoding
    if (binaryValue.Count >= 4)
    {
        uint saslLength = PeekUInt(binaryValue, 0, Endian.Big) + 4;
        return saslLength <= binaryValue.Count ? 0 : saslLength;
    }
    else
    {
        return null;
    }
}

bool? IsLDAPOrSasl(binary binaryValue)
{
    if (binaryValue[0] == 0x30) // assume that when IsLDAPOrSasl invoked, buffer should contain data
    {
        return IsLdap(binaryValue);
    }
    return IsSASL(binaryValue);
}

// the function only used when checking it is whether SASL message
bool? IsSASL(binary binaryValue)
{
    if (binaryValue.Count < 16)
    {
        return null;
    }
    
    binary b = binaryValue.Segment(4, 12);
    int saslLength = (binaryValue[0] << 24) + (binaryValue[1] << 16) + (binaryValue[2] << 8) + binaryValue[3];
    if (saslLength < 0)
    {
        // assume that length of SASL message will not exceed 2G.
        return false;
    }
    
    return (IsGSSAPIByCheckingTag(b) && CalculateAsn1BerLength(b) is length:uint && length == saslLength) || /* check whether is GSSAPI */
        IsGssapiKrb(b, saslLength) || /* check whether is GSSAPI Kerberos */
        IsNLMP(b) || /* check whether is NLMP */
        IsNLMPSignature(b) || /* check whether is NLMP Sealed */
        (b[0] == 0x30 && IsLdap(b) == true); /* check whether is LDAP from 4th byte for DIGEST-MD5*/
}

message LdapMessage[map<long, SicilyType> BindRequestCache]
{
    MessageID MessageID;
    // if there is key for the sicily response, decoded as sicily response
    ([|BindRequestCache != null && BindRequestCache.Keys[MessageID]|] SicilyBindResponse[BindRequestCache[MessageID]] | ProtocolOperation) ProtocolOp;
    optional Controls Controls with Asn1Encoding{TagClass = Asn1TagClass.ContextSpecific, TagNumber = 0, Tagging = Asn1Tagging.Implicit};
    
    override string ToString()
    {
        // add text here because they inherits basic types
        string backUpText = "";
        switch (ProtocolOp)
        {
            case op:DelRequest =>
            {
                backUpText = "Del Request, Delete object: " + (op as string);
            }
            case op:SearchResultReference =>
            {
                backUpText = "Search Result Reference";
            }
            case op:AbandonRequest =>
            {
                backUpText = "Abandon Request";
            }
        }
        return "LDAP Message, " + ((backUpText.Count == 0 ? ProtocolOp.ToString() : backUpText) + ", MessageID: " + (MessageID as string));
    }
};
       
// ---------------------------
// virtual operations
// ---------------------------
contract VirtualOperations
{
    issues virtual operation LdapBindOperation
    {
        in MessageID MessageID = id;
        in ResultCode Result = result1 == nothing ? (result2 as ResultCode) : (result1 as ResultCode);
        in optional string KeyInformation = ki;
           
        override string ToString()
        {
            string summaryLine = "Bind Operation, MessageID:" + (MessageID as string) + ", Result:" + EnumToString(Result, "LDAP.ResultCode");
            if (KeyInformation is keyInformation:string)
            {
                summaryLine += ", " + keyInformation;
            }
            return summaryLine;
        }
    } 
    =
    accepts LdapMessage{MessageID is var id, ProtocolOp is BindRequest, #KeyInformation is var ki}
    issues LdapMessage{MessageID == id, ProtocolOp is BindResponse{ResultCode is var result1} || ProtocolOp is SicilyBindResponse{ResultCode is var result2}};
    
    issues virtual operation LdapAddOperation
    {
        in MessageID MessageID = id;
        in LdapDN Object = ob;
        in ResultCode ResultCode = result;
    
        override string ToString()
        {
            return "Add Operation, MessageID:" + (MessageID as string) + ", Result:" + EnumToString(ResultCode, "LDAP.ResultCode") + ", Add object:" + (Object as string);
        }
    } 
    =
    accepts LdapMessage{MessageID is var id, ProtocolOp is AddRequest, (ProtocolOp as AddRequest).Entry is var ob}
    issues LdapMessage{MessageID == id, ProtocolOp is AddResponse, (ProtocolOp as AddResponse).ResultCode is var result};
    
    issues virtual operation LdapExtendedOperation
    {
        in MessageID MessageID = id;
        in LDAPOID Request = oid;
        in ResultCode ResultCode = result;
    
        override string ToString()
        {
            return "Extended Operation, MessageID:" + (MessageID as string) +
                ", Result:" + EnumToString(ResultCode, "LDAP.ResultCode") + ", Request:" + (Request as string);
        }
    } 
    =
    accepts LdapMessage{MessageID is var id, ProtocolOp is ExtendedRequest, (ProtocolOp as ExtendedRequest).RequestName is var oid}
    issues LdapMessage{MessageID == id, ProtocolOp is ExtendedResponse, (ProtocolOp as ExtendedResponse).ResultCode is var result};
    
    issues virtual operation LdapCompareOperation
    {
        in MessageID MessageID = id;
        in LdapDN Object = ob;
        in ResultCode ResultCode = result;
        
        override string ToString()
        {
            return "Compare Operation, MessageID:" + (MessageID as string) +
                ", Result:" + EnumToString(ResultCode, "LDAP.ResultCode") + ", Compare object:" + (Object as string);
        }
    } 
    =
    accepts LdapMessage{MessageID is var id, ProtocolOp is CompareRequest, (ProtocolOp as CompareRequest).Entry is var ob}
    issues LdapMessage{MessageID == id, ProtocolOp is CompareResponse, (ProtocolOp as CompareResponse).ResultCode is var result};

    issues virtual operation LdapDelOperation
    {
        in MessageID MessageID = id;
        in LdapDN Object = ob;
        in ResultCode ResultCode = result;
        
        override string ToString()
        {
            return "Del Operation, MessageID:" + (MessageID as string) +
                ", Result:" + EnumToString(ResultCode, "LDAP.ResultCode") + ", Delete object:" + (Object as string);
        }
    } 
    =
    accepts LdapMessage{MessageID is var id, ProtocolOp is DelRequest, (ProtocolOp as DelRequest) is var ob}
    issues LdapMessage{MessageID == id, ProtocolOp is DelResponse, (ProtocolOp as DelResponse).ResultCode is var result};
    
    issues virtual operation LdapModifyOperation
    {
        in MessageID MessageID = id;
        in LdapDN Object = ob;
        in ResultCode ResultCode = result;
        
        override string ToString()
        {
            return "Modify Operation, MessageID:" + (MessageID as string) +
                ", Result:" + EnumToString(ResultCode, "LDAP.ResultCode") + ", Modify object:" + (Object as string);
        }
    } 
    =
    accepts LdapMessage{MessageID is var id, ProtocolOp is ModifyRequest, (ProtocolOp as ModifyRequest).Object is var ob}
    issues LdapMessage{MessageID == id, ProtocolOp is ModifyResponse, (ProtocolOp as ModifyResponse).ResultCode is var result};

    issues virtual operation LdapModifyDNOperation
    {
        in MessageID MessageID = id;
        in LdapDN OldDN = old;
        in bool DelOld = delOld;
        in ResultCode ResultCode = result;
        
        override string ToString()
        {
            return "ModifyDN Operation, MessageID:" + (MessageID as string) + ", Result:" + EnumToString(ResultCode, "LDAP.ResultCode") + ", Move object:" + (OldDN as string);
        }
    } 
    =
    accepts LdapMessage{MessageID is var id, ProtocolOp is ModifyDNRequest, (ProtocolOp as ModifyDNRequest).Entry is var old, (ProtocolOp as ModifyDNRequest).Deleteoldrdn is var delOld}
    issues LdapMessage{MessageID == id, ProtocolOp is ModifyDNResponse, (ProtocolOp as ModifyDNResponse).ResultCode is var result};
        
    issues virtual operation LdapSearchOperation
    {
        in MessageID MessageID = id;
        in LdapDN BaseObject = ob;
        out PartialAttributeList Attributes = attributeList;
    
        override string ToString()
        {
            string ret = "Search Operation, MessageID:" + (MessageID as string);
            if (BaseObject == "")
            {
                ret += ", Search For RootDSE";
                foreach (var item in Attributes)
                {
                    switch (item.Type.ToString())
                    {
                        case "serverName" =>
                            ret += ", serverName: " + item.ValsToString();
                        case "dnsHostName" => 
                            ret += ", dnsHostName: " + item.ValsToString();
                    }
                }
            }
            else
            {
                ret += ", Search On BaseObject:" + (BaseObject as string);
            }
            return ret;
        }
    } = SearchScenario[out var id, out var ob, out var attributeList];
}

scenario SearchScenario[out MessageID id, out LdapDN ob, out PartialAttributeList attributeList]
=
accepts LdapMessage{MessageID is id, ProtocolOp is SearchRequest, (ProtocolOp as SearchRequest).BaseObject is ob}
(
issues LdapMessage
{
    MessageID == id, ProtocolOp is SearchResultEntry
    {
        // WORKAROUND: PEF Bug #3585309. The code should be simpled as below.
        // (attributeList == null ? Attributes : (Attributes + attributeList)) is var attributeList
        (attributeList == null ? Attributes : (Attributes + attributeList)) is var attributeList1 &&
        attributeList1 is attributeList
    }
    || ProtocolOp is SearchResultReference
}
) *
issues LdapMessage{MessageID == id, ProtocolOp is SearchResultDone};

// Types and patterns
pattern ProtocolOperation = [|MatchAuthenticationTagNumber(stream, 9)|] SicilyPackageDiscoveryType
| [|MatchAuthenticationTagNumber(stream, 10)|] SicilyNegotiateType
| [|MatchAuthenticationTagNumber(stream, 11)|] SicilyResponseType
| BindRequest
| BindResponse
| UnbindRequest
| SearchRequest
| SearchResultEntry
| SearchResultDone
| SearchResultReference
| ModifyRequest
| ModifyResponse
| AddRequest
| AddResponse
| DelRequest
| DelResponse
| ModifyDNRequest
| ModifyDNResponse
| CompareRequest
| CompareResponse
| AbandonRequest
| ExtendedRequest
| ExtendedResponse;

pattern MessageID = Integer with Asn1Encoding {LowerEndValue = 0, UpperEndValue = maxInt};

const long maxInt = 2147483647; // -- (2^^31 - 1) --

pattern LdapString = OctetString with Asn1Encoding{Flags = Asn1EncodingFlags.OctetStringIsString, Encoding = TextEncoding.UTF8};

pattern LDAPOID = OctetString with Asn1Encoding{Flags = Asn1EncodingFlags.OctetStringIsString};

pattern LdapDN = LdapString;

pattern RelativeLdapDN = LdapString;

pattern AttributeDescription = LdapString;

pattern AttributeValue = OctetString with DisplayInfo{ToText = DecodeOctetStringAsUTF8};

string DecodeOctetStringAsUTF8(any a)
{
    assert a is binary;
    var s = BinaryDecoder<UTF8StringWrapper>(a as binary);
    return s is nothing ? a.ToString() : (s as UTF8StringWrapper).Text;
}
 
type UTF8StringWrapper
{
    string Text;
} with BinaryEncodingDefaults{TextEncoding = TextEncoding.UTF8};

type AttributeValueAssertion[int Tag]
{
    AttributeDescription AttributeDesc;
    // WORKAROUND: The mix-encoding aspect should declare on AssertionValue
    // However, so far, OPN Language does not support declar Mix-Encoding on pattern and
    // and also does not support pass parameter through pattern
    (string | guid | uint | OctetString) AssertionValue
        with Encoding{Decoder = (x) => AssertionValueDecoder(AttributeDesc, x), SourcePattern = TypeOf<OctetString>()},
        DisplayInfo{ToText = (x) => AssertionValueToText(AttributeDesc, x)};
    
    override string ToString()
    {
        string op = "";
        switch (Tag)
        {
            case 3 =>
            op = " == ";
            case 5 =>
            op = " >= ";
            case 6 =>
            op = " <= ";
            case 8 =>
            op = " ~= ";
        }
        return AttributeDesc.ToString() + op + AssertionValueToText(AttributeDesc, AssertionValue);
    }
};

pattern AssertionValue = LdapString;

/*
 * ADTS Section 6.3.3
 *
 * ADTS The LDAP search filter included in the SearchRequest is a one-level AND of equalityMatch tests of the following elements:
 * DnsDomain: The DNS name of an NC (default NC or application NC).
 * Host: The NetBIOS name of the client.
 * DnsHostName: The fully qualified domain name (FQDN) of the client.
 * Note  The DnsHostName element is not sent by Windows clients from Windows 2000 operating system through Windows 7 operating system and Windows Server 2008 R2 operating system. 
 * User: The sAMAccountName of an account in the domain specified by DnsDomain, DomainSid, or DomainGuid.
 * AAC: Represents the userAccountControl attribute of an account.
 * DomainSid: The SID of a domain.
 * DomainGuid: The GUID of a domain.
 * NtVer: NETLOGON_NT_VERSION Options (see section 6.3.1.1).
 */
optional (string | guid | uint | OctetString) AssertionValueDecoder(AttributeDescription attributeDesc, OctetString assertionValue)
{
    if (assertionValue is bin:binary)
    {
        if (attributeDesc == "AAC" || attributeDesc == "NtVer")
        {
            return BinaryPrimitiveTypeDecoder<uint>(bin, Endian.Big);
        }
        else if (attributeDesc == "SID")
        {
            return BinaryDecoder<SID>(bin);
        }
        else if (attributeDesc == "DomainGuid")
        {
            return BinaryDecoder<guid>(bin);
        }

        // try decode as guid
        if (bin.Count == 16)
        {
            var ret = BinaryDecoder<guid>(bin);
            if (ret is g:guid)
            {
                return g;
            }
        }

        // try decode as UTF-8
        if (BinaryStringDecoder(bin, TextEncoding.UTF8) is utf8String:string)
        {
            return utf8String;
        }
    }
    return assertionValue;
}

// WORKAROUND: Since PEF runtime cannot display the meaningful value defined by enum/flag pattern
// if the type of field is or pattern, for example UserAccountControl | NetLogonNtVersion,
// OPN should code manually to display the meaningful value.
string AssertionValueToText(AttributeDescription attributeDesc, any input)
{
    if (input is number:uint)
    {
        if (attributeDesc == "AAC")
        {
            return EnumToString<UserAccountControl>(number, true, "{0:X8}");
        }
        else if (attributeDesc == "NtVer")
        {
            return EnumToString<NetLogonNtVersion>(number, true, "{0:X8}");
        }
    }

    return input.ToString();
}

// MS-ADTS 6.3.1.1
pattern NetLogonNtVersion = flags uint
{
    VGC     = 0x80000000,
    VL      = 0x40000000,
    VIP     = 0x20000000,
    VPDC    = 0x10000000,
    VNT4    = 0x01000000,
    VCS     = 0x00000010,
    V5EP    = 0x00000008,
    V5EX    = 0x00000004,
    V5      = 0x00000002,
    V1      = 0x00000001,
    ...
};

// MS-ADTS 2.2.16
pattern UserAccountControl = flags uint
{
    PS      = 0x04000000,
    NA      = 0x02000000,
    TA      = 0x01000000,
    PE      = 0x00800000,
    DR      = 0x00400000,
    DK      = 0x00200000,
    ND      = 0x00100000,
    TD      = 0x00080000,
    SR      = 0x00040000,
    DP      = 0x00010000,
    ST      = 0x00002000,
    WT      = 0x00001000,
    ID      = 0x00000800,
    N       = 0x00000200,
    ET      = 0x00000080,
    CC      = 0x00000040,
    NR      = 0x00000020,
    L       = 0x00000010,
    HR      = 0x00000008,
    D       = 0x00000002,
    ...
};

type PartialAttribute
{
    AttributeDescription Type;
    array<AttributeValue> Vals;

    override string ToString()
    {
        if (Vals.Count == 0)
        {
            return Type.ToString();
        }
        else
        {
            return Type.ToString() + ": " + ValsToString();
        }
    }

    string ValsToString()
    {
        if (Vals.Count == 0)
        {
            return "";
        }
        if (Vals.Count == 1)
        {
            return DecodeOctetStringAsUTF8(Vals[0]);
        }
        string summaryLine = DecodeOctetStringAsUTF8(Vals[0]);
        for (int i = 1; i < Vals.Count; i++)
        {
            summaryLine += ", " + DecodeOctetStringAsUTF8(Vals[i]);
        }
        return "[" + summaryLine + "]";
    }
}

pattern Attribute = PartialAttribute;

pattern MatchingRuleId = LdapString;

// WORKAROUND: codec always display LdapResult.ToString() even if child type/pattern has its own ToString/DisplayInfo implemented
type LdapResult[int Tag]
{
    ResultCode ResultCode where ErrorCodeIf(value in {1, 2}, null, value == 1 ? LDAP_Operation_Error : LDAP_Protocol_Error);
    LdapDN MatchedDN;
    LdapString DiagnosticMessage;
    optional Referral Referral with Asn1Encoding{TagClass = Asn1TagClass.ContextSpecific, TagNumber = 3, Tagging = Asn1Tagging.Implicit};
    
    override string ToString()
    {
        string ret = "";
        switch (Tag)
        {
            case 5 =>
                ret = "Search Result Done";
            case 7 =>
                ret = "Modify Response";
            case 9 =>
                ret = "Add Response";
            case 11 =>
                ret = "Del Response";
            case 13 =>
                ret = "ModifyDN Response";
            case 15 =>
                ret = "Compare Response";
        }
        return ret;
    }
}

pattern ResultCode = enum Integer
{
    Success                       = 0,
    OperationsError               = 1,
    ProtocolError                 = 2,
    TimeLimitExceeded             = 3,
    SizeLimitExceeded             = 4,
    CompareFalse                  = 5,
    CompareTrue                   = 6,
    AuthMethodNotSupported        = 7,
    Reserved                      = 9,
    StrongerAuthRequired          = 8,
    Referral                      = 10,
    AdminLimitExceeded            = 11,
    UnavailableCriticalExtension  = 12,
    ConfidentialityRequired       = 13,
    SaslBindInProgress            = 14,
    NoSuchAttribute               = 16,
    UndefinedAttributeType        = 17,
    InappropriateMatching         = 18,
    ConstraintViolation           = 19,
    AttributeOrValueExists        = 20,
    InvalidAttributeSyntax        = 21,
    NoSuchObject                  = 32,
    AliasProblem                  = 33,
    InvalidDNSyntax               = 34,
    ReservedForUndefinedIsLeaf    = 35,
    AliasDereferencingProblem     = 36,
    InappropriateAuthentication   = 48,
    InvalidCredentials            = 49,
    InsufficientAccessRights      = 50,
    Busy                          = 51,
    Unavailable                   = 52,
    UnwillingToPerform            = 53,
    LoopDetect                    = 54,
    NamingViolation               = 64,
    ObjectClassViolation          = 65,
    NotAllowedOnNonLeaf           = 66,
    NotAllowedOnRDN               = 67,
    EntryAlreadyExists            = 68,
    ObjectClassModsProhibited     = 69,
    ReservedForCldap              = 70,
    AffectsMultipleDSAs           = 71,
    Other                         = 80,
};

pattern Referral = array<Uri> where (value.Count >= 1);

pattern Uri = LdapString;

pattern Controls = array<Control>;

type Control
{
    LDAPOID ControlType;
    optional Boolean Criticality;
    optional (OctetString | any) ControlValue;
}

type BindRequest
{
    Integer Version where (value >= 1 && value <= 127);
    LdapDN Name;
    AuthenticationChoice Authentication;
    
    override string ToString()
    {
        string summaryLine = "Bind Request, Version:" + Version.ToString();

        if (GetKeyInformation() is keyInformation:string)
        {
            summaryLine += ", " + keyInformation;
        }

        return summaryLine;
    }

    virtual optional string GetKeyInformation()
    {
        if (Authentication is simple:string)
        {
            return "Simple";
        }
        else if (Authentication is saslCredentials:SaslCredentials &&
            saslCredentials.GetKeyInformation() is keyInfo:string)
        {
            return keyInfo;
        }
        return nothing;
    }
}
with Asn1Encoding
{
    TagClass = Asn1TagClass.Application,
    TagNumber = 0,
    Tagging = Asn1Tagging.Implicit
};

// Type is extensible 3.7.  LDAP Authentication Method
// According to RFC 4511, authentication supports Simple and SASL
// MS-ADTS section 5.1.1.1 extend it to Sicily Authentication
type SicilyPackageDiscoveryType : BindRequest
{
    new (NlmpMessage | OctetString) Authentication
        with Encoding{Decoder = AuthenticationDecoder, SourcePattern = TypeOf<SicilyPackageDiscovery>()};

    override string ToString()
    {
        return "Sicily Package Discovery, Version:" + Version.ToString();
    }

    override optional string GetKeyInformation()
    {
        if (Authentication is nlmpMessage:NlmpMessage)
        {
            return GetSummaryInfo(nlmpMessage);
        }
        else
        {
            return nothing;
        }
    }
};

type SicilyNegotiateType : BindRequest
{
    new (NlmpMessage | OctetString) Authentication
        with Encoding{Decoder = AuthenticationDecoder, SourcePattern = TypeOf<SicilyNegotiate>()};

    override string ToString()
    {
        return "Sicily Negotiate, Version:" + Version.ToString();
    }

    override optional string GetKeyInformation()
    {
        if (Authentication is nlmpMessage:NlmpMessage)
        {
            return GetSummaryInfo(nlmpMessage);
        }
        else
        {
            return nothing;
        }
    }
};

type SicilyResponseType : BindRequest
{
    new (NlmpMessage | OctetString) Authentication
        with Encoding{Decoder = AuthenticationDecoder, SourcePattern = TypeOf<SicilyResponse>()};

    override string ToString()
    {
        return "Sicily Response, Version:" + Version.ToString();
    }

    override optional string GetKeyInformation()
    {
        if (Authentication is nlmpMessage:NlmpMessage)
        {
            return GetSummaryInfo(nlmpMessage);
        }
        else
        {
            return nothing;
        }
    }
}

pattern AuthenticationChoice = Simple | Sasl;

// Ldap defines several bind request type in authentication. And to identify the type of 
// bind request, LDAP.opn should look ahead the authentication tag before decoding.
// This function is called in ProtocolOperation Pattern Look-ahead. ANS1 codec call this
// function after decoding ProtocolOperation tag but before decoding length.
bool MatchAuthenticationTagNumber(stream s, byte authenticationTagNumber)
{
    // check ProtocolOp tag number should be 0
    if (s.BitPosition <= 8 || (s.PeekByte(s.BitPosition - 8) & 0x1F) != 0)
    {
        return false;
    }

    if (s.RemainingByteLength() <= 2)
    {
        return false;
    }
    int currentPosition = 0;
    // skip tag and length of field ProtocolOp
    byte lengthOfLength = s.PeekByte(currentPosition + s.BitPosition);
    currentPosition += 8;
    if ((lengthOfLength & 0x80) == 0x80)
    {
        currentPosition += (lengthOfLength & 0x7F) * 8;
    }

    // Skip field Version
    if (CalculateAsn1BerLength(s, currentPosition) is versionLength:uint)
    {
        currentPosition += ((versionLength << 3) as int);
    }
    else
    {
        return false;
    }

    // Skip field Name
    if (CalculateAsn1BerLength(s, currentPosition) is nameLength:uint)
    {
        currentPosition += ((nameLength << 3) as int);
    }
    else
    {
        return false;
    }

    // check tag number for Authentication
    return (s.PeekByte(s.BitPosition + currentPosition) & 0x1F) == authenticationTagNumber;
}

optional (NlmpMessage | OctetString) AuthenticationDecoder(OctetString authenticationBinary)
{
    if (authenticationBinary is bin:binary && IsNLMP(bin))
    {
        // try decode as Sicily Authentication.
        // according MS-ATDS section 5.1.1.1.3, current Windows only implement Sicily Authentication with NLMP
        if (NlmpDecoder(bin) is nlmpMessage:NlmpMessage)
        {
            return nlmpMessage;
        }
    }
    
    return authenticationBinary;
}

// According below statements in RFC 4511 section 4.2, declare Simple Authentication as LDAPString
// Textual passwords (consisting of a character sequence with a known
// character set and encoding) transferred to the server using the
// simple AuthenticationChoice SHALL be transferred as UTF-8 [RFC3629]
pattern Simple = LdapString with Asn1Encoding 
{
    TagClass = Asn1TagClass.ContextSpecific,
    TagNumber = 0,
    Tagging = Asn1Tagging.Implicit
};

pattern Sasl = SaslCredentials with Asn1Encoding
{
    TagClass = Asn1TagClass.ContextSpecific,
    TagNumber = 3,
    Tagging = Asn1Tagging.Implicit
};

// Remove start--------->
// Future Reference: Remove the following code.
// There's extended in MS-ADTS 5.1.1.1. Detailed implement will be placed at ADTS.opn
//
pattern SicilyPackageDiscovery = OctetString with Asn1Encoding
{
    TagClass = Asn1TagClass.ContextSpecific,
    TagNumber = 9,
    Tagging = Asn1Tagging.Implicit
};
    
pattern SicilyNegotiate = OctetString with Asn1Encoding
{
    TagClass = Asn1TagClass.ContextSpecific,
    TagNumber = 10,
    Tagging = Asn1Tagging.Implicit
};
    
pattern SicilyResponse = OctetString with Asn1Encoding
{
    TagClass = Asn1TagClass.ContextSpecific,
    TagNumber = 11,
    Tagging = Asn1Tagging.Implicit
};

type SaslCredentials
{
    LdapString Mechanism;
    // Would detail of authentication protocols for MS implement: http://msdn.microsoft.com/en-us/library/cc223498(v=prot.10).aspx
    optional (Digest.DigestResponse | GssapiType | NlmpMessage | OctetString) Credentials with Encoding{Decoder = SaslCredentialsDecoder, SourcePattern = TypeOf<OctetString>()};

    optional (Digest.DigestResponse | GssapiType | NlmpMessage | OctetString) SaslCredentialsDecoder(OctetString buffer)
    {
        var cred = AuthenticationRequestDecoder(Mechanism.ToString(), buffer as binary);
        if (cred == nothing)
        {
            return buffer;
        }
        return cred;
    }

    optional string GetKeyInformation()
    {
        if (Credentials is digestResponse:Digest.DigestResponse)
        {
            return digestResponse.GetSummaryInfo();
        }
        else if (Credentials is gssapiType:GssapiType)
        {
            return gssapiType#KeyInformation;
        }
        else if (Credentials is nlmpMessage:NlmpMessage)
        {
            return GetSummaryInfo(nlmpMessage);
        }
        else if (Mechanism.ToString().Count > 0)
        {
            return Mechanism.ToString();
        }
        else
        {
            return nothing;
        }
    }
}

type BindResponse
{
    // Components of LDAPResult
    ResultCode ResultCode where ErrorCodeIf(value in {1, 2}, null, value == 1 ? LDAP_Operation_Error : LDAP_Protocol_Error);
    LdapDN MatchedDN;
    LdapString DiagnosticMessage;
    optional Referral Referral with Asn1Encoding{TagClass = Asn1TagClass.ContextSpecific, TagNumber = 3, Tagging = Asn1Tagging.Implicit};

    // use "optional (OctetString | any) ServerSaslCreds" will cause decode fail,
    // so add ServerSaslCredsValue field.
    // WORKAROUND: PEF bug, it should be (OctetString | RawGssApiWrapper), however ANS1 codec will throw exception.
    // The expected behavior is return nothing;
    optional OctetString ServerSaslCredsOctetString with Asn1Encoding{TagClass = Asn1TagClass.ContextSpecific, TagNumber = 7, Tagging = Asn1Tagging.Implicit};
    optional (GssapiType | NlmpMessage | RawGssApi | Digest.DigestChallenge | Digest.ResponseAuth) ServerSaslCreds with Encoding{Ignore = true};
    
    override string ToString()
    {
        string summaryLine = "Bind Response, Result:" + EnumToString(ResultCode, "LDAP.ResultCode");
        if (GetKeyInformation() is keyInfo:string)
        {
            return summaryLine + ", " + keyInfo;
        }
        else
        {
            return summaryLine;
        }
    }

    optional string GetKeyInformation()
    {
        if (ServerSaslCreds is digestChallenge:Digest.DigestChallenge)
        {
            return digestChallenge.GetSummaryInfo();
        }
        else if (ServerSaslCreds is responseAuth:Digest.ResponseAuth)
        {
            return responseAuth.GetSummaryInfo();
        }
        else if (ServerSaslCreds is gssapiType:GssapiType)
        {
            return gssapiType#KeyInformation;
        }
        else if (ServerSaslCreds is nlmpMessage:NlmpMessage)
        {
            return GetSummaryInfo(nlmpMessage);
        }
        else if (ServerSaslCreds is rawGssApi:RawGssApi)
        {
            return rawGssApi.GetSummaryInfo();
        }
        else
        {
            return nothing;
        }
    }
} with Asn1Encoding{TagClass = Asn1TagClass.Application, TagNumber = 1, Tagging = Asn1Tagging.Implicit};

// MS-ADTS section 5.1.1.1.3
type SicilyBindResponse[SicilyType SicilyRequestType]
{
    // Components of LDAPResult
    ResultCode ResultCode where ErrorCodeIf(value in {1, 2}, null, value == 1 ? LDAP_Operation_Error : LDAP_Protocol_Error);
    (NlmpMessage | string | OctetString) ServerCreds with Encoding{Decoder = ServerCredsDecoder, SourcePattern = TypeOf<OctetString>()};
    LdapString ErrorMessage;
    
    override string ToString()
    {
        return "Sicily Bind Response, Result:" + EnumToString(ResultCode, "LDAP.ResultCode");
    }
    
    optional (NlmpMessage | string | OctetString) ServerCredsDecoder(OctetString buffer)
    {
        if (buffer is bin:binary)
        {
            switch (SicilyRequestType)
            {
                case SicilyType.SicilyPackageDiscovery =>
                    /*
                     * If the sicilyPackageDiscovery request is successful, returns a string in serverCreds consisting 
                     * of the semicolon-separated names of the authentication (2) protocols it supports via the Sicily
                     * authentication (2) mechanism. 
                    */
                    if (BinaryStringDecoder(bin, TextEncoding.ASCII) is authenticationMechanism:string)
                    {
                        return authenticationMechanism;
                    }
                case SicilyType.SicilyNegotiate | SicilyType.SicilyResponse =>
                    if (IsNLMP(bin) && NlmpDecoder(bin) is nlmpMessage:NlmpMessage)
                    {
                        return nlmpMessage;
                    }
            }
        }
        return buffer;
    }
} with Asn1Encoding{TagClass = Asn1TagClass.Application, TagNumber = 1, Tagging = Asn1Tagging.Implicit};

type UnbindRequest
{
    override string ToString()
    {
        return "Unbind Request";
    }
} with Asn1Encoding{TagClass = Asn1TagClass.Application, TagNumber = 2, Tagging = Asn1Tagging.Implicit};

type SearchRequest
{
    LdapDN BaseObject;
    Scope Scope;
    DerefAliases DerefAliases;
    Integer SizeLimit;
    Integer TimeLimit;
    Boolean TypesOnly;
    Filter Filter;
    AttributeSelection Attributes;
    
    override string ToString()
    {
        return "Search Request, " + (BaseObject == "" ? "Search For RootDSE" : "baseObject:" + BaseObject.ToString());
    }
} with Asn1Encoding{TagClass = Asn1TagClass.Application, TagNumber = 3, Tagging = Asn1Tagging.Implicit};

pattern Scope = enum Integer
{
    BaseObject                      = 0,
    SingleLevel                     = 1,
    WholeSubtree                    = 2,
};

pattern DerefAliases = enum Integer
{
    NeverDerefAliases               = 0,
    DerefInSearching                = 1,
    DerefFindingBaseObj             = 2,
    DerefAlways                     = 3, 
};

pattern AttributeSelection = array<LdapString>;

/*
        Filter ::= CHOICE {
                and             [0] SET OF Filter,
                or              [1] SET OF Filter,
                not             [2] Filter,
                equalityMatch   [3] AttributeValueAssertion,
                substrings      [4] SubstringFilter,
                greaterOrEqual  [5] AttributeValueAssertion,
                lessOrEqual     [6] AttributeValueAssertion,
                present         [7] AttributeDescription,
                approxMatch     [8] AttributeValueAssertion,
                extensibleMatch [9] MatchingRuleAssertion }
*/
// Note: Although Filter is declared as CHOICE in ASN.1 syntax, we need to declare it as type since
// ASN.1 BER codec only generate decode function for type, not for pattern.
type Filter
{
    (And
    | Or
    | Not
    | EqualityMatch
    | Substrings
    | GreaterOrEqual
    | LessOrEqual
    | Present
    | ApproxMatch
    | ExtensibleMatch) Content;
    
    override string ToString()
    {
        if (Content is Present)
        {
            return "(" + Content.ToString() + " Present)";
        }
        return "(" + Content.ToString() + ")";
    }
} with Asn1Encoding{Flags = Asn1EncodingFlags.TagLengthSkipped};

// Note: Declared And, Or and Not as type to be able to override their ToString() function
type And
{
    array<Filter> Content;
    
    override string ToString()
    {
        string str;
        bool isFirst = true;
        foreach (var filter in Content)
        {
            if (isFirst)
            {
                isFirst = false;
                str = filter.ToString();
            }
            else
            {
                str += " && " + filter.ToString();
            }
        }
        return str;
    }
} with Asn1Encoding
{
    TagClass = Asn1TagClass.ContextSpecific,
    TagNumber = 0,
    Flags = Asn1EncodingFlags.TagLengthSkipped,
    Tagging = Asn1Tagging.Implicit
};

type Or
{
    array<Filter> Content;
    
    override string ToString()
    {
        string str;
        bool isFirst = true;
        foreach (var filter in Content)
        {
            if (isFirst)
            {
                isFirst = false;
                str = filter.ToString();
            }
            else
            {
                str += " || " + filter.ToString();
            }
        }
        return str;
    }
} with Asn1Encoding
{
    TagClass = Asn1TagClass.ContextSpecific,
    TagNumber = 1,
    Flags = Asn1EncodingFlags.TagLengthSkipped,
    Tagging = Asn1Tagging.Implicit
};

// Note: Shouldn't use Asn1EncodingFlags.TagLengthSkipped aspect on Not since
// that will cause stack overflow exception
type Not
{
    Filter Content;
    
    override string ToString()
    {
        return "! " + Content.ToString();
    }
} with Asn1Encoding{TagClass = Asn1TagClass.ContextSpecific, TagNumber = 2, Tagging = Asn1Tagging.Implicit};

pattern EqualityMatch = AttributeValueAssertion[3] with Asn1Encoding{TagClass = Asn1TagClass.ContextSpecific, TagNumber = 3, Tagging = Asn1Tagging.Implicit};

pattern Substrings = SubstringFilter with Asn1Encoding{TagClass = Asn1TagClass.ContextSpecific, TagNumber = 4, Tagging = Asn1Tagging.Implicit};

pattern GreaterOrEqual = AttributeValueAssertion[5] with Asn1Encoding{TagClass = Asn1TagClass.ContextSpecific, TagNumber = 5, Tagging = Asn1Tagging.Implicit};

pattern LessOrEqual = AttributeValueAssertion[6] with Asn1Encoding{TagClass = Asn1TagClass.ContextSpecific, TagNumber = 6, Tagging = Asn1Tagging.Implicit};

pattern Present = AttributeDescription with Asn1Encoding{TagClass = Asn1TagClass.ContextSpecific, TagNumber = 7, Tagging = Asn1Tagging.Implicit};

pattern ApproxMatch = AttributeValueAssertion[8] with Asn1Encoding{TagClass = Asn1TagClass.ContextSpecific, TagNumber = 8, Tagging = Asn1Tagging.Implicit};

pattern ExtensibleMatch = MatchingRuleAssertion with Asn1Encoding{TagClass = Asn1TagClass.ContextSpecific, TagNumber = 9, Tagging = Asn1Tagging.Implicit};

type SubstringFilter
{
    AttributeDescription Type;
    array<SubString> SubStrings where value.Count >= 1;
}

pattern SubString = Initial | Any | Final;

pattern Initial = AssertionValue with Asn1Encoding
{
    TagClass = Asn1TagClass.ContextSpecific,
    TagNumber = 0,
    Tagging = Asn1Tagging.Implicit
};

pattern Any = AssertionValue with Asn1Encoding
{
    TagClass = Asn1TagClass.ContextSpecific,
    TagNumber = 1,
    Tagging = Asn1Tagging.Implicit
};

pattern Final = AssertionValue with Asn1Encoding
{
    TagClass = Asn1TagClass.ContextSpecific,
    TagNumber = 2,
    Tagging = Asn1Tagging.Implicit
};

type MatchingRuleAssertion
{
    optional MatchingRuleId MatchingRule with Asn1Encoding {TagNumber = 1, Tagging = Asn1Tagging.Implicit};
    optional AttributeDescription Type with Asn1Encoding {TagNumber = 2, Tagging = Asn1Tagging.Implicit};
    // WORKAROUND: The mix-encoding aspect should declare on AssertionValue
    // However, so far, OPN Language does not support declar Mix-Encoding on pattern and
    // and also does not support pass parameter through pattern
    (string | guid | uint | OctetString) MatchValue 
        with Asn1Encoding {TagNumber = 3, Tagging = Asn1Tagging.Implicit},
        Encoding{Decoder = (x) => AssertionValueDecoder(Type is attributeDescription:AttributeDescription ? attributeDescription : "", x),
            SourcePattern = TypeOf<OctetString>()},
        DisplayInfo{ToText = (x) => AssertionValueToText(Type is attributeDescription:AttributeDescription ? attributeDescription : "", x)};
    optional Boolean DnAttributes with Asn1Encoding {TagNumber = 4, Tagging = Asn1Tagging.Implicit};
}

type SearchResultEntry
{
    LdapDN ObjectName;
    PartialAttributeList Attributes;
    
    override string ToString()
    {
        string summaryLine = "Search Result Entry";
        if (ObjectName != null && ObjectName.ToString() != "")
        {
            summaryLine += ", ObjectName: " + ObjectName.ToString();
        }
        foreach (var item in Attributes)
        {
            switch (item.Type.ToString())
            {
                case "serverName" =>
                    summaryLine += ", serverName: " + item.ValsToString();
                case "dnsHostName" => 
                    summaryLine += ", dnsHostName: " + item.ValsToString();
            }
        }

        return summaryLine;
    }
} with Asn1Encoding{TagClass = Asn1TagClass.Application, TagNumber = 4, Tagging = Asn1Tagging.Implicit};

pattern PartialAttributeList = array<PartialAttribute>;

pattern SearchResultReference = array<Uri> where (value.Count >= 1) with Asn1Encoding
{
    TagClass = Asn1TagClass.Application,
    TagNumber = 19,
    Tagging = Asn1Tagging.Implicit
};

pattern SearchResultDone = LdapResult[5] with Asn1Encoding
{
    TagClass = Asn1TagClass.Application,
    TagNumber = 5,
    Tagging = Asn1Tagging.Implicit
};

type ModifyRequest
{
    LdapDN Object;
    array<Modification> Modifications;
    
    override string ToString()
    {
        return "Modify Request, Modify object:" + (Object as string);
    }
} 
with Asn1Encoding
{
    TagClass = Asn1TagClass.Application,
    TagNumber = 6,
    Tagging = Asn1Tagging.Implicit
};

pattern Operation = enum Integer
{
    Add     = 0,
    Delete  = 1,
    Replace = 2,
}
;

type Modification
{
    Operation Operation;
    PartialAttribute Modification;
}

pattern ModifyResponse = LdapResult[7] with Asn1Encoding
{
    TagClass = Asn1TagClass.Application,
    TagNumber = 7,
    Tagging = Asn1Tagging.Implicit
};

type AddRequest
{
    LdapDN Entry;
    AttributeList Attributes;
    
    override string ToString()
    {
        return "Add Request, Add object:" + (Entry as string);
    }
}
with Asn1Encoding
{
    TagClass = Asn1TagClass.Application,
    TagNumber = 8,
    Tagging = Asn1Tagging.Implicit
};

pattern AttributeList = array<Attribute>;

pattern AddResponse = LdapResult[9] with Asn1Encoding
{
    TagClass = Asn1TagClass.Application,
    TagNumber = 9,
    Tagging = Asn1Tagging.Implicit
};
                        
pattern DelRequest = LdapDN with Asn1Encoding
{
    TagClass = Asn1TagClass.Application,
    TagNumber = 10,
    Tagging = Asn1Tagging.Implicit
};

pattern DelResponse = LdapResult[11] with Asn1Encoding
{
    TagClass = Asn1TagClass.Application,
    TagNumber = 11,
    Tagging = Asn1Tagging.Implicit
};

type ModifyDNRequest
{
    LdapDN Entry;
    RelativeLdapDN Newrdn;
    Boolean Deleteoldrdn;
    optional LdapDN NewSuperior with Asn1Encoding{TagClass = Asn1TagClass.ContextSpecific, TagNumber = 0, Tagging = Asn1Tagging.Implicit};
    
    override string ToString()
    {
        return "ModifyDN Request, Move object:" + (Entry as string);
    }
} 
with Asn1Encoding
{
    TagClass = Asn1TagClass.Application,
    TagNumber = 12,
    Tagging = Asn1Tagging.Implicit
};

pattern ModifyDNResponse = LdapResult[13] with Asn1Encoding
{
    TagClass = Asn1TagClass.Application,
    TagNumber = 13,
    Tagging = Asn1Tagging.Implicit
};

type CompareRequest
{
    LdapDN Entry;
    AttributeValueAssertion[3] Ava;
    
    override string ToString()
    {
        return "Compare Request, Compare object:" + (Entry as string);
    }
}
with Asn1Encoding
{
    TagClass = Asn1TagClass.Application,
    TagNumber = 14,
    Tagging = Asn1Tagging.Implicit
};

pattern CompareResponse = LdapResult[15] with Asn1Encoding
{
    TagClass = Asn1TagClass.Application,
    TagNumber = 15,
    Tagging = Asn1Tagging.Implicit
};

pattern AbandonRequest = MessageID with Asn1Encoding
{
    TagClass = Asn1TagClass.Application,
    TagNumber = 16,
    Tagging = Asn1Tagging.Implicit
};

type ExtendedRequest
{
    LDAPOID RequestName with Asn1Encoding{TagClass = Asn1TagClass.ContextSpecific, TagNumber = 0, Tagging = Asn1Tagging.Implicit};
    optional (ExtendedRequestValue | any) RequestValue;
        
    override string ToString()
    {
        return "Extended Request";
    }
} with Asn1Encoding{TagClass = Asn1TagClass.Application, TagNumber = 23, Tagging = Asn1Tagging.Implicit};

pattern ExtendedRequestValue = OctetString with Asn1Encoding {TagClass = Asn1TagClass.ContextSpecific, TagNumber = 1, Tagging = Asn1Tagging.Implicit};

type ExtendedResponse
{
    // Components of LDAPResult
    ResultCode ResultCode where ErrorCodeIf(value in {1, 2}, null, value == 1 ? LDAP_Operation_Error : LDAP_Protocol_Error);
    LdapDN MatchedDN;
    LdapString DiagnosticMessage;
    optional Referral Referral with Asn1Encoding{TagClass = Asn1TagClass.ContextSpecific, TagNumber = 3, Tagging = Asn1Tagging.Implicit};
    // end Components of LDAPResult
    optional LDAPOID ResponseName with Asn1Encoding{TagClass = Asn1TagClass.ContextSpecific, TagNumber = 10, Tagging = Asn1Tagging.Implicit};
    optional (ExtendedResponseValue | any) ResponseValue;
    
    override string ToString()
    {
        return "Extended Response";
    }
} with Asn1Encoding{TagClass = Asn1TagClass.Application, TagNumber = 24, Tagging = Asn1Tagging.Implicit};

pattern ExtendedResponseValue = OctetString with Asn1Encoding{TagClass = Asn1TagClass.ContextSpecific, TagNumber = 11, Tagging = Asn1Tagging.Implicit};

// ---------------------------------------------------------- Decoding Cache ---------------------------------------------------------- 
type LdapDecodingCache : TCPDecodingCache
{
    internal bool directionForLDAPInitialized = false;
    // the flag used when dispatch complete wrapped LDAP message when decoding incomplete SASL message
    internal bool isDestructed = false;
    internal (optional any message)(stream) DecodeLdapSingleMessage;
    /* 
     * second parameter is the indicator whether it is in decoding incomplete message phase
     */
    internal (optional SaslMessageResult)(stream, bool) DecodeSaslSingleMessage;
    internal MessageDirection (any message) GetLdapMessageDirection;
    WrappedLdapOriginsCalculator wrappedLdapOriginsCalculator = null;
    internal SaslMessage cachedSaslMessage = null;
    
    /* 
     * For wrapped LDAP message decoding.
     * Once SASL message is decoded, it should be dispatched immediately. And Plain Data from the SASL
     * message should be cached and then be decoded as wrapped LDAP messages.
     */
    binary PlainDataFromSasl = null;
    int SaslTotalLength = 0;
    
    void InitializeLdapDecodingCache(any endpoint ept, MessageDirection direction, bool?(binary) isCurrentProtocol,
        uint?(binary) isSufficientForSingleMsg, (optional any message)(stream) decodeLdapSingleMessage,
        (optional SaslMessageResult)(stream, bool) decodeSaslSingleMessage,
        MessageDirection(any message) getLdapMessageDirection)
    {
        assert decodeLdapSingleMessage != null;
        assert decodeSaslSingleMessage != null;
        assert getLdapMessageDirection != null;
        
        DecodeLdapSingleMessage = decodeLdapSingleMessage;
        DecodeSaslSingleMessage = decodeSaslSingleMessage;
        GetLdapMessageDirection = getLdapMessageDirection;
        wrappedLdapOriginsCalculator = new WrappedLdapOriginsCalculator();
        
        base.Initialize("LDAP", ept, direction, isCurrentProtocol,
            isSufficientForSingleMsg, DecodeLdapOrSaslSingleMessage, DecodeIncompleteLdapOrSaslMessage);
    }
    
    /* Accumulate decoding buffer and origins.
     * Store TCP diagnosis status.
     * Override AddDataSegment in TCPDecodingCache to cache TCP segment payload usage information,
     * which will be used in calculation of origins for TCP segments.
     */
    override bool AddDataSegment(Segment s)
    {
        // cache current buffer and origins count
        var bufferCount = Buffer.Count();
        
        bool ret = base.AddDataSegment(s);
        
        // If detect TCP segment-lost, clear cache first.
        if (IsTrue(s#SegmentLost))
        {
            // clear the buffer if segment lost
            bufferCount = 0;
        }
        
        /*
         * Several situation should be consider in AddDataSegment.
         * 1. Previous Buffer is not cleared, the segment may be partial-retransmitted, full-retransmitted
         *    or normal TCP segment. LDAP can calculate the length of payload inserted into Buffer, according
         *    to Buffer delta length between before base.AddDataSegment and after base.AddDataSegment.
         *    And in this situation, if segment is inserted in Origins, Origins.Count must be tcpPayloadUsageInformationArray.Count + 1.
         * 2. Previous Buffer is cleared, tcpPayloadUsageInformationArray must be empty. In this situation,
         *    LDAP should treat original Buffer Count as 0.
         */
        int informationArrayCount = wrappedLdapOriginsCalculator.tcpPayloadUsageInformationArray.Count;
        if (Origins.Count() > informationArrayCount)
            // for full retransmission situation, we should not add tcp payload information
            wrappedLdapOriginsCalculator.AddTcpPayloadInformation(Buffer.Count() - (informationArrayCount == 0 ? 0 : bufferCount));

        assert wrappedLdapOriginsCalculator.tcpPayloadUsageInformationArray.Count == Origins.Count;
        return ret;
    }

    override void AddPureAckSegment(Segment s)
    {
        base.AddPureAckSegment(s);
        
        if (Origins.Count > wrappedLdapOriginsCalculator.tcpPayloadUsageInformationArray.Count)
        {
            // the Pure ACK is inserted into Origins
            wrappedLdapOriginsCalculator.AddTcpPayloadInformation(0);
        }

        assert wrappedLdapOriginsCalculator.tcpPayloadUsageInformationArray.Count == Origins.Count;
    }

    // dispatch SASL or LDAP message
    override void DispatchMessage(any message msg)
    {
        if (msg is saslMessage:SaslMessage)
        {
            if (PlainDataFromSasl != null)
            {
                // SASL message will not be dispatched if there is data in plainDataFromSasl.
                // Because the SASL message will be dispatched as the origins of wrapped LDAP message.
                return;
            }
            else
            {
                if (Direction is MessageDirection.Accepts)
                {
                    dispatch endpoint SaslServer accepts saslMessage;
                }
                else
                {
                    dispatch endpoint SaslServer issues saslMessage;
                }
            }
            return;
        }
        
        // for LDAP
        DispatchLdapMessage(msg);
    }
    
    // the entry for decoding LDAP and SASL messages
    optional any message DecodeLdapOrSaslSingleMessage(stream s)
    {
        // LDAP PDUs
        if (s.CurrentByte == 0x30)
        {
            return DecodeLdapSingleMessage(s);
        }
        // SASL-protected data
        else if (DecodeSaslSingleMessage(s, false) is saslMessageResult:SaslMessageResult)
        {
            PlainDataFromSasl = saslMessageResult.PlainDataFromSasl;
            SaslTotalLength = saslMessageResult.SaslTotalLength;
            // assign application type annotation
            saslMessageResult.SaslMessage#SaslApplicationType = SaslApplicationTypeEnumPattern.LDAP;

            if (PlainDataFromSasl != null)
            {
                // cache SASL message to make it as the origin of the first wrapped LDAP message
                cachedSaslMessage = saslMessageResult.SaslMessage;
            }
            return saslMessageResult.SaslMessage;
        }
        
        return nothing;
    }
    
    // try decode incomplete message for SASL message
    optional any message DecodeIncompleteLdapOrSaslMessage(binary buffer)
    {
        // only handle SASL incomplete message.
        // For LDAP message, it is ASN.1 encoding, so we do not decode LDAP message manually.
        if (buffer[0] == 0x30)
        {
            return nothing;
        }
        
        if (DecodeSaslSingleMessage(buffer, true) is saslMessageResult:SaslMessageResult)
        {
            PlainDataFromSasl = saslMessageResult.PlainDataFromSasl;
            SaslTotalLength = saslMessageResult.SaslTotalLength;
            // assign application type annotation
            saslMessageResult.SaslMessage#SaslApplicationType = SaslApplicationTypeEnumPattern.LDAP;

            if (PlainDataFromSasl != null)
            {
                // cache SASL message to make it as the origin of the first wrapped LDAP message
                cachedSaslMessage = saslMessageResult.SaslMessage;
            }
            return saslMessageResult.SaslMessage;
        }
        return nothing;
    }
    
    // Decode the wrapped LDAP message one by one. And select the proper origin TCP segments and then assign to the LDAP message
    void DecodeAndDispatchWrappedLdapMessages(
        binary plainDataFromSasl,
        int saslTotalLength,
        bool isDecodingIncompleteMessage)
    {
        if (plainDataFromSasl != null && cachedSaslMessage != null)
        {
            // calculate the start origin message for LDAP message
            // keep in mind that we cannot assumed that start from the first byte of the first origin
            wrappedLdapOriginsCalculator.InitialCalculatorForDecoding(saslTotalLength, plainDataFromSasl.Count);
        
            stream s = plainDataFromSasl;
            plainDataFromSasl = null;
            bool isFirstWrappedLdapMessage = true;
            while (s.RemainingByteLength > 0)
            {
                int startPosition = s.BytePosition;
                if (DecodeLdapSingleMessage(s) is ldapMessage:any message)
                {
                    wrappedLdapOriginsCalculator.CalculateAndAssignOrigins(s.BytePosition - startPosition, ldapMessage);

                    if (isFirstWrappedLdapMessage)
                    {
                        // for the first wrapped LDAP message, re-assign its origins as SASL message
                        ldapMessage.Origins = [cachedSaslMessage];
                        isFirstWrappedLdapMessage = false;
                        cachedSaslMessage = null;
                    }

                    if (!isDestructed)
                    {
                        DispatchLdapMessage(ldapMessage);
                    }
                    else
                    {
                        // actually, it is the complete LDAP message.
                        // However, the incomplete message decoding function will be invoked when the LDAP endpoint is destructed.
                        // Avoid the diagnosis message from runtime, if the endpoint is destructed, display the LDAP message to Top Level.
                        DisplayTopLevelMessage(ldapMessage, Format(REASSEMBLY_INCOMPLETE_MESSAGE, "LDAP"));
                    }
                }
                else
                {
                    // GSSAPI may add padding after the plain data (LDAP message). Check whether it is padding or it is LDAP decoding failure.
                    // 
                    // If the follow start is not 0x30 (initial byte of LDAP) and the remaining data is small. 
                    // We assume that it is padding data and ignore the data.
                    // If not, it will report insufficient data or throw exception.
                    //
                    // Select value 8 because protocol document that the padding may be at least 1 or 8.
                    if (wrappedLdapOriginsCalculator.origins.Count > 0 && (s.CurrentByte == 0x30 || s.RemainingByteLength > 8))
                    {
                        if (!isDecodingIncompleteMessage)
                        {
                            // it is not decoding the incomplete TCP segment.
                            ValidationCheck(false, wrappedLdapOriginsCalculator.origins[0],
                                () => Format(UTILITY_STR_EXCEPTION_MESSAGE, ["LDAP", "SASL Wrapped LDAP message"]));
                        }
                        // for decoding incomplete TCP segment, it did nothing.
                        // because the cached origins will be assign to the SASL message and 
                        // diagnosis message of insufficient will also be reported when display SASL message to top level.
                    }
                    break;
                }
            }
        }
        
        wrappedLdapOriginsCalculator.Reset(Buffer.Count);

        // reset and dispatch cachedSaslMessage if no wrapped LDAP messsage is decoded
        if (cachedSaslMessage != null)
        {
            if (Direction is MessageDirection.Accepts)
            {
                dispatch endpoint SaslServer accepts cachedSaslMessage;
            }
            else
            {
                dispatch endpoint SaslServer issues cachedSaslMessage;
            }

            cachedSaslMessage = null;
        }
    }
    
    // Dispatch LDAP message
    void DispatchLdapMessage(any message ldapMessage)
    {
        if (!directionForLDAPInitialized)
        {
            Direction = GetLdapMessageDirection(ldapMessage);
            directionForLDAPInitialized = true;
        }

        base.DispatchMessage(ldapMessage);
    }
    
    // override ResetAfterSucceed to set bufferStartPosition
    override void ResetAfterSucceed(stream s)
    {
        if (PlainDataFromSasl != null)
        {
            /*
             * Clone Origins. In function, base.ResetAfterSucceed Origins will be empty
             * Then in DecodeAndDispatchWrappedLdapMessages, it will decode LDAP message and
             * remove related origins from array. So they can be GC.
             */
            wrappedLdapOriginsCalculator.origins = Origins;
        }
        
        base.ResetAfterSucceed(s);

        // decode wrapped ldap messages
        DecodeAndDispatchWrappedLdapMessages(PlainDataFromSasl, SaslTotalLength, false);
        
        // reset
        PlainDataFromSasl = null;
        SaslTotalLength = 0;
        assert wrappedLdapOriginsCalculator.tcpPayloadUsageInformationArray.Count == Origins.Count;
    }
    
    // override ResetAfterSucceed to reset bufferStartPosition
    override void ClearExceptionally()
    {
        if (IsCurProtocol == true)
        {
            /*
             * Clone Origins. In function, base.ResetAfterSucceed Origins will be empty
             * Then in DecodeAndDispatchWrappedLdapMessages, it will decode LDAP message and
             * remove related origins from array. So they can be GC.
             */
            wrappedLdapOriginsCalculator.origins = Origins;
        }
        
        base.ClearExceptionally();
        
        // decode wrapped ldap messages
        DecodeAndDispatchWrappedLdapMessages(PlainDataFromSasl, SaslTotalLength, true);
        
        // reset
        PlainDataFromSasl = null;
        SaslTotalLength = 0;
        assert wrappedLdapOriginsCalculator.tcpPayloadUsageInformationArray.Count == Origins.Count;
    }
    
    override void ClearInDestructor()
    {
        isDestructed = true;
        base.ClearInDestructor();
    }
};

type SaslMessageResult
{
    SaslMessage SaslMessage;
    binary PlainDataFromSasl;
    int SaslTotalLength;
}

/*
 * This type calculates and assign origins for wrapped LDAP message.
 * Because the wrapped LDAP messages comes with a bunch, we cannot assume that N-1 origins belongs one LDAP message.
 * So for each decoded wrapped LDAP message, we should calculate and assign the origins.
 * 
 * The calculator is used in Ldap decoding cache.
 * WrappedLdapOriginsCalculator.AddDataSegment should be invoked in LDAPDecodingCache.AddTcpPayloadInformation.
 * Then TCP payload information can be cached in the calculator.
 * 
 * In decoding wrapped ldap messages from plain data in SASL.
 * 1. It should initiliaze the decoding first (InitialCalculatorForDecoding).
 * 2. Then invoke CalculateAndAssignOrigins for each decoded LDAP message.
 * 3. At the end, it should reset for next decoding wrapped ldap message.
 */
type WrappedLdapOriginsCalculator
{
    // The position where the SASL message decoding starts from in Origins.
    // It will be used when calculate the origins for wrapped LDAP message.
    internal int saslMessageStartPosition = 0;
    // cache TCP Segment Payload usage information, which is used to calculate the origins for wrapped LDAP message.
    // we cannot use TCP.Segment.Payload.Length directly because TCP segment may be retransmitted message.
    internal int tcpPayloadUsageInformationIndex = 0;
    internal array<int> tcpPayloadUsageInformationArray = [];
    // offset of the current position to the first TCP.Segment
    internal int offset = 0;
    array<any message> origins = null;
    
    // add tcp payload length information when TCP segment coming
    void AddTcpPayloadInformation(int tcpPayloadLength)
    {
        assert tcpPayloadLength >= 0;
        tcpPayloadUsageInformationArray += [tcpPayloadLength];
    }
    
    void Reset(int bufferCount /*count of Buffer in Decoding Cache*/)
    {
        if (bufferCount == 0)
        {
            tcpPayloadUsageInformationArray = [];
            saslMessageStartPosition = 0;
        }
        else
        {
            // leave the last one TCP segments
            tcpPayloadUsageInformationArray = tcpPayloadUsageInformationArray.Segment(tcpPayloadUsageInformationArray.Count - 1);
            saslMessageStartPosition = tcpPayloadUsageInformationArray[0] - bufferCount;
        }
        
        origins = null;
        offset = 0;
        tcpPayloadUsageInformationIndex = 0;
    }
    
    void InitialCalculatorForDecoding(int saslMessageLength, int plainDataFromSaslLength)
    {
        assert origins != null && origins.Count == tcpPayloadUsageInformationArray.Count;
        
        // set offset = bufferStartPosition + Sasl Mechanism data length
        offset = saslMessageStartPosition + (saslMessageLength - plainDataFromSaslLength /* calculate the length of SASL mechanism*/);
        tcpPayloadUsageInformationIndex = 0;
        
        CalculateAndAssignOrigins(null);
    }
    
    void CalculateAndAssignOrigins(int ldapMessageLength, any message wrappedLdapMessage)
    {
        offset += ldapMessageLength;
        
        CalculateAndAssignOrigins(wrappedLdapMessage);
    }
    
    /*
     *   0 +---------------+
     *     | TCP Segment 0 |
     *  20 +---------------+
     *     | TCP Segment 1 |
     *  40 +---------------+
     *     |     ...       |
     *     +---------------+
     * "offest" represents a position in "origins".
     * In this function, it will adjust "offest" and "origins" array and assign correct origins to wrapped ldap message.
     * 
     * For example, before the function, offset is 30, which represents current position is 30 bytes apart from the first byte in TCP Segemtn 0.
     * We should assign the first and second TCP segment as the origins of wrapped ldap message.
     * Then remove the first TCP segment message and adjuest offset to 10 (30 - length of first TCP segment).
     */
    internal void CalculateAndAssignOrigins(any message wrappedLdapMessage)
    {
        assert origins != null;
        
        int originsIndex = 0;
        for (; originsIndex < origins.Count; originsIndex++, tcpPayloadUsageInformationIndex++)
        {
            if (offset < tcpPayloadUsageInformationArray[tcpPayloadUsageInformationIndex])
            {
                if (wrappedLdapMessage != null) wrappedLdapMessage.Origins = origins.Segment(0, (offset == 0 ? originsIndex : originsIndex + 1)); // assign origins
                if (originsIndex > 0) origins = origins.Segment(originsIndex); // adjust origins
                return;
            }
            offset -= tcpPayloadUsageInformationArray[tcpPayloadUsageInformationIndex];
        }
        
        // all is comsumed
        assert offset == 0;
        if (wrappedLdapMessage != null) wrappedLdapMessage.Origins = origins;
        origins = [];
    }
}

uint get PayloadLength(this LdapMessage s)
{
    return GetTCPPayloadsLength(s);
}
