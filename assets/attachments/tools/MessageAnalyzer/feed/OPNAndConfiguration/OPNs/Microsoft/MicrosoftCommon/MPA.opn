protocol MPA with 
BinaryEncodingDefaults{Endian = Endian.Big},
Documentation
{
    ProtocolName = "Marker PDU Aligned Framing for TCP Specification",
    ShortName = "MPA",
    Description = ""
},
OPNAuthoring
{
    Copyright = "(c) Microsoft Corporation",
    References = 
        [
            new Reference{Name = "RFC 5044"},
        ],
    RevisionSummary =
        [
            new Revision{Class = RevisionClass.Major, Version = "380827", Date = "09/22/2015"}
        ]
};

using Utility;
using TCP;
using DecodingUtility; // WORKAROUND: compiler bug#3131164, When type A inherit from type B, module C use tye A, and A, B, C is in different module file, compiler will give a compilation error
using CoreNetworkingResources;

endpoint Node over TCP.Server
    accepts MpaRequestFrame
    issues MpaReplyFrame
    accepts Fpdu
    issues Fpdu;

const binary MPARequestIdentifier = $[4D504120494420526571204672616D65]; // he binary means :"MPA ID Req Frame"
const binary MPAReplyIdentifier =   $[4D504120494420526570204672616D65]; // The binary means :"MPA ID rep Frame"

autostart actor MpaOverTcp(TCP.Server server)
{
    MpaDecodingHelper decodingHelper = null;
    MessageDirection directionOfAcceptedMsg = MessageDirection.Accepts;
    MessageDirection directionOfIssuedMsg = MessageDirection.Issues;

    process server accepts f:TCP.Segment where decodingHelper != null || (IsMpaRequestOrReplyFrame(f) is msgType:MpaMessagType && msgType != MpaMessagType.None)
    {
        if (decodingHelper == null)
        {
            decodingHelper = new MpaDecodingHelper(endpoint Node over server);
            if (msgType == MpaMessagType.Reply)
            {
                directionOfAcceptedMsg = MessageDirection.Issues;
                directionOfIssuedMsg = MessageDirection.Accepts;
            }
        }
        decodingHelper.TryDecode(f, directionOfAcceptedMsg);
    }

    process server issues f:TCP.Segment where decodingHelper != null || (IsMpaRequestOrReplyFrame(f) is msgType:MpaMessagType && msgType != MpaMessagType.None)
    {
        if (decodingHelper == null)
        {
            decodingHelper = new MpaDecodingHelper(endpoint Node over server);
            if (msgType == MpaMessagType.Request)
            {
                directionOfAcceptedMsg = MessageDirection.Issues;
                directionOfIssuedMsg = MessageDirection.Accepts;
            }
        }
        decodingHelper.TryDecode(f, directionOfIssuedMsg);
    }
    
    ~endpoint(TCP.Server server)
    {
        if (decodingHelper != null)
        {
            decodingHelper.ClearInDestructor();
        }
    }

    MpaMessagType IsMpaRequestOrReplyFrame(TCP.Segment f)
    {
        if (f.Payload.Count >= 16 && f.Payload.Segment(0, 16) is id:binary)
        {
            if (id == MPARequestIdentifier)
            {
                return MpaMessagType.Request;
            }
            else if (id == MPAReplyIdentifier)
            {
                return MpaMessagType.Reply;
            }
        }
        return MpaMessagType.None;
    }
}

type Flag
{
    bool M with BinaryEncoding{Width = 1};      // declares that Markers are REQUIRED(1) or not(0)
    bool C with BinaryEncoding{Width = 1};      // 0 CRCs MUST not be checked and need not be generated by either endpoint
    bool R with BinaryEncoding{Width = 1};      // In the MPA Reply Frame, this bit is the Rejected Connection bit, set by the Responders ULP to indicate acceptance '0', or rejection '1', of the connection parameters provided in the Private Data.
    byte Res where ValidationCheck(value == 0, null, "MPA: The Flag.Res field is set to zero.") with BinaryEncoding{Width = 5};
    
    override string ToString()
    {
        string sflag = "";
        if (M)
        {
            sflag += "|M";
        }
        if (C)
        {
            sflag += "|C";
        }
        if (R)
        {
            sflag += "|R";
        }
        return (sflag.Count == 0) ? "0" : sflag.Segment(1);
    }
}

// 7.1.1  MPA Request and Reply Frame Format
message MpaRequestFrame
{
    string Key with BinaryEncoding{Length = 16, TextEncoding = TextEncoding.ASCII};
    Flag Flag;
    byte Rev where ValidationCheckValue(value == 1, this, true, ReferenceType.Message, "MPA", "Rev", "MpaRequestFrame", "1", value);
    ushort PDLength;
    binary PrivateData with BinaryEncoding{MaxLength = PDLength};

    override string ToString()
    {
        return "Request, Key: " + Key + ", Flag: " + Flag.ToString() + ", PD_Length: " + PDLength.ToString();
    }
}

message MpaReplyFrame
{
    string Key with BinaryEncoding{Length = 16, TextEncoding = TextEncoding.ASCII};
    Flag Flag;
    byte Rev where ValidationCheckValue(value == 1, this, true, ReferenceType.Message, "MPA", "Rev", "MpaReplyFrame", "1", value);
    ushort PDLength;
    binary PrivateData with BinaryEncoding{MaxLength = PDLength};

    override string ToString()
    {
        string sflag = Flag.ToString();
        return "Reply, Key: " + Key + ", Flag: " + Flag.ToString() + ", PD_Length: " + (PDLength as string);
    }
}

message Fpdu
{
    (ushort where value != 0) UlpduLength;
    binary Ulpdu with BinaryEncoding{MaxLength = UlpduLength};
    binary Pad with BinaryEncoding{Length = (UlpduLength + 2) % 4 == 0 ? 0 : (4 - (UlpduLength + 2) % 4)};
    uint Crc;
    optional array<Marker> Marker with Encoding{Ignore = true};
    
    override string ToString()
    {
        return "FPDU Message, ULPDU_Length: " + (UlpduLength as string) + ", CRC: " + Utility.DecToHexFormat(Crc);
    }
}

type Marker
{
    ushort Reserved;
    ushort FpduPtr;
}

type MpaDecodingCache : TCPDecodingCache
{
    MpaDecodingCache OppositeCache;
    MpaConnectionState MpaConnState = MpaConnectionState.None;
    bool RequireMaker = false;
    uint MpaCurrentMarkerSeq = 0;
    bool MpaSeqStartInitialized = false;
    binary MarkerDataAll = $[];
    
    MpaDecodingCache(any endpoint ept, MessageDirection direction)
    {
        Initialize("MPA", ept, direction, IsMpaMsg, IsSufficientForSingleMpaMsg, DecodeMpaMessage, DecodeIncompleteMpaMessage);
    }

    override bool AddDataSegment(Segment s)
    {
        int preBufferLength = Buffer.Count;
        bool ret = base.AddDataSegment(s);

        // There's marker which should be removed from Buffer
        if (ret && MpaConnState == MpaConnectionState.Connected && RequireMaker)
        {
            Buffer = Buffer.Segment(0, preBufferLength);
            bool isOverlapping = SequenceComparer(s.SequenceNumber, BufferEndSequenceNumber) < 0 &&
                                    SequenceComparer(BufferEndSequenceNumber, s.NextSequenceNumber) < 0;
            RemoveMarkerAndAddToBuffer(s, isOverlapping);
        }
        return ret;
    }

    override void ClearInDestructor()
    {
        base.ClearInDestructor();
        OppositeCache = null;
        MpaConnState = MpaConnectionState.None;
        RequireMaker = false;
        MpaCurrentMarkerSeq = 0;
        MpaSeqStartInitialized = false;
        MarkerDataAll = $[];
    }

    void RemoveMarkerAndAddToBuffer(Segment s, bool overlapped)
    {
        if (!MpaSeqStartInitialized)
        {
            MpaCurrentMarkerSeq = s.SequenceNumber;
            MpaSeqStartInitialized = true;
        }
        uint startPosOfRemainBytes = overlapped ? BufferEndSequenceNumber - s.SequenceNumber : 0; // the start index of unconsumed bytes
        while (MpaCurrentMarkerSeq < s.SequenceNumber + startPosOfRemainBytes) // overlapped segment, or segment lost
        {
            MpaCurrentMarkerSeq += 512; // correct the MpaCurrentMarkerSeq in case marker is lost
        }
        uint currentMarkerPos = MpaCurrentMarkerSeq - s.SequenceNumber;
        while (currentMarkerPos < s.Payload.Count)
        {
            Buffer += s.Payload.Segment(startPosOfRemainBytes as int, (currentMarkerPos - startPosOfRemainBytes) as int); // store the data before this marker
            MarkerDataAll += s.Payload.Segment(currentMarkerPos as int, 4); // store marker; Note: marker will never cross 2 segments since it's 4 byte aligned
            startPosOfRemainBytes = currentMarkerPos + 4;
            currentMarkerPos += 512 + 4;
            MpaCurrentMarkerSeq += 512 + 4;
        }
        if (startPosOfRemainBytes < s.Payload.Count) // add remaining bytes after the last marker
        {
            Buffer += s.Payload.Segment(startPosOfRemainBytes as int);
        }
    }

    bool? IsMpaMsg(binary data)
    {
        if (MpaConnState == MpaConnectionState.Connected)
        {
            return data.Count >= 6 ? Utility.MakeWord(data[0], data[1]) != 0 : null;
        }
        if (MpaConnState == MpaConnectionState.Requesting || MpaConnState == MpaConnectionState.Replying) return true;
        if (data.Count >= 16 && data.Segment(0, 16) is id:binary)
        {
            if (id == MPARequestIdentifier)
            {
                MpaConnState = MpaConnectionState.Requesting;
                return true;
            }
            else if (id == MPAReplyIdentifier)
            {
                MpaConnState = MpaConnectionState.Replying;
                return true;
            }
            return false;
        }
        return null;
    }

    uint? IsSufficientForSingleMpaMsg(binary data)
    {
        if (MpaConnState == MpaConnectionState.Connected)
        {
            // Fpdu
            if (data.Count < 2) return null;
            uint len = (Utility.MakeWord(data[0], data[1]) + 6) as uint;
            len += len % 4 == 0 ? 0 : 4 - (len % 4);
            return data.Count < len ? len : 0;
        }
        else
        {
            // MpaRequestFrame or MpaReplyFrame
            if (data.Count < 20) return null;
            uint len = (Utility.MakeWord(data[18], data[19]) + 20) as uint;
            return data.Count < len ? len : 0;
        }
    }

    optional any message DecodeMpaMessage(stream s)
    {
        optional any message msg = nothing;
        switch (MpaConnState)
        {
            case MpaConnectionState.Requesting =>
                if (BinaryDecoder<MpaRequestFrame>(s) is m:MpaRequestFrame)
                {
                    msg = m;
                    OppositeCache.RequireMaker = m.Flag.M;
                    MpaConnState = MpaConnectionState.RequestSuccess;
                }
                else
                {
                    MpaConnState = MpaConnectionState.None;
                }
            case MpaConnectionState.Replying =>
                if (BinaryDecoder<MpaReplyFrame>(s) is m:MpaReplyFrame)
                {
                    msg = m;
                    OppositeCache.RequireMaker = m.Flag.M;
                    if (!m.Flag.R)
                    {
                        MpaConnState = MpaConnectionState.Connected;
                        OppositeCache.MpaConnState = MpaConnectionState.Connected;
                    }
                    else
                    {
                        MpaConnState = MpaConnectionState.None;
                        OppositeCache.MpaConnState = MpaConnectionState.None;
                    }
                }
                else
                {
                    MpaConnState = MpaConnectionState.None;
                }
            case MpaConnectionState.Connected =>
                if (BinaryDecoder<Fpdu>(s) is m:Fpdu)
                {
                    if (BinaryDecoder<MakerArrayWrapper>(MarkerDataAll) is marks:MakerArrayWrapper && marks.items.Count > 0)
                    {
                         m.Marker = marks.items;
                    }
                    msg = m;
                }
                // reset MarkerDataAll
                MarkerDataAll = $[];
            default =>;
        }
        return msg;
    }

    optional any message DecodeIncompleteMpaMessage(binary s)
    {
        return DecodeMpaMessage(s);
    }
}

type MpaDecodingHelper : TCPDecodingHelper
{
    MpaDecodingHelper(MPA.Node node)
    {
        var mCacheReq = new MpaDecodingCache(node, MessageDirection.Accepts);
        var mCacheResp = new MpaDecodingCache(node, MessageDirection.Issues);
        mCacheReq.OppositeCache = mCacheResp;
        mCacheResp.OppositeCache = mCacheReq;
        AcceptsCache = mCacheReq;
        IssuesCache = mCacheResp;
    }
}

pattern MpaConnectionState = enum byte
{
    None = 0,
    Requesting = 1, // After received first TCP segment of MpaRequestFrame and before received last segment of MpaRequestFrame
    RequestSuccess = 2, // After received last segment of MpaRequestFrame
    Replying = 3, // After received first TCP segment of MpaRequestFrameMpaReplyFrame and before received last segment of MpaReplyFrame
    Connected = 4 // received MpaReplyFrame (m) and m.Flag.R == 0
};

pattern MpaMessagType = enum byte
{
    None = 0,
    Request = 1,
    Reply = 2,
    Fpdu = 3
};

type MakerArrayWrapper
{
    array<Marker> items;
}
