protocol iSCSI with
BinaryEncodingDefaults{Endian = Endian.Big},
Documentation
{
    ProtocolName = "Internet Small Computer Systems Interface",
    ShortName = "iSCSI",
    Description = ""
},
OPNAuthoring
{
    Copyright = "(c) Microsoft Corporation",
    References =
        [
            new Reference{Name = "RFC 3720"},
            new Reference{Name = "RFC 3721"},
            new Reference{Name = "RFC 5048"},
            new Reference{Name = "SAM-2", Link = "http://www.t10.org/cgi-bin/ac.pl?t=f&f=sam2r24.pdf"},
            new Reference{Name = "SPC-2", Link = "http://www.t10.org/cgi-bin/ac.pl?t=f&f=spc2r20.pdf"},
            new Reference{Name = "SBC-3", Link = "http://www.t10.org/cgi-bin/ac.pl?t=f&f=sbc3r35f.pdf"},
            new Reference{Name = "SPC-4", Link = "http://www.t10.org/cgi-bin/ac.pl?t=f&f=spc4r33.pdf"},
            new Reference{Name = "SBC-2", Link = "http://www.o3one.org/hwdocs/scsispecs/hard_disk_sbc2r04.pdf"},
        ],
    RevisionSummary =
        [
            new Revision{Class = RevisionClass.Major, Version = "380827", Date = "09/22/2015"}
        ]
};

using Standard;
using Utility;
using MicrosoftCommonResources;
using Diagnostics;
using IANA;
using TCP;
using DecodingUtility; // WORKAROUND: compiler bug#3131164, When type A inherit from type B, module C use tye A, and A, B, C is in different module file, compiler will give a compilation error

/* Future Reference:
 * 1. Add Initiator side endpoint and sequence validation
 * 2. Add iSCSISession endpoint by the index of TSIH
 * 3. Add detailed key-value syntax definitions according to [RFC 3729] 12. Login/Text Operational Text Keys
 * 4. Add reassemble logic if the CommandData in ScsiCommand message is overflow
 * 5. Enable all the UTF8 decoding, currently UTF8 can't work properly due to bug 23734
 */

//-------------------------------------------
// Annotation
annotation bool NegotiationMessage#IsReassembled;

//-------------------------------------------
// Architecture

/* The iSCSI layer that builds/receives iSCSI PDUs and relays/receives them to/from one or more TCP connections;
 * the group of connections form an initiator-target "session".
 * An iSCSI Node is identified by its iSCSI Name.
 * It allows multiple iSCSI nodes to use the same addresses, and the same iSCSI node to use multiple addresses.
 * The following diagram shows an example for its relationship with other protocols of server side.
 *    ----------------------------IP Network---------------------
 *             |               |                    |
 *        +----|---------------|-----+         +----|---------+
 *        | +---------+  +---------+ |         | +---------+  |
 *        | | Network |  | Network | |         | | Network |  | 
 *        | | Portal  |  | Portal  | |         | | Portal  |  |
 *        | +--|------+  +---------+ |         | +---------+  |
 *        +--------------------------+         +--------------+
 *             |               |                    |
 *    +--------|---------------|--------------------|------------+
 *    |        -----------------  iSCSI Server      |            |
 *    | +--------|----+ +----|----------------------|--+         |
 *    | | iSCSI Node  | |         iSCSI Node           |         |
 *    | |  (Target)   | |          (Target)            |         |
 *    | +-------------+ +------------------------------+         |
 *    +----------------------------------------------------------+
 */

// Server side
endpoint TargetNode[string TargetName]
    over Server
    provides Messages consumes Messages;

/* The server endpoint of a SCSI transport.
 * No need to bind this endpoint over TCP server as communication between the initiator and target occurs over one or more TCP connections.
 */
// Add index for grouping virtual operations, the index is InitiatorTaskTag field.
// For messages cannot use InitiatorTaskTag to group virtual operations, dispatch them to Server[0]. 
endpoint Server[uint Tag]
    provides Messages consumes Messages provides VirtualOperations
{
    string targetName = "";
    
    observe this issues m: Messages.LoginResponse
    {
        // Get the TargetName
        if (m.LoginParameters is map<string, string>)
        {
            var pairs = m.LoginParameters as map<string, string>;
            if ("TargetName" in pairs)
            {
                targetName = pairs["TargetName"] as string;
            }
        }
    }
    
    observe this issues m: Messages.TextResponse
    {
        // Get the TargetName
        if (m.Text is map<string, string>)
        {
            var pairs = m.Text as map<string, string>;
            if (pairs.Keys["TargetName"])
            {
                targetName = pairs["TargetName"] as string;
            }
        }
    }
    
    observe this issues m: Messages.LogoutResponse
    {
        // Clear the target name when the session is logout
        targetName = "";
    }
    
    // Dispatch message to TargetNode to divide the session by TargetName
    process this accepts m: FeatureMessage
    {
        dispatch (endpoint TargetNode[targetName] over this) accepts m;
    }
    
    process this issues m: FeatureMessage
    {
        dispatch (endpoint TargetNode[targetName] over this) issues m;
    }
}

/* Intermediate endpoint that used to receive the fragmented negotiation message and TCP segment with incompelete payload.
 * And will set fragment origins for the reassembled message.
 */
endpoint IntermediateNode
    over TCP.Server
    accepts NegotiationMessage issues NegotiationMessage
{
    any LoginParameters = null; // it will be assigned by in underlying actor
    binary Buffer = $[]; // it will be assigned by in underlying actor

    Messages.LoginRequest loginRequest = null;
    array<any message> LoginRequestOrigins = [];
    Messages.LoginResponse loginResponse = null;
    array<any message> loginResponseOrigins = [];
    Messages.TextRequest textRequest = null;
    array<any message> textRequestOrigins = [];
    Messages.TextResponse textResponse = null;
    array<any message> textResponseOrigins = [];

    process this accepts m:Messages.LoginRequest
    {
        LoginRequestOrigins += [m];
        if (!m.C) // the final message
        {
            loginRequest = new Messages.LoginRequest 
                                    {
                                        I = m.I,
                                        Opcode = m.Opcode,
                                        T = m.T,
                                        Csg = m.Csg,
                                        Nsg = m.Nsg,
                                        VersionMax = m.VersionMax,
                                        VersionMin = m.VersionMin,
                                        DataSegmentLength = Buffer.Count as uint,
                                        Isid = m.Isid,
                                        Tsih = m.Tsih,
                                        InitiatorTaskTag = m.InitiatorTaskTag,
                                        Cid = m.Cid,
                                        CmdSN = m.CmdSN,
                                        ExpStatSN = m.ExpStatSN,
                                        Reserved4 = m.Reserved4
                                    };
            loginRequest.LoginParameters = LoginParameters;
            loginRequest.SourceData = Buffer;
            loginRequest.Origins = LoginRequestOrigins;
            loginRequest#IsReassembled = true;
            dispatch endpoint Server[0] accepts loginRequest;
            LoginRequestOrigins = [];
            Buffer = $[];
        }
    }
    
    process this accepts m:Messages.TextRequest
    {
        textRequestOrigins += [m];
        if (!m.C) // the final message
        {
            textRequest = new Messages.TextRequest {
                                            I = m.I,
                                            Opcode = m.Opcode,
                                            F = m.F,
                                            DataSegmentLength = Buffer.Count as uint,
                                            LogicalUnitNumber = m.LogicalUnitNumber,
                                            InitiatorTaskTag = m.InitiatorTaskTag,
                                            TargetTransferTag = m.TargetTransferTag,
                                            CmdSN = m.CmdSN,
                                            ExpStatSN = m.ExpStatSN,
                                            Reserved4 = m.Reserved4
                                        };
            textRequest.Text = LoginParameters;
            textRequest.SourceData = Buffer;
            textRequest.Origins = textRequestOrigins;
            textRequest#IsReassembled = true;
            dispatch endpoint Server[0] accepts textRequest;
            textRequestOrigins = [];
            Buffer = $[];
        }
    }
    process this issues m:Messages.LoginResponse
    {
        loginResponseOrigins += [m];
        if (!m.C) // the final message
        {
            loginResponse = new Messages.LoginResponse {
                                        I = m.I,
                                        Opcode = m.Opcode,
                                        T = m.T,
                                        Csg = m.Csg,
                                        Nsg = m.Nsg,
                                        VersionMax = m.VersionMax,
                                        VersionMin = m.VersionMin,
                                        DataSegmentLength = Buffer.Count as uint,
                                        Isid = m.Isid,
                                        Tsih = m.Tsih,
                                        InitiatorTaskTag = m.InitiatorTaskTag,
                                        Cid = m.Cid,
                                        CmdSN = m.CmdSN,
                                        ExpStatSN = m.ExpStatSN,
                                        MaxCmdSN = m.MaxCmdSN,
                                        StatusClass = m.StatusClass,
                                        StatusDetails = m.StatusDetails,
                                        Reserved4 = m.Reserved4
                                                        };
            loginResponse.LoginParameters = LoginParameters;
            loginResponse.SourceData = Buffer;
            loginResponse.Origins = loginResponseOrigins;
            loginResponse#IsReassembled = true;
            dispatch endpoint Server[0] issues loginResponse;
            loginResponseOrigins = [];
            Buffer = $[];
        }
    }
    process this issues m:Messages.TextResponse
    {
        textResponseOrigins += [m];
        if (!m.C) // the final message
        {
            textResponse = new Messages.TextResponse{
                                        Opcode = m.Opcode,
                                        F = m.F,
                                        DataSegmentLength = Buffer.Count as uint,
                                        LogicalUnitNumber = m.LogicalUnitNumber,
                                        InitiatorTaskTag = m.InitiatorTaskTag,
                                        TargetTransferTag = m.TargetTransferTag,
                                        CmdSN = m.CmdSN,
                                        ExpStatSN = m.ExpStatSN,
                                        Reserved4 = m.Reserved4
                                                            };
            textResponse.Text = LoginParameters;
            textResponse.SourceData = Buffer;
            textResponse.Origins = textResponseOrigins;
            textResponse#IsReassembled = true;
            dispatch endpoint Server[0] issues textResponse;
            textResponseOrigins = [];
            Buffer = $[];
        }
    }
}

// Client side
client endpoint InitiatorNode connected to TargetNode;
client endpoint Client connected to Server;

type SessionContext
{
    // Keep the session available parameters from the login messages
    LoginPhaseParameters lpp = null;
    // Record the scsi command information of each task
    map<uint, ScsiCommandParameters> taskInfo = {};
}

// Forward the parsed message to the iSCSI layer from TCP layer
autostart actor IscsiOverTcp(TCP.Server server)
{
    ISCSIDecodingHelper helper = null;
    
    process server accepts s:TCP.Segment{DestinationPort is (Port.iSCSI | Port.iSCSI860)}
    {
        if (helper == null)
        {   
            helper = new ISCSIDecodingHelper();
            helper.InitializeISCSIHelper(endpoint iSCSI.Server[0] over server);
        }
        helper.TryDecode(s, MessageDirection.Accepts);
    }
    
    process server issues s:TCP.Segment{SourcePort is (Port.iSCSI | Port.iSCSI860)}
    {
        if (helper == null)
        {
            helper = new ISCSIDecodingHelper();
            helper.InitializeISCSIHelper(endpoint iSCSI.Server[0] over server);
        }
        helper.TryDecode(s, MessageDirection.Issues);
    }
        
    ~endpoint(TCP.Server server)
    {
        if (helper != null)
        {
            helper.ClearInDestructor();
            helper = null;
        }
    }
}

//-------------------------------------------
// Messages

// The base message of Text/Login message, which used to establish an iSCSI session.
message NegotiationMessage{};

// The base message for the messages that sent in the full feature phase, after the login process has completed
message FeatureMessage{}

contract Messages
{
    // --------------------- Messages that send by Initiator ------------------
    
    // [RFC 3720] 10.3.  SCSI Command
    message ScsiCommand : FeatureMessage
    {
        // Basic Header Segment (BHS)
        byte Reserved1 with BinaryEncoding{Width = 1};
        bool I with BinaryEncoding{Width = 1};
        (Opcodes where value == Opcodes.ScsiCommand) Opcode with BinaryEncoding{Width = 6};
    
        ScsiCommandFlagsAndTaskAttributes TaskAttributes;
        ushort Reserved2 with BinaryEncoding{Length = 2};
        byte TotalAHSLength;
        uint DataSegmentLength with BinaryEncoding{Width = 24};
        long LogicalUnitNumber;
        uint InitiatorTaskTag;
        uint ExpectedDataTransferLength;
        uint CmdSN;
        uint ExpStatSN;
        (ScsiCommandDescriptorBlock | binary) ScsiCommandDescriptorBlock with BinaryEncoding{Length = 16};
       
        // Optional Fields
        // Will limit the data to the expected array size in the message decoding.
        optional [|TotalAHSLength > 0|] array<AdditionalHeaderSegment> AHS;
        // Add this addtional field for operation code 7Fh, since the data will be fall in two parts and need manully merge it.
        optional VariableLengthCommandDescriptorBlock VariableLengthCommandDescriptorBlock with Encoding{Ignore = true};
        // Ingnored the decoding for the existence and type of digests are negotiated during the Login Phase.
        optional uint HeaderDigest with Encoding{Ignore = true};
        optional (binary | any) CommandData with Encoding{Ignore = true};
        optional array<byte> Padding with Encoding{Ignore = true};
        optional uint DataDigest with Encoding{Ignore = true};
        
        // Message summary
        override string ToString()
        {
            string summary = "SCSI Command";
            if (ScsiCommandDescriptorBlock is cdb:ScsiCommandDescriptorBlock)
            {
                summary += ", Operation = " + ScsiCommandDescriptorBlock.ToString();
                summary += GetScsiCommandDescriptorBlockSummaryString(cdb);
            }
            else if (VariableLengthCommandDescriptorBlock is vcdb:VariableLengthCommandDescriptorBlock)
            {
                summary += ", Operation = " + VariableLengthCommandDescriptorBlock.ToString();
                summary += GetVariableLengthCommandDescriptorBlockSummaryString(vcdb);
            }
            return summary;
        }
    }
    
    // ----------------- Messages that send by Targetor ---------------------
    
    // [RFC 3720] 10.4.  SCSI Response
    message ScsiResponse : FeatureMessage
    {
        // Basic Header Segment (BHS) 
        byte Reserved1 with BinaryEncoding{Width = 2};
        (Opcodes where value == Opcodes.ScsiResponse) Opcode with BinaryEncoding{Width = 6};
        
        ScsiResponseFlags Flags;
        byte Response where ErrorCodeIf(value is ResponseByte.TargetFailure, this, iSCSI_STR_1);
        Status Status;
        byte TotalAHSLength where ValidationCheckZero(value == 0x00, this, true, ReferenceType.Message, "iSCSI", "TotalAHSLength", "ScsiResponse", value);
        uint DataSegmentLength with BinaryEncoding{Width = 24};
        array<byte> Reserved2 with BinaryEncoding{Length = 8};
        uint InitiatorTaskTag;
        uint SnackTag;
        uint StatSN;
        uint ExpCmdSN;
        uint MaxCmdSN;
        uint ExpDataSN;
        uint BidirectionalReadResidualCount;
        uint ResidualCount;
        
        // Optional Fields, ingnored the decoding for the existence and type of digests are negotiated during the Login Phase.
        optional uint HeaderDigest with Encoding{Ignore = true};
        optional SenseAndResponseDataSegment[DataSegmentLength] DataSegment with Encoding{Ignore = true};
        optional uint DataDigest with Encoding{Ignore = true};
        
        // Message summary
        override string ToString()
        {
            return "SCSI Response, Status = " + StatusToText(Status);
        }
    }
    
    // [RFC 3720] 10.5.  Task Management Function Request
    message ScsiTaskManagementFunctionRequest : FeatureMessage
    {
        // Basic Header Segment (BHS) 
        byte Reserved1 with BinaryEncoding{Width = 1};
        bool I with BinaryEncoding{Width = 1};
        (Opcodes where value == Opcodes.ScsiTaskManagementFunctionRequest) Opcode with BinaryEncoding{Width = 6};
        
        bool F where ValidationCheck(value == true, this, "iSCSI: The F bit in ScsiTaskManagementFunctionRequest message should be set to 1.") with BinaryEncoding{Width = 1};
        TaskManagementFunctions Function with BinaryEncoding{Width = 7};
        
        array<byte> Reserved2 with BinaryEncoding{Length = 2};
        byte TotalAHSLength where ValidationCheckZero(value == 0x00, this, true, ReferenceType.Message, "iSCSI", "TotalAHSLength", "ScsiTaskManagementFunctionRequest", value);
        uint DataSegmentLength where ValidationCheckZero(value == 0x00, this, true, ReferenceType.Message, "iSCSI", "DataSegmentLength", "ScsiTaskManagementFunctionRequest", value) with BinaryEncoding{Width = 24};
        long LogicalUnitNumber;
        uint InitiatorTaskTag;
        uint ReferencedTaskTag
            where ValidationCheck(value == 0xFFFFFFFF || (Function in {TaskManagementFunctions.AbortTask, TaskManagementFunctions.TaskReassign}), this, DiagnosisLevel.Error, iSCSI_TASK_MANEGEMENT_STR);
        uint CmdSN;
        uint ExpStatSN;
        uint RefCmdSN;
        uint ExpDataSN;
        array<byte> Reserved3 with BinaryEncoding{Length = 8};
        
        // Optional Fields, ingnored the decoding for the existence and type of digests are negotiated during the Login Phase.
        optional uint HeaderDigest with Encoding{Ignore = true};
        
        // Message summary
        override string ToString()
        {
            return "SCSI Task Management Function Request, Function = " + TaskManagementFunctionsMap[Function];
        }
    }
    
    // [RFC 3720] 10.6.  Task Management Function Response
    message ScsiTaskManagementFunctionResponse : FeatureMessage
    {
        // Basic Header Segment (BHS) 
        byte Reserved1 with BinaryEncoding{Width = 2};
        (Opcodes where value == Opcodes.ScsiTaskManagementFunctionResponse) Opcode with BinaryEncoding{Width = 6};
        
        bool F where ValidationCheck(value == true, this, "iSCSI: The F bit in ScsiTaskManagementFunctionResponse message should be set to 1.") with BinaryEncoding{Width = 1};
        byte Reserved2 with BinaryEncoding{Width = 7};
        
        byte Response;
        byte Reserved3;
        byte TotalAHSLength where ValidationCheckZero(value == 0x00, this, true, ReferenceType.Message, "iSCSI", "TotalAHSLength", "ScsiTaskManagementFunctionResponse", value);
        uint DataSegmentLength where ValidationCheckZero(value == 0x00, this, true, ReferenceType.Message, "iSCSI", "DataSegmentLength", "ScsiTaskManagementFunctionResponse", value) with BinaryEncoding{Width = 24};
        array<byte> Reserved4 with BinaryEncoding{Length = 8};
        uint InitiatorTaskTag;
        array<byte> Reserved5 with BinaryEncoding{Length = 4};
        uint StatSN;
        uint ExpCmdSN;
        uint MaxCmdSN;
        array<byte> Reserved6 with BinaryEncoding{Length = 12};
        
        // Optional Fields, ingnored the decoding for the existence and type of digests are negotiated during the Login Phase.
        optional uint HeaderDigest with Encoding{Ignore = true};
        
        // Message summary
        override string ToString()
        {
            return "Task Management Function Response, Response = " +
                (TaskManagementFunctionResponseMap.Keys[Response]? TaskManagementFunctionResponseMap[Response] : "Reserved");
        }
    }
    
    // [RFC 3720] 10.7.  SCSI Data-Out & SCSI Data-In
    message ScsiDataOut : FeatureMessage
    {
        // Basic Header Segment (BHS)
        byte Reserved with BinaryEncoding{Width = 1};
        bool I with BinaryEncoding{Width = 1};
        (Opcodes where value == Opcodes.ScsiDataOut) Opcode with BinaryEncoding{Width = 6};
        
        bool F with BinaryEncoding{Width = 1};
        uint Reserved2 with BinaryEncoding{Width = 23};
        
        byte TotalAHSLength where ValidationCheckZero(value == 0x00, this, true, ReferenceType.Message, "iSCSI", "TotalAHSLength", "ScsiDataOut", value);
        uint DataSegmentLength with BinaryEncoding{Width = 24};
        long LogicalUnitNumber;
        uint InitiatorTaskTag;
        uint TargetTransferTag;
        array<byte> Reserved3 with BinaryEncoding{Length = 4};
        uint ExpStatSN;
        array<byte> Reserved4 with BinaryEncoding{Length = 4};
        uint DataSN;
        uint BufferOffset;
        array<byte> Reserved5 with BinaryEncoding{Length = 4};
        
        // Optional Fields, ingnored the decoding for the existence and type of digests are negotiated during the Login Phase.
        optional uint HeaderDigest with Encoding{Ignore = true};
        (binary | any) DataSegment with Encoding{Ignore = true};
        optional array<byte> Padding with Encoding{Ignore = true};
        optional uint DataDigest with Encoding{Ignore = true};
        
        // Message summary
        override string ToString()
        {
            return "SCSI Data-Out (for WRITE operations),  DataSN = " + (DataSN as string);
        }
    }

    message ScsiDataIn : FeatureMessage
    {
        // Basic Header Segment (BHS) 
        byte Reserved1 with BinaryEncoding{Width = 2};
        (Opcodes where value == Opcodes.ScsiDataIn) Opcode with BinaryEncoding{Width = 6};
        
        ScsiDataInFlags Flags;
        byte Reserved2;
        byte Status;
        byte TotalAHSLength where ValidationCheckZero(value == 0x00, this, true, ReferenceType.Message, "iSCSI", "TotalAHSLength", "ScsiDataIn", value);
        uint DataSegmentLength with BinaryEncoding{Width = 24};
        ulong LogicalUnitNumber;
        uint InitiatorTaskTag;
        uint TargetTransferTag;
        uint StatSN;
        uint ExpCmdSN;
        uint MaxCmdSN;
        uint DataSN;
        uint BufferOffset;
        uint ResidualCount;
        
        // Optional Fields, ingnored the decoding for the existence and type of digests are negotiated during the Login Phase.
        optional uint HeaderDigest with Encoding{Ignore = true};
        (binary | any) DataSegment with Encoding{Ignore = true};
        optional array<byte> Padding with Encoding{Ignore = true};
        optional uint DataDigest with Encoding{Ignore = true};
        
        // Message summary
        override string ToString()
        {
            return "SCSI Data-In (for READ operations), DataSN = " + (DataSN as string);
        }
    }
    
    // [RFC 3720] 10.8.  Ready To Transfer (R2T)
    message ReadyToTransfer : FeatureMessage
    {
        // Basic Header Segment (BHS) 
        byte Reserved1 with BinaryEncoding{Width = 2};
        (Opcodes where value == Opcodes.ReadyToTransfer) Opcode with BinaryEncoding{Width = 6};
        
        bool F where ValidationCheck(value == true, this, "iSCSI: The F bit in ReadyToTransfer message should be set to 1.") with BinaryEncoding{Width = 1};
        uint Reserved2 with BinaryEncoding{Width = 23};
        byte TotalAHSLength where ValidationCheckZero(value == 0x00, this, true, ReferenceType.Message, "iSCSI", "TotalAHSLength", "ReadyToTransfer", value);
        uint DataSegmentLength where ValidationCheckZero(value == 0x00, this, true, ReferenceType.Message, "iSCSI", "DataSegmentLength", "ReadyToTransfer", value) with BinaryEncoding{Width = 24};
        ulong LogicalUnitNumber;
        uint InitiatorTaskTag;
        uint TargetTransferTag;
        uint StatSN;
        uint ExpCmdSN;
        uint MaxCmdSN;
        uint R2tsn;
        uint BufferOffset;
        uint DesiredDataTransferLength;
        
        // Optional Fields, ingnored the decoding for the existence and type of digests are negotiated during the Login Phase.
        optional uint HeaderDigest with Encoding{Ignore = true};
        
        // Message summary
        override string ToString()
        {
            return "Ready To Transfer, R2TSN = " + (R2tsn as string);
        }
    }
    
    // [RFC 3720] 10.9.  Asynchronous Message
    message AsynchronousMessage : FeatureMessage
    {
        // Basic Header Segment (BHS) 
        byte Reserved1 with BinaryEncoding{Width = 2};
        (Opcodes where value == Opcodes.AsynchronousMessage) Opcode with BinaryEncoding{Width = 6};
        
        bool F where ValidationCheck(value == true, this, "iSCSI: The F bit in message AsynchronousMessage should be set to 1.") with BinaryEncoding{Width = 1};
        uint Reserved2 with BinaryEncoding{Width = 23};
        byte TotalAHSLength where ValidationCheckZero(value == 0x00, this, true, ReferenceType.Message, "iSCSI", "TotalAHSLength", "AsynchronousMessage", value);
        uint DataSegmentLength with BinaryEncoding{Width = 24};
        ulong LogicalUnitNumber;
        uint InitiatorTaskTag where ValidationCheck(value == 0xffffffff, this, "iSCSI: The InitiatorTaskTag field in message AsynchronousMessage must be 0xffffffff.");
        uint Reserved3;
        uint StatSN;
        uint ExpCmdSN;
        uint MaxCmdSN;
        byte AsyncEvent;
        byte AsyncVCode;
        ushort Parameter1;
        ushort Parameter2;
        ushort Parameter3;
        array<byte> Reserved4 with BinaryEncoding{Length = 4};
        
        // Optional Fields, ingnored the decoding for the existence and type of digests are negotiated during the Login Phase.
        optional uint HeaderDigest with Encoding{Ignore = true};
        optional SenseDataAndiSCSIEventData[DataSegmentLength] SenseDataAndiSCSIEventData with Encoding{Ignore = true};
        optional uint DataDigest with Encoding{Ignore = true};
        
        // Message summary
        override string ToString()
        {
            return "Asynchronous Message, AsyncEvent = " +
                (AsyncEventMap.Keys[AsyncEvent]? AsyncEventMap[AsyncEvent] : AsyncEvent as string);
        }
    }
    
    // [RFC 3720] 10.10.  Text Request
    message TextRequest : NegotiationMessage
    {
        // Basic Header Segment (BHS)
        byte Reserved with BinaryEncoding{Width = 1};
        bool I with BinaryEncoding{Width = 1};
        (Opcodes where value == Opcodes.TextRequest) Opcode with BinaryEncoding{Width = 6};
        
        bool F with BinaryEncoding{Width = 1};
        bool C where ValidationCheck((C && !F) || (!C), this, Format(iSCSI_C_BIT_STR, "TextRequest", "F"))
            with BinaryEncoding{Width = 1};
        uint Reserved2 with BinaryEncoding{Width = 22};
        
        byte TotalAHSLength where ValidationCheckZero(value == 0x00, this, true, ReferenceType.Message, "iSCSI", "TotalAHSLength", "TextRequest", value);
        uint DataSegmentLength with BinaryEncoding{Width = 24};
        long LogicalUnitNumber;
        uint InitiatorTaskTag;
        uint TargetTransferTag;
        uint CmdSN;
        uint ExpStatSN;
        array<byte> Reserved4 with BinaryEncoding{Length = 16};
        
        // Optional Fields, ingnored the decoding for the existence and type of digests are negotiated during the Login Phase.
        optional uint HeaderDigest with Encoding{Ignore = true};
        (binary | map<string, string> | any) Text with Encoding{Ignore = true};
        optional array<byte> Padding with Encoding{Ignore = true};
        optional uint DataDigest with Encoding{Ignore = true};
        
        // Message summary
        override string ToString()
        {
            string summary = "Text Request";
            return ((this#IsReassembled == nothing) ? (summary + (C ? ", Text to be continued" : "")): ("[Reassembled Data Segment] " + summary));
        }
    }

    // [RFC 3720] 10.11.  Text Response
    message TextResponse : NegotiationMessage
    {
        // Basic Header Segment (BHS)
        byte Reserved with BinaryEncoding{Width = 2};
        (Opcodes where value == Opcodes.TextResponse) Opcode with BinaryEncoding{Width = 6};
        
        bool F with BinaryEncoding{Width = 1};
        bool C where ValidationCheck((C && !F) || (!C), this, Format(iSCSI_C_BIT_STR, "TextResponse", "F"))
            with BinaryEncoding{Width = 1};
        uint Reserved2 with BinaryEncoding{Width = 22};
        
        byte TotalAHSLength where ValidationCheckZero(value == 0x00, this, true, ReferenceType.Message, "iSCSI", "TotalAHSLength", "TextResponse", value);
        uint DataSegmentLength with BinaryEncoding{Width = 24};
        long LogicalUnitNumber;
        uint InitiatorTaskTag;
        uint TargetTransferTag;
        uint CmdSN;
        uint ExpStatSN;
        array<byte> Reserved4 with BinaryEncoding{Length = 16};
        
        // Optional Fields, ingnored the decoding for the existence and type of digests are negotiated during the Login Phase.
        optional uint HeaderDigest with Encoding{Ignore = true};
        (binary | map<string, string> | any) Text with Encoding{Ignore = true};
        optional array<byte> Padding with Encoding{Ignore = true};
        optional uint DataDigest with Encoding{Ignore = true};
        
        // Message summary
        override string ToString()
        {
            string summary = "Text Response";
            return ((this#IsReassembled == nothing)? (summary + (C ? ", Text to be continued" : "")): ("[Reassembled Data Segment] " + summary));
        }
    }
    
    // [RFC 3720] 10.12.  Login Request
    message LoginRequest : NegotiationMessage
    {
        // Basic Header Segment (BHS)
        byte Reserved1 with BinaryEncoding{Width = 1};
        bool I with BinaryEncoding{Width = 1};
        (Opcodes where value == Opcodes.LoginRequest) Opcode with BinaryEncoding{Width = 6};
        
        bool T with BinaryEncoding{Width = 1};
        bool C where ValidationCheck((C && !T) || (!C), this, Format(iSCSI_C_BIT_STR, "LoginRequest", "T"))
            with BinaryEncoding{Width = 1};
        byte Reserved2 with BinaryEncoding{Width = 2};
        byte Csg with BinaryEncoding{Width = 2};
        byte Nsg with BinaryEncoding{Width = 2};
        
        byte VersionMax;
        byte VersionMin;
        byte TotalAHSLength where ValidationCheckZero(value == 0x00, this, true, ReferenceType.Message, "iSCSI", "TotalAHSLength", "LoginRequest", value);
        uint DataSegmentLength with BinaryEncoding{Width = 24};
        Isid Isid;
        ushort Tsih;
        uint InitiatorTaskTag;
        uint Cid with BinaryEncoding{Width = 24};
        byte Reserved3;
        uint CmdSN;
        uint ExpStatSN;
        array<byte> Reserved4 with BinaryEncoding{Length = 16};
        (binary | map<string, string> | any) LoginParameters with Encoding{Ignore = true};
        optional array<byte> Padding with Encoding{Ignore = true};
        
        // Message summary
        override string ToString()
        {
            string summary = "Login Request, Current Stage = " + StageCodesToText(Csg) + 
                    ", Next Stage = " + StageCodesToText(Nsg);
            if (this#IsReassembled == nothing)
            {
                return summary + (C ? ", Text to be continued" : "");
            }
            else
            {
                return "[Reassembled Data Segment] " + summary;
            }
        }
    }
    
    // [RFC 3720] 10.13.  Login Response
    message LoginResponse : NegotiationMessage
    {
        // Basic Header Segment (BHS)
        byte Reserved1 with BinaryEncoding{Width = 1};
        bool I with BinaryEncoding{Width = 1};
        (Opcodes where value == Opcodes.LoginResponse) Opcode with BinaryEncoding{Width = 6};
        
        bool T with BinaryEncoding{Width = 1};
        bool C where ValidationCheck((C && !T) || (!C), this, Format(iSCSI_C_BIT_STR, "LoginResponse", "T"))
            with BinaryEncoding{Width = 1};
        byte Reserved2 with BinaryEncoding{Width = 2};
        byte Csg with BinaryEncoding{Width = 2};
        byte Nsg with BinaryEncoding{Width = 2};
        
        byte VersionMax;
        byte VersionMin;
        byte TotalAHSLength where ValidationCheckZero(value == 0x00, this, true, ReferenceType.Message, "iSCSI", "TotalAHSLength", "LoginResponse", value);
        uint DataSegmentLength with BinaryEncoding{Width = 24};
        Isid Isid;
        ushort Tsih;
        uint InitiatorTaskTag;
        uint Cid with BinaryEncoding{Width = 24};
        byte Reserved3;
        uint CmdSN;
        uint ExpStatSN;
        uint MaxCmdSN;
        byte StatusClass where ErrorCodeIf(value in {2, 3}, this, DiagnosisLevel.Error, "Login error");
        byte StatusDetails;
        array<byte> Reserved4 with BinaryEncoding{Length = 10};
        (binary | map<string, string> | any) LoginParameters with Encoding{Ignore = true};
        optional array<byte> Padding with Encoding{Ignore = true};
        
        // Message summary
        override string ToString()
        {
            string summary = (T ? (Nsg == 3 ? "Final ": ""): "Partial ") +
                    "Login Response, Status = " + (StatusClassesMap.Keys[StatusClass] ? StatusClassesMap[StatusClass] : StatusClass as string);
            if (this#IsReassembled == nothing)
            {
                return  summary + (C ? ", Text to be continued" : "");
            }
            else
            {
                return "[Reassembled Data Segment] " + summary;
            }
        }
    }
    
    // [RFC 3720] 10.14.  Logout Request
    message LogoutRequest
    {
        // Basic Header Segment (BHS)
        byte Reserved1 with BinaryEncoding{Width = 1};
        bool I with BinaryEncoding{Width = 1};
        (Opcodes where value == Opcodes.LogoutRequest) Opcode with BinaryEncoding{Width = 6};
        
        bool F where ValidationCheck(value == true, this, "iSCSI: The F bit in LogoutRequest message should be set to 1.") with BinaryEncoding{Width = 1};
        byte ReasonCode with BinaryEncoding{Width = 7};
        
        array<byte> Reserved2 with BinaryEncoding{Length = 2};
        byte TotalAHSLength where ValidationCheckZero(value == 0x00, this, true, ReferenceType.Message, "iSCSI", "TotalAHSLength", "LogoutRequest", value);
        uint DataSegmentLength where ValidationCheckZero(value == 0x00, this, true, ReferenceType.Message, "iSCSI", "DataSegmentLength", "LogoutRequest", value) with BinaryEncoding{Width = 24};
        array<byte> Reserved3 with BinaryEncoding{Length = 8};
        uint InitiatorTaskTag;
        ushort Cid;
        array<byte> Reserved4 with BinaryEncoding{Length = 2};
        uint CmdSN;
        uint ExpStatSN;
        array<byte> Reserved5 with BinaryEncoding{Length = 16};
        
        // Optional Fields, ingnored the decoding for the existence and type of digests are negotiated during the Login Phase.
        optional uint HeaderDigest with Encoding{Ignore = true};
        
        // Message summary
        override string ToString()
        {
            return "Logout Request, ReasonCode = " + (ReasonCodesMap.Keys[ReasonCode]? ReasonCodesMap[ReasonCode] : ReasonCode as string);
        }
    }
    
    // [RFC 3720] 10.15.  Logout Response
    message LogoutResponse
    {
        // Basic Header Segment (BHS)
        byte Reserved1 with BinaryEncoding{Width = 2};
        (Opcodes where value == Opcodes.LogoutResponse) Opcode with BinaryEncoding{Width = 6};
        
        bool F where ValidationCheck(value == true, this, "iSCSI: The F bit in LogoutResponse message should be set to 1.") with BinaryEncoding{Width = 1};
        byte Reserved2 with BinaryEncoding{Width = 7};
        
        byte Response;
        byte Reserved3;
        byte TotalAHSLength where ValidationCheckZero(value == 0x00, this, true, ReferenceType.Message, "iSCSI", "TotalAHSLength", "LogoutResponse", value);
        uint DataSegmentLength where ValidationCheckZero(value == 0x00, this, true, ReferenceType.Message, "iSCSI", "DataSegmentLength", "LogoutResponse", value) with BinaryEncoding{Width = 24};
        array<byte> Reserved4 with BinaryEncoding{Length = 8};
        uint InitiatorTaskTag;
        array<byte> Reserved5 with BinaryEncoding{Length = 4};
        uint StatSN;
        uint ExpCmdSN;
        uint MaxCmdSN;
        array<byte> Reserved6 with BinaryEncoding{Length = 4};
        ushort Time2Wait;
        ushort Time2Retain;
        array<byte> Reserved7 with BinaryEncoding{Length = 4};
        
        // Optional Fields, ingnored the decoding for the existence and type of digests are negotiated during the Login Phase.
        optional uint HeaderDigest with Encoding{Ignore = true};
        
        // Message summary
        override string ToString()
        {
            return "Logout Response, Response = " + (LogoutResponseMap.Keys[Response]? LogoutResponseMap[Response] : Response as string);
        }
    }
    
    // [RFC 3720] 10.16.  Snack Request
    message SnackRequest : FeatureMessage
    {
        // Basic Header Segment (BHS)
        byte Reserved1 with BinaryEncoding{Width = 2};
        (Opcodes where value == Opcodes.SnackRequest) Opcode with BinaryEncoding{Width = 6};
        
        bool F where ValidationCheck(value == true, this, "iSCSI: The F bit in SnackRequest message should be set to 1.") with BinaryEncoding{Width = 1};
        bool Reserved2 with BinaryEncoding{Width = 3};
        byte Type with BinaryEncoding{Width = 4};
        
        array<byte> Reserved3 with BinaryEncoding{Length = 2};
        byte TotalAHSLength where ValidationCheckZero(value == 0x00, this, true, ReferenceType.Message, "iSCSI", "TotalAHSLength", "SnackRequest", value);
        uint DataSegmentLength where ValidationCheckZero(value == 0x00, this, true, ReferenceType.Message, "iSCSI", "DataSegmentLength", "SnackRequest", value) with BinaryEncoding{Width = 24};
        ulong LogicalUnitNumber;
        uint InitiatorTaskTag where ValidationCheck((value == 0xffffffff && Type in {SnackRequestType.StatusSnack, SnackRequestType.DataAck}) || !(Type in {SnackRequestType.StatusSnack, SnackRequestType.DataAck}),
            this, DiagnosisLevel.Error, "iSCSI: The InitiatorTaskTag field in SnackRequest message must be set to 0xffffffff when Status is one of SNACK and DataACK.");
        uint TargetTransferTag where ValidationCheck((value == 0xffffffff && !(Type in {SnackRequestType.RDataSnack, SnackRequestType.DataAck})) || Type in {SnackRequestType.RDataSnack, SnackRequestType.DataAck},
            this, DiagnosisLevel.Error, "iSCSI: The TargetTransferTag field in SnackRequest message must be set to 0xffffffff when Status is not one of RDataSnack and DataAck.");
        array<byte> Reserved4 with BinaryEncoding{Length = 4};
        uint ExpStatSN;
        array<byte> Reserved5 with BinaryEncoding{Length = 8};
        uint BegRun;
        uint RunLength;
        
        // Optional Fields, ingnored the decoding for the existence and type of digests are negotiated during the Login Phase.
        optional uint HeaderDigest with Encoding{Ignore = true};
        
        // Message summary
        override string ToString()
        {
            return "Snack Request, Type = " + (SnackRequestTypesMap.Keys[Type]? SnackRequestTypesMap[Type] : Type as string);
        }
    }
    
    // [RFC 3720] 10.17.  Reject
    message Reject : FeatureMessage
    {
        // Basic Header Segment (BHS)
        byte Reserved1 with BinaryEncoding{Width = 2};
        (Opcodes where value == Opcodes.Reject) Opcode with BinaryEncoding{Width = 6};
        
        bool F where ValidationCheck(value == true, this, "iSCSI: The F bit in Reject message should be set to 1.") with BinaryEncoding{Width = 1};
        uint Reserved2 with BinaryEncoding{Width = 7};
        
        byte Reason;
        byte Reserved3;
        byte TotalAHSLength where ValidationCheckZero(value == 0x00, this, true, ReferenceType.Message, "iSCSI", "TotalAHSLength", "Reject", value);
        uint DataSegmentLength with BinaryEncoding{Width = 24};
        array<byte> Reserved4 with BinaryEncoding{Length = 8};
        uint InitiatorTaskTag where ValidationCheck(value == 0xffffffff, this, "iSCSI: The InitiatorTaskTag field in Reject message must be 0xffffffff.");
        array<byte> Reserved5 with BinaryEncoding{Length = 4};
        uint StatSN;
        uint ExpStatSN;
        uint MaxCmdSN;
        uint DataSNOrR2TSN;
        array<byte> Reserved6 with BinaryEncoding{Length = 8};
        
        // Optional Fields, ingnored the decoding for the existence and type of digests are negotiated during the Login Phase.
        optional uint HeaderDigest with Encoding{Ignore = true};
        binary CompleteHeaderOfBadPDU with Encoding{Ignore = true};
        binary VendorSpecificData with Encoding{Ignore = true};
        optional array<byte> Padding with Encoding{Ignore = true};
        optional uint DataDigest with Encoding{Ignore = true};
        
        // Message summary
        override string ToString()
        {
            return "Reject, Reason = " + (RejectReasonsMap.Keys[Reason]? RejectReasonsMap[Reason] : Reason as string);
        }
    }
    
    // [RFC 3720] 10.18.  NOP-Out
    message NopOut : FeatureMessage
    {
        // Basic Header Segment (BHS) 
        byte Reserved1 with BinaryEncoding{Width = 1};
        bool I with BinaryEncoding{Width = 1};
        (Opcodes where value == Opcodes.NopOut) Opcode with BinaryEncoding{Width = 6};
        
        bool F where ValidationCheck(value == true, this, "iSCSI: The F bit in NopOut message should be set to 1.") with BinaryEncoding{Width = 1};
        uint Reserved2 with BinaryEncoding{Width = 23};
        
        byte TotalAHSLength where ValidationCheckZero(value == 0x00, this, true, ReferenceType.Message, "iSCSI", "TotalAHSLength", "NopOut", value);
        uint DataSegmentLength with BinaryEncoding{Width = 24};
        ulong LogicalUnitNumber;
        uint InitiatorTaskTag where ValidationCheck(value != 0xffffffff || I, this, "iSCSI: The I bit in NopOut message must be set to 1 when the InitiatorTaskTag contains 0xFFFFFFFF.");
        uint TargetTransferTag;
        uint CmdSN;
        uint ExpStatSN;
        array<byte> Reserved3 with BinaryEncoding{Length = 16};
        
        // Optional Fields, ingnored the decoding for the existence and type of digests are negotiated during the Login Phase.
        optional uint HeaderDigest with Encoding{Ignore = true};
        optional binary PingData with Encoding{Ignore = true};
        optional array<byte> Padding with Encoding{Ignore = true};
        optional uint DataDigest with Encoding{Ignore = true};
        
        // Message summary
        override string ToString()
        {
            return "NOP-Out";
        }
    }
    
    // [RFC 3720] 10.19.  NOP-In
    message NopIn : FeatureMessage
    {
        // Basic Header Segment (BHS) 
        byte Reserved1 with BinaryEncoding{Width = 2};
        (Opcodes where value == Opcodes.NopIn) Opcode with BinaryEncoding{Width = 6};
        
        bool F where ValidationCheck(value == true, this, "iSCSI: The F bit in NopIn message should be set to 1.") with BinaryEncoding{Width = 1};
        uint Reserved2 with BinaryEncoding{Width = 23};
        
        byte TotalAHSLength where ValidationCheckZero(value == 0x00, this, true, ReferenceType.Message, "iSCSI", "TotalAHSLength", "NopIn", value);
        uint DataSegmentLength with BinaryEncoding{Width = 24};
        ulong LogicalUnitNumber;
        uint InitiatorTaskTag;
        uint TargetTransferTag;
        uint StatSN;
        uint ExpStatSN;
        uint MaxCmdSN;
        array<byte> Reserved3 with BinaryEncoding{Length = 12};
        
        // Optional Fields, ingnored the decoding for the existence and type of digests are negotiated during the Login Phase.
        optional uint HeaderDigest with Encoding{Ignore = true};
        optional binary PingData with Encoding{Ignore = true};
        optional array<byte> Padding with Encoding{Ignore = true};
        optional uint DataDigest with Encoding{Ignore = true};
        
        // Message summary
        override string ToString()
        {
            return "NOP-In";
        }
    }
    
    // 10.  iSCSI PDU Formats
    message VendorSpecificMessage : FeatureMessage
    {
        // Basic Header Segment (BHS) 
        byte Reserved1 with BinaryEncoding{Width = 1};
        bool I with BinaryEncoding{Width = 1};
        (Opcodes where (value >= 0x1c && value <= 0x1e) || (value >= 0x3c && value <= 0x3e)) Opcode with BinaryEncoding{Width = 6};
        
        bool F where ValidationCheck(value == true, this, "iSCSI: The F bit in message VendorSpecificMessage should be set to 1.") with BinaryEncoding{Width = 1};
        uint OpcodeSpecificFields1 with BinaryEncoding{Width = 23};
        
        byte TotalAHSLength;
        uint DataSegmentLength with BinaryEncoding{Width = 24};
        Blob[40] OpcodeSpecificFields2;
        
        // Optional Fields
        // Will limit the data to the expected array size in the message decoding.
        optional [|TotalAHSLength > 0|] array<AdditionalHeaderSegment> AHS;
        // Ingnored the decoding for the existence and type of digests are negotiated during the Login Phase.
        optional uint HeaderDigest with Encoding{Ignore = true};
        optional binary DataSegment with Encoding{Ignore = true};
        optional array<byte> Padding with Encoding{Ignore = true};
        optional uint DataDigest with Encoding{Ignore = true};
        
        // Message summary
        override string ToString()
        {
            return "Vendor Specific, Opcode = " + (Opcode as string);
        }
    }
}

contract VirtualOperations
{
    issues virtual operation ScsiCommandOperation
    {
        in optional ScsiCommandDescriptorBlock ScsiCommandDescriptorBlock = (cdb is ScsiCommandDescriptorBlock) ? (cdb as ScsiCommandDescriptorBlock) : nothing;
        in optional VariableLengthCommandDescriptorBlock VariableLengthCommandDescriptorBlock = vcdb;
        out Status Status = status;
        
        override string ToString()
        {
            string summary = "SCSI Command: ";
            if (ScsiCommandDescriptorBlock != nothing)
            {
                summary += ScsiCommandDescriptorBlock.ToString();
            }
            else if (VariableLengthCommandDescriptorBlock != nothing)
            {
                summary += VariableLengthCommandDescriptorBlock.ToString();
            }
            else
            {
                summary += "Unknown";
            }
            summary += ", Status: " + StatusToText(Status);
            if (ScsiCommandDescriptorBlock is cdb:ScsiCommandDescriptorBlock)
            {
                summary += GetScsiCommandDescriptorBlockSummaryString(cdb);
            }
            else if (VariableLengthCommandDescriptorBlock is vcdb:VariableLengthCommandDescriptorBlock)
            {
                summary += GetVariableLengthCommandDescriptorBlockSummaryString(vcdb);
            }
            return summary;
        }
    }
    =
    accepts Messages.ScsiCommand{InitiatorTaskTag is var tag, ScsiCommandDescriptorBlock is var cdb, VariableLengthCommandDescriptorBlock is var vcdb}
    issues Messages.ScsiResponse{InitiatorTaskTag == tag, Status is var status};
    
    issues virtual operation ScsiCommandDataIn
    {
        in uint InitiatorTaskTag = tag;
        in optional ScsiCommandDescriptorBlock ScsiCommandDescriptorBlock = (cdb is ScsiCommandDescriptorBlock) ? (cdb as ScsiCommandDescriptorBlock) : nothing;
        in optional VariableLengthCommandDescriptorBlock VariableLengthCommandDescriptorBlock = vcdb;
        
        override string ToString()
        {
            string summary = "SCSI Command: ";
            if (ScsiCommandDescriptorBlock != nothing)
            {
                summary += ScsiCommandDescriptorBlock.ToString();
            }
            else if (VariableLengthCommandDescriptorBlock != nothing)
            {
                summary += VariableLengthCommandDescriptorBlock.ToString();
            }
            else
            {
                summary += "Unknown";
            }
            summary += ", Data-In";
            if (ScsiCommandDescriptorBlock is cdb:ScsiCommandDescriptorBlock)
            {
                summary += GetScsiCommandDescriptorBlockSummaryString(cdb);
            }
            else if (VariableLengthCommandDescriptorBlock is vcdb:VariableLengthCommandDescriptorBlock)
            {
                summary += GetVariableLengthCommandDescriptorBlockSummaryString(vcdb);
            }
            return summary;
        }
    }
    =
    accepts Messages.ScsiCommand{InitiatorTaskTag is var tag, ScsiCommandDescriptorBlock is var cdb, VariableLengthCommandDescriptorBlock is var vcdb}
    issues Messages.ScsiDataIn{InitiatorTaskTag == tag};
    
    issues virtual operation ScsiCommandDataInWithResponse
    {
        in optional ScsiCommandDescriptorBlock ScsiCommandDescriptorBlock = cdb;
        in optional VariableLengthCommandDescriptorBlock VariableLengthCommandDescriptorBlock = vcdb;
        out Status Status = status;
        
        override string ToString()
        {
            string summary = "SCSI Command: ";
            if (ScsiCommandDescriptorBlock != nothing)
            {
                summary += ScsiCommandDescriptorBlock.ToString();
            }
            else if (VariableLengthCommandDescriptorBlock != nothing)
            {
                summary += VariableLengthCommandDescriptorBlock.ToString();
            }
            else
            {
                summary += "Unknown";
            }
            summary += ", Data-In, Status: " + StatusToText(Status);
            if (ScsiCommandDescriptorBlock is cdb:ScsiCommandDescriptorBlock)
            {
                summary += GetScsiCommandDescriptorBlockSummaryString(cdb);
            }
            else if (VariableLengthCommandDescriptorBlock is vcdb:VariableLengthCommandDescriptorBlock)
            {
                summary += GetVariableLengthCommandDescriptorBlockSummaryString(vcdb);
            }
            return summary;
        }
    }
    =
    issues VirtualOperations.ScsiCommandDataIn{InitiatorTaskTag is var tag, ScsiCommandDescriptorBlock is var cdb, VariableLengthCommandDescriptorBlock is var vcdb}
    issues Messages.ScsiResponse{InitiatorTaskTag == tag, Status is var status};

    issues virtual operation Login
    {
        in bool T = t;
        in bool C = c;
        in byte Csg = csg;
        in byte Nsg = nsg;
        out byte StatusClass = status;
        
        override string ToString()
        {
            string summary = "Login, Current Stage: " + StageCodesToText(Csg) + ", Next Stage: " + StageCodesToText(Nsg);
            summary += ", Status: " + (StatusClassesMap.Keys[StatusClass] ? StatusClassesMap[StatusClass] : StatusClass as string);
            return summary;
        }
    }
    =
    accepts Messages.LoginRequest{T is var t, C is var c, Csg is var csg, Nsg is var nsg}
    issues Messages.LoginResponse{StatusClass is var status};

    issues virtual operation Logout
    {
        in byte ReasonCode = reason;
        out byte Response = response;
        
        override string ToString()
        {
            string summary = "Logout, ReasonCode: " + (ReasonCodesMap.Keys[ReasonCode]? ReasonCodesMap[ReasonCode] : ReasonCode as string);
            summary += ", Response: " + (LogoutResponseMap.Keys[Response]? LogoutResponseMap[Response] : Response as string);
            return summary;
        }
    }
    =
    accepts Messages.LogoutRequest{ReasonCode is var reason}
    issues Messages.LogoutResponse{Response is var response};
    
    issues virtual operation Text
    {
        override string ToString()
        {
            return "Text Request/Response";
        }
    }
    =
    accepts Messages.TextRequest{InitiatorTaskTag is var tag}
    issues Messages.TextResponse{InitiatorTaskTag == tag};
    
    issues virtual operation ScsiCommandUnsolicitedDataOut
    {
        in uint InitiatorTaskTag = tag;
        in optional ScsiCommandDescriptorBlock ScsiCommandDescriptorBlock = (cdb is ScsiCommandDescriptorBlock) ? (cdb as ScsiCommandDescriptorBlock) : nothing;
        in optional VariableLengthCommandDescriptorBlock VariableLengthCommandDescriptorBlock = vcdb;
        out Status Status = status;
        
        override string ToString()
        {
            string summary = "SCSI Command: ";
            if (ScsiCommandDescriptorBlock != nothing)
            {
                summary += ScsiCommandDescriptorBlock.ToString();
            }
            else if (VariableLengthCommandDescriptorBlock != nothing)
            {
                summary += VariableLengthCommandDescriptorBlock.ToString();
            }
            else
            {
                summary += "Unknown";
            }
            summary += ", Unsolicited Data-Out, Status: " + StatusToText(Status);
            if (ScsiCommandDescriptorBlock is cdb:ScsiCommandDescriptorBlock)
            {
                summary += GetScsiCommandDescriptorBlockSummaryString(cdb);
            }
            else if (VariableLengthCommandDescriptorBlock is vcdb:VariableLengthCommandDescriptorBlock)
            {
                summary += GetVariableLengthCommandDescriptorBlockSummaryString(vcdb);
            }
            return summary;
        }
    }
    =
    accepts Messages.ScsiCommand{InitiatorTaskTag is var tag, ScsiCommandDescriptorBlock is var cdb, VariableLengthCommandDescriptorBlock is var vcdb}
    accepts Messages.ScsiDataOut{InitiatorTaskTag == tag}
    issues Messages.ScsiResponse{InitiatorTaskTag == tag, Status is var status};
    
    issues virtual operation NopInNopOut
    {
        in uint TargetTransferTag = tag;
        
        override string ToString()
        {
            return "Nop-In/Nop-Out";
        }
    }
    =
    issues Messages.NopIn{TargetTransferTag is var tag && TargetTransferTag != 0xFFFFFFFF && StatSN is var sn}
    accepts Messages.NopOut{TargetTransferTag == tag, ExpStatSN == sn};
    
    issues virtual operation NopOutNopIn
    {
        in uint InitiatorTaskTag = tag;
        
        override string ToString()
        {
            return "Nop-Out/Nop-In";
        }
    }
    =
    accepts Messages.NopOut{InitiatorTaskTag is var tag && InitiatorTaskTag != 0xFFFFFFFF}
    issues Messages.NopIn{InitiatorTaskTag == tag};
}

//--------------------------------------------
// Static contst

// Mapping the value GROUP CODE field to the lenth of CDB
const map<byte, byte> GroupCodeMap = {
        0 -> 6,
        1 -> 10,
        2 -> 10,
        4 -> 16,
        5 -> 12
    };

// Defines for the message summary
const map<byte, string> CommandOperationCodeMap = {
        0x89 -> "Compare And Write",
        0x04 -> "Format Unit",
        0x8b -> "OrWrite(16)",
        0x34 -> "PreFetch(10)",
        0x90 -> "PreFetch(16)",
        0x1E -> "Prevent Allow MediumRemoval",
        0x08 -> "Read(6)",
        0x28 -> "Read(10)",
        0xA8 -> "Read(12)",
        0x88 -> "Read(16)",
        0x25 -> "Read Capacity(10)",
        0x37 -> "Read Defect Data(10)",
        0xB7 -> "Read Defect Data(12)",
        0x3E -> "Read Long(10)",
        0x07 -> "Reassign Blocks",
        0x48 -> "Sanitize",
        0x1B -> "Start Stop Unit",
        0x35 -> "Synchronize Cache(10)",
        0x91 -> "Synchronize Cache(16)",
        0x42 -> "Unmap",
        0x2F -> "Verify(10)",
        0xAF -> "Verify(12)",
        0x8F -> "Verify(16)",
        0x0A -> "Write(6)",
        0x2A -> "Write(10)",
        0xAA -> "Write(12)",
        0x8A -> "Write(16)",
        0x2E -> "Write And Verify(10)",
        0xAE -> "Write And Verify(12)",
        0x8E -> "Write And Verify(16)",
        0x3F -> "Write Long(10)",
        0x9F -> "Write Long(16)",
        0x41 -> "Write Same(10)",
        0x93 -> "Write Same(16)",
        0x52 -> "XD Read(10)",
        0x50 -> "XD Write(10)",
        0x53 -> "XD Write Read(10)",
        0x51 -> "XP Write(10)",
        0x40 -> "Change Definition",
        0x17 -> "Release(6)",
        0x57 -> "Release(10)",
        0x12 -> "Inquiry",
        0x4C -> "Log Select",
        0x4D -> "Log Sense",
        0x15 -> "Mode Select(6)",
        0x55 -> "Mode Select(10)",
        0x1A -> "Mode Sense(6)",
        0x5A -> "Mode Sense(10)",
        0x5E -> "Persistent Reserve In",
        0x5F -> "Persistent Reserve Out",
        0x8D -> "Read Atrribute",
        0x3C -> "Read Buffer",
        0xAB -> "Read Media Serial Number",
        0x1C -> "Receive Diagnostic Results",
        0xA3 -> "Report Related",
        0xA0 -> "Report Luns",
        0x03 -> "Request Sense",
        0xA2 -> "Security Protocol In",
        0xB5 -> "Security Protocol Out",
        0x1D -> "Send Diagnostic",
        0x00 -> "Test Unit Ready",
        0x8D -> "Write Attribute",
        0x3B -> "Write Buffer",
    };
   
const map<byte, string> StatusMap = {
        0x00 -> "Good",
        0x02 -> "Check Condition",
        0x08 -> "Busy",
        0x18 -> "Reservation Conflict",
        0x28 -> "Task Set Full",
        0x30 -> "Aca Active",
        0x40 -> "Task Aborted",
    };
    
const map<byte, string> TaskManagementFunctionsMap = {
        1 -> "Abort Task",
        2 -> "Abort Task Set",
        3 -> "Clear Aca",
        4 -> "Clear Task Set",
        5 -> "Logical Unit Reset",
        6 -> "Target Warm Reset",
        7 -> "Target Cold Reset",
        8 -> "Task Reassign",
    };
    
const map<byte, string> TaskManagementFunctionResponseMap = {
        0 -> "Function complete",
        1 -> "Task does not exist",
        2 -> "LUN does not exist",
        3 -> "Task still allegiant",
        4 -> "Task allegiance reassignment not supported",
        5 -> "Task management function not supported",
        6 -> "Function authorization failed",
        255 -> "Function rejected",
    };

const map<byte, string> AsyncEventMap = {
        0 -> "Reported in the sense data",
        1 -> "Requests Logout",
        2 -> "Drop the connection",
        3 -> "Drop all the connections of this session",
        4 -> "Requests parameter negotiation on this connection",
        255 -> "Vendor specific iSCSI Event",
    };
    
const map<byte, string> StageCodesMap = {
        0 -> "SecurityNegotiation",
        1 -> "LoginOperationalNegotiation",
        3 -> "FullFeaturePhase",
        // All other values are reserved.
    };

const map<byte, string> StatusClassesMap  = { 
        0 -> "Success",
        1 -> "Redirection",
        2 -> "Initiator Error",
        3 -> "Target Error",
    };

const map<byte, string> ReasonCodesMap  = { 
        0 -> "Close the session",
        1 -> "Close the connection",
        2 -> "Remove the connection for recovery",
        // All other values are reserved.
     };

const map<byte, string> LogoutResponseMap = {
        0 -> "Connection or session closed successfully",
        1 -> "CID not found",
        2 -> "Connection recovery is not supported",
        3 -> "Cleanup failed for various reasons",
     };
     
const map<byte, string> SnackRequestTypesMap = {
        0 -> "DataOrR2TSnack",
        1 -> "StatusSnack",
        2 -> "DataAck",
        3 -> "RDataSnack",
    };
    
const map<byte, string> RejectReasonsMap = {
        0x01 -> "Reserved",
        0x02 -> "Data (payload) Digest Error",
        0x03 -> "SNACK Reject",
        0x04 -> "Protocol Error",
        0x05 -> "Command not supported",
        0x06 -> "Immediate Command Reject",
        0x07 -> "Task in progress",
        0x08 -> "Invalid Data ACK",
        0x09 -> "Invalid PDU field",
        0x0a -> "Long Operation Reject",
        0x0b -> "Negotiation Reset",
        0x0c -> "Waiting for Logout",
    };

//-------------------------------------------
// Data types
    
// [RFC 3720] 10.2.1.2.  Opcode
pattern Opcodes = enum byte
    {
        // Initiator opcode
        NopOut = 0x00,
        ScsiCommand = 0x01,
        ScsiTaskManagementFunctionRequest = 0x02,
        LoginRequest = 0x03,
        TextRequest = 0x04,
        ScsiDataOut = 0x05,
        LogoutRequest = 0x06,
        SnackRequest = 0x10,
        VendorSpecificCodeI0 = 0x1c,
        VendorSpecificCodeI1 = 0x1d,
        VendorSpecificCodeI2 = 0x1e,
        // Target opcode
        NopIn = 0x20,
        ScsiResponse =  0x21,
        ScsiTaskManagementFunctionResponse = 0x22,
        LoginResponse = 0x23,
        TextResponse = 0x24,
        ScsiDataIn = 0x25,
        LogoutResponse = 0x26,
        ReadyToTransfer = 0x31,
        AsynchronousMessage = 0x32,
        VendorSpecificCodesT0 = 0x3c,
        VendorSpecificCodesT1 = 0x3d,
        VendorSpecificCodesT2 = 0x3e,
        Reject =  0x3f
    };
    
// [RFC 3720] 10.2.2.  Additional Header Segment (AHS)
pattern AdditionalHeaderSegment = ExtendedCDBAHS | BidirectionalExpectedReadDataLengthAHS | ReservedAHS;

type ReservedAHS
{
    ushort AHSLength;
    byte AHSType;
    byte Reserved;
    
    binary AHSSpecifc with BinaryEncoding{Length = AHSLength - 1};
    optional [|(AHSLength - 1) % 4 > 0|] array<byte> Padding with BinaryEncoding{Length = 4 - (AHSLength - 1) % 4};
}

type AHSType
{
    byte Reserved with BinaryEncoding{Width = 2};
    AHSCode AHSCode with BinaryEncoding{Width = 6};
}

pattern AHSCode = enum byte
{
    ExtendedCDB = 1,
    ExpectedBidirectionalReadDataLength = 2,
    ...
    // Other value is reserved
};

// [RFC 3720] 10.2.2.3.  Extended CDB AHS
type ExtendedCDBAHS
{
    ushort AHSLength;
    (AHSType where value.AHSCode is AHSCode.ExtendedCDB) AHSType;
    byte Reserved;
    
    binary ExtendedCDB with BinaryEncoding{Length = AHSLength - 1};
    optional [|(AHSLength - 1) % 4 > 0|] array<byte> Padding with BinaryEncoding{Length = 4 - (AHSLength - 1) % 4};
}
        
// [RFC 3720] 10.2.2.4. Bidirectional Expected Read-Data Length AHS
type BidirectionalExpectedReadDataLengthAHS
{
    (ushort where value == 0x0005) AHSLength;
    (AHSType where value.AHSCode is AHSCode.ExpectedBidirectionalReadDataLength) AHSType;
    byte Reserved;
    uint ExpectedReadDataLength;
}

// [RFC 3720] 10.3.1. Flags and Task Attributes
type ScsiCommandFlagsAndTaskAttributes
{
    bool F with BinaryEncoding{Width = 1};
    bool R with BinaryEncoding{Width = 1};
    bool W with BinaryEncoding{Width = 1};
    byte Reserved1 with BinaryEncoding{Width = 2};
    TaskAttributesPattern ATTR with BinaryEncoding{Width = 3};
}

pattern TaskAttributesPattern = enum byte
{
    Untagged = 0,
    Simple = 1,
    Ordered = 2,
    HeaderOfQueue = 3,
    ACA = 4,
    ...
};

// [RFC 3720] 10.4.1. Flags
type ScsiResponseFlags
{
    bool F where ValidationCheck(value == true, null, "iSCSI: The F bit in type ScsiResponseFlag should be set to 1.") with BinaryEncoding{Width = 1};
    byte Reserved1 with BinaryEncoding{Width = 2};
    bool BidirectionalReadResidualOverflow with BinaryEncoding{Width = 1};
    bool BidirectionalReadResidualUnderflow with BinaryEncoding{Width = 1};
    bool ResidualOverflow with BinaryEncoding{Width = 1};
    bool ResidualUnderflow with BinaryEncoding{Width = 1};
    bool Reserved2 with BinaryEncoding{Width = 1};
}

// [RFC 3720] 10.4.2.  Status
pattern Status = enum byte
{
    Good = 0x00,
    CheckCondition = 0x02,
    Busy = 0x08,
    ReservationConflict = 0x18,
    TaskSetFull = 0x28,
    AcaActive = 0x30,
    TaskAborted = 0x40
};

string StatusToText(Status status)
{
    if (StatusMap.Keys[status])
    {
        return StatusMap[status];
    }
    else
    {
        return "Unknown Value: " + Utility.DecToHexFormat(status);
    }
}

// [RFC 3720] 10.4.3.  Response
pattern ResponseByte = enum byte
{
    CommandCompletedAtTarget = 0x00,
    TargetFailure = 0x01,
    ...
};

// [RFC 3720] 10.4.1. Flags
pattern TaskManagementFunctions = enum byte
{
    AbortTask = 1,
    AbortTaskSet = 2,
    ClearAca = 3,        
    ClearTaskSet = 4,
    LogicalUnitReset = 5,
    TargetWarmReset = 6,
    TargetColdReset = 7,
    TaskReassign = 8,
};

type SenseAndResponseDataSegment[uint DataSegmentLength]
{
    ushort SenseLength;
    Blob[SenseLength as uint] SenseData;
    optional [|DataSegmentLength - SenseLength - 2 > 0|] binary ResponseData with BinaryEncoding{Length = DataSegmentLength - SenseLength - 2};
    
    // The Data Segment is also padded to an integer number of 4 byte words.
    optional array<byte> Padding with BinaryEncoding{Length = 4 - DataSegmentLength % 4};
}

// [RFC 3720] 10.7.3.  Flags (byte 1)
type ScsiDataInFlags
{
    bool F with BinaryEncoding{Width = 1};
    bool A with BinaryEncoding{Width = 1};
    byte Reserved with BinaryEncoding{Width = 3};
    bool ResidualOverflow with BinaryEncoding{Width = 1};
    bool ResidualUnderflow with BinaryEncoding{Width = 1};
    bool S where ValidationCheck((F & S) | (!S), null, "iSCSI: The F bit in type ScsiDataInFlags must be set to 1 when bit S is set to 1.") with BinaryEncoding{Width = 1};
}

// [RFC 3720] 10.9.4.  Sense Data and iSCSI Event Data
type SenseDataAndiSCSIEventData[uint DataSegmentLength]
{
    ushort SenseLength;
    Blob[SenseLength as uint] SenseData;
    optional [|DataSegmentLength - SenseLength - 2 > 0|] binary iSCSIEventData with BinaryEncoding{Length = DataSegmentLength - SenseLength - 2};
    
    // The Data Segment is also padded to an integer number of 4 byte words.
    optional array<byte> Padding with BinaryEncoding{Length = 4 - DataSegmentLength % 4};
}

// [RFC 3720] 10.12.5.  ISID
pattern Isid = IsidOui | IsidEN | IsidRandom | IsidRerserved;

pattern IsidT = enum byte
{
    Oui =0,
    EN =1,
    Random =2,
    Reserved =3,
};
        
type IsidOui
{
    (IsidT where value == IsidT.Oui) T with BinaryEncoding{Width = 2};
    uint Oui with BinaryEncoding{Width = 22};
    uint Qualifier with BinaryEncoding{Width = 24};
}
 
type IsidEN
{
    (IsidT where value == IsidT.EN) T with BinaryEncoding{Width = 2};
    byte Reserved with BinaryEncoding{Width = 6};
    uint IanaEnterpriseNumber with BinaryEncoding{Width = 24};
    ushort Qualifier;
}

type IsidRandom
{
    (IsidT where value == IsidT.Random) T with BinaryEncoding{Width = 2};
    byte Reserved with BinaryEncoding{Width = 6};
    uint Random with BinaryEncoding{Width = 24};
    ushort Qualifier;
}

type IsidRerserved
{
    (IsidT where value == IsidT.Reserved) T with BinaryEncoding{Width = 2};
    ulong Reserved with BinaryEncoding{Width = 46};
}

// [RFC 3720] 10.16.1.  Type
pattern SnackRequestType = enum byte
{
    DataOrR2TSnack = 0,
    StatusSnack = 1,
    DataAck = 2,
    RDataSnack = 3,
};

// [SPC-4] 4.2.2.1.1 Generic 6-byte CDB format
type Generic6ByteCommandParameter
{
    array<byte> CDBInformation with BinaryEncoding{Length = 4};
    Control Control;
    array<byte> Padding with BinaryEncoding{Length = 10};
}

// [SPC-4] 4.2.2.2.1 Generic 10-byte CDB format
type Generic10ByteCommandParameter
{
    byte CDBInformation1 with BinaryEncoding{Width = 3};
    byte ServiceActionOrCDBInformation with BinaryEncoding{Width = 5};
    array<byte> CDBInformation2 with BinaryEncoding{Length = 7};
    Control Control;
    array<byte> Padding with BinaryEncoding{Length = 6};
}

// [SPC-4] 4.2.2.3.1 Generic 12-byte CDB format
type Generic12ByteCommandParameter
{
    byte CDBInformation1 with BinaryEncoding{Width = 3};
    byte ServiceActionOrCDBInformation with BinaryEncoding{Width = 5};
    array<byte> CDBInformation2 with BinaryEncoding{Length = 9};
    Control Control;
    array<byte> Padding with BinaryEncoding{Length = 4};
}

// [SPC-4] 4.2.2.4.1 Generic 16-byte CDB format
type Generic16ByteCommandParameter
{
    byte CDBInformation1 with BinaryEncoding{Width = 3};
    byte ServiceActionOrCDBInformation with BinaryEncoding{Width = 5};
    array<byte> CDBInformation2 with BinaryEncoding{Length = 13};
    Control Control;
}

// [SPC-4] Variable type data field requirements
pattern CodeSetType = enum byte
{
    Binary   = 0x01,
    ASCII    = 0x02,
    UTF8     = 0x03,
    ...
};

// [SAM2] 5.2 Command descriptor block (CDB)
type ScsiCommandDescriptorBlock
{
    (OperationCode where value.Value != CommandOperationCode.VariableLength) OperationCode;
    // Command specific parameters
    // Commands specified in [SBC-3]
    ([|OperationCode.Value == CommandOperationCode.CompareAndWrite|] CompareAndWriteCommandParameters |
        [|OperationCode.Value == CommandOperationCode.FormatUnit|] FormatUnitCommandParameters |
        [|OperationCode.Value == CommandOperationCode.OrWrite16|] OrWrite16CommandParameters |
        [|OperationCode.Value == CommandOperationCode.OperationCode83|] OperationCode83hCommandParameters |
        [|OperationCode.Value == CommandOperationCode.PreFetch10|] PreFetch10CommandParameters |
        [|OperationCode.Value == CommandOperationCode.PreFetch16|] PreFetch16CommandParameters |
        [|OperationCode.Value == CommandOperationCode.PreventAllowMediumRemoval|] PreventAllowMediumRemovalCommandParameters |
        [|OperationCode.Value == CommandOperationCode.Read6|] Read6CommandParameters |
        [|OperationCode.Value == CommandOperationCode.Read10|] Read10CommandParameters |
        [|OperationCode.Value == CommandOperationCode.Read12|] Read12CommandParameters |
        [|OperationCode.Value == CommandOperationCode.Read16|] Read16CommandParameters |
        [|OperationCode.Value == CommandOperationCode.ReadCapacity10|] ReadCapacity10CommandParameters |
        [|OperationCode.Value == CommandOperationCode.ServiceActionIn16|] ServiceActionIn16CommandParameters |
        [|OperationCode.Value == CommandOperationCode.ReadDefectData10|] ReadDefectData10CommandParameters |
        [|OperationCode.Value == CommandOperationCode.ReadDefectData12|] ReadDefectData12CommandParameters |
        [|OperationCode.Value == CommandOperationCode.ReadLong10|] ReadLong10CommandParameters |
        [|OperationCode.Value == CommandOperationCode.ReassignBlocks|] ReassignBlocksCommandParameters |
        [|OperationCode.Value == CommandOperationCode.Sanitize|] SanitizeCommandParameters |
        [|OperationCode.Value == CommandOperationCode.StartStopUnit|] StartStopUnitCommandParameters |
        [|OperationCode.Value == CommandOperationCode.SynchronizeCache10|] SynchronizeCache10CommandParameters |
        [|OperationCode.Value == CommandOperationCode.SynchronizeCache16|] SynchronizeCache16CommandParameters |
        [|OperationCode.Value == CommandOperationCode.Unmap|] UnmapCommandParameters |
        [|OperationCode.Value == CommandOperationCode.Verify10|] Verify10CommandParameters |
        [|OperationCode.Value == CommandOperationCode.Verify12|] Verify12CommandParameters |
        [|OperationCode.Value == CommandOperationCode.Verify16|] Verify16CommandParameters |
        [|OperationCode.Value == CommandOperationCode.Write6|] Write6CommandParameters |
        [|OperationCode.Value == CommandOperationCode.Write10|] Write10CommandParameters |
        [|OperationCode.Value == CommandOperationCode.Write12|] Write12CommandParameters |
        [|OperationCode.Value == CommandOperationCode.Write16|] Write16CommandParameters |
        [|OperationCode.Value == CommandOperationCode.WriteAndVerify10|] WriteAndVerify10CommandParameters |
        [|OperationCode.Value == CommandOperationCode.WriteAndVerify12|] WriteAndVerify12CommandParameters |
        [|OperationCode.Value == CommandOperationCode.WriteAndVerify16|] WriteAndVerify16CommandParameters |
        [|OperationCode.Value == CommandOperationCode.WriteLong10|] WriteLong10CommandParameters |
        [|OperationCode.Value == CommandOperationCode.WriteLong16|] WriteLong16CommandParameters |
        [|OperationCode.Value == CommandOperationCode.WriteSame10|] WriteSame10CommandParameters |
        [|OperationCode.Value == CommandOperationCode.WriteSame16|] WriteSame16CommandParameters |
        [|OperationCode.Value == CommandOperationCode.XDRead10|] XDRead10CommandParameters |
        [|OperationCode.Value == CommandOperationCode.XDWrite10|] XDWrite10CommandParameters |
        [|OperationCode.Value == CommandOperationCode.XDWriteRead10|] XDWriteRead10CommandParameters |
        [|OperationCode.Value == CommandOperationCode.XPWrite10|] XPWrite10CommandParameters |

        // Commands specified in [SPC-4] 
        [|OperationCode.Value == CommandOperationCode.ChangeDefinition|] ChangeDefinitionCommandParameters |
        [|OperationCode.Value == CommandOperationCode.ModeSelect6|] ModeSelect6CommandParameters |
        [|OperationCode.Value == CommandOperationCode.ModeSelect10|] ModeSelect10CommandParameters |
        [|OperationCode.Value == CommandOperationCode.ModeSense6|] ModeSense6CommandParameters |
        [|OperationCode.Value == CommandOperationCode.ModeSense10|] ModeSense10CommandParameters |
        [|OperationCode.Value == CommandOperationCode.PersistentReserveIn|] PersistentReserveInCommandParameters |
        [|OperationCode.Value == CommandOperationCode.PersistentReserveOut|] PersistentReserveOutCommandParameters |
        [|OperationCode.Value == CommandOperationCode.ReadBuffer|] ReadBufferCommandParameters |
        [|OperationCode.Value == CommandOperationCode.Release6|] Release6CommandParameters |
        [|OperationCode.Value == CommandOperationCode.Release10|] Release10CommandParameters |
        [|OperationCode.Value == CommandOperationCode.Inquiry|] InquiryCommandParameters |
        [|OperationCode.Value == CommandOperationCode.LogSelect|] LogSelectCommandParameters |
        [|OperationCode.Value == CommandOperationCode.LogSense|] LogSenseCommandParameters |
        [|OperationCode.Value == CommandOperationCode.ReceiveDiagnosticResults|] ReceiveDiagnosticResultsCommandParameters |
        [|OperationCode.Value == CommandOperationCode.MaintenanceIn|] MaintenanceInCommandParameters |
        [|OperationCode.Value == CommandOperationCode.ReportLuns|] ReportLunsCommandParameters |
        [|OperationCode.Value == CommandOperationCode.RequestSense|] RequestSenseCommandParameters |
        [|OperationCode.Value == CommandOperationCode.SendDiagnostic|] SendDiagnosticCommandParameters |
        [|OperationCode.Value == CommandOperationCode.TestUnitReady|] TestUnitReadyCommandParameters |
        [|OperationCode.Value == CommandOperationCode.WriteBuffer|] WriteBufferCommandParameters |
        [|OperationCode.Value == CommandOperationCode.SecurityProtocolIn|] SecurityProtocolInCommandParameters |
        [|OperationCode.Value == CommandOperationCode.SecurityProtocolOut|] SecurityProtocolOutCommandParameters |
        [|OperationCode.Value == CommandOperationCode.WriteAttribute|] WriteAttributeCommandParameters |
        [|OperationCode.Value == CommandOperationCode.MaintenanceOut|] MaintenanceOutCommandParameters |
        [|OperationCode.Value == CommandOperationCode.OperationCode84|] OperationCode84hCommandParameters |
        [|OperationCode.Value == CommandOperationCode.ReadAttribute|] ReadAttributeCommandParameters |
        [|OperationCode.Value == CommandOperationCode.ReadMediaSerialNumber|] ReadMediaSerialNumberCommandParameters |
        [|OperationCode.Value >= 0x00 && OperationCode.Value <= 0x1F|] Generic6ByteCommandParameter |
        [|OperationCode.Value >= 0x20 && OperationCode.Value <= 0x5F|] Generic10ByteCommandParameter | 
        [|OperationCode.Value >= 0xA0 && OperationCode.Value <= 0xCF|] Generic12ByteCommandParameter |
        [|OperationCode.Value >= 0x80 && OperationCode.Value <= 0x9F|] Generic16ByteCommandParameter |
        Blob[CDBLength() - 2 as uint]) CommandSpecificParameters;

    Control Control;
    optional [|16 - CDBLength() > 0|] array<byte> Padding with BinaryEncoding{Length = 16 - CDBLength()};
    
    // Caculate the padding bytes by the GroupCode
    byte CDBLength()
    {
        byte code = OperationCode.GroupCode;
        if (GroupCodeMap.Keys[code])
        {
            return GroupCodeMap[code];
        }
        else
        {
            return 16;
        }
    }
    
    // For summary
    override string ToString()
    {
        byte op = OperationCode.Value;
        if (CommandOperationCodeMap.Keys[op])
        {
            return CommandOperationCodeMap[op];
        }
        else
        {      
            switch (CommandSpecificParameters)
            {
                case ReadCapacity16CommandParameters =>
                    return "Read Capacity(16)";
                case ReadLong16CommandParameters =>
                    return "Read Long(16)";
                case ReportReferralsCommandParameters =>
                    return "Report Referrals";
                case GetLbaStatusCommandParameters =>
                    return "Get LBA Status";
                case PopulateTokenCommandParameters =>
                    return "Populate Token";
                case WriteUsingTokenCommandParameters =>
                    return "Write Using Token";
                case ReportAliasesCommandParameters =>
                    return "Report Aliases";
                case ReportIdentifyingInformationCommandParameters =>
                    return "Report Identifying Information";
                case ReportPriorityCommandParameters =>
                    return "Report Priority";
                case ReportSupportedOperationCodesCommandParameters =>
                    return "Report Supported Operation Codes";
                case ReportSupportedTaskManagementFunctionsCommandParameters =>
                    return "Report Supported Task Management Functions";
                case ReportTargetPortGroupsCommandParameters =>
                    return "Report Target Port Groups";
                case ReportTimestampCommandParameters =>
                    return "Report Timestamp";
                case ChangeAliasesCommandParameters =>
                    return "Change Aliases";
                case CopyOperationAbortCommandParameters =>
                    return "Copy Operation Abort";
                case ExtendedCopyLID4CommandParameters =>
                    return "Extended Copy(LID4)";
                case ExtendedCopyLID1CommandParameters =>
                    return "Extended Copy(LID1)";
                case ManagementProtocolInCommandParameters =>
                    return "Management Protocol In";
                case ManagementProtocolOutCommandParameters =>
                    return "Management Protocol Out";
                case RemoveITNexusCommandParameters =>
                    return "Remove I_T Nexus";
                case SetIdentifyingInformationCommandParameters =>
                    return "Set Identifying Information";
                case SetPriorityCommandParameters =>
                    return "Set Priority";
                case SetTargetPortGroupsCommandParameters =>
                    return "Set Target Port Groups";
                case SetTimestampCommandParameters =>
                    return "Set Timestamp";
                case ReceiveCopyDataLID4CommandParameters =>
                    return "Receive Copy Data(LID4)";
                case ReceiveCopyDataLID1CommandParameters =>
                    return "Receive Copy Data(LID1)";
                case ReceiveCopyOperatingPatametersCommandParameters =>
                    return "Receive Copy Operating Patameters";
                case ReceiveCopyFailureDetailsLID1CommandParameters =>
                    return "Receive Copy Failure Details(LID1)";
                case ReceiveCopyStatusLID4CommandParameters =>
                    return "Receive Copy Status(LID4)";
                case ReceiveCopyStatusLID1CommandParameters =>
                    return "Receive Copy Status(LID1)";
                case ReceiveRodTokenInformationCommandParameters =>
                    return "Receive Rod Token Information";
                case ReportAllRodTokensCommandParameters =>
                    return "Report All Rod Tokens";
                default =>
                    return "Unknown Value: " + Utility.DecToHexFormat(op);
            }
        }
    }
}

// [SAM2] 5.2.2 OPERATION CODE
type OperationCode
{
    GroupCode GroupCode with BinaryEncoding{Width = 3};
    byte CommandCode with BinaryEncoding{Width = 5};
    
    // Commented off due to Bug#16615: Errors found when checking OPN syntax for a property-style notation by prefixing  a method declaration with the get or set modifier in type definition.
    //byte get Value()
    //{
        //return (GroupCode << 5 + CommandCode) as byte;
    //}
    
    override string ToString()
    {
        byte op = ((GroupCode << 5) + CommandCode) as byte;
        if (CommandOperationCodeMap.Keys[op])
        {
            return CommandOperationCodeMap[op] + " (" + Utility.DecToHexFormat(op) + ")";
        }
        else 
        {
            return op.ToString() + " (" + Utility.DecToHexFormat(op) + ")";
        }
    }
}

// WORKAROUND: For Bug#16615
byte get Value(this OperationCode oc)
{
    return ((oc.GroupCode << 5) + oc.CommandCode) as byte;
}

pattern GroupCode = enum byte
{
    Commands6Byte = 0,
    Commands10Byte1 = 1,
    Commands10Byte2 = 2,
    Reserved  = 3,
    Commands16Byte = 4,
    Commands12Byte = 5,
    VendorSpecific1 = 6,
    VendorSpecific2 = 7
};

pattern CommandOperationCode = enum byte
{
    // SBC-3 commands
    CompareAndWrite = 0x89,
    FormatUnit = 0x04,
    OrWrite16 = 0x8b,
    OperationCode83 = 0x83, // PopulateToken, Write Using Token
    PreFetch10 = 0x34,
    PreFetch16 = 0x90,
    PreventAllowMediumRemoval = 0x1E,
    Read6 = 0x08,
    Read10 = 0x28,
    Read12 = 0xA8,
    Read16 = 0x88,
    ReadCapacity10 = 0x25,
    ServiceActionIn16 = 0x9E, // Read Long (16), Read Capacity (16), Report Referrals, Get Lba Status
    ReadDefectData10 = 0x37,
    ReadDefectData12 = 0xB7,
    ReadLong10 = 0x3E,
    ReassignBlocks = 0x07,
    Sanitize = 0x48,
    StartStopUnit = 0x1B,
    SynchronizeCache10 = 0x35,
    SynchronizeCache16 = 0x91,
    Unmap = 0x42,
    Verify10 = 0x2F,
    Verify12 = 0xAF,
    Verify16 = 0x8F,
    Write6 = 0x0A,
    Write10 = 0x2A,
    Write12 = 0xAA,
    Write16 = 0x8A,
    WriteAndVerify10 = 0x2E,
    WriteAndVerify12 = 0xAE,
    WriteAndVerify16 = 0x8E,
    WriteLong10 = 0x3F,
    WriteLong16 = 0x9F,
    WriteSame10 = 0x41,
    WriteSame16 = 0x93,
    XDRead10 = 0x52,
    XDWrite10 = 0x50,
    XDWriteRead10 = 0x53,
    XPWrite10 = 0x51,
    VariableLength = 0x7F,
    
    // SPC-4 commands
    ChangeDefinition = 0x40,
    ModeSelect6 = 0x15,
    ModeSelect10 = 0x55,
    ModeSense6 = 0x1A,
    ModeSense10 = 0x5A,
    PersistentReserveIn = 0x5E,
    PersistentReserveOut = 0x5F,
    ReadBuffer = 0x3C,
    Release6 = 0x17,
    Release10 = 0x57,
    Inquiry = 0x12,
    LogSelect = 0x4C,
    LogSense = 0x4D,
    ReceiveDiagnosticResults = 0x1C,
    MaintenanceIn = 0xA3,
    ReportLuns = 0xA0,
    RequestSense = 0x03,
    SendDiagnostic = 0x1D,
    TestUnitReady = 0x00,
    WriteBuffer = 0x3B,
    SecurityProtocolIn = 0xA2,
    SecurityProtocolOut = 0xB5,
    WriteAttribute = 0x8D,
    MaintenanceOut = 0xA4,
    OperationCode84 = 0x84,
    ReadAttribute = 0x8C,
    ReadMediaSerialNumber = 0xAB,
};

// [SAM2] 5.2.3 CONTROL byte
type Control
{
    byte VendorSpecific with BinaryEncoding{Width = 2};
    byte Reserved with BinaryEncoding{Width = 3};
    bool NACA with BinaryEncoding{Width = 1};
    byte Obsolete with BinaryEncoding{Width = 1};
    bool Link with BinaryEncoding{Width = 1};
}

// [SPC-2] 4.3.3 The variable length CDB formats
type VariableLengthCommandDescriptorBlock
{
    OperationCode OperationCode where value.Value == CommandOperationCode.VariableLength;
    Control Control;
    (OrWrite32CommandParameters
    | Read32CommandParameters
    | Verify32CommandParameters
    | Write32CommandParameters
    | WriteAndVerify32CommandParameters
    | WriteSame32CommandParameters
    | XDRead32CommandParameters
    | XDWrite32CommandParameters
    | XDWriteRead32CommandParameters
    | XPWrite32CommandParameters
    | ReceiveCredentialCommandParameters
    | TypicalVariableLengthForLongLba32ByteCommandParameters
    | TypicalVariableLengthCommandParameters) CommandParameters;

    override string ToString()
    {
        switch (CommandParameters)
        {
            case Read32CommandParameters =>
                return "Read(32)";
            case Verify32CommandParameters =>
                return "Verify(32)";
            case Write32CommandParameters =>
                return "Write(32)";
            case WriteAndVerify32CommandParameters =>
                return "Write And Verify(32)";
            case WriteSame32CommandParameters =>
                return "Write Same(32)";
            case XDRead32CommandParameters =>
                return "XD Read(32)";
            case XDWrite32CommandParameters =>
                return "XD Write(32)";
            case XDWriteRead32CommandParameters =>
                return "XD Write Read(32)";
            case XPWrite32CommandParameters =>
                return "XP Write(32)";
            case ReceiveCredentialCommandParameters =>
                return "Receive Credential";
            case TypicalVariableLengthForLongLba32ByteCommandParameters =>
                return "Long LBA 32-Byte";
            default =>
                return "Vendor Specific";
        }
    }
}

// [SPC-2] Table 6 - Typical variable length CDB
type TypicalVariableLengthCommandParameters
{
    array<byte> Reserved with BinaryEncoding{Length = 5};
    byte AdditionalCDBLength;
    ushort ServiceAction;
    binary ServiceActionSpecificFields with BinaryEncoding{Length = AdditionalCDBLength - 2};
}

// [SPC-2] Table 7 - Typical variable length CDB for long LBA 32-byte commands
type TypicalVariableLengthForLongLba32ByteCommandParameters
{
    array<byte> Reserved1 with BinaryEncoding{Length = 5};
    (byte where value == 0x18) AdditionalCDBLength;
    ushort ServiceAction;
    byte Reserved2 with BinaryEncoding{Width = 3};
    bool Dpo with BinaryEncoding{Width = 1};
    bool Fua with BinaryEncoding{Width = 1};
    ushort Reserved3 with BinaryEncoding{Width = 11};
    
    ulong LogicalBlockAddress;
    binary AdditionalCDBData with BinaryEncoding{Length = 8};
    uint SpecificLength;
}

// [SBC-3] 5.2 Compare And Write command - OPERATION CODE (89h)
type CompareAndWriteCommandParameters
{
    byte Wrprotect with BinaryEncoding{Width = 3};
    bool Dpo with BinaryEncoding{Width = 1};
    bool Fua with BinaryEncoding{Width = 1};
    byte Reserved1 with BinaryEncoding{Width = 3};
    ulong LogicalBlockAddress;
    uint Reserved2 with BinaryEncoding{Width = 24};
    byte NumberOfLogicalBlocks;
    byte Reserved3 with BinaryEncoding{Width = 3};
    byte GroupNumber with BinaryEncoding{Width = 5};
}

// [SBC-3] 5.3 Format Unit command - OPERATION CODE (04h)
type FormatUnitCommandParameters
{
    byte FmtPInfo with BinaryEncoding{Width = 2};
    bool LongList with BinaryEncoding{Width = 1};
    bool FmtData with BinaryEncoding{Width = 1};
    bool Cmplst with BinaryEncoding{Width = 1};
    byte DefectListFormat with BinaryEncoding{Width = 3};
    
    byte VendorSpecific;
    array<byte> Obsolete with BinaryEncoding{Length = 2};
}

// [SBC-3] 5.4 GET LBA STATUS command - OPERATION CODE (9Eh)
type GetLbaStatusCommandParameters
{
    byte Reserved1 with BinaryEncoding{Width = 3};
    (byte where value == 0x12) ServiceAction with BinaryEncoding{Width = 5};
    ulong StartingLogicalBlockAddress;
    uint AllocationLength;
    byte Reserved2;
}

// [SBC-3] 5.5 ORWRITE(16) command - OPERATION CODE (8bh)
type OrWrite16CommandParameters
{
    byte OrProtect with BinaryEncoding{Width = 3};
    bool Dpo with BinaryEncoding{Width = 1};
    bool Fua with BinaryEncoding{Width = 1};
    byte Reserved1 with BinaryEncoding{Width = 3};
    
    ulong LogicalBlockAddress;
    uint TransferLength;
    byte Reserved2 with BinaryEncoding{Width = 3};
    byte GroupNumber with BinaryEncoding{Width = 5};
}
    
// [SBC-3] 5.6 ORWRITE(32) command - OPERATION CODE (7Fh)
type OrWrite32CommandParameters
{
    byte Reserved1 with BinaryEncoding{Width = 5};
    byte Bmop with BinaryEncoding{Width = 3};
    byte Reserved2 with BinaryEncoding{Width = 4};
    byte PreviousGenerationProcessing with BinaryEncoding{Width = 4};
    uint Reserved3 with BinaryEncoding{Width = 19};
    byte GroupNumber with BinaryEncoding{Width = 5};
    byte AdditonalCdbLength;
    (ushort where value == 0x000E) ServiceAction;
    byte OrProtect with BinaryEncoding{Width = 3};
    bool Dbo with BinaryEncoding{Width = 1};
    bool Fua with BinaryEncoding{Width = 1};
    ushort Reserved4 with BinaryEncoding{Width = 11};
    ulong LogicalBlockAddress;
    uint ExpectedOrwGeneration;
    uint NewOrwGeneration;
    uint TransferLength;
}

// [SBC-3] 5.7 POPULATE TOKEN command - OPERATION CODE (83h)
type PopulateTokenCommandParameters
{
    byte Reserved1 with BinaryEncoding{Width = 3};
    (byte where value == 0x10) ServiceAction with BinaryEncoding{Width = 5};
    uint Reserved2;
    uint ListIdentifier;
    uint ParameterListLength;
    byte Reserved3 with BinaryEncoding{Width = 3};
    byte GroupNumber with BinaryEncoding{Width = 5};
}

// [SBC-3] 5.8 PRE-FETCH (10) command - OPERATION CODE (34h)
type PreFetch10CommandParameters
{
    byte Reserved1 with BinaryEncoding{Width = 6};
    bool IMMED with BinaryEncoding{Width = 1};
    byte Obsolete with BinaryEncoding{Width = 1};
    
    uint LogicalBlockAddress;
    byte Reserved2 with BinaryEncoding{Width = 3};
    byte GroupNumber with BinaryEncoding{Width = 5};
    ushort PrefetchLength;
}

// [SBC-3] 5.9 PRE-FETCH (16) command - OPERATION CODE (90h)
type PreFetch16CommandParameters
{
    byte Reserved1 with BinaryEncoding{Width = 6};
    bool IMMED with BinaryEncoding{Width = 1};
    byte Obsolete with BinaryEncoding{Width = 1};
    
    ulong LogicalBlockAddress;
    uint PrefetchLength;
    byte Reserved2 with BinaryEncoding{Width = 3};
    byte GroupNumber with BinaryEncoding{Width = 5};
}

// [SBC-3] 5.10 PREVENT ALLOW MEDIUM REMOVAL command - OPERATION CODE (1Eh)
type PreventAllowMediumRemovalCommandParameters
{
    uint Reserved with BinaryEncoding{Width = 30};
    uint Prevent with BinaryEncoding{Width = 2};
}

// [SBC-3] OBSOLETE    READ (6) command - OPERATION CODE (08h)
type Read6CommandParameters
{
    uint Reserved with BinaryEncoding{Width = 3};
    uint LogicalBlockAddress with BinaryEncoding{Width = 21};
    byte TransferLength;
}

// [SBC-3] 5.11 READ (10) command - OPERATION CODE (28h)
type Read10CommandParameters
{
    byte Protect with BinaryEncoding{Width = 3};
    bool Dpo with BinaryEncoding{Width = 1};
    bool Fua with BinaryEncoding{Width = 1};
    bool Rarc with BinaryEncoding{Width = 1};
    bool FuaNv_Obsolete with BinaryEncoding{Width = 1};
    byte Obsolete with BinaryEncoding{Width = 1};

    uint LogicalBlockAddress;
    byte Reserved with BinaryEncoding{Width = 3};
    byte GroupNumber with BinaryEncoding{Width = 5};
    ushort TransferLength;
}

// [SBC-3] 5.12 READ (12) command  - OPERATION CODE (A8h)
type Read12CommandParameters
{
    byte Protect with BinaryEncoding{Width = 3};
    bool Dpo with BinaryEncoding{Width = 1};
    bool Fua with BinaryEncoding{Width = 1};
    bool Rarc with BinaryEncoding{Width = 1};
    bool FuaNv_Obsolete with BinaryEncoding{Width = 1};
    byte Obsolete with BinaryEncoding{Width = 1};

    uint LogicalBlockAddress;
    uint TransferLength;
    bool RestrictedForMMC6 with BinaryEncoding{Width = 1};
    byte Reserved2 with BinaryEncoding{Width = 2};
    byte GroupNumber with BinaryEncoding{Width = 5};
}

// [SBC-3] 5.13 READ (16) command - OPERATION CODE (88h)
type Read16CommandParameters
{
    byte Protect with BinaryEncoding{Width = 3};
    bool Dpo with BinaryEncoding{Width = 1};
    bool Fua with BinaryEncoding{Width = 1};
    byte Rarc with BinaryEncoding{Width = 1};
    bool FuaNv_Obsolete with BinaryEncoding{Width = 1};
    byte Reserved2 with BinaryEncoding{Width = 1};
    
    ulong LogicalBlockAddress;
    uint TransferLength;
    
    bool RestrictedForMMC6 with BinaryEncoding{Width = 1};
    byte Reserved with BinaryEncoding{Width = 2};
    byte GroupNumber with BinaryEncoding{Width = 5};
}
     
// [SBC-3] 5.14 READ (32) command - OPERATION CODE (7Fh)
type Read32CommandParameters
{
    ulong Reserved1 with BinaryEncoding{Width = 35};
    byte GroupNumber with BinaryEncoding{Width = 5};
    
    byte AdditionalCDBLength;
    (ushort where value == 0x0009) ServiceAction;
    
    byte Protect with BinaryEncoding{Width = 3};
    bool Dpo with BinaryEncoding{Width = 1};
    bool Fua with BinaryEncoding{Width = 1};
    bool Rarc with BinaryEncoding{Width = 1};
    bool FuaNv_Obsolete with BinaryEncoding{Width = 1};
    ushort Reserved4 with BinaryEncoding{Width = 9};
    
    ulong LogicalBlockAddressLow;
    uint ExpectedInitialLogicalBlockReferenceTag;
    ushort ExpectedLogicalBlockApplicationTag;
    ushort LogicalBlockApplicationTagMask;
    uint TransferLength;
}

// [SBC-3] 5.15 READ CAPACITY (10) command - OPERATION CODE (25h)
type ReadCapacity10CommandParameters
{
    byte Reserved1 with BinaryEncoding{Width = 7};
    byte Obsolete with BinaryEncoding{Width = 1};
    
    uint LogicalBlockAddress_Obsolete;
    uint Reserved2 with BinaryEncoding{Width = 23};
    bool PMI_Obsolete with BinaryEncoding{Width = 1};
}
    
// [SBC-3] 5.16 READ CAPACITY (16) command - OPERATION CODE (9Eh)
type ReadCapacity16CommandParameters
{
    byte Reserved1 with BinaryEncoding{Width = 3};
    (byte where value == 0x10) ServiceAction with BinaryEncoding{Width = 5};
    
    ulong LogicalBlockAddress_Obsolete;
    uint AllocationLength;
    
    byte Reserved2 with BinaryEncoding{Width = 7};
    bool PMI_Obsolete with BinaryEncoding{Width = 1};
}

// [SBC-3] 5.17 READ DEFECT DATA (10) command - OPERATION CODE (37h)
type ReadDefectData10CommandParameters
{
    ushort Reserved1 with BinaryEncoding{Width = 11};
    bool ReqPList with BinaryEncoding{Width = 1};
    bool ReqGList with BinaryEncoding{Width = 1};
    byte DefectListFormat with BinaryEncoding{Width = 3};
    
    uint Reserved2;
    ushort AllocationLength;
}
 
// [SBC-3] 5.18 READ DEFECT DATA (12) command - OPERATION CODE (B7h)
type ReadDefectData12CommandParameters
{
    ushort Reserved1 with BinaryEncoding{Width = 3};
    bool ReqPList with BinaryEncoding{Width = 1};
    bool ReqGList with BinaryEncoding{Width = 1};
    byte DefectListFormat with BinaryEncoding{Width = 3};
    
    uint AddressDescriptorIndex;
    uint AllocationLength;
    byte Reserved2;
}
     
// [SBC-3] 5.19 READ LONG (10) command - OPERATION CODE (3Eh)
type ReadLong10CommandParameters
{
    byte Reserved1 with BinaryEncoding{Width = 5};
    bool PBLock with BinaryEncoding{Width = 1};
    bool Corrct with BinaryEncoding{Width = 1};
    byte Obsolete with BinaryEncoding{Width = 1};
    
    uint LogicalBlockAddress;
    byte Reserved2;
    ushort ByteTransferLength;
}

// [SBC-3] 5.20 READ LONG (16) command - OPERATION CODE (9Eh)
type ReadLong16CommandParameters
{
    byte Reserved1 with BinaryEncoding{Width = 3};
    (byte where value == 0x11) ServiceAction  with BinaryEncoding{Width = 5};
    
    ulong LogicalBlockAddress;
    ushort Reserved2;
    ushort ByteTransferLength;
    
    byte Reserved3 with BinaryEncoding{Width = 6};
    bool PBLock with BinaryEncoding{Width = 1};
    bool Corrct with BinaryEncoding{Width = 1};
}

// [SBC-3] 5.21 REASSIGN BLOCKS command - OPERATION CODE (07h)
type ReassignBlocksCommandParameters
{
    byte Reserved1 with BinaryEncoding{Width = 6};
    bool LongLBA with BinaryEncoding{Width = 1};
    bool LongList with BinaryEncoding{Width = 1};
    
    uint Reserved2 with BinaryEncoding{Width = 24};
}

// [SBC-3] 5.22.2 RECEIVE ROD TOKEN INFORMATION parameter data for POPULATE TOKEN command 
// [SBC-3] 5.22.3 RECEIVE ROD TOKEN INFORMATION parameter data for WRITE USING TOKEN command 
type ReceiveRodTokenInformationParameterData
{
    uint AvailableData;
    byte Reserved1 with BinaryEncoding{Width = 3};
    (byte where value == 0x10 || value == 0x11) ResponseToServiceAction with BinaryEncoding{Width = 5};
    byte Reserved2 with BinaryEncoding{Width = 1};
    byte CopyOperationStatus with BinaryEncoding{Width = 7};
    ushort OperationCounter;
    uint EstimatedStatusUpdateDelay;
    byte ExtendedCopyCompletionStatus;
    byte LengthOfTheSenseData;
    byte SenseDataLength;
    byte TransferCountUnits;
    ulong TransferCount;
    ushort SegmentsProcessed;
    array<byte> Reserved3 with BinaryEncoding{Length = 6};
    array<byte> SenseData with BinaryEncoding{Length = LengthOfTheSenseData};
    optional [|ResponseToServiceAction == 0x10|] uint RodTokenDescriptorLength;
    ([|ResponseToServiceAction == 0x10|] ushort | [|ResponseToServiceAction == 0x11|] uint) Restricted;
    optional [|ResponseToServiceAction == 0x10|] (GenericRodToken | binary) RodToken with BinaryEncoding{WidthForComposedType = ((RodTokenDescriptorLength as uint) - 2) * 8, Length = (RodTokenDescriptorLength as uint) - 2};
}

// [SBC-3] 5.23 REPORT REFERRALS command - OPERATION CODE (9Eh)
type ReportReferralsCommandParameters
{
    byte Reserved1 with BinaryEncoding{Width = 3};
    (byte where value == 0x13) ServiceAction with BinaryEncoding{Width = 5};
    ulong LogicalBlockAddress;
    uint AllocationLength;
    byte Reserved2 with BinaryEncoding{Width = 7};
    bool OneSeg with BinaryEncoding{Width = 1};
}

// [SBC-3] 5.24 SANITIZE command - OPERATION CODE (48h)
type SanitizeCommandParameters
{
    bool Immed with BinaryEncoding{Width = 1};
    byte Reserved1 with BinaryEncoding{Width = 1};
    bool Ause with BinaryEncoding{Width = 1};
    byte ServiceAction with BinaryEncoding{Width = 3};
    ulong Reserved2 with BinaryEncoding{Width = 40};
    ushort ParameterListLength;
}

// [SBC-3] 5.25 START STOP UNIT command - OPERATION CODE (1Bh)
type StartStopUnitCommandParameters
{
    byte Reserved1 with BinaryEncoding{Width = 7};
    bool Immed with BinaryEncoding{Width = 1};
    
    ushort Reserved2 with BinaryEncoding{Width = 12};
    byte PowerConditionModifier with BinaryEncoding{Width = 4};
    
    byte PowerCondition with BinaryEncoding{Width = 4};
    byte Reserved3 with BinaryEncoding{Width = 1};
    bool NoFlush with BinaryEncoding{Width = 1};
    bool Loej with BinaryEncoding{Width = 1};
    bool Start with BinaryEncoding{Width = 1};
}
     
// [SBC-3] 5.26 SYNCHRONIZE CACHE (10) command  - OPERATION CODE (35h)
type SynchronizeCache10CommandParameters
{
    byte Reserved1 with BinaryEncoding{Width = 5};
    bool SyncNV_Obsolete with BinaryEncoding{Width = 1};
    bool Immed with BinaryEncoding{Width = 1};
    byte Obsolete with BinaryEncoding{Width = 1};
    
    uint LogicalBlockAddress;
    
    byte Reserved2 with BinaryEncoding{Width = 3};
    byte GroupNumber with BinaryEncoding{Width = 5};
    ushort NumberOfLogicalBlocks;
}

// [SBC-3] 5.27 SYNCHRONIZE CACHE (16) command - OPERATION CODE (91h)
type SynchronizeCache16CommandParameters
{
    byte Reserved1 with BinaryEncoding{Width = 5};
    bool SyncNV_Obsolete with BinaryEncoding{Width = 1};
    bool Immed with BinaryEncoding{Width = 1};
    byte Obsolete with BinaryEncoding{Width = 1};
    
    ulong LogicalBlockAddress;
    uint NumberOfLogicalBlocks;
    
    byte Reserved2 with BinaryEncoding{Width = 3};
    byte GroupNumber with BinaryEncoding{Width = 5};
}

// [SBC-3] 5.28 UNMAP command - OPERATION CODE (42h)
type UnmapCommandParameters
{
    byte Reserved1 with BinaryEncoding{Width = 7};
    bool Anchor with BinaryEncoding{Width = 1};
    ulong Reserved2 with BinaryEncoding{Width = 35};
    byte GroupNumber with BinaryEncoding{Width = 5};
    ushort ParameterListLength;
}
     
// [SBC-3] 5.29 VERIFY (10) command - OPERATION CODE (2Fh)
type Verify10CommandParameters
{
    byte Vrprotect with BinaryEncoding{Width = 3};
    bool Dpo with BinaryEncoding{Width = 1};
    byte Reserved1 with BinaryEncoding{Width = 1};
    byte Bytchk with BinaryEncoding{Width = 2};
    byte Obsolete with BinaryEncoding{Width = 1};
    
    uint LogicalBlockAddress;
    
    bool RestrictedForMMC6 with BinaryEncoding{Width = 1};
    byte Reserved2 with BinaryEncoding{Width = 2};
    byte GroupNumber with BinaryEncoding{Width = 5};
    
    ushort VerificationLength;
}
     
// [SBC-3] 5.30 VERIFY (12) command - OPERATION CODE (AFh)
type Verify12CommandParameters
{
    byte Vrprotect with BinaryEncoding{Width = 3};
    bool Dpo with BinaryEncoding{Width = 1};
    byte Reserved1 with BinaryEncoding{Width = 1};
    byte Bytchk with BinaryEncoding{Width = 2};
    byte Obsolete with BinaryEncoding{Width = 1};
    
    uint LogicalBlockAddress;
    uint VerificationLength;
    
    bool RestrictedForMMC6 with BinaryEncoding{Width = 1};
    byte Reserved2 with BinaryEncoding{Width = 2};
    byte GroupNumber with BinaryEncoding{Width = 5};
}
 
// [SBC-3] 5.31 VERIFY (16) command - OPERATION CODE (8Fh)
type Verify16CommandParameters
{
    byte Vrprotect with BinaryEncoding{Width = 3};
    bool Dpo with BinaryEncoding{Width = 1};
    byte Reserved1 with BinaryEncoding{Width = 1};
    byte Bytchk with BinaryEncoding{Width = 2};
    byte Reserved2 with BinaryEncoding{Width = 1};
    
    ulong LogicalBlockAddress;
    uint VerificationLength;
    
    bool RestrictedForMMC6 with BinaryEncoding{Width = 1};
    byte Reserved3 with BinaryEncoding{Width = 2};
    byte GroupNumber with BinaryEncoding{Width = 5};
}

// [SBC-3] 5.32 VERIFY (32) command - OPERATION CODE (7Fh)
type Verify32CommandParameters
{
    ulong Reserved1 with BinaryEncoding{Width = 35};
    byte GroupNumber with BinaryEncoding{Width = 5};
    
    byte AdditionalCDBLength;
    (ushort where value == 0x000A) ServiceAction;
    
    byte Vrprotect with BinaryEncoding{Width = 3};
    bool Dpo with BinaryEncoding{Width = 1};
    byte Reserved2 with BinaryEncoding{Width = 1};
    byte Bytchk with BinaryEncoding{Width = 2};
    ushort Reserved3 with BinaryEncoding{Width = 9};
    
    ulong LogicalBlockAddress;
    uint ExpectedInitialLogicalBlockReferenceTag;
    ushort ExpectedLogicalBlockApplicationTag;
    ushort LogicalBlockApplicationTagMask;
    uint VerificationLength;
}

// [SBC-3] OBSOLETE    WRITE (6) command - OPERATION CODE (0Ah)
type Write6CommandParameters
{
    uint Byte with BinaryEncoding{Width = 4};
    uint LogicalBlockAddress with BinaryEncoding{Width = 20};
    byte TransferLength;
}

// [SBC-3] 5.33 WRITE (10) command - OPERATION CODE (2Ah)
type Write10CommandParameters
{
    byte Wrprotect with BinaryEncoding{Width = 3};
    bool Dpo with BinaryEncoding{Width = 1};
    bool Fua with BinaryEncoding{Width = 1};
    byte Reserved1 with BinaryEncoding{Width = 1};
    bool FuaNv_Obsolete with BinaryEncoding{Width = 1};
    byte Obsolete with BinaryEncoding{Width = 1};
    
    uint LogicalBlockAddress;
    
    byte Reserved2 with BinaryEncoding{Width = 3};
    byte GroupNumber with BinaryEncoding{Width = 5};
    
    ushort TransferLength;
}

// [SBC-3] 5.34 WRITE (12) command - OPERATION CODE (AAh)
type Write12CommandParameters
{
    byte Wrprotect with BinaryEncoding{Width = 3};
    bool Dpo with BinaryEncoding{Width = 1};
    bool Fua with BinaryEncoding{Width = 1};
    byte Reserved1 with BinaryEncoding{Width = 1};
    bool FuaNv_Obsolete with BinaryEncoding{Width = 1};
    byte Obsolete with BinaryEncoding{Width = 1};
    
    uint LogicalBlockAddress;
    uint TransferLength;
    
    bool RestrictedForMMC6 with BinaryEncoding{Width = 1};
    byte Reserved2 with BinaryEncoding{Width = 2};
    byte GroupNumber with BinaryEncoding{Width = 5};
}
     
// [SBC-3] 5.35 WRITE (16) command - OPERATION CODE (8Ah)
type Write16CommandParameters
{
    byte Wrprotect with BinaryEncoding{Width = 3};
    bool Dpo with BinaryEncoding{Width = 1};
    bool Fua with BinaryEncoding{Width = 1};
    byte Reserved1 with BinaryEncoding{Width = 1};
    bool FuaNv_Obsolete with BinaryEncoding{Width = 1};
    byte Obsolete with BinaryEncoding{Width = 1};
    
    ulong LogicalBlockAddress;
    uint TransferLength;
    
    bool RestrictedForMMC6 with BinaryEncoding{Width = 1};
    byte Reserved2 with BinaryEncoding{Width = 2};
    byte GroupNumber with BinaryEncoding{Width = 5};
}

// [SBC-3] 5.36 WRITE (32) command - OPERATION CODE (7Fh)
type Write32CommandParameters
{
    ulong Reserved1 with BinaryEncoding{Width = 35};
    byte GroupNumber with BinaryEncoding{Width = 5};
    
    byte AdditionalCDBLength;
    (ushort where value == 0x000B) ServiceAction;
    
    byte Wrprotect with BinaryEncoding{Width = 3};
    bool Dpo with BinaryEncoding{Width = 1};
    bool Fua with BinaryEncoding{Width = 1};
    byte Reserved2 with BinaryEncoding{Width = 1};
    bool FuaNv_Obsolete with BinaryEncoding{Width = 1};
    
    ushort Reserved3 with BinaryEncoding{Width = 9};
    ulong LogicalBlockAddress;
    uint ExpectedInitialLogicalBlockReferenceTag;
    ushort ExpectedLogicalBlockApplicationTag;
    ushort LogicalBlockApplicationTagMask;
    uint TransferLength;
}

// [SBC-3] 5.37 WRITE AND VERIFY (10) command - OPERATION CODE (2Eh)
type WriteAndVerify10CommandParameters
{
    byte Wrprotect with BinaryEncoding{Width = 3};
    bool Dpo with BinaryEncoding{Width = 1};
    byte Reserved1 with BinaryEncoding{Width = 1};
    byte Bytchk with BinaryEncoding{Width = 2};
    byte Obsolete with BinaryEncoding{Width = 1};
    
    uint LogicalBlockAddress;
    
    byte Reserved2 with BinaryEncoding{Width = 3};
    byte GroupNumber with BinaryEncoding{Width = 5};
    
    ushort TransferLength;
}
 
// [SBC-3] 5.38 WRITE AND VERIFY (12) command - OPERATION CODE (AEh)
type WriteAndVerify12CommandParameters
{
    byte Wrprotect with BinaryEncoding{Width = 3};
    bool Dpo with BinaryEncoding{Width = 1};
    byte Reserved1 with BinaryEncoding{Width = 1};
    byte Bytchk with BinaryEncoding{Width = 2};
    byte Obsolete with BinaryEncoding{Width = 1};
    
    uint LogicalBlockAddress;
    uint TransferLength;
    
    bool RestrictedForMMC6 with BinaryEncoding{Width = 1};
    byte Reserved2 with BinaryEncoding{Width = 2};
    byte GroupNumber with BinaryEncoding{Width = 5};
}

// [SBC-3] 5.39 WRITE AND VERIFY (16) command - OPERATION CODE (8Eh)
type WriteAndVerify16CommandParameters
{
    byte Wrprotect with BinaryEncoding{Width = 3};
    bool Dpo with BinaryEncoding{Width = 1};
    byte Reserved1 with BinaryEncoding{Width = 1};
    byte Bytchk with BinaryEncoding{Width = 2};
    byte Reserved2 with BinaryEncoding{Width = 1};
    
    ulong LogicalBlockAddress;
    uint TransferLength;
    
    bool RestrictedForMMC6 with BinaryEncoding{Width = 1};
    byte Reserved3 with BinaryEncoding{Width = 2};
    byte GroupNumber with BinaryEncoding{Width = 5};
}
     
// [SBC-3] 5.40 WRITE AND VERIFY (32) command - OPERATION CODE (7Fh)
type WriteAndVerify32CommandParameters
{
    ulong Reserved1 with BinaryEncoding{Width = 35};
    byte GroupNumber with BinaryEncoding{Width = 5};
    
    byte AdditionalCDBLength;
    (ushort where value == 0x000C) ServiceAction;
    
    byte Wrprotect with BinaryEncoding{Width = 3};
    bool Dpo with BinaryEncoding{Width = 1};
    byte Reserved2 with BinaryEncoding{Width = 1};
    byte Bytchk with BinaryEncoding{Width = 2};
    ushort Reserved3 with BinaryEncoding{Width = 9};
    
    ulong LogicalBlockAddress;
    uint ExpectedInitialLogicalBlockReferenceTag;
    ushort ExpectedLogicalBlockApplicationTag;
    ushort LogicalBlockApplicationTagMask;
    uint TransferLength;
}

// [SBC-3] 5.41 WRITE LONG (10) command - OPERATION CODE (3Fh)
type WriteLong10CommandParameters
{
    bool CorDis with BinaryEncoding{Width = 1};
    bool WrUncor with BinaryEncoding{Width = 1};
    bool PBLock with BinaryEncoding{Width = 1};
    byte Reserved1 with BinaryEncoding{Width = 4};
    byte Obsolete with BinaryEncoding{Width = 1};
    
    uint LogicalBlockAddress;
    byte Reserved2;
    ushort ByteTransferLength;
}
 
// [SBC-3] 5.42 WRITE LONG (16) command - OPERATION CODE (9Fh)
type WriteLong16CommandParameters
{
    bool CorDis with BinaryEncoding{Width = 1};
    bool WrUncor with BinaryEncoding{Width = 1};
    bool PBLock with BinaryEncoding{Width = 1};
    byte SeviceAction with BinaryEncoding{Width = 5};
    
    ulong LogicalBlockAddress;
    ushort Reserved1;
    ushort ByteTransferLength;
    byte Reserved2;
}

// [SBC-3] 5.43 WRITE Same (10) command - OPERATION CODE (41h)
type WriteSame10CommandParameters
{
    byte Wrprotect with BinaryEncoding{Width = 3};
    bool Anchor with BinaryEncoding{Width = 1};
    bool Unmap with BinaryEncoding{Width = 1};
    byte Obsolete with BinaryEncoding{Width = 3};
    
    uint LogicalBlockAddress;
    
    byte Reserved with BinaryEncoding{Width = 3};
    byte GroupNumber with BinaryEncoding{Width = 5};
    
    ushort NumberOfLogicalBlocks;
}

// [SBC-3] 5.44 WRITE SAME (16) command - OPERATION CODE (93h)
type WriteSame16CommandParameters
{
    byte Wrprotect with BinaryEncoding{Width = 3};
    bool Anchor with BinaryEncoding{Width = 1};
    bool Unmap with BinaryEncoding{Width = 1};
    byte Obsolete with BinaryEncoding{Width = 2};
    bool Ndob with BinaryEncoding{Width = 1};
    
    ulong LogicalBlockAddress;
    uint NumberOfLogicalBlocks;

    byte Reserved with BinaryEncoding{Width = 3};
    byte GroupNumber with BinaryEncoding{Width = 5};
}     
 
// [SBC-3] 5.45 WRITE SAME (32) command - OPERATION CODE (7Fh)
type WriteSame32CommandParameters
{
    ulong Reserved1 with BinaryEncoding{Width = 35};
    byte GroupNumber with BinaryEncoding{Width = 5};
    
    byte AdditionalCDBLength;
    (ushort where value == 0x000D) ServiceAction;
    
    byte Wrprotect with BinaryEncoding{Width = 3};
    bool Anchor with BinaryEncoding{Width = 1};
    bool Unmap with BinaryEncoding{Width = 1};
    byte Obsolete with BinaryEncoding{Width = 2};
    bool Ndob with BinaryEncoding{Width = 1};
   
    byte Reserved2;
    ulong LogicalBlockAddress;
    uint ExpectedInitialLogicalBlockReferenceTag;
    ushort ExpectedLogicalBlockApplicationTag;
    ushort LogicalBlockApplicationTagMask;
    uint NumberOfLogicalBlocks;
}

// [SBC-3] 5.46 WRITE USING TOKEN command - OPERATION CODE (83h)
type WriteUsingTokenCommandParameters
{
    byte Reserved1 with BinaryEncoding{Width = 3};
    (byte where value == 0x11) ServiceAction with BinaryEncoding{Width = 5};
    uint Reserved2;
    uint ListIdentifier;
    uint ParameterListLength;
    byte Reserved3 with BinaryEncoding{Width = 3};
    byte GroupNumber with BinaryEncoding{Width = 5};
}

// [SBC-3] OBSOLETE    XDREAD (10) command - OPERATION CODE (52h)
type XDRead10CommandParameters
{
    byte Reserved1 with BinaryEncoding{Width = 7};
    bool Xorpinfo with BinaryEncoding{Width = 1};
    
    uint LogicalBlockAddress;
    
    byte Reserved2 with BinaryEncoding{Width = 3};
    byte GroupNumber with BinaryEncoding{Width = 5};
    
    ushort TransferLength;
}
 
// [SBC-3] OBSOLETE    XDREAD (32) command - OPERATION CODE (7Fh)
type XDRead32CommandParameters
{
    array<byte> Reserved1 with BinaryEncoding{Length = 4};
    
    byte Reserved2 with BinaryEncoding{Width = 3};
    byte GroupNumber with BinaryEncoding{Width = 5};
    
    (byte where value == 0x18) AdditionalCDBLength;
    (ushort where value == 0x0003) ServiceAction;
    
    byte Reserved3 with BinaryEncoding{Width = 7};
    bool Xorpinfo with BinaryEncoding{Width = 1};
    
    byte Reserved4;
    ulong LogicalBlockAddress;
    array<byte> Reserved5 with BinaryEncoding{Length = 8};
    uint TransferLength;
}

// [SBC-3] OBSOLETE    XDWRITE (10) command - OPERATION CODE (50h)
type XDWrite10CommandParameters
{
    byte Wrprotect with BinaryEncoding{Width = 3};
    bool Dpo with BinaryEncoding{Width = 1};
    bool Fua with BinaryEncoding{Width = 1};
    byte DisableWrite with BinaryEncoding{Width = 1};
    bool FuaNv with BinaryEncoding{Width = 1};
    byte Obsolete with BinaryEncoding{Width = 1};
    
    uint LogicalBlockAddress;
    
    byte Reserved2 with BinaryEncoding{Width = 3};
    byte GroupNumber with BinaryEncoding{Width = 5};
    
    ushort TransferLength;
}
   
// [SBC-3] OBSOLETE    XDWRITE (32) command - OPERATION CODE (7Fh)
type XDWrite32CommandParameters
{
    array<byte> Reserved1 with BinaryEncoding{Length = 4};
    
    byte Reserved2 with BinaryEncoding{Width = 3};
    byte GroupNumber with BinaryEncoding{Width = 5};
    
    (byte where value == 0x18) AdditionalCDBLength;
    (ushort where value == 0x0004) ServiceAction;
    
    byte Wrprotect with BinaryEncoding{Width = 3};
    bool Dpo with BinaryEncoding{Width = 1};
    bool Fua with BinaryEncoding{Width = 1};
    byte DisableWrite with BinaryEncoding{Width = 1};
    bool FuaNv with BinaryEncoding{Width = 1};
    byte Obsolete with BinaryEncoding{Width = 1};
    
    byte Reserved3;
    ulong LogicalBlockAddress;
    array<byte> Reserved4 with BinaryEncoding{Length = 8};
    uint TransferLength;
}

// [SBC-3] 5.47 XDWRITEREAD (10) command - OPERATION CODE (53h)
type XDWriteRead10CommandParameters
{
    byte Wrprotect with BinaryEncoding{Width = 3};
    bool Dpo with BinaryEncoding{Width = 1};
    bool Fua with BinaryEncoding{Width = 1};
    bool DisableWrite with BinaryEncoding{Width = 1};
    bool FuaNv_Obsolete with BinaryEncoding{Width = 1};
    bool Xorpinfo with BinaryEncoding{Width = 1};
    
    uint LogicalBlockAddress;
    
    byte Reserved with BinaryEncoding{Width = 3};
    byte GroupNumber with BinaryEncoding{Width = 5};
    
    ushort TransferLength;
}
     
// [SBC-3] 5.48 XDWRITEREAD (32) command- OPERATION CODE (7Fh)
type XDWriteRead32CommandParameters
{
    ulong Reserved1 with BinaryEncoding{Width = 35};
    byte GroupNumber with BinaryEncoding{Width = 5};
    
    byte AdditionalCDBLength;
    (ushort where value == 0x0007) ServiceAction;
    
    byte Wrprotect with BinaryEncoding{Width = 3};
    bool Dpo with BinaryEncoding{Width = 1};
    bool Fua with BinaryEncoding{Width = 1};
    bool DisableWrite with BinaryEncoding{Width = 1};
    bool FuaNv_Obsolete with BinaryEncoding{Width = 1};
    bool Xorpinfo with BinaryEncoding{Width = 1};
    
    byte Reserved2;
    ulong LogicalBlockAddress;
    ulong Reserved3;
    uint TransferLength;
}

// [SBC-3] 5.49 XPWRITE (10) command - OPERATION CODE (51h)
type XPWrite10CommandParameters
{
    byte Reserved1 with BinaryEncoding{Width = 3};
    bool Dpo with BinaryEncoding{Width = 1};
    bool Fua with BinaryEncoding{Width = 1};
    bool Reserved2 with BinaryEncoding{Width = 1};
    bool FuaNv_Obsolete with BinaryEncoding{Width = 1};
    bool Xorpinfo with BinaryEncoding{Width = 1};
    
    uint LogicalBlockAddress;
    
    byte Reserved3 with BinaryEncoding{Width = 3};
    byte GroupNumber with BinaryEncoding{Width = 5};
    
    ushort TransferLength;
}
 
// [SBC-3] 5.50 XDWRITEREAD (32) command - OPERATION CODE (7Fh)
type XPWrite32CommandParameters
{
    ulong Reserved1 with BinaryEncoding{Width = 35};
    byte GroupNumber with BinaryEncoding{Width = 5};
    
    byte AdditionalCDBLength;
    (ushort where value == 0x0006) ServiceAction;
    
    byte Reserved2 with BinaryEncoding{Width = 3};
    bool Dpo with BinaryEncoding{Width = 1};
    bool Fua with BinaryEncoding{Width = 1};
    bool Reserved3 with BinaryEncoding{Width = 1};
    bool FuaNv_Obsolete with BinaryEncoding{Width = 1};
    bool Xorpinfo with BinaryEncoding{Width = 1};
    
    byte Reserved4;
    ulong LogicalBlockAddress;
    ulong Reserved5;
    uint TransferLength;
}

// Parameter data specified in [SBC-3]

// [SBC-3] 5.3.2 FORMAT UNIT parameter list
type FormatUnitParameterList[bool LongList, byte DefectListFormat]
{
    ([|LongList == false|] FormatUnitShortParameterListHeader |
    [|LongList == true|] FormatUnitLongParameterListHeader) ParameterListHeader;
    optional FormatUnitInitializationPatternDescriptor InitializationPatternDescriptor;
    optional ([|DefectListFormat == 0|] array<ShortBlockFormatAddressDescriptor> | 
        [|DefectListFormat == 0x1|] array<ExtendedBytesFromIndexFormatAddressDescriptor> |
        [|DefectListFormat == 0x2|] array<ExtendedPhysicalSectorFormatAddressDescriptor> |
        [|DefectListFormat == 0x3|] array<LongBlockFormatAddressDescriptor> |
        [|DefectListFormat == 0x4|] array<BytesFromIndexFormatAddressDescriptor> |
        [|DefectListFormat == 0x5|] array<PhysicalSectorFormatAddressDescriptor> |
        binary) DefectList;
}

type FormatUnitShortParameterListHeader
{
    byte Reserved with BinaryEncoding{Width = 5};
    byte ProtectionFieldUsage with BinaryEncoding{Width = 3};
    bool FOV with BinaryEncoding{Width = 1};
    bool DPRY with BinaryEncoding{Width = 1};
    bool DCRT with BinaryEncoding{Width = 1};
    bool STPF with BinaryEncoding{Width = 1};
    bool IP with BinaryEncoding{Width = 1};
    bool Obsolete with BinaryEncoding{Width = 1};
    bool IMMED with BinaryEncoding{Width = 1};
    bool VendorSpecific with BinaryEncoding{Width = 1};
    ushort DefectListLength;
}

type FormatUnitLongParameterListHeader
{
    byte Reserved1 with BinaryEncoding{Width = 5};
    byte ProtectionFieldUsage with BinaryEncoding{Width = 3};
    bool FOV with BinaryEncoding{Width = 1};
    bool DPRY with BinaryEncoding{Width = 1};
    bool DCRT with BinaryEncoding{Width = 1};
    bool STPF with BinaryEncoding{Width = 1};
    bool IP with BinaryEncoding{Width = 1};
    bool Obsolete with BinaryEncoding{Width = 1};
    bool IMMED with BinaryEncoding{Width = 1};
    bool VendorSpecific with BinaryEncoding{Width = 1};
    byte Reserved2;
    byte PIInformation with BinaryEncoding{Width = 4};
    byte ProtectionIntervalExponent with BinaryEncoding{Width = 4};
    uint DefectListLength;
}

 type FormatUnitInitializationPatternDescriptor
 {
     byte Obsolete with BinaryEncoding{Width = 2};
     bool SI with BinaryEncoding{Width = 1};
     byte Reserved with BinaryEncoding{Width = 5};
     ushort InitializationPatternLength;
     binary InitializationPattern with BinaryEncoding{Length = InitializationPatternLength};
 }
 
// [SBC-3] 5.4.2 GET LBA STATUS parameter data
type GetLbaStatusParameterData
{
    uint ParameterDataLength;
    uint Reserved;
    array <LbaStatusDescriptor> LbaStatusDescriptors;
}
 
type LbaStatusDescriptor
{
    ulong LbaStatusLogicalBlockAddress;
    uint NumberOfLogicalBlocks;
    byte Reserved1 with BinaryEncoding{Width = 4};
    ProvisioningStatus ProvisioningStatus with BinaryEncoding{Width = 4};
    uint Reserved2 with BinaryEncoding{Width = 24};
}

pattern ProvisioningStatus = enum byte
{
    Mapped      = 0x00,
    Deallocated = 0x01,
    Anchored    = 0x02,
    ...
};

// [SBC-3] 5.7.2 POPULATE TOKEN parameter list
type PopulateTokenParameterList
{
    ushort PopulateTokenDataLength;
    byte Reserved1 with BinaryEncoding{Width = 6};
    bool RTV with BinaryEncoding{Width = 1};
    bool IMMED with BinaryEncoding{Width = 1};
    byte Reserved2;
    uint InactivityTimeout;
    uint RodType;
    ushort Reserved3;
    ushort BlockDeviceRangeDescriptorLength;
    array<BlockDeviceRangeDescriptor> BlockDeviceRangeDescriptorList with BinaryEncoding{Length = (BlockDeviceRangeDescriptorLength / 16)};
}

type BlockDeviceRangeDescriptor
{
    ulong LogicalBlockAddress;
    uint NumberOfLogicalBlocks;
    uint Reserved;
}

// [SBC-3] 5.15.2 READ CAPACITY(10) parameter data
type ReadCapacity10ParameterData
{
    uint ReturnedLogicalBlockAddress;
    uint LogicalBlockLengthInBytes;
}

// [SBC-3] 5.16.2 READ CAPACITY(16) parameter data
type ReadCapacity16ParameterData
{
    ulong ReturnedLogicalBlockAddress;
    uint LogicalBlockLengthInBytes;
    byte Reserved1 with BinaryEncoding{Width = 4};
    byte PType with BinaryEncoding{Width = 3};
    bool ProtEn with BinaryEncoding{Width = 1};
    byte PIExponent with BinaryEncoding{Width = 4};
    byte LogicalBlocksPerPhysicalBlockExponent with BinaryEncoding{Width = 4};
    bool LBPME with BinaryEncoding{Width = 1};
    bool LBPRZ with BinaryEncoding{Width = 1};
    ushort LowestAlignedLogicalBlockAddress with BinaryEncoding{Width = 14};
    ulong Reserved2 with BinaryEncoding{Width = 48};
}

// [SBC-3] 5.17.2 READ DEFECT DATA (10) parameter data
type ReadDefectData10ParameterData
{
    ushort Reserved with BinaryEncoding{Width = 11};
    bool PListV with BinaryEncoding{Width = 1};
    bool GListV with BinaryEncoding{Width = 1};
    byte DefectListFormat with BinaryEncoding{Width = 3};
    ushort DefectListLength;
    optional ([|DefectListFormat == 0|] array<ShortBlockFormatAddressDescriptor> | 
        [|DefectListFormat == 0x1|] array<ExtendedBytesFromIndexFormatAddressDescriptor> |
        [|DefectListFormat == 0x2|] array<ExtendedPhysicalSectorFormatAddressDescriptor> |
        [|DefectListFormat == 0x3|] array<LongBlockFormatAddressDescriptor> |
        [|DefectListFormat == 0x4|] array<BytesFromIndexFormatAddressDescriptor> |
        [|DefectListFormat == 0x5|] array<PhysicalSectorFormatAddressDescriptor> |
        binary) DefectList;
}

// [SBC-3] 5.18.2 READ DEFECT DATA (12) parameter data
type ReadDefectData12ParameterData
{
    ushort Reserved with BinaryEncoding{Width = 11};
    bool PListV with BinaryEncoding{Width = 1};
    bool GListV with BinaryEncoding{Width = 1};
    byte DefectListFormat with BinaryEncoding{Width = 3};
    ushort GenerationCode;
    uint DefectListLength;
    optional ([|DefectListFormat == 0|] array<ShortBlockFormatAddressDescriptor> | 
        [|DefectListFormat == 0x1|] array<ExtendedBytesFromIndexFormatAddressDescriptor> |
        [|DefectListFormat == 0x2|] array<ExtendedPhysicalSectorFormatAddressDescriptor> |
        [|DefectListFormat == 0x3|] array<LongBlockFormatAddressDescriptor> |
        [|DefectListFormat == 0x4|] array<BytesFromIndexFormatAddressDescriptor> |
        [|DefectListFormat == 0x5|] array<PhysicalSectorFormatAddressDescriptor> |
        binary) DefectList;
}

// [SBC-3] 5.21.2 REASSIGN BLOCKS parameter list
type ReassignBlocksParameterList[bool LongList, bool LongLBA]
{
    ([|LongList == false|] ReassignBlocksShortParameterListHeader |
    [|LongList == true|] ReassignBlocksLongParameterListHeader) ParameterListHeader;
    optional ([|LongLBA == false|] array<ReassignShortLba> | [|LongLBA == true|] array<ReassignLongLba>) ReassignLbaList;
}

type ReassignBlocksShortParameterListHeader
{
    ushort Reserved;
    ushort ReassignLbaLength;
}

type ReassignBlocksLongParameterListHeader
{
    uint ReassignLbaLength;
}

type ReassignShortLba
{
    uint ReassignLogicalBlockAddress;
}

type ReassignLongLba
{
    ulong ReassignLogicalBlockAddress;
}

// [SBC-3] 5.23.2 REPORT REFERRALS parameter data
type ReportReferralsParameterData
{
    ushort Reserved;
    ushort UserDataSegmentReferralDescriptorLength;
    optional array<UserDataSegmentReferralDescriptor> UserDataSegmentReferralDescriptorList;
}

// [SBC-3] 4.18.4 User data segment referral sense data descriptor
type UserDataSegmentReferralDescriptor
{
    uint Reserved with BinaryEncoding{Width = 24};
    byte NumberOfTargetPortGroupDescriptors;
    ulong FirstUserDataSegmentLba;
    ulong LastUserDataSegmetnLba;
    array<TargetPortGroupDescriptor1> TargetPortGroupDescriptorList with BinaryEncoding{Length = NumberOfTargetPortGroupDescriptors};
}

type TargetPortGroupDescriptor1
{
    byte Reserved1 with BinaryEncoding{Width = 4};
    byte AsymmetricAccessState with BinaryEncoding{Width = 4};
    byte Reserved2;
    ushort TargetPortGroup;
}

// [SBC-3] 5.24.2 SANITIZE command service actions
type OverwriteServiceActionParameterList
{
    bool Invert with BinaryEncoding{Width = 1};
    byte Test with BinaryEncoding{Width = 2};
    byte OverwriteCount with BinaryEncoding{Width = 5};
    byte Reserved;
    ushort InitializationPatternLength;
    binary InitializationPattern with BinaryEncoding{Length = InitializationPatternLength};
}

// [SBC-3] 5.28.2 UNMAP parameter list
type UnmapParameterList
{
    ushort UnmapDataLength;
    ushort UnmapBlockDescriptorDataLength;
    uint Reserved;
    array<UnmapBlockDescriptor> UnmapBlockDescriptorList with BinaryEncoding{Length = (UnmapBlockDescriptorDataLength / 16)};
}

type UnmapBlockDescriptor
{
    ulong UnmapLogicalBlockAddress;
    uint NumberOfLogicalBlocks;
    uint Reserved;
}

// [SBC-3] 5.46.2 WRITE USING TOKEN parameter list
type WriteUsingTokenParameterList
{
    ushort WriteUsingTokenDataLength;
    byte Reserved1 with BinaryEncoding{Width = 6};
    bool DelTkn with BinaryEncoding{Width = 1};
    bool IMMED with BinaryEncoding{Width = 1};
    binary Reserved2 with BinaryEncoding{Length = 5};
    ulong OffsetIntoRod;
    (GenericRodToken | binary) RodToken with BinaryEncoding{WidthForComposedType = 512 * 8, Length = 512};
    binary Reserved3 with BinaryEncoding{Length = 6};
    ushort BlockDeviceRangeDescriptorLength;
    array<BlockDeviceRangeDescriptor> BlockDeviceRangeDescriptor with BinaryEncoding{Length = (BlockDeviceRangeDescriptorLength / 16)};
}

// [SBC-3] 6.2 Address descriptors
type ShortBlockFormatAddressDescriptor
{
    uint ShortBlockAddress;
}

type ExtendedBytesFromIndexFormatAddressDescriptor
{
    uint CylinderNumber with BinaryEncoding{Width = 24};
    byte HeadNumber;
    bool Mads with BinaryEncoding{Width = 1};
    byte Reserved with BinaryEncoding{Width = 3};
    uint BytesFromIndex with BinaryEncoding{Width = 28};
}

type ExtendedPhysicalSectorFormatAddressDescriptor
{
    uint CylinderNumber with BinaryEncoding{Width = 24};
    byte HeadNumber;
    bool Mads with BinaryEncoding{Width = 1};
    byte Reserved with BinaryEncoding{Width = 3};
    uint SectorNumber with BinaryEncoding{Width = 28};
}

type LongBlockFormatAddressDescriptor
{
    ulong LongBlockAddress;
}

type BytesFromIndexFormatAddressDescriptor
{
    uint CylinderNumber with BinaryEncoding{Width = 24};
    byte HeadNumber;
    uint BytesFromIndex;
}

type PhysicalSectorFormatAddressDescriptor
{
    uint CylinderNumber with BinaryEncoding{Width = 24};
    byte HeadNumber;
    uint SectorNumber;
}

// [SBC-3] 6.3 Diagnostic parameters
// [SBC-3] 6.3.2 Rebuild Assist Input diagnostic page
type RebuildAssistInputDiagnosticPage
{
    (byte where value == 0x42) PageCode;
    byte Reserved1;
    ushort PageLength;
    byte Reserved2 with BinaryEncoding{Width = 7};
    bool Enabled with BinaryEncoding{Width = 1};
    ushort Reserved3;
    byte PhysicalElementLength;
    array<byte> DisabledPhysicalElementMask with BinaryEncoding{Length = PhysicalElementLength};
    array<byte> DisabledPhysicalElement with BinaryEncoding{Length = PhysicalElementLength};
}

// [SBC-3] 6.3.3 Rebuild Assist Output diagnostic page
type RebuildAssistOutputDiagnosticPage
{
    (byte where value == 0x42) PageCode;
    byte Reserved1;
    ushort PageLength;
    byte Reserved2 with BinaryEncoding{Width = 7};
    bool Enabled with BinaryEncoding{Width = 1};
    ushort Reserved3;
    byte PhysicalElementLength;
    array<byte> DisabledPhysicalElementMask with BinaryEncoding{Length = PhysicalElementLength};
    array<byte> DisabledPhysicalElement with BinaryEncoding{Length = PhysicalElementLength};
}

// [SBC-3] 6.3.4 Translate Address Input diagnostic page
type TranslateAddressInputDiagnosticPage
{
    (byte where value == 0x40) PageCode;
    byte Reserved1;
    ushort PageLength;
    byte Reserved2 with BinaryEncoding{Width = 5};
    byte SuppliedFormat with BinaryEncoding{Width = 3};
    bool RAREA with BinaryEncoding{Width = 1};
    bool ALTSEC with BinaryEncoding{Width = 1};
    bool ALTTRK with BinaryEncoding{Width = 1};
    byte Reserved3 with BinaryEncoding{Width = 2};
    byte TranslatedFormat with BinaryEncoding{Width = 3};
    array<ulong> TranslatedAddressList with BinaryEncoding{Length = ((PageLength - 2) / 8) };
}

// [SBC-3] 6.3.5 Translate Address Output diagnostic page
type TranslateAddressOutputDiagnosticPage
{
    (byte where value == 0x40) PageCode;
    byte Reserved1;
    ushort PageLength;
    byte Reserved2 with BinaryEncoding{Width = 5};
    byte SuppliedFormat with BinaryEncoding{Width = 3};
    byte Reserved3 with BinaryEncoding{Width = 5};
    byte TranslateFormat with BinaryEncoding{Width = 3};
    ulong AddressToTranslate;
}

// [SBC-3] 6.4 Log parameters
// [SBC-3] 6.4.2 Background Scan log page - Page code (15h) Subpage code (00h)
type BackgroundScanLogPageParameter
{
    array<BackgroundScanStatusLogParameter | BackgroundScanResultsLogParameter> BackgroundScanParameters;
}

type BackgroundScanStatusLogParameter
{
    (ushort where value == 0x0000) ParameterCode;
    bool DU with BinaryEncoding{Width = 1};
    byte Obsolete with BinaryEncoding{Width = 1};
    bool TSD with BinaryEncoding{Width = 1};
    bool ETC with BinaryEncoding{Width = 1};
    byte TMC with BinaryEncoding{Width = 2};
    byte FormatAndLinking with BinaryEncoding{Width = 2};
    byte ParameterLength;
    uint AccumulatedPowerOnMinutes;
    byte Reserved;
    byte BackgroundScanStatus;
    ushort NumberOfBackgroundScansPerformed;
    ushort BackGroundScanProgress;
    ushort NumberOfBacgroundMediumScansPerformed;
}

type BackgroundScanResultsLogParameter
{
    (ushort where value >= 0x0001 && value <= 0x0800) ParameterCode;
    bool DU with BinaryEncoding{Width = 1};
    byte Obsolete with BinaryEncoding{Width = 1};
    bool TSD with BinaryEncoding{Width = 1};
    bool ETC with BinaryEncoding{Width = 1};
    byte TMC with BinaryEncoding{Width = 2};
    byte FormatAndLinking with BinaryEncoding{Width = 2};
    byte ParameterLength;
    uint AccumulatedPowerOnMinutes;
    byte ReassignStatus with BinaryEncoding{Width = 4};
    byte SenseKey with BinaryEncoding{Width = 4};
    byte AdditionalSenseKey;
    array<byte> VendorSpecific with BinaryEncoding{Length = 5};
    ulong LogicalBlockAddress;
}

// [SBC-3] 6.4.3 Format Status log page - Page code (08h) Subpage code (00h)
type FormatStatusLogPageParameter
{
    array<FormatStatusLogParameter> FormatStatusLogParameters;
}

type FormatStatusLogParameter
{
    ushort ParameterCode;
    bool DU with BinaryEncoding{Width = 1};
    byte Obsolete with BinaryEncoding{Width = 1};
    bool TSD with BinaryEncoding{Width = 1};
    bool ETC with BinaryEncoding{Width = 1};
    byte TMC with BinaryEncoding{Width = 2};
    byte FormatAndLinking with BinaryEncoding{Width = 2};
    byte ParameterLength;
    ([|ParameterCode == 0x0000|] FormatDataOutLogParameter[ParameterLength] |
     [|ParameterCode == 0x0001|] GrownDefectsDuringCertificationLogParameter |
     [|ParameterCode == 0x0002|] TotalBlocksReassignedDuringFormatLogParameter |
     [|ParameterCode == 0x0003|] TotalNewBlocksReassignedLogParameter |
     [|ParameterCode == 0x0004|] PowerOnMinutesSinceFormatLogParameter |
     binary) ParameterValue with BinaryEncoding{Length = ParameterLength};
}

type FormatDataOutLogParameter[byte Len]
{
    binary FormatDataOut with BinaryEncoding{Length = Len};
}

type GrownDefectsDuringCertificationLogParameter
{
    ulong GrownDefectsDuringCertification;
}

type TotalBlocksReassignedDuringFormatLogParameter
{
    ulong TotalBlocksReassignedDuringFormat;
}

type TotalNewBlocksReassignedLogParameter
{
    ulong TotalNewBlocksReassigned;
}

type PowerOnMinutesSinceFormatLogParameter
{
    uint PowerOnMinutesSinceFormat;
}

// [SBC-3] 6.4.4 Logical Block Provisioning log page - Page code (0Ch) Subpage code (00h)
type LogicalBlockProvisioningLogPageParameter
{
    array<ResourceCountLogParameter> LogicalBlockProvisioningParameterList;
}

type ResourceCountLogParameter
{
    byte ParameterCode;
    bool DU with BinaryEncoding{Width = 1};
    byte Obsolete with BinaryEncoding{Width = 1};
    bool TSD with BinaryEncoding{Width = 1};
    bool ETC with BinaryEncoding{Width = 1};
    byte TMC with BinaryEncoding{Width = 2};
    byte FormatAndLinking with BinaryEncoding{Width = 2};
    byte ParameterLength;
    uint ResourceCount;
    byte Reserved1 with BinaryEncoding{Width = 6};
    byte Scope with BinaryEncoding{Width = 2};
    uint Reserved2 with BinaryEncoding{Width = 24};
}

// [SBC-3] 6.4.5 Non-volatile Cache log page - Page code (17h) Subpage code (00h)
type NonvolatileCacheLogPageParameter
{
    array<RemainingNonvolatileTimeParameterData | MaximumNonvolatileTimeParameterData> NonvolatileCacheLogParameters;
}

type RemainingNonvolatileTimeParameterData
{
    (byte where value == 0x0000) ParameterCode;
    bool DU with BinaryEncoding{Width = 1};
    byte Obsolete1 with BinaryEncoding{Width = 1};
    bool TSD with BinaryEncoding{Width = 1};
    bool ETC with BinaryEncoding{Width = 1};
    byte TMC with BinaryEncoding{Width = 2};
    byte FormatAndLinking with BinaryEncoding{Width = 2};
    byte ParameterLength;
    byte Obsolete2;
    uint RemainingNonvolatileTime with BinaryEncoding{Width = 24};
}

type MaximumNonvolatileTimeParameterData
{
    (byte where value == 0x0001) ParameterCode;
    bool DU with BinaryEncoding{Width = 1};
    byte Obsolete1 with BinaryEncoding{Width = 1};
    bool TSD with BinaryEncoding{Width = 1};
    bool ETC with BinaryEncoding{Width = 1};
    byte TMC with BinaryEncoding{Width = 2};
    byte FormatAndLinking with BinaryEncoding{Width = 2};
    byte ParameterLength;
    byte Obsolete2;
    uint MaximumNonvolatileTime with BinaryEncoding{Width = 24};
}

// [SBC-3] 6.4.6 Solid State Media log page - Page code (11h) Subpage code (00h)
type SolidStateMediaLogPageParameter
{
    array<PercentageUsedEnduranceIndicatorLogParameter> SolidStateMediaLogParameters;
}

type PercentageUsedEnduranceIndicatorLogParameter
{
    (byte where value == 0x0001) ParameterCode;
    bool DU with BinaryEncoding{Width = 1};
    byte Obsolete with BinaryEncoding{Width = 1};
    bool TSD with BinaryEncoding{Width = 1};
    bool ETC with BinaryEncoding{Width = 1};
    byte TMC with BinaryEncoding{Width = 2};
    byte FormatAndLinking with BinaryEncoding{Width = 2};
    byte ParameterLength;
    uint Reserved with BinaryEncoding{Width = 24};
    byte PercentageUsedEnduranceIndicator;
}

// [SBC-3] 6.5 Mode parameters
// [SBC-3] 6.5.2 Mode parameter block descriptors
type ShortLBAModeParameterBlockDescriptor
{
    uint NumberOfLogicalBlocks;
    byte Reserved;
    uint LogicalBlockLength with BinaryEncoding{Width = 24};
}

type LongLBAModeParameterBlockDescriptor
{
    ulong NumberOfLogicalBlocks;
    uint Reserved;
    uint LogicalBlockLength;
}

// [SBC-3] 6.5.3 Application Tag mode page - Page code (0Ah) Subpage code (02h)
type ApplicationTagModePageParameter
{
    binary Reserved with BinaryEncoding{Length = 12};
    array<ApplicationTagDescriptor> ApplicationTagDescriptors;
}

type ApplicationTagDescriptor
{
    bool Last with BinaryEncoding{Width = 1};
    ulong Reserved with BinaryEncoding{Width = 47};
    ushort LogicalBlockApplicationTag;
    ulong LogicalBlockAddress;
    ulong LogicalBlockCount;
}

// [SBC-3] 6.5.4 Background Control mode page - Page code (1Ch) Subpage code (01h)
type BackgroundControlModePageParameter
{
    byte Reserved1 with BinaryEncoding{Width = 5};
    bool S_L_FULL with BinaryEncoding{Width = 1};
    bool LOWIR with BinaryEncoding{Width = 1};
    bool EN_BMS with BinaryEncoding{Width = 1};
    byte Reserved2 with BinaryEncoding{Width = 7};
    bool EN_PS with BinaryEncoding{Width = 1};
    ushort BackgroundMediumScanIntervalTime;
    ushort BackfroundPrescanTimeLimit;
    ushort MinimumIdleTimeBeforeBackgroundScan;
    ushort MaximumTimeToSuspendBackgroundScan;
    ushort Reserved3;
}

// [SBC-3] 6.5.5 Caching mode page - Page code (08h)
type CachingModePageParameter
{
    bool IC with BinaryEncoding{Width = 1};
    bool ABPF with BinaryEncoding{Width = 1};
    bool CAP with BinaryEncoding{Width = 1};
    bool DISC with BinaryEncoding{Width = 1};
    bool SIZE with BinaryEncoding{Width = 1};
    bool WCE with BinaryEncoding{Width = 1};
    bool MF with BinaryEncoding{Width = 1};
    bool RCD with BinaryEncoding{Width = 1};
    byte DemandReadRetentionPriority with BinaryEncoding{Width = 4};
    byte WriteRetentionPriority with BinaryEncoding{Width = 4};
    ushort DisablePrefetchTransferLength;
    ushort MinimumPrefetch;
    ushort MaximumPrefetch;
    ushort MaximumPrefetchCeiling;
    bool FSW with BinaryEncoding{Width = 1};
    bool LBCSS with BinaryEncoding{Width = 1};
    bool DRA with BinaryEncoding{Width = 1};
    byte VendorSpecific with BinaryEncoding{Width = 2};
    byte SYNC_PROG with BinaryEncoding{Width = 2};
    bool NV_DIS with BinaryEncoding{Width = 1};
    byte NumberOfCacheSegments;
    ushort CacheSegmentSize;
    byte Reserved;
    uint Obsolete with BinaryEncoding{Width = 24};
}

// [SBC-3] 6.5.6 Informational Exceptions Control mode page - Page code (1Ch)
type InformationalExceptionsControlModePageParameter
{
    bool PERF with BinaryEncoding{Width = 1};
    byte Reserved1 with BinaryEncoding{Width = 1};
    bool EBF with BinaryEncoding{Width = 1};
    bool EWasc with BinaryEncoding{Width = 1};
    bool DExcpt with BinaryEncoding{Width = 1};
    bool Test with BinaryEncoding{Width = 1};
    bool EBACKERR with BinaryEncoding{Width = 1};
    bool LogErr with BinaryEncoding{Width = 1};
    byte Reserved2 with BinaryEncoding{Width = 4};
    byte MRIE with BinaryEncoding{Width = 4};
    uint IntervalTimer;
    uint ReportCount;
}

// [SBC-3] 6.5.7 Logical Block Provisioning mode page - Page code (1Ch) Subpage Code (02h)
type LogicalBlockProvisioningModePageParameter
{
    byte Reserved1 with BinaryEncoding{Width = 7};
    bool SITUA with BinaryEncoding{Width = 1};
    binary Reserved2 with BinaryEncoding{Length = 11};
    array<ThresholdDescriptor> ThresholdDescriptors;
}

type ThresholdDescriptor
{
    bool Enabled with BinaryEncoding{Width = 1};
    byte Reserved1 with BinaryEncoding{Width = 1};
    byte ThresholdType with BinaryEncoding{Width = 3};
    byte ThresholdArming with BinaryEncoding{Width = 3};
    byte ThresholdResource;
    uint ThresholdCount;
}

// [SBC-3] 6.5.8 Read-Write Error Recovery mode page - Page code (01h)
type ReadWriteErrorRecoverModePageParameter
{
    bool AWRE with BinaryEncoding{Width = 1};
    bool ARRE with BinaryEncoding{Width = 1};
    bool TB with BinaryEncoding{Width = 1};
    bool PC with BinaryEncoding{Width = 1};
    bool EER with BinaryEncoding{Width = 1};
    bool PER with BinaryEncoding{Width = 1};
    bool DTE with BinaryEncoding{Width = 1};
    bool DCR with BinaryEncoding{Width = 1};
    byte ReadRetryCount;
    binary Obsolete with BinaryEncoding{Length = 3};
    bool LBPERE with BinaryEncoding{Width = 1};
    byte Reserved1 with BinaryEncoding{Width = 5};
    byte RestrictedForMMC6 with BinaryEncoding{Width = 2};
    byte WriteRetryCount;
    byte Reserved2;
    ushort RecoveryTimeLimit;
}

// [SBC-3] 6.5.9 Verify Error Recovery mode page - Page code (07h)
type VerifyErrorRecoverModePageParameter
{
    byte Reserved1 with BinaryEncoding{Width =4};
    bool EER with BinaryEncoding{Width = 1};
    bool PER with BinaryEncoding{Width = 1};
    bool DTE with BinaryEncoding{Width = 1};
    bool DCR with BinaryEncoding{Width = 1};
    byte VerifyRetryCount;
    byte Obsolete;
    binary Reserved2 with BinaryEncoding{Length = 5};
    ushort VerifyRecoveryTimeLimit;
}

// [SBC-3] 6.6 Vital product data (VPD) parameters
// [SBC-3] 6.6.2 Block Device Characteristics VPD page - Page Code (B1h)
type BlockDeviceCharacteristicVPDPageParameter
{
    ushort MediumPotationRate;
    byte ProductType;
    byte WABEREQ with BinaryEncoding{Width = 2};
    byte WACEREQ with BinaryEncoding{Width = 2};
    byte NominalFormFactor with BinaryEncoding{Width = 4};
    byte Reserved1 with BinaryEncoding{Width = 6};
    bool FUAB with BinaryEncoding{Width = 1};
    bool VBULS with BinaryEncoding{Width = 1};
    binary Reserved2 with BinaryEncoding{Length = 55};
}

// [SBC-3] 6.6.3 Block Limits VPD page - Page Code (B0h)
type BlockLimitsVPDPageParameter
{
    byte Reserved1 with BinaryEncoding{Width = 7};
    bool WSNZ with BinaryEncoding{Width = 1};
    byte MaximumCompareAndWriteLength;
    ushort OptimalTransferLengthGranularity;
    uint MaximumTransferLength;
    uint OptimalTransferLength;
    uint MaximumPrefetchLength;
    uint MaximumUnmapLBACount;
    uint MaximumUnmapBlockDescriptorCount;
    uint OptimalUnmapGranularity;
    bool UGAValid with BinaryEncoding{Width = 1};
    uint UnmapGranularityAlignment with BinaryEncoding{Width = 31};
    ulong MaximumWriteSameLength;
    binary Reserved2 with BinaryEncoding{Length = 20};
}

// [SBC-3] 6.6.4 Logical Block Provisioning VPD page - Page Code (B2h)
type LogicalBlockProvisioningVPDPageParameter
{
    byte ThresholdExponent;
    bool LBPU with BinaryEncoding{Width = 1};
    bool LBPWS with BinaryEncoding{Width = 1};
    bool LBPWS10 with BinaryEncoding{Width = 1};
    byte Reserved1 with BinaryEncoding{Width = 2};
    bool LBPRZ with BinaryEncoding{Width = 1};
    bool ANC_SUP with BinaryEncoding{Width = 1};
    bool DP with BinaryEncoding{Width = 1};
    
    byte Reserved2 with BinaryEncoding{Width = 5};
    byte ProvisioningType with BinaryEncoding{Width = 3};
    byte Reserved3;
    binary ProvisioningGroupDescriptor;
}

// [SBC-3] 6.6.5 Referrals VPD page - Page Code (B3h)
type ReferralsVPDPageParameter
{
    uint Reserved;
    uint UserDataSegmentSize;
    uint UserDataSegmentMultiplier;
}

// [SBC-3] 6.6.6.3 Block Device ROD Token Limits descriptor
type BlockDeviceRODTokenLimitsDescriptorParameter
{
    array<byte> VendorSpecific with BinaryEncoding{Length = 6};
    ushort MaximumRangeDescriptors;
    uint MaximumInactivityTimeout;
    uint DefaultInactivityTimeout;
    ulong MaximumTokenTransferSize;
    ulong OptimalTransferCount;
}

// [SPC-4] 5.16.6.5 Generic ROD tokens
type GenericRodToken
{
    uint RodType;
    ushort Reserved1;
    ushort RodTokenLength;
    ulong CopyManagerRodTokenIdentifier;
    CscdDescriptor CreatorLogicalUnitDescriptor;
    array<byte> NumberOfBytesRepresented with BinaryEncoding{Length = 16};
    array<byte> Reserved2 with BinaryEncoding{Length = 32};
    binary DeviceTypeSpecificData with BinaryEncoding{Length = 32};
    DesignationDescriptor TargetDeviceDescriptor;
    binary ExtendedRodTokenData;
}

// [SPC-4] OBSOLETE    CHANGE DEFINITION command - OPERATION CODE (40h)
type ChangeDefinitionCommandParameters
{
    array<byte> Reserved1 with BinaryEncoding{Length = 3};
    
    byte Reserved2 with BinaryEncoding{Width = 7};
    bool Save with BinaryEncoding{Width = 1};
    
    byte Reserved3 with BinaryEncoding{Width = 1};
    byte DefinitionParam with BinaryEncoding{Width = 7};
    
    array<byte> Reserved4 with BinaryEncoding{Length = 4};
    byte ParameterListLength;
}

// [SPC-4] OBSOLETE    RELEASE (6) command - OPERATION CODE (17h)
type Release6CommandParameters
{
    ushort Reserved1 with BinaryEncoding{Width = 3};
    ushort Obsolete with BinaryEncoding{Width = 13};

    array<byte> Reserved2 with BinaryEncoding{Length = 2};
}

// [SPC-4] OBSOLETE    RELEASE (10) command - OPERATION CODE (57h)
type Release10CommandParameters
{
    byte Reserved1 with BinaryEncoding{Width = 3};
    bool ThirdParty with BinaryEncoding{Width = 1};
    byte Reserved2 with BinaryEncoding{Width = 2};
    byte LongId with BinaryEncoding{Width = 1};
    byte Obsolete with BinaryEncoding{Width = 1};
    
    byte ThirdPtyDeviceId;
    array<byte> Reserved3 with BinaryEncoding{Length = 3};
    ushort ParameterListLength;
}

pattern ServiceActionIn16CommandParameters = ReadLong16CommandParameters 
                                          | ReadCapacity16CommandParameters 
                                          | ReportReferralsCommandParameters 
                                          | GetLbaStatusCommandParameters;

pattern MaintenanceOutCommandParameters = ChangeAliasesCommandParameters 
                                          | ManagementProtocolOutCommandParameters 
                                          | RemoveITNexusCommandParameters 
                                          | SetIdentifyingInformationCommandParameters 
                                          | SetPriorityCommandParameters 
                                          | SetTargetPortGroupsCommandParameters 
                                          | SetTimestampCommandParameters;
    
pattern OperationCode83hCommandParameters = PopulateTokenCommandParameters 
                                          | WriteUsingTokenCommandParameters 
                                          | CopyOperationAbortCommandParameters 
                                          | ExtendedCopyLID4CommandParameters 
                                          | ExtendedCopyLID1CommandParameters;
    
pattern MaintenanceInCommandParameters = ManagementProtocolInCommandParameters
                                          | ReportAliasesCommandParameters
                                          | ReportIdentifyingInformationCommandParameters
                                          | ReportPriorityCommandParameters
                                          | ReportSupportedOperationCodesCommandParameters
                                          | ReportSupportedTaskManagementFunctionsCommandParameters
                                          | ReportTargetPortGroupsCommandParameters
                                          | ReportTimestampCommandParameters;

pattern OperationCode84hCommandParameters = ReceiveCopyDataLID4CommandParameters
                                          | ReceiveCopyDataLID1CommandParameters
                                          | ReceiveCopyOperatingPatametersCommandParameters
                                          | ReceiveCopyFailureDetailsLID1CommandParameters
                                          | ReceiveCopyStatusLID4CommandParameters
                                          | ReceiveCopyStatusLID1CommandParameters
                                          | ReceiveRodTokenInformationCommandParameters
                                          | ReportAllRodTokensCommandParameters;
                                          
// Commands specified in [SPC-4]
    
// [SPC-4] 6.2 CHANGE ALIASES command - OPERATION CODE (A4h)
type ChangeAliasesCommandParameters
{
    byte Reserved1 with BinaryEncoding{Width = 3};
    (byte where value == 0x0B) ServiceAction with BinaryEncoding{Width = 5};
    uint Reserved2;
    uint ParameterListLength;
    byte Reserved3;
}

// [SPC-4] 6.3 COPY OPERATION ABORT command - OPERATION CODE (83h)
type CopyOperationAbortCommandParameters
{
    byte Reserved1 with BinaryEncoding{Width = 3};
    (byte where value == 0x1C) ServiceAction with BinaryEncoding{Width = 5};
    uint ListIdentifier;
    binary Reserved2 with BinaryEncoding{Length = 9};
}

// [SPC-4] 6.4 EXTENDED COPY(LID4) command - OPERATION CODE (83h)
type ExtendedCopyLID4CommandParameters
{
    byte Reserved1 with BinaryEncoding{Width = 3};
    (byte where value == 0x01) ServiceAction with BinaryEncoding{Width = 5};
    ulong Reserved2;
    uint ParameterListLength;
    byte Reserved3;
}

// [SPC-4] 6.6 EXTENDED COPY(LID1) command - OPERATION CODE (83h)
type ExtendedCopyLID1CommandParameters
{
    byte Reserved1 with BinaryEncoding{Width = 3};
    (byte where value == 0x00) ServiceAction with BinaryEncoding{Width = 5};
    ulong Reserved2;
    uint ParameterListLength;
    byte Reserved3;
}

// [SPC-4] 6.6 INQUIRY command - OPERATION CODE (12h)
type InquiryCommandParameters
{
    byte Reserved with BinaryEncoding{Width = 6};
    byte Obsolete with BinaryEncoding{Width = 1};
    bool EVPD with BinaryEncoding{Width = 1};

    VPDPageCode PageCode;
    ushort AllocationLength;
}

// [SPC-4] 6.7 LOG SELECT command - OPERATION CODE (4Ch)
type LogSelectCommandParameters
{
    byte Reserved1 with BinaryEncoding{Width = 6};
    bool PCR with BinaryEncoding{Width = 1};
    bool SP with BinaryEncoding{Width = 1};
    
    byte PC with BinaryEncoding{Width = 2};
    byte PageCode with BinaryEncoding{Width = 6};
    
    byte SubpageCode;
    array<byte> Reserved3 with BinaryEncoding{Length = 3};
    ushort ParametersListLength;
}
 
// [SPC-4] 6.8 LOG SENSE command - OPERATION CODE (4Dh)
type LogSenseCommandParameters
{
    byte Reserved1 with BinaryEncoding{Width = 6};
    byte PCR_Obsolete with BinaryEncoding{Width = 1};
    bool SP with BinaryEncoding{Width = 1};
    
    byte PC with BinaryEncoding{Width = 2};
    byte PageCode with BinaryEncoding{Width = 6};
    
    byte SubpageCode;
    byte Reserved2;
    ushort ParameterPointer;
    ushort AllocationLength;
}

// [SPC-4] 6.9 MANAGEMENT PROTOCOL IN command - OPERATION CODE (A3h) 
type ManagementProtocolInCommandParameters
{
    byte Reserved1 with BinaryEncoding{Width = 3};
    (byte where value == 0x10) ServiceAction with BinaryEncoding{Width = 5};
    byte ManagementProtocol;
    uint ManagementProtocolSpecific1 with BinaryEncoding{Width = 24};
    uint AllocationLength;
    byte ManagementProtocolSpecific2;
}

// [SPC-4] 6.10 MANAGEMENT PROTOCOL OUT command - OPERATION CODE (A4h) 
type ManagementProtocolOutCommandParameters
{
    byte Reserved1 with BinaryEncoding{Width = 3};
    (byte where value == 0x10) ServiceAction with BinaryEncoding{Width = 5};
    byte ManagementProtocol;
    uint ManagementProtocolSpecific1 with BinaryEncoding{Width = 24};
    uint AllocationLength;
    byte ManagementProtocolSpecific2;
}

// [SPC-4] 6.11 MODE SELECT(6) command - OPERATION CODE (15h)
type ModeSelect6CommandParameters
{
    byte Reserved1 with BinaryEncoding{Width = 3};
    bool PF with BinaryEncoding{Width = 1};
    byte Reserved2 with BinaryEncoding{Width = 3};
    bool SP with BinaryEncoding{Width = 1};
    
    ushort Reserved3;
    byte ParametersListLength;
}

// [SPC-4] 6.12 MODE SELECT(10) command - OPERATION CODE (55h)
type ModeSelect10CommandParameters
{
    byte Reserved1 with BinaryEncoding{Width = 3};
    bool PF with BinaryEncoding{Width = 1};
    byte Reserved2 with BinaryEncoding{Width = 3};
    bool SP with BinaryEncoding{Width = 1};
    
    array<byte> Reserved3 with BinaryEncoding{Length = 5};
    ushort ParametersListLength;
}

// [SPC-4] 6.13 MODE SENSE(6) command - OPERATION CODE (1Ah)
type ModeSense6CommandParameters
{
    byte Reserved1 with BinaryEncoding{Width = 4};
    bool DBD with BinaryEncoding{Width = 1};
    byte Reserved2 with BinaryEncoding{Width = 3};
    
    byte PC with BinaryEncoding{Width = 2};
    byte PageCode with BinaryEncoding{Width = 6};
    
    byte SubpageCode;
    byte AllocationLength;
}

// [SPC-4] 6.14 MODE SENSE(10) command - OPERATION CODE (5Ah)
type ModeSense10CommandParameters
{
    byte Reserved1 with BinaryEncoding{Width = 3};
    bool LLBAA with BinaryEncoding{Width = 1};
    bool DBD with BinaryEncoding{Width = 1};
    byte Reserved2 with BinaryEncoding{Width = 3};
    
    byte PC with BinaryEncoding{Width = 2};
    byte PageCode with BinaryEncoding{Width = 6};
    
    byte SubpageCode;
    array<byte> Reserved3 with BinaryEncoding{Length = 3};
    ushort AllocationLength;
}

// [SPC-4] 6.15 PERSISTENT RESERVE IN command - OPERATION CODE (5Eh)
type PersistentReserveInCommandParameters
{
    byte Reserved1 with BinaryEncoding{Width = 3};
    PersistentReserveInServiceAction ServiceAction with BinaryEncoding{Width = 5};
    
    array<byte> Reserved2 with BinaryEncoding{Length = 5};
    ushort AllocationLength;
}

pattern PersistentReserveInServiceAction = enum byte
{
    ReadKeys            = 0x00,
    ReadReservation     = 0x01,
    ReportCapabilities  = 0x02,
    ReadFullStatus      = 0x03,
    ...
};

// [SPC-4] 6.16 PERSISTENT RESERVE OUT command - OPERATION CODE (5Fh)
type PersistentReserveOutCommandParameters
{
    byte Reserved1 with BinaryEncoding{Width = 3};
    PersistentReserveOutServiceAction ServiceAction with BinaryEncoding{Width = 5};
    
    byte Scope with BinaryEncoding{Width = 4};
    byte Type with BinaryEncoding{Width = 4};
    
    ushort Reserved2;
    uint ParametersListLength;
}

pattern PersistentReserveOutServiceAction = enum byte
{
    Register                       = 0x00,
    Reserve                        = 0x01,
    Release                        = 0x02,
    Clear                          = 0x03,
    Preempt                        = 0x04,
    PreemptAndAbort                = 0x05,
    RegisterAndIgnoreExistingKey   = 0x06,
    RegisterAndMove                = 0x07,
    ReplaceLostReservation         = 0x08,
    ...
};

// [SPC-4] 6.17 READ ATTRIBUTE command - OPERATION CODE (8Ch)
type ReadAttributeCommandParameters
{
    byte Reserved1 with BinaryEncoding{Width = 3};
    ReadAttributeServiceAction ServiceAction with BinaryEncoding{Width = 5};
    uint Restricted with BinaryEncoding{Width = 24};
    byte LogicalVolumeNumber;
    byte Reserved2;
    byte PartitionNumber;
    ushort FirstAttributeIdentifier;
    uint AllocationLength;
    byte Reserved3;
}

pattern ReadAttributeServiceAction = enum byte
{
    AttributeValues      = 0x00,
    AttributeList        = 0x01,
    LogicalVolumeList    = 0x02,
    PartitionList        = 0x03,
    Restricted           = 0x04,
    SupportedAttributes  = 0x05,
    ...
};

// [SPC-4] 6.18 READ BUFFER command - OPERATION CODE (3Ch)
type ReadBufferCommandParameters
{
    byte Reserved1 with BinaryEncoding{Width = 3};
    ReadBufferMode Mode with BinaryEncoding{Width = 5};
    
    byte BufferId;
    uint BufferOffset with BinaryEncoding{Width = 24};
    uint AllocationLength with BinaryEncoding{Width = 24};
}

pattern ReadBufferMode = enum byte
{
    $"Combined header and data"     = 0x00,
    $"Vendor specific"              = 0x01,
    Data                            = 0x02,
    Descriptor                      = 0x03,
    $"Read data from echo buffer"   = 0x0A,
    $"Echo buffer descriptor"       = 0x0B,
    $"Enable expander communications protocol and Echo buffer"   = 0x1A,
    $"Error history"                = 0x0C,
};

// [SPC-4] 6.19 READ MEDIA SERIAL NUMBER command - OPERATION CODE (ABh)
type ReadMediaSerialNumberCommandParameters
{
    byte Reserved1 with BinaryEncoding{Width = 3};
    (byte where value == 0x01) ServiceAction with BinaryEncoding{Width = 5};
    uint Reserved2;
    uint AllocationLength;
    byte Reserved3;
}

// [SPC-4] 6.20 RECEIVE COPY DATA(LID4) command - OPERATION CODE (84h)
type ReceiveCopyDataLID4CommandParameters
{
    byte Reserved1 with BinaryEncoding{Width = 3};
    (byte where value == 0x06) ServiceAction with BinaryEncoding{Width = 5};
    uint ListIdentifier;
    uint Reserved2;
    uint AllocationLength;
    byte Reserved3;
}

// [SPC-4] 6.21 RECEIVE COPY DATA(LID1) command - OPERATION CODE (84h)
type ReceiveCopyDataLID1CommandParameters
{
    byte Reserved1 with BinaryEncoding{Width = 3};
    (byte where value == 0x01) ServiceAction with BinaryEncoding{Width = 5};
    byte ListIdentifier;
    binary Reserved2 with BinaryEncoding{Length = 7};
    uint AllocationLength;
    byte Reserved3;
}

// [SPC-4] 6.22 RECEIVE COPY OPERATING PARAMETERS command - OPERATION CODE (84h)
type ReceiveCopyOperatingPatametersCommandParameters
{
    byte Reserved1 with BinaryEncoding{Width = 3};
    (byte where value == 0x03) ServiceAction with BinaryEncoding{Width = 5};
    ulong Reserved2;
    uint AllocationLength;
    byte Reserved3;
}

// [SPC-4] 6.23 RECEIVE COPY FAILURE DETAILS(LID1) command - OPERATION CODE (84h)
type ReceiveCopyFailureDetailsLID1CommandParameters
{
    byte Reserved1 with BinaryEncoding{Width = 3};
    (byte where value == 0x04) ServiceAction with BinaryEncoding{Width = 5};
    byte ListIdentifier;
    binary Reserved2 with BinaryEncoding{Length = 7};
    uint AllocationLength;
    byte Reserved3;
}

// [SPC-4] 6.24 RECEIVE COPY STATUS(LID4) command - OPERATION CODE (84h)
type ReceiveCopyStatusLID4CommandParameters
{
    byte Reserved1 with BinaryEncoding{Width = 3};
    (byte where value == 0x05) ServiceAction with BinaryEncoding{Width = 5};
    uint ListIdentifier;
    uint Reserved2;
    uint AllocationLength;
    byte Reserved3;
}

// [SPC-4] 6.25 RECEIVE COPY STATUS(LID1) command - OPERATION CODE (84h)
type ReceiveCopyStatusLID1CommandParameters
{
    byte Reserved1 with BinaryEncoding{Width = 3};
    (byte where value == 0x00) ServiceAction with BinaryEncoding{Width = 5};
    byte ListIdentifier;
    binary Reserved2 with BinaryEncoding{Length = 7};
    uint AllocationLength;
    byte Reserved3;
}

// [SPC-4] 6.26 RECEIVE ROD TOKEN INFORMATION command - OPERATION CODE (84h)
type ReceiveRodTokenInformationCommandParameters
{
    byte Reserved1 with BinaryEncoding{Width = 3};
    (byte where value == 0x07) ServiceAction with BinaryEncoding{Width = 5};
    uint ListIdentifier;
    uint Reserved2;
    uint AllocationLength;
    byte Reserved3;
}

// [SPC-4] 6.27 RECEIVE CREDENTIAL command - OPERATION CODE (7Fh)
type ReceiveCredentialCommandParameters
{
    binary Reserved with BinaryEncoding{Length = 5};
    byte AdditionalCDBLength;
    (ushort where value == 0x1800) ServiceAction;
    ushort AllocationLength;
    uint AcSai;
    binary EncryptedRequestDescriptor;
}

// [SPC-4] 6.28 RECEIVE DIAGNOSTIC RESULTS command - OPERATION CODE (1Ch)
type ReceiveDiagnosticResultsCommandParameters
{
    byte Reserved with BinaryEncoding{Width = 7};
    bool PCV with BinaryEncoding{Width = 1};
    
    byte PageCode;
    ushort AllocationLength;
}

// [SPC-4] 6.29 REMOVE I_T NEXUS command - OPERATION CODE (A4h)
type RemoveITNexusCommandParameters
{
    byte Reserved1 with BinaryEncoding{Width = 3};
    (byte where value == 0x0C) ServiceAction with BinaryEncoding{Width = 5};
    uint Reserved2;
    uint ParameterListLength;
    byte Reserved3;
}

// [SPC-4] 6.30 REPORT ALIASES command - OPERATION CODE (A3h)
type ReportAliasesCommandParameters
{
    byte Reserved1 with BinaryEncoding{Width = 3};
    (byte where value == 0x0B) ServiceAction with BinaryEncoding{Width = 5};
    
    uint Reserved2;
    uint AllocationLength;
    byte Reserved3;
}

// [SPC-4] 6.31 REPORT ALL ROD TOKENS command - OPERATION CODE (84h)
type ReportAllRodTokensCommandParameters
{
    byte Reserved1 with BinaryEncoding{Width = 3};
    (byte where value == 0x08) ServiceAction with BinaryEncoding{Width = 5};
    
    ulong Reserved2;
    uint AllocationLength;
    byte Reserved3;
}

// [SPC-4] 6.32 REPORT IDENTIFYING INFORMATION command - OPERATION CODE (A3h)
type ReportIdentifyingInformationCommandParameters
{
    byte Reserved1 with BinaryEncoding{Width = 3};
    (byte where value == 0x05) ServiceAction with BinaryEncoding{Width = 5};
    
    ushort Reserved2;
    ushort Restricted;
    uint AllocationLength;
    
    byte IdentifyingInformationType with BinaryEncoding{Width = 7};
    byte Reserved3 with BinaryEncoding{Width = 1};
}

// [SPC-4] 6.33 REPORT LUNS command - OPERATION CODE (A0h)
type ReportLunsCommandParameters
{
    byte Reserved1;
    byte SelectReport;
    array<byte> Reserved2 with BinaryEncoding{Length = 3};
    uint AllocationLength;
    byte Reserved3;
}

// [SPC-4] 6.34 REPORT PRIORITY command - OPERATION CODE (A3h)
type ReportPriorityCommandParameters
{
    byte Reserved1 with BinaryEncoding{Width = 3};
    (byte where value == 0x0E) ServiceAction with BinaryEncoding{Width = 5};
    
    byte PriorityReported with BinaryEncoding{Width = 2};
    uint Reserved2 with BinaryEncoding{Width = 30};
    uint AllocationLength;
    byte Reserved3;
}

// [SPC-4] 6.35 REPORT SUPPORTED OPERATION CODES command - OPERATION CODE (A3h)
type ReportSupportedOperationCodesCommandParameters
{
    byte Reserved1 with BinaryEncoding{Width = 3};
    (byte where value == 0x0C) ServiceAction with BinaryEncoding{Width = 5};
    
    bool RCTD with BinaryEncoding{Width = 1};
    byte Reserved2 with BinaryEncoding{Width = 4};
    byte ReportingOptions with BinaryEncoding{Width = 3};
    
    byte RequestedOperationCode;
    ushort RequestedServiceAction;
    
    uint AllocationLength;
    byte Reserved4;
}

// [SPC-4] 6.36 REPORT SUPPORTED TASK MANAGEMENT FUNCTIONS command - OPERATION CODE (A3h)
type ReportSupportedTaskManagementFunctionsCommandParameters
{
    byte Reserved1 with BinaryEncoding{Width = 3};
    (byte where value == 0x0D) ServiceAction with BinaryEncoding{Width = 5};
    
    bool REPD with BinaryEncoding{Width = 1};
    uint Reserved2 with BinaryEncoding{Width = 2};
    uint AllocationLength;
    byte Reserved3;
}

// [SPC-4] 6.37 REPORT TARGET PORT GROUPS command - OPERATION CODE (A3h)
type ReportTargetPortGroupsCommandParameters
{
    byte ParameterDataFormat with BinaryEncoding{Width = 3};
    (byte where value == 0x0A) ServiceAction with BinaryEncoding{Width = 5};
    
    uint Reserved1;
    uint AllocationLength;
    byte Reserved2;
}

// [SPC-4] 6.38 REPORT TIMESTAMP command - OPERATION CODE (A3h)
type ReportTimestampCommandParameters
{
    byte Reserved1 with BinaryEncoding{Width = 3};
    (byte where value == 0x0F) ServiceAction with BinaryEncoding{Width = 5};
    
    uint Reserved2;
    uint AllocationLength;
    byte Reserved3;
}

// [SPC-4] 6.39 REQUEST SENSE command - OPERATION CODE (03h)
type RequestSenseCommandParameters
{
    byte Reserved1 with BinaryEncoding{Width = 7};
    bool DESC with BinaryEncoding{Width = 1};
    
    ushort Reserved2;
    byte AllocationLength;
}

// [SPC-4] 6.40 SECURITY PROTOCOL IN command - OPERATION CODE (A2h)
type SecurityProtocolInCommandParameters
{
    SecurityProtocol SecurityProtocol;
    ushort SecurityProtocolSpecific;
    bool INC512 with BinaryEncoding{Width = 1};
    ushort Reserved1 with BinaryEncoding{Width = 15};
    uint AllocationLength;
    byte Reserved2;
}

pattern SecurityProtocol = enum byte
{
    SecurityProtocolInformation                                = 0x00,
    CbCS                                                       = 0x07,
    TapeDataEncryption                                         = 0x20,
    DataEncryptionConfiguration                                = 0x21,
    SACreationCapabilities                                     = 0x40,
    Ikev2Scsi                                                  = 0x41,
    JEDECUniversalFlashStorage                                 = 0xEC,
    SDcardTrustedFlashSecuritySystemsSpecification             = 0xED,
    AuthenticationInHostAttachmentsOfTransientStorageDevices   = 0xEE,
    ATADeviceServerPassword                                    = 0xEF,
    ...
};

// [SPC-4] 6.41 SECURITY PROTOCOL OUT command - OPERATION CODE (B5h)
type SecurityProtocolOutCommandParameters
{
    SecurityProtocol SecurityProtocol;
    ushort SecurityProtocolSpecific;
    bool INC512 with BinaryEncoding{Width = 1};
    ushort Reserved1 with BinaryEncoding{Width = 15};
    uint TransferLength;
    byte Reserved2;
}

// [SPC-4] 6.42 SEND DIAGNOSTIC command - OPERATION CODE (1Dh)
type SendDiagnosticCommandParameters
{
    byte SelfTestCode with BinaryEncoding{Width = 3};
    bool PF with BinaryEncoding{Width = 1};
    byte Reserved1 with BinaryEncoding{Width = 1};
    bool SelfTest with BinaryEncoding{Width = 1};
    bool DevOffL with BinaryEncoding{Width = 1};
    bool UnitOffL with BinaryEncoding{Width = 1};
    
    byte Reserved2;
    ushort ParametersListLength;
}

// [SPC-4] 6.43 SET IDENTIFYING INFORMATION command - OPERATION CODE (A4h)
type SetIdentifyingInformationCommandParameters
{
    byte Reserved1 with BinaryEncoding{Width = 3};
    (byte where value == 0x06) ServiceAction with BinaryEncoding{Width = 5};
    ushort Reserved2;
    ushort Restricted;
    uint ParameterListLength;
    byte IdentifyingInformationType with BinaryEncoding{Width = 7};
    byte Reserved3 with BinaryEncoding{Width = 1};
}

// [SPC-4] 6.44 SET PRIORITY command - OPERATION CODE (A4h)
type SetPriorityCommandParameters
{
    byte Reserved1 with BinaryEncoding{Width = 3};
    (byte where value == 0x0E) ServiceAction with BinaryEncoding{Width = 5};
    byte ITLNexusToSet with BinaryEncoding{Width = 2};
    uint Reserved2 with BinaryEncoding{Width = 30};
    uint ParameterListLength;
    byte Reserved3;
}

// [SPC-4] 6.45 SET TARGET PORT GROUPS command - OPERATION CODE (A4h)
type SetTargetPortGroupsCommandParameters
{
    byte Reserved1 with BinaryEncoding{Width = 3};
    (byte where value == 0x0A) ServiceAction with BinaryEncoding{Width = 5};
    uint Reserved2;
    uint ParameterListLength;
    byte Reserved3;
}

// [SPC-4] 6.46 SET TIMESTAMP command - OPERATION CODE (A4h)
type SetTimestampCommandParameters
{
    byte Reserved1 with BinaryEncoding{Width = 3};
    (byte where value == 0x0F) ServiceAction with BinaryEncoding{Width = 5};
    uint Reserved2;
    uint ParameterListLength;
    byte Reserved3;
}

// [SPC-4] 6.47 TEST UNIT READY command - OPERATION CODE (00h)
type TestUnitReadyCommandParameters
{
    uint Reserved;
}

// [SPC-4] 6.48 WRITE ATTRIBUTE command - OPERATION CODE (8Dh)
type WriteAttributeCommandParameters
{
    byte Reserved1 with BinaryEncoding{Width = 7};
    bool WTC with BinaryEncoding{Width = 1};
    uint Restricted with BinaryEncoding{Width = 24};
    byte LogicalVolumeNumber;
    byte Reserved2;
    byte PartitionNumber;
    ushort Reserved3;
    uint ParameterListLength;
    byte Reserved4;
}

// [SPC-4] 6.49 WRITE BUFFER command - OPERATION CODE (3Bh)
type WriteBufferCommandParameters
{
    byte ModeSpecific with BinaryEncoding{Width = 3};
    WriteBufferMode Mode with BinaryEncoding{Width = 5};
    
    byte BufferId;
    uint BufferOffset with BinaryEncoding{Width = 24};
    uint AllocationLength with BinaryEncoding{Width = 24};
}

pattern WriteBufferMode = enum byte
{
    $"Combined header and data"                                 = 0x00,
    $"Vendor specific"                                          = 0x01,
    Data                                                        = 0x02,
    $"Download microcode and activate"                          = 0x04,
    $"Download microcode, save, and activate"                   = 0x05,
    $"Download microcode with offsets and activate"             = 0x06,
    $"Download microcode with offsets, save, and activate"      = 0x07,
    $"Write data to echo buffer"                                = 0x0A,
    $"Download microcode with offsets, select activation events, save and defer activate" = 0x0D,
    $"Download microcode with offsets, save and defer activate" = 0x0E,
    $"Activate deferred microcode"                              = 0x0F,
    $"Enable expander communications protocol and Echo buffer"  = 0x1A,
    $"Disable expander communications protocol"                 = 0x1B,
    $"Download application client error history"                = 0x1C,    
};

// Parameter data specified in [SPC-4]
// [SPC-4] 4.5.2 Descriptor format sense data
type DescriptorFormatSenseData
{
    byte Reserved1 with BinaryEncoding{Width = 1};
    (byte where value == 0x72 || value == 0x73) ResponseCode with BinaryEncoding{Width = 7};
    byte Reserved2 with BinaryEncoding{Width = 4};
    byte SenseKey with BinaryEncoding{Width = 4};
    byte AdditionalSenseCode;
    byte AdditionalSenseCodeQualifier;
    bool SDAT_OVFL with BinaryEncoding{Width = 1};
    uint Reserved3 with BinaryEncoding{Width = 23};
    byte AdditionalSenseLength;
    array<SenseDataDescriptor> SenseDataDescriptorList with BinaryEncoding{WidthForComposedType = AdditionalSenseLength * 8};
}

pattern SenseDataDescriptor = InformationSenseDataDescriptor | CommandSpecificInformationSenseDataDescriptor | SenseKeySpecificSenseDataDescriptor |
                              FieldReplaceableUnitSenseDataDescriptor | AnotherProgressIndicationSenseDataDescriptor | ForwardedSenseDataDescriptor |
                              GeneralSenseDataDescriptor;

type GeneralSenseDataDescriptor
{
    byte DescriptorType;
    byte AdditionalLength;
    binary SenseDataDescriptorSpecific with BinaryEncoding{Length = AdditionalLength};
}

type InformationSenseDataDescriptor
{
    (byte where value == 0x00) DescriptorType;
    byte AdditionalLength;
    bool Valid with BinaryEncoding{Width = 1};
    ushort Reserved with BinaryEncoding{Width = 15};
    ulong Information;
}

type CommandSpecificInformationSenseDataDescriptor
{
    (byte where value == 0x01) DescriptorType;
    byte AdditionalLength;
    ushort Reserved;
    array<byte> CommandSpecificInformation with BinaryEncoding{Length = 8};
}

type SenseKeySpecificSenseDataDescriptor
{
    (byte where value == 0x02) DescriptorType;
    byte AdditionalLength;
    ushort Reserved1;
    bool SKSV with BinaryEncoding{Width = 1};
    uint SenseKeySpecificInformation with BinaryEncoding{Width = 23};
    byte Reserved2;
}

type FieldReplaceableUnitSenseDataDescriptor
{
    (byte where value == 0x03) DescriptorType;
    byte AdditionalLength;
    byte Reserved;
    byte FieldReplaceableUnitCode;
}

type AnotherProgressIndicationSenseDataDescriptor
{
    (byte where value == 0x0A) DescriptorType;
    byte AdditionalLength;
    byte AnotherSenseKey;
    byte AnotherAdditionalSenseCode;
    byte AnotherAdditionalSenseCodeQualifier;
    byte Reserved;
    ushort AnotherProgressIndication;
}

type ForwardedSenseDataDescriptor
{
    (byte where value == 0x0C) DescriptorType;
    byte AdditionalLength;
    bool FSDT with BinaryEncoding{Width = 1};
    byte Reserved with BinaryEncoding{Width = 3};
    byte SenseDataSource with BinaryEncoding{Width = 4};
    byte ForwardedStatus;
    array<byte> ForwardedSenseData with BinaryEncoding{Length = (AdditionalLength - 2)};
}

// [SPC-4] 4.5.3
type FixedFormatSenseData
{
    byte Valid with BinaryEncoding{Width = 1};
    (byte where value == 0x70 || value == 0x71) ResponseCode with BinaryEncoding{Width = 7};
    byte Obsolete;
    bool FileMark with BinaryEncoding{Width = 1};
    bool EOM with BinaryEncoding{Width = 1};
    bool ILI with BinaryEncoding{Width = 1};
    bool SDAT_OVFL with BinaryEncoding{Width = 1};
    byte SenseKey with BinaryEncoding{Width = 4};
    uint Information;
    byte AdditionalSenseLength;
    uint CommandSpecificInformation;
    byte AdditionalSenseCode;
    byte AdditionalSenseCodeQualifier;
    byte FieldReplaceableUnitCode;
    bool SKSV with BinaryEncoding{Width = 1};
    uint SenseKeySpecificInformation with BinaryEncoding{Width = 23};
    array<byte> AdditionalSenseBytes with BinaryEncoding{Length = (AdditionalSenseLength - 10)};
}

// [SPC-4] 6.2 CHANGE ALIASES command - Table 120
type ChangeAliasesParameterList
{
    uint ParameterDataLength;
    uint Reserved;
    array<AliasEntry> AliasEntries with BinaryEncoding{WidthForComposedType = (ParameterDataLength * 8) as int};
}

type AliasEntry
{
    ulong AliasEntry;
    ProtocolIdentifier ProtocolIdentifier;
    ushort Reserved1;
    byte FormatCode;
    ushort Reserved2;
    ushort DesignationLength;
    ([|ProtocolIdentifier == 0x00 && FormatCode == 0x00|] FibreChannelWorldWidePortNameAliasEntryDesignation |
     [|ProtocolIdentifier == 0x00 && FormatCode == 0x01|] FibreChannelWorldWidePortNameWithNPortCheckingAliasEntryDesignation |
     [|ProtocolIdentifier == 0x04 && FormatCode == 0x00|] RDMATargetPortIdentifierAliasEntryDesignation | 
     [|ProtocolIdentifier == 0x04 && FormatCode == 0x00|] InfiniBandGlobalIdentifierWithTargetPortIdentifierCheckingAliasEntryDesignation |
     [|ProtocolIdentifier == 0x05 && FormatCode == 0x00|] iSCSINameAliasEntryDesignation[DesignationLength] |
     [|ProtocolIdentifier == 0x05 && FormatCode == 0x01|] iSCSINameWithBinaryIPv4AddressAliasEntryDesignation[DesignationLength] |
     [|ProtocolIdentifier == 0x05 && FormatCode == 0x02|] iSCSINameWithIPNameAliasEntryDesignation |
     [|ProtocolIdentifier == 0x05 && FormatCode == 0x03|] iSCSINameWithBinaryIPv6AddressAliasEntryDesignation[DesignationLength] |
     binary) Designation with BinaryEncoding{Length = DesignationLength, WidthForComposedType = DesignationLength * 8};
}

// [SPC-4] 7.6.2 Alias entry protocol specific designations
type FibreChannelWorldWidePortNameAliasEntryDesignation
{
    binary FibreChannelWorldWidePortName with BinaryEncoding{Length = 8}, DisplayInfo{ToText = DecodeOctetStringAsUTF8};
    // string FibreChannelWorldWidePortName with BinaryEncoding {TextEncoding = TextEncoding.UTF8, Length = 8};
}

type FibreChannelWorldWidePortNameWithNPortCheckingAliasEntryDesignation
{
    binary FibreChannelWorldWidePortName with BinaryEncoding{Length = 8}, DisplayInfo{ToText = DecodeOctetStringAsUTF8};
    // string FibreChannelWorldWidePortName with BinaryEncoding {TextEncoding = TextEncoding.UTF8, Length = 8};
    byte Reserved;
    uint NPort with BinaryEncoding{Width = 24};
}

type RDMATargetPortIdentifierAliasEntryDesignation
{
    array<byte> TargetPortIdentifier with BinaryEncoding{Length = 16};
}

type InfiniBandGlobalIdentifierWithTargetPortIdentifierCheckingAliasEntryDesignation
{
    array<byte> InfiniBandGlobalIdentifier with BinaryEncoding{Length = 16};
    array<byte> TargetPortIdentifier with BinaryEncoding{Length = 16};
}

type iSCSINameAliasEntryDesignation[ushort Len]
{
    string iSCSIName with BinaryEncoding{TextEncoding = TextEncoding.UTF8, WidthForComposedType = Len * 8};
}

type iSCSINameWithBinaryIPv4AddressAliasEntryDesignation[ushort Len]
{
    string iSCSIName with BinaryEncoding{TextEncoding = TextEncoding.UTF8, WidthForComposedType = (Len - 12) * 8};
    IPv4Address IPv4Address;
    ushort Reserved1;
    ushort PortNumber;
    ushort Reserved2;
    ushort InternetProtocolNumber;
}

type iSCSINameWithIPNameAliasEntryDesignation
{
    string iSCSIName with BinaryEncoding{TextEncoding = TextEncoding.UTF8, TextTerminator = "\0"};
    string IPName with BinaryEncoding{TextEncoding = TextEncoding.UTF8, TextTerminator = "\0"};
    array<byte> Pad with BinaryEncoding{Length = (4 - (iSCSIName.Count + IPName.Count) % 4) % 4};
    ushort Reserved1;
    ushort PortNumber;
    ushort Reserved2;
    ushort InternetProtocolNumber;
}

type iSCSINameWithBinaryIPv6AddressAliasEntryDesignation[ushort Len]
{
    binary iSCSIName with BinaryEncoding{Length = (Len - 24)}, DisplayInfo{ToText = DecodeOctetStringAsUTF8};
    // string iSCSIName with BinaryEncoding{TextEncoding = TextEncoding.UTF8, Length = (Len - 24)};
    IPv6Address IPv6Address;
    ushort Reserved1;
    ushort PortNumber;
    ushort Reserved2;
    ushort InternetProtocolNumber;
}

// [SPC-4] 6.4.2 EXTENDED COPY(LID4) parameter list
type ExtendedCopyLID4ParameterList
{
    (byte where value == 0x01) ParameterListFormat;
    byte Reserved1 with BinaryEncoding{Width = 2};
    bool STR with BinaryEncoding{Width = 1};
    byte ListIdUsage with BinaryEncoding{Width = 2};
    byte Priority with BinaryEncoding{Width = 3};
    
    ushort HeaderCscdDescriptorListLength;
    binary Reserved2 with BinaryEncoding{Length = 11};
    byte Reserved3 with BinaryEncoding{Width = 6};
    bool GSense with BinaryEncoding{Width = 1};
    bool IMMED with BinaryEncoding{Width = 1};
    (byte where value == 0xFF) HeaderCscdDescriptorTypeCode;
    
    uint Reserved4 with BinaryEncoding{Width = 24};
    ushort CscdDescriptorListLength;
    ushort SegmentDescriptorListLength;
    ushort InlineDataLength;
    
    array<IpCopyServiceCscdDescriptor | CscdDescriptor> CscdDescriptorList with BinaryEncoding{WidthForComposedType = (CscdDescriptorListLength * 8) as int};
    array<SegmentDescriptor> SegmentDescriptorList with BinaryEncoding{WidthForComposedType = (SegmentDescriptorListLength * 8) as int};
    binary InlineData with BinaryEncoding{Length = InlineDataLength};
}

// [SPC-4] 6.4.5 CSCD descriptors
type CscdDescriptor
{
    byte DescriptorTypeCode;
    byte LuIdType with BinaryEncoding{Width = 2};
    byte Obsolete with BinaryEncoding{Width = 1};
    byte PeripheralDeviceType with BinaryEncoding{Width = 5};
    ushort RelativeInitiatorPortIdentifier;
    ([|DescriptorTypeCode == 0xE4|] IdentificationDescriptorCscdDescriptorParameter |
    [|DescriptorTypeCode == 0xE6|] AliasCscdDescriptorParameter |
    [|DescriptorTypeCode == 0xFE|] RodCscdDescriptorParameter |
    [|DescriptorTypeCode == 0xE0|] FibreChannelNPortNameCscdDescriptorParameter |
    [|DescriptorTypeCode == 0xE1|] FibreChannelNPortIdCscdDescriptorParameter |
    [|DescriptorTypeCode == 0xE2|] FibreChannelNPortIdWithNPortNameCheckingCscdDescriptorParameter |
    [|DescriptorTypeCode == 0xE3|] SCSIParallelTLCscdDescriptorParameter |
    [|DescriptorTypeCode == 0xE8|] IEEE1394EUI64CscdDescriptorParameter |
    [|DescriptorTypeCode == 0xE7|] RDMACscdDescriptorParameter |
    [|DescriptorTypeCode == 0xE5|] iSCSIIPv4CscdDescriptorParameter |
    [|DescriptorTypeCode == 0xEA|] iSCSIIPv6CscdDescriptorParameter |
    [|DescriptorTypeCode == 0xE9|] SASSerialSCSIProtocolCscdDescriptorParameter |
     binary) CscdDescriptorParameters with BinaryEncoding{Length = 24};
    ([|PeripheralDeviceType == 0x00 || PeripheralDeviceType == 0x04 || PeripheralDeviceType == 0x05 || PeripheralDeviceType == 0x07 || PeripheralDeviceType == 0x0E|] BlockDeviceTypeCscdDescriptorParameters |
     [|PeripheralDeviceType == 0x01|] SequentialAccessDeviceTypeCscdDescriptorParameters |
     [|PeripheralDeviceType == 0x03|] ProcessorDeviceTypeCscdDescriptorParameters | 
     uint) DeviceTypeSpecificParameters;
    optional array<CscdDescriptorExtension[DescriptorTypeCode]> CscdDescriptorExtensions;
}

type IdentificationDescriptorCscdDescriptorParameter
{
    byte Reserved1 with BinaryEncoding{Width = 4};
    CodeSetType CodeSet with BinaryEncoding{Width = 4};
    byte Reserved2 with BinaryEncoding{Width = 2};
    byte Association with BinaryEncoding{Width = 2};
    DesignatorType DesignatorType with BinaryEncoding{Width = 4};
    byte Reserved3;
    byte DesignatorLength;
    ([|DesignatorType == 0x01|] T10VendorIdBasedDesignator | 
     [|DesignatorType == 0x02 && DesignatorType == 0x08|] EUI64Designator |
     [|DesignatorType == 0x02 && DesignatorType == 0x0C|] EUI64Based12ByteDesignator |
     [|DesignatorType == 0x02 && DesignatorType == 0x10|] EUI64Based16ByteDesignator |
     [|DesignatorType == 0x03|] NAADesignator |
     [|DesignatorType == 0x04 && Association == 0x01|] RelativeTargetPortDesignator |
     [|DesignatorType == 0x05 && Association == 0x01|] TargetPortGroupDesignator |
     [|DesignatorType == 0x06 && Association == 0x00|] LogicalUintGroupDesignator |
     [|DesignatorType == 0x07 && Association == 0x00|] MD5LogicalUnitDesignator |
     [|DesignatorType == 0x08|] SCSINameStringDesignator[DesignatorLength] |
     binary) Designator with BinaryEncoding{Length = DesignatorLength, WidthForComposedType = DesignatorLength * 8};
}

type AliasCscdDescriptorParameter
{
    ulong LuIdentifier;
    ulong AliasValue;
    ulong Reserved;
}

type IpCopyServiceCscdDescriptor
{
    (byte where value == 0xEB) DescriptorTypeCode;
    byte LuIdType with BinaryEncoding{Width = 2};
    byte Obsolete with BinaryEncoding{Width = 1};
    byte PeripheralDeviceType with BinaryEncoding{Width = 5};
    byte Reserved1 with BinaryEncoding{Width = 7};
    bool IpType with BinaryEncoding{Width = 1};
    binary Reserved2 with BinaryEncoding{Length = 9};
    binary CopyServiceIpAddress with BinaryEncoding{Length = 16};
    ([|PeripheralDeviceType == 0x00 || PeripheralDeviceType == 0x04 || PeripheralDeviceType == 0x05 || PeripheralDeviceType == 0x07 || PeripheralDeviceType == 0x0E|] BlockDeviceTypeCscdDescriptorParameters |
     [|PeripheralDeviceType == 0x01|] SequentialAccessDeviceTypeCscdDescriptorParameters |
     [|PeripheralDeviceType == 0x03|] ProcessorDeviceTypeCscdDescriptorParameters | uint) DeviceTypeSpecificParameters;
     
    (byte where value == 0xFF) ExtensionDescriptorTypeCode;
    uint Reserved3 with BinaryEncoding{Width = 24};
    ushort CopyServicePortNumber;
    ushort CopyServiceInternetProtocolNumber;
    byte Reserved4 with BinaryEncoding{Width = 4};
    CodeSetType CodeSet with BinaryEncoding{Width = 4};
    byte Reserved5 with BinaryEncoding{Width = 2};
    byte Association with BinaryEncoding{Width = 2};
    DesignatorType DesignatorType with BinaryEncoding{Width = 4};
    byte Reserved6;
    byte DesignatorLength;
    ([|DesignatorType == 0x01|] T10VendorIdBasedDesignator | 
     [|DesignatorType == 0x02 && DesignatorType == 0x08|] EUI64Designator |
     [|DesignatorType == 0x02 && DesignatorType == 0x0C|] EUI64Based12ByteDesignator |
     [|DesignatorType == 0x02 && DesignatorType == 0x10|] EUI64Based16ByteDesignator |
     [|DesignatorType == 0x03|] NAADesignator |
     [|DesignatorType == 0x04 && Association == 0x01|] RelativeTargetPortDesignator |
     [|DesignatorType == 0x05 && Association == 0x01|] TargetPortGroupDesignator |
     [|DesignatorType == 0x06 && Association == 0x00|] LogicalUintGroupDesignator |
     [|DesignatorType == 0x07 && Association == 0x00|] MD5LogicalUnitDesignator |
     [|DesignatorType == 0x08|] SCSINameStringDesignator[DesignatorLength] |
     binary) Designator with BinaryEncoding{Length = DesignatorLength, WidthForComposedType = DesignatorLength * 8};
}

type RodCscdDescriptorParameter
{
    ushort RodProducerCscdDescriptorId;
    ushort Reserved1;
    uint RodType;
    uint RequestedRodTokenLifeTime;
    uint RequestedRodTokenInactivityTimeout;
    uint Reserved2 with BinaryEncoding{Length = 23};
    bool RToken with BinaryEncoding{Width = 1};
    byte Reserved3 with BinaryEncoding{Width = 7};
    bool DelTkn with BinaryEncoding{Width = 1};
    uint RodTokenOffset;
}

type BlockDeviceTypeCscdDescriptorParameters
{
    byte Reserved1 with BinaryEncoding{Width = 5};
    bool PAD with BinaryEncoding{Width = 1};
    byte Reserved2 with BinaryEncoding{Width = 2};
    uint DiskBlockLength with BinaryEncoding{Width = 24};
}

type SequentialAccessDeviceTypeCscdDescriptorParameters
{
    byte Reserved1 with BinaryEncoding{Width = 5};
    bool PAD with BinaryEncoding{Width = 1};
    byte Reserved2 with BinaryEncoding{Width = 1};
    bool Fixed with BinaryEncoding{Width = 1};
    uint StreamBlockLength with BinaryEncoding{Width = 24};
}

type ProcessorDeviceTypeCscdDescriptorParameters
{
    byte Reserved1 with BinaryEncoding{Width = 5};
    bool PAD with BinaryEncoding{Width = 1};
    uint Reserved2 with BinaryEncoding{Width = 26};
}

type CscdDescriptorExtension[byte DescriptorTypeCode]
{
    (byte where value == 0xFF) ExtensionDescriptorTypeCode;
    ([|DescriptorTypeCode == 0xEA|] iSCSIIPv6CscdDescriptorExtension | 
     array<byte>) CscdDescriptorSpecificInformation with BinaryEncoding{Length = 31};
}

// [SPC-4] 6.5 EXTENDED COPY(LID1) command
type ExtendedCopyLID1ParameterList
{
    byte ListIdentifier;
    byte Reserved1 with BinaryEncoding{Width = 2};
    bool STR with BinaryEncoding{Width = 1};
    byte ListIdUsage with BinaryEncoding{Width = 2};
    byte Priority with BinaryEncoding{Width = 3};
    ushort CscdDescriptorListLength;
    uint Reserved2;
    uint SegmentDescriptorListLength;
    uint InlineDataLength;
    array<IpCopyServiceCscdDescriptor | CscdDescriptor> CscdDescriptorList with BinaryEncoding{WidthForComposedType = (CscdDescriptorListLength * 8) as int};
    array<SegmentDescriptor> SegmentDescriptorList with BinaryEncoding{WidthForComposedType = (SegmentDescriptorListLength * 8) as int};
    binary InlineData with BinaryEncoding{Length = InlineDataLength};
}

// [SPC-4] 7.6.3 EXTENDED COPY protocol specific CSCD descriptors
type FibreChannelNPortNameCscdDescriptorParameter
{
    ulong LuIdentifier;
    binary NPortName with BinaryEncoding{Length = 8}, DisplayInfo{ToText = DecodeOctetStringAsUTF8};
    // string NPortName with BinaryEncoding {TextEncoding = TextEncoding.UTF8, Length = 8};
    ulong Reserved;
}

type FibreChannelNPortIdCscdDescriptorParameter
{
    ulong LuIdentifier;
    array<byte> Reserved1 with BinaryEncoding{Length = 9};
    uint NPortId with BinaryEncoding{Width = 24};
    uint Reserved2;
}

type FibreChannelNPortIdWithNPortNameCheckingCscdDescriptorParameter
{
    ulong LuIdentifier;
    binary NPortName with BinaryEncoding{Length = 8}, DisplayInfo{ToText = DecodeOctetStringAsUTF8};
    // string NPortName with BinaryEncoding{TextEncoding = TextEncoding.UTF8, Length = 8};
    byte Reserved1;
    uint NPortId with BinaryEncoding{Width = 24};
    uint Reserved2;
}

type SCSIParallelTLCscdDescriptorParameter
{
    ulong LuIdentifier;
    byte VendorSpecific;
    byte TargetIdentifier;
    array<byte> Reserved with BinaryEncoding{Length = 14};
}

type IEEE1394EUI64CscdDescriptorParameter
{
    ulong LuIdentifier;
    string EUI64 with BinaryEncoding{TextEncoding = TextEncoding.ASCII, Length = 8};
    uint DirectoryId with BinaryEncoding{Width = 24};
    array<byte> Reserved with BinaryEncoding{Length = 5};
}

type RDMACscdDescriptorParameter
{
    ulong LuIdentifier;
    array<byte> TargetPortIdentifier with BinaryEncoding{Length = 16};
}

type iSCSIIPv4CscdDescriptorParameter
{
    ulong LuIdentifier;
    IPv4Address IPv4Address;
    array<byte> Reserved1 with BinaryEncoding{Length = 6};
    ushort PortNumber;
    ushort Reserved2;
    ushort InternetProtocolNumber;
}

type iSCSIIPv6CscdDescriptorParameter
{
    ulong LuIdentifier;
    IPv6Address IPv6Address;
}

type iSCSIIPv6CscdDescriptorExtension
{
    array<byte> Reserved1 with BinaryEncoding{Length = 3};
    ushort PortNumber;
    ushort InternetProtocolNumber;
    array<byte> Reserved2 with BinaryEncoding{Length = 24};
}

type SASSerialSCSIProtocolCscdDescriptorParameter
{
    ulong LuIdentifier;
    ulong SASAddress;
    ulong Reserved;
}

// [SPC-4] 6.4.6 Segment descriptors
pattern SegmentDescriptor = BlockDeviceToStreamDeviceSegmentDescriptor
                          | StreamDeviceToBlockDeviceSegmentDescriptor
                          | BlockDeviceToBlockDeviceSegmentDescriptor
                          | StreamDeviceToStreamDeviceSegmentDescriptor
                          | InlineDataToStreamDeviceSegmentDescriptor
                          | EmbeddedDataToStreamDeviceSegmentDescriptor
                          | StreamDeviceToDiscardSegmentDescriptor
                          | VerifyCscdSegmentDescriptor
                          | BlockDeviceWithOffsetToStreamDeviceSegmentDescriptor
                          | StreamDeviceWithOffsetToBlockDeviceSegmentDescriptor
                          | BlockDeviceWithOffsetToBlockDeviceWithOffsetSegmentDescriptor
                          | WriteFilemarksSegmentDescriptor
                          | SpaceSegmentDescriptor
                          | LocateSegmentDescriptor
                          | TapeDeviceImageCopySegmentDescriptor
                          | RegisterPersistentReservationKeySegmentDescriptor
                          | ThirdPartyPersistentReservationsSourceITNexusSegmentDescriptor
                          | BlockDeviceImageCopySegmentDescriptor
                          | PopulateRodFromOneOrMoreBlockRangesSegmentDescriptor
                          | FourGibiBlockRangeDescriptor
                          | PopulateRodFromOneBlockRangeSegmentDescriptor
                          | GeneralSegmentDescriptor;

type GeneralSegmentDescriptor
{
    byte DescriptorTypeCode;
    byte Reserved1 with BinaryEncoding{Width = 6};
    bool DC with BinaryEncoding{Width = 1};
    bool CAT with BinaryEncoding{Width = 1};
    ushort DescriptorLength;
    ushort SourceCscdDescriptorId;
    ushort DestinationCscdDescriptorId;
    binary SegmentDescriptorParameters;
}

type BlockDeviceToStreamDeviceSegmentDescriptor
{
    (byte where value == 0x00 || value == 0x0B) DescriptorTypeCode;
    byte Reserved1 with BinaryEncoding{Width = 7};
    bool CAT with BinaryEncoding{Width = 1};
    ushort DescriptorLength;
    ushort SourceCscdDescriptorId;
    ushort DestinationCscdDescriptorId;
    byte Reserved2;
    uint StreamDeviceTransferLength with BinaryEncoding{Width = 24};
    ushort Reserved3;
    ushort BlockDeviceNumberOfBlocks;
    ulong BlockDeviceLogicalBlockAddress;
}

type StreamDeviceToBlockDeviceSegmentDescriptor
{
    (byte where value == 0x01 || value == 0x0C) DescriptorTypeCode;
    byte Reserved1 with BinaryEncoding{Width = 7};
    bool CAT with BinaryEncoding{Width = 1};
    ushort DescriptorLength;
    ushort SourceCscdDescriptorId;
    ushort DestinationCscdDescriptorId;
    byte Reserved2;
    uint StreamDeviceTransferLength with BinaryEncoding{Width = 24};
    ushort Reserved3;
    ushort BlockDeviceNumberOfBlocks;
    ulong BlockDeviceLogicalBlockAddress;
}

type BlockDeviceToBlockDeviceSegmentDescriptor
{
    (byte where value == 0x02 || value == 0x0D) DescriptorTypeCode;
    byte Reserved1 with BinaryEncoding{Width = 6};
    bool DC with BinaryEncoding{Width = 1};
    bool CAT with BinaryEncoding{Width = 1};
    ushort DescriptorLength;
    ushort SourceCscdDescriptorId;
    ushort DestinationCscdDescriptorId;
    ushort Reserved2;
    ushort BlockDeviceNumberOfBlocks;
    ulong SourceBlockDeviceLogicalBlockAddress;
    ulong DestinationBlockDeviceLogicalBlockAddress;
}

type StreamDeviceToStreamDeviceSegmentDescriptor
{
    (byte where value == 0x03 || value == 0x0E) DescriptorTypeCode;
    byte Reserved1 with BinaryEncoding{Width = 7};
    bool CAT with BinaryEncoding{Width = 1};
    ushort DescriptorLength;
    ushort SourceCscdDescriptorId;
    ushort DestinationCscdDescriptorId;
    byte Reserved2;
    uint DestinationStreamDeviceTransferLength with BinaryEncoding{Width = 24};
    uint ByteCount;
}

type InlineDataToStreamDeviceSegmentDescriptor
{
    (byte where value == 0x04) DescriptorTypeCode;
    byte Reserved1 with BinaryEncoding{Width = 7};
    bool CAT with BinaryEncoding{Width = 1};
    ushort DescriptorLength;
    ushort Reserved2;
    ushort DestinationCscdDescriptorId;
    byte Reserved3;
    uint StreamDeviceTransferLength with BinaryEncoding{Width = 24};
    uint InlineDataOffset;
    uint InlineDataNumberOfBytes;
}

type EmbeddedDataToStreamDeviceSegmentDescriptor
{
    (byte where value == 0x05) DescriptorTypeCode;
    byte Reserved1 with BinaryEncoding{Width = 7};
    bool CAT with BinaryEncoding{Width = 1};
    ushort DescriptorLength;
    ushort Reserved2;
    ushort DestinationCscdDescriptorId;
    byte Reserved3;
    uint StreamDeviceTransferLength with BinaryEncoding{Width = 24};
    ushort EmbeddedDataNumberOfBytes;
    ushort Reserved4;
    binary EmbeddedData with BinaryEncoding{Length = EmbeddedDataNumberOfBytes};
}

type StreamDeviceToDiscardSegmentDescriptor
{
    (byte where value == 0x06 || value == 0x0F) DescriptorTypeCode;
    byte Reserved1 with BinaryEncoding{Width = 7};
    bool CAT with BinaryEncoding{Width = 1};
    ushort DescriptorLength;
    ushort SourceCscdDescriptorId;
    uint Reserved2 with BinaryEncoding{Width = 24};
    uint StreamDeviceTransferLength with BinaryEncoding{Width = 24};
    uint NumberOfBytes;
}

type VerifyCscdSegmentDescriptor
{
    (byte where value == 0x07) DescriptorTypeCode;
    byte Reserved1;
    ushort DescriptorLength;
    ushort SourceCscdDescriptorId;
    binary Reserved2 with BinaryEncoding{Length = 6};
}

type BlockDeviceWithOffsetToStreamDeviceSegmentDescriptor
{
    (byte where value == 0x08) DescriptorTypeCode;
    byte Reserved1 with BinaryEncoding{Width = 7};
    bool CAT with BinaryEncoding{Width = 1};
    ushort DescriptorLength;
    ushort SourceCscdDescriptorId;
    ushort DestinationCscdDescriptorId;
    byte Reserved2;
    uint StreamDeviceTransferLength with BinaryEncoding{Width = 24};
    uint NumberOfBytes;
    ulong BlockDeviceLogicalBlockAddress;
    ushort Reserved3;
    ushort BlockDeviceByteOffset;
}

type StreamDeviceWithOffsetToBlockDeviceSegmentDescriptor
{
    (byte where value == 0x09) DescriptorTypeCode;
    byte Reserved1 with BinaryEncoding{Width = 7};
    bool CAT with BinaryEncoding{Width = 1};
    ushort DescriptorLength;
    ushort SourceCscdDescriptorId;
    ushort DestinationCscdDescriptorId;
    byte Reserved2;
    uint StreamDeviceTransferLength with BinaryEncoding{Width = 24};
    uint NumberOfBytes;
    ulong BlockDeviceLogicalBlockAddress;
    ushort Reserved3;
    ushort BlockDeviceByteOffset;
}

type BlockDeviceWithOffsetToBlockDeviceWithOffsetSegmentDescriptor
{
    (byte where value == 0x0A) DescriptorTypeCode;
    byte Reserved1 with BinaryEncoding{Width = 7};
    bool CAT with BinaryEncoding{Width = 1};
    ushort DescriptorLength;
    ushort SourceCscdDescriptorId;
    ushort DestinationCscdDescriptorId;
    uint NumberOfBytes;
    ulong SourceBlockDeviceLogicalBlockAddress;
    ulong DestinationBlockDeviceLogicalBlockAddress;
    ushort SourceBlockDeviceByteOffset;
    ushort DestinationBlockDeviceByteOffset;
}

type WriteFilemarksSegmentDescriptor
{
    (byte where value == 0x10) DescriptorTypeCode;
    byte Reserved1;
    ushort DescriptorLength;
    ushort Reserved2;
    ushort DestinationCscdDescriptorId;
    byte Reserved3;
    uint FileMarkCount with BinaryEncoding{Width = 24};
}

type SpaceSegmentDescriptor
{
    (byte where value == 0x11) DescriptorTypeCode;
    byte Reserved1;
    ushort DescriptorLength;
    ushort Reserved2;
    ushort DestinationCscdDescriptorId;
    byte Reserved3 with BinaryEncoding{Width = 5};
    byte Code with BinaryEncoding{Width = 3};
    uint Count with BinaryEncoding{Width = 24};
}

type LocateSegmentDescriptor
{
    (byte where value == 0x12) DescriptorTypeCode;
    byte Reserved1;
    ushort DescriptorLength;
    ushort Reserved2;
    ushort DestinationCscdDescriptorId;
    uint LogicalObjectIdentifier;
}

type TapeDeviceImageCopySegmentDescriptor
{
    (byte where value == 0x13) DescriptorTypeCode;
    byte Reserved1;
    ushort DescriptorLength;
    ushort SourceCscdDescriptorId;
    ushort DestinationCscdDescriptorId;
    uint Count;
}

type RegisterPersistentReservationKeySegmentDescriptor
{
    (byte where value == 0x14) DescriptorTypeCode;
    byte Reserved1;
    ushort DescriptorLength;
    ushort Reserved2;
    ushort DestinationCscdDescriptorId;
    ulong ReservationKey;
    ulong ServiceActionReservationKey;
    uint Reserved3;
}

type ThirdPartyPersistentReservationsSourceITNexusSegmentDescriptor
{
    (byte where value == 0x15) DescriptorTypeCode;
    byte Reserved1;
    ushort DescriptorLength;
    ushort Reserved2;
    ushort DestinationCscdDescriptorId;
    ulong ReservationKey;
    ulong ServiceActionReservationKey;
    ushort Reserved3;
    ushort RelativeTargetPortIdentifier;
    uint TransportIdLength;
    binary TransportId with BinaryEncoding{Length = TransportIdLength};
}

type BlockDeviceImageCopySegmentDescriptor
{
    (byte where value == 0x16) DescriptorTypeCode;
    byte Reserved1;
    ushort DescriptorLength;
    ushort SourceCscdDescriptorId;
    ushort DestinationCscdDescriptorId;
    ulong StartingSourceLogicalBlockAddress;
    ulong StartingDestinationLogicalBlockAddress;
    uint NumberOfLogicalBlocks;
}

type PopulateRodFromOneOrMoreBlockRangesSegmentDescriptor
{
    (byte where value == 0xBE) DescriptorTypeCode;
    byte Reserved1;
    ushort DescriptorLength;
    ushort SourceCscdDescriptorId;
    ushort DestinationCscdDescriptorId;
    binary Reserved2 with BinaryEncoding{Length = 5};
    byte RangeDescriptorType;
    ushort RangeDescriptorsLength;
    ([|RangeDescriptorType == 0x01|] array<FourGibiBlockRangeDescriptor> | binary) RangeDescriptors 
        with BinaryEncoding{WidthForComposedType = RangeDescriptorsLength * 8, Length = RangeDescriptorsLength};
}

type FourGibiBlockRangeDescriptor
{
    ulong LogicalBlockAddress;
    uint NumberOfLogicalBlocks;
    uint Reserved;
}

type PopulateRodFromOneBlockRangeSegmentDescriptor
{
    (byte where value == 0xBF) DescriptorTypeCode;
    byte Reserved1;
    ushort DescriptorLength;
    ushort SourceCscdDescriptorId;
    ushort DestinationCscdDescriptorId;
    ulong LogicalBlockAddress;
    uint NumberOfLogicalBlocks;
}

// [SPC-4] 6.6.2 Standard INQUIRY data
type StandardInquiryData
{
    byte PeripheralQualifier with BinaryEncoding{Width = 3};
    byte PeripheralDeviceType with BinaryEncoding{Width = 5};
    bool RMB with BinaryEncoding{Width = 1};
    byte Reserved1 with BinaryEncoding{Width = 7};
    byte Version;
    byte Reserved2 with BinaryEncoding{Width = 2};
    bool NormACA with BinaryEncoding{Width = 1};
    byte HiSup with BinaryEncoding{Width = 1};
    byte ResponseDataFormat with BinaryEncoding{Width = 4};
    byte AdditionalLength;
    
    bool SCCS with BinaryEncoding{Width = 1};
    bool ACC with BinaryEncoding{Width = 1};
    byte TPGS with BinaryEncoding{Width = 2};
    bool ThreePC with BinaryEncoding{Width = 1};
    byte Reserved3 with BinaryEncoding{Width = 2};
    bool Protect with BinaryEncoding{Width = 1};
    byte Obsolete1 with BinaryEncoding{Width = 1};
    bool EncServ with BinaryEncoding{Width = 1};
    bool VS1 with BinaryEncoding{Width = 1};
    bool MultiP with BinaryEncoding{Width = 1};
    byte Obsolete2 with BinaryEncoding{Width = 1};
    byte Reserved4 with BinaryEncoding{Width = 2};
    bool Addr16 with BinaryEncoding{Width = 1};
    byte Obsolete3 with BinaryEncoding{Width = 1};
    byte Reserved5 with BinaryEncoding{Width = 1};
    bool Wbus16 with BinaryEncoding{Width = 1};
    bool Sync with BinaryEncoding{Width = 1};
    byte Obsolete4 with BinaryEncoding{Width = 1};
    byte Reserved6 with BinaryEncoding{Width = 1};
    bool CmdQue with BinaryEncoding{Width = 1};
    bool VS2 with BinaryEncoding{Width = 1};
    
    string T10VendorIdentification with BinaryEncoding{TextEncoding = TextEncoding.ASCII, Length = 8};
    string ProductIdentification with BinaryEncoding{TextEncoding = TextEncoding.ASCII, Length = 16};
    string ProductRevisionLevel with BinaryEncoding{TextEncoding = TextEncoding.ASCII, Length = 4};
    array<byte> VendorSpecific1 with BinaryEncoding{Length = 20};
    
    byte Reserved7 with BinaryEncoding{Width = 4};
    byte Clocking with BinaryEncoding{Width = 2};
    bool QAS with BinaryEncoding{Width = 1};
    bool IUS with BinaryEncoding{Width = 1};
    
    byte Reserved8;
    array<ushort> VersionDescriptors with BinaryEncoding{Length = 8};
    binary Reserved9 with BinaryEncoding{Length = 22};
    binary VendorSpecific2;
}

// [SPC-4] 6.9.2.3 Supported management protocols list description
type SupportedManagementProtocolsManagementProtocolInParameterData
{
    binary Reserved1 with BinaryEncoding{Length = 6};
    ushort SupportedManagementProtocolListLength;
    array<byte> SupportedManagementProtocolList with BinaryEncoding{Length = SupportedManagementProtocolListLength};
}

// [SPC-4] 6.15.2 READ KEYS service action
type ReadKeysPersistentReserveInParameterData
{
    uint PRGeneration;
    uint AdditionalLength;
    array<ulong> ReservationKeyList with BinaryEncoding{Length = AdditionalLength / 8};
}

// [SPC-4] 6.15.3 READ RESERVATION service action
type ReadReservationPersistentReserveInParameterData
{
    uint PRGeneration;
    (uint where value == 0 || value == 0x10) AdditionalLength;
    optional [|AdditionalLength == 0x10|] ulong ReservationKey;
    optional [|AdditionalLength == 0x10|] uint Obsolete1;
    optional [|AdditionalLength == 0x10|] byte Reserved;
    optional [|AdditionalLength == 0x10|] byte Scope with BinaryEncoding{Width = 4};
    optional [|AdditionalLength == 0x10|] byte Type with BinaryEncoding{Width = 4};
    optional [|AdditionalLength == 0x10|] ushort Obsolete2;
}

// [SPC-4] 6.15.4 REPORT CAPABILITIES service action
type ReportCapabilitiesPersistentReserveInParameterData
{
    ushort Length;
    bool RLR_C with BinaryEncoding{Width = 1};
    byte Reserved1 with BinaryEncoding{Width = 2};
    bool CRH with BinaryEncoding{Width = 1};
    bool SIP_C with BinaryEncoding{Width = 1};
    bool ATP_C with BinaryEncoding{Width = 1};
    byte Reserved2 with BinaryEncoding{Width = 1};
    bool PTPL_C with BinaryEncoding{Width = 1};
    
    bool TMV with BinaryEncoding{Width = 1};
    byte AllowCommands with BinaryEncoding{Width = 3};
    byte Reserved3 with BinaryEncoding{Width = 3};
    bool PTPL_A with BinaryEncoding{Width = 1};
    
    PersistentReservationTypeMask PersistentReservationTypeMask;
    ushort Reserved4;
}

pattern PersistentReservationTypeMask = flags ushort
{
    WR_EX_AR = 0x8000,
    EX_AC_RO = 0x4000,
    WR_EX_RO = 0x2000,
    EX_AC    = 0x0800,
    WR_EX    = 0x0200,
    EX_AC_AR = 0x0001,
    ...
};

// [SPC-4] 6.15.5 READ FULL STATUS service action
type ReadFullStatusPersistentReserveInParameterData
{
    uint PRGeneration;
    uint AdditionalLength;
    array<FullStatusDescriptor> FullStatusDescriptors with BinaryEncoding{WidthForComposedType = (AdditionalLength * 8) as int};
}

type FullStatusDescriptor
{
    ulong ReservationKey;
    uint Reserved1;
    byte Reserved2 with BinaryEncoding{Width = 6};
    bool ALL_TG_PT with BinaryEncoding{Width = 1};
    bool R_HOLDER with BinaryEncoding{Width = 1};
    byte Scope with BinaryEncoding{Width = 4};
    byte Type with BinaryEncoding{Width = 4};
    uint Reserved;
    ushort RelativeTargetPortIdentifier;
    uint AdditionalDescriptorLength;
    binary TransportId with BinaryEncoding{Length = AdditionalDescriptorLength};
}

// [SPC-4] 6.16.3 Basic PERSISTENT RESERVE OUT parameter list
type PersistentReserveOutParameterList
{
    ulong ReservationKey;
    ulong ServiceActionReservationKey;
    uint Obsolete1;
    byte Reserved1 with BinaryEncoding{Width = 4};
    bool SPEC_I_PT with BinaryEncoding{Width = 1};
    bool ALL_TG_PT with BinaryEncoding{Width = 1};
    byte Reserved2 with BinaryEncoding{Width = 1};
    bool APTPL with BinaryEncoding{Width = 1};
    byte Reserved3;
    ushort Obsolete2;
    (PersistentReserveOutSpecifyInitiatorPortsAdditionParameterData | binary) AdditionalParameterData;
}

type PersistentReserveOutSpecifyInitiatorPortsAdditionParameterData
{
    uint TransportIdParameterDataLength;
    array<TransportId> TransportIdsList with BinaryEncoding{WidthForComposedType = (TransportIdParameterDataLength * 8) as int};
}

// [SPC-4] 6.16.4 Parameter list for the PERSISTENT RESERVE OUT command with REGISTER AND MOVE service action
type RegisterAndMoveServiceActionParameterList
{
    ulong ReservationKey;
    ulong ServiceActionReservationKey;
    ushort Reserved1 with BinaryEncoding{Width = 14};
    bool UNREG with BinaryEncoding{Width = 1};
    bool APTPL with BinaryEncoding{Width = 1};
    ushort RelativeTargetPortIdentifier;
    uint TransportIdLength;
    TransportId TransportId with BinaryEncoding{Length = TransportIdLength};
}

// [SPC-4] 6.17.2 ATTRIBUTE VALUES service action
type AttributeValuesServiceActionParameterList
{
    uint AvailableData;
    array<MAMAttribute> Attributes with BinaryEncoding{WidthForComposedType = (AvailableData * 8) as int};
}

// [SPC-4] 6.17.3 ATTRIBUTE LIST service action
type AttributeListServiceActionParameterList
{
    uint AvailableData;
    array<ushort> AttributeIdentifiers with BinaryEncoding{Length = (AvailableData / 2)};
}

// [SPC-4] 6.17.4 LOGICAL VOLUME LIST service action
type LogicalVolumeListServiceActionParameterList
{
    ushort AvailableData;
    byte FirstLogicalVolumeNumber;
    byte NumberOfLogicalVolumesAvailable;
}

// [SPC-4] 6.17.5 PARTITION LIST service action
type PartitionListServiceActionParameterList
{
    ushort AvailableData;
    byte FirstPartitionNumber;
    byte NumberOfPartitionsAvailable;
}

// [SPC-4] 6.17.6 SUPPORTED ATTRIBUTES service action
type SupportedAttributesServiceActionParameterList
{
    uint AvailableData;
    array<ushort> AttributeIdentifiers with BinaryEncoding{Length = (AvailableData / 2)};
}

// [SPC-4] 6.18.2 Combined header and data mode (00h)
type ReadBufferHeader
{
    byte Reserved;
    uint BufferCapacity with BinaryEncoding{Width = 24};
    binary Data;
}

// [SPC-4] 6.18.5 Descriptor mode (03h)
type ReadBufferDescriptor
{
    byte OffsetBoundary;
    uint BufferCapacity with BinaryEncoding{Width = 24};
}

// [SPC-4] 6.18.7 Echo buffer descriptor mode (0Bh)
type EchoBufferDescriptor
{
    byte Reserved1 with BinaryEncoding{Width = 7};
    bool EBOS with BinaryEncoding{Width = 1};
    ushort Reserved with BinaryEncoding{Width = 11};
    ushort BufferCapacity with BinaryEncoding{Width = 13};
}

// [SPC-4] 6.18.9 Error history mode (1Ch)
type ErrorHistoryDirectory
{
    string T10VendorIdentification with BinaryEncoding{TextEncoding = TextEncoding.ASCII, Length = 8};
    byte Version;
    byte Reserved1 with BinaryEncoding{Width = 3};
    byte EHS_RETRIEVED with BinaryEncoding{Width = 2};
    byte EHS_SOURCE with BinaryEncoding{Width = 2};
    bool SLR_SUP with BinaryEncoding{Width = 1};
    array<byte> Reserved2 with BinaryEncoding{Length = 20};
    ushort DirectoryLength;
    array<ErrorHistoryDirectoryEntry> ErrorHistoryDirectoryList with BinaryEncoding{WidthForComposedType = DirectoryLength * 8};
}

type ErrorHistoryDirectoryEntry
{
    byte SupportedBufferId;
    array<byte> Reserved with BinaryEncoding{Length = 3};
    uint MaximumAvailableLength;
}

// [SPC-4] 6.19 READ MEDIA SERIAL NUMBER command - parameter data
type ReadMediaSerialNumberParameterData
{
    uint MediaSerialNumberLength;
    binary MediaSerialNumber with BinaryEncoding{Length = MediaSerialNumberLength};
}

// [SPC-4] 6.29 REMOVE I_T NEXUS command
type RemoveITNexusParameterList
{
    ushort Reserved;
    ushort ITNexusDescriptorListLength;
    array<ITNexusDescriptor> ITNexusDescriptorList with BinaryEncoding{WidthForComposedType = ITNexusDescriptorListLength * 8};
}

type ITNexusDescriptor
{
    ushort RelativeTargetPortIdentifier;
    ushort TransportIdLength;
    TransportId TransportId with BinaryEncoding{WidthForComposedType = TransportIdLength * 8};
}

// [SPC-4] 6.30 REPORT ALIASES command
type ReportAliasesParameterData
{
    uint AdditionalLength;
    ushort Reserved;
    ushort NumberOfAliases;
    array<AliasEntry> AliasEntries with BinaryEncoding{Length = NumberOfAliases};
}

// [SPC-4] 6.31 REPORT ALL ROD TOKENS command
type ReportAllRodTokensParameterData
{
    uint AvailableData;
    uint Reserved;
    array<RodManagementToken> RODManagementTokenList with BinaryEncoding{WidthForComposedType = (AvailableData - 4) * 8 as int};
}

type RodManagementToken
{
    uint RodType;
    ushort Reserved;
    ushort RodTokenLength;
    ulong CopyManagerRodTokenIdentifier;
    array<byte> CreatorLogicalUnitDescriptor with BinaryEncoding{Length = 32};
    array<byte> NumberOfBytesRepresented with BinaryEncoding{Length = 16};
    array<byte> RodTokenTypeSpecificData with BinaryEncoding{Length = 32};
}

// [SPC-4] 6.32.2 Perihperal device identifying information parameter data
type PeripheralDeviceIdentifyingInformationParameterData
{
    ushort Reserved;
    ushort IdentifyingInformationLength;
    array<byte> IdentifyingInformation with BinaryEncoding{Length = IdentifyingInformationLength};
}

type PeripheralDeviceTextIdentifyingInformationParameterData
{
    ushort Reserved;
    ushort IdentifyingInformationLength;
    binary IdentifyingInformation with BinaryEncoding{Length = IdentifyingInformationLength}, DisplayInfo{ToText = DecodeOctetStringAsUTF8};
    // string IdentifyingInformation with BinaryEncoding{TextEncoding = TextEncoding.UTF8, Length = IdentifyingInformationLength};
}

// [SPC-4] 6.32.3 Identifying information supported parameter data
type IdentifyingInformationSupportedParameterData
{
    ushort Reserved;
    ushort IdentifyingInformationLength;
    array<IdentifyingInformationDescriptor> IdentifyingInformationDescriptorList with BinaryEncoding{WidthForComposedType = (IdentifyingInformationLength * 8) as int};
}

type IdentifyingInformationDescriptor
{
    byte IdentifyingInformationType with BinaryEncoding{Width = 7};
    ushort Reserved with BinaryEncoding{Width = 9};
    ushort MaximumIdentifyingInformationLength;
}

// [SPC-4] 6.33 REPORT LUNS command
type ReportLunsParameterData
{
    uint LunListLength;
    uint Reserved;
    array<byte> LunList with BinaryEncoding{Length = LunListLength};
}

// [SPC-4] 6.34 REPORT PRIORITY command
type ReportPriorityParameterData
{
    uint PriorityParameterDataLength;
    array<PriorityDescriptor> PriorityDescriptors with BinaryEncoding{WidthForComposedType = PriorityParameterDataLength * 8 as int};
}

type PriorityDescriptor
{
    byte Reserved1 with BinaryEncoding{Width = 4};
    byte CurrentPriority with BinaryEncoding{Width = 4};
    byte Reserved2;
    ushort RelativeTargetPortIdentifier;
    ushort Reserved3;
    ushort AdditionalDescriptorLength;
    TransportId TransportId;
}

// [SPC-4] 6.35.2 All_commands parameter data format
type AllCommandsParameterData
{
    uint CommandDataLength;
    array<CommandDescriptor> CommandDescriptorsList with BinaryEncoding{WidthForComposedType = (CommandDataLength * 8) as int};
}

type CommandDescriptor
{
    byte OperationCode;
    byte Reserved1;
    ushort ServiceAction;
    ushort Reserved2 with BinaryEncoding{Width = 14};
    bool CTDP with BinaryEncoding{Width = 1};
    bool SERVACTV with BinaryEncoding{Width = 1};
    ushort CDBLength;
    optional [|CTDP|] CommandTimeoutsDescriptor CommandTimeoutsDescriptor;
}

type OneCommandParameterData
{
    byte Reserved1;
    bool CTDP with BinaryEncoding{Width = 1};
    byte Reserved2 with BinaryEncoding{Width = 4};
    byte Support with BinaryEncoding{Width = 3};
    ushort CDBSize;
    binary CDBUsageData with BinaryEncoding{Length = CDBSize};
    optional [|CTDP|] CommandTimeoutsDescriptor CommandTimeoutsDescriptor;
}

type CommandTimeoutsDescriptor
{
    ushort DescriptorLength;
    byte Reserved;
    byte CommandSpecific;
    uint NominalCommandProcessingTimeout;
    uint RecommendedCommandTimeout;
}

// [SPC-4] 6.36 REPORT SUPPORTED TASK MANAGEMENT FUNCTIONS command - Table 300 & 301
type ReportSupportedTaskManagementFunctionsBasicParameterData
{
    bool ATS with BinaryEncoding{Width = 1};
    bool ATSS with BinaryEncoding{Width = 1};
    bool CACAS with BinaryEncoding{Width = 1};
    bool CTSS with BinaryEncoding{Width = 1};
    bool LURS with BinaryEncoding{Width = 1};
    bool QTS with BinaryEncoding{Width = 1};
    byte Obsolete with BinaryEncoding{Width = 2};
    byte Reserved1 with BinaryEncoding{Width = 5};
    bool QAES with BinaryEncoding{Width = 1};
    bool QTSS with BinaryEncoding{Width = 1};
    bool ITNRS with BinaryEncoding{Width = 1};
    byte Reserved2;
    byte ReportSupportedTaskManagementFunctionsAdditionalDataLength;
}

type ReportSupportedTaskManagementFunctionsExtendedParameterData
{
    bool ATS with BinaryEncoding{Width = 1};
    bool ATSS with BinaryEncoding{Width = 1};
    bool CACAS with BinaryEncoding{Width = 1};
    bool CTSS with BinaryEncoding{Width = 1};
    bool LURS with BinaryEncoding{Width = 1};
    bool QTS with BinaryEncoding{Width = 1};
    byte Obsolete with BinaryEncoding{Width = 2};
    byte Reserved1 with BinaryEncoding{Width = 5};
    bool QAES with BinaryEncoding{Width = 1};
    bool QTSS with BinaryEncoding{Width = 1};
    bool ITNRS with BinaryEncoding{Width = 1};
    byte Reserved2;
    byte ReportSupportedTaskManagementFunctionsAdditionalDataLength;
    byte Reserved3 with BinaryEncoding{Width = 7};
    bool TMFTMOV with BinaryEncoding{Width = 1};
    byte Reserved4;
    bool ATTS with BinaryEncoding{Width = 1};
    bool ATSTS with BinaryEncoding{Width = 1};
    bool CACATS with BinaryEncoding{Width = 1};
    bool CTSTS with BinaryEncoding{Width = 1};
    bool LURTS with BinaryEncoding{Width = 1};
    bool QTTS with BinaryEncoding{Width = 1};
    byte Reserved5 with BinaryEncoding{Width = 7};
    bool QAETS with BinaryEncoding{Width = 1};
    bool QTSTS with BinaryEncoding{Width = 1};
    bool ITNRTS with BinaryEncoding{Width = 1};
    uint TaskManagementFunctionsLongTimeout;
    uint TaskManagementFunctionsShortTimeout;
}

// [SPC-4] 6.37 REPORT TARGET PORT GROUPS command - Table 304 & 305
type LengthOnlyHeaderParameterData
{
    uint ReturnDataLength;
    array<TargetPortGroupDescriptor> TargetPortGroupDescriptorList with BinaryEncoding{WidthForComposedType = (ReturnDataLength * 8) as int};
}

type ExtendedHeaderParameterData
{
    uint ReturnDataLength;
    byte Reserved1 with BinaryEncoding{Width = 1};
    (byte where value == 0x01) FormatType with BinaryEncoding{Width = 3};
    byte Reserved2 with BinaryEncoding{Width = 4};
    byte ImplicitTransitionTime;
    ushort Reserved3;
    array<TargetPortGroupDescriptor> TargetPortGroupDescriptorList with BinaryEncoding{WidthForComposedType = ((ReturnDataLength - 4) * 8) as int};
}

type TargetPortGroupDescriptor
{
    bool PREF with BinaryEncoding{Width = 1};
    byte Zero with BinaryEncoding{Width = 3};
    byte AsymmetricAccessState with BinaryEncoding{Width = 4};
    bool T_SUP with BinaryEncoding{Width = 1};
    bool O_SUP with BinaryEncoding{Width = 1};
    byte Reserved1 with BinaryEncoding{Width = 1};
    bool LBD_SUP with BinaryEncoding{Width = 1};
    bool U_SUP with BinaryEncoding{Width = 1};
    bool S_SUP with BinaryEncoding{Width = 1};
    bool AN_SUP with BinaryEncoding{Width = 1};
    bool AO_SUP with BinaryEncoding{Width = 1};
    ushort TargetPortGroup;
    byte Reserved2;
    byte StatusCode;
    byte VendorSpecific;
    byte TargetPortCount;
    array<TargetPortDescriptor> TargetPortDescriptorList with BinaryEncoding{Length = TargetPortCount};
}

type TargetPortDescriptor
{
    ushort Reserved;
    ushort RelativeTargetPortIdentifier;
}

// [SPC-4] 6.38 REPORT SUPPORTED TASK MANAGEMENT FUNCTIONS command - Table 311
type ReportTimestampParameterData
{
    ushort TimestampParameterDataLength;
    byte Reserved1 with BinaryEncoding{Width = 5};
    byte TimestampOrigin with BinaryEncoding{Width = 3};
    byte Reserved2;
    ulong Timestamp with BinaryEncoding{Width = 48};
    ushort Reserved3;
}

// [SPC-4] 6.44 SET PRIORITY command - Table 326
type SetPriorityParameterList
{
    byte Reserved1 with BinaryEncoding{Width = 4};
    byte PriorityToSet with BinaryEncoding{Width = 4};
    byte Reserved2;
    ushort RelativeTargetPortIdentifier;
    ushort Reserved3;
    ushort AdditionalLength;
    TransportId TransportId with BinaryEncoding{Length = AdditionalLength};
}

// [SPC-4] 6.45 SET TARGET PORT GROUPS command - Table 328
type SetTargetPortGroupsParameterList
{
    uint Reserved;
    array<SetTargetPortGroupDescriptor> SetTargetPortGroupDescriptorList;
}

type SetTargetPortGroupDescriptor
{
    byte Reserved1 with BinaryEncoding{Width = 4};
    byte AsymmetricAccessState with BinaryEncoding{Width = 4};
    byte Reserved2;
    ushort TargetPortGroupOrTargetPort;
}

// [SPC-4] 6.46 SET TIMESTAMP command - Table 332
type SetTimestampParameterList
{
    uint Reserved1;
    ulong Timestamp with BinaryEncoding{Width = 48};
    ushort Reserved2;
}

// [SPC-4] 6.48 WRITE ATTRIBUTE command - Table 336
type WriteAttributeParameterList
{
    uint ParameterDataLength;
    array<MAMAttribute> Attributes with BinaryEncoding{WidthForComposedType = (ParameterDataLength * 8) as int};
}

// [SPC-4] 7.2.2 Diagnostic page format and page codes for all device types
type DiagnosticPage
{
    byte PageCode;
    byte PageCodeSpecific;
    ushort PageLength;
    binary DiagnosticParameters with BinaryEncoding{Length = PageLength};
}

// [SPC-4] 7.2.3 Protocol Specific
type ProtocolSpecificDiagnosticPage
{
    (byte where value == 0x3F) PageCode;
    byte Reserved with BinaryEncoding{Width = 4};
    ProtocolIdentifier ProtocolIdentifier with BinaryEncoding{Width = 4};
    ushort PageLength;
    binary SCSITransportProtocolSpecificDiagnosticParameters with BinaryEncoding{Length = PageLength};
}

// [SPC-4] 7.2.4 Supported Diagnostic Pages
type SupportedDiagnosticPagesDiagnosticPage
{
    (byte where value == 0x00) PageCode;
    byte Reserved;
    ushort PageLength;
    array<byte> SupportedPageList with BinaryEncoding{Length = PageLength};
}

// [SPC-4] 7.3.2 Log page structure and log parameter structure for all device types
type LogPage
{
    bool DS with BinaryEncoding{Width = 1};
    bool SPF with BinaryEncoding{Width = 1};
    byte PageCode with BinaryEncoding{Width = 6};
    byte SubpageCode;
    ushort PageLength;
    ([|PageCode == 0x15 && SubpageCode == 0x00|] BackgroundScanLogPageParameter| 
     [|PageCode == 0x08 && SubpageCode == 0x00|] FormatStatusLogPageParameter |
     [|PageCode == 0x0C && SubpageCode == 0x00|] LogicalBlockProvisioningLogPageParameter |
     [|PageCode == 0x17 && SubpageCode == 0x00|] NonvolatileCacheLogPageParameter |
     [|PageCode == 0x11 && SubpageCode == 0x00|] SolidStateMediaLogPageParameter |
     [|PageCode == 0x0F && SubpageCode == 0x00|] ApplicationClientLogPageParameter |
     [|PageCode == 0x01 && SubpageCode == 0x00|] BufferOverRunUnderRunLogPageParameter |
     [|PageCode == 0x19 && SubpageCode == 0x20|] CacheMemoryStatisticsLogPageParameter |
     [|PageCode == 0x19 && SubpageCode == 0x00|] GeneralStatisticsAndPerformanceLogPageParameter |
     [|PageCode == 0x19 && SubpageCode >= 0x01 && SubpageCode <= 0x1F|] GroupStatisticsAndPerformanceLogPageParameter |
     [|PageCode == 0x2F && SubpageCode == 0x00|] InformationalExceptionsLogPageParameter |
     [|PageCode == 0x0B && SubpageCode == 0x00|] LastNDeferredErrorsOrAsynchronousEventsLogPageParameter |
     [|PageCode == 0x07 && SubpageCode == 0x00|] LastNErrorEventsLogPageParameter |
     [|PageCode == 0x06 && SubpageCode == 0x00|] NonMediumErrorLogPageParameter |
     [|PageCode == 0x1A && SubpageCode == 0x00|] PowerConditionTransitionsLogPageParameter |
     [|PageCode == 0x18 && SubpageCode >= 0x00 && SubpageCode <= 0xFE|] ProtocolSpecificPortLogPageParameter |
     [|PageCode == 0x03 && SubpageCode == 0x00|] ReadErrorCountersLogPageParameter |
     [|PageCode == 0x04 && SubpageCode == 0x00|] ReadReverseErrorCountersLogPageParameter |
     [|PageCode == 0x10 && SubpageCode == 0x00|] SelfTestResultsLogPageParameter |
     [|PageCode == 0x0E && SubpageCode == 0x00|] StartStopCycleCounterLogPageParameter |
     [|PageCode == 0x00 && SubpageCode == 0x00|] SupportedLogPagesLogPageParameter |
     [|PageCode == 0x00 && SubpageCode == 0xFF|] SupportedLogPagesAndSubpagesLogPageParameter |
     [|PageCode >= 0x01 && PageCode <= 0x3F && SubpageCode == 0xFF|] SupportedSubpagesLogPageParameter |
     [|PageCode == 0x0D && SubpageCode == 0x00|] TemperatureLogPageParameter |
     [|PageCode == 0x05 && SubpageCode == 0x00|] VerifyErrorCountersLogPageParameter |
     [|PageCode == 0x02 && SubpageCode == 0x00|] WriteErrorCountersLogPageParameter |
     array<LogParameter> | binary) LogParameters with BinaryEncoding{WidthForComposedType = (PageLength * 8) as int, Length = PageLength};
     
     override string ToString()
     {
         if (PageCode == 0x19 && SubpageCode >= 0x01 && SubpageCode <= 0x1F)
         {
             return "Group Statistics and Performance Log Page";
         }
         if (PageCode == 0x18 && SubpageCode >= 0x00 && SubpageCode <= 0xFE)
         {
             return "Protocol Specific Port LogPage";
         }
         if (PageCode >= 0x01 && PageCode <= 0x3F && SubpageCode == 0xFF)
         {
             return "Supported Subpages Log Page";
         }
         ushort code = ((PageCode as ushort) << 8 + SubpageCode) as ushort;
         switch (code)
         {
             case 0x1500 =>
                return "Background Scan Log Page";
             case 0x0800 =>
                return "Format Status Log Page";
             case 0x0C00 =>
                return "Logical Block Provisioning Log Page";
             case 0x1700 =>
                return "Non-volatile Cache Log Page";
             case 0x1100 =>
                return "Solid State Media Log Page";
             case 0x0F00 =>
                return "Application Client Log Page";
             case 0x0100 =>
                return "Buffer Over-Run/Under-Run Log Page";
             case 0x1920 =>
                return "Cache Memory Statistics Log Page";
             case 0x1900 =>
                return "General Statistics and Performance Log Page";
             case 0x2F00 =>
                return "Informational Exceptions Log Page";
             case 0x0B00 =>
                return "Last n Deferred Errors or Asynchronous Events Log Page";
             case 0x0700 =>
                return "Last n Error Events Log Page";
             case 0x0600 =>
                return "Non-Medium Error Log Page";
             case 0x1A00 =>
                return "Power Condition Transitions Log Page";
             case 0x0300 =>
                return "Read Error Counters Log Page";
             case 0x0400 =>
                return "Read Reverse Error Counters Log Page";
             case 0x1000 =>
                return "Self-Test Results Log Page";
             case 0x0E00 =>
                return "Start-Stop Cycle Counter Log Page";
             case 0x0000 =>
                return "Supported Log Pages Log Page";
             case 0x00FF =>
                return "Supported Log Pages and Subpages Log Page";
             case 0x0D00 =>
                return "Temperature Log Page";
             case 0x0500 =>
                return "Verify Error Counters Log Page";
             case 0x0200 =>
                return "Write Error Counters Log Page";
             default =>
                return "Unknown Log Page, PageCode: " + Utility.DecToHexFormat(PageCode) + ", SubpageCode: " + Utility.DecToHexFormat(SubpageCode);
         }
     }
}

type LogParameter
{
    ushort ParameterCode;
    bool DU with BinaryEncoding{Width = 1};
    byte Obsolete with BinaryEncoding{Width = 1};
    bool TSD with BinaryEncoding{Width = 1};
    bool ETC with BinaryEncoding{Width = 1};
    byte TMC with BinaryEncoding{Width = 2};
    byte FormatAndLinking with BinaryEncoding{Width = 2};
    byte ParameterLength;
    array<byte> ParameterValue with BinaryEncoding{Length = ParameterLength};
}

//  [SPC-4] 7.3.3 Application Client log page - Page Code (0Fh) SubpageCode (00h)
type ApplicationClientLogPageParameter
{
    array<LogParameter> ApplicationClientLogParameters;
}

// [SPC-4] 7.3.4 Buffer Over-Run/Under-Run log page - Page Code (01h) SubpageCode (00h)
type BufferOverRunUnderRunLogPageParameter
{
    array<BufferOverRunUnderRunLogParameter> BufferOverRunUnderRunLogParameters;
}

type BufferOverRunUnderRunLogParameter
{
    ushort ParameterCode;
    bool DU with BinaryEncoding{Width = 1};
    byte Obsolete with BinaryEncoding{Width = 1};
    bool TSD with BinaryEncoding{Width = 1};
    bool ETC with BinaryEncoding{Width = 1};
    byte TMC with BinaryEncoding{Width = 2};
    byte FormatAndLinking with BinaryEncoding{Width = 2};
    byte ParameterLength;
    array<byte> OverRunUnderRunCounter with BinaryEncoding{Length = ParameterLength};
}

// [SPC-4] 7.3.5 Cache Memory Statistics log page - Page Code (19h) SubpageCode (20h)
type CacheMemoryStatisticsLogPageParameter
{
    array<CacheMemoryStatisticsLogParameter> CacheMemoryStatisticsLogParameters;
}

type CacheMemoryStatisticsLogParameter
{
    ushort ParameterCode;
    bool DU with BinaryEncoding{Width = 1};
    byte Obsolete with BinaryEncoding{Width = 1};
    bool TSD with BinaryEncoding{Width = 1};
    bool ETC with BinaryEncoding{Width = 1};
    byte TMC with BinaryEncoding{Width = 2};
    byte FormatAndLinking with BinaryEncoding{Width = 2};
    byte ParameterLength;
    ([|ParameterCode == 0x0001|] ReadCacheMemoryHitsLogParameter |
     [|ParameterCode == 0x0002|] ReadToCacheMemoryLogParameter |
     [|ParameterCode == 0x0003|] WriteCacheMemoryHitsLogParameter |
     [|ParameterCode == 0x0004|] WriteFromCacheMemoryLogParameter |
     [|ParameterCode == 0x0005|] TimeFromLastHardResetLogParameter |
     TimeIntervalLogParameter | binary) ParameterValue with BinaryEncoding{Length = ParameterLength};
}

type ReadCacheMemoryHitsLogParameter
{
    ulong NumberOfReadCacheMemoryHits;
}

type ReadToCacheMemoryLogParameter
{
    ulong NumberOfReadToCacheMemory;
}

type WriteCacheMemoryHitsLogParameter
{
    ulong NumberOfWriteCacheMemoryHits;
}

type WriteFromCacheMemoryLogParameter
{
    ulong NumberOfWriteFromCacheMemory;
}

type TimeFromLastHardResetLogParameter
{
    ulong LastHardResetIntervals;
}

type TimeIntervalLogParameter
{
    TimeIntervalDescriptor TimeIntervalDescriptor;
}

type TimeIntervalDescriptor
{
    uint Exponent;
    uint Integer;
}

// [SPC-4] 7.3.6 General Statistics and Performance log page - Page Code (19h) SubpageCode (00h)
type GeneralStatisticsAndPerformanceLogPageParameter
{
    array<GeneralStatisticsAndPerformanceLogParameter> GeneralStatisticsAndPerformanceLogParameters;
}

type GeneralStatisticsAndPerformanceLogParameter
{
    ushort ParameterCode;
    bool DU with BinaryEncoding{Width = 1};
    byte Obsolete with BinaryEncoding{Width = 1};
    bool TSD with BinaryEncoding{Width = 1};
    bool ETC with BinaryEncoding{Width = 1};
    byte TMC with BinaryEncoding{Width = 2};
    byte FormatAndLinking with BinaryEncoding{Width = 2};
    byte ParameterLength;
    ([|ParameterCode == 0x0001|] GeneralAccessStatisticsAndPerformanceLogParameter |
     [|ParameterCode == 0x0002|] IdleTimeLogParameter |
     [|ParameterCode == 0x0004|] ForceUnitAccessStatisticsAndPerformanceLogParameter |
     binary) ParameterValue with BinaryEncoding{Length = ParameterLength};
}

type GeneralAccessStatisticsAndPerformanceLogParameter
{
    ulong NumberOfReadCommands;
    ulong NumberOfWriteCommands;
    ulong NumberOfLogicalBlocksReceived;
    ulong NumberOfLogicalBlocksTransmitted;
    ulong ReadCommandProcessingIntervals;
    ulong WriteCommandProcessingIntervals;
    ulong WeightedNumberOfRdCommandsPlusWtCommands;
    ulong WeightedRdCommandProcessingPlusWtCommandProcessing;
}

type IdleTimeLogParameter
{
    ulong IdleTimeIntervals;
}

type ForceUnitAccessStatisticsAndPerformanceLogParameter
{
    ulong NumberOfReadFuaCommands;
    ulong NumberOfWriteFuaCommands;
    ulong NumberOfReadFuaNvCommands;
    ulong NumberOfWriteFuaNvCommands;
    ulong ReadFuaCommandProcessingIntervals;
    ulong WriteFuaCommandProcessingIntervals;
    ulong ReadFuaNvCommandProcessingIntervals;
    ulong WriteFuaNvCommandProcessingIntervals;
}

// [SPC-4] 7.3.7 Group Statistics and Performance log page - Page Code (19h) SubpageCode (01h to 0Fh)
type GroupStatisticsAndPerformanceLogPageParameter
{
    array<GroupStatisticsAndPerformanceLogParameter> GroupStatisticsAndPerformanceLogParameters;
}

type GroupStatisticsAndPerformanceLogParameter
{
    ushort ParameterCode;
    bool DU with BinaryEncoding{Width = 1};
    byte Obsolete with BinaryEncoding{Width = 1};
    bool TSD with BinaryEncoding{Width = 1};
    bool ETC with BinaryEncoding{Width = 1};
    byte TMC with BinaryEncoding{Width = 2};
    byte FormatAndLinking with BinaryEncoding{Width = 2};
    byte ParameterLength;
    ([|ParameterCode == 0x0001|] GroupNStatisticsAndPerformanceLogParameter |
     [|ParameterCode == 0x0004|] GroupNForceUnitAccessStatisticsAndPerformanceLogParameter |
     binary) ParameterValue with BinaryEncoding{Length = ParameterLength};
}

type GroupNStatisticsAndPerformanceLogParameter
{
    ulong GroupNNumberOfReadCommands;
    ulong GroupNNumberOfWriteCommands;
    ulong GroupNNumberOfLogicalBlocksReceived;
    ulong GroupNNumberOfLogicalBlocksTransmitted;
    ulong GroupNReadCommandProcessingIntervals;
    ulong GroupNWriteCommandProcessingIntervals;
}

type GroupNForceUnitAccessStatisticsAndPerformanceLogParameter
{
    ulong GroupNNumberOfReadFuaCommands;
    ulong GroupNNumberOfWriteFuaCommands;
    ulong GroupNNumberOfReadFuaNvCommands;
    ulong GroupNNumberOfWriteFuaNvCommands;
    ulong GroupNReadFuaCommandProcessingIntervals;
    ulong GroupNWriteFuaCommandProcessingIntervals;
    ulong GroupNReadFuaNvCommandProcessingIntervals;
    ulong GroupNWriteFuaNvCommandProcessingIntervals;
}

// [SPC-4] 7.3.8 Information Exceptions log page - Page Code (2Fh) SubpageCode (00h)
type InformationalExceptionsLogPageParameter
{
    array<InformationalExceptionsGeneralLogParameter | LogParameter> InformationalExceptionsLogParameters;
}

type InformationalExceptionsGeneralLogParameter
{
    (ushort where value == 0x0000) ParameterCode;
    bool DU with BinaryEncoding{Width = 1};
    byte Obsolete with BinaryEncoding{Width = 1};
    bool TSD with BinaryEncoding{Width = 1};
    bool ETC with BinaryEncoding{Width = 1};
    byte TMC with BinaryEncoding{Width = 2};
    byte FormatAndLinking with BinaryEncoding{Width = 2};
    byte ParameterLength;
    byte InformationalExceptionAdditionalSenseCode;
    byte InformationalExceptionAdditionalSenseCodeQualifier;
    byte MostRecentTemperatureReading;
    array<byte> VendorSpecific with BinaryEncoding{Length = (ParameterLength - 3)};
}

// [SPC-4] 7.3.9 Last n Deferred Errors or Asynchronous Events log page - Page Code (0Bh) SubpageCode (00h)
type LastNDeferredErrorsOrAsynchronousEventsLogPageParameter
{
    array<LogParameter> DeferredErrorOrAsynchronousEventLogParameters;
}

// [SPC-4] 7.3.10 Last n Error Events log page - Page Code (07h) SubpageCode (00h)
type LastNErrorEventsLogPageParameter
{
    array<ErrorEventLogParameter> ErrorEventLogParameters;
}

type ErrorEventLogParameter
{
    ushort ParameterCode;
    bool DU with BinaryEncoding{Width = 1};
    byte Obsolete with BinaryEncoding{Width = 1};
    bool TSD with BinaryEncoding{Width = 1};
    bool ETC with BinaryEncoding{Width = 1};
    byte TMC with BinaryEncoding{Width = 2};
    byte FormatAndLinking with BinaryEncoding{Width = 2};
    byte ParameterLength;
    string ErrorEventData with BinaryEncoding{TextEncoding = TextEncoding.ASCII, Length = ParameterLength};
}

// [SPC-4] 7.3.11 Non-Medium Error log page - Page Code (06h) SubpageCode (00h)
type NonMediumErrorLogPageParameter
{
    array<LogParameter> NonMediumErrorLogParameters;
}

// [SPC-4] 7.3.12 Power Condition Transitions log page - Page Code (1Ah) SubpageCode (00h)
type PowerConditionTransitionsLogPageParameter
{
    array<LogParameter> PowerConditionTransitionsLogParameters;
}

// [SPC-4] 7.3.13 Protocol Specific Port log page - Page Code (18h) SubpageCode (00h to FEh)
type ProtocolSpecificPortLogPageParameter
{
    array<GenericProtocolSpecificPortLogParameter> ProtocolSpecificPortLogParameters;
}

type GenericProtocolSpecificPortLogParameter
{
    ushort ParameterCode;
    bool DU with BinaryEncoding{Width = 1};
    byte Obsolete with BinaryEncoding{Width = 1};
    bool TSD with BinaryEncoding{Width = 1};
    bool ETC with BinaryEncoding{Width = 1};
    byte TMC with BinaryEncoding{Width = 2};
    byte FormatAndLinking with BinaryEncoding{Width = 2};
    byte ParameterLength;
    byte Reserved with BinaryEncoding{Width = 4};
    ProtocolIdentifier ProtocolIdentifier with BinaryEncoding{Width = 4};
    array<byte> SCSITransportProtocolSpecific with BinaryEncoding{Length = (ParameterLength - 1)};
}

// [SPC-4] 7.3.14 Read Error Counters log page - Page Code (03h) SubpageCode (00h)
type ReadErrorCountersLogPageParameter
{
    array<LogParameter> ReadErrorCounterLogParameters;
}

// [SPC-4] 7.3.15 Read Reverse Error Counters log page - Page Code (04h) SubpageCode (00h)
type ReadReverseErrorCountersLogPageParameter
{
    array<LogParameter> ReadReverseErrorCounterLogParameters;
}

// [SPC-4] 7.3.16 Self-Test Results log page - Page Code (10h) SubpageCode (00h)
type SelfTestResultsLogPageParameter
{
    array<UnusedSelfTestResultsLogParameter | SelfTestResultsLogParameter> SelfTestResultsLogParameters;
}

type UnusedSelfTestResultsLogParameter
{
    ushort ParameterCode;
    bool DU with BinaryEncoding{Width = 1};
    byte Obsolete with BinaryEncoding{Width = 1};
    bool TSD with BinaryEncoding{Width = 1};
    bool ETC with BinaryEncoding{Width = 1};
    byte TMC with BinaryEncoding{Width = 2};
    byte FormatAndLinking with BinaryEncoding{Width = 2};
    (byte where value == 0x10) ParameterLength;
    (binary where value == $[00000000000000000000000000000000]) Zero;
}

type SelfTestResultsLogParameter
{
    ushort ParameterCode;
    bool DU with BinaryEncoding{Width = 1};
    byte Obsolete with BinaryEncoding{Width = 1};
    bool TSD with BinaryEncoding{Width = 1};
    bool ETC with BinaryEncoding{Width = 1};
    byte TMC with BinaryEncoding{Width = 2};
    byte FormatAndLinking with BinaryEncoding{Width = 2};
    byte ParameterLength;
    byte SelfTestCode with BinaryEncoding{Width = 3};
    byte Reserved1 with BinaryEncoding{Width = 1};
    byte SelfTestResults with BinaryEncoding{Width = 4};
    byte SelfTestNumber;
    ushort AccumulatedPowerOnHours;
    ulong AddressOfFirstFailure;
    byte Reserved2 with BinaryEncoding{Width = 4};
    byte SenseKey with BinaryEncoding{Width = 4};
    byte AdditionalSenseCode;
    byte AdditionalSenseCodeQualifier;
    byte VendorSpecific;
}

// [SPC-4] 7.3.17 Start-Stop Cycle Counter log page - Page Code (0Eh) SubpageCode (00h)
type StartStopCycleCounterLogPageParameter
{
    array<StartStopCycleLogParameter> StartStopCycleLogParameters;
}

type StartStopCycleLogParameter
{
    ushort ParameterCode;
    bool DU with BinaryEncoding{Width = 1};
    byte Obsolete with BinaryEncoding{Width = 1};
    bool TSD with BinaryEncoding{Width = 1};
    bool ETC with BinaryEncoding{Width = 1};
    byte TMC with BinaryEncoding{Width = 2};
    byte FormatAndLinking with BinaryEncoding{Width = 2};
    byte ParameterLength;
    ([|ParameterCode == 0x0001|] DateOfManufactureLogParameter |
     [|ParameterCode == 0x0002|] AccountingDateLogParameter |
     [|ParameterCode == 0x0003|] SpecifiedCycleCountOverDeviceLifetimeLogParameter |
     [|ParameterCode == 0x0004|] AccumulatedStartStopCyclesLogParameter |
     [|ParameterCode == 0x0005|] SpecifiedLoadUnloadCountOverDeviceLifetimeLogParameter |
     [|ParameterCode == 0x0006|] AccumulatedLoadUnloadCyclesLogParameter |
     binary) ParameterValue with BinaryEncoding{Length = ParameterLength};
}

type DateOfManufactureLogParameter
{
    string YearOfManufacture with BinaryEncoding{TextEncoding = TextEncoding.ASCII, Length = 4};
    string WeekOfManufacture with BinaryEncoding{TextEncoding = TextEncoding.ASCII, Length = 2};
}

type AccountingDateLogParameter
{
    string AccountingDateYear with BinaryEncoding{TextEncoding = TextEncoding.ASCII, Length = 4};
    string AccountingDateWeek with BinaryEncoding{TextEncoding = TextEncoding.ASCII, Length = 2};
}

type SpecifiedCycleCountOverDeviceLifetimeLogParameter
{
    uint SpecifiedCycleCountOverDeviceLifeTime;
}

type AccumulatedStartStopCyclesLogParameter
{
    uint AccumulatedStartStopCycles;
}

type SpecifiedLoadUnloadCountOverDeviceLifetimeLogParameter
{
    uint SpecifiedLoadUnloadCountOverDeviceLifetime;
}

type AccumulatedLoadUnloadCyclesLogParameter
{
    uint AccumulatedLoadUnloadCycles;
}

// [SPC-4] 7.3.18 Supported Log Pages log page - Page Code (00h) SubpageCode (00h)
type SupportedLogPagesLogPageParameter
{
    array<SupportedPageDescriptor> SupportedPagesList;
}

type SupportedPageDescriptor
{
    byte Reserved with BinaryEncoding{Width = 2};
    byte PageCode with BinaryEncoding{Width = 6};
}

// [SPC-4] 7.3.19 Supported Log Pages and Subpages log page - Page Code (00h) SubpageCode (FFh)
type SupportedLogPagesAndSubpagesLogPageParameter
{
    array<SupportedPageSubpageDescriptor> SupportedPageSubpageDescriptors;
}

type SupportedPageSubpageDescriptor
{
     byte Reserved with BinaryEncoding{Width = 2};
     byte PageCode with BinaryEncoding{Width = 6};
     byte SubpageCode;
}

// [SPC-4] 7.3.20 Supported Subpages log page
type SupportedSubpagesLogPageParameter
{
    array<SupportedPageSubpageDescriptor> SupportedSubpageDescriptors;
}

// [SPC-4] 7.3.21 Temperature log page
type TemperatureLogPageParameter
{
    array<TemperatureLogParameter | ReferenceTemperatureLogParameter> TemperatureLogParameters;
}

type TemperatureLogParameter
{
    (ushort where value == 0x0000) ParameterCode;
    bool DU with BinaryEncoding{Width = 1};
    byte Obsolete with BinaryEncoding{Width = 1};
    bool TSD with BinaryEncoding{Width = 1};
    bool ETC with BinaryEncoding{Width = 1};
    byte TMC with BinaryEncoding{Width = 2};
    byte FormatAndLinking with BinaryEncoding{Width = 2};
    byte ParameterLength;
    byte Reserved;
    byte Temperature;
}

type ReferenceTemperatureLogParameter
{
    (ushort where value == 0x0001) ParameterCode;
    bool DU with BinaryEncoding{Width = 1};
    byte Obsolete with BinaryEncoding{Width = 1};
    bool TSD with BinaryEncoding{Width = 1};
    bool ETC with BinaryEncoding{Width = 1};
    byte TMC with BinaryEncoding{Width = 2};
    byte FormatAndLinking with BinaryEncoding{Width = 2};
    byte ParameterLength;
    byte Reserved;
    byte ReferenceTemperature;
}

// [SPC-4] 7.3.22 Verify Error Counters log page
type VerifyErrorCountersLogPageParameter
{
    array<VerifyErrorCounterLogParameter> VerifyErrorCounterLogParameters;
}

type VerifyErrorCounterLogParameter
{
    ushort ParameterCode;
    bool DU with BinaryEncoding{Width = 1};
    byte Obsolete with BinaryEncoding{Width = 1};
    bool TSD with BinaryEncoding{Width = 1};
    bool ETC with BinaryEncoding{Width = 1};
    byte TMC with BinaryEncoding{Width = 2};
    byte FormatAndLinking with BinaryEncoding{Width = 2};
    byte ParameterLength;
    array<byte> VerifyErrorCounter with BinaryEncoding{Length = ParameterLength};
}

// [SPC-4] 7.3.23 Write Error Counters log page
type WriteErrorCountersLogPageParameter
{
    array<WriteErrorCounterLogParameter> WriteErrorCounterLogParameters;
}

type WriteErrorCounterLogParameter
{
    ushort ParameterCode;
    bool DU with BinaryEncoding{Width = 1};
    byte Obsolete with BinaryEncoding{Width = 1};
    bool TSD with BinaryEncoding{Width = 1};
    bool ETC with BinaryEncoding{Width = 1};
    byte TMC with BinaryEncoding{Width = 2};
    byte FormatAndLinking with BinaryEncoding{Width = 2};
    byte ParameterLength;
    array<byte> WriteErrorCounter with BinaryEncoding{Length = ParameterLength};
}

// [SPC-4] 7.4.1 Attribute format
type MAMAttribute
{
    ushort AttributeIdentifier;
    bool ReadOnly with BinaryEncoding{Width = 1};
    byte Reserved with BinaryEncoding{Width = 5};
    byte Format with BinaryEncoding{Width = 2};
    ushort AttributeLength;
    ([|Format == 0x01|] string | binary) AttributeValue with BinaryEncoding{Length = AttributeLength, TextEncoding = TextEncoding.ASCII};
}

// [SPC-4] 7.5.5 Mode parameter header formats
type ModeParameterHeader6
{
    byte ModeDataLength;
    byte MediumType;
    byte DeviceSpecificParameter;
    byte BlockDescriptorLength;
}

type ModeParameterHeader10
{
    ushort ModeDataLength;
    byte MediumType;
    byte DeviceSpecificParameter;
    byte Reserved1 with BinaryEncoding{Width = 7};
    bool LongLBA with BinaryEncoding{Width = 1};
    byte Reserved2;
    ushort BlockDescriptorLength;
}

type ModeParameterList6
{
    ModeParameterHeader6 ModeParameterHeader;
    array<ShortLBAModeParameterBlockDescriptor> BlockDescriptors with BinaryEncoding{WidthForComposedType = ModeParameterHeader.BlockDescriptorLength * 8};
    array<ModePage> ModePages;
}

type ModeParameterList10
{
    ModeParameterHeader10 ModeParameterHeader;
    ([|ModeParameterHeader.LongLBA|] array<LongLBAModeParameterBlockDescriptor> | [|!(ModeParameterHeader.LongLBA)|] array<ShortLBAModeParameterBlockDescriptor>) BlockDescriptors 
        with BinaryEncoding{WidthForComposedType = ModeParameterHeader.BlockDescriptorLength * 8};
    array<ModePage> ModePages;
}
     
pattern ModePage = Page0ModePage | SubpageModePage;

// [SPC-4] 7.5.7 Mode page and subpage formats and page codes
type Page0ModePage
{
    bool PS with BinaryEncoding{Width = 1};
    (bool where value == false) SPF with BinaryEncoding{Width = 1};
    byte PageCode with BinaryEncoding{Width = 6};
    byte PageLength;
    ([|PageCode == 0x08 && PageLength == 0x12|] CachingModePageParameter |
     [|PageCode == 0x1C && PageLength == 0x0A|] InformationalExceptionsControlModePageParameter |
     [|PageCode == 0x01 && PageLength == 0x0A|] ReadWriteErrorRecoverModePageParameter |
     [|PageCode == 0x07 && PageLength == 0x0A|] VerifyErrorRecoverModePageParameter |
     [|PageCode == 0x0A && PageLength == 0x0A|] ControlModePageParameter |
     [|PageCode == 0x02 && PageLength == 0x0E|] DisconnectReconnectModePageParameter |
     [|PageCode == 0x1A && PageLength == 0x26|] PowerConditionModePageParameter |
     [|PageCode == 0x03 && PageLength == 0x16|] FormatDevicePageParameter |
     [|PageCode == 0x04 && PageLength == 0x16|] RigidDiskDeviceGeometryPageParameter |
     [|PageCode == 0x18|] ProtocolSpecificLogicalUnitModePageParameter |
     [|PageCode == 0x19|] Page0FormatProtocolSpecificPortModePageParameter |
     binary) ModeParameters with BinaryEncoding{Length = PageLength, WidthForComposedType = PageLength * 8};
     
     override string ToString()
     {
         switch (PageCode)
         {
             case 0x08 =>
                return "Caching Mode Page";
             case 0x1C =>
                return "Informational Exception Control Mode Page";
             case 0x01 =>
                return "Read Write Error Recover Mode Page";
             case 0x07 =>
                return "Verify Error Recover Mode Page";
             case 0x0A =>
                return "Control Mode Page";
             case 0x02 =>
                return "Disconnect-Reconnect Mode Page";
             case 0x1A => 
                return "Power Condition Mode Page";
             case 0x18 =>
                return "Protocol Specific Logical Unit Mode Page";
             case 0x19 =>
                return "Page_0 Format Protocol Specific Port Mode Page";
             case 0x15 =>
                return "Extended Mode Page";
             case 0x16 =>
                return "Extended Device-Type Specific Mode Page";
             case 0x03 =>
                return "Format Device Page";
             case 0x04 =>
                return "Rigid Disk Device Geometry Page";
             default =>
                return "Unknown Mode Page, PageCode: " + Utility.DecToHexFormat(PageCode);
         }
     }
}

type SubpageModePage
{
    bool PS with BinaryEncoding{Width = 1};
    (bool where value == true) SPF with BinaryEncoding{Width = 1};
    byte PageCode with BinaryEncoding{Width = 6};
    byte SubpageCode;
    ushort PageLength;
    ([|PageCode == 0x0A && SubpageCode == 0x02|] ApplicationTagModePageParameter |
     [|PageCode == 0x1C && SubpageCode == 0x01|] BackgroundControlModePageParameter |
     [|PageCode == 0x1C && SubpageCode == 0x02|] LogicalBlockProvisioningModePageParameter |
     [|PageCode == 0x0A && SubpageCode == 0x01|] ControlExtensionModePageParameter |
     [|PageCode == 0x1A && SubpageCode == 0x01|] PowerConsumptionModePageParameter |
     [|PageCode == 0x19|] SubpageFormatProtocolSpecificPortModePageParameter |
     binary) ModeParameters with BinaryEncoding{Length = PageLength, WidthForComposedType = PageLength * 8};
     
    override string ToString()
    {
        switch (ModeParameters)
        {
            case p:ApplicationTagModePageParameter =>
                return "Application Tag Mode Page";
            case p:BackgroundControlModePageParameter =>
                return "Background Control Mode Page";
            case p:LogicalBlockProvisioningModePageParameter =>
                return "Logical Block Provisioning Mode Page";
            case p:ControlExtensionModePageParameter =>
                return "Control Extension Mode Page";
            case p:PowerConsumptionModePageParameter =>
                return "Power Consumption Mode Page";
            case p:SubpageFormatProtocolSpecificPortModePageParameter =>
                return "Subpage Format Protocol Specific Port Mode Page";
            default =>
                return "Unknown Mode Page, PageCode: " + Utility.DecToHexFormat(PageCode) + ", SubpageCode: " + Utility.DecToHexFormat(SubpageCode);
        }
    }
}

// [SBC-2] 6.2.4 Format device page
type FormatDevicePageParameter
{
    ushort TracksPerZone;
    ushort AlternateSectorsPerZone;
    ushort AlternateTracksPerZone;
    ushort AlternateTracksPerLogicalUnit;
    ushort SectorsPerTrack;
    ushort DataBytesPerPhysicalSector;
    ushort Interleave;
    ushort TrackSkewFactor;
    ushort CylinderSkewFactor;
    bool SSEC with BinaryEncoding{Width = 1};
    bool HSEC with BinaryEncoding{Width = 1};
    bool RMB with BinaryEncoding{Width = 1};
    bool SURF with BinaryEncoding{Width = 1};
    uint Reserved with BinaryEncoding{Width = 28};
}

// [SBC-2] 6.2.8 Rigid disk device geometry page
type RigidDiskDeviceGeometryPageParameter
{
    uint NumberOfCylinders with BinaryEncoding{Width = 24};
    byte NumberOfHeads;
    uint StartingCylinderWritePrecompensation with BinaryEncoding{Width = 24};
    uint StartingCylinderReducedWriteCurrent with BinaryEncoding{Width = 24};
    ushort DeviceStepRate;
    uint LandingZoneCylinder with BinaryEncoding{Width = 24};
    byte Reserved1 with BinaryEncoding{Width = 6};
    byte RPL with BinaryEncoding{Width = 2};
    byte RotationalOffset;
    byte Reserved2;
    ushort MediumRotationRate;
    ushort Reserved3;
}

// [SPC-4] 7.5.8 Control mode page
type ControlModePageParameter
{
    byte TST with BinaryEncoding{Width = 3};
    bool TMF_ONLY with BinaryEncoding{Width = 1};
    bool DPICZ with BinaryEncoding{Width = 1};
    bool D_SENSE with BinaryEncoding{Width = 1};
    bool GLTSD with BinaryEncoding{Width = 1};
    bool RLEC with BinaryEncoding{Width = 1};
    byte QueueAlgorithmModifier with BinaryEncoding{Width = 4};
    bool NUAR with BinaryEncoding{Width = 1};
    byte QErr with BinaryEncoding{Width = 2};
    byte Obsolete1 with BinaryEncoding{Width = 1};
    bool VS with BinaryEncoding{Width = 1};
    bool RAC with BinaryEncoding{Width = 1};
    byte UA_INTLCK_CTRL with BinaryEncoding{Width = 2};
    bool SWP with BinaryEncoding{Width = 1};
    byte Obsolete2 with BinaryEncoding{Width = 3};
    bool ATO with BinaryEncoding{Width = 1};
    bool TAS with BinaryEncoding{Width = 1};
    bool ATMPE with BinaryEncoding{Width = 1};
    bool RWWP with BinaryEncoding{Width = 1};
    byte Reserved with BinaryEncoding{Width = 1};
    byte AutoloadMode with BinaryEncoding{Width = 3};
    ushort Obsolete3;
    ushort BusyTimeoutPeriod;
    ushort ExtendedSelfTestCompletionTime;
}

// [SPC-4] 7.5.9 Control Extension mode page
type ControlExtensionModePageParameter
{
    byte Reserved1 with BinaryEncoding{Width = 5};
    bool TCMOS with BinaryEncoding{Width = 1};
    bool SCSIP with BinaryEncoding{Width = 1};
    bool IALUAE with BinaryEncoding{Width = 1};
    byte Reserved2 with BinaryEncoding{Width = 4};
    byte InitialCommandPriority with BinaryEncoding{Width = 4};
    byte MaximumSenseDataLength;
    array<byte> Reserved3 with BinaryEncoding{Length = 25};
}

// [SPC-4] 7.5.10 Disconnect-Reconnect mode page
type DisconnectReconnectModePageParameter
{
    byte BufferFullRatio;
    byte BufferEmptyRatio;
    ushort BusInactivityLimit;
    ushort DisconnectTimeLimit;
    ushort ConnectTimeLimit;
    ushort MaximumBurstSize;
    bool EMDP with BinaryEncoding{Width = 1};
    byte FairArbitration with BinaryEncoding{Width = 3};
    bool DImm with BinaryEncoding{Width = 1};
    byte DTDC with BinaryEncoding{Width = 3};
    byte Reserved;
    ushort FirstBurstSize;
}

// [SPC-4] 7.5.13 Power Condition mode page
type PowerConditionModePageParameter
{
    byte PM_BG_PRECEDENCE with BinaryEncoding{Width = 2};
    byte Reserved1 with BinaryEncoding{Width = 5};
    bool STANDBY_Y with BinaryEncoding{Width = 1};
    byte Reserved2 with BinaryEncoding{Width = 4};
    bool IDLE_C with BinaryEncoding{Width = 1};
    bool IDLE_B with BinaryEncoding{Width = 1};
    bool IDLE_A with BinaryEncoding{Width = 1};
    bool STANDBY_Z with BinaryEncoding{Width = 1};
    uint IdleAConditionTimer;
    uint StandbyZConditionTimer;
    uint IdleBConditionTimer;
    uint IdleCConditionTimer;
    uint StandbyYConditionTimer;
    array<byte> Reserved3 with BinaryEncoding{Length = 15};
    byte CcfIdle with BinaryEncoding{Width = 2};
    byte CcfStandby with BinaryEncoding{Width = 2};
    byte CcfStopped with BinaryEncoding{Width = 2};
    byte Reserved4 with BinaryEncoding{Width = 2};
}

// [SPC-4] 7.5.14 Power Consumption mode page
type PowerConsumptionModePageParameter
{
    array<byte> Reserved1 with BinaryEncoding{Length = 3};
    byte PowerConsumptionIdentifier;
    array<byte> Reserved2 with BinaryEncoding{Length = 8};
}

// [SPC-4] 7.5.15 Protocol Specific Logical Unit mode page
type ProtocolSpecificLogicalUnitModePageParameter
{
    byte ProtocolSpecificModeParameters1 with BinaryEncoding{Width = 4};
    ProtocolIdentifier ProtocolIdentifier with BinaryEncoding{Width = 4};
    array<byte> ProtocolSpecificModeParameters2;
}

// [SPC-4] 7.5.16 Protocol Specific Port mode page
type Page0FormatProtocolSpecificPortModePageParameter
{
    byte ProtocolSpecificModeParameters1 with BinaryEncoding{Width = 4};
    ProtocolIdentifier ProtocolIdentifier with BinaryEncoding{Width = 4};
    array<byte> ProtocolSpecificModeParameters2;
}

type SubpageFormatProtocolSpecificPortModePageParameter
{
    byte Reserved;
    byte ProtocolSpecificModeParameters1 with BinaryEncoding{Width = 4};
    ProtocolIdentifier ProtocolIdentifier with BinaryEncoding{Width = 4};
    array<byte> ProtocolSpecificModeParameters2;
}

// [SPC-4] 7.6.1 Protocol specific parameters introduction
pattern ProtocolIdentifier = enum byte
{
    FibreChannelProtocolForSCSI               = 0x00,
    SCSIParallelInterface                     = 0x01,
    SerialStorageArchitectureSCSI3Protocol    = 0x02,
    SerialBusProtocolForIEEE1394              = 0x03,
    SCSIRDMAProtocol                          = 0x04,
    InternetSCSI                              = 0x05,
    SASSerialSCSIProtocol                     = 0x06,
    AutomationDriveInterfaceTransportProtocol = 0x07,
    ATAttachmentInterface                     = 0x08,
    USBAttachedSCSI                           = 0x09,
    SCSIOverPCIExpressArchitecture            = 0x0A,
    ...
};

// [SPC-4] 7.6.4 TransportID identifiers
type TransportId
{
    byte FormatCode with BinaryEncoding{Width = 2};
    byte Reserved with BinaryEncoding{Width = 2};
    ProtocolIdentifier ProtocolIdentifier with BinaryEncoding{Width = 4};
    ([|FormatCode == 0x00 && ProtocolIdentifier == 0x00|] FibreChannelTransportIdData |
     [|FormatCode == 0x00 && ProtocolIdentifier == 0x01|] ParallelSCSIBusTransportIdData |
     [|FormatCode == 0x00 && ProtocolIdentifier == 0x03|] IEEE1394TransportIdData |
     [|FormatCode == 0x00 && ProtocolIdentifier == 0x04|] RDMATransportIdData |
     [|FormatCode == 0x00 && ProtocolIdentifier == 0x05|] iSCSIInitiatorDeviceTransportIdData |
     [|FormatCode == 0x01 && ProtocolIdentifier == 0x05|] iSCSIInitiatorPortTransportIdData |
     [|FormatCode == 0x00 && ProtocolIdentifier == 0x06|] SASSerialSCSIProtocolTransportIdData |
     [|FormatCode == 0x00 && ProtocolIdentifier == 0x0A|] SOPTransportIdData |
     binary) SCSITransportProtocolSpecificData;
}

type FibreChannelTransportIdData
{
    array<byte> Reserved1 with BinaryEncoding{Length = 7};
    binary NPortName with BinaryEncoding{Length = 8}, DisplayInfo{ToText = DecodeOctetStringAsUTF8};
    // string NPortName with BinaryEncoding {TextEncoding = TextEncoding.UTF8, Length = 8};
    ulong Reserved2;
}

type ParallelSCSIBusTransportIdData
{
    byte Reserved1;
    ushort SCSIAddress;
    ushort Obsolete;
    ushort RelativeTargetPortIdentifier;
    array<byte> Reserved2 with BinaryEncoding{Length = 16};
}

type IEEE1394TransportIdData
{
    array<byte> Reserved1 with BinaryEncoding{Length = 7};
    string EUI64Name with BinaryEncoding{TextEncoding = TextEncoding.ASCII, Length = 8};
    ulong Reserved2;
}

type RDMATransportIdData
{
    array<byte> Reserved1 with BinaryEncoding{Length = 7};
    array<byte> InitiatorPortIdentifier with BinaryEncoding{Length = 16};
}

type iSCSIInitiatorDeviceTransportIdData
{
    byte Reserved;
    ushort AdditionalLength;
    binary iSCSIName with BinaryEncoding{Length = AdditionalLength}, DisplayInfo{ToText = DecodeOctetStringAsUTF8};
    // string iSCSIName with BinaryEncoding{TextEncoding = TextEncoding.UTF8, Length = AdditionalLength};
}

type iSCSIInitiatorPortTransportIdData
{
    byte Reserved;
    ushort AdditionalLength;
    string iSCSIName with BinaryEncoding{TextEncoding = TextEncoding.UTF8, TextTerminator = "\0"};
    (string where value == ",i,0x") Separator with BinaryEncoding{TextEncoding = TextEncoding.ASCII};
    string iSCSIInitiatorSessionId with BinaryEncoding{TextEncoding = TextEncoding.ASCII, TextTerminator = "\0"};
}

type SASSerialSCSIProtocolTransportIdData
{
    array<byte> Reserved1 with BinaryEncoding{Length = 3};
    ulong SASAddress;
    array<byte> Reserved2 with BinaryEncoding{Length = 12};
}

type SOPTransportIdData
{
    byte Reserved1;
    ushort RoutingId;
    array<byte> Reserved2 with BinaryEncoding{Length = 20};
}

// [SPC-4] 7.7.1.3 Supported security protocols list description - Security Protocol (00h) Security Protocol Specific (0000h)
type SupportedSecurityProtocolsSecurityProtocolInParameterData
{
    array<byte> Reserved with BinaryEncoding{Length = 6};
    ushort SupportedSecurityProtocolListLength;
    array<SecurityProtocol> SupportedSecurityProtocolList with BinaryEncoding{Length = SupportedSecurityProtocolListLength};
    optional binary Pad;
}

// [SPC-4] 7.7.1.4 Certificate data description - Security Protocol (00h) Security Protocol Specific (0001h)
type CertificateDataSecurityProtocolInParameterData
{
    ushort Reserved;
    ushort CertificateLength;
    binary Certificate with BinaryEncoding{Length = CertificateLength};
    optional binary Pad;
}

// [SPC-4] 7.7.1.5 Security compliance information description - Security Protocol (00h) Security Protocol Specific (0002h)
type SecurityComplianceInformationSecurityProtocolInParameterData
{
    uint SecurityComplianceInformationLength;
    array<ComplianceDescriptor> ComplianceDescriptors with BinaryEncoding{WidthForComposedType = SecurityComplianceInformationLength * 8 as int};
    optional binary Pad;
}

type ComplianceDescriptor
{
    ushort ComplianceDescriptorType;
    ushort Reserved;
    uint ComplianceDescriptorLength;
    ([|ComplianceDescriptorType == 0x0001|] FIPS140ComplianceDescriptor | 
     binary) DescriptorSpecificInformation with BinaryEncoding{Length = ComplianceDescriptorLength};
}

type FIPS140ComplianceDescriptor
{
    string Revision with BinaryEncoding{TextEncoding = TextEncoding.ASCII, Length = 1};
    string OverallSecurityLevel with BinaryEncoding{TextEncoding = TextEncoding.ASCII, Length = 1};
    array<byte> Reserved with BinaryEncoding{Length = 6};
    string HardwareVersion with BinaryEncoding{WidthForComposedType = 128 * 8, TextEncoding = TextEncoding.UTF8};
    string Version with BinaryEncoding{WidthForComposedType = 128 * 8, TextEncoding = TextEncoding.UTF8};
    string Module with BinaryEncoding{WidthForComposedType = 256 * 8, TextEncoding = TextEncoding.UTF8};
}

// [SPC-4] 7.7.2.3 SA creation capabilities parameter data formats - Security Protocol (40h)
// Security Protocol Specific (0000h)
type SupportedDeviceServerCapabilitiesFormatsParameterData
{
    uint ParameterDataLength;
    array<SecurityProtocolSpecificForSACreationCapabilites> SupportedCapabilitiesParameterDataFormats with BinaryEncoding{Length = ParameterDataLength};
}

pattern SecurityProtocolSpecificForSACreationCapabilites = enum ushort
{
    SupportedDeviceServerCapabilities  = 0x0000,
    Ikev2ScsiDeviceServerCapabilities  = 0x0101,
    ...
};

// Security Protocol Specific (0101h)
type Ikev2ScsiDeviceServerCapabilitiesParameterData
{
    uint ParameterDataLength;
    Ikev2ScsiSaCreationCapabilitiesPayload Ikev2ScsiSaCreationCapabilitiesPayload;
}

// [SPC-4] 7.7.3.4 IKEv2-SCSI parameter data format - Security Protocol In  & Security Protocol Out
type Ikev2ScsiSecurityParameterData
{
    uint Restricted1;
    uint IkeSaApplicationClientSai;
    uint Restricted2;
    uint IkeSaDeviceServerSai;
    byte NextPayload;
    byte MajorVersion with BinaryEncoding{Width = 4};
    byte MinorVersion with BinaryEncoding{Width = 4};
    byte ExchangeType;
    byte Reserved1 with BinaryEncoding{Width = 3};
    byte INTTR with BinaryEncoding{Width = 1};
    byte Version with BinaryEncoding{Width = 1};
    byte RSPNS with BinaryEncoding{Width = 1};
    byte Reserved2 with BinaryEncoding{Width = 2};
    uint MessageId;
    uint IkeLength;
    array<Ikev2ScsiPayload> Ikev2ScsiPayloads;
}

// [SPC-4] 7.7.3.5 IKEv2-SCSI payloads
type Ikev2ScsiPayload
{
    byte NextPayload;
    bool CRIT with BinaryEncoding{Width = 1};
    byte Reserved with BinaryEncoding{Width = 7};
    ushort IkePayloadLength;
    binary Ikev2ScsiPayloadSpecificData with BinaryEncoding{Length = (IkePayloadLength >= 4) ? (IkePayloadLength - 4) : 0};
}

// [SPC-4] 7.7.3.5.12 IKEv2-SCSI SA Creation Capabilities payload
type Ikev2ScsiSaCreationCapabilitiesPayload
{
    (byte where value == 0x00) NextPayload;
    bool CRIT with BinaryEncoding{Width = 1};
    byte Reserved1 with BinaryEncoding{Width = 7};
    ushort IkePayloadLength;
    uint Reserved2 with BinaryEncoding{Width = 24};
    byte NumberOfAlgorithmDescriptors;
    array<Ikev2ScsiCryptographicAlgorithmDescriptor> Ikev2ScsiCryptographicAlgorithmDescriptor with BinaryEncoding{Length = NumberOfAlgorithmDescriptors};
}

// [SPC-4] 7.7.3.6 IKEv2-SCSI cryptographic algorithm descriptors
type Ikev2ScsiCryptographicAlgorithmDescriptor
{
    AlgorithmType AlgorithmType;
    byte Reserved;
    ushort IkeDescriptorLength;
    uint AlgorithmIdentifier;
    uint AlgorithmAttributes;
}

pattern AlgorithmType = enum byte
{
    ENCR        = 0x01,
    PRF         = 0x02,
    INTEG       = 0x03,
    DH          = 0x04,
    SA_AUTH_OUT = 0xF9,
    SA_AUTH_IN  = 0xFA,
    ...
};

// [SPC-4] 7.7.4.3 CbCS SECURITY PROTOCOL IN parameter data - Security Protocol (07h)
type CbCsSecurityProtocolInParameterData
{
    ushort PageCode;
    ushort PageLength;
    ([|PageCode == 0x0000|] SupportedCbCsSecurityProtocolInPagesCbCsPageData |
     [|PageCode == 0x0001|] SupportedCbCsSecurityProtocolOutPagesCbCsPageData |
     [|PageCode == 0x0002|] UnchangeableCbCbParametersCbCsPageData |
     [|PageCode == 0x003F|] SecurityTokenCbCsPageData |
     [|PageCode == 0x0040|] CurrentCbCsParametersCbCsPageData |
     [|PageCode == 0xD010|] SetMasterKeySeedExchangeCbCsPageForInData |
     binary) CbCsSecurityProtocolInData with BinaryEncoding{Length = PageLength, WidthForComposedType = PageLength * 8};
}

// 7.7.4.3.1 Suppoted CbCS SECURITY PROTOCOL IN Pages CbCS page - Security Protocol Specific (0000h)
type SupportedCbCsSecurityProtocolInPagesCbCsPageData
{
   array<SecurityProtocolSpecificForCbCsSecurityProtocolIn> SupportedCbCsSecurityProtocolInPageList;
}

pattern SecurityProtocolSpecificForCbCsSecurityProtocolIn = enum ushort
{
    SupportedCbCsSecurityProtocolInPages      = 0x0000,
    SupportedCbCsSecurityProtocolOutPages     = 0x0001,
    UnchangeableCbCsParameters                = 0x0002,
    SecurityToken                             = 0x003F,
    CurrentCbCsParameters                     = 0x0040,
    SetMasterKeySeedExchange                  = 0xD010,
    ...
};

// 7.7.4.3.2 Suppoted CbCS SECURITY PROTOCOL OUT Pages CbCS page - Security Protocol Specific (0001h)
type SupportedCbCsSecurityProtocolOutPagesCbCsPageData
{
    array<SecurityProtocolSpecificForCbCsSecurityProtocolOut> SupportedCbCsSecurityProtocolOutPageList;
}

pattern SecurityProtocolSpecificForCbCsSecurityProtocolOut = enum ushort
{
    SetPolicyAccessTag          = 0x0041,
    SetMinimumCbCsMethod        = 0x0042,
    InvalidateKey               = 0xD000,
    SetKey                      = 0xD001,
    SetMasterKeySeeExchange     = 0xD010,
    SetMasterKeyChangeMasterKey = 0xD011,
    ...
};

// 7.7.4.3.3 Unchangeable CbCS Parameters CbCS page - Security Protocol Specific (0002h)
type UnchangeableCbCbParametersCbCsPageData
{
    byte KeysSupport with BinaryEncoding{Width = 2};
    byte MinCbCsMethodSup with BinaryEncoding{Width = 2};
    ushort Reserved1 with BinaryEncoding{Width = 12};
    ushort SupportedIntegrityCheckValueAlgorithmListLength;
    array<uint> SupportedIntegrityCheckValueAlgorithmsList with BinaryEncoding{Length = (SupportedIntegrityCheckValueAlgorithmListLength / 4)};
    ushort Reserved2;
    ushort SupportedDHAlgorithmListLength;
    array<uint> SupportedDHAlgorithmsList with BinaryEncoding{Length = (SupportedDHAlgorithmListLength / 4)};
    ushort SupportedCbCsMethodsListLength;
    array<byte> SupportedCbCsMethod with BinaryEncoding{Length = SupportedCbCsMethodsListLength};
}

// [SPC-4] 7.7.4.3.4 Security Token CbCS page
type SecurityTokenCbCsPageData
{
    binary SecurityToken;
}

// [SPC-4] 7.7.4.3.5 Current CbCS Parameters CbCS page
type CurrentCbCsParametersCbCsPageData
{
    uint Reserved1 with BinaryEncoding{Width = 24};
    byte MinimumAllowedCbCsMethod;
    uint PolicyAccessTag;
    uint Reserved2;
    ulong MasterKeyIdentifier;
    array<ulong> WorkingKeyIdentifiers with BinaryEncoding{Length = 16};
    ulong Clock with BinaryEncoding{Width = 48};
}

// [SPC-4] 7.7.4.3.6 Set Master Key - Seed Exchange CbCS page
type SetMasterKeySeedExchangeCbCsPageForInData
{
    binary DHData;
}

// [SPC-4] 7.7.4.5 CbCS SECURITY PROTOCOL OUT parameter data - Security Protocol (07h)
type CbCsSecurityProtocolOutParameterData
{
    ushort PageCode;
    ushort PageLength;
    ([|PageCode == 0x0041|] SetPolicyAccessTagCbCsPageData |
     [|PageCode == 0x0042|] SetMinimumCbCsMethodCbCsPageData |
     [|PageCode == 0xD000|] InvalidateKeyCbCsPageData |
     [|PageCode == 0xD001|] SetKeyCbCsPageData |
     [|PageCode == 0xD010|] SetMasterKeySeedExchangeCbCsPageForOutData |
     [|PageCode == 0xD011|] SetMasterKeyChangeMasterKeyCbCsPageForOutData |
     binary) CbCsSecurityProtocolOutData with BinaryEncoding{Length = PageLength, WidthForComposedType = PageLength * 8};
}

// [SPC-4] 7.7.4.5.1 Set Policy Access Tag CbCS page
type SetPolicyAccessTagCbCsPageData
{
    uint PolicyAccessTag;
}

// [SPC-4] 7.7.4.5.2 Set Minimum CbCS Method CbCS page
type SetMinimumCbCsMethodCbCsPageData
{
    byte Reserved;
    byte MinimumAllowedCbCsMethod;
}

// [SPC-4] 7.7.4.5.3 Invalidate Key CbCS page
type InvalidateKeyCbCsPageData
{
    uint Reserved with BinaryEncoding{Width = 28};
    byte KeyVersion with BinaryEncoding{Width = 4};
}

// [SPC-4] 7.7.4.5.4 Set Key CbCS page
type SetKeyCbCsPageData
{
    uint Reserved with BinaryEncoding{Width = 28};
    byte KeyVersion with BinaryEncoding{Width = 4};
    ulong KeyIdentifier;
    binary Seed with BinaryEncoding{Length = 20};
}

// [SPC-4] 7.7.4.5.5 Set Master Key - Seed Exchange CbCS page
type SetMasterKeySeedExchangeCbCsPageForOutData
{
    uint DHAlgorithm;
    uint DHDataLength;
    binary DHData with BinaryEncoding{Length = DHDataLength};
}

// [SPC-4] 7.7.4.5.6 Set Master Key - Change Master Key CbCS page
type SetMasterKeyChangeMasterKeyCbCsPageForOutData
{
    uint Reserved;
    ulong KeyIdentifier;
    uint ApplicationClientDHDataLength;
    binary ApplicationClientDHData with BinaryEncoding{Length = ApplicationClientDHDataLength};
    uint DeviceServerDHDataLength;
    binary DeviceServerDHData with BinaryEncoding{Length = DeviceServerDHDataLength};
}

// [SPC-4] 7.8.2 VPD page format and page codes for all device types
type VPDPage
{
    byte PeripheralQualifier with BinaryEncoding{Width = 3};
    byte PeripheralDeviceType with BinaryEncoding{Width = 5};
    VPDPageCode PageCode;
    ushort PageLength;
    ([|PeripheralDeviceType == 0x00 && PageCode == 0xB1|] BlockDeviceCharacteristicVPDPageParameter |
     [|PeripheralDeviceType == 0x00 && PageCode == 0xB0|] BlockLimitsVPDPageParameter |
     [|PeripheralDeviceType == 0x00 && PageCode == 0xB2|] LogicalBlockProvisioningVPDPageParameter |
     [|PeripheralDeviceType == 0x00 && PageCode == 0xB3|] ReferralsVPDPageParameter |
     [|PageCode >= 0x01 && PageCode <= 0x7F|] AsciiInformationVPDPageParameter |
     [|PageCode == 0x8C|] CFAProfileInformationVPDPageParameter |
     [|PageCode == 0x8B|] DeviceConstituentsVPDPageParameter |
     [|PageCode == 0x83|] DeviceIdentificationVPDPageParameter |
     [|PageCode == 0x86|] ExtendedInquiryDataVPDPageParameter |
     [|PageCode == 0x85|] ManagementNetworkAddressesVPDPageParameter |
     [|PageCode == 0x87|] ModePagePolicyVPDPageParameter |
     [|PageCode == 0x8A|] PowerConditionVPDPageParameter |
     [|PageCode == 0x8D|] PowerConsumptionVPDPageParameter |
     [|PageCode == 0x90|] ProtocolSpecificLogicalUnitInformationVPDPageParameter |
     [|PageCode == 0x91|] ProtocolSpecificPortInformationVPDPageParameter |
     [|PageCode == 0x88|] SCSIPortsVPDPageParameter |
     [|PageCode == 0x84|] SoftwareInterfaceIdentificationVPDPageParameter |
     [|PageCode == 0x00|] SupportedVPDPagesVPDPageParameter |
     [|PageCode == 0x8F|] ThirdPartyCopyVPDPageParameter |
     [|PageCode == 0x80|] UnitSerialNumberVPDPageParameter |
     binary) VPDParameters with BinaryEncoding{Length = PageLength, WidthForComposedType = PageLength * 8};
     
    override string ToString()
    {
        if (PeripheralDeviceType == 0x00)
        {
            switch (PageCode)
            {
                case 0xB1 =>
                    return "Block Device Characteristic VPD Page";
                case 0xB0 =>
                    return "Block Limits VPD Page";
                case 0xB2 =>
                    return "Logical Block Provisioning VPD Page";
                case 0xB3 =>
                    return "Referrals VPD Page";
                default =>
            }
        }
        if (PageCode >= 0x01 && PageCode <= 0x7F)
        {
            return "ASCII Information VPD Page";
        }
        switch (PageCode)
        {
            case 0x8C =>
                return "CFA Profile Information VPD Page";
            case 0x8B =>
                return "Device Constituents VPD Page";
            case 0x83 =>
                return "Device Identification VPD Page";
            case 0x86 =>
                return "Extended Inquiry Data VPD Page";
            case 0x85 =>
                return "Management Network Addresses VPD Page";
            case 0x87 =>
                return "Mode Page Policy VPD Page";
            case 0x8A =>
                return "Power Condition VPD Page";
            case 0x8D =>
                return "Power Consumption VPD Page";
            case 0x90 =>
                return "Protocol Specific Logical Unit Information VPD Page";
            case 0x91 =>
                return "Protocol Specific Port Information VPD Page";
            case 0x88 =>
                return "SCSI Ports VPD Page";
            case 0x84 =>
                return "Software Interface Identification VPD Page";
            case 0x00 =>
                return "Supported VPD Pages VPD Page";
            case 0x8F =>
                return "Third-party Copy VPD Page";
            case 0x80 =>
                return "Unit Serial Number VPD Page";
            default =>
                return "Unknown VPD Page, PageCode: " + Utility.DecToHexFormat(PageCode);
        }
    }
}

pattern VPDPageCode = enum byte
{
    ATAInformation                          = 0x89,
    CFAProfileInformation                   = 0x8C,
    DeviceConstituents                      = 0x8B,
    DeviceIdentification                    = 0x83,
    ExtendedInquiryData                     = 0x86,
    ManagementNetworkAddresses              = 0x85,
    ModePagePolicy                          = 0x87,
    PowerCondition                          = 0x8A,
    PowerConsumption                        = 0x8D,
    ProtocolSpecificLogicalUnitInformation  = 0x90,
    ProtocolSpecificPortInformation         = 0x91,
    SCSIPorts                               = 0x88,
    SoftwareInterfaceIdentification         = 0x84,
    SupportedVPDPages                       = 0x00,
    ThirdPartyCopy                          = 0x8F,
    UnitSerialNumber                        = 0x80,
    ...
};

// [SPC-4] 7.8.3 ASCII Information VPD page
type AsciiInformationVPDPageParameter
{
    byte AsciiLength;
    string AsciiInformation with BinaryEncoding{Length = AsciiLength, TextEncoding = TextEncoding.ASCII};
    binary VendorSpecificInformation;
}

// [SPC-4] 7.8.4 CFA Profile Information VPD page
type CFAProfileInformationVPDPageParameter
{
    array<CFAProfileDescriptor> CFAProfileDescriptorList;
}

type CFAProfileDescriptor
{
    byte CFAProfileSupported;
    byte Reserved;
    ushort SequentialWriteDataSize;
}

// [SPC-4] 7.8.5 Device Constituents VPD page
type DeviceConstituentsVPDPageParameter
{
    array<ConstituentDescriptor> ConstituentDescriptorList;
}

type ConstituentDescriptor
{
    ConstituentType ConstituentType;
    byte ConstituentDeviceType;
    byte Reserved1;
    string T10VendorIdentification with BinaryEncoding{TextEncoding = TextEncoding.ASCII, Length = 8};
    string ProductIdentification with BinaryEncoding{TextEncoding = TextEncoding.ASCII, Length = 16};
    string ProductRevisionLevel with BinaryEncoding{TextEncoding = TextEncoding.ASCII, Length = 4};
    ushort Reserved;
    ushort ConstituentDescriptorLength;
    ([|ConstituentType == 0x0001|] array<VirtualTapeLibraryConstituentTypeSpecificDescriptor> |
     [|ConstituentType == 0x0002|] array<VirtualTapeDriveConstituentTypeSpecifcDescriptor> |
     [|ConstituentType == 0x0003|] array<DirectAccessBlockDeviceConstituentTypeSpecificDescriptor> |
     binary) ConstituentTypeSpecificDescriptorList with BinaryEncoding{Length = ConstituentDescriptorLength};
}

pattern ConstituentType = enum ushort
{
    VirtualTapeLibrary = 0x0001,
    VirtualTapeDrive = 0x0002,
    DirectAccessBlockDevice = 0x0003,
    ...
};

type VirtualTapeLibraryConstituentTypeSpecificDescriptor
{
    byte VirtualTapeLibrarySpecificType;
    ushort Reserved;
    byte AdditionalLength;
    binary VirtualTapeLibrarySpecficData with BinaryEncoding{Length = AdditionalLength};
}

type VirtualTapeDriveConstituentTypeSpecifcDescriptor
{
    byte VirtualTapeDriveSpecificType;
    ushort Reserved;
    byte AdditionalLength;
    binary VirtualTapeDriveSpecficData with BinaryEncoding{Length = AdditionalLength};
}

type DirectAccessBlockDeviceConstituentTypeSpecificDescriptor
{
    byte DirectAccessBlockDeviceSpecificType;
    ushort Reserved;
    byte AdditionalLength;
    binary DirectAccessBlockDeviceSpecficData with BinaryEncoding{Length = AdditionalLength};
}

// [SPC-4] 7.8.6 Device Identification VPD page
type DeviceIdentificationVPDPageParameter
{
    array<DesignationDescriptor> DesignationDescriptorList;
}

type DesignationDescriptor
{
    ProtocolIdentifier ProtocolIdentifier with BinaryEncoding{Width = 4};
    CodeSetType CodeSet with BinaryEncoding{Width = 4};
    bool PIV with BinaryEncoding{Width = 1};
    byte Reserved1 with BinaryEncoding{Width = 1};
    byte Association with BinaryEncoding{Width = 2};
    DesignatorType DesignatorType with BinaryEncoding{Width = 4};
    byte Reserved2;
    byte DesignatorLength;
    ([|DesignatorType == 0x01|] T10VendorIdBasedDesignator | 
     [|DesignatorType == 0x02 && DesignatorType == 0x08|] EUI64Designator |
     [|DesignatorType == 0x02 && DesignatorType == 0x0C|] EUI64Based12ByteDesignator |
     [|DesignatorType == 0x02 && DesignatorType == 0x10|] EUI64Based16ByteDesignator |
     [|DesignatorType == 0x03|] NAADesignator |
     [|DesignatorType == 0x04 && Association == 0x01|] RelativeTargetPortDesignator |
     [|DesignatorType == 0x05 && Association == 0x01|] TargetPortGroupDesignator |
     [|DesignatorType == 0x06 && Association == 0x00|] LogicalUintGroupDesignator |
     [|DesignatorType == 0x07 && Association == 0x00|] MD5LogicalUnitDesignator |
     [|DesignatorType == 0x08|] SCSINameStringDesignator[DesignatorLength] |
     [|DesignatorType == 0x09 && ProtocolIdentifier == 0x09|] USBTargetPortIdentifierDesignator |
     [|DesignatorType == 0x09 && ProtocolIdentifier == 0x0A|] PCIExpressRoutingIdDesignator |
     binary) Designator with BinaryEncoding{Length = DesignatorLength, WidthForComposedType = DesignatorLength * 8};
}

pattern DesignatorType = enum byte
{
    VendorSpecific                 = 0x00,
    T10VendorIdBased               = 0x01,
    EUI64Based                     = 0x02,
    NAA                            = 0x03,
    RelativeTargetPortIdentifier   = 0x04,
    TargetPortGroup                = 0x05,
    LogicalUintGroup               = 0x06,
    MD5LogicalUintIdentifier       = 0x07,
    SCSINameString                 = 0x08,
    ProtocolSpecificPortIdentifier = 0x09,
    ...
};

type T10VendorIdBasedDesignator
{
    string T10VendorIdentification with BinaryEncoding{Length = 8, TextEncoding = TextEncoding.ASCII};
    binary VendorSpecificIdentifier;
}

type EUI64Designator
{
    uint IEEECompanyId with BinaryEncoding{Width = 24};
    binary VendorSpecificExtensionIdentifier with BinaryEncoding{Length = 5};
}

type EUI64Based12ByteDesignator
{
    uint IEEECompanyId with BinaryEncoding{Width = 24};
    binary VendorSpecificExtensionIdentifier with BinaryEncoding{Length = 5};
    uint DirectoryId;
}

type EUI64Based16ByteDesignator
{
    ulong IdentifierExtension;
    uint IEEECompanyId with BinaryEncoding{Width = 24};
    binary VendorSpecificExtensionIdentifier with BinaryEncoding{Length = 5};
}

type NAADesignator
{
    byte NAA with BinaryEncoding{Width = 4};
    ([|NAA == 0x02|] IEEEExtendedDesignatorData |
     [|NAA == 0x03|] LocallyAssignedDesignatorData |
     [|NAA == 0x05|] IEEERegisteredDesignatorData |
     [|NAA == 0x06|] IEEERegisteredExtendedDesignatorData |
     binary) NAASpecificData;
}

type IEEEExtendedDesignatorData
{
    ushort VendorSpecificIdentifierA with BinaryEncoding{Width = 12};
    uint IEEECompanyId with BinaryEncoding{Width = 24};
    uint VendorSpecificIdentifierB with BinaryEncoding{Width = 24};
}

type LocallyAssignedDesignatorData
{
    ulong LocallyAdministeredValue with BinaryEncoding{Width = 60};
}

type IEEERegisteredDesignatorData
{
    uint IEEECompanyId with BinaryEncoding{Width = 24};
    ulong VendorSpecificIdentifier with BinaryEncoding{Width = 36};
}

type IEEERegisteredExtendedDesignatorData
{
    uint IEEECompanyId with BinaryEncoding{Width = 24};
    ulong VendorSpecificIdentifier with BinaryEncoding{Width = 36};
    ulong VendorSpecificIdentifierExtension;
}

type RelativeTargetPortDesignator
{
    ushort Reserved;
    ushort RelativeTargetPortIdentifier;
}

type TargetPortGroupDesignator
{
    ushort Reserved;
    ushort TargetPortGroup;
}

type LogicalUintGroupDesignator
{
    ushort Reserved;
    ushort LogicalUintGroup;
}

type MD5LogicalUnitDesignator
{
    binary MD5LogicalUnitIdentifier with BinaryEncoding{Length = 16};
}

type SCSINameStringDesignator[byte Len]
{
    binary SCSINameString with BinaryEncoding{Length = Len}, DisplayInfo{ToText = DecodeOctetStringAsUTF8};
    // string SCSINameString with BinaryEncoding{TextEncoding = TextEncoding.UTF8, Length = Len};
}

type USBTargetPortIdentifierDesignator
{
    byte Reserved1 with BinaryEncoding{Width = 1};
    byte DeviceAddress with BinaryEncoding{Width = 7};
    byte Reserved2;
    byte InterfaceNumber;
    byte Reserved3;
}

type PCIExpressRoutingIdDesignator
{
    ushort RoutingId;
    binary Reserved;
}

// [SPC-4] 7.8.7 Extended INQUIRY Data VPD page
type ExtendedInquiryDataVPDPageParameter
{
    byte ActivateMicrocode with BinaryEncoding{Width = 2};
    byte SPT with BinaryEncoding{Width = 3};
    bool GRD_CHK with BinaryEncoding{Width = 1};
    bool APP_CHK with BinaryEncoding{Width = 1};
    bool REF_CHK with BinaryEncoding{Width = 1};
    byte Reserved1 with BinaryEncoding{Width = 2};
    bool UASK_SUP with BinaryEncoding{Width = 1};
    bool GROUP_SUP with BinaryEncoding{Width = 1};
    bool PRIPR_SUP with BinaryEncoding{Width = 1};
    bool HEADSUP with BinaryEncoding{Width = 1};
    bool ORDSUP with BinaryEncoding{Width = 1};
    bool SIMPSUP with BinaryEncoding{Width = 1};
    byte Reserved2 with BinaryEncoding{Width = 4};
    bool WU_SUP with BinaryEncoding{Width = 1};
    bool CRD_SUP with BinaryEncoding{Width = 1};
    bool NV_SUP with BinaryEncoding{Width = 1};
    bool V_SUP with BinaryEncoding{Width = 1};
    byte Reserved3 with BinaryEncoding{Width = 3};
    bool P_I_I_SUP with BinaryEncoding{Width = 1};
    byte Reserved4 with BinaryEncoding{Width = 3};
    bool LUICLR with BinaryEncoding{Width = 1};
    byte Reserved5 with BinaryEncoding{Width = 3};
    bool R_SUP with BinaryEncoding{Width = 1};
    byte Reserved6 with BinaryEncoding{Width = 3};
    bool CBCS with BinaryEncoding{Width = 1};
    byte Reserved7 with BinaryEncoding{Width = 4};
    byte MultiITNexusMicrocodeDownload with BinaryEncoding{Width = 4};
    ushort ExtendedSelfTestCompletionMinutes;
    bool POA_SUP with BinaryEncoding{Width = 1};
    bool HRA_SUP with BinaryEncoding{Width = 1};
    bool VSA_SUP with BinaryEncoding{Width = 1};
    byte Reserved8 with BinaryEncoding{Width = 5};
    byte MaximumSupportedSenseDataLength;
    array<byte> Reserved9 with BinaryEncoding{Length = 50};
}

// [SPC-4] 7.8.8 Management Network Addresses VPD page
type ManagementNetworkAddressesVPDPageParameter
{
    array<NetworkServicesDescriptor> NetworkServicesDescriptorList;
}

type NetworkServicesDescriptor
{
    byte Reserved1 with BinaryEncoding{Width = 1};
    byte Association with BinaryEncoding{Width = 2};
    ServiceType ServiceType with BinaryEncoding{Width = 5};
    byte Reserved2;
    ushort NetworkAddressLength;
    binary NetworkAddress with BinaryEncoding{Length = NetworkAddressLength}, DisplayInfo{ToText = DecodeOctetStringAsUTF8};
    // string NetworkAddress with BinaryEncoding{TextEncoding = TextEncoding.UTF8, Length = NetworkAddressLength};
}

pattern ServiceType = enum byte
{
    Unspecified                        = 0x00,
    StorageConfigurationService        = 0x01,
    Diagnostics                        = 0x02,
    Status                             = 0x03,
    Logging                            = 0x04,
    CodeDownload                       = 0x05,
    CopyService                        = 0x06,
    AdministrativeConfigurationService = 0x07,
    ...
};

// [SPC-4] 7.8.9 Mode Page Policy VPD page
type ModePagePolicyVPDPageParameter
{
    array<ModePagePolicyDescriptor> ModePagePolicyDescriptorList;
}

type ModePagePolicyDescriptor
{
    byte Reserved1 with BinaryEncoding{Width = 2};
    byte PolicyPageCode with BinaryEncoding{Width = 6};
    byte PolicySubpageCode;
    bool MLUS with BinaryEncoding{Width = 1};
    byte Reserved2 with BinaryEncoding{Width = 5};
    byte ModePagePolicy with BinaryEncoding{Width = 2};
    byte Reserved3;
}

// [SPC-4] 7.8.10 Power Condition VPD page
type PowerConditionVPDPageParameter
{
    byte Reserved1 with BinaryEncoding{Width = 6};
    bool STANDBY_Y with BinaryEncoding{Width = 1};
    bool STANDBY_Z with BinaryEncoding{Width = 1};
    byte Reserved2 with BinaryEncoding{Width = 5};
    bool IDLE_C with BinaryEncoding{Width = 1};
    bool IDLE_B with BinaryEncoding{Width = 1};
    bool IDLE_A with BinaryEncoding{Width = 1};
    ushort StoppedConditionRecoveryTime;
    ushort StandbyZConditionRecoveryTime;
    ushort StandbyYConditionRecoveryTime;
    ushort IdleAConditionRecoveryTime;
    ushort IdleBConditionRecoveryTime;
    ushort IdleCConditionRecoveryTime;
}

// [SPC-4] 7.8.11 Power Consumption VPD page
type PowerConsumptionVPDPageParameter
{
    array<PowerConsumptionDescriptor> PowerConsumptionDescriptorList;
}

type PowerConsumptionDescriptor
{
    byte PowerConsumptionIdentifier;
    byte Reserved with BinaryEncoding{Width = 5};
    byte PowerConsumptionUnits with BinaryEncoding{Width = 3};
    ushort PowerConsumptionValue;
}

// [SPC-4] 7.8.12 Protocol Specific Logical Unit Information VPD page
type ProtocolSpecificLogicalUnitInformationVPDPageParameter
{
    array<LogicalUnitInformationDescriptor> LogicalUnitInformationDescriptorList;
}

type LogicalUnitInformationDescriptor
{
    ushort RelativePortIdentifier;
    byte Reserved1 with BinaryEncoding{Width = 4};
    ProtocolIdentifier ProtocolIdentifier with BinaryEncoding{Width = 4};
    uint Reserved2 with BinaryEncoding{Width = 24};
    ushort ProtocolSpecificDataLength;
    binary PerLogicalUnitSCSITransportProtocolSpecificData with BinaryEncoding{Length = ProtocolSpecificDataLength};
}

// [SPC-4] 7.8.13 Protocol Specific Port Information VPD page
type ProtocolSpecificPortInformationVPDPageParameter
{
    array<PortInformationDescriptor> PortInformationDescriptorList;
}

type PortInformationDescriptor
{
    ushort RelativePortIdentifier;
    byte Reserved1 with BinaryEncoding{Width = 4};
    ProtocolIdentifier ProtocolIdentifier with BinaryEncoding{Width = 4};
    uint Reserved2 with BinaryEncoding{Width = 24};
    ushort ProtocolSpecificDataLength;
    binary SharedSCSITransportProtocolSpecificData with BinaryEncoding{Length = ProtocolSpecificDataLength};
}

// [SPC-4] 7.8.14 SCSI Ports VPD page
type SCSIPortsVPDPageParameter
{
    array<SCSIPortDesignationDescriptor> SCSIPortDesignationDescriptorList;
}

type SCSIPortDesignationDescriptor
{
    ushort Reserved1;
    ushort RelativePortIdentifier;
    ushort Reserved2;
    ushort InitiatorPortTransortIdLength;
    array<byte> InitiatorPortTransportId with BinaryEncoding{Length = InitiatorPortTransortIdLength};
    ushort Reserved3;
    ushort TargetPortDescriptorsLength;
    array<DesignationDescriptor> TargetPortDescriptorList with BinaryEncoding{WidthForComposedType = TargetPortDescriptorsLength * 8};
}

// [SPC-4] 7.8.15 Software Interface Identification VPD page
type SoftwareInterfaceIdentificationVPDPageParameter
{
    array<SoftwareInterfaceIdentifier> SoftwareInterfaceIdentifierList;
}

type SoftwareInterfaceIdentifier
{
    uint IEEECompanyId with BinaryEncoding{Width = 24};
    uint VendorSpecificExtensionIdentifier with BinaryEncoding{Width = 24};
}

// [SPC-4] 7.8.16 Supported VPD Pages VPD page
type SupportedVPDPagesVPDPageParameter
{
    array<VPDPageCode> SupportedVPDPageList;
}

// [SPC-4] 7.8.17 Third-party Copy VPD page
type ThirdPartyCopyVPDPageParameter
{
    array<ThirdPartyCopyDescriptor> ThirdPartyCopyDescriptors;
}

type ThirdPartyCopyDescriptor
{
    ThirdPartyCopyDescriptorType ThirdPartyCopyDescriptorType;
    ushort ThirdPartyCopyDescriptroLength;
    ([|ThirdPartyCopyDescriptorType == 0x0000|] BlockDeviceRODTokenLimitsDescriptorParameter | 
     [|ThirdPartyCopyDescriptorType == 0x0001|] SupportedCommandsThirdPartyCopyDescriptorParameter |
     [|ThirdPartyCopyDescriptorType == 0x0004|] ParameterDataThirdPartyCopyDescriptorParameter |
     [|ThirdPartyCopyDescriptorType == 0x0008|] SupportedDescriptorsThirdPartyCopyDescriptorParameter |
     [|ThirdPartyCopyDescriptorType == 0x000C|] SupportedCscdIdsThirdPartyCopyDescriptorParameter |
     [|ThirdPartyCopyDescriptorType == 0x0106|] RODTokenFeaturesThirdPartyCopyDescriptorParameter |
     [|ThirdPartyCopyDescriptorType == 0x0108|] SupportedRODTypesThirdPartyCopyDescriptorParameter |
     [|ThirdPartyCopyDescriptorType == 0x8001|] GeneralCopyOperationsThirdPartyCopyDescriptorParameter |
     [|ThirdPartyCopyDescriptorType == 0x9101|] StreamCopyOperationsThirdPartyCopyDescriptorParameter |
     [|ThirdPartyCopyDescriptorType == 0xC001|] HeldDataThirdPartyCopyDescriptorParameter |
     binary) ThirdPartyCopyParameters with BinaryEncoding{Length = ThirdPartyCopyDescriptroLength, WidthForComposedType = ThirdPartyCopyDescriptroLength * 8};
}

pattern ThirdPartyCopyDescriptorType = enum ushort
{
    BlockDeviceRODLimits               = 0x0000,
    SupportedCommands                  = 0x0001,
    ParameterData                      = 0x0004,
    SupportedDescriptors               = 0x0008,
    SupportedCscdIds                   = 0x000C,
    RODTokenFeatures                   = 0x0106,
    SupportedRODTokenAndRODTypes       = 0x0108,
    GeneralCopyOperations              = 0x8001,
    StreamCopyOperations               = 0x9101,
    HeldData                           = 0xC001,
    ...
};

// [SPC-4] 7.8.17.4 Supported Commands third-party copy descriptor
type SupportedCommandsThirdPartyCopyDescriptorParameter
{
    byte CommandsSupportedListLength;
    array<CommandSupportDescriptor> CommandsSupportedList with BinaryEncoding{WidthForComposedType = CommandsSupportedListLength * 8};
}

type CommandSupportDescriptor
{
    byte SupportedOperationCode;
    byte SupportedServiceActionsListLength;
    array<byte> SupportedServiceActionsList with BinaryEncoding{Length = SupportedServiceActionsListLength};
}

// [SPC-4] 7.8.15.4 Parameter Data third-party copy descriptor
type ParameterDataThirdPartyCopyDescriptorParameter
{
    uint Reserved1;
    ushort MaximumCscdDescriptorCount;
    ushort MaximumSegmentDescriptorCount;
    uint MaximumDescriptorListLength;
    uint MaximumInlineDataLength;
    array<byte> Reserved2 with BinaryEncoding{Length = 12};
}

// [SPC-4] 7.8.17.6 Supported Descriptos third-party copy descriptor
type SupportedDescriptorsThirdPartyCopyDescriptorParameter
{
    byte SupportedDescriptorListLength;
    array<byte> SupportedDescriptorTypeCodesList with BinaryEncoding{Length = SupportedDescriptorListLength};
    binary DescriptorPad;
}

// [SPC-4] 7.8.17.7 Supported CSCD IDs third-party copy descriptor
type SupportedCscdIdsThirdPartyCopyDescriptorParameter
{
    ushort SupportedCscdIdsListLength;
    array<byte> SupportedCscdIdList with BinaryEncoding{Length = SupportedCscdIdsListLength};
    optional binary DescriptorPad;
}

// [SPC-4] 7.8.17.8 ROD Token Features third-party copy descriptor
type RODTokenFeaturesThirdPartyCopyDescriptorParameter
{
    byte Reserved1 with BinaryEncoding{Width = 4};
    byte RemoteTokens with BinaryEncoding{Width = 4};
    array<byte> Reserved2 with BinaryEncoding{Length = 11};
    uint MinimumTokenLifetime;
    uint MaximumTokenLifetime;
    uint MaximumTokenInactivityTimeout;
    array<byte> Reserved3 with BinaryEncoding{Length = 18};
    ushort RODDeviceTypeSpecificFeaturesDescriptorsLength;
    array<RODDeviceTypeSpecificFeaturesDescriptor> RODDeviceTypeSpecificFeaturesDescriptors with BinaryEncoding{WidthForComposedType = RODDeviceTypeSpecificFeaturesDescriptorsLength * 8};
    optional binary DescriptorPad;
}

type RODDeviceTypeSpecificFeaturesDescriptor
{
    byte DescriptorFormat with BinaryEncoding{Width = 3};
    byte PeripheralDeviceType with BinaryEncoding{Width = 5};
    byte Reserved1;
    ushort DescriptorLength;
    ([|DescriptorFormat == 0x00 && PeripheralDeviceType == 0x00|] BlockRODDeviceTypeSpecificFeaturesDescriptorParameter |
     [|DescriptorFormat == 0x00 && PeripheralDeviceType == 0x01|] StreamRODDeviceTypeSpecificFeaturesDescriptorParameter |
     [|DescriptorFormat == 0x00 && PeripheralDeviceType == 0x03|] CopyManagerRODTokenDeviceSpecificFeaturesDescriptorParameter |
     binary) RODDeviceTypeSpecificFeaturesDescriptorParameter with BinaryEncoding{Length = DescriptorLength};
}

type BlockRODDeviceTypeSpecificFeaturesDescriptorParameter
{
    ushort Reserved2;
    ushort OptimalBlockRODLengthGranularity;
    ulong MaximumBytesInBlockROD;
    ulong OptimalBytesInBlockRODTransfer;
    ulong OptimalBytesToTokenPerSegment;
    ulong OptimalBytesFromTokenPerSegment;
    ulong Reserved3;
}

type StreamRODDeviceTypeSpecificFeaturesDescriptorParameter
{
    uint Reserved2;
    ulong MaximumBytesInStreamROD;
    ulong OptimalBytesInStreamRODTransfer;
    array<byte> Reserved3 with BinaryEncoding{Length = 24};
}

type CopyManagerRODTokenDeviceSpecificFeaturesDescriptorParameter
{
    uint Reserved2;
    ulong MaximumBytesInProcessorROD;
    ulong OptimalBytesInProcessorRodTransfer;
    array<byte> Reserved3 with BinaryEncoding{Length = 24};
}

// 7.8.17.9 Supported ROD Types third-party copy descriptor
type SupportedRODTypesThirdPartyCopyDescriptorParameter
{
    ushort Reserved;
    ushort RDPTypeDescriptorsLength;
    array<RODTypeDescriptor> RODTypeDescriptors with BinaryEncoding{WidthForComposedType = RDPTypeDescriptorsLength * 8};
    optional binary DescriptorPad;
}

type RODTypeDescriptor
{
    uint RODType;
    bool ECPY_INT with BinaryEncoding{Width = 1};
    byte Reserved1 with BinaryEncoding{Width = 5};
    bool TOKEN_IN with BinaryEncoding{Width = 1};
    bool TOKEN_OUT with BinaryEncoding{Width = 1};
    byte Reserved2;
    ushort PreferenceIndication;
    array<byte> Reserved3 with BinaryEncoding{Length = 56};
}

// [SPC-4] 7.8.17.10 General Copy Operations third-party copy descriptor
type GeneralCopyOperationsThirdPartyCopyDescriptorParameter
{
    uint TotalConcurrentCopies;
    uint MaximumIdentifiedConcurrentCopies;
    uint MaximumSegmentLength;
    byte DataSegmentGranularity;
    byte InlineDataGranularity;
    array<byte> Reserved with BinaryEncoding{Length = 18};
}

// [SPC-4] 7.8.17.11 Stream Copy Operations third-party copy descriptor
type StreamCopyOperationsThirdPartyCopyDescriptorParameter
{
    uint MaximumStreamDeviceTransferSize;
    ulong Reserved;
}

// [SPC-4] 7.8.17.12 Held Data third-party copy descriptor
type HeldDataThirdPartyCopyDescriptorParameter
{
    uint HeldDataLimit;
    byte HeldDataGranularity;
    array<byte> Reserved with BinaryEncoding{Length = 23};
}

// [SPC-4] 7.8.18 Unit Serial Number VPD page
type UnitSerialNumberVPDPageParameter
{
    string ProductSerialNumber with BinaryEncoding{TextEncoding = TextEncoding.ASCII};
}

// WORKAROUND for UTF8 decoding
string DecodeOctetStringAsUTF8(any a)
{
    assert a is binary;
    var s = BinaryDecoder<UTF8StringWrapper>(a as binary);
    return s is nothing ? a.ToString() : (s as UTF8StringWrapper).Text;
}
 
type UTF8StringWrapper
{
    string Text;
} with BinaryEncodingDefaults{TextEncoding = TextEncoding.UTF8};

// [RFC 3720] 5.1.  Text Format
syntax KeyValueFormat = pairs: (SimpleKeyValuePair)+
                        => MergeKeyValuePairs(pairs)
                        with StreamEncoding{Encoding = TextEncoding.ASCII};
/* Future Reference: Using UTF8 if this TextEncoding is supported
 * Bug#23734 - [ValueSystem] Stream Encoding does not support UTF8 as Text Encoding
 */

// Simple "key=value" syntax
syntax SimpleKeyValuePair = k: KeyName "=" v: KeyValue NullDelimiter
                            => new KeyValuePair
                            {
                                Key = k,
                                Value = (v == null ? "" : v)
                            };

syntax KeyName = s: StandardLabel => s;

// A string of one or more characters that consist of letters, digits, dot, minus, plus, commercial at, or underscore.
syntax StandardLabel = s:regex {[A-Z][a-z0-9A-Z_@+\x2E\x2D]*} => s;

syntax NullDelimiter = regex {[\x00]};

syntax KeyValue = s:regex {[^\x00]*} => s;

// Future Reference: Define more detailed syntax according to different Value type.

//--------------------------------------------------------------------
// Types that not from the protocol refrence
type KeyValuePair
{
    string Key;
    string Value;
}

// Types that defines to keep the values that available in the session
type LoginPhaseParameters
{
    bool HasHeaderDigest;
    bool HasDataDigest;
}
 
type ScsiCommandParameters
{
    byte OperationCode;
    ushort ServiceAction;
    int Auxiliary1;
    int Auxiliary2;
}

// WORKAROUND: For Bug#31792 - [DCR]BinaryDecoder<T>(binary) should support big-endian or little-endian dynamically assigned in runtime decoding.
type Uint24Type
{
    uint Value with BinaryEncoding{Width = 24};
}

pattern Uint32Type = uint;

//-------------------------------------------
// Helper functions

// Convert the array of KeyValuePair to map<string, string>
map<string, string> MergeKeyValuePairs(array<KeyValuePair> keyValuePairs)
{
    map<string, string> result = {};
    foreach (var pair in keyValuePairs)
    {
        result[pair.Key] = pair.Value;
    }
    return result;
}

// Get the value of the HeaderDigest field
optional uint GetDigest(stream s, bool hasDigest)
{
    if (hasDigest)
    {
        return BinaryDecoder<Uint32Type>(s);
    }
    return nothing;
}

// Get the value of the DataDigest field
optional uint GetDigest(stream s, uint dataSegmentLength, bool hasDigest)
{
    // A zero-length Data Segment also implies a zero-length data-digest.
    if (hasDigest && dataSegmentLength != 0)
    {
        return BinaryDecoder<Uint32Type>(s);
    }
    return nothing;
}

// Get the value of the DataSegment field
optional binary GetDataSegment(stream s, uint dataSegmentLength)
{
    if (dataSegmentLength > 0)
    {
        var ds = BinaryDecoder<Blob[dataSegmentLength]>(s) as Blob;
        return ds.Data;
    }
    return nothing;
}

// Get the padding for the DataSegment field
optional array<byte> GetDataSegmentPadding(stream s, uint padLength)
{
    if (padLength == 0)
    {
        return nothing;
    }
    Blob pad = BinaryDecoder<Blob[padLength as uint]>(s) as Blob;
    return pad.Data as array<byte>;
}

// Get the format of key-value pairs for the DataSegment field
map<string, string> GetKeyValuePairsAndSetLoginPhaseParams(stream s, uint dataSegmentLength, ref LoginPhaseParameters lpp)
{
    if (dataSegmentLength == 0)
    {
        return {};
    }
    
    var ds = BinaryDecoder<Blob[dataSegmentLength]>(s) as Blob;
    var kvp = KeyValueFormat(ds.Data);
    if (kvp != nothing)
    {
        var pairs = kvp as map<string, string>;
        // Get the parameters that will availble in current session
        if (pairs.Keys["HeaderDigest"])
        {
            if (lpp == null)
            {
                lpp = new LoginPhaseParameters{};
            }
            lpp.HasHeaderDigest = pairs["HeaderDigest"] == "CRC32C";
        }
        
        if (pairs.Keys["DataDigest"])
        {
            if (lpp == null) // This should not happen. Add this check in case that the data is invalid
            {
                lpp = new LoginPhaseParameters{};
            }
            lpp.HasDataDigest = pairs["DataDigest"] == "CRC32C";
        }
        
        return pairs;
    }
    else
    {
        throw "Key-value pairs cannot be decoded successfully.";
    }
}

// For summary
string StageCodesToText(byte code)
{
    return (StageCodesMap.Keys[code]? StageCodesMap[code] : (code as string) + "(Reserved)");
}

type ISCSIDecodingHelper : TCPDecodingHelper
{
    // shared context by two directions.
    SessionContext Context = new SessionContext();

    void InitializeISCSIHelper(any endpoint ept)
    {
        ISCSIDecodingCache acceptsCache = new ISCSIDecodingCache();
        acceptsCache.InitializeISCSI(ept, MessageDirection.Accepts, Context);
        ISCSIDecodingCache issuesCache = new ISCSIDecodingCache();
        issuesCache.InitializeISCSI(ept, MessageDirection.Issues, Context);
        AcceptsCache = acceptsCache;
        IssuesCache = issuesCache;
    }

    override void ClearInDestructor()
    {
        base.ClearInDestructor();
        Context = null;
    }
}

type ISCSIDecodingCache : TCPDecodingCache
{
    // Cache reassembled buffer for Text/Login messages.
    binary LoginBuffer = $[];
    binary TextBuffer = $[];

    // length of current message
    int totalPDULength = 0;
    uint dataSegmentLength = 0;
    uint paddingLength = 0;

    SessionContext SessionContext;
    
    void InitializeISCSI(any endpoint ept, MessageDirection direction, SessionContext ctx)
    {
        base.Initialize("iSCSI", ept, direction, IsiSCSI, IsDataSufficientForISCSI, DecodeSingleISCSIMessage, (binary b) => nothing);
        SessionContext = ctx;
    }
    
    bool? IsiSCSI(binary bin)
    {
        if (bin.Count < 0)
        {
            // should not hit TCP data Segment should have at least one-byte payload
            return null;
        }
        // Check the byte value if it is the invalid iSCSI opcode
        return ((bin[0] & 0x3F) as byte) is Opcodes;
    }
    
    uint? IsDataSufficientForISCSI(binary bin)
    {
        if (bin.Count < 8)
            return null;

        bool hasHeaderDigest = false;
        bool hasDataDigest = false;
        if (SessionContext.lpp != null) // The login messages are lost in the session
        {
            hasHeaderDigest = SessionContext.lpp.HasHeaderDigest;
            hasDataDigest = SessionContext.lpp.HasDataDigest;
        }
        var totalAHSLength = bin[4] * 4;
        dataSegmentLength = (bin[5] << 16) + (bin[6] << 8) + bin[7] as uint;
        paddingLength = (dataSegmentLength % 4 == 0) ? 0 : (4 - dataSegmentLength % 4);
        totalPDULength = (48 + totalAHSLength + dataSegmentLength + (hasHeaderDigest ? 4 : 0) + ((hasDataDigest && dataSegmentLength != 0)? 4 : 0) + paddingLength) as int;

        if (totalPDULength <= bin.Count)
        {
            return 0; // '0' indicates remaining data is enough for parse at least one message.
        }
        else
        {
            return totalPDULength as uint;
        }
    }
    
    optional any message DecodeSingleISCSIMessage(stream str)
    {
        bool hasHeaderDigest = false;
        bool hasDataDigest = false;
        if (SessionContext.lpp != null) // The login messages are not lost in the session
        {
            hasHeaderDigest = SessionContext.lpp.HasHeaderDigest;
            hasDataDigest = SessionContext.lpp.HasDataDigest;
        }
 
        byte opcode = (str.CurrentByte & 0x3F) as byte;
        switch (opcode)
        {
            // Initiator opcodes, the message that accepted by the server side
            case Opcodes.NopOut =>
                switch (str)
                {
                    case m: Messages.NopOut from BinaryDecoder<Messages.NopOut> =>
                        // Update the optional fields
                        int headerDigestBeginPos = str.BitPosition;
                        m.HeaderDigest = GetDigest(str, hasHeaderDigest);
                        if (m.HeaderDigest != nothing)
                        {
                            m.AssignFieldEncodingInfo("HeaderDigest", headerDigestBeginPos, 32);
                        }
                        int pingDataBeginPos = str.BitPosition;
                        m.PingData = GetDataSegment(str, dataSegmentLength);
                        if (m.PingData != nothing)
                        {
                            m.AssignFieldEncodingInfo("PingData", pingDataBeginPos, dataSegmentLength * 8 as int);
                        }
                        int paddingBeginPos = str.BitPosition;
                        m.Padding = GetDataSegmentPadding(str, paddingLength);
                        if (m.Padding != nothing)
                        {
                            m.AssignFieldEncodingInfo("Padding", paddingBeginPos, paddingLength * 8 as int);
                        }
                        int dataDigestBeginPos = str.BitPosition;
                        m.DataDigest = GetDigest(str, dataSegmentLength, hasDataDigest);
                        if (m.DataDigest != nothing)
                        {
                            m.AssignFieldEncodingInfo("DataDigest", dataDigestBeginPos, 32);
                        }
                        this.EPT = endpoint Server[0];
                        return m as any message;
                    default =>
                        return nothing;
                }
            case Opcodes.ScsiCommand =>
                switch (str)
                {
                    case m: Messages.ScsiCommand from BinaryDecoder<Messages.ScsiCommand> =>
                        /* Decode the CommandDescriptorBlock for operation code 7Fh,
                            * since the data size will extend 16 bytes and need manully merge it
                            */
                        if (m.ScsiCommandDescriptorBlock is binary && m.AHS != nothing && (m.AHS as array<AdditionalHeaderSegment>).Count > 0)
                        {
                            // Get the compelete CDB data from ScsiCommandDescriptorBlock and AHS
                            binary binaryCDB = m.ScsiCommandDescriptorBlock as binary;
                            foreach (var ahs in m.AHS as array<AdditionalHeaderSegment>)
                            {
                                if (ahs is ExtendedCDBAHS)
                                {
                                    binaryCDB += (ahs as ExtendedCDBAHS).ExtendedCDB;
                                }
                            }
                            m.VariableLengthCommandDescriptorBlock = BinaryDecoder<VariableLengthCommandDescriptorBlock>(binaryCDB);
                        }
                        else
                        {
                            m.VariableLengthCommandDescriptorBlock = nothing;
                        }
                        int headerDigestBeginPos = str.BitPosition;
                        m.HeaderDigest = GetDigest(str, hasHeaderDigest);
                        if (m.HeaderDigest != nothing)
                        {
                            m.AssignFieldEncodingInfo("HeaderDigest", headerDigestBeginPos, 32);
                        }
                        int dataBeginPos = str.BitPosition;
                        optional binary data = GetDataSegment(str, dataSegmentLength);
                        optional any result = nothing;
                            
                        // Record useful CDB information, which will be used in decoding future SCSI Data-In and SCSI Data-Out messages.
                        if (m.ScsiCommandDescriptorBlock is ScsiCommandDescriptorBlock)
                        {
                            var db = m.ScsiCommandDescriptorBlock as ScsiCommandDescriptorBlock;
                            SessionContext.taskInfo[m.InitiatorTaskTag] = new ScsiCommandParameters{OperationCode = db.OperationCode.Value};
                            switch (db.CommandSpecificParameters)
                            {
                                case cp:FormatUnitCommandParameters =>
                                    SessionContext.taskInfo[m.InitiatorTaskTag].Auxiliary1 = cp.LongList as int;
                                    SessionContext.taskInfo[m.InitiatorTaskTag].Auxiliary2 = cp.DefectListFormat as int;
                                case cp:GetLbaStatusCommandParameters =>
                                    SessionContext.taskInfo[m.InitiatorTaskTag].ServiceAction = cp.ServiceAction;
                                case cp:PopulateTokenCommandParameters =>
                                    SessionContext.taskInfo[m.InitiatorTaskTag].ServiceAction = cp.ServiceAction;
                                case cp:ReadCapacity16CommandParameters =>
                                    SessionContext.taskInfo[m.InitiatorTaskTag].ServiceAction = cp.ServiceAction;
                                case cp:ReassignBlocksCommandParameters =>
                                    SessionContext.taskInfo[m.InitiatorTaskTag].Auxiliary1 = cp.LongList as int;
                                    SessionContext.taskInfo[m.InitiatorTaskTag].Auxiliary2 = cp.LongLBA as int;
                                case cp:ReportReferralsCommandParameters =>
                                    SessionContext.taskInfo[m.InitiatorTaskTag].ServiceAction = cp.ServiceAction;
                                case cp:WriteUsingTokenCommandParameters =>
                                    SessionContext.taskInfo[m.InitiatorTaskTag].ServiceAction = cp.ServiceAction;
                                case cp:InquiryCommandParameters =>
                                    SessionContext.taskInfo[m.InitiatorTaskTag].Auxiliary1 = (cp.EVPD ? cp.PageCode : 0xFF);
                                case cp:ChangeAliasesCommandParameters =>
                                    SessionContext.taskInfo[m.InitiatorTaskTag].ServiceAction = cp.ServiceAction;
                                case cp:ExtendedCopyLID4CommandParameters =>
                                    SessionContext.taskInfo[m.InitiatorTaskTag].ServiceAction = cp.ServiceAction;
                                case cp:ExtendedCopyLID1CommandParameters =>
                                    SessionContext.taskInfo[m.InitiatorTaskTag].ServiceAction = cp.ServiceAction;
                                case cp:ManagementProtocolInCommandParameters =>
                                    SessionContext.taskInfo[m.InitiatorTaskTag].ServiceAction = cp.ServiceAction;
                                case cp:PersistentReserveInCommandParameters =>
                                    SessionContext.taskInfo[m.InitiatorTaskTag].ServiceAction = cp.ServiceAction;
                                case cp:PersistentReserveOutCommandParameters =>
                                    SessionContext.taskInfo[m.InitiatorTaskTag].ServiceAction = cp.ServiceAction;
                                case cp:ReadAttributeCommandParameters =>
                                    SessionContext.taskInfo[m.InitiatorTaskTag].ServiceAction = cp.ServiceAction;
                                case cp:ReadBufferCommandParameters =>
                                    SessionContext.taskInfo[m.InitiatorTaskTag].Auxiliary1 = cp.Mode;
                                case cp:ReadMediaSerialNumberCommandParameters =>
                                    SessionContext.taskInfo[m.InitiatorTaskTag].ServiceAction = cp.ServiceAction;
                                case cp:RemoveITNexusCommandParameters =>
                                    SessionContext.taskInfo[m.InitiatorTaskTag].ServiceAction = cp.ServiceAction;
                                case cp:ReportAliasesCommandParameters =>
                                    SessionContext.taskInfo[m.InitiatorTaskTag].ServiceAction = cp.ServiceAction;
                                case cp:ReportAllRodTokensCommandParameters =>
                                    SessionContext.taskInfo[m.InitiatorTaskTag].ServiceAction = cp.ServiceAction;
                                case cp:ReportIdentifyingInformationCommandParameters =>
                                    SessionContext.taskInfo[m.InitiatorTaskTag].ServiceAction = cp.ServiceAction;
                                    SessionContext.taskInfo[m.InitiatorTaskTag].Auxiliary1 = cp.IdentifyingInformationType;
                                case cp:ReportLunsCommandParameters =>
                                    SessionContext.taskInfo[m.InitiatorTaskTag].Auxiliary1 = cp.SelectReport;
                                case cp:ReportPriorityCommandParameters =>
                                    SessionContext.taskInfo[m.InitiatorTaskTag].ServiceAction = cp.ServiceAction;
                                case cp:ReportSupportedOperationCodesCommandParameters =>
                                    SessionContext.taskInfo[m.InitiatorTaskTag].ServiceAction = cp.ServiceAction;
                                    SessionContext.taskInfo[m.InitiatorTaskTag].Auxiliary1 = cp.ReportingOptions;
                                case cp:ReportSupportedTaskManagementFunctionsCommandParameters =>
                                    SessionContext.taskInfo[m.InitiatorTaskTag].ServiceAction = cp.ServiceAction;
                                    SessionContext.taskInfo[m.InitiatorTaskTag].Auxiliary1 = cp.REPD as int;
                                case cp:ReportTargetPortGroupsCommandParameters =>
                                    SessionContext.taskInfo[m.InitiatorTaskTag].ServiceAction = cp.ServiceAction;
                                    SessionContext.taskInfo[m.InitiatorTaskTag].Auxiliary1 = cp.ParameterDataFormat;
                                case cp:ReportTimestampCommandParameters =>
                                    SessionContext.taskInfo[m.InitiatorTaskTag].ServiceAction = cp.ServiceAction;
                                case cp:SetPriorityCommandParameters =>
                                    SessionContext.taskInfo[m.InitiatorTaskTag].ServiceAction = cp.ServiceAction;
                                case cp:SetTargetPortGroupsCommandParameters =>
                                    SessionContext.taskInfo[m.InitiatorTaskTag].ServiceAction = cp.ServiceAction;
                                case cp:SetTimestampCommandParameters =>
                                    SessionContext.taskInfo[m.InitiatorTaskTag].ServiceAction = cp.ServiceAction;
                                case cp:RequestSenseCommandParameters =>
                                    SessionContext.taskInfo[m.InitiatorTaskTag].Auxiliary1 = cp.DESC as int;
                                case cp:ReceiveRodTokenInformationCommandParameters =>
                                    SessionContext.taskInfo[m.InitiatorTaskTag].ServiceAction = cp.ServiceAction;
                                case cp:SecurityProtocolInCommandParameters =>
                                    SessionContext.taskInfo[m.InitiatorTaskTag].ServiceAction = cp.SecurityProtocol;
                                    SessionContext.taskInfo[m.InitiatorTaskTag].Auxiliary1 = cp.SecurityProtocolSpecific;
                                case cp:SecurityProtocolOutCommandParameters =>
                                    SessionContext.taskInfo[m.InitiatorTaskTag].ServiceAction = cp.SecurityProtocol;
                                    SessionContext.taskInfo[m.InitiatorTaskTag].Auxiliary1 = cp.SecurityProtocolSpecific;
                                default =>;
                            }
                            if (data != nothing)
                            {
                                binary d = data as binary;
                                result = DecodeOutgoingData(SessionContext.taskInfo[m.InitiatorTaskTag], d);
                            }
                        }
                        if (result == nothing)
                        {
                            result = data;
                        }
                        m.CommandData = result;
                        if (m.CommandData != nothing)
                        {                                
                            m.AssignFieldEncodingInfo("CommandData", dataBeginPos, dataSegmentLength * 8 as int);
                        }
                        int paddingBeginPos = str.BitPosition;
                        m.Padding = GetDataSegmentPadding(str, paddingLength);
                        if (m.Padding != nothing)
                        {
                            m.AssignFieldEncodingInfo("Padding", paddingBeginPos, paddingLength * 8 as int);
                        }
                        int dataDigestBeginPos = str.BitPosition;
                        m.DataDigest = GetDigest(str, dataSegmentLength, hasDataDigest);
                        if (m.DataDigest != nothing)
                        {
                            m.AssignFieldEncodingInfo("DataDigest", dataDigestBeginPos, 32);
                        }
                        this.EPT = endpoint Server[m.InitiatorTaskTag];
                        return m as any message;
                    default =>
                        return nothing;
                }
            case Opcodes.ScsiTaskManagementFunctionRequest =>
                switch (str)
                {
                    case m: Messages.ScsiTaskManagementFunctionRequest from BinaryDecoder<Messages.ScsiTaskManagementFunctionRequest> =>
                        int beginPos = str.BitPosition;
                        m.HeaderDigest = GetDigest(str, hasHeaderDigest);
                        if (m.HeaderDigest != nothing)
                        {
                            m.AssignFieldEncodingInfo("HeaderDigest", beginPos, 32);
                        }
                        this.EPT = endpoint Server[0];
                        return m as any message;
                    default =>
                        return nothing;
                }
            case Opcodes.LoginRequest =>
                switch (str)
                {
                    case m: Messages.LoginRequest from BinaryDecoder<Messages.LoginRequest> =>
                        if (!m.C && LoginBuffer == $[]) // The Text (data segment) is complete
                        {
                            int loginBeginPos = str.BitPosition;
                            var lppcopy = SessionContext.lpp;
                            m.LoginParameters = GetKeyValuePairsAndSetLoginPhaseParams(str, dataSegmentLength, ref lppcopy);
                            SessionContext.lpp = lppcopy;
                            int paddingBeginPos = str.BitPosition;
                            if (paddingBeginPos > loginBeginPos)
                            {
                                m.AssignFieldEncodingInfo("LoginParameters", loginBeginPos, (paddingBeginPos - loginBeginPos));
                            }
                            m.Padding = GetDataSegmentPadding(str, paddingLength);
                            if (m.Padding != nothing)
                            {
                                m.AssignFieldEncodingInfo("Padding", paddingBeginPos, paddingLength * 8 as int);
                            }
                            this.EPT = endpoint Server[0];
                            return m as any message;
                        }
                        // The text need to be continued
                        else
                        {
                            int loginBeginPos = str.BitPosition;
                            optional binary data = GetDataSegment(str, dataSegmentLength);
                            if (data != nothing)
                            {
                                LoginBuffer += data as binary;
                            }
                            m.LoginParameters = data;
                            if (m.LoginParameters != nothing)
                            {
                                m.AssignFieldEncodingInfo("LoginParameters", loginBeginPos, dataSegmentLength * 8 as int);
                            }
                            int paddingBeginPos = str.BitPosition;
                            m.Padding = GetDataSegmentPadding(str, paddingLength);
                            if (m.Padding != nothing)
                            {
                                m.AssignFieldEncodingInfo("Padding", paddingBeginPos, paddingLength * 8 as int);
                            }
                            IntermediateNode node = endpoint IntermediateNode;
                            this.EPT = node;
                            if (!m.C)
                            {
                                var lppcopy = SessionContext.lpp;
                                node.LoginParameters =  GetKeyValuePairsAndSetLoginPhaseParams(LoginBuffer, LoginBuffer.Count as uint , ref lppcopy);
                                SessionContext.lpp = lppcopy;
                                node.Buffer = LoginBuffer;
                            }
                            return m as any message;
                        }
                    default =>
                        return nothing;
                }
            case Opcodes.TextRequest =>
                switch (str)
                {
                    case m: Messages.TextRequest from BinaryDecoder<Messages.TextRequest> =>
                        if (!m.C && TextBuffer == $[]) // The Text (data segment) is complete
                        {
                            int textBeginPos = str.BitPosition;
                            var lppcopy = SessionContext.lpp;
                            m.Text = GetKeyValuePairsAndSetLoginPhaseParams(str, dataSegmentLength, ref lppcopy);
                            SessionContext.lpp = lppcopy;
                            int paddingBeginPos = str.BitPosition;
                            if (paddingBeginPos > textBeginPos)
                            {
                                m.AssignFieldEncodingInfo("Text", textBeginPos, (paddingBeginPos - textBeginPos));
                            }
                            m.Padding = GetDataSegmentPadding(str, paddingLength);
                            if (m.Padding != nothing)
                            {
                                m.AssignFieldEncodingInfo("Padding", paddingBeginPos, paddingLength * 8 as int);
                            }
                            int dataDigestBeginPos = str.BitPosition;
                            m.DataDigest = GetDigest(str, dataSegmentLength, hasDataDigest);
                            if (m.DataDigest != nothing)
                            {
                                m.AssignFieldEncodingInfo("DataDigest", dataDigestBeginPos, 32);
                            }
                            this.EPT = endpoint Server[m.InitiatorTaskTag];
                            return m as any message;
                        }
                        // The text need to be continued
                        else
                        {
                            int textBeginPos = str.BitPosition;
                            optional binary data = GetDataSegment(str, dataSegmentLength);
                            if (data != nothing)
                            {
                                TextBuffer += data as binary;
                            }
                            m.Text = data;
                            if (m.Text != nothing)
                            {
                                m.AssignFieldEncodingInfo("Text", textBeginPos, dataSegmentLength * 8 as int);
                            }
                            int paddingBeginPos = str.BitPosition;
                            m.Padding = GetDataSegmentPadding(str, paddingLength);
                            if (m.Padding != nothing)
                            {
                                m.AssignFieldEncodingInfo("Padding", paddingBeginPos, paddingLength * 8 as int);
                            }
                            int dataDigestBeginPos = str.BitPosition;
                            m.DataDigest = GetDigest(str, dataSegmentLength, hasDataDigest);
                            if (m.DataDigest != nothing)
                            {
                                m.AssignFieldEncodingInfo("DataDigest", dataDigestBeginPos, 32);
                            }
                            IntermediateNode node = endpoint IntermediateNode;
                            this.EPT = node;
                            if (!m.C)
                            {
                                var lppcopy = SessionContext.lpp;
                                node.LoginParameters =  GetKeyValuePairsAndSetLoginPhaseParams(TextBuffer, TextBuffer.Count as uint , ref lppcopy);
                                SessionContext.lpp = lppcopy;
                                node.Buffer = TextBuffer;
                            }
                            return m as any message;
                        }
                    default =>
                        return nothing;
                }
            case Opcodes.ScsiDataOut =>
                switch (str)
                {
                    case m: Messages.ScsiDataOut from BinaryDecoder<Messages.ScsiDataOut> =>
                        int headerDigestBeginPos = str.BitPosition;
                        m.HeaderDigest = GetDigest(str, hasHeaderDigest);
                        if (m.HeaderDigest != nothing)
                        {
                            m.AssignFieldEncodingInfo("HeaderDigest", headerDigestBeginPos, 32);
                        }
                        int dataBeginPos = str.BitPosition;
                        optional binary data = GetDataSegment(str, dataSegmentLength);
                        m.DataSegment = $[];
                        if (data != nothing)
                        {
                            binary s = data as binary;
                            optional any result = nothing;
                            if (m.InitiatorTaskTag in SessionContext.taskInfo)
                            {
                                result = DecodeOutgoingData(SessionContext.taskInfo[m.InitiatorTaskTag], s);
                            }
                            if (result != nothing)
                            {
                                m.DataSegment = result;
                            }
                            else
                            {
                                m.DataSegment = s;
                            }
                            m.AssignFieldEncodingInfo("DataSegment", dataBeginPos, dataSegmentLength * 8 as int);
                        }
                        int paddingBeginPos = str.BitPosition;
                        m.Padding = GetDataSegmentPadding(str, paddingLength);
                        if (m.Padding != nothing)
                        {
                            m.AssignFieldEncodingInfo("Padding", paddingBeginPos, paddingLength * 8 as int);
                        }
                        int dataDigestBeginPos = str.BitPosition;
                        m.DataDigest = GetDigest(str, dataSegmentLength, hasDataDigest);
                        if (m.DataDigest != nothing)
                        {
                            m.AssignFieldEncodingInfo("DataDigest", dataDigestBeginPos, 32);
                        }
                        this.EPT = endpoint Server[m.InitiatorTaskTag];
                        return m as any message;
                    default =>
                        return nothing;
                }
            case Opcodes.LogoutRequest =>
                switch (str)
                {
                    case m: Messages.LogoutRequest from BinaryDecoder<Messages.LogoutRequest> =>
                        int beginPos = str.BitPosition;
                        m.HeaderDigest = GetDigest(str, hasHeaderDigest);
                        if (m.HeaderDigest != nothing)
                        {
                            m.AssignFieldEncodingInfo("HeaderDigest", beginPos, 32);
                        }
                        this.EPT = endpoint Server[0];
                        return m as any message;
                    default =>
                        return nothing;
                }        
            case Opcodes.SnackRequest =>
                switch (str)
                {
                    case m: Messages.SnackRequest from BinaryDecoder<Messages.SnackRequest> =>
                        int beginPos = str.BitPosition;
                        m.HeaderDigest = GetDigest(str, hasHeaderDigest);
                        if (m.HeaderDigest != nothing)
                        {
                            m.AssignFieldEncodingInfo("HeaderDigest", beginPos, 32);
                        }
                        this.EPT = endpoint Server[0];
                        return m as any message;
                    default =>
                        return nothing;
                }
            case Opcodes.VendorSpecificCodeI0 =>
                DecodeAndDispatchVendorSpecificMessage(str, true, hasHeaderDigest, hasDataDigest, dataSegmentLength, paddingLength);
            case Opcodes.VendorSpecificCodeI1 =>
                DecodeAndDispatchVendorSpecificMessage(str, true, hasHeaderDigest, hasDataDigest, dataSegmentLength, paddingLength);
            case Opcodes.VendorSpecificCodeI2 =>
                DecodeAndDispatchVendorSpecificMessage(str, true, hasHeaderDigest, hasDataDigest, dataSegmentLength, paddingLength);
            // Target opcodes, the message that issued by the server side
            case Opcodes.NopIn =>
                switch (str)
                {
                    case m: Messages.NopIn from BinaryDecoder<Messages.NopIn> =>
                        int headerDigestBeginPos = str.BitPosition;
                        m.HeaderDigest = GetDigest(str, hasHeaderDigest);
                        if (m.HeaderDigest != nothing)
                        {
                            m.AssignFieldEncodingInfo("HeaderDigest", headerDigestBeginPos, 32);
                        }
                        int pingDataBeginPos = str.BitPosition;
                        m.PingData = GetDataSegment(str, dataSegmentLength);
                        if (m.PingData != nothing)
                        {
                            m.AssignFieldEncodingInfo("PingData", pingDataBeginPos, dataSegmentLength * 8 as int);
                        }
                        int paddingBeginPos = str.BitPosition;
                        m.Padding = GetDataSegmentPadding(str, paddingLength);
                        if (m.Padding != nothing)
                        {
                            m.AssignFieldEncodingInfo("Padding", paddingBeginPos, paddingLength * 8 as int);
                        }
                        int dataDigestBeginPos = str.BitPosition;
                        m.DataDigest = GetDigest(str, dataSegmentLength, hasDataDigest);
                        if (m.DataDigest != nothing)
                        {
                            m.AssignFieldEncodingInfo("DataDigest", dataDigestBeginPos, 32);
                        }
                        this.EPT = endpoint Server[0];
                        return m as any message;
                    default =>
                        return nothing;
                }
            case Opcodes.ScsiResponse =>
                switch (str)
                {
                    case m: Messages.ScsiResponse from BinaryDecoder<Messages.ScsiResponse> =>
                        int beginPos = str.BitPosition;
                        m.HeaderDigest = GetDigest(str, hasHeaderDigest);
                        if (m.HeaderDigest != nothing)
                        {
                            m.AssignFieldEncodingInfo("HeaderDigest", beginPos, 32);
                        }
                        int dataSegmentBeginPos = str.BitPosition;
                        m.DataSegment = dataSegmentLength == 0 ? nothing: BinaryDecoder<SenseAndResponseDataSegment[dataSegmentLength]>(str) as SenseAndResponseDataSegment;
                        if (m.DataSegment != nothing)
                        {
                            m.AssignFieldEncodingInfo("DataSegment", dataSegmentBeginPos, dataSegmentLength * 8 as int);
                        }
                        int dataDigestBeginPos = str.BitPosition;
                        m.DataDigest = GetDigest(str, dataSegmentLength, hasDataDigest);
                        if (m.DataDigest != nothing)
                        {
                            m.AssignFieldEncodingInfo("DataDigest", dataDigestBeginPos, 32);
                        }
                        // Remove the record of this task from cache.
                        if (m.InitiatorTaskTag in SessionContext.taskInfo)
                        {
                            SessionContext.taskInfo = SessionContext.taskInfo.Remove(m.InitiatorTaskTag);
                        }
                        this.EPT = endpoint Server[m.InitiatorTaskTag];
                        return m as any message;
                    default =>
                        return nothing;
                }
            case Opcodes.ScsiTaskManagementFunctionResponse =>
                switch (str)
                {
                    case m: Messages.ScsiTaskManagementFunctionResponse from BinaryDecoder<Messages.ScsiTaskManagementFunctionResponse> =>
                        int beginPos = str.BitPosition;
                        m.HeaderDigest = GetDigest(str, hasHeaderDigest);
                        if (m.HeaderDigest != nothing)
                        {
                            m.AssignFieldEncodingInfo("HeaderDigest", beginPos, 32);
                        }
                        this.EPT = endpoint Server[0];
                        return m as any message;
                    default =>
                        return nothing;
                }         
            case Opcodes.LoginResponse =>
                switch (str)
                {
                    case m: Messages.LoginResponse from BinaryDecoder<Messages.LoginResponse> =>
                        if (!m.C && LoginBuffer == $[]) // The Text (data segment) is complete
                        {
                            int loginBeginPos = str.BitPosition;
                            var lppcopy = SessionContext.lpp;
                            m.LoginParameters = GetKeyValuePairsAndSetLoginPhaseParams(str, dataSegmentLength, ref lppcopy);
                            SessionContext.lpp = lppcopy;
                            int paddingBeginPos = str.BitPosition;
                            if (paddingBeginPos > loginBeginPos)
                            {
                                m.AssignFieldEncodingInfo("LoginParameters", loginBeginPos, (paddingBeginPos - loginBeginPos));
                            }
                            m.Padding = GetDataSegmentPadding(str, paddingLength);
                            if (m.Padding != nothing)
                            {
                                m.AssignFieldEncodingInfo("Padding", paddingBeginPos, paddingLength * 8 as int);
                            }
                            this.EPT = endpoint Server[0];
                            return m as any message;
                        }
                        // The text need to be continued
                        else
                        {
                            int loginBeginPos = str.BitPosition;
                            optional binary data = GetDataSegment(str, dataSegmentLength);
                            if (data != nothing)
                            {
                                LoginBuffer += data as binary;
                            }
                            m.LoginParameters = data;
                            if (m.LoginParameters != nothing)
                            {
                                m.AssignFieldEncodingInfo("LoginParameters", loginBeginPos, dataSegmentLength * 8 as int);
                            }
                            int paddingBeginPos = str.BitPosition;
                            m.Padding = GetDataSegmentPadding(str, paddingLength);
                            if (m.Padding != nothing)
                            {
                                m.AssignFieldEncodingInfo("Padding", paddingBeginPos, paddingLength * 8 as int);
                            }
                            IntermediateNode node = endpoint IntermediateNode;
                            this.EPT = node;
                            if (!m.C)
                            {
                                var lppcopy = SessionContext.lpp;
                                node.LoginParameters =  GetKeyValuePairsAndSetLoginPhaseParams(LoginBuffer, LoginBuffer.Count as uint , ref lppcopy);
                                SessionContext.lpp = lppcopy;
                                node.Buffer = LoginBuffer;
                            }
                            return m as any message;
                        }
                    default =>
                        return nothing;
                } 
            case Opcodes.TextResponse =>
                switch (str)
                {
                    case m: Messages.TextResponse from BinaryDecoder<Messages.TextResponse> =>
                        if (!m.C && TextBuffer == $[]) // The Text (data segment) is complete
                        {
                            int textBeginPos = str.BitPosition;
                            var lppcopy = SessionContext.lpp;
                            m.Text = GetKeyValuePairsAndSetLoginPhaseParams(str, dataSegmentLength, ref lppcopy);
                            SessionContext.lpp = lppcopy;
                            int paddingBeginPos = str.BitPosition;
                            if (paddingBeginPos > textBeginPos)
                            {
                                m.AssignFieldEncodingInfo("Text", textBeginPos, (paddingBeginPos - textBeginPos));
                            }
                            m.Padding = GetDataSegmentPadding(str, paddingLength);
                            if (m.Padding != nothing)
                            {
                                m.AssignFieldEncodingInfo("Padding", paddingBeginPos, paddingLength * 8 as int);
                            }
                            this.EPT = endpoint Server[m.InitiatorTaskTag];
                            return m as any message;
                        }
                        // The text need to be continued
                        else
                        {
                            int textBeginPos = str.BitPosition;
                            optional binary data = GetDataSegment(str, dataSegmentLength);
                            if (data != nothing)
                            {
                                TextBuffer += data as binary;
                            }
                            m.Text = data;
                            if (m.Text != nothing)
                            {
                                m.AssignFieldEncodingInfo("Text", textBeginPos, dataSegmentLength * 8 as int);
                            }
                            int paddingBeginPos = str.BitPosition;
                            m.Padding = GetDataSegmentPadding(str, paddingLength);
                            if (m.Padding != nothing)
                            {
                                m.AssignFieldEncodingInfo("Padding", paddingBeginPos, paddingLength * 8 as int);
                            }
                            IntermediateNode node = endpoint IntermediateNode;
                            this.EPT = node;
                            if (!m.C)
                            {
                                var lppcopy = SessionContext.lpp;
                                node.LoginParameters =  GetKeyValuePairsAndSetLoginPhaseParams(TextBuffer, TextBuffer.Count as uint , ref lppcopy);
                                SessionContext.lpp = lppcopy;
                                node.Buffer = TextBuffer;
                            }
                            return m as any message;
                        }
                    default =>
                        return nothing;
                }
            case Opcodes.ScsiDataIn =>
                switch (str)
                {
                    case m: Messages.ScsiDataIn from BinaryDecoder<Messages.ScsiDataIn> =>
                        ErrorCodeIf(m.Flags.ResidualOverflow, m, DiagnosisLevel.Information, iSCSI_RESIDUAL_OVEFLOW);
                        int headerDigestBeginPos = str.BitPosition;
                        m.HeaderDigest = GetDigest(str, hasHeaderDigest);
                        if (m.HeaderDigest != nothing)
                        {
                            m.AssignFieldEncodingInfo("HeaderDigest", headerDigestBeginPos, 32);
                        }
                        int dataBeginPos = str.BitPosition;
                        optional binary data = GetDataSegment(str, dataSegmentLength);
                        m.DataSegment = $[];
                        if (data != nothing)
                        {
                            binary s = data as binary;
                            optional any result = nothing;
                            if (m.InitiatorTaskTag in SessionContext.taskInfo)
                            {
                                result = DecodeIncomingData(SessionContext.taskInfo[m.InitiatorTaskTag], s);
                                if (m.Flags.F)
                                {
                                    SessionContext.taskInfo = SessionContext.taskInfo.Remove(m.InitiatorTaskTag);
                                }
                            }
                            if (result != nothing)
                            {
                                m.DataSegment = result;
                            }
                            else
                            {
                                m.DataSegment = s;
                            }
                            m.AssignFieldEncodingInfo("DataSegment", dataBeginPos, dataSegmentLength * 8 as int);
                        }
                        int paddingBeginPos = str.BitPosition;
                        m.Padding = GetDataSegmentPadding(str, paddingLength);
                        if (m.Padding != nothing)
                        {
                            m.AssignFieldEncodingInfo("Padding", paddingBeginPos, paddingLength * 8 as int);
                        }
                        int dataDigestBeginPos = str.BitPosition;
                        m.DataDigest = GetDigest(str, dataSegmentLength, hasDataDigest);
                        if (m.DataDigest != nothing)
                        {
                            m.AssignFieldEncodingInfo("DataDigest", dataDigestBeginPos, 32);
                        }
                        this.EPT = endpoint Server[m.InitiatorTaskTag];
                        return m as any message;
                    default =>
                        return nothing;
                }      
            case Opcodes.LogoutResponse =>
                switch (str)
                {
                    case m: Messages.LogoutResponse from BinaryDecoder<Messages.LogoutResponse> =>
                        int beginPos = str.BitPosition;
                        m.HeaderDigest = GetDigest(str, hasHeaderDigest);
                        if (m.HeaderDigest != nothing)
                        {
                            m.AssignFieldEncodingInfo("HeaderDigest", beginPos, 32);
                        }
                        this.EPT = endpoint Server[0];
                        return m as any message;
                    default =>
                        return nothing;
                }
            case Opcodes.ReadyToTransfer =>
                switch (str)
                {
                    case m: Messages.ReadyToTransfer from BinaryDecoder<Messages.ReadyToTransfer> =>
                        int beginPos = str.BitPosition;
                        m.HeaderDigest = GetDigest(str, hasHeaderDigest);
                        if (m.HeaderDigest != nothing)
                        {
                            m.AssignFieldEncodingInfo("HeaderDigest", beginPos, 32);
                        }
                        this.EPT = endpoint Server[m.InitiatorTaskTag];
                        return m as any message;
                    default =>
                        return nothing;
                }
            case Opcodes.AsynchronousMessage =>
                switch (str)
                {
                    case m: Messages.AsynchronousMessage from BinaryDecoder<Messages.AsynchronousMessage> =>
                        int headerDigestBeginPos = str.BitPosition;
                        m.HeaderDigest = GetDigest(str, hasHeaderDigest);
                        if (m.HeaderDigest != nothing)
                        {
                            m.AssignFieldEncodingInfo("HeaderDigest", headerDigestBeginPos, 32);
                        }
                        int dataBeginPos = str.BitPosition;
                        m.SenseDataAndiSCSIEventData = dataSegmentLength == 0? nothing : BinaryDecoder<SenseDataAndiSCSIEventData[dataSegmentLength]>(str) as SenseDataAndiSCSIEventData;
                        if (m.SenseDataAndiSCSIEventData != nothing)
                        {
                            m.AssignFieldEncodingInfo("SenseDataAndiSCSIEventData", dataBeginPos, dataSegmentLength * 8 as int);
                        }
                        int dataDigestBeginPos = str.BitPosition;
                        m.DataDigest = GetDigest(str, dataSegmentLength, hasDataDigest);
                        if (m.DataDigest != nothing)
                        {
                            m.AssignFieldEncodingInfo("DataDigest", dataDigestBeginPos, 32);
                        }
                        this.EPT = endpoint Server[0];
                        return m as any message;
                    default =>
                        return nothing;
                }
            case Opcodes.Reject =>
                switch (str)
                {
                    case m: Messages.Reject from BinaryDecoder<Messages.Reject> =>
                        int headerDigestBeginPos = str.BitPosition;
                        m.HeaderDigest = GetDigest(str, hasHeaderDigest);
                        if (m.HeaderDigest != nothing)
                        {
                            m.AssignFieldEncodingInfo("HeaderDigest", headerDigestBeginPos, 32);
                        }
                        int headerBeginPos = str.BitPosition;
                        m.CompleteHeaderOfBadPDU = GetDataSegment(str, 48) as binary;
                        m.AssignFieldEncodingInfo("CompleteHeaderOfBadPDU", headerBeginPos, 48 * 8);
                        int dataBeginPos = str.BitPosition;
                        m.VendorSpecificData = dataSegmentLength > 48? GetDataSegment(str, dataSegmentLength - 48 as uint) as binary : $[];
                        if (dataSegmentLength > 48)
                        {
                            m.AssignFieldEncodingInfo("VendorSpecificData", dataBeginPos, (dataSegmentLength - 48) * 8 as int);
                        }
                        int paddingBeginPos = str.BitPosition;
                        m.Padding = GetDataSegmentPadding(str, paddingLength);
                        if (m.Padding != nothing)
                        {
                            m.AssignFieldEncodingInfo("Padding", paddingBeginPos, paddingLength * 8 as int);
                        }
                        int dataDigestBeginPos = str.BitPosition;
                        m.DataDigest = GetDigest(str, dataSegmentLength, hasDataDigest);
                        if (m.DataDigest != nothing)
                        {
                            m.AssignFieldEncodingInfo("DataDigest", dataDigestBeginPos, 32);
                        }
                        this.EPT = endpoint Server[0];
                        return m as any message;
                    default =>
                        return nothing;
                }
            case Opcodes.VendorSpecificCodesT0 =>
                this.EPT = endpoint Server[0];
                return DecodeAndDispatchVendorSpecificMessage(str, false, hasHeaderDigest, hasDataDigest, dataSegmentLength, paddingLength);
            case Opcodes.VendorSpecificCodesT1 =>
                this.EPT = endpoint Server[0];
                return DecodeAndDispatchVendorSpecificMessage(str, false, hasHeaderDigest, hasDataDigest, dataSegmentLength, paddingLength);
            case Opcodes.VendorSpecificCodesT2 =>
                this.EPT = endpoint Server[0];
                return DecodeAndDispatchVendorSpecificMessage(str, false, hasHeaderDigest, hasDataDigest, dataSegmentLength, paddingLength);
            default =>;
        }
            
        // In case that missing the login messages, clear the buffer if remaining data is smaller than 8
        if (SessionContext.lpp == null && Buffer.Count - totalPDULength <= 8 && !(opcode in {Opcodes.LoginRequest, Opcodes.LoginResponse}))
        {
            Buffer = $[];
            return nothing;
        }
        return nothing;
    }

    override void ClearExceptionally()
    {
        base.ClearExceptionally();
        LoginBuffer = $[];
        TextBuffer = $[];
        totalPDULength = 0;
        dataSegmentLength = 0;
        paddingLength = 0;
    }

    override void ResetAfterSucceed(stream s)
    {
        base.ResetAfterSucceed(s);
        totalPDULength = 0;
        dataSegmentLength = 0;
        paddingLength = 0;
    }
}

optional any message DecodeAndDispatchVendorSpecificMessage(stream str, bool isAccepts, bool hasHeaderDigest, bool hasDataDigest, uint dataSegmentLength, uint paddingLength)
{
    switch (str)
    {
        case m: Messages.VendorSpecificMessage from BinaryDecoder<Messages.VendorSpecificMessage> =>
            int headerDigestBeginPos = str.BitPosition;
            m.HeaderDigest = GetDigest(str, hasHeaderDigest);
            if (m.HeaderDigest != nothing)
            {
                m.AssignFieldEncodingInfo("HeaderDigest", headerDigestBeginPos, 32);
            }
            int dataBeginPos = str.BitPosition;
            m.DataSegment = GetDataSegment(str, dataSegmentLength);
            if (m.DataSegment != nothing)
            {
                m.AssignFieldEncodingInfo("DataSegment", dataBeginPos, dataSegmentLength * 8 as int);
            }
            int paddingBeginPos = str.BitPosition;
            m.Padding = GetDataSegmentPadding(str, paddingLength);
            if (m.Padding != nothing)
            {
                m.AssignFieldEncodingInfo("Padding", paddingBeginPos, paddingLength * 8 as int);
            }
            int dataDigestBeginPos = str.BitPosition;
            m.DataDigest = GetDigest(str, dataSegmentLength, hasDataDigest);
            if (m.DataDigest != nothing)
            {
                m.AssignFieldEncodingInfo("DataDigest", dataDigestBeginPos, 32);
            }
            return m as any message;
        default =>
            return nothing;
    }
}

optional any DecodeOutgoingData(ScsiCommandParameters info, binary s)
{
    switch (info.OperationCode)
    {
        case CommandOperationCode.Unmap =>
            return BinaryDecoder<UnmapParameterList>(s);
        case CommandOperationCode.FormatUnit =>
            return BinaryDecoder<FormatUnitParameterList[(info.Auxiliary1 != 0), info.Auxiliary2 as byte]>(s);
        case CommandOperationCode.ReassignBlocks =>
            return BinaryDecoder<ReassignBlocksParameterList[(info.Auxiliary1 != 0), (info.Auxiliary2 != 0)]>(s);
        case CommandOperationCode.Sanitize =>
            return BinaryDecoder<OverwriteServiceActionParameterList>(s);
        case CommandOperationCode.SendDiagnostic =>
            switch (s)
            {
                case pg:RebuildAssistOutputDiagnosticPage from BinaryDecoder<RebuildAssistOutputDiagnosticPage> =>
                    return pg;
                case pg:TranslateAddressOutputDiagnosticPage from BinaryDecoder<TranslateAddressOutputDiagnosticPage> =>
                    return pg;
                case pg:ProtocolSpecificDiagnosticPage from BinaryDecoder<ProtocolSpecificDiagnosticPage> =>
                    return pg;
                case pg:SupportedDiagnosticPagesDiagnosticPage from BinaryDecoder<SupportedDiagnosticPagesDiagnosticPage> =>
                    return pg;
                case pg:DiagnosticPage from BinaryDecoder<DiagnosticPage> =>
                    return pg;
                default =>;
            }
        case CommandOperationCode.LogSelect =>
            stream ss = s;
            array<any> pages = [];
            while (ss.RemainingByteLength > 0)
            {
                var page = BinaryDecoder<LogPage>(ss);
                if (page == nothing)
                {
                    break;
                }
                else
                {
                    pages += [page];
                }
            }
            if (pages.Count > 0)
            {
                return pages;
            }
        case CommandOperationCode.ModeSelect6 =>
            return BinaryDecoder<ModeParameterList6>(s);
        case CommandOperationCode.ModeSelect10 =>
            return BinaryDecoder<ModeParameterList10>(s);
        case CommandOperationCode.MaintenanceOut =>
            switch (info.ServiceAction)
            {
                case 0x0E =>
                    return BinaryDecoder<SetPriorityParameterList>(s);
                case 0x0A =>
                    return BinaryDecoder<SetTargetPortGroupsParameterList>(s);
                case 0x0F =>
                    return BinaryDecoder<SetTimestampParameterList>(s);
                case 0x0B =>
                    return BinaryDecoder<ChangeAliasesParameterList>(s);
                case 0x0C =>
                    return BinaryDecoder<RemoveITNexusParameterList>(s);
                default =>;
            }
        case CommandOperationCode.WriteAttribute =>
            return BinaryDecoder<WriteAttributeParameterList>(s);
        case CommandOperationCode.SecurityProtocolOut =>
            switch (info.ServiceAction)
            {
                case 0x41 =>
                    return BinaryDecoder<Ikev2ScsiSecurityParameterData>(s);
                case 0x07 =>
                    return BinaryDecoder<CbCsSecurityProtocolOutParameterData>(s);
                default =>;
            }
        case CommandOperationCode.OperationCode83 =>
            switch (info.ServiceAction)
            {
                case 0x10 =>
                    return BinaryDecoder<PopulateTokenParameterList>(s);
                case 0x11 =>
                    return BinaryDecoder<WriteUsingTokenParameterList>(s);
                case 0x01 =>
                    return BinaryDecoder<ExtendedCopyLID4ParameterList>(s);
                case 0x00 =>
                    return BinaryDecoder<ExtendedCopyLID1ParameterList>(s);
                default =>;
            }
        case CommandOperationCode.PersistentReserveOut =>
            if (info.ServiceAction == 0x07)
            {
                return BinaryDecoder<RegisterAndMoveServiceActionParameterList>(s);
            }
            else
            {
                return BinaryDecoder<PersistentReserveOutParameterList>(s);
            }
        default =>;
    }
    return nothing;
}

optional any DecodeIncomingData(ScsiCommandParameters info, binary s)
{
    switch (info.OperationCode)
    {
        case CommandOperationCode.ReadCapacity10 =>
            return BinaryDecoder<ReadCapacity10ParameterData>(s);
        case CommandOperationCode.ReadDefectData10 =>
            return BinaryDecoder<ReadDefectData10ParameterData>(s);
        case CommandOperationCode.ReadDefectData12 =>
            return BinaryDecoder<ReadDefectData12ParameterData>(s);
        case CommandOperationCode.Inquiry =>
            if (info.Auxiliary1 == 0xFF)
            {
                return BinaryDecoder<StandardInquiryData>(s);
            }
            else
            {
                return BinaryDecoder<VPDPage>(s);
            }
        case CommandOperationCode.ReceiveDiagnosticResults =>
            switch (s)
            {
                case pg:RebuildAssistInputDiagnosticPage from BinaryDecoder<RebuildAssistInputDiagnosticPage> =>
                    return pg;
                case pg:TranslateAddressInputDiagnosticPage from BinaryDecoder<TranslateAddressInputDiagnosticPage> =>
                    return pg;
                case pg:ProtocolSpecificDiagnosticPage from BinaryDecoder<ProtocolSpecificDiagnosticPage> =>
                    return pg;
                case pg:SupportedDiagnosticPagesDiagnosticPage from BinaryDecoder<SupportedDiagnosticPagesDiagnosticPage> =>
                    return pg;
                case pg:DiagnosticPage from BinaryDecoder<DiagnosticPage> =>
                    return pg;
                default =>;
            }
        case CommandOperationCode.LogSense =>
            return BinaryDecoder<LogPage>(s);
        case CommandOperationCode.ModeSense6 =>
            return BinaryDecoder<ModeParameterList6>(s);
        case CommandOperationCode.ModeSense10 =>
            return BinaryDecoder<ModeParameterList10>(s);
        case CommandOperationCode.PersistentReserveIn =>
            switch (info.ServiceAction)
            {
                case 0x00 =>
                    return BinaryDecoder<ReadKeysPersistentReserveInParameterData>(s);
                case 0x01 =>
                    return BinaryDecoder<ReadReservationPersistentReserveInParameterData>(s);
                case 0x02 =>
                    return BinaryDecoder<ReportCapabilitiesPersistentReserveInParameterData>(s);
                case 0x03 =>
                    return BinaryDecoder<ReadFullStatusPersistentReserveInParameterData>(s);
                default =>;
            }
        case CommandOperationCode.ReadAttribute =>
            switch (info.ServiceAction)
            {
                case 0x00 =>
                    return BinaryDecoder<AttributeValuesServiceActionParameterList>(s);
                case 0x01 =>
                    return BinaryDecoder<AttributeListServiceActionParameterList>(s);
                case 0x02 =>
                    return BinaryDecoder<LogicalVolumeListServiceActionParameterList>(s);
                case 0x03 =>
                    return BinaryDecoder<PartitionListServiceActionParameterList>(s);
                case 0x05 =>
                    return BinaryDecoder<SupportedAttributesServiceActionParameterList>(s);
                default =>;
            }
        case CommandOperationCode.ReadBuffer =>
            switch (info.Auxiliary1)
            {
                case 0x00 =>
                    return BinaryDecoder<ReadBufferHeader>(s);
                case 0x03 =>
                    return BinaryDecoder<ReadBufferDescriptor>(s);
                case 0x0B =>
                    return BinaryDecoder<EchoBufferDescriptor>(s);
                case 0x1C =>
                    return BinaryDecoder<ErrorHistoryDirectory>(s);
                default =>;
            }
        case CommandOperationCode.ReadMediaSerialNumber =>
            return BinaryDecoder<ReadMediaSerialNumberParameterData>(s);
        case CommandOperationCode.MaintenanceIn =>
            switch (info.ServiceAction)
            {
                case 0x0B =>
                    return BinaryDecoder<ReportAliasesParameterData>(s);
                case 0x05 =>
                    switch (info.Auxiliary1)
                    {
                        case 0x00 =>
                            return BinaryDecoder<PeripheralDeviceIdentifyingInformationParameterData>(s);
                        case 0x02 =>
                            return BinaryDecoder<PeripheralDeviceTextIdentifyingInformationParameterData>(s);
                        case 0x7F =>
                            return BinaryDecoder<IdentifyingInformationSupportedParameterData>(s);
                        default =>;
                    }
                case 0x0E =>
                    return BinaryDecoder<ReportPriorityParameterData>(s);
                case 0x0C =>
                    if (info.Auxiliary1 == 0x00)
                    {
                        return BinaryDecoder<AllCommandsParameterData>(s);
                    }
                    else
                    {
                        return BinaryDecoder<OneCommandParameterData>(s);
                    }
                case 0x0D =>
                    if (info.Auxiliary1 == 0x00)
                    {
                        return BinaryDecoder<ReportSupportedTaskManagementFunctionsBasicParameterData>(s);
                    }
                    else
                    {
                        return BinaryDecoder<ReportSupportedTaskManagementFunctionsExtendedParameterData>(s);
                    }
                case 0x0A =>
                    if (info.Auxiliary1 == 0x00)
                    {
                        return BinaryDecoder<LengthOnlyHeaderParameterData>(s);
                    }
                    else
                    {
                        return BinaryDecoder<ExtendedHeaderParameterData>(s);
                    }
                case 0x0F =>
                    return BinaryDecoder<ReportTimestampCommandParameters>(s);
                case 0x10 =>
                    return BinaryDecoder<SupportedManagementProtocolsManagementProtocolInParameterData>(s);
                default =>;
            }
        case CommandOperationCode.OperationCode84 =>
            switch (info.ServiceAction)
            {
                case 0x08 =>
                    return BinaryDecoder<ReportAllRodTokensParameterData>(s);
                case 0x07 =>
                    return BinaryDecoder<ReceiveRodTokenInformationParameterData>(s);
                default =>;
            }
        case CommandOperationCode.ReportLuns =>
            return BinaryDecoder<ReportLunsParameterData>(s);
        case CommandOperationCode.RequestSense =>
            if (info.Auxiliary1 == 0x00)
            {
                return BinaryDecoder<FixedFormatSenseData>(s);
            }
            else
            {
                return BinaryDecoder<DescriptorFormatSenseData>(s);
            }
        case CommandOperationCode.SecurityProtocolIn =>
            switch (info.ServiceAction)
            {
                case 0x00 =>
                    switch (info.Auxiliary1)
                    {
                        case 0x0000 =>
                            return BinaryDecoder<SupportedSecurityProtocolsSecurityProtocolInParameterData>(s);
                        case 0x0001 =>
                            return BinaryDecoder<CertificateDataSecurityProtocolInParameterData>(s);
                        case 0x0002 =>
                            return BinaryDecoder<SecurityComplianceInformationSecurityProtocolInParameterData>(s);
                        default =>;
                    }
                case 0x40 =>
                    switch (info.Auxiliary1)
                    {
                        case 0x0000 =>
                            return BinaryDecoder<SupportedDeviceServerCapabilitiesFormatsParameterData>(s);
                        case 0x0101 =>
                            return BinaryDecoder<Ikev2ScsiDeviceServerCapabilitiesParameterData>(s);
                        default =>;
                    }
                case 0x41 =>
                    return BinaryDecoder<Ikev2ScsiSecurityParameterData>(s);
                case 0x07 =>
                    return BinaryDecoder<CbCsSecurityProtocolInParameterData>(s);
                default =>;
            }
        case CommandOperationCode.ServiceActionIn16 =>
            switch (info.ServiceAction)
            {
                case 0x12 =>
                    return BinaryDecoder<GetLbaStatusParameterData>(s);
                case 0x10 =>
                    return BinaryDecoder<ReadCapacity16ParameterData>(s);
                case 0x13 =>
                    return BinaryDecoder<ReportReferralsParameterData>(s);
                default =>;
            }
        default =>;
    }
    return nothing;
}

string GetScsiCommandDescriptorBlockSummaryString(ScsiCommandDescriptorBlock cdb)
{
    string summary = "";
    switch (cdb.CommandSpecificParameters)
    {
        case p:Read6CommandParameters =>
            summary += ", TransferLength: " + p.TransferLength.ToString();
        case p:Read10CommandParameters =>
            summary += ", TransferLength: " + p.TransferLength.ToString();
        case p:Read12CommandParameters =>
            summary += ", TransferLength: " + p.TransferLength.ToString();
        case p:Read16CommandParameters =>
            summary += ", TransferLength: " + p.TransferLength.ToString();
        case p:Write6CommandParameters =>
            summary += ", TransferLength: " + p.TransferLength.ToString();
        case p:Write10CommandParameters =>
            summary += ", TransferLength: " + p.TransferLength.ToString();
        case p:Write12CommandParameters =>
            summary += ", TransferLength: " + p.TransferLength.ToString();
        case p:Write16CommandParameters =>
            summary += ", TransferLength: " + p.TransferLength.ToString();
        case p:LogSelectCommandParameters =>
            summary += ", PageCode: " + Utility.DecToHexFormat(p.PageCode) + ", SubPageCode: " + Utility.DecToHexFormat(p.SubpageCode);
        case p:PersistentReserveOutCommandParameters =>
            summary += ", ServiceAction: " + 
                (InRange<PersistentReserveOutServiceAction>(p.ServiceAction) ? 
                EnumToString(p.ServiceAction, "iSCSI.PersistentReserveOutServiceAction") : Utility.DecToHexFormat(p.ServiceAction));
        case p:InquiryCommandParameters =>
            if (p.EVPD)
            {
                summary += ", PageCode: " + (InRange<VPDPageCode>(p.PageCode) ? EnumToString(p.PageCode, "iSCSI.VPDPageCode") : Utility.DecToHexFormat(p.PageCode));
            }
        case p:LogSenseCommandParameters =>
            summary += ", PageCode: " + Utility.DecToHexFormat(p.PageCode) + ", SubPageCode: " + Utility.DecToHexFormat(p.SubpageCode);
        case p:ModeSense6CommandParameters =>
            summary += ", PageCode: " + Utility.DecToHexFormat(p.PageCode) + ", SubPageCode: " + Utility.DecToHexFormat(p.SubpageCode);
        case p:ModeSense10CommandParameters =>
            summary += ", PageCode: " + Utility.DecToHexFormat(p.PageCode) + ", SubPageCode: " + Utility.DecToHexFormat(p.SubpageCode);
        case p:PersistentReserveInCommandParameters =>
            summary += ", ServiceAction: " +
                (InRange<PersistentReserveInServiceAction>(p.ServiceAction) ? 
                EnumToString(p.ServiceAction, "iSCSI.PersistentReserveInServiceAction") : Utility.DecToHexFormat(p.ServiceAction));
        case p:ReadAttributeCommandParameters =>
            summary += ", ServiceAction: " +
                (InRange<ReadAttributeServiceAction>(p.ServiceAction) ? 
                EnumToString(p.ServiceAction, "iSCSI.ReadAttributeServiceAction") : Utility.DecToHexFormat(p.ServiceAction));
        case p:ReadBufferCommandParameters =>
            summary += ", Mode: " + (InRange<ReadBufferMode>(p.Mode) ? EnumToString(p.Mode, "iSCSI.ReadBufferMode") : Utility.DecToHexFormat(p.Mode));
        case p:WriteBufferCommandParameters =>
            summary += ", Mode: " + (InRange<WriteBufferMode>(p.Mode) ? EnumToString(p.Mode, "iSCSI.WriteBufferMode") : Utility.DecToHexFormat(p.Mode));
        case p:OrWrite16CommandParameters =>
            summary += ", TransferLength: " + p.TransferLength.ToString();
        case p:PreFetch10CommandParameters =>
            summary += ", PrefetchLength: " + p.PrefetchLength.ToString();
        case p:PreFetch16CommandParameters =>
            summary += ", PrefetchLength: " + p.PrefetchLength.ToString();
        case p:ReadLong10CommandParameters =>
            summary += ", ByteTransferLength: " + p.ByteTransferLength.ToString();
        case p:ReadLong16CommandParameters =>
            summary += ", ByteTransferLength: " + p.ByteTransferLength.ToString();
        case p:Verify10CommandParameters =>
            summary += ", VerificationLength: " + p.VerificationLength.ToString();
        case p:Verify12CommandParameters =>
            summary += ", VerificationLength: " + p.VerificationLength.ToString();
        case p:Verify16CommandParameters =>
            summary += ", VerificationLength: " + p.VerificationLength.ToString();
        case p:WriteAndVerify10CommandParameters =>
            summary += ", TransferLength: " + p.TransferLength.ToString();
        case p:WriteAndVerify12CommandParameters =>
            summary += ", TransferLength: " + p.TransferLength.ToString();
        case p:WriteAndVerify16CommandParameters =>
            summary += ", TransferLength: " + p.TransferLength.ToString();
        case p:WriteLong10CommandParameters =>
            summary += ", ByteTransferLength: " + p.ByteTransferLength.ToString();
        case p:WriteLong16CommandParameters =>
            summary += ", ByteTransferLength: " + p.ByteTransferLength.ToString();
        case p:XDWriteRead10CommandParameters =>
            summary += ", TransferLength: " + p.TransferLength.ToString();
        case p:XPWrite10CommandParameters =>
            summary += ", TransferLength: " + p.TransferLength.ToString();
        default =>;
    }
    return summary;
}

string GetVariableLengthCommandDescriptorBlockSummaryString(VariableLengthCommandDescriptorBlock cdb)
{
    string summary = "";
    switch (cdb.CommandParameters)
    {
        case p:OrWrite32CommandParameters =>
            summary += ", TransferLength: " + p.TransferLength.ToString();
        case p:Read32CommandParameters =>
            summary += ", TransferLength: " + p.TransferLength.ToString();
        case p:Verify32CommandParameters =>
            summary += ", VerificationLength: " + p.VerificationLength.ToString();
        case p:Write32CommandParameters =>
            summary += ", TransferLength: " + p.TransferLength.ToString();
        case p:WriteAndVerify32CommandParameters =>
            summary += ", TransferLength: " + p.TransferLength.ToString();
        case p:XDWriteRead32CommandParameters =>
            summary += ", TransferLength: " + p.TransferLength.ToString();
        case p:XPWrite32CommandParameters =>
            summary += ", TransferLength: " + p.TransferLength.ToString();
    }
    return summary;
}
