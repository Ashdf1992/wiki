protocol SMB with
BinaryEncodingDefaults{Endian = Endian.Little},
Documentation
{
    ProtocolName = "Server Message Block (SMB) Protocol",
    ShortName = "SMB"
},
OPNAuthoring
{
    Copyright = "(c) Microsoft Corporation",
    References = 
        [
            new Reference{Name = "MS-CIFS", Version = "26.0", Date = "07/14/2016", ProgramName = ProgramName.WSPP},
            new Reference{Name = "MS-SMB", Version = "46.0", Date = "06/01/2017", ProgramName = ProgramName.WSPP},
            new Reference{Name = "SMB-LM21", Version = "3.4", Link = "http://www.cifs.org/mediawiki/images/b/b9/1992-02-29-SMB-LM21.pdf"},
        ],
    RevisionSummary = 
        [
            new Revision{Class = RevisionClass.Major, Version = "383633", Date = "01/11/2016"}
        ]
};

using Standard;
using Utility;
using DTYP;
using ERREF;
using FSCC;
using NBTSS;
using NBF;
using Diagnostics;
using InfrastructureResources;
using SMBTransport;
using MSRPCE;
using GSSAPI;
using NLMP;
using FAS;
using FileSharingResources;

annotation string FileRequest#SMBFileName;
annotation string FileResponse#SMBFileName;
// Keep the command name for SmbHeader message
annotation string SmbHeader#SMBMessageName;
// Keep Information for Gssapi, NLMP messages.
annotation string SmbHeader#KeyInformation;

annotation binary Messages.ComNegotiateRequest#EndpointIndex;

autostart actor MsrpceOverSmbServer(SMB.Server server)
{
    MSRPCEOverNamedpipeDecodingHelper helper = null;
    
    process server accepts s:SMB.Messages.ComTransactionRequest where s.Request.TransData is bin:binary && 
        (helper != null && helper.AcceptsCache.BufferCount() > 0 || IsRpcconnCommonHdrT(bin) && bin[2] in AcceptsMsgTypeSet)
    {
        EnsureInitialized();
        helper.TryDecode(bin, s, MessageDirection.Accepts);
    }

    process server issues s:SMB.Messages.ComTransactionResponse where s.Response.TransData is bin:binary && 
        (helper != null && helper.IssuesCache.BufferCount() > 0 || IsRpcconnCommonHdrT(bin) && bin[2] in IssuesMsgTypeSet)
    {
        EnsureInitialized();
        helper.TryDecode(bin, s, MessageDirection.Issues);
    }

    process server accepts s:SMB.Messages.ComWriteAndxRequest where s.Request.Data is bin:binary && 
        (helper != null && helper.AcceptsCache.BufferCount() > 0 || IsRpcconnCommonHdrT(bin) && bin[2] in AcceptsMsgTypeSet)
    {
        EnsureInitialized();
        helper.TryDecode(bin, s, MessageDirection.Accepts);
    }

    process server issues s:SMB.Messages.ComReadAndxResponse where s.Response.Data is bin:binary && 
        (helper != null && helper.IssuesCache.BufferCount() > 0 || IsRpcconnCommonHdrT(bin) && bin[2] in IssuesMsgTypeSet)
    {
        EnsureInitialized();
        helper.TryDecode(bin, s, MessageDirection.Issues);
    }
    
    ~endpoint(SMB.Server server)
    {
        if (helper != null)
        {
            helper.ClearInDestructor();
        }
    }

    void EnsureInitialized()
    {
        if (helper == null)
        {
            helper = new MSRPCEOverNamedpipeDecodingHelper{};
            helper.Initialize(endpoint MSRPCE.Server over server);
        }
    }
}

/* For performance consideration, file is reassembled only when there're upper layer file protocol implemented.
 * For SMB, file accessed by command is reassembled: SMB_COM_READ, SMB_COM_READ_ANDX, SMB_COM_WRITE_ANDX
 * File accessed by following commands is not reassembled due to there're obsoleted or deprecated:
 *         SMB_COM_LOCK_AND_READ (deprecated)
 *         SMB_COM_READ_RAW (deprecated)
 *         SMB_COM_READ_MPX (obsolescent)
 *         SMB_COM_WRITE (deprecated)
 *         SMB_COM_WRITE_AND_UNLOCK (deprecated)
 *         SMB_COM_WRITE_RAW (deprecated)
 *         SMB_COM_WRITE_MPX (obsolescent)
 *         SMB_COM_WRITE_AND_CLOSE (deprecated)
 * File accessed by batched command is not reassembled.
 */
autostart actor ReassembleFileOverSMBActor(SMB.Server smbServer)
{
    FAS.Server FASServer = null;
    process smbServer accepts req:Messages.ComWriteAndxRequest 
                where req.FileNameReference is fileName:string && NeedFASReassemble(fileName) && CalculateRealSmbOffset(req.Request.Offset, req.Request.OffsetHigh) is offset:ulong && offset == 0 || 
                    FASServer != null && FASServer.Command == CommandType.Write
    {   
        if (offset == 0)
        {
            FASServer = FAS.InitializeFASServer(smbServer, CommandType.Write, 
                (any message m, FAS.Server fasServer) => CalculateRealSmbOffset(((m as Messages.ComWriteAndxRequest)).Request.Offset, ((m as Messages.ComWriteAndxRequest)).Request.OffsetHigh), 
                (any message m) => ((m as Messages.ComWriteAndxRequest).Request.Data as binary), 
                fileName);
        }
        dispatch FASServer accepts req;
    }
    
    observe smbServer accepts req:Messages.ComReadAndxRequest 
                where req.FileNameReference is fileName:string && NeedFASReassemble(fileName) && CalculateRealSmbOffset(req.Request.Offset, req.Request.OffsetHigh) is offset:ulong &&
                    offset == 0 || FASServer != null && FASServer.Command == CommandType.Read
    {
        if (offset == 0)
        {
            FASServer = FAS.InitializeFASServer(smbServer, CommandType.Read, 
                (any message m, FAS.Server fasServer) => (fasServer.ReadResponseOffset != null ? (fasServer.ReadResponseOffset as ulong) : 0xFFFFFFFFFFFFFFFF), 
                (any message m) => ((m as Messages.ComReadAndxResponse).Response.Data as binary), 
                fileName);
        }
        FASServer.ReadResponseOffset = offset;
    }
    
    process smbServer issues res:Messages.ComReadAndxResponse 
        where res.FileNameReference is fileName:string && NeedFASReassemble(fileName) && FASServer != null && FASServer.Command == CommandType.Read
    {
        dispatch FASServer issues res;
    }

    observe smbServer accepts req:Messages.ComReadRequest 
        where req.FileNameReference is fileName:string && NeedFASReassemble(fileName) && req.Request.ReadOffsetInBytes is offset:uint &&
            offset == 0 || FASServer != null && FASServer.Command == CommandType.Read
    {
        if (offset == 0)
        {
            FASServer = FAS.InitializeFASServer(smbServer, CommandType.Read, 
                (any message m, FAS.Server fasServer) => (fasServer.ReadResponseOffset != null ? (fasServer.ReadResponseOffset as ulong) : 0xFFFFFFFFFFFFFFFF), 
                (any message m) => ((m as Messages.ComReadResponse).Response.Bytes as binary), 
                fileName);
        }
        FASServer.ReadResponseOffset = offset;
    }
    
    process smbServer issues res:Messages.ComReadResponse 
        where res.FileNameReference is fileName:string && NeedFASReassemble(fileName) && FASServer != null && FASServer.Command == CommandType.Read
    {
        dispatch FASServer issues res;
        FASServer.ReadResponseOffset = null;
    }
    
    process smbServer accepts closeReq:Messages.ComCloseRequest where FASServer != null
    {
        dispatch FASServer accepts closeReq;
        FASServer.HasCloseRequestAccepted = true;
    }
}

endpoint Server over LowestServer | over FileServer provides Messages provides VirtualOperations accepts SmbRequest issues SmbResponse;
client endpoint Client connected to Server;

endpoint FileServer[string File] over LowestServer provides Messages accepts SmbRequest issues SmbResponse
{
    process this accepts m:SmbRequest
    {
        dispatch (endpoint Server over this) accepts m;
    }
    
    process this issues m:SmbResponse
    {
        dispatch (endpoint Server over this) issues m;
    }
}
client endpoint FileClient connected to FileServer;

endpoint LowestServer
    over SMBTransport.Server | over NBTSS.Server | over NBF.Node
    provides Messages accepts SmbRequest issues SmbResponse
{
    DecoderVariables dvar = new DecoderVariables{};
    map<ushort, array<Messages.ComTransactionResponse>> transMessages = {};
    map<ushort, array<Messages.ComTransaction2Response>> trans2Messages = {};
    map<ushort, array<Messages.ComNTTransactResponse>> ntTransMessages = {};
    
    process this accepts m:Messages.ComTransactionRequest where m.Command == SmbCommand.SMB_COM_TRANSACTION
    {
        string index = InitialIndex; // when no Fid, give a initial value
        if (!(m.Request.Fid is nothing))
        {
            ushort fid = m.Request.Fid as ushort;
            index = dvar.GetIndex(m.Mid, fid, false, false);
            m#SMBFileName = index;
        }
        dispatch (endpoint FileServer[index] over this) accepts m;
    }
    
    process this issues m:Messages.ComTransactionResponse where m.Command == SmbCommand.SMB_COM_TRANSACTION
    {
        if (m.Response.TransData != nothing && (m.Response.TransData is binary) && (m.Response.TransData as binary).Count < m.Response.DataCount) //deal with messages contains insufficient data
        {
            DisplayTopLevelMessage(m);
            ReportInsufficientTruncation(m, "SMB", "TransData", "ComTransactionResponse", !dvar.pduFull);
            if (m.Mid in transMessages)
            {
                foreach(var transRsp in transMessages[m.Mid])
                {
                    DisplayTopLevelMessage(transRsp);
                }
            }
            if (m.Mid in dvar.Subcommand)
            {
                dvar.Subcommand = dvar.Subcommand.Remove(m.Mid);
            }
            transMessages = transMessages.Remove(m.Mid);
        }
        else if (IsCompletedResponse(m.Response.ParameterDisplacement, m.Response.ParameterCount, m.Response.TotalParameterCount) && IsCompletedResponse(m.Response.DataDisplacement, m.Response.DataCount, m.Response.TotalDataCount))
        {
            m#SMBFileId = (m.Mid in dvar.FidForRsp) ? (dvar.FidForRsp[m.Mid] as ulong) : nothing;
            string index = dvar.GetIndex(m.Mid);
            m#SMBFileName = index;
            dispatch (endpoint FileServer[index] over this) issues m;
        }
        else
        {
            if (!(m.Mid in transMessages.Keys))
            {
                transMessages[m.Mid] = [m];
            }
            else
            {
                transMessages[m.Mid] = transMessages[m.Mid].InsertSorted<Messages.ComTransactionResponse>(
                    (Messages.ComTransactionResponse r1, Messages.ComTransactionResponse r2) => r1.Response.ParameterDisplacement == r2.Response.ParameterDisplacement ? r1.Response.DataDisplacement - r2.Response.DataDisplacement : r1.Response.ParameterDisplacement - r2.Response.ParameterDisplacement,
                    m);
                array<Messages.ComTransactionResponse> comTransactionResponse = transMessages[m.Mid];
                Messages.ComTransactionResponse lastRsp = comTransactionResponse[comTransactionResponse.Count - 1];
                /* The data part in response is made up of TransParameter and TransData, TransParameter is before TransData.
                 * when there is no TransData, only check whether TransParameters is sequential and completed,
                 * otherwise only check  whether TransData is sequential and completed.
                 * if TransData is completed, TransParameter must be completed
                */
                if (lastRsp.Response.TotalDataCount == 0 ?
                    IsFragmentsSequentialCompleted<Messages.ComTransactionResponse>(comTransactionResponse,
                        (Messages.ComTransactionResponse r) => r.Response.ParameterDisplacement == 0,
                        (Messages.ComTransactionResponse r) => r.Response.ParameterDisplacement + r.Response.ParameterCount == r.Response.TotalParameterCount,
                        (Messages.ComTransactionResponse r) => r.Response.ParameterDisplacement,
                        (Messages.ComTransactionResponse r) => r.Response.ParameterDisplacement + r.Response.ParameterCount) :
                    IsFragmentsSequentialCompleted<Messages.ComTransactionResponse>(comTransactionResponse,
                        (Messages.ComTransactionResponse r) => r.Response.DataDisplacement == 0,
                        (Messages.ComTransactionResponse r) => r.Response.DataDisplacement + r.Response.DataCount == r.Response.TotalDataCount,
                        (Messages.ComTransactionResponse r) => r.Response.DataDisplacement,
                        (Messages.ComTransactionResponse r) => r.Response.DataDisplacement + r.Response.DataCount))
                {
                    binary buffer = $[];
                    for (int j = 0; j < comTransactionResponse.Count; j++)
                    {
                        if (j == 0)
                        {
                            binary temp = comTransactionResponse[0].SourceData as binary;
                            buffer = temp.Segment(0, 39) + temp.Segment(33, 2) // make ParameterCount same as TotalParameterCount
                                 + temp.Segment(41, 4) + temp.Segment(35, 2) // make DataCount same as TotalDataCount
                                 + temp.Segment(47);
                        }
                        else
                        {
                            if (comTransactionResponse[j].Response.TransParameters != nothing)
                            {
                                buffer += comTransactionResponse[j].Response.TransParameters as binary;
                            }
                            if (comTransactionResponse[j].Response.TransData != nothing)
                            {
                                buffer += comTransactionResponse[j].Response.TransData as binary;
                            }
                        }
                    }
                    transMessages = transMessages.Remove(m.Mid);
                    stream s = buffer;
                    var fid = (m.Mid in dvar.FidForRsp) ? dvar.FidForRsp[m.Mid] : 0;
                    string index = dvar.GetIndex(m.Mid);
                    ushort mid = MakeWord(s.PeekByte(248), s.PeekByte(240));
                    optional ushort subcommand = mid in dvar.Subcommand.Keys ? dvar.Subcommand[mid] : nothing;
                    switch (s)
                    {
                        case msg:Messages.ComTransactionResponse from BinaryDecoder<Messages.ComTransactionResponse[subcommand]> =>
                            SmbStatusErrorCodeIf(msg, DiagnosisLevel.Warning);
                            if (msg.Response.TotalParameterCount == msg.Response.ParameterCount && msg.Response.TotalDataCount == msg.Response.DataCount && msg.Mid in dvar.Subcommand.Keys)
                            {
                                dvar.Subcommand = dvar.Subcommand.Remove(msg.Mid);
                            }
                            msg#SMBFileId = (fid as ulong);
                            dispatch (endpoint FileServer[index] over this) issues msg;
                        default =>
                            TryDecodeHeaderOnlyMessage(s, "ComTransactionResponse", true, 0x0A);
                    }
                }
            }
        }
    }
    
    process this accepts m:Messages.ComTransaction2Request where m.Command == SmbCommand.SMB_COM_TRANSACTION2
    {
        string index = InitialIndex; // when no Fid, give a initial value
        if ((m.Request.Trans2Parameters is param:Trans2SubcommandRequestParameters) && 
            (param.Parameters is p1:Trans2SetFSInformationRequestParameters ||
            param.Parameters is p2:Trans2QueryFileInformationRequestParameters ||
            param.Parameters is p3:Trans2SetFileInformationRequestParameters))
        {
            ushort fid = 0;
            if (p1 != null)
            {
                fid = p1.Fid;
            }
            else if (p2 != null)
            {
                fid = p2.Fid;
            }
            else if (p3 != null)
            {
                fid = p3.Fid;
            }
            index = dvar.GetIndex(m.Mid, fid, false, false);
            m#SMBFileName = index;
        }
        dispatch (endpoint FileServer[index] over this) accepts m;
    }

    process this issues m:Messages.ComTransaction2Response where m.Command == SmbCommand.SMB_COM_TRANSACTION2
    {
        if (m.Response is SmbComTransaction2Response)
        {
            SmbComTransaction2Response rsp = m.Response as SmbComTransaction2Response;
            if (rsp.Trans2Data != nothing && (rsp.Trans2Data is binary) && (rsp.Trans2Data as binary).Count < rsp.DataCount) //deal with messages contains insufficient data
            {
                DisplayTopLevelMessage(m);
                ReportInsufficientTruncation(m, "SMB", "Trans2Data", "ComTransaction2Response", !dvar.pduFull);                            
                
                if (m.Mid in trans2Messages)
                {
                    foreach(var transRsp in trans2Messages[m.Mid])
                    {
                        DisplayTopLevelMessage(transRsp);
                    }
                }
                if (m.Mid in dvar.Subcommand)
                {
                    dvar.Subcommand = dvar.Subcommand.Remove(m.Mid);
                }
                if (m.Mid in dvar.InformationLevel)
                {
                    dvar.InformationLevel = dvar.InformationLevel.Remove(m.Mid);
                }
                if (m.Mid in dvar.Trans2FindFlags)
                {
                    dvar.Trans2FindFlags = dvar.Trans2FindFlags.Remove(m.Mid);
                }
                trans2Messages = trans2Messages.Remove(m.Mid);
            }
            else if (IsCompletedResponse(rsp.ParameterDisplacement, rsp.ParameterCount, rsp.TotalParameterCount) && IsCompletedResponse(rsp.DataDisplacement, rsp.DataCount, rsp.TotalDataCount))
            {
                string index = dvar.GetIndex(m.Mid);
                m#SMBFileName = index;
                dispatch (endpoint FileServer[index] over this) issues m;
            }
            else
            {
                if (!(m.Mid in trans2Messages.Keys))
                {
                    trans2Messages[m.Mid] = [m];
                }
                else
                {
                    trans2Messages[m.Mid] = trans2Messages[m.Mid].InsertSorted<Messages.ComTransaction2Response>(
                        (Messages.ComTransaction2Response r1, Messages.ComTransaction2Response r2) => (r1.Response as SmbComTransaction2Response).ParameterDisplacement == (r2.Response as SmbComTransaction2Response).ParameterDisplacement ? (r1.Response as SmbComTransaction2Response).DataDisplacement - (r2.Response as SmbComTransaction2Response).DataDisplacement : (r1.Response as SmbComTransaction2Response).ParameterDisplacement - (r2.Response as SmbComTransaction2Response).ParameterDisplacement,
                        m);
                    array<Messages.ComTransaction2Response> comTransaction2Response = trans2Messages[m.Mid];
                    Messages.ComTransaction2Response lastRsp = comTransaction2Response[comTransaction2Response.Count - 1];
                    if ((lastRsp.Response as SmbComTransaction2Response).TotalDataCount == 0 ? 
                        IsFragmentsSequentialCompleted<Messages.ComTransaction2Response>(comTransaction2Response,
                            (Messages.ComTransaction2Response r) => (r.Response as SmbComTransaction2Response).ParameterDisplacement == 0,
                            (Messages.ComTransaction2Response r) => (r.Response as SmbComTransaction2Response).ParameterDisplacement + (r.Response as SmbComTransaction2Response).ParameterCount == (r.Response as SmbComTransaction2Response).TotalParameterCount,
                            (Messages.ComTransaction2Response r) => (r.Response as SmbComTransaction2Response).ParameterDisplacement,
                            (Messages.ComTransaction2Response r) => (r.Response as SmbComTransaction2Response).ParameterDisplacement + (r.Response as SmbComTransaction2Response).ParameterCount) :
                        IsFragmentsSequentialCompleted<Messages.ComTransaction2Response>(comTransaction2Response,
                            (Messages.ComTransaction2Response r) => (r.Response as SmbComTransaction2Response).DataDisplacement == 0,
                            (Messages.ComTransaction2Response r) => (r.Response as SmbComTransaction2Response).DataDisplacement + (r.Response as SmbComTransaction2Response).DataCount == (r.Response as SmbComTransaction2Response).TotalDataCount,
                            (Messages.ComTransaction2Response r) => (r.Response as SmbComTransaction2Response).DataDisplacement,
                            (Messages.ComTransaction2Response r) => (r.Response as SmbComTransaction2Response).DataDisplacement + (r.Response as SmbComTransaction2Response).DataCount))
                    {
                        binary buffer = $[];
                        for (int j = 0; j < comTransaction2Response.Count; j++)
                        {
                            if (j == 0)
                            {
                                binary temp = comTransaction2Response[0].SourceData as binary;
                                buffer = temp.Segment(0, 39) + temp.Segment(33, 2) + temp.Segment(41, 4) + temp.Segment(35, 2) + temp.Segment(47);
                            }
                            else
                            {
                                rsp = comTransaction2Response[j].Response as SmbComTransaction2Response;
                                if (rsp.Trans2Parameters != nothing)
                                {
                                    buffer += rsp.Trans2Parameters as binary;
                                }
                                if (rsp.Trans2Data != nothing)
                                {
                                    buffer += rsp.Trans2Data as binary;
                                }
                            }
                        }
                        trans2Messages = trans2Messages.Remove(m.Mid);
                        DecodeTransaction2Response((endpoint FileServer[dvar.GetIndex(m.Mid)] over this), buffer as stream, dvar, true, 0x0A, "ComTransaction2Response");
                    }
                }
            }
        }
        else
        {
            dispatch (endpoint Server over this) issues m;
        }
    }
    
    process this accepts m:Messages.ComNTTransactRequest where m.Command == SmbCommand.SMB_COM_NT_TRANSACT
    {
        string index = InitialIndex; // when no Fid, give a initial value

        if (m.Request.Setup is p1: NTTransactIoctlRequestSetup ||
            m.Request.Setup is p2: NTTransactNotifyChangeRequestSetup)
        {
            ushort fid = 0;
            if (p1 != null)
            {
                fid = p1.Fid;
            }
            else if (p2 != null)
            {
                fid = p2.Fid;
            }
            index = dvar.GetIndex(m.Mid, fid, false, false);
            m#SMBFileName = index;
        }
        else if (m.Request.NTTransParameters is p3: NTTransactSetSecurityDescRequestNTTransParameters ||
            m.Request.NTTransParameters is p4: NTTransactQuerySecurityDescRequestNTTransParameters ||
            m.Request.NTTransParameters is p5: NTTransactQueryQuotaRequestNTTransParameters ||
            m.Request.NTTransParameters is p6: NTTransactSetQuotaRequestNTTransParameters)
        {
            ushort fid = 0;
            if (p3 != null)
            {
                fid = p3.Fid;
            }
            else if (p4 != null)
            {
                fid = p4.Fid;
            }
            else if (p5 != null)
            {
                fid = p5.Fid;
            }
            else if (p6 != null)
            {
                fid = p6.Fid;
            }
            index = dvar.GetIndex(m.Mid, fid, false, false);
            m#SMBFileName = index;
        }
        dispatch (endpoint FileServer[index] over this) accepts m;
    }

    process this issues m:Messages.ComNTTransactResponse where m.Command == SmbCommand.SMB_COM_NT_TRANSACT
    {
        if (m.Response.Data != nothing && (m.Response.Data is binary) && (m.Response.Data as binary).Count < m.Response.DataCount) //deal with messages contains insufficient data
        {
            DisplayTopLevelMessage(m);
            ReportInsufficientTruncation(m, "SMB", "Data", "ComNTTransactResponse", !dvar.pduFull);                            
            
            if (m.Mid in ntTransMessages)
            {
                foreach(var transRsp in ntTransMessages[m.Mid])
                {
                    DisplayTopLevelMessage(transRsp);
                }
            }
            if (m.Mid in dvar.Subcommand)
            {
                dvar.Subcommand = dvar.Subcommand.Remove(m.Mid);
            }
            if (m.Mid in dvar.IoctlFunctionCode)
            {
                dvar.IoctlFunctionCode = dvar.IoctlFunctionCode.Remove(m.Mid);
            }
            ntTransMessages = ntTransMessages.Remove(m.Mid);
        }
        else if (IsCompletedResponse(m.Response.ParameterDisplacement, m.Response.ParameterCount, m.Response.TotalParameterCount) && IsCompletedResponse(m.Response.DataDisplacement, m.Response.DataCount, m.Response.TotalDataCount))
        {
            string index = dvar.GetIndex(m.Mid);
            m#SMBFileName = index;
            dispatch (endpoint FileServer[index] over this) issues m;
        }
        else
        {
            if (!(m.Mid in ntTransMessages.Keys))
            {
                ntTransMessages[m.Mid] = [m];
            }
            else
            {
                ntTransMessages[m.Mid] = ntTransMessages[m.Mid].InsertSorted<Messages.ComNTTransactResponse>(
                    (Messages.ComNTTransactResponse r1, Messages.ComNTTransactResponse r2) => r1.Response.ParameterDisplacement == r2.Response.ParameterDisplacement ? (r1.Response.DataDisplacement as int) - (r2.Response.DataDisplacement as int) : (r1.Response.ParameterDisplacement as int) - (r2.Response.ParameterDisplacement as int),
                    m);
                array<Messages.ComNTTransactResponse> comNTTransactResponse = ntTransMessages[m.Mid];
                Messages.ComNTTransactResponse lastRsp = comNTTransactResponse[comNTTransactResponse.Count - 1];
                if (lastRsp.Response.TotalDataCount == 0 ? 
                    IsFragmentsSequentialCompleted<Messages.ComNTTransactResponse>(comNTTransactResponse,
                        (Messages.ComNTTransactResponse r) => r.Response.ParameterDisplacement == 0,
                        (Messages.ComNTTransactResponse r) => r.Response.ParameterDisplacement + r.Response.ParameterCount == r.Response.TotalParameterCount,
                        (Messages.ComNTTransactResponse r) => r.Response.ParameterDisplacement as int,
                        (Messages.ComNTTransactResponse r) => (r.Response.ParameterDisplacement + r.Response.ParameterCount) as int) :
                    IsFragmentsSequentialCompleted<Messages.ComNTTransactResponse>(comNTTransactResponse,
                        (Messages.ComNTTransactResponse r) => r.Response.DataDisplacement == 0,
                        (Messages.ComNTTransactResponse r) => r.Response.DataDisplacement + r.Response.DataCount == r.Response.TotalDataCount,
                        (Messages.ComNTTransactResponse r) => r.Response.DataDisplacement as int,
                        (Messages.ComNTTransactResponse r) => (r.Response.DataDisplacement + r.Response.DataCount) as int))
                {
                    binary buffer = $[];
                    for (int j = 0; j < comNTTransactResponse.Count; j++)
                    {
                        if (j == 0)
                        {
                            binary temp = comNTTransactResponse[0].SourceData as binary;
                            buffer = temp.Segment(0, 44) + temp.Segment(36, 4) + temp.Segment(48, 8) + temp.Segment(40, 4) + temp.Segment(60);
                        }
                        else
                        {
                            if (comNTTransactResponse[j].Response.Parameters != nothing)
                            {
                                buffer += comNTTransactResponse[j].Response.Parameters as binary;
                            }
                            if (comNTTransactResponse[j].Response.Data != nothing)
                            {
                                buffer += comNTTransactResponse[j].Response.Data as binary;
                            }
                        }
                    }
                    ntTransMessages = ntTransMessages.Remove(m.Mid);
                    DecodeNTTransactResponse((endpoint FileServer[dvar.GetIndex(m.Mid)] over this), buffer as stream, dvar, true, 0x12, "ComNTTransactResponse");
                }
            }
        }
    }
    
    process this accepts m:Messages.ComOpenRequest where m.Command == SmbCommand.SMB_COM_OPEN
    {
        string index = (m.Request.FileName.Value.Count == 0 || m.Request.FileName.Value == null) ? "*NULL*" : m.Request.FileName.Value;
        index += "@#" + (m.FrameMessageNumber as string);
        dvar.FileNameForRsp[m.Mid] = index;
        m#SMBFileName = index;
        dispatch (endpoint FileServer[index] over this) accepts m;
    }
    
    process this issues m:Messages.ComOpenResponse where m.Command == SmbCommand.SMB_COM_OPEN
    {
        string index = dvar.GetIndex(m.Mid, m.Response.Fid, true, false);
        m#SMBFileName = index;
        dispatch (endpoint FileServer[index] over this) issues m;
    }
    
    process this accepts m:Messages.ComCreateRequest where m.Command == SmbCommand.SMB_COM_CREATE
    {
        string index = (m.Request.FileName.Value.Count == 0 || m.Request.FileName.Value == null) ? "*NULL*" : m.Request.FileName.Value;
        index += "@#" + (m.FrameMessageNumber as string);
        dvar.FileNameForRsp[m.Mid] = index;
        m#SMBFileName = index;
        dispatch (endpoint FileServer[index] over this) accepts m;
    }
    
    process this issues m:Messages.ComCreateResponse where m.Command == SmbCommand.SMB_COM_CREATE
    {
        string index = dvar.GetIndex(m.Mid, m.Response.Fid, true, false);
        m#SMBFileName = index;
        dispatch (endpoint FileServer[index] over this) issues m;
    }
    
    process this accepts m:Messages.ComCloseRequest where m.Command == SmbCommand.SMB_COM_CLOSE
    {
        string index = dvar.GetIndex(m.Mid, m.Request.Fid, false, true);
        m#SMBFileName = index;
        dispatch (endpoint FileServer[index] over this) accepts m;
    }
    
    process this issues m:Messages.ComCloseResponse where m.Command == SmbCommand.SMB_COM_CLOSE
    {
        string index = dvar.GetIndex(m.Mid);
        m#SMBFileName = index;
        var fileServer = endpoint FileServer[index] over this;
        dispatch fileServer issues m;
        delete fileServer;
    }
    
    process this accepts m:Messages.ComFlushRequest where m.Command == SmbCommand.SMB_COM_FLUSH
    {
        string index = dvar.GetIndex(m.Mid, m.Request.Fid, false, false);
        m#SMBFileName = index;
        dispatch (endpoint FileServer[index] over this) accepts m;
    }
    
    process this issues m:Messages.ComFlushResponse where m.Command == SmbCommand.SMB_COM_FLUSH
    {
        string index = dvar.GetIndex(m.Mid);
        m#SMBFileName = index;
        dispatch (endpoint FileServer[index] over this) issues m;
    }
    
    process this accepts m:Messages.ComReadRequest where m.Command == SmbCommand.SMB_COM_READ
    {
        string index = dvar.GetIndex(m.Mid, m.Request.Fid, false, false);
        m#SMBFileName = index;
        dispatch (endpoint FileServer[index] over this) accepts m;
    }
    
    process this issues m:Messages.ComReadResponse where m.Command == SmbCommand.SMB_COM_READ
    {
        string index = dvar.GetIndex(m.Mid);
        m#SMBFileName = index;
        dispatch (endpoint FileServer[index] over this) issues m;
    }
    
    process this accepts m:Messages.ComWriteRequest where m.Command == SmbCommand.SMB_COM_WRITE
    {
        string index = dvar.GetIndex(m.Mid, m.Request.Fid, false, false);
        m#SMBFileName = index;
        dispatch (endpoint FileServer[index] over this) accepts m;
    }
    
    process this issues m:Messages.ComWriteResponse where m.Command == SmbCommand.SMB_COM_WRITE
    {
        string index = dvar.GetIndex(m.Mid);
        m#SMBFileName = index;
        dispatch (endpoint FileServer[index] over this) issues m;
    }
    
    process this accepts m:Messages.ComLockByteRangeRequest where m.Command == SmbCommand.SMB_COM_LOCK_BYTE_RANGE
    {
        string index = dvar.GetIndex(m.Mid, m.Request.Fid, false, false);
        m#SMBFileName = index;
        dispatch (endpoint FileServer[index] over this) accepts m;
    }
    
    process this issues m:Messages.ComLockByteRangeResponse where m.Command == SmbCommand.SMB_COM_LOCK_BYTE_RANGE
    {
        string index = dvar.GetIndex(m.Mid);
        m#SMBFileName = index;
        dispatch (endpoint FileServer[index] over this) issues m;
    }
    
    process this accepts m:Messages.ComUnlockByteRangeRequest where m.Command == SmbCommand.SMB_COM_UNLOCK_BYTE_RANGE
    {
        string index = dvar.GetIndex(m.Mid, m.Request.Fid, false, false);
        m#SMBFileName = index;
        dispatch (endpoint FileServer[index] over this) accepts m;
    }
    
    process this issues m:Messages.ComUnlockByteRangeResponse where m.Command == SmbCommand.SMB_COM_UNLOCK_BYTE_RANGE
    {
        string index = dvar.GetIndex(m.Mid);
        m#SMBFileName = index;
        dispatch (endpoint FileServer[index] over this) issues m;
    }
    
    process this accepts m:Messages.ComCreateTemporaryRequest where m.Command == SmbCommand.SMB_COM_CREATE_TEMPORARY
    {
        string index = (m.Request.DirectoryName.Value.Count == 0 || m.Request.DirectoryName.Value == null) ? "*NULL*" : m.Request.DirectoryName.Value;
        index += "@#" + (m.FrameMessageNumber as string);
        dvar.FileNameForRsp[m.Mid] = index;
        m#SMBFileName = index;
        dispatch (endpoint FileServer[index] over this) accepts m;
    }
    
    process this issues m:Messages.ComCreateTemporaryResponse where m.Command == SmbCommand.SMB_COM_CREATE_TEMPORARY
    {
        string index = dvar.GetIndex(m.Mid, m.Response.Fid, true, false);
        m#SMBFileName = index;
        dispatch (endpoint FileServer[index] over this) issues m;
    }
    
    process this accepts m:Messages.ComCreateNewRequest where m.Command == SmbCommand.SMB_COM_CREATE_NEW
    {
        string index = (m.Request.FileName.Value.Count == 0 || m.Request.FileName.Value == null) ? "*NULL*" : m.Request.FileName.Value;
        index += "@#" + (m.FrameMessageNumber as string);
        dvar.FileNameForRsp[m.Mid] = index;
        m#SMBFileName = index;
        dispatch (endpoint FileServer[index] over this) accepts m;
    }
    
    process this issues m:Messages.ComCreateNewResponse where m.Command == SmbCommand.SMB_COM_CREATE_NEW
    {
        string index = dvar.GetIndex(m.Mid, m.Response.Fid, true, false);
        m#SMBFileName = index;
        dispatch (endpoint FileServer[index] over this) issues m;
    }
    
    process this accepts m:Messages.ComSeekRequest where m.Command == SmbCommand.SMB_COM_SEEK
    {
        string index = dvar.GetIndex(m.Mid, m.Request.Fid, false, false);
        m#SMBFileName = index;
        dispatch (endpoint FileServer[index] over this) accepts m;
    }
    
    process this issues m:Messages.ComSeekResponse where m.Command == SmbCommand.SMB_COM_SEEK
    {
        string index = dvar.GetIndex(m.Mid);
        m#SMBFileName = index;
        dispatch (endpoint FileServer[index] over this) issues m;
    }
    
    process this accepts m:Messages.ComLockAndReadRequest where m.Command == SmbCommand.SMB_COM_LOCK_AND_READ
    {
        string index = dvar.GetIndex(m.Mid, m.Request.Fid, false, false);
        m#SMBFileName = index;
        dispatch (endpoint FileServer[index] over this) accepts m;
    }
    
    process this issues m:Messages.ComLockAndReadResponse where m.Command == SmbCommand.SMB_COM_LOCK_AND_READ
    {
        string index = dvar.GetIndex(m.Mid);
        m#SMBFileName = index;
        dispatch (endpoint FileServer[index] over this) issues m;
    }
    
    process this accepts m:Messages.ComWriteAndUnlockRequest where m.Command == SmbCommand.SMB_COM_WRITE_AND_UNLOCK
    {
        string index = dvar.GetIndex(m.Mid, m.Request.Fid, false, false);
        m#SMBFileName = index;
        dispatch (endpoint FileServer[index] over this) accepts m;
    }
    
    process this issues m:Messages.ComWriteAndUnlockResponse where m.Command == SmbCommand.SMB_COM_WRITE_AND_UNLOCK
    {
        string index = dvar.GetIndex(m.Mid);
        m#SMBFileName = index;
        dispatch (endpoint FileServer[index] over this) issues m;
    }
    
    process this accepts m:Messages.ComReadRawRequest where m.Command == SmbCommand.SMB_COM_READ_RAW
    {
        string index = dvar.GetIndex(m.Mid, m.Request.Fid, false, false);
        m#SMBFileName = index;
        dispatch (endpoint FileServer[index] over this) accepts m;
    }
    
    process this issues m:Messages.ComReadRawResponse where m.Command == SmbCommand.SMB_COM_READ_RAW
    {
        string index = dvar.GetIndex(m.Mid);
        m#SMBFileName = index;
        dispatch (endpoint FileServer[index] over this) issues m;
    }
    
    process this accepts m:Messages.ComReadMpxRequest where m.Command == SmbCommand.SMB_COM_READ_MPX
    {
        string index = dvar.GetIndex(m.Mid, m.Request.Fid, false, false);
        m#SMBFileName = index;
        dispatch (endpoint FileServer[index] over this) accepts m;
    }
    
    process this issues m:Messages.ComReadMpxResponse where m.Command == SmbCommand.SMB_COM_READ_MPX
    {
        string index = dvar.GetIndex(m.Mid);
        m#SMBFileName = index;
        dispatch (endpoint FileServer[index] over this) issues m;
    }
    
    process this accepts m:Messages.ComWriteRawRequest where m.Command == SmbCommand.SMB_COM_WRITE_RAW
    {
        string index = dvar.GetIndex(m.Mid, m.Request.Fid, false, false);
        m#SMBFileName = index;
        dispatch (endpoint FileServer[index] over this) accepts m;
    }
    
    process this issues m:Messages.ComWriteRawResponse where m.Command == SmbCommand.SMB_COM_WRITE_RAW
    {
        string index = dvar.GetIndex(m.Mid);
        m#SMBFileName = index;
        dispatch (endpoint FileServer[index] over this) issues m;
    }
    
    process this accepts m:Messages.ComWriteMpxRequest where m.Command == SmbCommand.SMB_COM_WRITE_MPX
    {
        string index = dvar.GetIndex(m.Mid, m.Request.Fid, false, false);
        m#SMBFileName = index;
        dispatch (endpoint FileServer[index] over this) accepts m;
    }
    
    process this issues m:Messages.ComWriteMpxResponse where m.Command == SmbCommand.SMB_COM_WRITE_MPX
    {
        string index = dvar.GetIndex(m.Mid);
        m#SMBFileName = index;
        dispatch (endpoint FileServer[index] over this) issues m;
    }
    
    process this accepts m:Messages.ComSetInformation2Request where m.Command == SmbCommand.SMB_COM_SET_INFORMATION2
    {
        string index = dvar.GetIndex(m.Mid, m.Request.Fid, false, false);
        m#SMBFileName = index;
        dispatch (endpoint FileServer[index] over this) accepts m;
    }
    
    process this issues m:Messages.ComSetInformation2Response where m.Command == SmbCommand.SMB_COM_SET_INFORMATION2
    {
        string index = dvar.GetIndex(m.Mid);
        m#SMBFileName = index;
        dispatch (endpoint FileServer[index] over this) issues m;
    }
    
    process this accepts m:Messages.ComQueryInformation2Request where m.Command == SmbCommand.SMB_COM_QUERY_INFORMATION2
    {
        string index = dvar.GetIndex(m.Mid, m.Request.Fid, false, false);
        m#SMBFileName = index;
        dispatch (endpoint FileServer[index] over this) accepts m;
    }
    
    process this issues m:Messages.ComQueryInformation2Response where m.Command == SmbCommand.SMB_COM_QUERY_INFORMATION2
    {
        string index = dvar.GetIndex(m.Mid);
        m#SMBFileName = index;
        dispatch (endpoint FileServer[index] over this) issues m;
    }
    
    process this accepts m:Messages.ComLockingAndxRequest where m.Command == SmbCommand.SMB_COM_LOCKING_ANDX
    {
        string index = dvar.GetIndex(m.Mid, m.Request.Fid, false, false);
        m#SMBFileName = index;
        dispatch (endpoint FileServer[index] over this) accepts m;
    }
    
    process this issues m:Messages.ComLockingAndxResponse where m.Command == SmbCommand.SMB_COM_LOCKING_ANDX
    {
        string index = dvar.GetIndex(m.Mid);
        m#SMBFileName = index;
        dispatch (endpoint FileServer[index] over this) issues m;
    }
    
    process this accepts m:Messages.ComIoctlRequest where m.Command == SmbCommand.SMB_COM_IOCTL
    {
        string index = dvar.GetIndex(m.Mid, m.Request.Fid, false, false);
        m#SMBFileName = index;
        dispatch (endpoint FileServer[index] over this) accepts m;
    }
    
    process this issues m:Messages.ComIoctlResponse where m.Command == SmbCommand.SMB_COM_IOCTL
    {
        string index = dvar.GetIndex(m.Mid);
        m#SMBFileName = index;
        dispatch (endpoint FileServer[index] over this) issues m;
    }
    
    process this accepts m:Messages.ComWriteAndCloseRequest where m.Command == SmbCommand.SMB_COM_WRITE_AND_CLOSE
    {
        string index = dvar.GetIndex(m.Mid, m.Request.Fid, false, true);
        m#SMBFileName = index;
        dispatch (endpoint FileServer[index] over this) accepts m;
    }
    
    process this issues m:Messages.ComWriteAndCloseResponse where m.Command == SmbCommand.SMB_COM_WRITE_AND_CLOSE
    {
        string index = dvar.GetIndex(m.Mid);
        m#SMBFileName = index;
        var fileServer = endpoint FileServer[index] over this;
        dispatch fileServer issues m;
        delete fileServer;
    }
    
    process this accepts m:Messages.ComOpenAndxRequest where m.Command == SmbCommand.SMB_COM_OPEN_ANDX
    {
        string index = (m.Request.FileName.Value.Count == 0 || m.Request.FileName.Value == null) ? "*NULL*" : m.Request.FileName.Value;
        index += "@#" + (m.FrameMessageNumber as string);
        dvar.FileNameForRsp[m.Mid] = index;
        m#SMBFileName = index;
        dispatch (endpoint FileServer[index] over this) accepts m;
    }
    
    process this issues m:Messages.ComOpenAndxResponse where m.Command == SmbCommand.SMB_COM_OPEN_ANDX
    {
        string index = dvar.GetIndex(m.Mid, m.Response.Fid, true, false);
        m#SMBFileName = index;
        dispatch (endpoint FileServer[index] over this) issues m;
    }
    
    process this accepts m:Messages.ComReadAndxRequest where m.Command == SmbCommand.SMB_COM_READ_ANDX
    {
        string index = dvar.GetIndex(m.Mid, m.Request.Fid, false, false);
        m#SMBFileName = index;
        dispatch (endpoint FileServer[index] over this) accepts m;
    }
    
    process this issues m:Messages.ComReadAndxResponse where m.Command == SmbCommand.SMB_COM_READ_ANDX
    {
        m#SMBFileId = (m.Mid in dvar.FidForRsp) ? (dvar.FidForRsp[m.Mid] as ulong) : nothing;
        string index = dvar.GetIndex(m.Mid);
        m#SMBFileName = index;
        dispatch (endpoint FileServer[index] over this) issues m;
    }
    
    process this accepts m:Messages.ComWriteAndxRequest where m.Command == SmbCommand.SMB_COM_WRITE_ANDX
    {
        string index = dvar.GetIndex(m.Mid, m.Request.Fid, false, false);
        m#SMBFileName = index;
        dispatch (endpoint FileServer[index] over this) accepts m;
    }
    
    process this issues m:Messages.ComWriteAndxResponse where m.Command == SmbCommand.SMB_COM_WRITE_ANDX
    {
        string index = dvar.GetIndex(m.Mid);
        m#SMBFileName = index;
        dispatch (endpoint FileServer[index] over this) issues m;
    }
    
    process this accepts m:Messages.ComNTCreateAndxRequest where m.Command == SmbCommand.SMB_COM_NT_CREATE_ANDX
    {
        string index = (m.Request.FileName.Value.Count == 0 || m.Request.FileName.Value == null) ? "*NULL*" : m.Request.FileName.Value;
        index += "@#" + (m.FrameMessageNumber as string);
        dvar.FileNameForRsp[m.Mid] = index;
        m#SMBFileName = index;
        dispatch (endpoint FileServer[index] over this) accepts m;
    }
    
    process this issues m:Messages.ComNTCreateAndxResponse where m.Command == SmbCommand.SMB_COM_NT_CREATE_ANDX
    {
        string index = dvar.GetIndex(m.Mid, m.Response.Fid, true, false);
        m#SMBFileName = index;
        dispatch (endpoint FileServer[index] over this) issues m;
    }
    
    process this accepts m:Messages.ComOpenPrintFileRequest where m.Command == SmbCommand.SMB_COM_OPEN_PRINT_FILE
    {
        string index = (m.Request.Identifier.Value.Count == 0 || m.Request.Identifier.Value == null) ? "*NULL*" : m.Request.Identifier.Value;
        index += "@#" + (m.FrameMessageNumber as string);
        dvar.FileNameForRsp[m.Mid] = index;
        m#SMBFileName = index;
        dispatch (endpoint FileServer[index] over this) accepts m;
    }

    process this issues m:Messages.ComOpenPrintFileResponse where m.Command == SmbCommand.SMB_COM_OPEN_PRINT_FILE
    {
        string index = dvar.GetIndex(m.Mid, m.Response.Fid, true, false);
        m#SMBFileName = index;
        dispatch (endpoint FileServer[index] over this) issues m;
    }
    
    process this accepts m:Messages.ComWritePrintFileRequest where m.Command == SmbCommand.SMB_COM_WRITE_PRINT_FILE
    {
        string index = dvar.GetIndex(m.Mid, m.Request.Fid, false, false);
        m#SMBFileName = index;
        dispatch (endpoint FileServer[index] over this) accepts m;
    }
    
    process this issues m:Messages.ComWritePrintFileResponse where m.Command == SmbCommand.SMB_COM_WRITE_PRINT_FILE
    {
        string index = dvar.GetIndex(m.Mid);
        m#SMBFileName = index;
        dispatch (endpoint FileServer[index] over this) issues m;
    }
    
    process this accepts m:Messages.ComClosePrintFileRequest where m.Command == SmbCommand.SMB_COM_CLOSE_PRINT_FILE
    {
        string index = dvar.GetIndex(m.Mid, m.Request.Fid, false, true);
        m#SMBFileName = index;
        dispatch (endpoint FileServer[index] over this) accepts m;
    }
    
    process this issues m:Messages.ComClosePrintFileResponse where m.Command == SmbCommand.SMB_COM_CLOSE_PRINT_FILE
    {
        string index = dvar.GetIndex(m.Mid);
        m#SMBFileName = index;
        var fileServer = endpoint FileServer[index] over this;
        dispatch fileServer issues m;
        delete fileServer;
    }
    
    process this issues m:Messages.ErrorResponse where (m.Command is FileSmbCommand)
    {
        string index = dvar.GetIndex(m.Mid);
        m#SMBFileName = index;
        dispatch (endpoint FileServer[index] over this) issues m;
    }
    
    process this accepts m:SmbRequest where !(m.Command is FileSmbCommand)
    {
        dispatch (endpoint Server over this) accepts m;
    }
    
    process this issues m:SmbResponse where !((m.Command is FileSmbCommand) || m.Command == 0x32 || m.Command == 0xA0)
    {
        dispatch (endpoint Server over this) issues m;
    }
    
    process this issues m:Messages.ErrorResponse where (m.Command == SmbCommand.SMB_COM_TRANSACTION2 || m.Command == SmbCommand.SMB_COM_NT_TRANSACT)
    {
        string index = dvar.GetIndex(m.Mid);
        m#SMBFileName = index;
        dispatch (endpoint FileServer[index] over this) issues m;
    }
    
    void AcceptDispatcher(SmbRequest req)
    {
        dispatch this accepts req;
    }

    void IssueDispatcher(SmbResponse rsp)
    {
        dispatch this issues rsp;
    }
    
    void Clear<T>(map<ushort, array<T>> buffer)
    {
        if (buffer.Count > 0)
        {
            foreach (ushort key in buffer.Keys)
            {
                foreach (T t in buffer[key])
                {
                    any tm = t as any;
                    any message m = tm as any message;
                    DisplayTopLevelMessage(m);
                }
            }
        }
        buffer = {};
    }
}

autostart actor LowestServerActor(LowestServer LowestServer)
{
    ~endpoint(LowestServer LowestServer)
    {
        Server server = endpoint Server over LowestServer;
        LowestServer.Clear<Messages.ComTransactionResponse>(LowestServer.transMessages);
        LowestServer.Clear<Messages.ComTransaction2Response>(LowestServer.trans2Messages);
        LowestServer.Clear<Messages.ComNTTransactResponse>(LowestServer.ntTransMessages);
    }
}

client endpoint LowestClient connected to LowestServer;
const binary SMBProtocolId = $[FF534D42];

autostart actor SMBOverSMBTransport(SMBTransport.Server server) precedes SMBTransport.SMBOverSMBTransportWithoutFileSharing
{
    process server accepts p:SMBTransport.TransportPacket where p.SMBMessage.Count >= 4 && p.SMBMessage.Segment(0,4) == SMBProtocolId
    {
        LowestServer lowestServer = endpoint LowestServer over server;
        DecodeAndDispatchMessages(lowestServer, p.SMBMessage, lowestServer.dvar);
    }

    // parsing response message
    process server issues p:SMBTransport.TransportPacket where p.SMBMessage.Count >= 4 && p.SMBMessage.Segment(0,4) == SMBProtocolId
    {
        LowestServer lowestServer = endpoint LowestServer over server;
        DecodeAndDispatchMessages(lowestServer, p.SMBMessage, lowestServer.dvar);
    }
}

autostart actor SmbOverNbtss(NBTSS.Server server) precedes SMBTransport.SmbOverNbtss
{
    process server accepts p:NBTSS.SessionService where p.Trailer != nothing 
                                                        && p.Trailer is NBTSS.SessionMessagePacket 
                                                        && ((p.Trailer as NBTSS.SessionMessagePacket).UserData.Count >= 4 && (p.Trailer as NBTSS.SessionMessagePacket).UserData.Segment(0,4) is SMBProtocolId)
    {
        LowestServer lowestServer = endpoint LowestServer over server;
        DecodeAndDispatchMessages(lowestServer, (p.Trailer as NBTSS.SessionMessagePacket).UserData, lowestServer.dvar);
    }

    // parsing response message
    process server issues p:NBTSS.SessionService where p.Trailer != nothing 
                                                        && p.Trailer is NBTSS.SessionMessagePacket 
                                                        && ((p.Trailer as NBTSS.SessionMessagePacket).UserData.Count >= 4 && (p.Trailer as NBTSS.SessionMessagePacket).UserData.Segment(0,4) is SMBProtocolId)
    {
        LowestServer lowestServer = endpoint LowestServer over server;
        DecodeAndDispatchMessages(lowestServer, (p.Trailer as NBTSS.SessionMessagePacket).UserData, lowestServer.dvar);
    }
}

autostart actor SmbOverNbf(NBF.Node node) precedes SMBTransport.SmbOverNbf
{
    process node accepts d:NBF.Datagram where d.Payload is bin:binary && IsSMBTrafficButNotMail(bin)
    {
        LowestServer lowestServer = endpoint LowestServer over node;
        DecodeAndDispatchMessages(lowestServer, d.Payload as binary, lowestServer.dvar);
    }
    process node accepts d:NBF.DatagramBroadcast where d.Payload is bin:binary && IsSMBTrafficButNotMail(bin)
    {
        LowestServer lowestServer = endpoint LowestServer over node;
        DecodeAndDispatchMessages(lowestServer, d.Payload as binary, lowestServer.dvar);
    }
    process node accepts d:NBF.DataOnlyLast where d.UserData is bin:binary && IsSMBTrafficButNotMail(bin)
    {
        LowestServer lowestServer = endpoint LowestServer over node;
        DecodeAndDispatchMessages(lowestServer, d.UserData as binary, lowestServer.dvar);
    }
    
   bool IsSMBTrafficButNotMail(binary bin)
   {
       return (bin.Count >= 4 && bin.Segment(0, 4) is SMBProtocolId) && !(bin.Segment(4, 1) is $[25] && bin.Count > 63 && (bin.Segment(59, 1) is $[03] && bin.Segment(61, 2) is $[0100]));
   }
}

annotation string Messages.ComNegotiateResponse#DialectString;
const string InitialIndex = "0x00";
type DecoderVariables
{
    array<string> NegotiateDialects = [];
    map<USHORT, USHORT> Subcommand = {};
    map<USHORT, USHORT> InformationLevel = {};
    map<USHORT, USHORT> Trans2FindFlags = {};
    map<USHORT, ULONG> IoctlFunctionCode = {};
    map<USHORT, string> FileName = {}; // key is FID, for conversation usage
    map<USHORT, string> FileNameForRsp = {}; // key is MID, for response usage
    map<USHORT, USHORT> FidForRsp = {}; // Key is MID, for response referring FID
    bool pduFull = true; // Indicates what PduFull is set in etw provider
    binary EndpointIndex = null;

    string GetIndex(ushort mid, ushort fid, bool isOpen, bool isClose)
    {
        string index = fid as string;
        if (isOpen)
        {
            if (mid in FileNameForRsp)
            {
                index = FileNameForRsp[mid];
                FileNameForRsp = FileNameForRsp.Remove(mid);
                FileName[fid] = index;
            }
        }
        else
        {
            FidForRsp[mid] = fid;
            if (fid in FileName)
            {
                index = FileName[fid];
                FileNameForRsp[mid] = index;
                if (isClose)
                {
                    FileName = FileName.Remove(fid);
                }
            }
        }
        return index;
    }
    
    string GetIndex(ushort mid)
    {
        string index = InitialIndex;
        if (mid in FidForRsp)
        {
            index = FidForRsp[mid] as string;
            FidForRsp = FidForRsp.Remove(mid);
        }
        if (mid in FileNameForRsp)
        {
            index = FileNameForRsp[mid];
            FileNameForRsp = FileNameForRsp.Remove(mid);
        }
        return index;
    }
}

bool IsCompletedResponse(uint displacement, uint count, uint totalCount)
{
    return displacement == 0 && displacement + count == totalCount;
}

void DecodeSmbRequest<T>(stream s, string msg, bool isGreater, byte wordCount, void(T) dispatcher)
{
    switch (s)
    {
        case m:T from BinaryDecoder<T> =>
            dispatcher(m);
        default =>
            TryDecodeHeaderOnlyMessage(s, msg, isGreater, wordCount);
    }
}

void DecodeSmbResponse<T>(stream s, string msg, bool isGreater, byte wordCount, void(T) dispatcher, void(T) displayErrorCode)
{
    switch (s)
    {
        case m:T from BinaryDecoder<T> =>
            displayErrorCode(m);
            dispatcher(m);
        default =>
            TryDecodeHeaderOnlyMessage(s, msg, isGreater, wordCount);
    }
}

void DisplayErrorCode(SmbHeader m)
{
    SmbStatusErrorCodeIf(m, DiagnosisLevel.Warning);
}

// Try to decode the insufficient data into the header only message
void TryDecodeHeaderOnlyMessage(stream s, string msgName, bool isGreater, byte wordCount)
{
    switch (s)
    {
        case m:SMB.SmbHeader from BinaryDecoder<SMB.SmbHeader> =>
            m#SMBMessageName = msgName;
            DisplayTopLevelMessage(m);
            ReportDiagnosticMessageForHeaderOnly(isGreater, wordCount, s, msgName, m);
        default =>
            ThrowDecodingException("SMB", msgName);
    }
}

void DecodeTransaction2Response((LowestServer | FileServer) server, stream s, DecoderVariables dvar, bool isGreater, byte wordCount, string msgName)
{
    ushort mid = MakeWord(s.PeekByte(248), s.PeekByte(240));
    optional ushort subcommand = mid in dvar.Subcommand.Keys ? dvar.Subcommand[mid] : nothing;
    ushort informationLevel = mid in dvar.InformationLevel.Keys ? dvar.InformationLevel[mid] : 0;
    bool resumeKeyExist = mid in dvar.Trans2FindFlags.Keys ? ((dvar.Trans2FindFlags[mid] & 0x0004) == 0x0004) : false;
    switch (s)
    {
        case msg:Messages.ComTransaction2Response from BinaryDecoder<Messages.ComTransaction2Response[subcommand, informationLevel, resumeKeyExist]> =>
            SmbStatusErrorCodeIf(msg, DiagnosisLevel.Warning);
            if (msg.Response is response:SmbComTransaction2Response)
            {
                if (response.TotalParameterCount == response.ParameterCount && response.TotalDataCount == response.DataCount)
                {
                    if (msg.Mid in dvar.Subcommand.Keys)
                    {
                        dvar.Subcommand = dvar.Subcommand.Remove(msg.Mid);
                    }
                    if (msg.Mid in dvar.InformationLevel.Keys)
                    {
                        dvar.InformationLevel = dvar.InformationLevel.Remove(msg.Mid);
                    }
                    if (msg.Mid in dvar.Trans2FindFlags.Keys)
                    {
                        dvar.Trans2FindFlags = dvar.Trans2FindFlags.Remove(msg.Mid);
                    }
                }
            }
            if (server is LowestServer)
            {
                dispatch (server as LowestServer) issues msg;
            }
            else
            {
                var fileServer = (server as FileServer);
                msg#SMBFileName = fileServer.File;
                dispatch fileServer issues msg;
            }
            
        default =>
            TryDecodeHeaderOnlyMessage(s, "ComTransaction2Response", isGreater, wordCount);
    }
}

void DecodeNTTransactResponse((LowestServer | FileServer) server, stream s, DecoderVariables dvar, bool isGreater, byte wordCount, string msgName)
{
    ushort mid = MakeWord(s.PeekByte(248), s.PeekByte(240));
    optional ushort subcommand = mid in dvar.Subcommand.Keys ? dvar.Subcommand[mid] : nothing;
    uint ioctlFunctionCode = mid in dvar.IoctlFunctionCode.Keys ? dvar.IoctlFunctionCode[mid] : 0xffffffff;
    switch (s)
    {
        case msg:Messages.ComNTTransactResponse from BinaryDecoder<Messages.ComNTTransactResponse[subcommand, ioctlFunctionCode]> =>
            SmbStatusErrorCodeIf(msg, DiagnosisLevel.Warning);
            if (msg.Mid in dvar.Subcommand.Keys && msg.Response.TotalParameterCount == msg.Response.ParameterCount && msg.Response.TotalDataCount == msg.Response.DataCount)
            {
                dvar.Subcommand = dvar.Subcommand.Remove(msg.Mid);
                if (msg.Mid in dvar.IoctlFunctionCode.Keys)
                {
                    dvar.IoctlFunctionCode = dvar.IoctlFunctionCode.Remove(msg.Mid);
                }
            }
            if (server is lowestServer:LowestServer)
            {
                dispatch lowestServer issues msg;
            }
            else
            {
                var fileServer = (server as FileServer);
                msg#SMBFileName = fileServer.File;
                dispatch fileServer issues msg;
            }
            
        default =>
            TryDecodeHeaderOnlyMessage(s, "ComNTTransactResponse", isGreater, wordCount);
    }
}

void DecodeAndDispatchMessages(LowestServer server, stream s, DecoderVariables dvar)
{
    bool isRequest = ((s.PeekByte(72) & 0x80) == 0x00);
    byte command = s.PeekByte(32);
    
    if (IsErrorResponse(s))
    {
        switch (s)
        {
            case m:Messages.ErrorResponse from BinaryDecoder<Messages.ErrorResponse> =>
                SmbStatusErrorCodeIf(m, DiagnosisLevel.Warning);
                dispatch server issues m;
                
            default =>
                TryDecodeHeaderOnlyMessage(s, "Error Response", false, 0xFF);
        }
        return;
    }
    // Parsing message as per Command.
    
    switch (command)
    {
        case SmbCommand.SMB_COM_CREATE_DIRECTORY =>
            if (isRequest) // request
            {
                DecodeSmbRequest<Messages.ComCreateDirectoryRequest>(s, "ComCreateDirectoryRequest", false, 0x00, server.AcceptDispatcher);
            }
            else // response
            {
                DecodeSmbResponse<Messages.ComCreateDirectoryResponse>(s, "ComCreateDirectoryResponse", false, 0x00, server.IssueDispatcher, DisplayErrorCode);
            }
            
        case SmbCommand.SMB_COM_DELETE_DIRECTORY =>
            if (isRequest) // request
            {
                DecodeSmbRequest<Messages.ComDeleteDirectoryRequest>(s, "ComDeleteDirectoryRequest", false, 0x00, server.AcceptDispatcher);
            }
            else // response
            {
                DecodeSmbResponse<Messages.ComDeleteDirectoryResponse>(s, "ComDeleteDirectoryResponse", false, 0x00, server.IssueDispatcher, DisplayErrorCode);
            }
        case SmbCommand.SMB_COM_OPEN =>
            if (isRequest) // request
            {
                DecodeSmbRequest<Messages.ComOpenRequest>(s, "ComOpenRequest", false, 0x02, server.AcceptDispatcher);
            }
            else // response
            {
                DecodeSmbResponse<Messages.ComOpenResponse>(s, "ComOpenResponse", false, 0x07, server.IssueDispatcher, DisplayErrorCode);
            }
        case SmbCommand.SMB_COM_CREATE =>
            if (isRequest) // request
            {
                DecodeSmbRequest<Messages.ComCreateRequest>(s, "ComCreateRequest", false, 0x03, server.AcceptDispatcher);
            }
            else // response
            {
                DecodeSmbResponse<Messages.ComCreateResponse>(s, "ComCreateResponse", false, 0x01, server.IssueDispatcher, DisplayErrorCode);
            }
        case SmbCommand.SMB_COM_CLOSE =>
            if (isRequest) // request
            {
                DecodeSmbRequest<Messages.ComCloseRequest>(s, "ComCloseRequest", false, 0x03, server.AcceptDispatcher);
            }
            else // response
            {
                DecodeSmbResponse<Messages.ComCloseResponse>(s, "ComCloseResponse", false, 0x00, server.IssueDispatcher, DisplayErrorCode);
            }
        case SmbCommand.SMB_COM_FLUSH =>
            if (isRequest) // request
            {
                DecodeSmbRequest<Messages.ComFlushRequest>(s, "ComFlushRequest", false, 0x01, server.AcceptDispatcher);
            }
            else // response
            {
                DecodeSmbResponse<Messages.ComFlushResponse>(s, "ComFlushResponse", false, 0x00, server.IssueDispatcher, DisplayErrorCode);
            }
        case SmbCommand.SMB_COM_DELETE =>
            if (isRequest) // request
            {
                DecodeSmbRequest<Messages.ComDeleteRequest>(s, "ComDeleteRequest", false, 0x01, server.AcceptDispatcher);
            }
            else // response
            {
                DecodeSmbResponse<Messages.ComDeleteResponse>(s, "ComDeleteResponse", false, 0x00, server.IssueDispatcher, DisplayErrorCode);
            }
        case SmbCommand.SMB_COM_RENAME =>
            if (isRequest) // request
            {
                DecodeSmbRequest<Messages.ComRenameRequest>(s, "ComRenameRequest", false, 0x01, server.AcceptDispatcher);
            }
            else // response
            {
                DecodeSmbResponse<Messages.ComRenameResponse>(s, "ComRenameResponse", false, 0x00, server.IssueDispatcher, DisplayErrorCode);
            }
        case SmbCommand.SMB_COM_QUERY_INFORMATION =>
            if (isRequest) // request
            {
                DecodeSmbRequest<Messages.ComQueryInformationRequest>(s, "ComQueryInformationRequest", false, 0x00, server.AcceptDispatcher);
            }
            else // response
            {
                DecodeSmbResponse<Messages.ComQueryInformationResponse>(s, "ComQueryInformationResponse", false, 0x0A, server.IssueDispatcher, DisplayErrorCode);
            }
        case SmbCommand.SMB_COM_SET_INFORMATION =>
            if (isRequest) // request
            {
                DecodeSmbRequest<Messages.ComSetInformationRequest>(s, "ComSetInformationRequest", false, 0x08, server.AcceptDispatcher);
            }
            else // response
            {
                DecodeSmbResponse<Messages.ComSetInformationResponse>(s, "ComSetInformationResponse", false, 0x00, server.IssueDispatcher, DisplayErrorCode);
            }
        case SmbCommand.SMB_COM_READ =>
            if (isRequest) // request
            {
                DecodeSmbRequest<Messages.ComReadRequest>(s, "ComReadRequest", false, 0x05, server.AcceptDispatcher);
            }
            else // response
            {
                DecodeSmbResponse<Messages.ComReadResponse>(s, "ComReadResponse", false, 0x05, server.IssueDispatcher, DisplayErrorCode);
            }
        case SmbCommand.SMB_COM_WRITE =>
            if (isRequest) // request
            {
                DecodeSmbRequest<Messages.ComWriteRequest>(s, "ComWriteRequest", false, 0x05, server.AcceptDispatcher);
            }
            else // response
            {
                DecodeSmbResponse<Messages.ComWriteResponse>(s, "ComWriteResponse", false, 0x01, server.IssueDispatcher, DisplayErrorCode);
            }
        case SmbCommand.SMB_COM_LOCK_BYTE_RANGE =>
            if (isRequest) // request
            {
                DecodeSmbRequest<Messages.ComLockByteRangeRequest>(s, "ComLockByteRangeRequest", false, 0x05, server.AcceptDispatcher);
            }
            else // response
            {
                DecodeSmbResponse<Messages.ComLockByteRangeResponse>(s, "ComLockByteRangeResponse", false, 0x00, server.IssueDispatcher, DisplayErrorCode);
            }
        case SmbCommand.SMB_COM_UNLOCK_BYTE_RANGE =>
            if (isRequest) // request
            {
                DecodeSmbRequest<Messages.ComUnlockByteRangeRequest>(s, "ComUnlockByteRangeRequest", false, 0x05, server.AcceptDispatcher);
            }
            else // response
            {
                DecodeSmbResponse<Messages.ComUnlockByteRangeResponse>(s, "ComUnlockByteRangeResponse", false, 0x00, server.IssueDispatcher, DisplayErrorCode);
            }
        case SmbCommand.SMB_COM_CREATE_TEMPORARY =>
            if (isRequest) // request
            {
                DecodeSmbRequest<Messages.ComCreateTemporaryRequest>(s, "ComCreateTemporaryRequest", false, 0x03, server.AcceptDispatcher);
            }
            else // response
            {
                DecodeSmbResponse<Messages.ComCreateTemporaryResponse>(s, "ComCreateTemporaryResponse", false, 0x01, server.IssueDispatcher, DisplayErrorCode);
            }
        case SmbCommand.SMB_COM_CREATE_NEW =>
            if (isRequest) // request
            {
                DecodeSmbRequest<Messages.ComCreateNewRequest>(s, "ComCreateNewRequest", false, 0x03, server.AcceptDispatcher);
            }
            else // response
            {
                DecodeSmbResponse<Messages.ComCreateNewResponse>(s, "ComCreateNewResponse", false, 0x01, server.IssueDispatcher, DisplayErrorCode);
            }
        case SmbCommand.SMB_COM_CHECK_DIRECTORY =>
            if (isRequest) // request
            {
                DecodeSmbRequest<Messages.ComCheckDirectoryRequest>(s, "ComCheckDirectoryRequest", false, 0x00, server.AcceptDispatcher);
            }
            else // response
            {
                DecodeSmbResponse<Messages.ComCheckDirectoryResponse>(s, "ComCheckDirectoryResponse", false, 0x00, server.IssueDispatcher, DisplayErrorCode);
            }
        case SmbCommand.SMB_COM_PROCESS_EXIT =>
            if (isRequest) // request
            {
                DecodeSmbRequest<Messages.ComProcessExitRequest>(s, "ComProcessExitRequest", false, 0x00, server.AcceptDispatcher);
            }
            else // response
            {
                DecodeSmbResponse<Messages.ComProcessExitResponse>(s, "ComProcessExitResponse", false, 0x00, server.IssueDispatcher, DisplayErrorCode);
            }
        case SmbCommand.SMB_COM_SEEK =>
            if (isRequest) // request
            {
                DecodeSmbRequest<Messages.ComSeekRequest>(s, "ComSeekRequest", false, 0x04, server.AcceptDispatcher);
            }
            else // response
            {
                DecodeSmbResponse<Messages.ComSeekResponse>(s, "ComSeekResponse", false, 0x02, server.IssueDispatcher, DisplayErrorCode);
            }
        case SmbCommand.SMB_COM_LOCK_AND_READ =>
            if (isRequest) // request
            {
                DecodeSmbRequest<Messages.ComLockAndReadRequest>(s, "ComLockAndReadRequest", false, 0x05, server.AcceptDispatcher);
            }
            else // response
            {
                DecodeSmbResponse<Messages.ComLockAndReadResponse>(s, "ComLockAndReadResponse", false, 0x05, server.IssueDispatcher, DisplayErrorCode);
            }
        case SmbCommand.SMB_COM_WRITE_AND_UNLOCK =>
            if (isRequest) // request
            {
                DecodeSmbRequest<Messages.ComWriteAndUnlockRequest>(s, "ComWriteAndUnlockRequest", false, 0x05, server.AcceptDispatcher);
            }
            else // response
            {
                DecodeSmbResponse<Messages.ComWriteAndUnlockResponse>(s, "ComWriteAndUnlockResponse", false, 0x01, server.IssueDispatcher, DisplayErrorCode);
            }
        case SmbCommand.SMB_COM_READ_RAW =>
            if (isRequest) // request
            {
                DecodeSmbRequest<Messages.ComReadRawRequest>(s, "ComReadRawRequest", true, 0x08, server.AcceptDispatcher);
            }
            else // response
            {
                DecodeSmbResponse<Messages.ComReadRawResponse>(s, "ComReadRawResponse", false, 0x02, server.IssueDispatcher, DisplayErrorCode);
            }
        case SmbCommand.SMB_COM_READ_MPX =>
            if (isRequest) // request
            {
                DecodeSmbRequest<Messages.ComReadMpxRequest>(s, "ComReadMpxRequest", false, 0x08, server.AcceptDispatcher);
            }
            else // response
            {
                DecodeSmbResponse<Messages.ComReadMpxResponse>(s, "ComReadMpxResponse", false, 0x08, server.IssueDispatcher, DisplayErrorCode);
            }
        case SmbCommand.SMB_COM_WRITE_RAW =>
            if (isRequest) // request
            {
                DecodeSmbRequest<Messages.ComWriteRawRequest>(s, "ComWriteRawRequest", true, 0x0C, server.AcceptDispatcher);
            }
            else // response
            {
                DecodeSmbResponse<Messages.ComWriteRawResponse>(s, "ComWriteRawResponse", false, 0x01, server.IssueDispatcher, DisplayErrorCode);
            }
        case SmbCommand.SMB_COM_WRITE_MPX =>
            if (isRequest) // request
            {
                DecodeSmbRequest<Messages.ComWriteMpxRequest>(s, "ComWriteMpxRequest", false, 0x0C, server.AcceptDispatcher);
            }
            else // response
            {
                DecodeSmbResponse<Messages.ComWriteMpxResponse>(s, "ComWriteMpxResponse", false, 0x02, server.IssueDispatcher, DisplayErrorCode);
            }
        case SmbCommand.SMB_COM_SET_INFORMATION2 =>
            if (isRequest) // request
            {
                DecodeSmbRequest<Messages.ComSetInformation2Request>(s, "ComSetInformation2Request", false, 0x07, server.AcceptDispatcher);
            }
            else // response
            {
                DecodeSmbResponse<Messages.ComSetInformation2Response>(s, "ComSetInformation2Response", false, 0x00, server.IssueDispatcher, DisplayErrorCode);
            }
        case SmbCommand.SMB_COM_QUERY_INFORMATION2 =>
            if (isRequest) // request
            {
                DecodeSmbRequest<Messages.ComQueryInformation2Request>(s, "ComQueryInformation2Request", false, 0x01, server.AcceptDispatcher);
            }
            else // response
            {
                DecodeSmbResponse<Messages.ComQueryInformation2Response>(s, "ComQueryInformation2Response", false, 0x0B, server.IssueDispatcher, DisplayErrorCode);
            }
        case SmbCommand.SMB_COM_LOCKING_ANDX =>
            if (isRequest) // request
            {
                switch (s)
                {
                    case m:Messages.ComLockingAndxRequest from BinaryDecoder<Messages.ComLockingAndxRequest> =>
                        bool isFlags2Unicode = (m.Flags2 & 0x8000) == 0x8000;
                        if (s.BytePosition < s.ByteLength && m.Request.AndXOffset > s.BytePosition)
                        {
                            int padLength = (s.ByteLength < m.Request.AndXOffset ? s.ByteLength : m.Request.AndXOffset) - s.BytePosition;
                            m.Request.AssignFieldEncodingInfo("AndXPadding", s.BitPosition, padLength * 8);
                            m.Request.AndXPadding = (BinaryDecoder<Blob[padLength as uint]>(s) as Blob).Data;
                        }
                        if (m.Request.AndXCommand != 0xff)
                        {
                            m.AssignFieldEncodingInfo("AndXRequests", s.BitPosition, s.RemainingBitLength);
                            m.AndXRequests = DecodeAndXRequestMessages(s, m.Request.AndXCommand, isFlags2Unicode, m.Mid, dvar);
                        }
                        dispatch server accepts m;
                        
                    default =>
                        TryDecodeHeaderOnlyMessage(s, "ComLockingAndxRequest", false, 0x08);
                }
            }
            else // response
            {
                switch (s)
                {
                    case m:Messages.ComLockingAndxResponse from BinaryDecoder<Messages.ComLockingAndxResponse> =>
                        SmbStatusErrorCodeIf(m, DiagnosisLevel.Warning);
                        bool isFlags2Unicode = (m.Flags2 & 0x8000) == 0x8000;
                        if (s.BytePosition < s.ByteLength && m.Response.AndXOffset > s.BytePosition)
                        {
                            int padLength = (s.ByteLength < m.Response.AndXOffset ? s.ByteLength : m.Response.AndXOffset) - s.BytePosition;
                            m.Response.AssignFieldEncodingInfo("AndXPadding", s.BitPosition, padLength * 8);
                            m.Response.AndXPadding = (BinaryDecoder<Blob[padLength as uint]>(s) as Blob).Data;
                        }
                        if (m.Response.AndXCommand != 0xff)
                        {
                            m.AssignFieldEncodingInfo("AndXResponses", s.BitPosition, s.RemainingBitLength);
                            m.AndXResponses = DecodeAndXResponseMessages(s, m.Response.AndXCommand, isFlags2Unicode, m.Mid, dvar);
                        }
                        dispatch server issues m;
                        
                    default =>
                        TryDecodeHeaderOnlyMessage(s, "ComLockingAndxResponse", false, 0x02);
                }
            }
        case SmbCommand.SMB_COM_TRANSACTION =>
            if (isRequest) // request
            {
                switch (s)
                {
                    case m:Messages.ComTransactionRequest from BinaryDecoder<Messages.ComTransactionRequest> =>
                        if (m.Request.SetupCount > 0)
                        {
                            dvar.Subcommand[m.Mid] = (m.Request.Subcommand) as USHORT;
                        }
                        if (s.BytePosition < s.ByteLength && m.Request.ParameterOffset > s.BytePosition)
                        {
                            int padLength = m.Request.ParameterOffset - s.BytePosition;
                            m.Request.AssignFieldEncodingInfo("Pad1", s.BitPosition, padLength * 8);
                            m.Request.Pad1 = (BinaryDecoder<Blob[padLength as uint]>(s) as Blob).Data;
                        }
                        if (s.BytePosition < s.ByteLength && m.Request.ParameterCount > 0)
                        {
                            m.Request.AssignFieldEncodingInfo("TransParameters", s.BitPosition, m.Request.ParameterCount * 8);
                            if (m.Request.SetupCount > 0)
                            {
                                m.Request.TransParameters = BinaryDecoder<TransactionSubCommandsRequestParameters[(m.Request.Subcommand) as USHORT, m.Request.ParameterCount]>(s);
                            }
                            else
                            {
                                m.Request.TransParameters = BinaryDecoder<Blob[(m.Request.ParameterCount) as uint]>(s);
                            }
                        }
                        if (s.BytePosition < s.ByteLength && m.Request.DataOffset > s.BytePosition)
                        {
                            int padLength = m.Request.DataCount > 0 ? (m.Request.DataOffset - s.BytePosition) : (s.ByteLength - s.BytePosition);
                            m.Request.AssignFieldEncodingInfo("Pad2", s.BitPosition, padLength * 8);
                            m.Request.Pad2 = (BinaryDecoder<Blob[padLength as uint]>(s) as Blob).Data;
                        }
                        if (s.BytePosition < s.ByteLength && m.Request.DataCount > 0)
                        {
                            int dataCount = m.Request.DataCount > s.RemainingByteLength ? s.RemainingByteLength : m.Request.DataCount;
                            m.Request.AssignFieldEncodingInfo("TransData", s.BitPosition, dataCount * 8);
                            m.Request.TransData = (BinaryDecoder<Blob[dataCount as uint]>(s) as Blob).Data;
                            if (dataCount < m.Request.DataCount)
                            {
                                ReportInsufficientTruncation(m, "SMB", "TransData", "ComTransactionRequest", !dvar.pduFull);                            
                                
                                DisplayTopLevelMessage(m);
                            }
                            else
                            {
                                dispatch server accepts m;
                            }
                        }
                        else
                        {
                            dispatch server accepts m;
                        }
                        
                    default =>
                        TryDecodeHeaderOnlyMessage(s, "ComTransactionRequest", true, 0x0E);
                }
            }
            else // response
            {
                ushort mid = MakeWord(s.PeekByte(248), s.PeekByte(240));
                optional ushort subcommand = mid in dvar.Subcommand.Keys ? dvar.Subcommand[mid] : nothing;
                switch (s)
                {
                    case msg:Messages.ComTransactionResponse from BinaryDecoder<Messages.ComTransactionResponse[subcommand]> =>
                        SmbStatusErrorCodeIf(msg, DiagnosisLevel.Warning);
                        if (msg.Response.TotalParameterCount == msg.Response.ParameterCount && msg.Response.TotalDataCount == msg.Response.DataCount && msg.Mid in dvar.Subcommand.Keys)
                        {
                            dvar.Subcommand = dvar.Subcommand.Remove(msg.Mid);
                        }
                        dispatch server issues msg;
                    default =>
                        TryDecodeHeaderOnlyMessage(s, "ComTransactionResponse", true, 0x0A);
                }
            }
        case SmbCommand.SMB_COM_TRANSACTION_SECONDARY =>
            if (isRequest) // request
            {
                DecodeSmbRequest<Messages.ComTransactionSecondaryRequest>(s, "ComTransactionSecondaryRequest", false, 0x08, server.AcceptDispatcher);
            }
            else // response
            {
                DecodeSmbResponse<Messages.ComTransactionSecondaryResponse>(s, "ComTransactionSecondaryResponse", false, 0xFF, server.IssueDispatcher, DisplayErrorCode);
            }
        case SmbCommand.SMB_COM_IOCTL =>
            if (isRequest) // request
            {
                DecodeSmbRequest<Messages.ComIoctlRequest>(s, "ComIoctlRequest", false, 0x0E, server.AcceptDispatcher);
            }
            else // response
            {
                DecodeSmbResponse<Messages.ComIoctlResponse>(s, "ComIoctlResponse", false, 0x08, server.IssueDispatcher, DisplayErrorCode);
            }
        case SmbCommand.SMB_COM_ECHO =>
            if (isRequest) // request
            {
                DecodeSmbRequest<Messages.ComEchoRequest>(s, "ComEchoRequest", false, 0x01, server.AcceptDispatcher);
            }
            else // response
            {
                DecodeSmbResponse<Messages.ComEchoResponse>(s, "ComEchoResponse", false, 0x01, server.IssueDispatcher, DisplayErrorCode);
            }
        case SmbCommand.SMB_COM_WRITE_AND_CLOSE =>
            if (isRequest) // request
            {
                DecodeSmbRequest<Messages.ComWriteAndCloseRequest>(s, "ComWriteAndCloseRequest", true, 0x06, server.AcceptDispatcher);
            }
            else // response
            {
                DecodeSmbResponse<Messages.ComWriteAndCloseResponse>(s, "ComWriteAndCloseResponse", false, 0x01, server.IssueDispatcher, DisplayErrorCode);
            }
        case SmbCommand.SMB_COM_OPEN_ANDX =>
            if (isRequest) // request
            {
                switch (s)
                {
                    case m:Messages.ComOpenAndxRequest from BinaryDecoder<Messages.ComOpenAndxRequest> =>
                        bool isFlags2Unicode = (m.Flags2 & 0x8000) == 0x8000;
                        if (s.BytePosition < s.ByteLength && m.Request.AndXOffset > s.BytePosition)
                        {
                            int padLength = (s.ByteLength < m.Request.AndXOffset ? s.ByteLength : m.Request.AndXOffset) - s.BytePosition;
                            m.Request.AssignFieldEncodingInfo("AndXPadding", s.BitPosition, padLength * 8);
                            m.Request.AndXPadding = (BinaryDecoder<Blob[padLength as uint]>(s) as Blob).Data;
                        }
                        if (m.Request.AndXCommand != 0xff)
                        {
                            m.AssignFieldEncodingInfo("AndXRequests", s.BitPosition, s.RemainingBitLength);
                            m.AndXRequests = DecodeAndXRequestMessages(s, m.Request.AndXCommand, isFlags2Unicode, m.Mid, dvar);
                        }
                        dispatch server accepts m;
                        
                    default =>
                        TryDecodeHeaderOnlyMessage(s, "ComOpenAndxRequest", false, 0x0F);
                }
            }
            else // response
            {
                switch (s)
                {
                    case m:Messages.ComOpenAndxResponse from BinaryDecoder<Messages.ComOpenAndxResponse> =>
                        SmbStatusErrorCodeIf(m, DiagnosisLevel.Warning);
                        bool isFlags2Unicode = (m.Flags2 & 0x8000) == 0x8000;
                        if (s.BytePosition < s.ByteLength && m.Response.AndXOffset > s.BytePosition)
                        {
                            int padLength = (s.ByteLength < m.Response.AndXOffset ? s.ByteLength : m.Response.AndXOffset) - s.BytePosition;
                            m.Response.AssignFieldEncodingInfo("AndXPadding", s.BitPosition, padLength * 8);
                            m.Response.AndXPadding = (BinaryDecoder<Blob[padLength as uint]>(s) as Blob).Data;
                        }
                        if (m.Response.AndXCommand != 0xff)
                        {
                            m.AssignFieldEncodingInfo("AndXResponses", s.BitPosition, s.RemainingBitLength);
                            m.AndXResponses = DecodeAndXResponseMessages(s, m.Response.AndXCommand, isFlags2Unicode, m.Mid, dvar);
                        }
                        dispatch server issues m;
                        
                    default =>
                        TryDecodeHeaderOnlyMessage(s, "ComOpenAndxResponse", false, 0x0F);
                }
            }
        case SmbCommand.SMB_COM_READ_ANDX =>
            if (isRequest) // request
            {
                switch (s)
                {
                    case m:Messages.ComReadAndxRequest from BinaryDecoder<Messages.ComReadAndxRequest> =>
                        bool isFlags2Unicode = (m.Flags2 & 0x8000) == 0x8000;
                        if (s.BytePosition < s.ByteLength && m.Request.AndXOffset > s.BytePosition)
                        {
                            int padLength = (s.ByteLength < m.Request.AndXOffset ? s.ByteLength : m.Request.AndXOffset) - s.BytePosition;
                            m.Request.AssignFieldEncodingInfo("AndXPadding", s.BitPosition, padLength * 8);
                            m.Request.AndXPadding = (BinaryDecoder<Blob[padLength as uint]>(s) as Blob).Data;
                        }
                        if (m.Request.AndXCommand != 0xff)
                        {
                            m.AssignFieldEncodingInfo("AndXRequests", s.BitPosition, s.RemainingBitLength);
                            m.AndXRequests = DecodeAndXRequestMessages(s, m.Request.AndXCommand, isFlags2Unicode, m.Mid, dvar);
                        }
                        dispatch server accepts m;
                        
                    default =>
                        TryDecodeHeaderOnlyMessage(s, "ComReadAndxRequest", true, 0x0A);
                }
            }
            else // response
            {
                switch (s)
                {
                    case m:Messages.ComReadAndxResponse from BinaryDecoder<Messages.ComReadAndxResponse> =>
                        SmbStatusErrorCodeIf(m, DiagnosisLevel.Warning);                        
                        bool isFlags2Unicode = (m.Flags2 & 0x8000) == 0x8000;
                        int dataLength1 = m.Response.DataLength < m.Response.ByteCount ? (m.Response.DataLength + (m.Response.DataLengthHigh << 16)) : m.Response.DataLength;
                        int dataLength = dataLength1 > s.RemainingByteLength ? s.RemainingByteLength : dataLength1;
                        m.Response.AssignFieldEncodingInfo("Data", s.BitPosition, dataLength * 8);
                        m.Response.Data = (BinaryDecoder<Blob[dataLength as uint]>(s) as Blob).Data;
                        if (dataLength < dataLength1)
                        {
                            ReportInsufficientTruncation(m, "SMB", "Data", "ComReadAndxResponse", !dvar.pduFull);                            
                            DisplayTopLevelMessage(m);
                        }
                        else
                        {
                            if (s.BytePosition < s.ByteLength && m.Response.AndXOffset > s.BytePosition)
                            {
                                int padLength = (s.ByteLength < m.Response.AndXOffset ? s.ByteLength : m.Response.AndXOffset) - s.BytePosition;
                                m.Response.AssignFieldEncodingInfo("AndXPadding", s.BitPosition, padLength * 8);
                                m.Response.AndXPadding = (BinaryDecoder<Blob[padLength as uint]>(s) as Blob).Data;
                            }
                            if (m.Response.AndXCommand != 0xff)
                            {
                                m.AssignFieldEncodingInfo("AndXResponses", s.BitPosition, s.RemainingBitLength);
                                m.AndXResponses = DecodeAndXResponseMessages(s, m.Response.AndXCommand, isFlags2Unicode, m.Mid, dvar);
                            }
                            dispatch server issues m;
                        }
                        
                    default =>
                        TryDecodeHeaderOnlyMessage(s, "ComReadAndxResponse", false, 0x0C);
                }
            }
        case SmbCommand.SMB_COM_WRITE_ANDX =>
            if (isRequest) // request
            {
                switch (s)
                {
                    case m:Messages.ComWriteAndxRequest from BinaryDecoder<Messages.ComWriteAndxRequest> =>
                        bool isFlags2Unicode = (m.Flags2 & 0x8000) == 0x8000;
                        int dataLength1 = m.Request.DataLength < m.Request.ByteCount ? (m.Request.DataLength + (m.Request.DataLengthHigh << 16)) : m.Request.DataLength;
                        int dataLength = dataLength1 > s.RemainingByteLength ? s.RemainingByteLength : dataLength1;
                        m.Request.AssignFieldEncodingInfo("Data", s.BitPosition, dataLength * 8);
                        m.Request.Data = (BinaryDecoder<Blob[dataLength as uint]>(s) as Blob).Data;
                        if (dataLength < dataLength1)
                        {
                            ReportInsufficientTruncation(m, "SMB", "Data", "ComWriteAndxRequest", !dvar.pduFull);
                            DisplayTopLevelMessage(m);
                        }
                        else
                        {
                            if (s.BytePosition < s.ByteLength && m.Request.AndXOffset > s.BytePosition)
                            {
                                int padLength = (s.ByteLength < m.Request.AndXOffset ? s.ByteLength : m.Request.AndXOffset) - s.BytePosition;
                                m.Request.AssignFieldEncodingInfo("AndXPadding", s.BitPosition, padLength * 8);
                                m.Request.AndXPadding = (BinaryDecoder<Blob[padLength as uint]>(s) as Blob).Data;
                            }
                            if (m.Request.AndXCommand != 0xff)
                            {
                                m.AssignFieldEncodingInfo("AndXRequests", s.BitPosition, s.RemainingBitLength);
                                m.AndXRequests = DecodeAndXRequestMessages(s, m.Request.AndXCommand, isFlags2Unicode, m.Mid, dvar);
                            }
                            dispatch server accepts m;
                        }
                        
                    default =>
                        TryDecodeHeaderOnlyMessage(s, "ComWriteAndxRequest", true, 0x0C);
                }
            }
            else // response
            {
                switch (s)
                {
                    case m:Messages.ComWriteAndxResponse from BinaryDecoder<Messages.ComWriteAndxResponse> =>
                        SmbStatusErrorCodeIf(m, DiagnosisLevel.Warning);                        
                        bool isFlags2Unicode = (m.Flags2 & 0x8000) == 0x8000;
                        if (s.BytePosition < s.ByteLength && m.Response.AndXOffset > s.BytePosition)
                        {
                            int padLength = (s.ByteLength < m.Response.AndXOffset ? s.ByteLength : m.Response.AndXOffset) - s.BytePosition;
                            m.Response.AssignFieldEncodingInfo("AndXPadding", s.BitPosition, padLength * 8);
                            m.Response.AndXPadding = (BinaryDecoder<Blob[padLength as uint]>(s) as Blob).Data;
                        }
                        if (m.Response.AndXCommand != 0xff)
                        {
                            m.AssignFieldEncodingInfo("AndXResponses", s.BitPosition, s.RemainingBitLength);
                            m.AndXResponses = DecodeAndXResponseMessages(s, m.Response.AndXCommand, isFlags2Unicode, m.Mid, dvar);
                        }
                        dispatch server issues m;
                        
                    default =>
                        TryDecodeHeaderOnlyMessage(s, "ComWriteAndxResponse", false, 0x06);
                }
            }
        case SmbCommand.SMB_COM_TRANSACTION2 =>
            if (isRequest) // request
            {
                switch (s)
                {
                    case m:Messages.ComTransaction2Request from BinaryDecoder<Messages.ComTransaction2Request> =>
                        bool isFlags2Unicode = (m.Flags2 & 0x8000) == 0x8000;
                        dvar.Subcommand[m.Mid] = m.Request.Subcommand;
                        if (s.BytePosition < s.ByteLength && m.Request.ParameterOffset > s.BytePosition)
                        {
                            int padLength = m.Request.ParameterOffset - s.BytePosition;
                            m.Request.AssignFieldEncodingInfo("Pad1", s.BitPosition, padLength * 8);
                            m.Request.Pad1 = (BinaryDecoder<Blob[padLength as uint]>(s) as Blob).Data;
                        }
                        if (m.Request.ParameterCount > 0 && s.BytePosition < s.ByteLength)
                        {
                            m.Request.AssignFieldEncodingInfo("Trans2Parameters", s.BitPosition, m.Request.ParameterCount * 8);
                            m.Request.Trans2Parameters = BinaryDecoder<Trans2SubcommandRequestParameters[dvar.Subcommand[m.Mid], isFlags2Unicode, m.Request.ParameterCount]>(s);
                            if (m.Request.Trans2Parameters != nothing)
                            {
                                var paras = m.Request.Trans2Parameters as Trans2SubcommandRequestParameters;
                                switch (dvar.Subcommand[m.Mid])
                                {
                                    case 0x01 =>
                                        dvar.InformationLevel[m.Mid] = (paras.Parameters as Trans2FindFirst2RequestParameters).InformationLevel;
                                        dvar.Trans2FindFlags[m.Mid] = (paras.Parameters as Trans2FindFirst2RequestParameters).Flags;
                                    case 0x02 =>
                                        dvar.InformationLevel[m.Mid] = (paras.Parameters as Trans2FindNext2RequestParameters).InformationLevel;
                                        dvar.Trans2FindFlags[m.Mid] = (paras.Parameters as Trans2FindNext2RequestParameters).Flags;
                                    case 0x03 =>
                                        dvar.InformationLevel[m.Mid] = (paras.Parameters as Trans2QueryFSInformationRequestParameters).InformationLevel;
                                    case 0x05 =>
                                        dvar.InformationLevel[m.Mid] = (paras.Parameters as Trans2QueryPathInformationRequestParameters).InformationLevel;
                                    case 0x06 =>
                                        dvar.InformationLevel[m.Mid] = (paras.Parameters as Trans2SetPathInformationRequestParameters).InformationLevel;
                                    case 0x07 =>
                                        dvar.InformationLevel[m.Mid] = (paras.Parameters as Trans2QueryFileInformationRequestParameters).InformationLevel;
                                    case 0x08 =>
                                        dvar.InformationLevel[m.Mid] = (paras.Parameters as Trans2SetFileInformationRequestParameters).InformationLevel;
                                }
                            }
                        }
                        if (s.BytePosition < s.ByteLength && m.Request.DataOffset > s.BytePosition)
                        {
                            int padLength = m.Request.DataOffset - s.BytePosition;
                            m.Request.AssignFieldEncodingInfo("Pad2", s.BitPosition, padLength * 8);
                            m.Request.Pad2 = (BinaryDecoder<Blob[padLength as uint]>(s) as Blob).Data;
                        }
                        if (m.Request.DataCount > 0 && s.BytePosition < s.ByteLength)
                        {
                            m.Request.AssignFieldEncodingInfo("Trans2Data", s.BitPosition, m.Request.DataCount * 8);
                            m.Request.Trans2Data = BinaryDecoder<Trans2SubcommandRequestData[m.Request.Subcommand, m.Mid in dvar.InformationLevel ? dvar.InformationLevel[m.Mid] : 0, m.Request.DataCount]>(s);
                        }
                        dispatch server accepts m;
                        
                    default =>
                        TryDecodeHeaderOnlyMessage(s, "ComTransaction2Request", true, 0x0E);
                }
            }
            else // response
            {
                DecodeTransaction2Response(server, s, dvar, true, 0x0A, "ComTransaction2Response");
            }
        case SmbCommand.SMB_COM_TRANSACTION2_SECONDARY =>
            if (isRequest) // request
            {
                DecodeSmbRequest<Messages.ComTransaction2SecondaryRequest>(s, "ComTransaction2SecondaryRequest", false, 0x09, server.AcceptDispatcher);
            }
            else // response
            {
                DecodeSmbResponse<Messages.ComTransaction2SecondaryResponse>(s, "ComTransaction2SecondaryResponse", false, 0xFF, server.IssueDispatcher, DisplayErrorCode);
            }
        case SmbCommand.SMB_COM_FIND_CLOSE2 =>
            if (isRequest) // request
            {
                DecodeSmbRequest<Messages.ComFindClose2Request>(s, "ComFindClose2Request", false, 0x01, server.AcceptDispatcher);
            }
            else // response
            {
                DecodeSmbResponse<Messages.ComFindClose2Response>(s, "ComFindClose2Response", false, 0x00, server.IssueDispatcher, DisplayErrorCode);
            }
        case SmbCommand.SMB_COM_TREE_CONNECT =>
            if (isRequest) // request
            {
                DecodeSmbRequest<Messages.ComTreeConnectRequest>(s, "ComTreeConnectRequest", false, 0x00, server.AcceptDispatcher);
            }
            else // response
            {
                DecodeSmbResponse<Messages.ComTreeConnectResponse>(s, "ComTreeConnectResponse", false, 0x02, server.IssueDispatcher, DisplayErrorCode);
            }
        case SmbCommand.SMB_COM_TREE_DISCONNECT =>
            if (isRequest) // request
            {
                DecodeSmbRequest<Messages.ComTreeDisconnectRequest>(s, "ComTreeDisconnectRequest", false, 0x00, server.AcceptDispatcher);
            }
            else // response
            {
                DecodeSmbResponse<Messages.ComTreeDisconnectResponse>(s, "ComTreeDisconnectResponse", false, 0x00, server.IssueDispatcher, DisplayErrorCode);
            }
        case SmbCommand.SMB_COM_NEGOTIATE =>
            if (isRequest) // request
            {
                switch (s)
                {
                    case m:Messages.ComNegotiateRequest from BinaryDecoder<Messages.ComNegotiateRequest> =>
                        foreach (var d in m.Request.Dialects)
                        {
                            dvar.NegotiateDialects += [d.DialectString.Trim()];
                        }
                        m#EndpointIndex = dvar.EndpointIndex;
                        dispatch server accepts m;
                        
                    default =>
                        TryDecodeHeaderOnlyMessage(s, "ComNegotiateRequest", false, 0x00);
                }
            }
            else // response
            {
                switch (s)
                {
                    case m:Messages.ComNegotiateResponse from BinaryDecoder<Messages.ComNegotiateResponse> =>
                                                SmbStatusErrorCodeIf(m, DiagnosisLevel.Warning);                        
                        if (dvar.NegotiateDialects.Count > m.Response.DialectIndex)
                        {
                            m#DialectString = dvar.NegotiateDialects[m.Response.DialectIndex];
                            dvar.NegotiateDialects = [];
                        }
                        // When Response.WordCount == 0x11, the data type of Response.NTLanManager is SmbComNegotiateResponseNTLanManager
                        if (m.Response.WordCount == 0x11)
                        {
                            SmbComNegotiateResponseNTLanManager manager = m.Response.NTLanManager as SmbComNegotiateResponseNTLanManager;
                            if (manager.SecurityBlob != nothing)
                            {
                                binary b = manager.SecurityBlob as binary;
                                if(IsGSSAPIByCheckingTag(b))
                                {
                                    var gssapi = DecodeGssapiAndSetAnnotation(b, m);
                                    if (gssapi != nothing)
                                    {
                                        manager.SecurityBlob = gssapi as GssapiType;
                                    }
                                    else
                                    {
                                        ValidationCheck(false, m, DiagnosisLevel.Warning, () => Format(SMB_STR_GSSAPI_DECODING_FAILURE, "SmbComNegotiateResponseNTLanManager"));
                                    }
                                }
                            }
                        }
                        dispatch server issues m;
                        
                    default =>
                        TryDecodeHeaderOnlyMessage(s, "ComNegotiateResponse", false, 0x01);
                }
            }
        case SmbCommand.SMB_COM_SESSION_SETUP_ANDX =>
            if (isRequest) // request
            {
                switch (s)
                {
                    case m:Messages.ComSessionSetupAndxRequest from BinaryDecoder<Messages.ComSessionSetupAndxRequest> =>
                        bool isFlags2Unicode = (m.Flags2 & 0x8000) == 0x8000;
                        if (s.BytePosition < s.ByteLength && m.Request.AndXOffset > s.BytePosition)
                        {
                            int padLength = (s.ByteLength < m.Request.AndXOffset ? s.ByteLength : m.Request.AndXOffset) - s.BytePosition;
                            m.Request.AssignFieldEncodingInfo("AndXPadding", s.BitPosition, padLength * 8);
                            m.Request.AndXPadding = (BinaryDecoder<Blob[padLength as uint]>(s) as Blob).Data;
                        }
                        if (m.Request.AndXCommand != 0xff)
                        {
                            m.AssignFieldEncodingInfo("AndXRequests", s.BitPosition, s.RemainingBitLength);
                            m.AndXRequests = DecodeAndXRequestMessages(s, m.Request.AndXCommand, isFlags2Unicode, m.Mid, dvar);
                        }
                        if (m.Request.SecurityBlob != nothing)
                        {
                            binary b = m.Request.SecurityBlob as binary;
                            if (IsGSSAPIByCheckingTag(b))
                            {
                                var g = DecodeGssapiAndSetAnnotation(b, m);
                                if (g != nothing)
                                {
                                    GssapiType gssapi = g as GssapiType;
                                    m.Request.SecurityBlob = gssapi;
                                    m#KeyInformation = gssapi#KeyInformation;
                                }
                                else
                                {
                                    ValidationCheck(false, m, DiagnosisLevel.Warning, () => Format(SMB_STR_GSSAPI_DECODING_FAILURE, "ComSessionSetupAndxRequest"));
                                }
                            }
                            else if (IsNLMP(b))
                            {
                                var nlmpMessage = NlmpDecoder(b);
                                if (nlmpMessage != nothing)
                                {
                                    m.Request.SecurityBlob = nlmpMessage;
                                    m#Embedded = {"NLMP" -> ""};
                                    m#KeyInformation = GetSummaryInfo(nlmpMessage);
                                }
                                else
                                {
                                    ValidationCheck(false, m, DiagnosisLevel.Warning, () => Format(SMB_STR_NLMP_DECODING_FAILURE, "ComSessionSetupAndxRequest"));
                                }
                            }
                        }
                        dispatch server accepts m;

                    default =>
                        TryDecodeHeaderOnlyMessage(s, "ComSessionSetupAndxRequest", true, 0x0A);
                }
            }
            else // response
            {
                switch (s)
                {
                    case m:Messages.ComSessionSetupAndxResponse from BinaryDecoder<Messages.ComSessionSetupAndxResponse> =>
                                                SmbStatusErrorCodeIf(m, DiagnosisLevel.Warning);                        
                        bool isFlags2Unicode = (m.Flags2 & 0x8000) == 0x8000;
                        if (s.BytePosition < s.ByteLength && 35 + m.Response.WordCount * 2 + m.Response.ByteCount > s.BytePosition && m.Response.WordCount == 0x03)
                        {
                            int primaryDomainLength = 35 + m.Response.WordCount * 2 + m.Response.ByteCount - s.BytePosition;
                            m.Response.AssignFieldEncodingInfo("PrimaryDomain", s.BitPosition, primaryDomainLength * 8);
                            m.Response.PrimaryDomain = BinaryDecoder<SmbStringWithLength[isFlags2Unicode, (isFlags2Unicode ? primaryDomainLength / 2 : primaryDomainLength) as uint]>(s);
                        }
                        if (s.BytePosition < s.ByteLength && m.Response.AndXOffset > s.BytePosition)
                        {
                            int padLength = (s.ByteLength < m.Response.AndXOffset ? s.ByteLength : m.Response.AndXOffset) - s.BytePosition;
                            m.Response.AssignFieldEncodingInfo("AndXPadding", s.BitPosition, padLength * 8);
                            m.Response.AndXPadding = (BinaryDecoder<Blob[padLength as uint]>(s) as Blob).Data;
                        }
                        if (m.Response.AndXCommand != 0xff)
                        {
                            m.AssignFieldEncodingInfo("AndXResponses", s.BitPosition, s.RemainingBitLength);
                            m.AndXResponses = DecodeAndXResponseMessages(s, m.Response.AndXCommand, isFlags2Unicode, m.Mid, dvar);
                        }
                        if (m.Response.SecurityBlob != nothing)
                        {
                            binary b = m.Response.SecurityBlob as binary;
                            if (IsGSSAPIByCheckingTag(b))
                            {
                                var g = DecodeGssapiAndSetAnnotation(b, m);
                                if (g != nothing)
                                {
                                    GssapiType gssapi = g as GssapiType;
                                    m.Response.SecurityBlob = gssapi;
                                    m#KeyInformation = gssapi#KeyInformation;
                                }
                                else
                                {
                                    ValidationCheck(false, m, DiagnosisLevel.Warning, () => Format(SMB_STR_GSSAPI_DECODING_FAILURE, "ComSessionSetupAndxResponse"));
                                }
                            }
                            else if (IsNLMP(b))
                            {
                                var nlmpMessage = NlmpDecoder(b);
                                if (nlmpMessage != nothing)
                                {
                                    m.Response.SecurityBlob = nlmpMessage;
                                    m#Embedded = {"NLMP" -> ""};
                                    m#KeyInformation = GetSummaryInfo(nlmpMessage);
                                }
                                else
                                {
                                    ValidationCheck(false, m, DiagnosisLevel.Warning, () => Format(SMB_STR_NLMP_DECODING_FAILURE, "ComSessionSetupAndxResponse"));
                                }
                            }
                        }
                        dispatch server issues m;
                        
                    default =>
                        TryDecodeHeaderOnlyMessage(s, "ComSessionSetupAndxResponse", false, 0x03);
                }
            }
        case SmbCommand.SMB_COM_LOGOFF_ANDX =>
            if (isRequest) // request
            {
                switch (s)
                {
                    case m:Messages.ComLogoffAndxRequest from BinaryDecoder<Messages.ComLogoffAndxRequest> =>
                        bool isFlags2Unicode = (m.Flags2 & 0x8000) == 0x8000;
                        if (s.BytePosition < s.ByteLength && m.Request.AndXOffset > s.BytePosition)
                        {
                            int padLength = (s.ByteLength < m.Request.AndXOffset ? s.ByteLength : m.Request.AndXOffset) - s.BytePosition;
                            m.Request.AssignFieldEncodingInfo("AndXPadding", s.BitPosition, padLength * 8);
                            m.Request.AndXPadding = (BinaryDecoder<Blob[padLength as uint]>(s) as Blob).Data;
                        }
                        if (m.Request.AndXCommand != 0xff)
                        {
                            m.AssignFieldEncodingInfo("AndXRequests", s.BitPosition, s.RemainingBitLength);
                            m.AndXRequests = DecodeAndXRequestMessages(s, m.Request.AndXCommand, isFlags2Unicode, m.Mid, dvar);
                        }
                        dispatch server accepts m;
                        
                    default =>
                        TryDecodeHeaderOnlyMessage(s, "ComLogoffAndxRequest", false, 0x02);
                }
            }
            else // response
            {
                switch (s)
                {
                    case m:Messages.ComLogoffAndxResponse from BinaryDecoder<Messages.ComLogoffAndxResponse> =>
                                                SmbStatusErrorCodeIf(m, DiagnosisLevel.Warning);                       
                        bool isFlags2Unicode = (m.Flags2 & 0x8000) == 0x8000;
                        if (s.BytePosition < s.ByteLength && m.Response.AndXOffset > s.BytePosition)
                        {
                            int padLength = (s.ByteLength < m.Response.AndXOffset ? s.ByteLength : m.Response.AndXOffset) - s.BytePosition;
                            m.Response.AssignFieldEncodingInfo("AndXPadding", s.BitPosition, padLength * 8);
                            m.Response.AndXPadding = (BinaryDecoder<Blob[padLength as uint]>(s) as Blob).Data;
                        }
                        if (m.Response.AndXCommand != 0xff)
                        {
                            m.AssignFieldEncodingInfo("AndXResponses", s.BitPosition, s.RemainingBitLength);
                            m.AndXResponses = DecodeAndXResponseMessages(s, m.Response.AndXCommand, isFlags2Unicode, m.Mid, dvar);
                        }
                        dispatch server issues m;
                        
                    default =>
                        TryDecodeHeaderOnlyMessage(s, "ComLogoffAndxResponse", false, 0x02);
                }
            }
        case SmbCommand.SMB_COM_TREE_CONNECT_ANDX =>
            if (isRequest) // request
            {
                switch (s)
                {
                    case m:Messages.ComTreeConnectAndxRequest from BinaryDecoder<Messages.ComTreeConnectAndxRequest> =>
                        bool isFlags2Unicode = (m.Flags2 & 0x8000) == 0x8000;
                        if (s.BytePosition < s.ByteLength && m.Request.AndXOffset > s.BytePosition)
                        {
                            int padLength = (s.ByteLength < m.Request.AndXOffset ? s.ByteLength : m.Request.AndXOffset) - s.BytePosition;
                            m.Request.AssignFieldEncodingInfo("AndXPadding", s.BitPosition, padLength * 8);
                            m.Request.AndXPadding = (BinaryDecoder<Blob[padLength as uint]>(s) as Blob).Data;
                        }
                        if (m.Request.AndXCommand != 0xff)
                        {
                            m.AssignFieldEncodingInfo("AndXRequests", s.BitPosition, s.RemainingBitLength);
                            m.AndXRequests = DecodeAndXRequestMessages(s, m.Request.AndXCommand, isFlags2Unicode, m.Mid, dvar);
                        }
                        dispatch server accepts m;
                        
                    default =>
                        TryDecodeHeaderOnlyMessage(s, "ComTreeConnectAndxRequest", false, 0x04);
                }
            }
            else // response
            {
                switch (s)
                {
                    case m:Messages.ComTreeConnectAndxResponse from BinaryDecoder<Messages.ComTreeConnectAndxResponse> =>
                                                SmbStatusErrorCodeIf(m, DiagnosisLevel.Warning);                        
                        bool isFlags2Unicode = (m.Flags2 & 0x8000) == 0x8000;
                        if (s.BytePosition < s.ByteLength && m.Response.AndXOffset > s.BytePosition)
                        {
                            int padLength = (s.ByteLength < m.Response.AndXOffset ? s.ByteLength : m.Response.AndXOffset) - s.BytePosition;
                            m.Response.AssignFieldEncodingInfo("AndXPadding", s.BitPosition, padLength * 8);
                            m.Response.AndXPadding = (BinaryDecoder<Blob[padLength as uint]>(s) as Blob).Data;
                        }
                        if (m.Response.AndXCommand != 0xff)
                        {
                            m.AssignFieldEncodingInfo("AndXResponses", s.BitPosition, s.RemainingBitLength);
                            m.AndXResponses = DecodeAndXResponseMessages(s, m.Response.AndXCommand, isFlags2Unicode, m.Mid, dvar);
                        }
                        dispatch server issues m;
                        
                    default =>
                        TryDecodeHeaderOnlyMessage(s, "ComTreeConnectAndxResponse", false, 0x03);
                }
            }
        case SmbCommand.SMB_COM_QUERY_INFORMATION_DISK =>
            if (isRequest) // request
            {
                DecodeSmbRequest<Messages.ComQueryInformationDiskRequest>(s, "ComQueryInformationDiskRequest", false, 0x00, server.AcceptDispatcher);
            }
            else // response
            {
                DecodeSmbResponse<Messages.ComQueryInformationDiskResponse>(s, "ComQueryInformationDiskResponse", false, 0x05, server.IssueDispatcher, DisplayErrorCode);
            }
        case SmbCommand.SMB_COM_SEARCH =>
            if (isRequest) // request
            {
                DecodeSmbRequest<Messages.ComSearchRequest>(s, "ComSearchRequest", false, 0x02, server.AcceptDispatcher);
            }
            else // response
            {
                DecodeSmbResponse<Messages.ComSearchResponse>(s, "ComSearchResponse", false, 0x01, server.IssueDispatcher, DisplayErrorCode);
            }
        case SmbCommand.SMB_COM_FIND =>
            if (isRequest) // request
            {
                DecodeSmbRequest<Messages.ComFindRequest>(s, "ComFindRequest", false, 0x02, server.AcceptDispatcher);
            }
            else // response
            {
                DecodeSmbResponse<Messages.ComFindResponse>(s, "ComFindResponse", false, 0x01, server.IssueDispatcher, DisplayErrorCode);
            }
        case SmbCommand.SMB_COM_FIND_UNIQUE =>
            if (isRequest) // request
            {
                DecodeSmbRequest<Messages.ComFindUniqueRequest>(s, "ComFindUniqueRequest", false, 0x02, server.AcceptDispatcher);
            }
            else // response
            {
                DecodeSmbResponse<Messages.ComFindUniqueResponse>(s, "ComFindUniqueResponse", false, 0x01, server.IssueDispatcher, DisplayErrorCode);
            }
        case SmbCommand.SMB_COM_FIND_CLOSE =>
            if (isRequest) // request
            {
                DecodeSmbRequest<Messages.ComFindCloseRequest>(s, "ComFindCloseRequest", false, 0x02, server.AcceptDispatcher);
            }
            else // response
            {
                switch (s)
                {
                    case m:Messages.ComFindCloseResponse from BinaryDecoder<Messages.ComFindCloseResponse> =>
                        SmbStatusErrorCodeIf(m, DiagnosisLevel.Warning);                                                
                        if (s.RemainingByteLength == 3)
                        {
                            m.Response.AssignFieldEncodingInfo("BufferFormat", s.BitPosition, 8);
                            m.Response.BufferFormat = BinaryDecoder<byte>(s);
                            m.Response.AssignFieldEncodingInfo("DataLength", s.BitPosition, 16);
                            m.Response.DataLength = BinaryDecoder<ushort>(s);
                        }
                        dispatch server issues m;
                        
                    default =>
                        TryDecodeHeaderOnlyMessage(s, "ComFindCloseResponse", false, 0x01);
                }
            }
        case SmbCommand.SMB_COM_NT_TRANSACT =>
            if (isRequest) // request
            {
                switch (s)
                {
                    case m:Messages.ComNTTransactRequest from BinaryDecoder<Messages.ComNTTransactRequest> =>
                        dvar.Subcommand[m.Mid] = m.Request.Function;
                        if (m.Request.Function == 0x02)
                        {
                            dvar.IoctlFunctionCode[m.Mid] = (m.Request.Setup as NTTransactIoctlRequestSetup).FunctionCode;
                        }
                        dispatch server accepts m;
                        
                    default =>
                        TryDecodeHeaderOnlyMessage(s, "ComNTTransactRequest", true, 0x13);
                }
            }
            else // response
            {
                DecodeNTTransactResponse(server, s, dvar, true, 0x12, "ComNTTransactResponse");
            }
        case SmbCommand.SMB_COM_NT_TRANSACT_SECONDARY =>
            if (isRequest) // request
            {
                DecodeSmbRequest<Messages.ComNTTransactSecondaryRequest>(s, "ComNTTransactSecondaryRequest", false, 0x12, server.AcceptDispatcher);
            }
            else // response
            {
                DecodeSmbResponse<Messages.ComNTTransactSecondaryResponse>(s, "ComNTTransactSecondaryResponse", false, 0xFF, server.IssueDispatcher, DisplayErrorCode);
            }
        case SmbCommand.SMB_COM_NT_CREATE_ANDX =>
            if (isRequest) // request
            {
                switch (s)
                {
                    case m:Messages.ComNTCreateAndxRequest from BinaryDecoder<Messages.ComNTCreateAndxRequest> =>
                        bool isFlags2Unicode = (m.Flags2 & 0x8000) == 0x8000;
                        if (s.BytePosition < s.ByteLength && m.Request.AndXOffset > s.BytePosition)
                        {
                            int padLength = (s.ByteLength < m.Request.AndXOffset ? s.ByteLength : m.Request.AndXOffset) - s.BytePosition;
                            m.Request.AssignFieldEncodingInfo("AndXPadding", s.BitPosition, padLength * 8);
                            m.Request.AndXPadding = (BinaryDecoder<Blob[padLength as uint]>(s) as Blob).Data;
                        }
                        if (m.Request.AndXCommand != 0xff)
                        {
                            m.AssignFieldEncodingInfo("AndXRequests", s.BitPosition, s.RemainingBitLength);
                            m.AndXRequests = DecodeAndXRequestMessages(s, m.Request.AndXCommand, isFlags2Unicode, m.Mid, dvar);
                        }
                        dispatch server accepts m;
                        
                    default =>
                        TryDecodeHeaderOnlyMessage(s, "ComNTCreateAndxRequest", false, 0x18);
                }
            }
            else // response
            {
                switch (s)
                {
                    case m:Messages.ComNTCreateAndxResponse from BinaryDecoder<Messages.ComNTCreateAndxResponse> =>
                        SmbStatusErrorCodeIf(m, DiagnosisLevel.Warning);                                                
                        bool isFlags2Unicode = (m.Flags2 & 0x8000) == 0x8000;
                        if (s.BytePosition < s.ByteLength && m.Response.AndXOffset > s.BytePosition)
                        {
                            int padLength = (s.ByteLength < m.Response.AndXOffset ? s.ByteLength : m.Response.AndXOffset) - s.BytePosition;
                            m.Response.AssignFieldEncodingInfo("AndXPadding", s.BitPosition, padLength * 8);
                            m.Response.AndXPadding = (BinaryDecoder<Blob[padLength as uint]>(s) as Blob).Data;
                        }
                        if (m.Response.AndXCommand != 0xff)
                        {
                            m.AssignFieldEncodingInfo("AndXResponses", s.BitPosition, s.RemainingBitLength);
                            m.AndXResponses = DecodeAndXResponseMessages(s, m.Response.AndXCommand, isFlags2Unicode, m.Mid, dvar);
                        }
                        dispatch server issues m;
                        
                    default =>
                        TryDecodeHeaderOnlyMessage(s, "ComNTCreateAndxResponse", false, 0x22);
                }
            }
        case SmbCommand.SMB_COM_NT_CANCEL =>
            if (isRequest) // request
            {
                DecodeSmbRequest<Messages.ComNTCancelRequest>(s, "ComNTCancelRequest", false, 0x00, server.AcceptDispatcher);
            }
            else // response
            {
                DecodeSmbResponse<Messages.ComNTCancelResponse>(s, "ComNTCancelResponse",false, 0xFF, server.IssueDispatcher, DisplayErrorCode);
            }
        case SmbCommand.SMB_COM_NT_RENAME =>
            if (isRequest) // request
            {
                DecodeSmbRequest<Messages.ComNTRenameRequest>(s, "ComNTRenameRequest", false, 0x04, server.AcceptDispatcher);
            }
            else // response
            {
                DecodeSmbResponse<Messages.ComNTRenameResponse>(s, "ComNTRenameResponse", false, 0x00, server.IssueDispatcher, DisplayErrorCode);
            }
        case SmbCommand.SMB_COM_OPEN_PRINT_FILE =>
            if (isRequest) // request
            {
                DecodeSmbRequest<Messages.ComOpenPrintFileRequest>(s, "ComOpenPrintFileRequest", false, 0x02, server.AcceptDispatcher);
            }
            else // response
            {
                DecodeSmbResponse<Messages.ComOpenPrintFileResponse>(s, "ComOpenPrintFileResponse", false, 0x01, server.IssueDispatcher, DisplayErrorCode);
            }
        case SmbCommand.SMB_COM_WRITE_PRINT_FILE =>
            if (isRequest) // request
            {
                DecodeSmbRequest<Messages.ComWritePrintFileRequest>(s, "ComWritePrintFileRequest", false, 0x01, server.AcceptDispatcher);
            }
            else // response
            {
                DecodeSmbResponse<Messages.ComWritePrintFileResponse>(s, "ComWritePrintFileResponse", false, 0x00, server.IssueDispatcher, DisplayErrorCode);
            }
        case SmbCommand.SMB_COM_CLOSE_PRINT_FILE =>
            if (isRequest) // request
            {
                DecodeSmbRequest<Messages.ComClosePrintFileRequest>(s, "ComClosePrintFileRequest", false, 0x01, server.AcceptDispatcher);
            }
            else // response
            {
                DecodeSmbResponse<Messages.ComClosePrintFileResponse>(s, "ComClosePrintFileResponse", false, 0x00, server.IssueDispatcher, DisplayErrorCode);
            }
        default =>
            throw ("Unrecognized SMB command: " + command.ToString() + ".");
    }
    return;
}

bool IsErrorResponse(stream s)
{
    bool ret = true;
    if (s.PeekBytes(s.BitPosition + 32 * 8, 1) != $[00]) // WordCount != 0
    {
        ret = false;
    }
    else if ((s.PeekByte(88) & 0x4000) > 0 && (s.PeekByte(64) & 0xC0) == 0) // ERREF.NTSTATUS Severity != 3
    {
        ret = false;
    }
    else if ((s.PeekByte(88) & 0x4000) == 0 && (s.PeekByte(40) & 0xFF) == 0) // SMBStatus ErrorClass == 0
    {
        ret = false;
    }
    return ret;
}

bool DecodeAndxMessages<T>(stream s, ref UCHAR command, ref array<any> messages)
{
    switch (s)
    {
        case m:T from BinaryDecoder<T> =>
            command = 0xff;
            messages += [m];
            return true;
    }
    return false;
}

optional array<any> DecodeAndXRequestMessages(stream s, UCHAR andxCommand, bool isFlags2Unicode, ushort mid, DecoderVariables dvar)
{
    array<any> messages = [];
    UCHAR command = andxCommand;
    bool isDecodeSuccess = true;
    while (command != 0xff && s.BytePosition < s.ByteLength && isDecodeSuccess)
    {
        switch (command)
        {
            case SmbCommand.SMB_COM_CREATE_DIRECTORY =>
                switch (s)
                {
                    case req:SmbComCreateDirectoryRequest from BinaryDecoder<SmbComCreateDirectoryRequest[isFlags2Unicode]> =>
                        command = 0xFF;
                        messages += [req];
                    default =>
                        isDecodeSuccess = false;
                }
            case SmbCommand.SMB_COM_DELETE_DIRECTORY =>
                switch (s)
                {
                    case req:SmbComDeleteDirectoryRequest from BinaryDecoder<SmbComDeleteDirectoryRequest[isFlags2Unicode]> =>
                        command = 0xFF;
                        messages += [req];
                    default =>
                        isDecodeSuccess = false;
                }
            case SmbCommand.SMB_COM_OPEN =>
                switch (s)
                {
                    case req:SmbComOpenRequest from BinaryDecoder<SmbComOpenRequest[isFlags2Unicode]> =>
                        command = 0xFF;
                        messages += [req];
                    default =>
                        isDecodeSuccess = false;
                }
            case SmbCommand.SMB_COM_CREATE =>
                switch (s)
                {
                    case req:SmbComCreateRequest from BinaryDecoder<SmbComCreateRequest[isFlags2Unicode]> =>
                        command = 0xFF;
                        messages += [req];
                    default =>
                        isDecodeSuccess = false;
                }
            case SmbCommand.SMB_COM_CLOSE =>
                isDecodeSuccess = DecodeAndxMessages<SmbComCloseRequest>(s, ref command, ref messages);
            case SmbCommand.SMB_COM_FLUSH =>
                isDecodeSuccess = DecodeAndxMessages<SmbComFlushRequest>(s, ref command, ref messages);
            case SmbCommand.SMB_COM_DELETE =>
                switch (s)
                {
                    case req:SmbComDeleteRequest from BinaryDecoder<SmbComDeleteRequest[isFlags2Unicode]> =>
                        command = 0xFF;
                        messages += [req];
                    default =>
                        isDecodeSuccess = false;
                }
            case SmbCommand.SMB_COM_RENAME =>
                switch (s)
                {
                    case req:SmbComRenameRequest from BinaryDecoder<SmbComRenameRequest[isFlags2Unicode]> =>
                        command = 0xFF;
                        messages += [req];
                    default =>
                        isDecodeSuccess = false;
                }
            case SmbCommand.SMB_COM_QUERY_INFORMATION =>
                switch (s)
                {
                    case req:SmbComQueryInformationRequest from BinaryDecoder<SmbComQueryInformationRequest[isFlags2Unicode]> =>
                        command = 0xFF;
                        messages += [req];
                    default =>
                        isDecodeSuccess = false;
                }
            case SmbCommand.SMB_COM_SET_INFORMATION =>
                switch (s)
                {
                    case req:SmbComSetInformationRequest from BinaryDecoder<SmbComSetInformationRequest[isFlags2Unicode]> =>
                        command = 0xFF;
                        messages += [req];
                    default =>
                        isDecodeSuccess = false;
                }
            case SmbCommand.SMB_COM_READ =>
                isDecodeSuccess = DecodeAndxMessages<SmbComReadRequest>(s, ref command, ref messages);
            case SmbCommand.SMB_COM_WRITE =>
                isDecodeSuccess = DecodeAndxMessages<SmbComWriteRequest>(s, ref command, ref messages);
            case SmbCommand.SMB_COM_CREATE_NEW =>
                switch (s)
                {
                    case req:SmbComCreateNewRequest from BinaryDecoder<SmbComCreateNewRequest[isFlags2Unicode]> =>
                        command = 0xFF;
                        messages += [req];
                    default =>
                        isDecodeSuccess = false;
                }
            case SmbCommand.SMB_COM_CHECK_DIRECTORY =>
                switch (s)
                {
                    case req:SmbComCheckDirectoryRequest from BinaryDecoder<SmbComCheckDirectoryRequest[isFlags2Unicode]> =>
                        command = 0xFF;
                        messages += [req];
                    default =>
                        isDecodeSuccess = false;
                }
            case SmbCommand.SMB_COM_LOCK_AND_READ =>
                isDecodeSuccess = DecodeAndxMessages<SmbComLockAndReadRequest>(s, ref command, ref messages);
            case SmbCommand.SMB_COM_LOCKING_ANDX =>
                switch (s)
                {
                    case req:SmbComLockingAndxRequest from BinaryDecoder<SmbComLockingAndxRequest> =>
                        if (s.BytePosition < s.ByteLength && req.AndXOffset > s.BytePosition)
                        {
                            int padLength = req.AndXOffset - s.BytePosition;
                            req.AssignFieldEncodingInfo("AndXPadding", s.BitPosition, padLength * 8);
                            req.AndXPadding = (BinaryDecoder<Blob[padLength as uint]>(s) as Blob).Data;
                        }
                        command = req.AndXCommand;
                        messages += [req];
                    default =>
                        isDecodeSuccess = false;
                }
            case SmbCommand.SMB_COM_TRANSACTION =>
                switch (s)
                {
                    case req:SmbComTransactionRequest from BinaryDecoder<SmbComTransactionRequest[isFlags2Unicode]> =>
                        if (req.SetupCount > 0)
                        {
                            dvar.Subcommand[mid] = (req.Subcommand) as USHORT;
                        }
                        if (s.BytePosition < s.ByteLength && req.ParameterOffset > s.BytePosition)
                        {
                            int padLength = req.ParameterOffset - s.BytePosition;
                            req.AssignFieldEncodingInfo("Pad1", s.BitPosition, padLength * 8);
                            req.Pad1 = (BinaryDecoder<Blob[padLength as uint]>(s) as Blob).Data;
                        }
                        if (s.BytePosition < s.ByteLength && req.ParameterCount > 0)
                        {
                            req.AssignFieldEncodingInfo("TransParameters", s.BitPosition, req.ParameterCount * 8);
                            if (req.SetupCount > 0)
                            {
                                req.TransParameters = BinaryDecoder<TransactionSubCommandsRequestParameters[(req.Subcommand) as USHORT, req.ParameterCount]>(s);
                            }
                            else
                            {
                                req.TransParameters = BinaryDecoder<Blob[(req.ParameterCount) as uint]>(s);
                            }
                        }
                        if (s.BytePosition < s.ByteLength && req.DataOffset > s.BytePosition)
                        {
                            int padLength = req.DataCount > 0 ? (req.DataOffset - s.BytePosition) : (s.ByteLength - s.BytePosition);
                            req.AssignFieldEncodingInfo("Pad2", s.BitPosition, padLength * 8);
                            req.Pad2 = (BinaryDecoder<Blob[padLength as uint]>(s) as Blob).Data;
                        }
                        if (s.BytePosition < s.ByteLength && req.DataCount > 0)
                        {
                            req.AssignFieldEncodingInfo("TransData", s.BitPosition, req.DataCount * 8);
                            req.TransData = (BinaryDecoder<Blob[(req.DataCount) as uint]>(s) as Blob).Data;
                        }
                        command = 0xFF;
                        messages += [req];
                    default =>
                        isDecodeSuccess = false;
                }
            case SmbCommand.SMB_COM_IOCTL =>
                isDecodeSuccess = DecodeAndxMessages<SmbComIoctlRequest>(s, ref command, ref messages);
            case SmbCommand.SMB_COM_OPEN_ANDX =>
                switch (s)
                {
                    case req:SmbComOpenAndxRequest from BinaryDecoder<SmbComOpenAndxRequest[isFlags2Unicode]> =>
                        if (s.BytePosition < s.ByteLength && req.AndXOffset > s.BytePosition)
                        {
                            int padLength = req.AndXOffset - s.BytePosition;
                            req.AssignFieldEncodingInfo("AndXPadding", s.BitPosition, padLength * 8);
                            req.AndXPadding = (BinaryDecoder<Blob[padLength as uint]>(s) as Blob).Data;
                        }
                        command = req.AndXCommand;
                        messages += [req];
                    default =>
                        isDecodeSuccess = false;
                }
            case SmbCommand.SMB_COM_READ_ANDX =>
                switch (s)
                {
                    case req:SmbComReadAndxRequest from BinaryDecoder<SmbComReadAndxRequest> =>
                        if (s.BytePosition < s.ByteLength && req.AndXOffset > s.BytePosition)
                        {
                            int padLength = req.AndXOffset - s.BytePosition;
                            req.AssignFieldEncodingInfo("AndXPadding", s.BitPosition, padLength * 8);
                            req.AndXPadding = (BinaryDecoder<Blob[padLength as uint]>(s) as Blob).Data;
                        }
                        command = req.AndXCommand;
                        messages += [req];
                    default =>
                        isDecodeSuccess = false;
                }
            case SmbCommand.SMB_COM_WRITE_ANDX =>
                switch (s)
                {
                    case req:SmbComWriteAndxRequest from BinaryDecoder<SmbComWriteAndxRequest> =>
                        if (s.BytePosition < s.ByteLength && req.AndXOffset > s.BytePosition)
                        {
                            int padLength = req.AndXOffset - s.BytePosition;
                            req.AssignFieldEncodingInfo("AndXPadding", s.BitPosition, padLength * 8);
                            req.AndXPadding = (BinaryDecoder<Blob[padLength as uint]>(s) as Blob).Data;
                        }
                        command = req.AndXCommand;
                        messages += [req];
                    default =>
                        isDecodeSuccess = false;
                }
            case SmbCommand.SMB_COM_SESSION_SETUP_ANDX =>
                switch (s)
                {
                    case req:SmbComSessionSetupAndxRequest from BinaryDecoder<SmbComSessionSetupAndxRequest[isFlags2Unicode]> =>
                        if (s.BytePosition < s.ByteLength && req.AndXOffset > s.BytePosition)
                        {
                            int padLength = req.AndXOffset - s.BytePosition;
                            req.AssignFieldEncodingInfo("AndXPadding", s.BitPosition, padLength * 8);
                            req.AndXPadding = (BinaryDecoder<Blob[padLength as uint]>(s) as Blob).Data;
                        }
                        command = req.AndXCommand;
                        messages += [req];
                    default =>
                        isDecodeSuccess = false;
                }
            case SmbCommand.SMB_COM_TREE_CONNECT_ANDX =>
                switch (s)
                {
                    case req:SmbComTreeConnectAndxRequest from BinaryDecoder<SmbComTreeConnectAndxRequest[isFlags2Unicode]> =>
                        if (s.BytePosition < s.ByteLength && req.AndXOffset > s.BytePosition)
                        {
                            int padLength = req.AndXOffset - s.BytePosition;
                            req.AssignFieldEncodingInfo("AndXPadding", s.BitPosition, padLength * 8);
                            req.AndXPadding = (BinaryDecoder<Blob[padLength as uint]>(s) as Blob).Data;
                        }
                        command = req.AndXCommand;
                        messages += [req];
                    default =>
                        isDecodeSuccess = false;
                }
            case SmbCommand.SMB_COM_SEARCH =>
                switch (s)
                {
                    case req:SmbComSearchRequest from BinaryDecoder<SmbComSearchRequest[isFlags2Unicode]> =>
                        command = 0xFF;
                        messages += [req];
                    default =>
                        isDecodeSuccess = false;
                }
            case SmbCommand.SMB_COM_FIND =>
                switch (s)
                {
                    case req:SmbComFindRequest from BinaryDecoder<SmbComFindRequest[isFlags2Unicode]> =>
                        command = 0xFF;
                        messages += [req];
                    default =>
                        isDecodeSuccess = false;
                }
            case SmbCommand.SMB_COM_FIND_UNIQUE =>
                switch (s)
                {
                    case req:SmbComFindUniqueRequest from BinaryDecoder<SmbComFindUniqueRequest[isFlags2Unicode]> =>
                        command = 0xFF;
                        messages += [req];
                    default =>
                        isDecodeSuccess = false;
                }
            case SmbCommand.SMB_COM_NT_RENAME =>
                switch (s)
                {
                    case req:SmbComNTRenameRequest from BinaryDecoder<SmbComNTRenameRequest[isFlags2Unicode]> =>
                        command = 0xFF;
                        messages += [req];
                    default =>
                        isDecodeSuccess = false;
                }
            case SmbCommand.SMB_COM_OPEN_PRINT_FILE =>
                switch (s)
                {
                    case req:SmbComOpenPrintFileRequest from BinaryDecoder<SmbComOpenPrintFileRequest[isFlags2Unicode]> =>
                        command = 0xFF;
                        messages += [req];
                    default =>
                        isDecodeSuccess = false;
                }
            default =>
                isDecodeSuccess = false;
        }
    }
    if (command != 0xFF)
    {
        ValidationCheck(false, null, "SMB: The Andx request message is not decoded completely because the command value in the last Andx message is not set to 0xFF.");
    }
    return messages;
}

optional array<any> DecodeAndXResponseMessages(stream s, UCHAR andxCommand, bool isFlags2Unicode, ushort mid, DecoderVariables dvar)
{
    array<any> messages = [];
    UCHAR command = andxCommand;
    bool isDecodeSuccess = true;
    while (command != 0xff && s.BytePosition < s.ByteLength && isDecodeSuccess)
    {
        switch (command)
        {
            case SmbCommand.SMB_COM_CREATE_DIRECTORY =>
                isDecodeSuccess = DecodeAndxMessages<SmbComCreateDirectoryResponse>(s, ref command, ref messages);
            case SmbCommand.SMB_COM_DELETE_DIRECTORY =>
                isDecodeSuccess = DecodeAndxMessages<SmbComDeleteDirectoryResponse>(s, ref command, ref messages);
            case SmbCommand.SMB_COM_OPEN =>
                isDecodeSuccess = DecodeAndxMessages<SmbComOpenResponse>(s, ref command, ref messages);
            case SmbCommand.SMB_COM_CREATE =>
                isDecodeSuccess = DecodeAndxMessages<SmbComCreateResponse>(s, ref command, ref messages);
            case SmbCommand.SMB_COM_CLOSE =>
                isDecodeSuccess = DecodeAndxMessages<SmbComCloseResponse>(s, ref command, ref messages);
            case SmbCommand.SMB_COM_FLUSH =>
                isDecodeSuccess = DecodeAndxMessages<SmbComFlushResponse>(s, ref command, ref messages);
            case SmbCommand.SMB_COM_DELETE =>
                isDecodeSuccess = DecodeAndxMessages<SmbComDeleteResponse>(s, ref command, ref messages);
            case SmbCommand.SMB_COM_RENAME =>
                isDecodeSuccess = DecodeAndxMessages<SmbComRenameResponse>(s, ref command, ref messages);
            case SmbCommand.SMB_COM_QUERY_INFORMATION =>
                isDecodeSuccess = DecodeAndxMessages<SmbComQueryInformationResponse>(s, ref command, ref messages);
            case SmbCommand.SMB_COM_SET_INFORMATION =>
                isDecodeSuccess = DecodeAndxMessages<SmbComSetInformationResponse>(s, ref command, ref messages);
            case SmbCommand.SMB_COM_READ =>
                isDecodeSuccess = DecodeAndxMessages<SmbComReadResponse>(s, ref command, ref messages);
            case SmbCommand.SMB_COM_WRITE =>
                isDecodeSuccess = DecodeAndxMessages<SmbComWriteResponse>(s, ref command, ref messages);
            case SmbCommand.SMB_COM_CREATE_NEW =>
                isDecodeSuccess = DecodeAndxMessages<SmbComCreateNewResponse>(s, ref command, ref messages);
            case SmbCommand.SMB_COM_CHECK_DIRECTORY =>
                isDecodeSuccess = DecodeAndxMessages<SmbComCheckDirectoryResponse>(s, ref command, ref messages);
            case SmbCommand.SMB_COM_LOCK_AND_READ =>
                isDecodeSuccess = DecodeAndxMessages<SmbComLockAndReadResponse>(s, ref command, ref messages);
            case SmbCommand.SMB_COM_LOCKING_ANDX =>
                switch (s)
                {
                    case rsp:SmbComLockingAndxResponse from BinaryDecoder<SmbComLockingAndxResponse> =>
                        if (s.BytePosition < s.ByteLength && rsp.AndXOffset > s.BytePosition)
                        {
                            int padLength = rsp.AndXOffset - s.BytePosition;
                            rsp.AssignFieldEncodingInfo("AndXPadding", s.BitPosition, padLength * 8);
                            rsp.AndXPadding = (BinaryDecoder<Blob[padLength as uint]>(s) as Blob).Data;
                        }
                        command = rsp.AndXCommand;
                        messages += [rsp];
                    default =>
                        isDecodeSuccess = false;
                }
            case SmbCommand.SMB_COM_TRANSACTION =>
                optional ushort subcommand = mid in dvar.Subcommand.Keys ? dvar.Subcommand[mid] : nothing;
                switch (s)
                {
                    case rsp:SmbComTransactionResponse from BinaryDecoder<SmbComTransactionResponse[isFlags2Unicode, subcommand]> =>
                        if (rsp.TotalParameterCount == rsp.ParameterCount && rsp.TotalDataCount == rsp.DataCount && mid in dvar.Subcommand.Keys)
                        {
                            dvar.Subcommand = dvar.Subcommand.Remove(mid);
                        }
                        command = 0xFF;
                        messages += [rsp];
                    default =>
                        isDecodeSuccess = false;
                }
            case SmbCommand.SMB_COM_IOCTL =>
                isDecodeSuccess = DecodeAndxMessages<SmbComIoctlResponse>(s, ref command, ref messages);
            case SmbCommand.SMB_COM_OPEN_ANDX =>
                switch (s)
                {
                    case rsp:SmbComOpenAndxResponse from BinaryDecoder<SmbComOpenAndxResponse> =>
                        if (s.BytePosition < s.ByteLength && rsp.AndXOffset > s.BytePosition)
                        {
                            int padLength = rsp.AndXOffset - s.BytePosition;
                            rsp.AssignFieldEncodingInfo("AndXPadding", s.BitPosition, padLength * 8);
                            rsp.AndXPadding = (BinaryDecoder<Blob[padLength as uint]>(s) as Blob).Data;
                        }
                        command = rsp.AndXCommand;
                        messages += [rsp];
                    default =>
                        isDecodeSuccess = false;
                }
            case SmbCommand.SMB_COM_READ_ANDX =>
                switch (s)
                {
                    case rsp:SmbComReadAndxResponse from BinaryDecoder<SmbComReadAndxResponse[isFlags2Unicode]> =>
                        if (s.BytePosition < s.ByteLength && rsp.AndXOffset > s.BytePosition)
                        {
                            int padLength = rsp.AndXOffset - s.BytePosition;
                            rsp.AssignFieldEncodingInfo("AndXPadding", s.BitPosition, padLength * 8);
                            rsp.AndXPadding = (BinaryDecoder<Blob[padLength as uint]>(s) as Blob).Data;
                        }
                        command = rsp.AndXCommand;
                        messages += [rsp];
                    default =>
                        isDecodeSuccess = false;
                }
            case SmbCommand.SMB_COM_WRITE_ANDX =>
                switch (s)
                {
                    case rsp:SmbComWriteAndxResponse from BinaryDecoder<SmbComWriteAndxResponse> =>
                        if (s.BytePosition < s.ByteLength && rsp.AndXOffset > s.BytePosition)
                        {
                            int padLength = rsp.AndXOffset - s.BytePosition;
                            rsp.AssignFieldEncodingInfo("AndXPadding", s.BitPosition, padLength * 8);
                            rsp.AndXPadding = (BinaryDecoder<Blob[padLength as uint]>(s) as Blob).Data;
                        }
                        command = rsp.AndXCommand;
                        messages += [rsp];
                    default =>
                        isDecodeSuccess = false;
                }
            case SmbCommand.SMB_COM_SESSION_SETUP_ANDX =>
                switch (s)
                {
                    case rsp:SmbComSessionSetupAndxResponse from BinaryDecoder<SmbComSessionSetupAndxResponse[isFlags2Unicode]> =>
                        if (s.BytePosition < s.ByteLength && rsp.AndXOffset > s.BytePosition)
                        {
                            int padLength = rsp.AndXOffset - s.BytePosition;
                            rsp.AssignFieldEncodingInfo("AndXPadding", s.BitPosition, padLength * 8);
                            rsp.AndXPadding = (BinaryDecoder<Blob[padLength as uint]>(s) as Blob).Data;
                        }
                        command = rsp.AndXCommand;
                        messages += [rsp];
                    default =>
                        isDecodeSuccess = false;
                }
            case SmbCommand.SMB_COM_TREE_CONNECT_ANDX =>
                switch (s)
                {
                    case rsp:SmbComTreeConnectAndxResponse from BinaryDecoder<SmbComTreeConnectAndxResponse[isFlags2Unicode]> =>
                        if (s.BytePosition < s.ByteLength && rsp.AndXOffset > s.BytePosition)
                        {
                            int padLength = rsp.AndXOffset - s.BytePosition;
                            rsp.AssignFieldEncodingInfo("AndXPadding", s.BitPosition, padLength * 8);
                            rsp.AndXPadding = (BinaryDecoder<Blob[padLength as uint]>(s) as Blob).Data;
                        }
                        command = rsp.AndXCommand;
                        messages += [rsp];
                    default =>
                        isDecodeSuccess = false;
                }
            case SmbCommand.SMB_COM_SEARCH =>
                isDecodeSuccess = DecodeAndxMessages<SmbComSearchResponse>(s, ref command, ref messages);
            case SmbCommand.SMB_COM_FIND =>
                isDecodeSuccess = DecodeAndxMessages<SmbComFindResponse>(s, ref command, ref messages);
            case SmbCommand.SMB_COM_FIND_UNIQUE =>
                isDecodeSuccess = DecodeAndxMessages<SmbComFindUniqueResponse>(s, ref command, ref messages);
            case SmbCommand.SMB_COM_NT_RENAME =>
                isDecodeSuccess = DecodeAndxMessages<SmbComNTRenameResponse>(s, ref command, ref messages);
            case SmbCommand.SMB_COM_OPEN_PRINT_FILE =>
                isDecodeSuccess = DecodeAndxMessages<SmbComOpenPrintFileResponse>(s, ref command, ref messages);
            default =>
                isDecodeSuccess = false;
        }
    }
    
    if (!isDecodeSuccess)
    {
        DecodeAndxMessages<SmbErrorResponse>(s, ref command, ref messages);
    }
    
    if (command != 0xFF)
    {
        ValidationCheck(false, null, "SMB: The Andx response message is not decoded completely because the command value in the last Andx message is not set to 0xFF.");
    }
    return messages;
}

contract Messages
{
    issues ErrorResponse:FileResponse
    {
        SmbErrorResponse ErrorResponse;
        invariant ErrorResponse != null;
        override string ToString()
        {
            return "ErrorResponse, " + GetResponseSmbHeaderString(Status, Tid, Mid);
        }
    }

    accepts ComCreateDirectoryRequest:SmbRequest
    {
        SmbComCreateDirectoryRequest[(Flags2 & 0x8000) == 0x8000] Request;
        invariant Request != null;
        override string ToString()
        {
            return "ComCreateDirectoryRequest, " + GetRequestSmbHeaderString(Tid, Mid) + ", DirectoryName: " + Request.DirectoryName.Value;
        }
    }
    
    issues ComCreateDirectoryResponse:SmbResponse
    {
        SmbComCreateDirectoryResponse Response;
        invariant Response != null;
        override string ToString()
        {
            return "ComCreateDirectoryResponse, " + GetResponseSmbHeaderString(Status, Tid, Mid);
        }
    }
    
    accepts ComDeleteDirectoryRequest:SmbRequest
    {
        SmbComDeleteDirectoryRequest[(Flags2 & 0x8000) == 0x8000] Request;
        invariant Request != null;
        override string ToString()
        {
            return "ComDeleteDirectoryRequest, " + GetRequestSmbHeaderString(Tid, Mid) + ", DirectoryName: " + Request.DirectoryName.Value;
        }
    }
    
    issues ComDeleteDirectoryResponse:SmbResponse
    {
        SmbComDeleteDirectoryResponse Response;
        invariant Response != null;
        override string ToString()
        {
            return "ComDeleteDirectoryResponse, " + GetResponseSmbHeaderString(Status, Tid, Mid);
        }
    }
    
    accepts ComOpenRequest:FileRequest
    {
        SmbComOpenRequest[(Flags2 & 0x8000) == 0x8000] Request;
        invariant Request != null;
        override string ToString()
        {
            return "ComOpenRequest, " + GetRequestSmbHeaderString(Tid, Mid) + ", FileName: " + Request.FileName.Value;
        }
    }
    
    issues ComOpenResponse:FileResponse
    {
        SmbComOpenResponse Response;
        invariant Response != null;
        override string ToString()
        {
            return "ComOpenResponse, " + GetResponseSmbHeaderString(Status, Tid, Mid);
        }
    }
    
    accepts ComCreateRequest:FileRequest
    {
        SmbComCreateRequest[(Flags2 & 0x8000) == 0x8000] Request;
        invariant Request != null;
        override string ToString()
        {
            return "ComCreateRequest, " + GetRequestSmbHeaderString(Tid, Mid) + ", FileName: " + Request.FileName.Value;
        }
    }
    
    issues ComCreateResponse:FileResponse
    {
        SmbComCreateResponse Response;
        invariant Response != null;
        override string ToString()
        {
            return "ComCreateResponse, " + GetResponseSmbHeaderString(Status, Tid, Mid);
        }
    }
    
    accepts ComCloseRequest:FileRequest
    {
        SmbComCloseRequest Request;
        invariant Request != null;
        override string ToString()
        {
            return "ComCloseRequest, " + GetRequestSmbHeaderString(Tid, Mid) + ", Fid: " + DecToHexFormat(Request.Fid);
        }
    }
    
    issues ComCloseResponse:FileResponse
    {
        SmbComCloseResponse Response;
        invariant Response != null;
        override string ToString()
        {
            return "ComCloseResponse, " + GetResponseSmbHeaderString(Status, Tid, Mid);
        }
    }
    
    accepts ComFlushRequest:FileRequest
    {
        SmbComFlushRequest Request;
        invariant Request != null;
        override string ToString()
        {
            return "ComFlushRequest, " + GetRequestSmbHeaderString(Tid, Mid) + ", Fid: " + DecToHexFormat(Request.Fid);
        }
    }
    
    issues ComFlushResponse:FileResponse
    {
        SmbComFlushResponse Response;
        invariant Response != null;
        override string ToString()
        {
            return "ComFlushResponse, " + GetResponseSmbHeaderString(Status, Tid, Mid);
        }
    }
    
    accepts ComDeleteRequest:SmbRequest
    {
        SmbComDeleteRequest[(Flags2 & 0x8000) == 0x8000] Request;
        invariant Request != null;
        override string ToString()
        {
            return "ComDeleteRequest, " + GetRequestSmbHeaderString(Tid, Mid) + ", FileName: " + Request.FileName.Value;
        }
    }
    
    issues ComDeleteResponse:SmbResponse
    {
        SmbComDeleteResponse Response;
        invariant Response != null;
        override string ToString()
        {
            return "ComDeleteResponse, " + GetResponseSmbHeaderString(Status, Tid, Mid);
        }
    }
    
    accepts ComRenameRequest:SmbRequest
    {
        SmbComRenameRequest[(Flags2 & 0x8000) == 0x8000] Request;
        invariant Request != null;
        override string ToString()
        {
            return "ComRenameRequest, " + GetRequestSmbHeaderString(Tid, Mid) + ", OldFileName: " + Request.OldFileName.Value + ", NewFileName: " + Request.NewFileName.Value;
        }
    }
    
    issues ComRenameResponse:SmbResponse
    {
        SmbComRenameResponse Response;
        invariant Response != null;
        override string ToString()
        {
            return "ComRenameResponse, " + GetResponseSmbHeaderString(Status, Tid, Mid);
        }
    }
    
    accepts ComQueryInformationRequest:SmbRequest
    {
        SmbComQueryInformationRequest[(Flags2 & 0x8000) == 0x8000] Request;
        invariant Request != null;
        override string ToString()
        {
            return "ComQueryInformationRequest, " + GetRequestSmbHeaderString(Tid, Mid) + ", FileName: " + Request.FileName.Value;
        }
    }
    
    issues ComQueryInformationResponse:SmbResponse
    {
        SmbComQueryInformationResponse Response;
        invariant Response != null;
        override string ToString()
        {
            return "ComQueryInformationResponse, " + GetResponseSmbHeaderString(Status, Tid, Mid) + ", FileAttributes: " + EnumToString(Response.FileAttributes, "SMB.SmbFileAttributes");
        }
    }
    
    accepts ComSetInformationRequest:SmbRequest
    {
        SmbComSetInformationRequest[(Flags2 & 0x8000) == 0x8000] Request;
        invariant Request != null;
        override string ToString()
        {
            return "ComSetInformationRequest, " + GetRequestSmbHeaderString(Tid, Mid) + ", FileAttributes: " + EnumToString(Request.FileAttributes, "SMB.SmbFileAttributes") + ", FileName: " + Request.FileName.Value;
        }
    }
    
    issues ComSetInformationResponse:SmbResponse
    {
        SmbComSetInformationResponse Response;
        invariant Response != null;
        override string ToString()
        {
            return "ComSetInformationResponse" + GetResponseSmbHeaderString(Status, Tid, Mid);
        }
    }
    
    accepts ComReadRequest:FileRequest
    {
        SmbComReadRequest Request;
        invariant Request != null;
        override string ToString()
        {
            return "ComReadRequest, " + GetRequestSmbHeaderString(Tid, Mid) + ", Fid: " + DecToHexFormat(Request.Fid) + ", CountOfBytesToRead: " + (Request.CountOfBytesToRead as string)
                + ", ReadOffsetInBytes: " + (Request.ReadOffsetInBytes as string);
        }
    }
    
    issues ComReadResponse:FileResponse
    {
        SmbComReadResponse Response;
        invariant Response != null;
        override string ToString()
        {
            return "ComReadResponse, " + GetResponseSmbHeaderString(Status, Tid, Mid) + ", CountOfBytesReturned: " + (Response.CountOfBytesReturned as string);
        }
    }
    
    accepts ComWriteRequest:FileRequest
    {
        SmbComWriteRequest Request;
        invariant Request != null;
        override string ToString()
        {
            return "ComWriteRequest, " + GetRequestSmbHeaderString(Tid, Mid) + ", Fid: " + DecToHexFormat(Request.Fid) + ", CountOfBytesToWrite: " + (Request.CountOfBytesToWrite as string) 
                + ", WriteOffsetInBytes: " + (Request.WriteOffsetInBytes as string);
        }
    }
    
    issues ComWriteResponse:FileResponse
    {
        SmbComWriteResponse Response;
        invariant Response != null;
        override string ToString()
        {
            return "ComWriteResponse, " + GetResponseSmbHeaderString(Status, Tid, Mid) + ", CountOfBytesWritten: " + (Response.CountOfBytesWritten as string);
        }
    }
    
    accepts ComLockByteRangeRequest:FileRequest
    {
        SmbComLockByteRangeRequest Request;
        invariant Request != null;
        override string ToString()
        {
            return "ComLockByteRangeRequest, " + GetRequestSmbHeaderString(Tid, Mid) + ", Fid: " + DecToHexFormat(Request.Fid) 
                + ", CountOfBytesToLock: " + (Request.CountOfBytesToLock as string) + ", LockOffsetInBytes: " + (Request.LockOffsetInBytes as string);
        }
    }
    
    issues ComLockByteRangeResponse:FileResponse
    {
        SmbComLockByteRangeResponse Response;
        invariant Response != null;
        override string ToString()
        {
            return "ComLockByteRangeResponse, " + GetResponseSmbHeaderString(Status, Tid, Mid);
        }
    }
    
    accepts ComUnlockByteRangeRequest:FileRequest
    {
        SmbComUnlockByteRangeRequest Request;
        invariant Request != null;
        override string ToString()
        {
            return "ComUnlockByteRangeRequest, " + GetRequestSmbHeaderString(Tid, Mid) + ", Fid: " + DecToHexFormat(Request.Fid) 
                + ", CountOfBytesToUnlock: " + (Request.CountOfBytesToUnlock as string) + ", UnlockOffsetInBytes: " + (Request.UnlockOffsetInBytes as string);
        }
    }
    
    issues ComUnlockByteRangeResponse:FileResponse
    {
        SmbComUnlockByteRangeResponse Response;
        invariant Response != null;
        override string ToString()
        {
            return "ComUnlockByteRangeResponse, " + GetResponseSmbHeaderString(Status, Tid, Mid);
        }
    }
    
    accepts ComCreateTemporaryRequest:FileRequest
    {
        SmbComCreateTemporaryRequest[(Flags2 & 0x8000) == 0x8000] Request;
        invariant Request != null;
        override string ToString()
        {
            return "ComCreateTemporaryRequest, " + GetRequestSmbHeaderString(Tid, Mid) + ", DirectoryName: " + Request.DirectoryName.Value;
        }
    }
    
    issues ComCreateTemporaryResponse:FileResponse
    {
        SmbComCreateTemporaryResponse[(Flags2 & 0x8000) == 0x8000] Response;
        invariant Response != null;
        override string ToString()
        {
            return "ComCreateTemporaryResponse, " + GetResponseSmbHeaderString(Status, Tid, Mid) + ", TemporaryFileName: " + Response.TemporaryFileName;
        }
    }
    
    accepts ComCreateNewRequest:FileRequest
    {
        SmbComCreateNewRequest[(Flags2 & 0x8000) == 0x8000] Request;
        invariant Request != null;
        override string ToString()
        {
            return "ComCreateNewRequest, " + GetRequestSmbHeaderString(Tid, Mid) + ", FileName: " + Request.FileName.Value;
        }
    }
    
    issues ComCreateNewResponse:FileResponse
    {
        SmbComCreateNewResponse Response;
        invariant Response != null;
        override string ToString()
        {
            return "ComCreateNewResponse, " + GetResponseSmbHeaderString(Status, Tid, Mid) + ", Fid: " + DecToHexFormat(Response.Fid);
        }
    }
    
    accepts ComCheckDirectoryRequest:SmbRequest
    {
        SmbComCheckDirectoryRequest[(Flags2 & 0x8000) == 0x8000] Request;
        invariant Request != null;
        override string ToString()
        {
            return "ComCheckDirectoryRequest, " + GetRequestSmbHeaderString(Tid, Mid) + ", DirectoryName: " + Request.DirectoryName.Value;
        }
    }
    
    issues ComCheckDirectoryResponse:SmbResponse
    {
        SmbComCheckDirectoryResponse Response;
        invariant Response != null;
        override string ToString()
        {
            return "ComCheckDirectoryResponse, " + GetResponseSmbHeaderString(Status, Tid, Mid);
        }
    }
    
    accepts ComProcessExitRequest:SmbRequest
    {
        SmbComProcessExitRequest Request;
        invariant Request != null;
        override string ToString()
        {
            return "ComProcessExitRequest, " + GetRequestSmbHeaderString(Tid, Mid);
        }
    }
    
    issues ComProcessExitResponse:SmbResponse
    {
        SmbComProcessExitResponse Response;
        invariant Response != null;
        override string ToString()
        {
            return "ComProcessExitResponse, " + GetResponseSmbHeaderString(Status, Tid, Mid);
        }
    }
    
    accepts ComSeekRequest:FileRequest
    {
        SmbComSeekRequest Request;
        invariant Request != null;
        override string ToString()
        {
            return "ComSeekRequest, " + GetRequestSmbHeaderString(Tid, Mid) + ", Fid: " + DecToHexFormat(Request.Fid);
        }
    }
    
    issues ComSeekResponse:FileResponse
    {
        SmbComSeekResponse Response;
        invariant Response != null;
        override string ToString()
        {
            return "ComSeekResponse, " + GetResponseSmbHeaderString(Status, Tid, Mid);
        }
    }
    
    accepts ComLockAndReadRequest:FileRequest
    {
        SmbComLockAndReadRequest Request;
        invariant Request != null;
        override string ToString()
        {
            return "ComLockAndReadRequest, " + GetRequestSmbHeaderString(Tid, Mid) + ", Fid: " + DecToHexFormat(Request.Fid) + ", CountOfBytesToRead: " + (Request.CountOfBytesToRead as string)
                + ", ReadOffsetInBytes: " + (Request.ReadOffsetInBytes as string);
        }
    }
    
    issues ComLockAndReadResponse:FileResponse
    {
        SmbComLockAndReadResponse Response;
        invariant Response != null;
        override string ToString()
        {
            return "ComLockAndReadResponse, " + GetResponseSmbHeaderString(Status, Tid, Mid) + ", CountOfBytesReturned: " + (Response.CountOfBytesReturned as string);
        }
    }
    
    accepts ComWriteAndUnlockRequest:FileRequest
    {
        SmbComWriteAndUnlockRequest Request;
        invariant Request != null;
        override string ToString()
        {
            return "ComWriteAndUnlockRequest, " + GetRequestSmbHeaderString(Tid, Mid) + ", Fid: " + DecToHexFormat(Request.Fid) 
                + ", CountOfBytesToWrite: " + (Request.CountOfBytesToWrite as string) + ", WriteOffsetInBytes: " + (Request.WriteOffsetInBytes as string);
        }
    }
    
    issues ComWriteAndUnlockResponse:FileResponse
    {
        SmbComWriteAndUnlockResponse Response;
        invariant Response != null;
        override string ToString()
        {
            return "ComWriteAndUnlockResponse, " + GetResponseSmbHeaderString(Status, Tid, Mid) + ", CountOfBytesWritten: " + (Response.CountOfBytesWritten as string);
        }
    }
    
    accepts ComReadRawRequest:FileRequest
    {
        SmbComReadRawRequest Request;
        invariant Request != null;
        override string ToString()
        {
            return "ComReadRawRequest, " + GetRequestSmbHeaderString(Tid, Mid) + ", Fid: " + DecToHexFormat(Request.Fid) + ", Offset: " + (Request.Offset as string);
        }
    }
    
    issues ComReadRawResponse:FileResponse
    {
        SmbComReadRawResponse Response;
        invariant Response != null;
        override string ToString()
        {
            return "ComReadRawResponse, " + GetResponseSmbHeaderString(Status, Tid, Mid);
        }
    }
    
    accepts ComReadMpxRequest:FileRequest
    {
        SmbComReadMpxRequest Request;
        invariant Request != null;
        override string ToString()
        {
            return "ComReadMpxRequest, " + GetRequestSmbHeaderString(Tid, Mid) + ", Fid: " + DecToHexFormat(Request.Fid) + ", Offset: " + (Request.Offset as string);
        }
    }
    
    issues ComReadMpxResponse:FileResponse
    {
        SmbComReadMpxResponse Response;
        invariant Response != null;
        override string ToString()
        {
            return "ComReadMpxResponse, " + GetResponseSmbHeaderString(Status, Tid, Mid) + ", Offset: " + (Response.Offset as string) + ", Count: " + (Response.Count as string);
        }
    }
    
    accepts ComWriteRawRequest:FileRequest
    {
        SmbComWriteRawRequest Request;
        invariant Request != null;
        override string ToString()
        {
            return "ComWriteRawRequest, " + GetRequestSmbHeaderString(Tid, Mid) +  ", Fid: " + DecToHexFormat(Request.Fid) + ", CountOfBytes: " + (Request.CountOfBytes as string)
                + ", Offset: " + (Request.Offset as string) + ", WriteMode: " + EnumToString(Request.WriteMode, "SMB.SmbComWriteRawRequestParametersWordsWriteMode");
        }
    }
    
    issues ComWriteRawResponse:FileResponse
    {
        SmbComWriteRawResponse Response;
        invariant Response != null;
        override string ToString()
        {
            return "ComWriteRawResponse, " + GetResponseSmbHeaderString(Status, Tid, Mid);
        }
    }
    
    accepts ComWriteMpxRequest:FileRequest
    {
        SmbComWriteMpxRequest Request;
        invariant Request != null;
        override string ToString()
        {
            return "ComWriteMpxRequest, " + GetRequestSmbHeaderString(Tid, Mid) +  ", Fid: " + DecToHexFormat(Request.Fid) + ", TotalByteCount: " + (Request.TotalByteCount as string)
                + ", ByteOffsetToBeginWrite: " + (Request.ByteOffsetToBeginWrite as string) + ", WriteMode: " + EnumToString(Request.WriteMode, "SMB.SmbComWriteMpxRequestParametersWordsWriteMode");
        }
    }
    
    issues ComWriteMpxResponse:FileResponse
    {
        SmbComWriteMpxResponse Response;
        invariant Response != null;
        override string ToString()
        {
            return "ComWriteMpxResponse, " + GetResponseSmbHeaderString(Status, Tid, Mid);
        }
    }
    
    accepts ComSetInformation2Request:FileRequest
    {
        SmbComSetInformation2Request Request;
        invariant Request != null;
        override string ToString()
        {
            return "ComSetInformation2Request, " + GetRequestSmbHeaderString(Tid, Mid) +  ", Fid: " + DecToHexFormat(Request.Fid);
        }
    }
    
    issues ComSetInformation2Response:FileResponse
    {
        SmbComSetInformation2Response Response;
        invariant Response != null;
        override string ToString()
        {
            return "ComSetInformation2Response, " + GetResponseSmbHeaderString(Status, Tid, Mid);
        }
    }
    
    accepts ComQueryInformation2Request:FileRequest
    {
        SmbComQueryInformation2Request Request;
        invariant Request != null;
        override string ToString()
        {
            return "ComQueryInformation2Request, " + GetRequestSmbHeaderString(Tid, Mid) +  ", Fid: " + DecToHexFormat(Request.Fid);
        }
    }
    
    issues ComQueryInformation2Response:FileResponse
    {
        SmbComQueryInformation2Response Response;
        invariant Response != null;
        override string ToString()
        {
            return "ComQueryInformation2Response, " + GetResponseSmbHeaderString(Status, Tid, Mid);
        }
    }
    
    accepts ComLockingAndxRequest:FileRequest
    {
        SmbComLockingAndxRequest Request;
        optional array<any> AndXRequests with Encoding{Ignore = true};
        invariant Request != null;
        override string ToString()
        {
            return "ComLockingAndxRequest, " + GetRequestSmbHeaderString(Tid, Mid) +  ", Fid: " + DecToHexFormat(Request.Fid) + ", TypeOfLock: " 
                + TypeOfLockToString(Request.TypeOfLock) + ", NewOpLockLevel: " + (Request.NewOpLockLevel as string);
        }
    }
    
    issues ComLockingAndxResponse:FileResponse
    {
        SmbComLockingAndxResponse Response;
        optional array<any> AndXResponses with Encoding{Ignore = true};
        invariant Response != null;
        override string ToString()
        {
            return "ComLockingAndxResponse, " + GetResponseSmbHeaderString(Status, Tid, Mid);
        }
    }

    accepts ComTransactionRequest:FileRequest
    {
        SmbComTransactionRequest[(Flags2 & 0x8000) == 0x8000] Request;
        invariant Request != null;
        override string ToString()
        {
            if (Request.SetupCount > 0)
            {
                return "ComTransactionRequest, " + GetRequestSmbHeaderString(Tid, Mid) + (Request.ToString().Count == 0 ? "" : (", " + Request.ToString()));
            }
            else
            {
                return "ComTransactionRequest, Remote Administration Protocol, " + GetRequestSmbHeaderString(Tid, Mid);
            }
        }
    }
    
    issues ComTransactionResponse[optional ushort Subcommand]:FileResponse
    {
        SmbComTransactionResponse[(Flags2 & 0x8000) == 0x8000, Subcommand] Response;
        invariant Response != null;
        override string ToString()
        {
            return "ComTransactionResponse, " + GetResponseSmbHeaderString(Status, Tid, Mid) + (Response.ToString().Count == 0 ? "" : (", " + Response.ToString()));
        }
    }

    accepts ComTransactionSecondaryRequest:SmbRequest
    {
        SmbComTransactionSecondaryRequest Request;
        invariant Request != null;
        override string ToString()
        {
            return "ComTransactionSecondaryRequest, " + GetRequestSmbHeaderString(Tid, Mid);
        }
    }
    
    issues ComTransactionSecondaryResponse:SmbResponse // Response is empty
    {
        SmbComTransactionSecondaryResponse Response;
        invariant Response != null;
        override string ToString()
        {
            return "ComTransactionSecondaryResponse, " + GetResponseSmbHeaderString(Status, Tid, Mid);
        }
    }

    accepts ComIoctlRequest:FileRequest
    {
        SmbComIoctlRequest Request;
        invariant Request != null;
        override string ToString()
        {
            return "ComIoctlRequest, " + GetRequestSmbHeaderString(Tid, Mid) + ", Fid: " + DecToHexFormat(Request.Fid);
        }
    }
    
    issues ComIoctlResponse:FileResponse
    {
        SmbComIoctlResponse Response;
        invariant Response != null;
        override string ToString()
        {
            return "ComIoctlResponse" + GetResponseSmbHeaderString(Status, Tid, Mid);
        }
    }

    accepts ComEchoRequest:SmbRequest
    {
        SmbComEchoRequest Request;
        invariant Request != null;
        override string ToString()
        {
            return "ComEchoRequest, " + GetRequestSmbHeaderString(Tid, Mid);
        }
    }
    
    issues ComEchoResponse:SmbResponse
    {
        SmbComEchoResponse Response;
        invariant Response != null;
        override string ToString()
        {
            return "ComEchoResponse, " + GetResponseSmbHeaderString(Status, Tid, Mid) + ", SequenceNumber: " + (Response.SequenceNumber as string);
        }
    }

    accepts ComWriteAndCloseRequest:FileRequest
    {
        SmbComWriteAndCloseRequest Request;
        invariant Request != null;
        override string ToString()
        {
            return "ComWriteAndCloseRequest, " + GetRequestSmbHeaderString(Tid, Mid) + ", Fid: " + DecToHexFormat(Request.Fid) 
                + ", CountOfBytesToWrite: " + (Request.CountOfBytesToWrite as string) + ", WriteOffsetInBytes: " + (Request.WriteOffsetInBytes as string);
        }
    }
    
    issues ComWriteAndCloseResponse:FileResponse
    {
        SmbComWriteAndCloseResponse Response;
        invariant Response != null;
        override string ToString()
        {
            return "ComWriteAndCloseResponse, " + GetResponseSmbHeaderString(Status, Tid, Mid) + ", CountOfBytesWritten: " + (Response.CountOfBytesWritten as string);
        }
    }

    accepts ComOpenAndxRequest:FileRequest
    {
        SmbComOpenAndxRequest[(Flags2 & 0x8000) == 0x8000] Request;
        optional array<any> AndXRequests with Encoding{Ignore = true};
        invariant Request != null;
        override string ToString()
        {
            return "ComOpenAndxRequest, " + GetRequestSmbHeaderString(Tid, Mid) + ", FileName: " + Request.FileName.Value;
        }
    }
    
    issues ComOpenAndxResponse:FileResponse
    {
        SmbComOpenAndxResponse Response;
        optional array<any> AndXResponses with Encoding{Ignore = true};
        invariant Response != null;
        override string ToString()
        {
            return "ComOpenAndxResponse, " + GetResponseSmbHeaderString(Status, Tid, Mid) + ", Fid: " + DecToHexFormat(Response.Fid) + ", AccessRights: " + EnumToString(Response.AccessRights, "SMB.SmbComOpenAndxResponseAccessRight");
        }
    }

    accepts ComReadAndxRequest:FileRequest
    {
        SmbComReadAndxRequest Request;
        optional array<any> AndXRequests with Encoding{Ignore = true};
        invariant Request != null;
        override string ToString()
        {
            return "ComReadAndxRequest, " + GetRequestSmbHeaderString(Tid, Mid) + ", Fid: " + DecToHexFormat(Request.Fid);
        }
    }
    
    issues ComReadAndxResponse:FileResponse
    {
        SmbComReadAndxResponse[(Flags2 & 0x8000) == 0x8000] Response;
        optional array<any> AndXResponses with Encoding{Ignore = true};
        invariant Response != null;
        override string ToString()
        {
            return "ComReadAndxResponse, " + GetResponseSmbHeaderString(Status, Tid, Mid);
        }
    }

    accepts ComWriteAndxRequest:FileRequest
    {
        SmbComWriteAndxRequest Request;
        optional array<any> AndXRequests with Encoding{Ignore = true};
        invariant Request != null;
        override string ToString()
        {
            return "ComWriteAndxRequest, " + GetRequestSmbHeaderString(Tid, Mid) + ", Fid: " + DecToHexFormat(Request.Fid) + ", WriteMode: " + EnumToString(Request.WriteMode, "SMB.SmbComWriteAndxRequestParametersWordsWriteMode");
        }
    }
    
    issues ComWriteAndxResponse:FileResponse
    {
        SmbComWriteAndxResponse Response;
        optional array<any> AndXResponses with Encoding{Ignore = true};
        invariant Response != null;
        override string ToString()
        {
            return "ComWriteAndxResponse, " + GetResponseSmbHeaderString(Status, Tid, Mid) + ", Count: " + (Response.Count as string) + ", Available: " + (Response.Available as string);
        }
    }

    accepts ComTransaction2Request:FileRequest
    {
        SmbComTransaction2Request[(Flags2 & 0x8000) == 0x8000] Request;
        invariant Request != null;
        override string ToString()
        {
            return "SmbComTransaction2Request, " + GetRequestSmbHeaderString(Tid, Mid) + ", " + Request.ToString();
        }
    }
    
    issues ComTransaction2Response[optional ushort Subcommand, USHORT InfoLevel, bool ResumeKeyExist]:FileResponse
    {
        (SmbComTransaction2InterimResponse | SmbComTransaction2Response[(Flags2 & 0x8000) == 0x8000, Subcommand, InfoLevel, ResumeKeyExist]) Response;
        invariant Response != null;
        override string ToString()
        {
            string summary = "ComTransaction2Response, " + GetResponseSmbHeaderString(Status, Tid, Mid);
            if (Response is SmbComTransaction2Response && ((Response as SmbComTransaction2Response).ToString() != ""))
            {
                summary += ", " + (Response as SmbComTransaction2Response).ToString();
            }
            return summary;
        }
    }

    accepts ComTransaction2SecondaryRequest:SmbRequest
    {
        SmbComTransaction2SecondaryRequest Request;
        invariant Request != null;
        override string ToString()
        {
            return "SmbComTransaction2SecondaryRequest, " + GetRequestSmbHeaderString(Tid, Mid) + ", Fid: " + DecToHexFormat(Request.Fid)
                + ", DataCount: " + (Request.DataCount as string) + ", DataOffset: " + (Request.DataOffset as string);
        }
    }
    
    issues ComTransaction2SecondaryResponse:SmbResponse
    {
        SmbComTransaction2SecondaryResponse Response;
        invariant Response != null;
        override string ToString()
        {
            return "SmbComTransaction2SecondaryResponse, " + GetResponseSmbHeaderString(Status, Tid, Mid);
        }
    }

    accepts ComFindClose2Request:SmbRequest
    {
        SmbComFindClose2Request Request;
        invariant Request != null;
        override string ToString()
        {
            return "ComFindClose2Request, " + GetRequestSmbHeaderString(Tid, Mid) + ", Sid: " + DecToHexFormat(Request.Sid);
        }
    }
    
    issues ComFindClose2Response:SmbResponse
    {
        SmbComFindClose2Response Response;
        invariant Response != null;
        override string ToString()
        {
            return "ComFindClose2Response, " + GetResponseSmbHeaderString(Status, Tid, Mid);
        }
    }

    accepts ComTreeConnectRequest:SmbRequest
    {
        SmbComTreeConnectRequest Request;
        invariant Request != null;
        override string ToString()
        {
            return "ComTreeConnectRequest, " + GetRequestSmbHeaderString(Tid, Mid) + ", Path: " + Request.Path + ", Password: " + Request.Password + ", Service: " + Request.Service;
        }
    }
    
    issues ComTreeConnectResponse:SmbResponse
    {
        SmbComTreeConnectResponse Response;
        invariant Response != null;
        override string ToString()
        {
            return "ComTreeConnectResponse, " + GetResponseSmbHeaderString(Status, Tid, Mid);
        }
    }

    accepts ComTreeDisconnectRequest:SmbRequest
    {
        SmbComTreeDisconnectRequest Request;
        invariant Request != null;
        override string ToString()
        {
            return "ComTreeDisconnectRequest, " +  GetRequestSmbHeaderString(Tid, Mid);
        }
    }
    
    issues ComTreeDisconnectResponse:SmbResponse
    {
        SmbComTreeDisconnectResponse Response;
        invariant Response != null;
        override string ToString()
        {
            return "ComTreeDisconnectResponse, " + GetResponseSmbHeaderString(Status, Tid, Mid);
        }
    }

    accepts ComNegotiateRequest:SmbRequest
    {
        SmbComNegotiateRequest Request;
        invariant Request != null;
        override string ToString()
        {
            string summary = "ComNegotiateRequest, " + GetRequestSmbHeaderString(Tid, Mid);
            summary += ", Dialects: " + DialectArrayToText(Request.Dialects);
            return summary;
        }
    }
    
    issues ComNegotiateResponse:SmbResponse
    {
        SmbComNegotiateResponse[(Flags2 & 0x8000) == 0x8000] Response;
        invariant Response != null;
        override string ToString()
        {
            return "ComNegotiateResponse, " + GetResponseSmbHeaderString(Status, Tid, Mid) + ", DialectIndex: " + (Response.DialectIndex as string);
        }
    }

    accepts ComSessionSetupAndxRequest:SmbRequest
    {
        SmbComSessionSetupAndxRequest[(Flags2 & 0x8000) == 0x8000] Request;
        optional array<any> AndXRequests with Encoding{Ignore = true};
        invariant Request != null;
        override string ToString()
        {
            return "ComSessionSetupAndxRequest" + (this#KeyInformation != nothing ? ", " + this#KeyInformation.ToString() : "") +
                ", " + GetRequestSmbHeaderString(Tid, Mid) + (Request.AccountName == nothing ? "" : (", AccountName: " + Request.AccountName.ToString())) +
                (Request.PrimaryDomain == nothing ? "" : (", PrimaryDomain: " + Request.PrimaryDomain.ToString()));
        }
    }
    
    issues ComSessionSetupAndxResponse:SmbResponse
    {
        SmbComSessionSetupAndxResponse[(Flags2 & 0x8000) == 0x8000] Response;
        optional array<any> AndXResponses with Encoding{Ignore = true};
        invariant Response != null;
        override string ToString()
        {
            return "ComSessionSetupAndxResponse, Status: " + SmbStatusValuesToText(Status) +
                (this#KeyInformation != nothing ? ", " + this#KeyInformation.ToString() : "") +
                ", Tid: " + DecToHexFormat(Tid) + ", Mid: " + DecToHexFormat(Mid) + ", Uid: " + DecToHexFormat(Uid);
        }
    }

    accepts ComLogoffAndxRequest:SmbRequest
    {
        SmbComLogoffAndxRequest Request;
        optional array<any> AndXRequests with Encoding{Ignore = true};
        invariant Request != null;
        override string ToString()
        {
            return "ComLogoffAndxRequest, " + GetRequestSmbHeaderString(Tid, Mid) + ", Uid: " + DecToHexFormat(Uid);
        }
    }
    
    issues ComLogoffAndxResponse:SmbResponse
    {
        SmbComLogoffAndxResponse Response;
        optional array<any> AndXResponses with Encoding{Ignore = true};
        invariant Response != null;
        override string ToString()
        {
            return "ComLogoffAndxResponse, " + GetResponseSmbHeaderString(Status, Tid, Mid);
        }
    }

    accepts ComTreeConnectAndxRequest:SmbRequest
    {
        SmbComTreeConnectAndxRequest[(Flags2 & 0x8000) == 0x8000] Request;
        optional array<any> AndXRequests with Encoding{Ignore = true};
        invariant Request != null;
        override string ToString()
        {
            return "ComTreeConnectAndxRequest, " + GetRequestSmbHeaderString(Tid, Mid) + ", Path: " + Request.Path.Value + ", Service: " + Request.Service;
        }
    }
    
    issues ComTreeConnectAndxResponse:SmbResponse
    {
        SmbComTreeConnectAndxResponse[(Flags2 & 0x8000) == 0x8000] Response;
        optional array<any> AndXResponses with Encoding{Ignore = true};
        invariant Response != null;
        override string ToString()
        {
            return "ComTreeConnectAndxResponse, " + GetResponseSmbHeaderString(Status, Tid, Mid) + ", Service: " + Response.Service;
        }
    }

    accepts ComQueryInformationDiskRequest:SmbRequest
    {
        SmbComQueryInformationDiskRequest Request;
        invariant Request != null;
        override string ToString()
        {
            return "ComQueryInformationDiskRequest, " + GetRequestSmbHeaderString(Tid, Mid);
        }
    }
    
    issues ComQueryInformationDiskResponse:SmbResponse
    {
        SmbComQueryInformationDiskResponse Response;
        invariant Response != null;
        override string ToString()
        {
            return "ComQueryInformationDiskResponse, " + GetResponseSmbHeaderString(Status, Tid, Mid) + ", TotalUnits: " + (Response.TotalUnits as string) + ", FreeUnits: " + (Response.FreeUnits as string);
        }
    }

    accepts ComSearchRequest:SmbRequest
    {
        SmbComSearchRequest[(Flags2 & 0x8000) == 0x8000] Request;
        invariant Request != null;
        override string ToString()
        {
            return "ComSearchRequest, " + GetRequestSmbHeaderString(Tid, Mid) + ", FileName: " + Request.FileName.Value;
        }
    }
    
    issues ComSearchResponse:SmbResponse
    {
        SmbComSearchResponse Response;
        invariant Response != null;
        override string ToString()
        {
            return "ComSearchResponse, " + GetResponseSmbHeaderString(Status, Tid, Mid) + ", Count: " + (Response.Count as string);
        }
    }

    accepts ComFindRequest:SmbRequest
    {
        SmbComFindRequest[(Flags2 & 0x8000) == 0x8000] Request;
        invariant Request != null;
        override string ToString()
        {
            return "ComFindRequest, " + GetRequestSmbHeaderString(Tid, Mid) + ", FileName: " + Request.FileName.Value;
        }
    }
    
    issues ComFindResponse:SmbResponse
    {
        SmbComFindResponse Response;
        invariant Response != null;
        override string ToString()
        {
            return "ComFindResponse, " + GetResponseSmbHeaderString(Status, Tid, Mid) + ", Count: " + (Response.Count as string);
        }
    }

    accepts ComFindUniqueRequest:SmbRequest
    {
        SmbComFindUniqueRequest[(Flags2 & 0x8000) == 0x8000] Request;
        invariant Request != null;
        override string ToString()
        {
            return "ComFindUniqueRequest, " + GetRequestSmbHeaderString(Tid, Mid) + ", FileName: " + Request.FileName.Value;
        }
    }
    
    issues ComFindUniqueResponse:SmbResponse
    {
        SmbComFindUniqueResponse Response;
        invariant Response != null;
        override string ToString()
        {
            return "ComFindUniqueResponse, " + GetResponseSmbHeaderString(Status, Tid, Mid) + ", Count: " + (Response.Count as string);
        }
    }

    accepts ComFindCloseRequest:SmbRequest
    {
        SmbComFindCloseRequest[(Flags2 & 0x8000) == 0x8000] Request;
        invariant Request != null;
        override string ToString()
        {
            return "ComFindCloseRequest, " + GetRequestSmbHeaderString(Tid, Mid) + ", FileName: " + Request.FileName.Value;
        }
    }
    
    issues ComFindCloseResponse:SmbResponse
    {
        SmbComFindCloseResponse Response;
        invariant Response != null;
        override string ToString()
        {
            return "ComFindCloseResponse, " + GetResponseSmbHeaderString(Status, Tid, Mid) + ", Count: " + (Response.Count as string);
        }
    }

    accepts ComNTTransactRequest:FileRequest
    {
        SmbComNTTransactRequest[(Flags2 & 0x8000) == 0x8000] Request;
        invariant Request != null;
        override string ToString()
        {
            return "ComNTTransactRequest, " + GetRequestSmbHeaderString(Tid, Mid) + ", " + Request.ToString();
        }
    }
    
    issues ComNTTransactResponse[optional ushort Function, uint IoctlFunctionCode]:FileResponse
    {
        SmbComNTTransactResponse[(Flags2 & 0x8000) == 0x8000, Function, IoctlFunctionCode] Response;
        invariant Response != null;
        override string ToString()
        {
            string summary = "ComNTTransactResponse, " + GetResponseSmbHeaderString(Status, Tid, Mid);
            if (Response.Parameters != nothing && (Response.Parameters is NTTransactCreateResponseNTTransparameters))
            {
                summary += ", " + Response.Parameters.ToString();
            }
            return summary;
        }
    }

    accepts ComNTTransactSecondaryRequest:SmbRequest
    {
        SmbComNTTransactSecondaryRequest Request;
        invariant Request != null;
        override string ToString()
        {
            return "ComNTTransactSecondaryRequest, " + GetRequestSmbHeaderString(Tid, Mid);
        }
    }
    
    issues ComNTTransactSecondaryResponse:SmbResponse
    {
        SmbComNTTransactSecondaryResponse Response;
        invariant Response != null;
        override string ToString()
        {
            return "ComNTTransactSecondaryResponse, " + GetResponseSmbHeaderString(Status, Tid, Mid);
        }
    }

    accepts ComNTCreateAndxRequest:FileRequest
    {
        SmbComNTCreateAndxRequest[(Flags2 & 0x8000) == 0x8000] Request;
        optional array<any> AndXRequests with Encoding{Ignore = true};
        invariant Request != null;
        override string ToString()
        {
            return "ComNTCreateAndxRequest, " + GetRequestSmbHeaderString(Tid, Mid) + ", FileName: " + Request.FileName.Value;
        }
    }
    
    issues ComNTCreateAndxResponse:FileResponse
    {
        SmbComNTCreateAndxResponse Response;
        optional array<any> AndXResponses with Encoding{Ignore = true};
        invariant Response != null;
        override string ToString()
        {
            return "ComNTCreateAndxResponse, " + GetResponseSmbHeaderString(Status, Tid, Mid) + ", OpLockLevel: " + EnumToString(Response.OpLockLevel, "SMB.SmbOpLockLevel") + ", Fid: " + DecToHexFormat(Response.Fid) + ", ResourceType: " + EnumToString(Response.ResourceType, "SMB.SmbComNTCreateAndxResponseResourceType");
        }
    }

    accepts ComNTCancelRequest:SmbRequest
    {
        SmbComNTCancelRequest Request;
        invariant Request != null;
        override string ToString()
        {
            return "ComNTCancelRequest, " + GetRequestSmbHeaderString(Tid, Mid) + ", Uid: " + DecToHexFormat(Uid);
        }
    }
    
    issues ComNTCancelResponse:SmbResponse
    {
        SmbComNTCancelResponse Response;
        invariant Response != null;
        override string ToString()
        {
            return "ComNTCancelResponse, " + GetResponseSmbHeaderString(Status, Tid, Mid);
        }
    }

    accepts ComNTRenameRequest:SmbRequest
    {
        SmbComNTRenameRequest[(Flags2 & 0x8000) == 0x8000] Request;
        invariant Request != null;
        override string ToString()
        {
            return "ComNTRenameRequest, " + GetRequestSmbHeaderString(Tid, Mid) + ", OldFileName: " + Request.OldFileName.Value + ", NewFileName: " 
                + Request.NewFileName.Value + ", InformationLevel: " + Trans2SetFSInformationRequestParameters.InformationLevelToText(Request.InformationLevel);
        }
    }
    
    issues ComNTRenameResponse:SmbResponse
    {
        SmbComNTRenameResponse Response;
        invariant Response != null;
        override string ToString()
        {
            return "ComNTRenameResponse, " + GetResponseSmbHeaderString(Status, Tid, Mid);
        }
    }

    accepts ComOpenPrintFileRequest:FileRequest
    {
        SmbComOpenPrintFileRequest[(Flags2 & 0x8000) == 0x8000] Request;
        invariant Request != null;
        override string ToString()
        {
            return "ComOpenPrintFileRequest, " + GetRequestSmbHeaderString(Tid, Mid) + ", Mode: " + EnumToString(Request.Mode, "SMB.SmbComOpenPrintFileRequestParametersWordsMode") + ", Identifier: " + Request.Identifier.Value;
        }
    }
    
    issues ComOpenPrintFileResponse:FileResponse
    {
        SmbComOpenPrintFileResponse Response;
        invariant Response != null;
        override string ToString()
        {
            return "ComOpenPrintFileResponse, " + GetResponseSmbHeaderString(Status, Tid, Mid) + ", Fid: " + DecToHexFormat(Response.Fid);
        }
    }

    accepts ComWritePrintFileRequest:FileRequest
    {
        SmbComWritePrintFileRequest Request;
        invariant Request != null;
        override string ToString()
        {
            return "ComWritePrintFileRequest, " + GetRequestSmbHeaderString(Tid, Mid) + ", Fid: " + DecToHexFormat(Request.Fid) + ", DataLength: " + (Request.DataLength as string);
        }
    }
    
    issues ComWritePrintFileResponse:FileResponse
    {
        SmbComWritePrintFileResponse Response;
        invariant Response != null;
        override string ToString()
        {
            return "ComWritePrintFileResponse, " + GetResponseSmbHeaderString(Status, Tid, Mid);
        }
    }

    accepts ComClosePrintFileRequest:FileRequest
    {
        SmbComClosePrintFileRequest Request;
        invariant Request != null;
        override string ToString()
        {
            return "ComClosePrintFileRequest, " + GetRequestSmbHeaderString(Tid, Mid) + ", Fid: " + DecToHexFormat(Request.Fid);
        }
    }
    
    issues ComClosePrintFileResponse:FileResponse
    {
        SmbComClosePrintFileResponse Response;
        invariant Response != null;
        override string ToString()
        {
            return "ComClosePrintFileResponse, " + GetResponseSmbHeaderString(Status, Tid, Mid);
        }
    }
}
    
string DialectArrayToText(any input)
{
    string text = "";
    array<SmbComNegotiateRequestDialects> Dialects;
    if(input is array<SmbComNegotiateRequestDialects>)
    {
        Dialects = input as array<SmbComNegotiateRequestDialects>;
    }
    if (Dialects != nothing && Dialects.Count > 0)
    {
        if (Dialects.Count > 1)
        {
            text += "[";
        }
        string strComma = "";
        foreach (SmbComNegotiateRequestDialects item in Dialects)
        {
            text += strComma + item.DialectString;
            strComma = ", ";
        }
        if (Dialects.Count > 1)
        {
            text += "]";
        }
    }
    
    return text;
}

contract VirtualOperations
{
    issues virtual operation SmbError
    {
        in SmbCommand Command = command;
        out SmbStatusOrNtstatus Status = status;

        override string ToString()
        {
            string summary = Command in SmbCommandNameMap ? SmbCommandNameMap[Command] : Utility.DecToHexFormat(8, Command);
            summary += ", Status: " + SmbStatusValuesToText(Status);
            var req = this.Origins[0] as SmbRequest;
            switch (req)
            {
                case m:Messages.ComCreateDirectoryRequest =>
                    summary += ", DirectoryName: " + m.Request.DirectoryName.Value;
                case m:Messages.ComDeleteDirectoryRequest =>
                    summary += ", DirectoryName: " + m.Request.DirectoryName.Value;
                case m:Messages.ComOpenRequest =>
                    summary += ", FileName: " + m.Request.FileName.Value;
                case m:Messages.ComCreateRequest =>
                    summary += ", FileName: " + m.Request.FileName.Value;
                case m:Messages.ComCloseRequest =>
                    summary += ", Fid: " + DecToHexFormat(m.Request.Fid);
                case m:Messages.ComFlushRequest =>
                    summary += ", Fid: " + DecToHexFormat(m.Request.Fid);
                case m:Messages.ComDeleteRequest =>
                    summary += ", FileName: " + m.Request.FileName.Value;
                case m:Messages.ComRenameRequest =>
                    summary += ", OldFileName: " + m.Request.OldFileName.Value + ", NewFileName: " + m.Request.NewFileName.Value;
                case m:Messages.ComQueryInformationRequest =>
                    summary += ", FileName: " + m.Request.FileName.Value;
                case m:Messages.ComSetInformationRequest =>
                    summary += ", FileAttributes: " + EnumToString(m.Request.FileAttributes, "SMB.SmbFileAttributes") + ", FileName: " + m.Request.FileName.Value;
                case m:Messages.ComReadRequest =>
                    summary += ", Fid: " + DecToHexFormat(m.Request.Fid) +  ", CountOfBytesToRead: " + (m.Request.CountOfBytesToRead as string) +
                                ", ReadOffsetInBytes: " + (m.Request.ReadOffsetInBytes as string);
                case m:Messages.ComWriteRequest =>
                    summary += ", Fid: " + DecToHexFormat(m.Request.Fid) + ", CountOfBytesToWrite: " + (m.Request.CountOfBytesToWrite as string) 
                                + ", WriteOffsetInBytes: " + (m.Request.WriteOffsetInBytes as string);
                case m:Messages.ComLockByteRangeRequest =>
                    summary += ", Fid: " + DecToHexFormat(m.Request.Fid) + ", CountOfBytesToLock: " + (m.Request.CountOfBytesToLock as string) 
                                + ", LockOffsetInBytes: " + (m.Request.LockOffsetInBytes as string);
                case m:Messages.ComUnlockByteRangeRequest =>
                    summary += ", Fid: " + DecToHexFormat(m.Request.Fid) + ", CountOfBytesToUnlock: " + (m.Request.CountOfBytesToUnlock as string) 
                                + ", UnlockOffsetInBytes: " + (m.Request.UnlockOffsetInBytes as string);    
                case m:Messages.ComCreateTemporaryRequest =>
                    summary += ", DirectoryName: " + m.Request.DirectoryName.Value;
                case m:Messages.ComCreateNewRequest =>
                    summary += ", FileName: " + m.Request.FileName.Value;
                case m:Messages.ComCheckDirectoryRequest =>
                    summary += ", DirectoryName: " + m.Request.DirectoryName.Value;
                case m:Messages.ComSeekRequest =>
                    summary += ", Fid: " + DecToHexFormat(m.Request.Fid);
                case m:Messages.ComLockAndReadRequest =>
                    summary += ", Fid: " + DecToHexFormat(m.Request.Fid) + ", CountOfBytesToRead: " + (m.Request.CountOfBytesToRead as string)
                                + ", ReadOffsetInBytes: " + (m.Request.ReadOffsetInBytes as string);
                case m:Messages.ComWriteAndUnlockRequest =>
                    summary += ", Fid: " + DecToHexFormat(m.Request.Fid) + ", CountOfBytesToWrite: " + (m.Request.CountOfBytesToWrite as string)
                                + ", WriteOffsetInBytes: " + (m.Request.WriteOffsetInBytes as string);
                case m:Messages.ComReadRawRequest =>
                    summary += ", Fid: " + DecToHexFormat(m.Request.Fid) + ", Offset: " + (m.Request.Offset as string);
                case m:Messages.ComReadMpxRequest =>
                    summary += ", Fid: " + DecToHexFormat(m.Request.Fid) + ", Offset: " + (m.Request.Offset as string);
                case m:Messages.ComWriteRawRequest =>
                    summary += ", Fid: " + DecToHexFormat(m.Request.Fid) + ", CountOfBytes: " + (m.Request.CountOfBytes as string) + ", Offset: " + (m.Request.Offset as string) 
                                + ", WriteMode: " + EnumToString(m.Request.WriteMode, "SMB.SmbComWriteRawRequestParametersWordsWriteMode");
                case m:Messages.ComWriteMpxRequest =>
                    summary += ", Fid: " + DecToHexFormat(m.Request.Fid) + ", TotalByteCount: " + (m.Request.TotalByteCount as string)
                                 + ", ByteOffsetToBeginWrite: " + (m.Request.ByteOffsetToBeginWrite as string) 
                                 + ", WriteMode: " + EnumToString(m.Request.WriteMode, "SMB.SmbComWriteMpxRequestParametersWordsWriteMode");
                case m:Messages.ComSetInformation2Request =>
                    summary += ", Fid: " + DecToHexFormat(m.Request.Fid);
                case m:Messages.ComQueryInformation2Request =>
                    summary += ", Fid: " + DecToHexFormat(m.Request.Fid);
                case m:Messages.ComLockingAndxRequest =>
                    summary += ", Fid: " + DecToHexFormat(m.Request.Fid) + ", TypeOfLock: " + TypeOfLockToString(m.Request.TypeOfLock) + ", NewOpLockLevel: " + (m.Request.NewOpLockLevel as string);
                case m:Messages.ComTransactionRequest =>
                    if (m.Request.SetupCount > 0)
                    {
                        summary += ", Remote Administration Protocol";
                    }
                    if (m.Request.Name != nothing)
                    {
                        summary += ", Name: " + m.Request.Name.ToString();
                    }
                    if (m.Request.Subcommand != nothing)
                    {
                        summary += ", Subcommand: " + GetTransactionSubcommandName(m.Request.SetupCount, m.Request.Subcommand as USHORT);
                    }
                    if (m.Request.Fid != nothing)
                    {
                        summary += ", Fid: " + DecToHexFormat(m.Request.Fid as USHORT);
                    }
                    if (m.Request.Subcommand != nothing && (m.Request.Subcommand == 0x0001))
                    {
                        summary += ", " + ((m.Request.TransParameters as TransactionSubCommandsRequestParameters).SmbParameters as TransSetNmpipeStateRequest).ToString();
                    }
                case m:Messages.ComIoctlRequest =>
                    summary += ", Fid: " + DecToHexFormat(m.Request.Fid);
                case m:Messages.ComWriteAndCloseRequest =>
                    summary += ", Fid: " + DecToHexFormat(m.Request.Fid)  + ", CountOfBytesToWrite: " + (m.Request.CountOfBytesToWrite as string)
                                + ", WriteOffsetInBytes: " + (m.Request.WriteOffsetInBytes as string);
                case m:Messages.ComOpenAndxRequest =>
                    summary += ", FileName: " + m.Request.FileName.Value;
                case m:Messages.ComReadAndxRequest =>
                    summary += ", Fid: " + DecToHexFormat(m.Request.Fid);
                case m:Messages.ComWriteAndxRequest =>
                    summary += ", Fid: " + DecToHexFormat(m.Request.Fid) + ", WriteMode: " + EnumToString(m.Request.WriteMode, "SMB.SmbComWriteAndxRequestParametersWordsWriteMode");
                case m:Messages.ComTransaction2Request =>
                    summary += ", Subcommand: " + GetTransaction2SubcommandName(m.Request.Subcommand);
                    if (m.Request.Trans2Parameters != nothing && (m.Request.Subcommand in {0x00, 0x01, 0x02, 0x03, 0x05, 0x06, 0x07, 0x08, 0x0D}))
                    {
                        summary += ", " + m.Request.Trans2Parameters.ToString();
                    }
                case m:Messages.ComFindClose2Request =>
                    summary += ", Sid: " + DecToHexFormat(m.Request.Sid);
                case m:Messages.ComTreeConnectRequest =>
                    summary += ", Path: " + m.Request.Path + ", Password: " + m.Request.Password + ", Service: " + m.Request.Service;
                case m:Messages.ComTreeDisconnectRequest =>
                    summary += ", Tid: " + DecToHexFormat(m.Tid);
                case m:Messages.ComNegotiateRequest =>
                    if (m.Request.Dialects.Count > 0)
                    {
                        summary += ", Requested Dialects: " + DialectArrayToText(m.Request.Dialects);
                    }
                case m:Messages.ComSessionSetupAndxRequest =>
                    if (m.Request.WordCount == 0x0A || m.Request.WordCount == 0x0D)
                    {
                        summary += (m.Request.AccountName == nothing ? "" : (", AccountName: " + m.Request.AccountName.ToString())) + (m.Request.PrimaryDomain == nothing ? "" : (", PrimaryDomain: " + m.Request.PrimaryDomain.ToString()));
                    }
                    else if (m.Request.WordCount == 0x0C)
                    {
                        summary += m#KeyInformation == nothing ? "" : (", " + m#KeyInformation.ToString());
                    }
                case m:Messages.ComTreeConnectAndxRequest =>
                    summary += ", Path: " + m.Request.Path.Value;
                case m:Messages.ComSearchRequest =>
                    summary += ", FileName: " + m.Request.FileName.Value;
                case m:Messages.ComFindRequest =>
                    summary += ", FileName: " + m.Request.FileName.Value;
                case m:Messages.ComFindUniqueRequest =>
                    summary += ", FileName: " + m.Request.FileName.Value;
                case m:Messages.ComFindCloseRequest =>
                    summary += ", FileName: " + m.Request.FileName.Value;
                case m:Messages.ComNTTransactRequest =>
                    summary += ", Function: " + GetNTTransactionSubcommandName(m.Request.Function);
                    var Setup = m.Request.Setup;
                    if (Setup != nothing && Setup is NTTransactNotifyChangeRequestSetup)
                    {
                        summary += ", " + Setup.ToString();
                    }
                    var NTTransParameters = m.Request.NTTransParameters;
                    if (NTTransParameters != nothing && ((NTTransParameters is NTTransactCreateRequestNTTransParameters) || 
                        (NTTransParameters is NTTransactSetSecurityDescRequestNTTransParameters) || (NTTransParameters is NTTransactQuerySecurityDescRequestNTTransParameters)))
                    {
                        summary += ", " +  NTTransParameters.ToString(); 
                    }
                case m:Messages.ComNTCreateAndxRequest =>
                    summary += ", FileName: " + m.Request.FileName.Value;
                case m:Messages.ComNTRenameRequest =>
                    summary += ", OldFileName: " + m.Request.OldFileName.Value + ", NewFileName: " + m.Request.NewFileName.Value
                                + ", InformationLevel: " + Trans2SetFSInformationRequestParameters.InformationLevelToText(m.Request.InformationLevel);
                case m:Messages.ComOpenPrintFileRequest =>
                    summary += ", Mode: " + EnumToString(m.Request.Mode, "SMB.SmbComOpenPrintFileRequestParametersWordsMode") + ", Identifier: " + m.Request.Identifier.Value;
                case m:Messages.ComWritePrintFileRequest =>
                    summary += ", Fid: " + DecToHexFormat(m.Request.Fid) + ", DataLength: " + (m.Request.DataLength as string);
                case m:Messages.ComClosePrintFileRequest =>
                    summary += ", Fid: " + DecToHexFormat(m.Request.Fid);
                default =>
                    break;
            }
            return summary;
        }
    }
    =
    accepts SmbRequest{Mid is var mid, Command is var command}
    issues Messages.ErrorResponse{Mid == mid, Status is var status};

    issues virtual operation ComCreateDirectory
    {
        in string DirectoryName = directoryName.Value;
        out SmbStatusOrNtstatus Status = status;

        override string ToString()
        {
            return "ComCreateDirectory, Status: " + SmbStatusValuesToText(Status) + ", DirectoryName: " + DirectoryName;
        }
    }
    =
    accepts Messages.ComCreateDirectoryRequest{Mid is var mid, Request is SmbComCreateDirectoryRequest{DirectoryName is var directoryName}}
    issues Messages.ComCreateDirectoryResponse{Mid == mid, Status is var status};

    issues virtual operation ComDeleteDirectory
    {
        in string DirectoryName = directoryName.Value as string;
        out SmbStatusOrNtstatus Status = status;

        override string ToString()
        {
            return "ComDeleteDirectory, Status: " + SmbStatusValuesToText(Status) + ", DirectoryName: " + DirectoryName;
        }
    }
    =
    accepts Messages.ComDeleteDirectoryRequest{Mid is var mid, Request is SmbComDeleteDirectoryRequest{DirectoryName is var directoryName}}
    issues Messages.ComDeleteDirectoryResponse{Mid == mid, Status is var status};
    
    issues virtual operation ComOpen
    {
        in string Name = fileName.Value;
        out USHORT Fid = response.Fid;
        out SmbStatusOrNtstatus Status = status;

        override string ToString()
        {
            return "ComOpen, Status: " + SmbStatusValuesToText(Status) + ", FileName: " + Name + ", Fid: " + DecToHexFormat(Fid);
        }
    }
    =
    accepts Messages.ComOpenRequest{Mid is var mid, Request is SMB.SmbComOpenRequest{FileName is var fileName}}
    issues Messages.ComOpenResponse{Mid == mid, Status is var status, Response is var response};
    
    issues virtual operation ComCreate
    {
        in string Name = fileName.Value;
        out USHORT Fid = response.Fid;
        out SmbStatusOrNtstatus Status = status;

        override string ToString()
        {
            return "ComCreate, Status: " + SmbStatusValuesToText(Status) + ", FileName: " + Name + ", Fid: " + DecToHexFormat(Fid);
        }
    }
    =
    accepts Messages.ComCreateRequest{Mid is var mid, Request is SMB.SmbComCreateRequest{FileName is var fileName}}
    issues Messages.ComCreateResponse{Mid == mid, Status is var status, Response is var response};
    
    issues virtual operation ComClose
    {
        in ushort Fid = request.Fid;
        out SmbStatusOrNtstatus Status = status;

        override string ToString()
        {
            return "ComClose, Status: " + SmbStatusValuesToText(Status) + ", Fid: " + DecToHexFormat(Fid);
        }
    }
    =
    accepts Messages.ComCloseRequest{Mid is var mid, Request is var request}
    issues Messages.ComCloseResponse{Mid == mid, Status is var status};
    
    issues virtual operation ComFlush
    {
        in ushort Fid = request.Fid;
        out SmbStatusOrNtstatus Status = status;

        override string ToString()
        {
            return "ComFlush, Status: " + SmbStatusValuesToText(Status) + ", Fid: " + DecToHexFormat(Fid);
        }
    }
    =
    accepts Messages.ComFlushRequest{Mid is var mid, Request is var request}
    issues Messages.ComFlushResponse{Mid == mid, Status is var status};
    
    issues virtual operation ComDelete
    {
        in string Name = fileName.Value;
        out SmbStatusOrNtstatus Status = status;

        override string ToString()
        {
            return "ComDelete, Status: " + SmbStatusValuesToText(Status) + ", FileName: " + Name;
        }
    }
    =
    accepts Messages.ComDeleteRequest{Mid is var mid, Request is SmbComDeleteRequest{FileName is var fileName}}
    issues Messages.ComDeleteResponse{Mid == mid, Status is var status};
    
    issues virtual operation ComRename
    {
        in string OldFileName = oldFileName.Value;
        in string NewFileName = newFileName.Value;
        out SmbStatusOrNtstatus Status = status;

        override string ToString()
        {
            return "ComRename, Status: " + SmbStatusValuesToText(Status) + ", OldFileName: " + OldFileName + ", NewFileName: " + NewFileName;
        }
    }
    =
    accepts Messages.ComRenameRequest{Mid is var mid, Request is SmbComRenameRequest{OldFileName is var oldFileName, NewFileName is var newFileName}}
    issues Messages.ComRenameResponse{Mid == mid, Status is var status};
    
    issues virtual operation ComQueryInformation
    {
        in string Name = fileName.Value;
        out ULONG FileSize = response.FileSize;
        out SmbStatusOrNtstatus Status = status;

        override string ToString()
        {
            return "ComQueryInformation, Status: " + SmbStatusValuesToText(Status) + ", FileName: " + Name;
        }
    }
    =
    accepts Messages.ComQueryInformationRequest{Mid is var mid, Request is SmbComQueryInformationRequest{FileName is var fileName}}
    issues Messages.ComQueryInformationResponse{Mid == mid, Status is var status, Response is var response};
    
    issues virtual operation ComSetInformation
    {
        in string Name = fileName.Value;
        in SmbFileAttributes FileAttributes = fileattributes;
        out SmbStatusOrNtstatus Status = status;

        override string ToString()
        {
            return "ComSetInformation, Status: " + SmbStatusValuesToText(Status) + ", FileAttributes: " + EnumToString(FileAttributes, "SMB.SmbFileAttributes") + ", FileName: " + Name;
        }
    }
    =
    accepts Messages.ComSetInformationRequest{Mid is var mid, Request is SmbComSetInformationRequest{FileName is  var fileName, FileAttributes is var fileattributes}}
    issues Messages.ComSetInformationResponse{Mid == mid, Status is var status};
    
    issues virtual operation ComRead
    {
        in ushort Fid = request.Fid;
        in ushort CountOfBytesToRead = request.CountOfBytesToRead;
        in ULONG ReadOffsetInBytes = request.ReadOffsetInBytes;
        out USHORT CountOfBytesReturned = response.CountOfBytesReturned;
        out binary Bytes = response.Bytes;
        out SmbStatusOrNtstatus Status = status;

        override string ToString()
        {
            return "ComRead, Status: " + SmbStatusValuesToText(Status) + ", Fid: " + DecToHexFormat(Fid) +  ", CountOfBytesToRead: " + (CountOfBytesToRead as string) +
                ", ReadOffsetInBytes: " + (ReadOffsetInBytes as string) + ", CountOfBytesReturned: " + (CountOfBytesReturned as string);
        }
    }
    =
    accepts Messages.ComReadRequest{Mid is var mid, Request is var request}
    issues Messages.ComReadResponse{Mid == mid, Status is var status, Response is var response};
    
    issues virtual operation ComWrite
    {
        in ushort Fid = request.Fid;
        in ushort CountOfBytesToWrite = request.CountOfBytesToWrite;
        in ULONG WriteOffsetInBytes = request.WriteOffsetInBytes;
        in binary Data = request.Data;
        out ushort CountOfBytesWritten = response.CountOfBytesWritten;
        out SmbStatusOrNtstatus Status = status;

        override string ToString()
        {
            return "ComWrite, Status: " + SmbStatusValuesToText(Status) + ", Fid: " + DecToHexFormat(Fid) + ", CountOfBytesToWrite: " + (CountOfBytesToWrite as string) 
                + ", WriteOffsetInBytes: " + (WriteOffsetInBytes as string) + ", CountOfBytesWritten: " + (CountOfBytesWritten as string);
        }
    }
    =
    accepts Messages.ComWriteRequest{Mid is var mid, Request is var request}
    issues Messages.ComWriteResponse{Mid == mid, Status is var status, Response is var response};
    
    issues virtual operation ComLockByteRange
    {
        in ushort Fid = request.Fid;
        in ULONG CountOfBytesToLock = request.CountOfBytesToLock;
        in ULONG LockOffsetInBytes = request.LockOffsetInBytes;
        out SmbStatusOrNtstatus Status = status;

        override string ToString()
        {
            return "ComLockByteRange, Status: " + SmbStatusValuesToText(Status) + ", Fid: " + DecToHexFormat(Fid) 
                + ", CountOfBytesToLock: " + (CountOfBytesToLock as string) + ", LockOffsetInBytes: " + (LockOffsetInBytes as string);
        }
    }
    =
    accepts Messages.ComLockByteRangeRequest{Mid is var mid, Request is var request}
    issues Messages.ComLockByteRangeResponse{Mid == mid, Status is var status};
    
    issues virtual operation ComUnlockByteRange
    {
        in ushort Fid = request.Fid;
        in ULONG CountOfBytesToUnlock = request.CountOfBytesToUnlock;
        in ULONG UnlockOffsetInBytes = request.UnlockOffsetInBytes;
        out SmbStatusOrNtstatus Status = status;

        override string ToString()
        {
            return "ComUnlockByteRange, Status: " + SmbStatusValuesToText(Status) + ", Fid: " + DecToHexFormat(Fid) 
                + ", CountOfBytesToUnlock: " + (CountOfBytesToUnlock as string) + ", UnlockOffsetInBytes: " + (UnlockOffsetInBytes as string);
        }
    }
    =
    accepts Messages.ComUnlockByteRangeRequest{Mid is var mid, Request is var request}
    issues Messages.ComUnlockByteRangeResponse{Mid == mid, Status is var status};
    
    issues virtual operation ComCreateTemporary
    {
        in string DirectoryName = directoryName.Value;
        out string TemporaryFileName = temporaryFileName;
        out SmbStatusOrNtstatus Status = status;

        override string ToString()
        {
            return "ComCreateTemporary, Status: " + SmbStatusValuesToText(Status) + ", DirectoryName: " + DirectoryName + ", TemporaryFileName: " + TemporaryFileName;
        }
    }
    =
    accepts Messages.ComCreateTemporaryRequest{Mid is var mid, Request is SMB.SmbComCreateTemporaryRequest{DirectoryName is var directoryName}}
    issues Messages.ComCreateTemporaryResponse{Mid == mid, Status is var status, Response is SMB.SmbComCreateTemporaryResponse{TemporaryFileName is var temporaryFileName}};
    
    issues virtual operation ComCreateNew
    {
        in string Name = fileName.Value;
        out USHORT Fid = response.Fid;
        out SmbStatusOrNtstatus Status = status;

        override string ToString()
        {
            return "ComCreateNew, Status: " + SmbStatusValuesToText(Status) + ", FileName: " + Name + ", Fid: " + DecToHexFormat(Fid);
        }
    }
    =
    accepts Messages.ComCreateNewRequest{Mid is var mid, Request is SMB.SmbComCreateNewRequest{FileName is var fileName}}
    issues Messages.ComCreateNewResponse{Mid == mid, Status is var status, Response is var response};
    
    issues virtual operation ComCheckDirectory
    {
        in string DirectoryName = directoryName.Value;
        out SmbStatusOrNtstatus Status = status;

        override string ToString()
        {
            return "ComCheckDirectory, Status: " + SmbStatusValuesToText(Status) + ", DirectoryName: " + DirectoryName;
        }
    }
    =
    accepts Messages.ComCheckDirectoryRequest{Mid is var mid, Request is SMB.SmbComCheckDirectoryRequest{DirectoryName is var directoryName}}
    issues Messages.ComCheckDirectoryResponse{Mid == mid, Status is var status};
    
    issues virtual operation ComProcessExit
    {
        out SmbStatusOrNtstatus Status = status;

        override string ToString()
        {
            return "ComProcessExit, Status: " + SmbStatusValuesToText(Status);
        }
    }
    =
    accepts Messages.ComProcessExitRequest{Mid is var mid}
    issues Messages.ComProcessExitResponse{Mid == mid, Status is var status};
    
    issues virtual operation ComSeek
    {
        in ushort Fid = request.Fid;
        out SmbStatusOrNtstatus Status = status;

        override string ToString()
        {
            return "ComSeek, Status: " + SmbStatusValuesToText(Status) + ", Fid: " + DecToHexFormat(Fid);
        }
    }
    =
    accepts Messages.ComSeekRequest{Mid is var mid, Request is var request}
    issues Messages.ComSeekResponse{Mid == mid, Status is var status};
    
    issues virtual operation ComLockAndRead
    {
        in ushort Fid = request.Fid;
        in ushort CountOfBytesToRead = request.CountOfBytesToRead;
        in ULONG ReadOffsetInBytes = request.ReadOffsetInBytes;
        out USHORT CountOfBytesReturned = response.CountOfBytesReturned;
        out binary Bytes = response.Bytes;
        out SmbStatusOrNtstatus Status = status;

        override string ToString()
        {
            return "ComLockAndRead, Status: " + SmbStatusValuesToText(Status) + ", Fid: " + DecToHexFormat(Fid) + ", CountOfBytesToRead: " + (CountOfBytesToRead as string)
                + ", ReadOffsetInBytes: " + (ReadOffsetInBytes as string) + ", CountOfBytesReturned: " + (CountOfBytesReturned as string);
        }
    }
    =
    accepts Messages.ComLockAndReadRequest{Mid is var mid, Request is var request}
    issues Messages.ComLockAndReadResponse{Mid == mid, Status is var status, Response is var response};
    
    issues virtual operation ComWriteAndUnlock
    {
        in ushort Fid = request.Fid;
        in ushort CountOfBytesToWrite = request.CountOfBytesToWrite;
        in ULONG WriteOffsetInBytes = request.WriteOffsetInBytes;
        in binary Data = request.Data;
        out USHORT CountOfBytesWritten = response.CountOfBytesWritten;
        out SmbStatusOrNtstatus Status = status;

        override string ToString()
        {
            return "ComWriteAndUnlock, Status: " + SmbStatusValuesToText(Status) + ", Fid: " + DecToHexFormat(Fid)  + ", CountOfBytesToWrite: " + (CountOfBytesToWrite as string)
                 + ", WriteOffsetInBytes: " + (WriteOffsetInBytes as string) + ", CountOfBytesWritten: " + (CountOfBytesWritten as string);
        }
    }
    =
    accepts Messages.ComWriteAndUnlockRequest{Mid is var mid, Request is var request}
    issues Messages.ComWriteAndUnlockResponse{Mid == mid, Status is var status, Response is var response};
    
    issues virtual operation ComReadRaw
    {
        in ushort Fid = request.Fid;
        in ULONG Offset = request.Offset; 
        out SmbStatusOrNtstatus Status = status;

        override string ToString()
        {
            return "ComReadRaw, Status: " + SmbStatusValuesToText(Status) + ", Fid: " + DecToHexFormat(Fid) + ", Offset: " + (Offset as string);
        }
    }
    =
    accepts Messages.ComReadRawRequest{Mid is var mid, Request is var request}
    issues Messages.ComReadRawResponse{Mid == mid, Status is var status};
    
    issues virtual operation ComReadMpx
    {
        in ushort Fid = request.Fid;
        in ULONG Offset = request.Offset;
        binary Buffer = response.Buffer;
        out SmbStatusOrNtstatus Status = status;

        override string ToString()
        {
            return "ComReadMpx, Status: " + SmbStatusValuesToText(Status) + ", Fid: " + DecToHexFormat(Fid) + ", Offset: " + (Offset as string);
        }
    }
    =
    accepts Messages.ComReadMpxRequest{Mid is var mid, Request is var request}
    issues Messages.ComReadMpxResponse{Mid == mid, Status is var status, Response is var response};
    
    issues virtual operation ComWriteRaw
    {
        in ushort Fid = request.Fid;
        in ushort CountOfBytes = request.CountOfBytes;
        in ULONG Offset = request.Offset;
        in SmbComWriteRawRequestParametersWordsWriteMode WriteMode = request.WriteMode;
        in binary Data = request.Data;
        out SmbStatusOrNtstatus Status = status;

        override string ToString()
        {
            return "ComWriteRaw, Status: " + SmbStatusValuesToText(Status) + ", Fid: " + DecToHexFormat(Fid) + ", CountOfBytes: " + (CountOfBytes as string)
                + ", Offset: " + (Offset as string) + ", WriteMode: " + EnumToString(WriteMode, "SMB.SmbComWriteRawRequestParametersWordsWriteMode");
        }
    }
    =
    accepts Messages.ComWriteRawRequest{Mid is var mid, Request is var request}
    issues Messages.ComWriteRawResponse{Mid == mid, Status is var status};
    
    issues virtual operation ComWriteMpx
    {
        in ushort Fid = request.Fid;
        in ushort TotalByteCount = request.TotalByteCount;
        in ULONG ByteOffsetToBeginWrite= request.ByteOffsetToBeginWrite;
        in SmbComWriteMpxRequestParametersWordsWriteMode WriteMode = request.WriteMode;
        in binary Buffer = request.Buffer;
        out SmbStatusOrNtstatus Status = status;

        override string ToString()
        {
            return "ComWriteMpx, Status: " + SmbStatusValuesToText(Status) + ", Fid: " + DecToHexFormat(Fid) + ", TotalByteCount: " + (TotalByteCount as string)
                + ", ByteOffsetToBeginWrite: " + (ByteOffsetToBeginWrite as string) + ", WriteMode: " + EnumToString(WriteMode, "SMB.SmbComWriteMpxRequestParametersWordsWriteMode");
        }
    }
    =
    accepts Messages.ComWriteMpxRequest{Mid is var mid, Request is var request}
    issues Messages.ComWriteMpxResponse{Mid == mid, Status is var status};
    
    issues virtual operation ComSetInformation2
    {
        in ushort Fid = request.Fid;
        out SmbStatusOrNtstatus Status = status;

        override string ToString()
        {
            return "ComSetInformation2, Status: " + SmbStatusValuesToText(Status) + ", Fid: " + DecToHexFormat(Fid);
        }
    }
    =
    accepts Messages.ComSetInformation2Request{Mid is var mid, Request is var request}
    issues Messages.ComSetInformation2Response{Mid == mid, Status is var status};
    
    issues virtual operation ComQueryInformation2
    {
        in USHORT Fid = request.Fid;
        out SmbStatusOrNtstatus Status = status;

        override string ToString()
        {
            return "ComQueryInformation2, Status: " + SmbStatusValuesToText(Status) + ", Fid: " + DecToHexFormat(Fid);
        }
    }
    =
    accepts Messages.ComQueryInformation2Request{Mid is var mid, Request is var request}
    issues Messages.ComQueryInformation2Response{Mid == mid, Status is var status};
    
    issues virtual operation ComLockingAndx
    {
        in ushort Fid = request.Fid;
        in SmbComLockingAndxRequestParametersWordsTypeOfLock TypeOfLock = request.TypeOfLock;
        in UCHAR NewOpLockLevel = request.NewOpLockLevel;
        out SmbStatusOrNtstatus Status = status;

        override string ToString()
        {
            return "ComLockingAndx, Status: " + SmbStatusValuesToText(Status) + ", Fid: " + DecToHexFormat(Fid) + ", TypeOfLock: " 
                + TypeOfLockToString(TypeOfLock) + ", NewOpLockLevel: " + (NewOpLockLevel as string);
        }
    }
    =
    accepts Messages.ComLockingAndxRequest{Mid is var mid, Request is var request}
    issues Messages.ComLockingAndxResponse{Mid == mid, Status is var status};
    
    issues virtual operation ComTransaction
    {
        in UCHAR SetupCount = request.SetupCount;
        in optional SmbString Name = request.Name;
        in optional SMBComTransactionSubCommand Subcommand = request.Subcommand;
        in optional USHORT Fid = request.Fid;
        in optional (TransactionSubCommandsRequestParameters | Blob) TransParameters = request.TransParameters;
        out SmbStatusOrNtstatus Status = status;

        override string ToString()
        {
            string summary = "ComTransaction";
            if (SetupCount > 0)
            {
                summary += ", Remote Administration Protocol";
            }
            summary += ", Status: " + SmbStatusValuesToText(Status);
            if (Name != nothing)
            {
                summary += ", Name: " + Name.ToString();
            }
            if (Subcommand != nothing)
            {
                summary += ", Subcommand: " + GetTransactionSubcommandName(SetupCount, Subcommand as USHORT);
            }
            if (Fid != nothing)
            {
                summary += ", Fid: " + DecToHexFormat(Fid as USHORT);
            }
            if (Subcommand != nothing && (Subcommand == 0x0001))
            {
                summary += ", " + ((TransParameters as TransactionSubCommandsRequestParameters).SmbParameters as TransSetNmpipeStateRequest).ToString();
            }
            return summary;
        }
    }
    =
    accepts Messages.ComTransactionRequest{Mid is var mid, Request is var request}
    issues Messages.ComTransactionResponse{Mid == mid, Status is var status};
        
    issues virtual operation ComIoctl
    {
        in ushort Fid = request.Fid;
        out SmbStatusOrNtstatus Status = status;

        override string ToString()
        {
            return "ComIoctl, Status: " + SmbStatusValuesToText(Status) + ", Fid: " + DecToHexFormat(Fid);
        }
    }
    =
    accepts Messages.ComIoctlRequest{Mid is var mid, Request is var request}
    issues Messages.ComIoctlResponse{Mid == mid, Status is var status};
    
    issues virtual operation ComEcho
    {
        out ushort SequenceNumber = response.SequenceNumber;
        out SmbStatusOrNtstatus Status = status;

        override string ToString()
        {
            return "ComEcho, Status: " + SmbStatusValuesToText(Status) + ", SequenceNumber: " + (SequenceNumber as string);
        }
    }
    =
    accepts Messages.ComEchoRequest{Mid is var mid}
    issues Messages.ComEchoResponse{Mid == mid, Status is var status, Response is var response};
    
    issues virtual operation ComWriteAndClose
    {
        in ushort Fid = request.Fid;
        in ushort CountOfBytesToWrite = request.CountOfBytesToWrite;
        in ULONG WriteOffsetInBytes = request.WriteOffsetInBytes;
        in optional binary Data = request.Data;
        out USHORT CountOfBytesWritten = response.CountOfBytesWritten;
        out SmbStatusOrNtstatus Status = status;

        override string ToString()
        {
            return "ComWriteAndClose, Status: " + SmbStatusValuesToText(Status) + ", Fid: " + DecToHexFormat(Fid)  + ", CountOfBytesToWrite: " + (CountOfBytesToWrite as string)
                 + ", WriteOffsetInBytes: " + (WriteOffsetInBytes as string) + ", CountOfBytesWritten: " + (CountOfBytesWritten as string);
        }
    }
    =
    accepts Messages.ComWriteAndCloseRequest{Mid is var mid, Request is var request}
    issues Messages.ComWriteAndCloseResponse{Mid == mid, Status is var status, Response is var response};
    
    issues virtual operation ComOpenAndx
    {
        in string Name = fileName.Value;
        in SmbAccessMode AccessMode = accessMode;
        out ushort Fid = response.Fid;
        out SmbComOpenAndxResponseAccessRight AccessRights = response.AccessRights;
        out SmbStatusOrNtstatus Status = status;

        override string ToString()
        {
            return "ComOpenAndx, Status: " + SmbStatusValuesToText(Status) + ", FileName: " + Name + 
                ", Fid: " + DecToHexFormat(Fid) + ", AccessRights: " + EnumToString(AccessRights, "SMB.SmbComOpenAndxResponseAccessRight");
        }
    }
    =
    accepts Messages.ComOpenAndxRequest{Mid is var mid, Request is SMB.SmbComOpenAndxRequest{FileName is var fileName, AccessMode is var accessMode}}
    issues Messages.ComOpenAndxResponse{Mid == mid, Status is var status, Response is var response};
    
    issues virtual operation ComReadAndx
    {
        in ushort Fid = request.Fid;
        out optional binary Data = response.Data;
        out SmbStatusOrNtstatus Status = status;

        override string ToString()
        {
            return "ComReadAndx, Status: " + SmbStatusValuesToText(Status) + ", Fid: " + DecToHexFormat(Fid);
        }
    }
    =
    accepts Messages.ComReadAndxRequest{Mid is var mid, Request is var request}
    issues Messages.ComReadAndxResponse{Mid == mid, Status is var status, Response is var response};

    issues virtual operation ComWriteAndx
    {
        in ushort Fid = request.Fid;
        in SmbComWriteAndxRequestParametersWordsWriteMode WriteMode = request.WriteMode;
        in optional binary Data = request.Data;
        out SmbStatusOrNtstatus Status = status;

        override string ToString()
        {
            return "ComWriteAndx, Status: " + SmbStatusValuesToText(Status) + ", Fid: " + DecToHexFormat(Fid) + ", WriteMode: " + EnumToString(WriteMode, "SMB.SmbComWriteAndxRequestParametersWordsWriteMode");
        }
    }
    =
    accepts Messages.ComWriteAndxRequest{Mid is var mid, Request is var request}
    issues Messages.ComWriteAndxResponse{Mid == mid, Status is var status};
    
    issues virtual operation ComTransaction2
    {
        in USHORT Subcommand = subcommand;
        in optional Trans2SubcommandRequestParameters Trans2Parameters = trans2Parameters;
        out SmbStatusOrNtstatus Status = status;

        override string ToString()
        {
            string summary = "ComTransaction2, Status: " + SmbStatusValuesToText(Status) + ", Subcommand: " + GetTransaction2SubcommandName(Subcommand);
            if (Trans2Parameters != nothing && (Subcommand in {0x00, 0x01, 0x02, 0x03, 0x05, 0x06, 0x07, 0x08, 0x0D}))
            {
                summary += ", " + Trans2Parameters.ToString();
            }
            return summary;
        }
    }
    =
    accepts Messages.ComTransaction2Request{Mid is var mid, Request.Subcommand is var subcommand, Request.Trans2Parameters is var trans2Parameters}
    issues Messages.ComTransaction2Response{Mid == mid, Status is var status};
            
    issues virtual operation ComFindClose2
    {
        in ushort Sid = request.Sid;
        out SmbStatusOrNtstatus Status = status;

        override string ToString()
        {
            return "ComFindClose2, Status: " + SmbStatusValuesToText(Status) + ", Sid: " + DecToHexFormat(Sid);
        }
    }
    =
    accepts Messages.ComFindClose2Request{Mid is var mid, Request is var request}
    issues Messages.ComFindClose2Response{Mid == mid, Status is var status};
    
    issues virtual operation ComTreeConnect
    {
        in string Path = request.Path;
        in string Password = request.Password;
        in string Service = request.Service;
        out SmbStatusOrNtstatus Status = status;
        out ushort Tid = response.Tid;

        override string ToString()
        {
            return "ComTreeConnect, Status: " + SmbStatusValuesToText(Status) + ", Path: " + Path + ", Tid: " + DecToHexFormat(Tid) + ", Password: " + Password + ", Service: " + Service;
        }
    }
    =
    accepts Messages.ComTreeConnectRequest{Mid is var mid, Request is var request}
    issues Messages.ComTreeConnectResponse{Mid == mid, Status is var status, Response is var response};
    
    issues virtual operation ComTreeDisconnect
    {
        in ushort Tid = tid;
        out SmbStatusOrNtstatus Status = status;

        override string ToString()
        {
            return "ComTreeDisconnect, Status: " + SmbStatusValuesToText(Status) + ", Tid: " + DecToHexFormat(Tid);
        }
    }
    =
    accepts Messages.ComTreeDisconnectRequest{Mid is var mid, Tid is var tid}
    issues Messages.ComTreeDisconnectResponse{Mid == mid, Status is var status};
    
    issues virtual operation ComNegotiate
    {
        in array<SmbComNegotiateRequestDialects> Dialects = request.Dialects;
        out ushort SelectedDialectIndex = response.DialectIndex;
        out SmbStatusOrNtstatus Status = status;

        override string ToString()
        {
            string summary = "ComNegotiate, Status: " + SmbStatusValuesToText(Status);
            if (Dialects.Count > SelectedDialectIndex)
            {
                summary += ", Selected Dialect: " + Dialects[SelectedDialectIndex].ToString();
            }
            if (Dialects.Count > 0)
            {
                summary += ", Requested Dialects: " + DialectArrayToText(Dialects);
            }
            return summary;
        }
    }
    =
    accepts Messages.ComNegotiateRequest{Mid is var mid, Request is var request}
    issues Messages.ComNegotiateResponse{Mid == mid, Status is var status, Response is var response};
    
    issues virtual operation ComSessionSetupAndx
    {
        in string AuthenticationMethod = ki != nothing ? GetAuthInfoFromSummary(ki.ToString()) : "";
        in optional string User = ki != nothing && GetUserInfoFromSummary(ki.ToString()).Count > 0 ? GetUserInfoFromSummary(ki.ToString()) : nothing;
        in optional SmbString AccountName = request.AccountName;
        in optional SmbString PrimaryDomain = request.PrimaryDomain;
        out SmbStatusOrNtstatus Status = status;
        out USHORT Uid = uid;

        override string ToString()
        {
            return "ComSessionSetupAndx, Status: " + SmbStatusValuesToText(Status) + 
                (AuthenticationMethod.Count == 0 ? "" : (", " + AuthenticationMethod)) + (User == nothing ? "" : (", User: " + User.ToString())) +
                ", Uid: " + DecToHexFormat(Uid) + (AccountName == nothing ? "" : (", AccountName: " + AccountName.ToString())) + 
                (PrimaryDomain == nothing ? "" : (", PrimaryDomain: " + PrimaryDomain.ToString()));
        }
    }
    =
    accepts Messages.ComSessionSetupAndxRequest{#KeyInformation is var ki, Mid is var mid, Request is var request}
    issues Messages.ComSessionSetupAndxResponse{Mid == mid, Status is var status, Uid is var uid};
                
    issues virtual operation ComLogoffAndx
    {
        out SmbStatusOrNtstatus Status = status;
        out USHORT Uid = uid;

        override string ToString()
        {
            return "ComLogoffAndx, Status: " + SmbStatusValuesToText(Status) + ", Uid: " + DecToHexFormat(Uid);
        }
    }
    =
    accepts Messages.ComLogoffAndxRequest{Mid is var mid}
    issues Messages.ComLogoffAndxResponse{Mid == mid, Status is var status, Uid is var uid};
    
    issues virtual operation ComTreeConnectAndx
    {
        in string Path = path.Value;
        out string Service = service;
        out SmbStatusOrNtstatus Status = status;
        out USHORT Tid = tid;

        override string ToString()
        {
            return "ComTreeConnectAndx, Status: " + SmbStatusValuesToText(Status) + ", Path: " + Path + ", Tid: " + DecToHexFormat(Tid) + ", Service: " + Service;
        }
    }
    =
    accepts Messages.ComTreeConnectAndxRequest{Mid is var mid, Request is SmbComTreeConnectAndxRequest{Path is var path}}
    issues Messages.ComTreeConnectAndxResponse{Mid == mid, Status is var status, Tid is var tid,  
                                               Response is SmbComTreeConnectAndxResponse{Service is var service}};
    
    issues virtual operation ComQueryInformationDisk
    {
        out ushort TotalUnits = response.TotalUnits;
        out ushort FreeUnits = response.FreeUnits;
        out SmbStatusOrNtstatus Status = status;

        override string ToString()
        {
            return "ComQueryInformationDisk, Status: " + SmbStatusValuesToText(Status) + ", TotalUnits: " + (TotalUnits as string) + ", FreeUnits: " + (FreeUnits as string);
        }
    }
    =
    accepts Messages.ComQueryInformationDiskRequest{Mid is var mid}
    issues Messages.ComQueryInformationDiskResponse{Mid == mid, Status is var status, Response is var response};
    
    issues virtual operation ComSearch
    {
        in string Name = fileName.Value;
        out array<SmbDirectoryInformation> DirectoryInformationData = response.DirectoryInformationData;
        out SmbStatusOrNtstatus Status = status;

        override string ToString()
        {
            return "ComSearch, Status: " + SmbStatusValuesToText(Status) + ", FileName: " + Name;
        }
    }
    =
    accepts Messages.ComSearchRequest{Mid is var mid, Request is SmbComSearchRequest{FileName is var fileName}}
    issues Messages.ComSearchResponse{Mid == mid, Status is var status, Response is var response};
    
    issues virtual operation ComFind
    {
        in string Name = fileName.Value;
        out array<SmbDirectoryInformation> DirectoryInformationData = response.DirectoryInformationData;
        out SmbStatusOrNtstatus Status = status;

        override string ToString()
        {
            return "ComFind, Status: " + SmbStatusValuesToText(Status) + ", FileName: " + Name;
        }
    }
    =
    accepts Messages.ComFindRequest{Mid is var mid, Request is SmbComFindRequest{FileName is var fileName}}
    issues Messages.ComFindResponse{Mid == mid, Status is var status, Response is var response};
    
    issues virtual operation ComFindUnique
    {
        in string Name = fileName.Value;
        out array<SmbDirectoryInformation> DirectoryInformationData = response.DirectoryInformationData;
        out SmbStatusOrNtstatus Status = status;

        override string ToString()
        {
            return "ComFindUnique, Status: " + SmbStatusValuesToText(Status) + ", FileName: " + Name;
        }
    }
    =
    accepts Messages.ComFindUniqueRequest{Mid is var mid, Request is SmbComFindUniqueRequest{FileName is var fileName}}
    issues Messages.ComFindUniqueResponse{Mid == mid, Status is var status, Response is var response};
    
    issues virtual operation ComFindClose
    {
        in string Name = fileName.Value;
        out SmbStatusOrNtstatus Status = status;

        override string ToString()
        {
            return "ComFindClose, Status: " + SmbStatusValuesToText(Status) + ", FileName: " + Name;
        }
    }
    =
    accepts Messages.ComFindCloseRequest{Mid is var mid, Request is SmbComFindCloseRequest{FileName is var fileName}}
    issues Messages.ComFindCloseResponse{Mid == mid, Status is var status};
    
    issues virtual operation ComNTTransact
    {
        in USHORT Function = request.Function;
        in optional (NTTransactCreateRequestNTTransParameters | NTTransactSetSecurityDescRequestNTTransParameters
                        | NTTransactQuerySecurityDescRequestNTTransParameters | NTTransactQueryQuotaRequestNTTransParameters
                        | NTTransactSetQuotaRequestNTTransParameters | Blob) NTTransParameters = request.NTTransParameters;
        in optional (NTTransactIoctlRequestSetup | NTTransactNotifyChangeRequestSetup | Blob) Setup = request.Setup;
        out SmbStatusOrNtstatus Status = status;

        override string ToString()
        {
            string summary = "ComNTTransact, Status: " + SmbStatusValuesToText(Status);
            summary += ", Function: " + GetNTTransactionSubcommandName(Function);
            if (Setup != nothing && Setup is NTTransactNotifyChangeRequestSetup)
            {
                summary += ", " + Setup.ToString();
            }
            if (NTTransParameters != nothing && ((NTTransParameters is NTTransactCreateRequestNTTransParameters) || 
                (NTTransParameters is NTTransactSetSecurityDescRequestNTTransParameters) || (NTTransParameters is NTTransactQuerySecurityDescRequestNTTransParameters)))
            {
                summary += ", " +  NTTransParameters.ToString(); 
            }
            return summary;
        }
    }
    =
    accepts Messages.ComNTTransactRequest{Mid is var mid, Request is var request}
    issues Messages.ComNTTransactResponse{Mid == mid, Status is var status};
        
    issues virtual operation ComNTCreateAndx
    {
        in string Name = fileName.Value;
        out SmbStatusOrNtstatus Status = status;
        out ushort Fid = response.Fid;

        override string ToString()
        {
            return "ComNTCreateAndx, Status: " + SmbStatusValuesToText(Status) + ", FileName: " + Name + ", Fid: " + DecToHexFormat(Fid);
        }
    }
    =
    accepts Messages.ComNTCreateAndxRequest{Mid is var mid, Request is SMB.SmbComNTCreateAndxRequest{FileName is var fileName}}
    issues Messages.ComNTCreateAndxResponse{Mid == mid, Status is var status, Response is var response};
        
    issues virtual operation ComNTRename
    {
        in string OldFileName = oldFileName.Value;
        in string NewFileName = newFileName.Value;
        in SmbComNTRenameRequestInformationLevel InformationLevel = informationLevel;
        out SmbStatusOrNtstatus Status = status;

        override string ToString()
        {
            return "ComNTRename, Status: " + SmbStatusValuesToText(Status) + ", OldFileName: " + OldFileName + ", NewFileName: " + NewFileName
                + ", InformationLevel: " + Trans2SetFSInformationRequestParameters.InformationLevelToText(InformationLevel);;
        }
    }
    =
    accepts Messages.ComNTRenameRequest{Mid is var mid, Request is SmbComNTRenameRequest{OldFileName is var oldFileName, NewFileName is var newFileName, InformationLevel is var informationLevel}}
    issues Messages.ComNTRenameResponse{Mid == mid, Status is var status};
    
    issues virtual operation ComOpenPrintFile
    {
        in string Identifier = identifier.Value;
        out ushort Fid = response.Fid;
        in SmbComOpenPrintFileRequestParametersWordsMode Mode = mode;
        out SmbStatusOrNtstatus Status = status;

        override string ToString()
        {
            return "ComOpenPrintFile, Status: " + SmbStatusValuesToText(Status) + ", Mode: " + EnumToString(Mode, "SMB.SmbComOpenPrintFileRequestParametersWordsMode") 
                + ", Identifier: " + Identifier + ", Fid: " + DecToHexFormat(Fid);
        }
    }
    =
    accepts Messages.ComOpenPrintFileRequest{Mid is var mid, Request is SmbComOpenPrintFileRequest{Identifier is var identifier, Mode is var mode}}
    issues Messages.ComOpenPrintFileResponse{Mid == mid, Status is var status, Response is var response};
    
    issues virtual operation ComWritePrintFile
    {
        in ushort Fid = request.Fid;
        in ushort DataLength = request.DataLength;
        in binary Data = request.Data;
        out SmbStatusOrNtstatus Status = status;

        override string ToString()
        {
            return "ComWritePrintFile, Status: " + SmbStatusValuesToText(Status) + ", Fid: " + DecToHexFormat(Fid) + ", DataLength: " + (DataLength as string);
        }
    }
    =
    accepts Messages.ComWritePrintFileRequest{Mid is var mid, Request is var request}
    issues Messages.ComWritePrintFileResponse{Mid == mid, Status is var status};
    
    issues virtual operation ComClosePrintFile
    {
        in ushort Fid = request.Fid;
        out SmbStatusOrNtstatus Status = status;

        override string ToString()
        {
            return "ComClosePrintFile, Status: " + SmbStatusValuesToText(Status) + ", Fid: " + DecToHexFormat(Fid);
        }
    }
    =
    accepts Messages.ComClosePrintFileRequest{Mid is var mid, Request is var request}
    issues Messages.ComClosePrintFileResponse{Mid == mid, Status is var status};
}


message SmbRequest : SmbHeader
{
}

message SmbResponse: SmbHeader
{
}

// For add property FileName
message FileRequest:SmbRequest
{
}

message FileResponse:SmbResponse
{
}

// 2.2.1.2.1   SMB_GEA
type SmbGea
{
    UCHAR AttributeNameLengthInBytes
        with Documentation{Description = "This field MUST contain the length, in bytes (excluding the trailing null padding byte), of the AttributeName field."};
    string AttributeName with BinaryEncoding{TextEncoding = TextEncoding.ASCII, Length = AttributeNameLengthInBytes},
        Documentation{Description = "This field contains the name, in extended ASCII (OEM) characters, of an extended attribute. The length of the name MUST NOT exceed 255 bytes. An additional byte is added to store a null padding byte. This field MAY be interpreted as an OEM_STRING."};
} with Documentation{Description = "The SMB_GEA data structure is used in Transaction2 subcommand requests to request specific extended attribute (EA) name/value pairs by name. This structure is used when the SMB_INFO_QUERY_EAS_FROM_LIST information level is specified. \"GEA\" stands for \"get extended attribute\"."};

// 2.2.1.2.1.1   SMB_GEA_LIST
type SmbGeaList
{
    ULONG SizeOfListInBytes
        with Documentation{Description = "This field MUST contain the total size of the GEAList field, plus the size of the SizeOfListInBytes field (4 bytes).windows clients include both the size of the SizeOfListInBytes field and the total size of the GEAList field when calculating the value passed in the SizeOfListInBytes field for compatibility with dialects less than the LAN Manager 1.2 dialect, as implemented in OS/2 v1.2. See [XOPEN-SMB] sections 4.3.7 and 16.1.5 for more information."};
    array<SmbGea> GeaList
        with Documentation{Description = "A concatenated list of SMB_GEA structures."};
} with Documentation{Description = "The SMB_GEA_LIST data structure is used to send a concatenated list of SMB_GEA structures."};

// 2.2.1.2.2   SMB_FEA
type SmbFea
{
    SmbFeaExtendedAttributeFlag ExtendedAttributeFlag
        with Documentation{Description = "This is a bit field. Only the 0x80 bit is defined."};
    UCHAR AttributeNameLengthInBytes
        with Documentation{Description = "This field MUST contain the length, in bytes, of the AttributeName field (excluding the trailing null byte)."};
    USHORT AttributeValueLengthInBytes
        with Documentation{Description = "This field MUST contain the length, in bytes, of the AttributeValue field."};
    string AttributeName with BinaryEncoding{TextEncoding = TextEncoding.ASCII},
        Documentation{Description = "This field contains the name, in extended ASCII (OEM) characters, of an extended attribute. The length of the name MUST NOT exceed 255 bytes. An additional byte is added to store a null padding byte. This field MAY be interpreted as an OEM_STRING."};
    string AttributeValue with BinaryEncoding{Length = AttributeValueLengthInBytes, TextEncoding = TextEncoding.ASCII},
        Documentation{Description = "This field contains the value of an extended file attribute. The value is expressed as an array of extended ASCII (OEM) characters. This array MUST NOT be null-terminated, and its length MUST NOT exceed 65,535 bytes."};
} with Documentation{Description = "The SMB_FEA data structure is used in Transaction2 subcommands and in the NT_TRANSACT_CREATE subcommand to encode an extended attribute (EA) name/value pair. \"FEA\" stands for \"full extended attribute\".The SMB_FEA structure originated with the LANMAN1.2 dialect and is, therefore, used in Trans2 calls, the majority of which also originated in the LANMAN1.2 dialect. See [XOPEN-SMB] section 16.1.5 for a detailed description of the SMB_FEA structure. NT_TRANSACT_CREATE makes use of the FILE_FULL_EA_INFORMATION structure, which is similar to SMB_FEA. See [MS-FSCC] for information on the FILE_FULL_EA_INFORMATION structure."};

pattern SmbFeaExtendedAttributeFlag = flags UCHAR
{
    Reserved   = 0x7f,
    FileNeedEa = 0x80
        with Documentation{Description = "If set (1), this bit indicates that extended attribute (EA) support is required on this file. Otherwise, EA support is not required. If this flag is set, the file to which the EA belongs cannot be properly interpreted without understanding the associated extended attributes."}
};

// 2.2.1.2.2.1   SMB_FEA_LIST
type SmbFeaList
{
    ULONG SizeOfListInBytes
        with Documentation{Description = "This field MUST contain the total size of the FEAList field, plus the size of the SizeOfListInBytes field (4 bytes).windows clients include both the size of the SizeOfListInBytes field and the total size of the FEAList field when calculating the value passed in the SizeOfListInBytes field. This is required for compatibility with dialects less than the LAN Manager 1.2 dialect, as implemented in OS/2 v1.2. See [XOPEN-SMB] sections 4.3.7 and 16.1.5 for more information."};
    array<SmbFea> FeaList
        with Documentation{Description = "A concatenated list of SMB_FEA structures."};
} with Documentation{Description = "The SMB_FEA_LIST data structure is used to send a concatenated list of SMB_FEA  structures."};

// 2.2.1.2.3   SMB_EXT_FILE_ATTR
pattern SmbExtFileAttr = flags uint
{
    AttrReadonly          = 0x00000001
        with Documentation{Description = "The file is read only. Applications can read the file but cannot write to it or delete it."},
    AttrHidden            = 0x00000002
        with Documentation{Description = "The file is hidden. It is not to be included in an ordinary directory listing."},
    AttrSystem            = 0x00000004
        with Documentation{Description = "The file is part of or is used exclusively by the operating system."},
    Reserved4             = 0x00000008,
    AttrDirectory         = 0x00000010
        with Documentation{Description = "The file is a directory."},
    AttrArchive           = 0x00000020
        with Documentation{Description = "The file has not been archived since it was last modified. Applications use this attribute to mark files for backup or removal."},
    Reserved1             = 0x00000040,
    AttrNormal            = 0x00000080
        with Documentation{Description = "The file has no other attributes set. This attribute is valid only if used alone."},
    AttrTemporary         = 0x00000100
        with Documentation{Description = "The file is temporary. This is a hint to the cache manager that it does not need to flush the file to backing storage."},
    AttrSparse            = 0x00000200
        with Documentation{Description = "File is a sparse file."},
    AttrSparsePoint       = 0x00000400
        with Documentation{Description = "File or directory has an associated reparse point."},
    AttrCompressed        = 0x00000800
        with Documentation{Description = "The file or directory is compressed. For a file, this means that all of the data in the file is compressed. For a directory, this means that compression is the default for newly created files and subdirectories."},
    AttrOffline           = 0x00001000
        with Documentation{Description = "File data is not available. The attribute indicates that the file has been moved to offline storage."},
    AttrNotContentIndexed = 0x00002000
        with Documentation{Description = "File or directory SHOULD NOT be indexed by a content indexing service."},
    AttrEncrypted         = 0x00004000
        with Documentation{Description = "File or directory is encrypted. For a file, this means that all data in the file is encrypted. For a directory, this means that encryption is the default for newly created files and subdirectories."},
    Reserved2             = 0x00FF8000,
    PosixSemantics        = 0x01000000
        with Documentation{Description = "Indicates that the file is to be accessed according to POSIX rules. This includes allowing multiple files with names differing only in case, for file systems that support such naming."},
    BackupSemantics       = 0x02000000
        with Documentation{Description = "Indicates that the file is being opened or created for a backup or restore operation. The server SHOULD allow the client to override normal file security checks, provided it has the necessary permission to do so."},
    DeleteOnClose         = 0x04000000
        with Documentation{Description = "Requests that the server delete the file immediately after all of its handles have been closed."},
    SequentialScan        = 0x08000000
        with Documentation{Description = "Indicates that the file is to be accessed sequentially from beginning to end."},
    RandomAccess          = 0x10000000
        with Documentation{Description = "Indicates that the application is designed to access the file randomly. The server can use this flag to optimize file caching."},
    NoBuffering           = 0x20000000
        with Documentation{Description = "Requests that the server open the file with no intermediate buffering or caching; the server might not honor the request. The application MUST meet certain requirements when working with files opened with FILE_FLAG_NO_BUFFERING. File access MUST begin at offsets within the file that are integer multiples of the volume's sector size and MUST be for numbers of bytes that are integer multiples of the volume's sector size. For example, if the sector size is 512 bytes, an application can request reads and writes of 512, 1024, or 2048 bytes, but not of 335, 981, or 7171 bytes."},
    Reserved3             = 0x40000000,
    WriteThrough          = 0x80000000
        with Documentation{Description = "Instructs the operating system to write through any intermediate cache and go directly to the file. The operating system can still cache write operations, but cannot lazily flush them."},
};

// 2.2.1.2.4   SMB_FILE_ATTRIBUTES
pattern SmbFileAttributes = flags ushort
{
    SmbFileAttributeReadonly    = 0x0001
        with Documentation{Description = "Read-only file."},
    SmbFileAttributeHidden      = 0x0002
        with Documentation{Description = "Hidden file."},
    SmbFileAttributeSystem      = 0x0004
        with Documentation{Description = "System file."},
    SmbFileAttributeVolume      = 0x0008
        with Documentation{Description = "Volume Label."},
    SmbFileAttributeDirectory   = 0x0010
        with Documentation{Description = "Directory file."},
    SmbFileAttributeArchive     = 0x0020
        with Documentation{Description = "File changed since last archive."},
    Reserved1                   = 0x00C0,
    SmbSearchAttributeReadonly  = 0x0100
        with Documentation{Description = "Search for Read-only files."},
    SmbSearchAttributeHidden    = 0x0200
        with Documentation{Description = "Search for Hidden files."},
    SmbSearchAttributeSystem    = 0x0400
        with Documentation{Description = "Search for System files."},
    Reserved2                   = 0x0800,
    SmbSearchAttributeDirectory = 0x1000
        with Documentation{Description = "Search for Directory files."},
    SmbSearchAttributeArchive   = 0x2000
        with Documentation{Description = "Search for files that have changed since they were last archived."},
    Reserved3                   = 0xC000,
};

// 2.2.1.3   Named Pipe Status (SMB_NMPIPE_STATUS)
type SmbNMPipeStatus
{
    byte ICount
        with Documentation{Description = "An 8-bit unsigned integer that gives the maximum number of instances the named pipe can have."};
    byte Nonblocking with BinaryEncoding{Width = 1}, DisplayInfo{ToText = NonblockingToString},
        Documentation{Description = "A named pipe read or raw read request will wait (block) until sufficient data to satisfy the read request becomes available, or until the request is canceled."};
    byte Endpoint with BinaryEncoding{Width = 1}, DisplayInfo{ToText = EndpointToString},
        Documentation{Description = "Client-side end of the named pipe. The SMB server MUST clear the Endpoint bit (set it to zero) when responding to the client request because the CIFS client is a consumer requesting service from the named pipe. "};
    byte Reserved where ValidationCheckReservedZero(value == 0, null, false, ReferenceType.Type, "SMB", "Reserved", "SmbNMPipeStatus", value)
        with BinaryEncoding{Width = 2},
            Documentation{Description = "Reserved"};
    byte NamedPipeType with BinaryEncoding{Width = 2}, DisplayInfo{ToText = NamedPipeTypeToString},
        Documentation{Description = "This bit field indicates the type of the named pipe when the named pipe was created by the server. "};
    byte ReadMode with BinaryEncoding{Width = 2}, DisplayInfo{ToText = ReadModeToText},
        Documentation{Description = "This bit field indicates the client read mode for the named pipe. This bit field has no effect on writes to the named pipe."};
        
    static string NonblockingToString(any input)
    {
        if(!(input is byte))
            return "";
        byte data = input as byte;
        switch(data)
        {
            case 0 => return "Read and write request block if no date available(" + Utility.DecToHexFormat(data) + ")";
            case 1 => return "Read and write request will not block(" + Utility.DecToHexFormat(data) + ")";
            default => return "Unknown(" + Utility.DecToHexFormat(data) + ")";
        }
    }
    
    static string EndpointToString(any input)
    {
        if(!(input is byte))
            return "";
        byte data = input as byte;
        switch(data)
        {
            case 0 => return "Client-side end of the named pipe(" + Utility.DecToHexFormat(data) + ")";
            case 1 => return "Server end of the pipe(" + Utility.DecToHexFormat(data) + ")";
            default => return "Unknown(" + Utility.DecToHexFormat(data) + ")";
        }
    }

    
    static string NamedPipeTypeToString(any input)
    {
        if(!(input is byte))
            return "";
        byte data = input as byte;
        switch(data)
        {
            case 0 => return "Byte mode pipe(" + Utility.DecToHexFormat(data) + ")";
            case 1 => return "Message mode pipe(" + Utility.DecToHexFormat(data) + ")";
            default => return "Reserved(" + Utility.DecToHexFormat(data) + ")";
        }
    }

    
    static string ReadModeToText(any input)
    {
        if(!(input is byte))
            return "";
        byte data = input as byte;
        switch(data)
        {
            case 0 => return "Should be read in byte mode(" + Utility.DecToHexFormat(data) + ")";
            case 1 => return "Should be read in message mode(" + Utility.DecToHexFormat(data) + ")";
            default => return "Reserved(" + Utility.DecToHexFormat(data) + ")";
        }
    }
    
    override string ToString()
    {
        return "ICount: " + (ICount as string) + 
            ", ReadMode: " + (ReadMode == 0? "Byte" : (ReadMode == 1? "Message" : "Reserved")) +
            ", NamedPipeType: " + (NamedPipeType == 0? "Byte" : (NamedPipeType == 1? "Message" : "Reserved")) + 
            ", Endpoint: " + (Endpoint == 0? "Client" : "Server") +
            ", Nonblocking: " + (Nonblocking == 0? "Block" : "Nonblock");
    }
}

// 2.2.1.4.1   SMB_DATE
type SmbDate
{
    byte Year with BinaryEncoding{Width = 7},
        Documentation{Description = "The year. Add 1980 to the resulting value to return the actual year."};
    byte Month with BinaryEncoding{Width = 4, Endian = Endian.Big},
        Documentation{Description = "The month. Values range from 1 to 12."};
    byte Day with BinaryEncoding{Width = 5},
        Documentation{Description = "The date. Values range from 1 to 31."};
    override string ToString()
    {
        return ((Year + 1980) as string) + "-" + (Month as string) + "-" + (Day as string);
    }
} with BinaryEncoding{WidthForComposedType = 16, DecodeAsUnit = true};

// 2.2.1.4.2   SMB_TIME
type SmbTime
{
    byte Hour with BinaryEncoding{Width = 5},
        Documentation{Description = "The hours. Values range from 0 to 23."};
    byte Minutes with BinaryEncoding{Width = 6, Endian = Endian.Big},
        Documentation{Description = "The minutes. Values range from 0 to 59."};
    byte Seconds with BinaryEncoding{Width = 5},
        Documentation{Description = "The seconds. Values MUST represent two-second increments."};
    override string ToString()
    {
        return ((Hour as string) + ":" + (Minutes as string) + ":" + (Seconds as string));
    }
} with BinaryEncoding{WidthForComposedType = 16, DecodeAsUnit = true};

type SmbString[bool IsFlags2Unicode]
{
    string Value with BinaryEncoding{TextEncoding = (IsFlags2Unicode ? TextEncoding.UTF16 : TextEncoding.ASCII)};
    
    override string ToString()
    {
        return Value;
    }
}

type SmbStringWithLength[bool IsFlags2Unicode, ULONG Length]
{
    string Value with BinaryEncoding{Length = Length, TextEncoding = (IsFlags2Unicode ? TextEncoding.UTF16 : TextEncoding.ASCII)};
}

// 2.2.2.3.1   FIND Information Level Codes
pattern FindInformationLevelCodes = enum ushort
{
    SMB_INFO_STANDARD                 = 0x0001
        with Documentation{Description = "Return creation, access, and last write timestamps, size and file attributes along with the file name."},
    SMB_INFO_QUERY_EA_SIZE              = 0x0002
        with Documentation{Description = "Return the SMB_INFO_STANDARD data along with the size of a file's extended attributes (EAs)."},
    SMB_INFO_QUERY_EAS_FROM_LIST         = 0x0003
        with Documentation{Description = "Return the SMB_INFO_QUERY_EA_SIZE data along with a specific list of a file's EAs. The requested EAs are provided in the Trans2_Data block of the request."},
    SMB_FIND_FILE_DIRECTORY_INFO        = 0x0101
        with Documentation{Description = "Return 64-bit format versions of: creation, access, last write, and last attribute change timestamps; size. In addition, return extended file attributes and file name."},
    SMB_FIND_FILE_FULL_DIRECTORY_INFO    = 0x0102
        with Documentation{Description = "Returns the SMB_FIND_FILE_DIRECTORY_INFO data along with the size of a file's EAs."},
    SMB_FIND_FILE_NAMES_INFO            = 0x0103
        with Documentation{Description = "Returns the name(s) of the file(s)."},
    SMB_FIND_FILE_BOTH_DIRECTORY_INFO    = 0x0104
        with Documentation{Description = "Returns a combination of the data from SMB_FIND_FILE_FULL_DIRECTORY_INFO and SMB_FIND_FILE_NAMES_INFO."},
    SMB_FIND_FILE_ID_FULL_DIRECTORY_INFO  = 0x0105
        with Documentation{Description = "Returns the SMB_FIND_ FULL_DIRECTORY_INFO data with a FileId."},
    SMB_FIND_FILE_ID_BOTH_DIRECTORY_INFO  = 0x0106
        with Documentation{Description = "Returns the SMB_FIND_FILE_ID_BOTH_DIRECTORY_INFO data with a FileId."},
    ...
};

// 2.2.2.3.2   QUERY_FS Information Level Codes
pattern QueryFSInformationLevelCodes = enum ushort
{
    SMB_INFO_ALLOCATION       = 0x0001
        with Documentation{Description = "Query file system allocation unit information."},
    SMB_INFO_VOLUME           = 0x0002
        with Documentation{Description = "Query volume name and serial number."},
    SMB_QUERY_FS_VOLUME_INFO    = 0x0102
        with Documentation{Description = "Query the creation timestamp, serial number, and Unicode-encoded volume label."},
    SMB_QUERY_FS_SIZE_INFO      = 0x0103
        with Documentation{Description = "Query 64-bit file system allocation unit information."},
    SMB_QUERY_FS_DEVICE_INFO    = 0x0104
        with Documentation{Description = "Query a file system's underlying device type and characteristics."},
    SMB_QUERY_FS_ATTRIBUTE_INFO = 0x0105
        with Documentation{Description = "Query file system attributes."},
    ...
};
    
// 2.2.2.3.3   QUERY Information Level Codes
pattern QueryInformationLevelCodes = enum ushort
{
    SMB_INFO_STANDARD             = 0x0001
        with Documentation{Description = "Query creation, access, and last write timestamps, size and file attributes."},
    SMB_INFO_QUERY_EA_SIZE          = 0x0002
        with Documentation{Description = "Query the SMB_INFO_STANDARD data along with the size of the file's extended attributes (EAs)."},
    SMB_INFO_QUERY_EAS_FROM_LIST     = 0x0003
        with Documentation{Description = "Query a file's specific EAs by attribute name."},
    SMB_INFO_QUERY_ALL_EAS          = 0x0004
        with Documentation{Description = "Query all of a file's EAs."},
    SMB_INFO_IS_NAME_VALID          = 0x0006
        with Documentation{Description = "Validate the syntax of the path provided in the request. Not supported for TRANS2_QUERY_FILE_INFORMATION."},
    SMB_QUERY_FILE_BASIC_INFO       = 0x0101
        with Documentation{Description = "Query 64-bit create, access, write, and change timestamps along with extended file attributes."},
    SMB_QUERY_FILE_STANDARD_INFO    = 0x0102
        with Documentation{Description = "Query size, number of links, if a delete is pending, and if the path is a directory."},
    SMB_QUERY_FILE_EA_INFO          = 0x0103
        with Documentation{Description = "Query the size of the file's EAs."},
    SMB_QUERY_FILE_NAME_INFO        = 0x0104
        with Documentation{Description = "Query the long file name in Unicode format."},
    SMB_QUERY_FILE_ALL_INFO         = 0x0107
        with Documentation{Description = "Query the SMB_QUERY_FILE_BASIC_INFO, SMB_FILE_QUERY_STANDARD_INFO, SMB_FILE_EA_INFO, and SMB_QUERY_FILE_NAME_INFO data as well as access flags, access mode, and alignment information in a single request."},
    SMB_QUERY_FILE_ALT_NAME_INFO     = 0x0108
        with Documentation{Description = "Query the 8.3 file name."},
    SMB_QUERY_FILE_STREAM_INFO      = 0x0109
        with Documentation{Description = "Query file stream information."},
    SMB_QUERY_FILE_COMPRESSION_INFO = 0x010B
        with Documentation{Description = "Query file compression information."},
    ...
};

// 2.2.2.3.4   SET Information Level Codes
pattern SetInformationLevelCodes = enum ushort
{
    SMB_INFO_STANDARD           = 0x0001
        with Documentation{Description = "Set creation, access, and last write timestamps."},
    SMB_INFO_SET_EAS             = 0x0002
        with Documentation{Description = "Set a specific list of extended attributes (EAs)."},
    SMB_SET_FILE_BASIC_INFO       = 0x0101
        with Documentation{Description = "Set 64-bit create, access, write, and change timestamps along with extended file attributes. Not supported for TRANS2_SET_PATH_INFORMATION (section 2.2.6.7)."},
    SMB_SET_FILE_DISPOSITION_INFO = 0x0102
        with Documentation{Description = "Set whether or not the file is marked for deletion. Not supported for TRANS2_SET_PATH_INFORMATION (section 2.2.6.7)."},
    SMB_SET_FILE_ALLOCATION_INFO  = 0x0103
        with Documentation{Description = "Set file allocation size. Not supported for TRANS2_SET_PATH_INFORMATION (section 2.2.6.7)."},
    SMB_SET_FILE_END_OF_FILE_INFO   = 0x0104
        with Documentation{Description = "Set file EOF offset. Not supported for TRANS2_SET_PATH_INFORMATION (section 2.2.6.7)."},
    ...
};

// 2.2.2.3.5   Pass-through Information Level Codes
// 0x03E8 + FileSystemInformationClasses | FileInformationClasses
/* This document provides an extension of a new Information Level code value range called pass-through Information Levels, 
 *      which can be used to set or query information on the server. These Information Levels allow SMB clients to directly query 
 *      Information Levels native to the underlying object store.
 * Servers indicate support for these new pass-through Information Levels by setting the new CAP_INFOLEVEL_PASSTHRU capability 
 *      flag in an SMB_COM_NEGOTIATE server response (section 2.2.4.5.2).
 * To access these new Information Levels, a client adds the constant SMB_INFO_PASSTHROUGH (0x03e8) to the desired native 
 *      information class level value. This value is then sent in the InformationLevel field of the particular SMB_COM_TRANSACTION2 
 *      subcommand being used to access the Information Levels.
 */

// 2.2.2.4   SMB Error Classes and Codes
map<uint, string> SmbNtStatusMap =
{
    0x00000000 -> "STATUS_SUCCESS",
    0x00010002 -> "STATUS_INVALID_SMB",
    0x00050002 -> "STATUS_SMB_BAD_TID",
    0x00160002 -> "STATUS_SMB_BAD_COMMAND",
    0x005B0002 -> "STATUS_SMB_BAD_UID",
    0x00FB0002 -> "STATUS_SMB_USE_STANDARD",
    0x80000005 -> "STATUS_BUFFER_OVERFLOW",
    0x80000006 -> "STATUS_NO_MORE_FILES",
    0x8000002D -> "STATUS_STOPPED_ON_SYMLINK",
    0xC0000002 -> "STATUS_NOT_IMPLEMENTED",
    0xC000000D -> "STATUS_INVALID_PARAMETER",
    0xC000000E -> "STATUS_NO_SUCH_DEVICE",
    0xC0000010 -> "STATUS_INVALID_DEVICE_REQUEST",
    0xC0000016 -> "STATUS_MORE_PROCESSING_REQUIRED",
    0xC0000022 -> "STATUS_ACCESS_DENIED",
    0xC0000023 -> "STATUS_BUFFER_TOO_SMALL",
    0xC0000034 -> "STATUS_OBJECT_NAME_NOT_FOUND",
    0xC0000035 -> "STATUS_OBJECT_NAME_COLLISION",
    0xC000003A -> "STATUS_OBJECT_PATH_NOT_FOUND",
    0xC00000A5 -> "STATUS_BAD_IMPERSONATION_LEVEL",
    0xC00000B5 -> "STATUS_IO_TIMEOUT",
    0xC00000BA -> "STATUS_FILE_IS_A_DIRECTORY",
    0xC00000BB -> "STATUS_NOT_SUPPORTED",
    0xC00000C9 -> "STATUS_NETWORK_NAME_DELETED",
    0xC0000203 -> "STATUS_USER_SESSION_DELETED",
    0xC000035C -> "STATUS_NETWORK_SESSION_EXPIRED",
    0xC000205A -> "STATUS_SMB_TOO_MANY_UIDS",
    0xC0000002 -> "STATUS_NOT_IMPLEMENTED",
    0xC00000AF -> "STATUS_ILLEGAL_FUNCTION",
    0xC000000F -> "STATUS_NO_SUCH_FILE",
    0xC0000039 -> "STATUS_OBJECT_PATH_INVALID",
    0xC000003B -> "STATUS_OBJECT_PATH_SYNTAX_BAD",
    0xC000009B -> "STATUS_DFS_EXIT_PATH_FOUND",
    0xC00000FB -> "STATUS_REDIRECTOR_NOT_STARTED",
    0xC000011F -> "STATUS_TOO_MANY_OPENED_FILES",
    0xC000001E -> "STATUS_INVALID_LOCK_SEQUENCE",
    0xC000001F -> "STATUS_INVALID_VIEW_SIZE",
    0xC0000021 -> "STATUS_ALREADY_COMMITTED",
    0xC0000041 -> "STATUS_PORT_CONNECTION_REFUSED",
    0xC000004B -> "STATUS_THREAD_IS_TERMINATING",
    0xC0000056 -> "STATUS_DELETE_PENDING",
    0xC0000061 -> "STATUS_PRIVILEGE_NOT_HELD",
    0xC000006D -> "STATUS_LOGON_FAILURE",
    0xC00000D5 -> "STATUS_FILE_RENAMED",
    0xC000010A -> "STATUS_PROCESS_IS_TERMINATING",
    0xC0000101 -> "STATUS_DIRECTORY_NOT_EMPTY",
    0xC0000121 -> "STATUS_CANNOT_DELETE",
    0xC0000123 -> "STATUS_FILE_DELETED",
    0x00060001 -> "STATUS_SMB_BAD_FID",
    0xC0000008 -> "STATUS_INVALID_HANDLE",
    0xC0000024 -> "STATUS_OBJECT_TYPE_MISMATCH",
    0xC0000037 -> "STATUS_PORT_DISCONNECTED",
    0xC0000042 -> "STATUS_INVALID_PORT_HANDLE",
    0xC0000128 -> "STATUS_FILE_CLOSED",
    0xC0000235 -> "STATUS_HANDLE_NOT_CLOSABLE",
    0xC0000040 -> "STATUS_SECTION_TOO_BIG",
    0xC0000097 -> "STATUS_TOO_MANY_PAGING_FILES",
    0xC0000205 -> "STATUS_INSUFF_SERVER_RESOURCES",
    0x000C0001 -> "STATUS_OS2_INVALID_ACCESS",
    0xC0000022 -> "STATUS_ACCESS_DENIED",
    0xC000009C -> "STATUS_DATA_ERROR",
    0xC00000D4 -> "STATUS_NOT_SAME_DEVICE",
    0x80000006 -> "STATUS_NO_MORE_FILES",
    0xC0000001 -> "STATUS_UNSUCCESSFUL",
    0xC0000043 -> "STATUS_SHARING_VIOLATION",
    0xC0000054 -> "STATUS_FILE_LOCK_CONFLICT",
    0xC0000055 -> "STATUS_LOCK_NOT_GRANTED",
    0xC0000011 -> "STATUS_END_OF_FILE",
    0XC00000BB -> "STATUS_NOT_SUPPORTED",
    0xC0000035 -> "STATUS_OBJECT_NAME_COLLISION",
    0xC000000D -> "STATUS_INVALID_PARAMETER",
    0x007C0001 -> "STATUS_OS2_INVALID_LEVEL",
    0x00830001 -> "STATUS_OS2_NEGATIVE_SEEK",
    0x00FF0001 -> "STATUS_OS2_EA_LIST_INCONSISTENT",
    0xC000007E -> "STATUS_RANGE_NOT_LOCKED",
    0x00710001 -> "STATUS_OS2_NO_MORE_SIDS",
    0x00AD0001 -> "STATUS_OS2_CANCEL_VIOLATION",
    0x00AE0001 -> "STATUS_OS2_ATOMIC_LOCKS_NOT_SUPPORTED",
    0xC0000003 -> "STATUS_INVALID_INFO_CLASS",
    0xC00000AD -> "STATUS_INVALID_PIPE_STATE",
    0xC00000B4 -> "STATUS_INVALID_READ_MODE",
    0x010A0001 -> "STATUS_OS2_CANNOT_COPY",
    0xC00000AB -> "STATUS_INSTANCE_NOT_AVAILABLE",
    0xC00000AC -> "STATUS_PIPE_NOT_AVAILABLE",
    0xC00000AE -> "STATUS_PIPE_BUSY",
    0xC00000B1 -> "STATUS_PIPE_CLOSING",
    0xC00000D9 -> "STATUS_PIPE_EMPTY",
    0xC00000B0 -> "STATUS_PIPE_DISCONNECTED",
    0x80000005 -> "STATUS_BUFFER_OVERFLOW",
    0xC0000016 -> "STATUS_MORE_PROCESSING_REQUIRED",
    0xC0000050 -> "STATUS_EA_TOO_LARGE",
    0x01130001 -> "STATUS_OS2_EAS_DIDNT_FIT",
    0xC000004F -> "STATUS_EAS_NOT_SUPPORTED",
    0x03E20001 -> "STATUS_OS2_EA_ACCESS_DENIED",
    0x0000010C -> "STATUS_NOTIFY_ENUM_DIR",
    0x00010002 -> "STATUS_INVALID_SMB",
    0xC000006A -> "STATUS_WRONG_PASSWORD",
    0xC0000257 -> "STATUS_PATH_NOT_COVERED",
    0xC00000CA -> "STATUS_NETWORK_ACCESS_DENIED",
    0xC00000C9 -> "STATUS_NETWORK_NAME_DELETED",
    0x00050002 -> "STATUS_SMB_BAD_TID",
    0xC00000CC -> "STATUS_BAD_NETWORK_NAME",
    0xC00000CB -> "STATUS_BAD_DEVICE_TYPE",
    0x00160002 -> "STATUS_SMB_BAD_COMMAND",
    0xC00000C6 -> "STATUS_PRINT_QUEUE_FULL",
    0xC00000C7 -> "STATUS_NO_SPOOL_SPACE",
    0xC00000C8 -> "STATUS_PRINT_CANCELLED",
    0xC0000002 -> "STATUS_NOT_IMPLEMENTED",
    0xC00000C4 -> "STATUS_UNEXPECTED_NETWORK_ERROR",
    0xC00000B5 -> "STATUS_IO_TIMEOUT",
    0xC00000D0 -> "STATUS_REQUEST_NOT_ACCEPTED",
    0xC00000CE -> "STATUS_TOO_MANY_SESSIONS",
    0x005B0002 -> "STATUS_SMB_BAD_UID",
    0x00FA0002 -> "STATUS_SMB_USE_MPX",
    0x00FB0002 -> "STATUS_SMB_USE_STANDARD",
    0x00FC0002 -> "STATUS_SMB_CONTINUE_MPX",
    0x80000014 -> "STATUS_EA_LIST_INCONSISTENT",
    0xC0000072 -> "STATUS_ACCOUNT_DISABLED",
    0xC0000193 -> "STATUS_ACCOUNT_EXPIRED",
    0xC0000070 -> "STATUS_INVALID_WORKSTATION",
    0xC000006F -> "STATUS_INVALID_LOGON_HOURS",
    0xC0000071 -> "STATUS_PASSWORD_EXPIRED",
    0xC0000224 -> "STATUS_PASSWORD_MUST_CHANGE",
    0XFFFF0002 -> "STATUS_SMB_NO_SUPPORT",
    0xC00000A2 -> "STATUS_MEDIA_WRITE_PROTECTED",
    0xC0000013 -> "STATUS_NO_MEDIA_IN_DEVICE",
    0xC0000184 -> "STATUS_INVALID_DEVICE_STATE",
    0xC000003E -> "STATUS_DATA_ERROR",
    0xC000003F -> "STATUS_CRC_ERROR",
    0xC0000032 -> "STATUS_DISK_CORRUPT_ERROR",
    0xC0000015 -> "STATUS_NONEXISTENT_SECTOR",
    0x8000000E -> "STATUS_DEVICE_PAPER_EMPTY",
    0xC0000043 -> "STATUS_SHARING_VIOLATION",
    0xC0000054 -> "STATUS_FILE_LOCK_CONFLICT",
    0xC0000012 -> "STATUS_WRONG_VOLUME",
    0xC000007F -> "STATUS_DISK_FULL"    
};

string SmbStatusValuesToText(SmbStatusOrNtstatus status)
{
    if (status is s:ERREF.NTSTATUS)
    {
        uint code = s.Value;
        if (code in SmbNtStatusMap)
        {
            return SmbNtStatusMap[code];
        }
        else
        {
            return NtStatusValuesToText(code);
        }
    }
    else
    {
        return SmbErrorToText(status as SMBSTATUS);
    }
}

// 2.2.2.5 Data Buffer Format Codes
pattern DataBufferFormatCodes = enum byte
{
    DataBuffer = 0x01
        with Documentation{Description = "A two-byte USHORT value indicating the length of the data buffer. The data buffer follows immediately after the length field."},
    DialectString = 0x02
        with Documentation{Description = "A null-terminated OEM_STRING. This format code is used only in the SMB_COM_NEGOTIATE (section ) command to identify SMB dialect strings."},
    Pathname = 0x03
        with Documentation{Description = "A null-terminated string representing a file system path. In the NT LAN Manager dialect, the string is of type SMB_STRING unless otherwise specified."},
    SMBString = 0x04
        with Documentation{Description = "A null-terminated string. In the NT LAN Manager dialect, the string is of type SMB_STRING unless otherwise specified."},
    VariableBlock = 0x05
        with Documentation{Description = "A two-byte USHORT value indicating the length of the variable block. The variable block follows immediately after the length field."},
    ...
};

// 2.2.1.5   Status Codes (SMB_ERROR)
type SMBSTATUS
{
    SmbErrorClass ErrorClass;
    UCHAR Reserved;
    ([|ErrorClass == SmbErrorClass.SUCCESS|] SuccessClassErrorCode
    | [|ErrorClass == SmbErrorClass.ERRDOS|] ErrdosClassErrorCode
    | [|ErrorClass == SmbErrorClass.ERRSRV|] ErrsrvClassErrorCode
    | [|ErrorClass == SmbErrorClass.ERRHRD|] ErrhrdClassErrorCode
    | USHORT) ErrorCode with DisplayInfo{ToText = ErrorCodeToText};
}

uint get Value(this SMBSTATUS status)
{
    uint val = (status.ErrorCode << 16) as uint;
    val += (status.Reserved << 8) as uint;
    val += status.ErrorClass;
    return val;
}

string ErrorCodeToText(any v)
{
    if(v is s:SuccessClassErrorCode)
    {
        return EnumToString<SMB.SuccessClassErrorCode>(s, true, s.ToString());
    }
    else if(v is dos:ErrdosClassErrorCode)
    {
        return EnumToString<SMB.ErrdosClassErrorCode>(dos, true, dos.ToString());
    }
    else if(v is srv:ErrsrvClassErrorCode)
    {
        return EnumToString<SMB.ErrsrvClassErrorCode>(srv, true, srv.ToString());
    }
    else if(v is hrd:ErrhrdClassErrorCode)
    {
        return EnumToString<SMB.ErrhrdClassErrorCode>(hrd, true, hrd.ToString());
    }
    return v.ToString();
}

pattern SmbStatusOrNtstatus = ERREF.NTSTATUS | SMBSTATUS;

// 2.2.3.1   The SMB Header
message SmbHeader
{
    ULONG Protocol where ValidationCheck(value == 0xFF534D42, null, "SMB: The Protocol in SmbHeader must be a 4-byte literal string (in network order) containing '0xFF', 'S', 'M', 'B'.")
        with BinaryEncoding{Endian = Endian.Big}, 
            DisplayInfo{ToText = GetProtocolString},
            Documentation{Description = "This field MUST contain the 4-byte literal string '\xFF', 'S', 'M', 'B', with the letters represented by their respective ASCII values in the order shown. In the earliest available SMB documentation, this field is defined as a one byte message type (0xFF) followed by a three byte server type identifier."};
    SmbCommand Command
        where ValidationCheck(InRange<SmbCommand>(value), null, DiagnosisLevel.Error, "SMB: The Command field in message SmbHeader is an undefined value. Please refer to SMB_COM Command Codes in Technical Document [MS-CIFS].")
        with Documentation{Description = "A one-byte command code. Defined SMB command codes are listed in section 2.2.2.1."};
    
    // SmbHeaderFlags2.SMB_FLAGS2_NT_STATUS(0x4000) If this bit is set in a client request, the server MUST return errors as 32-bit NTSTATUS codes in the response. If it is clear, the server SHOULD<27> return errors in SMBSTATUS format.
    // If this bit is set in the server response, the Status field in the header is formatted as an NTSTATUS code; else, it is in SMBSTATUS format.
    // Since SmbHeaderFlags2 is little-endian, so peek byte with position offset 48 from current field (STATUS), which is the higher byte of SmbHeaderFlags2, to determine how to parse this field.
    (([|RemainingBitLength(stream) >= 56 && (PeekByte(stream, stream.BitPosition + 48) & 0x40) != 0|] ERREF.NTSTATUS) | SMBSTATUS) Status
        with Documentation{Description = "A 32-bit field used to communicate error messages from the server to the client."};
    SmbHeaderFlags Flags
        with Documentation{Description = "An 8-bit field of 1-bit flags describing various features in effect for the message."};
    SmbHeaderFlags2 Flags2
        with Documentation{Description = "A 16-bit field of 1-bit flags that represent various features in effect for the message. Unspecified bits are reserved and MUST be zero."};
    USHORT PidHigh
        with Documentation{Description = "If set to a nonzero value, this field represents the high-order bytes of a process identifier (PID). It is combined with the PIDLow field below to form a full PID."};
    SmbHeaderSecurityfeatures SecurityFeatures
        with Documentation{Description = "This 8-byte field has three possible interpretations. In the case that security signatures are negotiated (see SMB_COM_NEGOTIATE (section 2.2.4.52) ), the following format MUST be observed."};
    USHORT Reserved where ValidationCheckReservedZero(value == 0, null, false, ReferenceType.Message, "SMB", "Reserved", "SmbHeader", value)
        with Documentation{Description = "This field is reserved and SHOULD be 0x0000."};
    USHORT Tid with Documentation{Description = "A tree identifier (TID)."};
    USHORT PidLow with Documentation{Description = "The lower 16 bits of the PID."};
    USHORT Uid with Documentation{Description = "A user identifier (UID)."};
    USHORT Mid with Documentation{Description = "A multiplex identifier (MID)."};
    
    static string GetProtocolString(any data) 
    {
        return "SMB";
    }

    static string GetRequestSmbHeaderString(USHORT Tid, USHORT Mid)
    {
        return "Tid: " + DecToHexFormat(Tid) + ", Mid: " + DecToHexFormat(Mid);
    }
    
    static string GetResponseSmbHeaderString(SmbStatusOrNtstatus status, USHORT tid, USHORT mid)
    {
        return "Status: " + SmbStatusValuesToText(status) + ", Tid: " + DecToHexFormat(tid) + ", Mid: " + DecToHexFormat(mid);
    }
    
    override string ToString()
    {
        return ((this#SMBMessageName is nothing) ? "" : ((this#SMBMessageName as string)+", ")) + "Header Only, Status: " + SmbStatusValuesToText(Status) + ", Tid: " + DecToHexFormat(Tid) + ", Mid: " + DecToHexFormat(Mid);
    }
} with Documentation{Description = "The SMB_Header structure is a fixed 32 bytes in length."};

pattern SmbHeaderFlags = flags byte
{
    SmbFlagsLockAndReadOk      = 0x01
        with Documentation{Description = "This bit is set (1) in the SMB_COM_NEGOTIATE (0x72) Response (section 2.2.4.52.2) if the server supports SMB_COM_LOCK_AND_READ (0x13) (section 2.2.4.20) and SMB_COM_WRITE_AND_UNLOCK (0x14) (section 2.2.4.21) commands."},
    SmbFlagsBufAvail           = 0x02
        with Documentation{Description = "Obsolete. This bit MUST be set to zero by the client and MUST be ignored by the server."},
    Reserved                   = 0x04
        with Documentation{Description = "This flag MUST be set to zero by the client and MUST be ignored by the server."},
    SmbFlagsCaseInsensitive    = 0x08
        with Documentation{Description = "Obsolete. If this bit is set then all pathnames in the SMB SHOULD be treated as case-insensitive."},
    SmbFlagsCanonicalizedPaths = 0x10
        with Documentation{Description = "Obsolescent. When set in session setup, this bit indicates that all paths sent to the server are already in canonical format. That is, all file and directory names are composed of valid file name characters in all upper-case, and that the path segments are separated by backslash characters ('\')."},
    SmbFlagsOplock             = 0x20
        with Documentation{Description = "Obsolescent. This bit has meaning only in the deprecated SMB_COM_OPEN (0x02) Request (section 2.2.4.3.1), SMB_COM_CREATE (0x03) Request (section 2.2.4.4.1), and SMB_COM_CREATE_NEW (0x0F) Request (section 2.2.4.16.1) messages, where it is used to indicate that the client is requesting an Exclusive OpLock. "},
    SmbFlagsOpbatch            = 0x40
        with Documentation{Description = "Obsolescent. This bit has meaning only in the deprecated SMB_COM_OPEN (0x02) Request (section 2.2.4.3.1), SMB_COM_CREATE (0x03) Request (section 2.2.4.4.1), and SMB_COM_CREATE_NEW (0x0F) Request (section 2.2.4.16.1) messages, where it is used to indicate that the client is requesting a Batch OpLock. "},
    SMBFlagsReply              = 0x80
        with Documentation{Description = "When on, this message is being sent from the server in response to a client request. The Command field usually contains the same value in a protocol request from the client to the server as in the matching response from the server to the client. This bit unambiguously distinguishes the message as a server response."},
};

pattern SmbHeaderFlags2 = flags ushort
{
    SmbFlags2LongNames                 = 0x0001
        with Documentation{Description = "If the bit is set, the message MAY contain long file names. If the bit is clear then file names in the message MUST adhere to the 8.3 naming convention."},
    SmbFlags2Eas                       = 0x0002
        with Documentation{Description = "If the bit is set, the client is aware of extended attributes (EAs)."},
    SmbFlags2SmbSecuritySignature      = 0x0004
        with Documentation{Description = "If set by the client, the client is requesting signing (if signing is not yet active) or the message being sent is signed. This bit is used on the SMB header of an SMB_COM_SESSION_SETUP_ANDX (section 2.2.4.53) client request to indicate that the client supports signing and that the server can choose to enforce signing on the connection based on its configuration."},
    SmbFlags2Compressed                = 0x0008
        with Documentation{Description = "If set by the client, the client is requesting compressed data for an SMB_COM_READ_ANDX request.If cleared by the server, the server is notifying the client that the data was written uncompressed. This bit field SHOULD only be set to one when NT LAN Manager or later is negotiated for the SMB dialect."},
    SmbFlags2SecuritySignatureRequired = 0x0010
        with Documentation{Description = "This flag SHOULD be set by the client on the first SMB_COM_SESSION_SETUP_ANDX request (section 2.2.4.6.1) sent to a server that supports extended security if the client requires all further communication with this server to be signed. If the server does not support signing, it MUST disconnect the client by closing the underlying transport connection. Clients and servers MUST ignore this value for other requests and responses. If the client receives a non-signed response from the server, it MUST disconnect the underlying transport connection. This bit field SHOULD only be set to one when NT LAN Manager or later is negotiated for the SMB dialect, the client supports extended security, and the client is configured to require security signatures."},
    Reserved                           = 0x0020,
    SmbFlags2IsLong_Name               = 0x0040
        with Documentation{Description = "If set, the path contained in the message contains long names; otherwise, the paths are restricted to 8.3 names. This bit field SHOULD only be set to one when NT LAN Manager or later is negotiated for the SMB dialect. If client sets this bit in the request, the server SHOULD also set this bit in the response."},
    Reserved2                          = 0x0380,
    SmbFlags2ReparsePath               = 0x0400
        with Documentation{Description = "If set, the path in the request MUST contain an @GMT token (that is, a Previous Version token), as specified in section 2.2.1.1.1."},
    SmbFlags2ExtendedSecurity          = 0x0800
        with Documentation{Description = "Indicates that the client or server supports SPNEGO authentication, as specified in section 3.2.5.2 for client behavior and section 3.3.5.2 for server behavior. This bit field SHOULD be set to one only when NT LAN Manager or later is negotiated for the SMB dialect and the client or server supports extended security"},
    SmbFlags2Dfs                       = 0x1000
        with Documentation{Description = "If the bit is set, any pathnames in this SMB SHOULD be resolved in the Distributed File System (DFS)."},
    SmbFlags2PagingIO                  = 0x2000
        with Documentation{Description = "This flag is useful only on a read request. If the bit is set, then the client MAY read the file if the client does not have read permission but does have execute permission."},
    SmbFlags2NTStatus                  = 0x4000
        with Documentation{Description = "If this bit is set in a client request, the server MUST return errors as 32-bit ERREF.NTSTATUS codes in the response. If it is clear, the server SHOULD return errors in SMBSTATUS format. If this bit is set in the server response, the Status field in the header is formatted as an ERREF.NTSTATUS code; else, it is in SMBSTATUS format."},
    SmbFlags2Unicode                   = 0x8000
        with Documentation{Description = "If set in a client request or server response, each field that contains a string in this SMB message MUST be encoded as an array of 16-bit Unicode characters, unless otherwise specified."},
};

type SmbHeaderSecurityfeatures
{
    binary SecuritySignature with BinaryEncoding{Length = 8},
        Documentation{Description = "If SMB signing has been negotiated, this field MUST contain an 8-byte cryptographic message signature that can be used to detect whether the message was modified while in transit. The use of message signing is mutually exclusive with connectionless transport."};
} with Documentation{Description = "This 8-byte field has three possible interpretations."},
       Documentation {EmbeddedType = true};

// 2.2.4.1   SMB_COM_CREATE_DIRECTORY (0x00)
type SmbComCreateDirectoryRequest[bool IsFlags2Unicode]
{
    UCHAR WordCount where value == 0
        with Documentation{Description = "This field MUST be 0x00"};
    USHORT ByteCount where value >= 0x02
        with Documentation{Description = "The number of bytes in the Bytes array that follows."};
    DataBufferFormatCodes BufferFormat where value == 0x04
        with Documentation{Description = "This field MUST be 0x04."};
    SmbString[IsFlags2Unicode] DirectoryName
        with Documentation{Description = "A null-terminated string giving the full pathname, relative to the supplied TID, of the directory to be created."};
} with Documentation{EmbeddedType = true};

// 2.2.4.1   SMB_COM_CREATE_DIRECTORY (0x00)
type SmbComCreateDirectoryResponse
{
    UCHAR WordCount where value == 0x00
        with Documentation{Description = "This field MUST be 0x00. No parameters are sent by this message."};
    USHORT ByteCount where value == 0x0000
        with Documentation{Description = "This field MUST be 0x0000. No data is sent by this message."};
}

// 2.2.4.2   SMB_COM_DELETE_DIRECTORY (0x01)
type SmbComDeleteDirectoryRequest[bool IsFlags2Unicode]
{
    UCHAR WordCount where value == 0x00
        with Documentation{Description = "This field MUST be 0x00. No parameters are sent by this message."};
    USHORT ByteCount where value >= 0x0002
        with Documentation{Description = "This field MUST be greater than or equal to 0x0002."};
    DataBufferFormatCodes BufferFormat where value == 0x04
        with Documentation{Description = "This field MUST contain the value 0x04."};
    SmbString[IsFlags2Unicode] DirectoryName
        with Documentation{Description = "A null-terminated string that contains the full pathname, relative to the supplied TID, of the directory to be deleted."};
} with Documentation{EmbeddedType = true};

// 2.2.4.2   SMB_COM_DELETE_DIRECTORY (0x01)
type SmbComDeleteDirectoryResponse
{
    UCHAR WordCount where value == 0x00
        with Documentation{Description = "This field MUST be 0x00. No parameters are sent by this message."};
    USHORT ByteCount where value == 0x0000
        with Documentation{Description = "This field MUST be 0x0000. No data is sent by this message."};
} with Documentation{EmbeddedType = true};

// 2.2.4.3   SMB_COM_OPEN (0x02)
type SmbComOpenRequest[bool IsFlags2Unicode]
{
    UCHAR WordCount where value == 0x02
        with Documentation{Description = "This field MUST be 0x02."};
    SmbAccessMode AccessMode
        with Documentation{Description = "A 16-bit field for encoding the requested access mode. See section  for a discussion on sharing modes."};
    SmbFileAttributes SearchAttributes
        with Documentation{Description = "Specifies the type of file. This field is used as a search mask. Both the FileName and the SearchAttributes of a file MUST match in order for the file to be opened.windows_nt_server always ignores the SearchAttributes field on Open and Create operations, and searches for files by name only."};
    USHORT ByteCount where value >= 0x0002
        with Documentation{Description = "This field MUST be greater than or equal to 0x0002."};
    DataBufferFormatCodes BufferFormat where value == 0x04
        with Documentation{Description = "A buffer format identifier. The value of this field MUST be 0x04."};
    SmbString[IsFlags2Unicode] FileName
        with Documentation{Description = "A null-terminated string containing the file name of the file to be opened."};
} with Documentation{Description = "The message-specific data structure, which follows."},
       Documentation {EmbeddedType = true};

type SmbAccessMode
{
    byte Reserved1 with BinaryEncoding{Width = 1};
    byte SharingMode with BinaryEncoding{Width = 3} with DisplayInfo{ToText = SharingModeToText};
    byte Reserved2 with BinaryEncoding{Width = 1};
    byte AccessMode with BinaryEncoding{Width = 3} with DisplayInfo{ToText = AccessModeToText};

    byte Reserved3 with BinaryEncoding{Width = 1};
    byte WritethroughMode with BinaryEncoding{Width = 1} with DisplayInfo{ToText = WritethroughModeToText};
    byte Reserved4 with BinaryEncoding{Width = 1};
    byte CacheMode with BinaryEncoding{Width = 1} with DisplayInfo{ToText = CacheModeToText};
    byte Reserved5 with BinaryEncoding{Width = 1};
    byte ReferenceLocality with BinaryEncoding{Width = 3} with DisplayInfo{ToText = ReferenceLocalityToText};
    
    static string AccessModeToText(any input)
    {
        if(!(input is byte))
            return "";
        byte data = input as byte;
        switch(data)
        {
            case 0 => return "Open for reading(" + Utility.DecToHexFormat(data) + ")";
            case 1 => return "Open for writing(" + Utility.DecToHexFormat(data) + ")";
            case 2 => return "Open for reading and writing(" + Utility.DecToHexFormat(data) + ")";
            case 3 => return "Open for execution(" + Utility.DecToHexFormat(data) + ")";
            default => return "Unknown(" + Utility.DecToHexFormat(data) + ")";
        }
    }
        
    static string SharingModeToText(any input)
    {
        if(!(input is byte))
            return "";
        byte data = input as byte;
        switch(data)
        {
            case 0 => return "Compatibility mode(" + Utility.DecToHexFormat(data) + ")";
            case 1 => return "Deny read/write/execute to others (exclusive use requested)(" + Utility.DecToHexFormat(data) + ")";
            case 2 => return "Deny write to others(" + Utility.DecToHexFormat(data) + ")";
            case 3 => return "Deny read/execute to others(" + Utility.DecToHexFormat(data) + ")";
            case 4 => return "Deny nothing to others(" + Utility.DecToHexFormat(data) + ")";
            default => return "Unknown(" + Utility.DecToHexFormat(data) + ")";
        }
    }
    
    static string ReferenceLocalityToText(any input)
    {
        if(!(input is byte))
            return "";        
        byte data = input as byte;
        switch(data)
        {
            case 0 => return "Unknown locality of reference(" + Utility.DecToHexFormat(data) + ")";
            case 1 => return "Mainly sequential access(" + Utility.DecToHexFormat(data) + ")";
            case 2 => return "Mainly random access(" + Utility.DecToHexFormat(data) + ")";
            case 3 => return "Random access with some locality(" + Utility.DecToHexFormat(data) + ")";
            default => return "Undefined(" + Utility.DecToHexFormat(data) + ")";
        }
    }
    
    static string CacheModeToText(any input)
    {
        if(!(input is byte))
            return "";        
        byte data = input as byte;
        switch(data)
        {
            case 0 => return "Perform caching on file(" + Utility.DecToHexFormat(data) + ")";
            case 1 => return "Do not cache the file(" + Utility.DecToHexFormat(data) + ")";
            default => return "Unknown(" + Utility.DecToHexFormat(data) + ")";
        }
    }
    
    static string WritethroughModeToText(any input)
    {
        if(!(input is byte))
            return "";        
        byte data = input as byte;
        switch(data)
        {
            case 0 => return "Read ahead and write behind allowed(" + Utility.DecToHexFormat(data) + ")";
            case 1 => return "No read ahead or write behind allowed(" + Utility.DecToHexFormat(data) + ")";
            default => return "Unknown(" + Utility.DecToHexFormat(data) + ")";
        }
    }
}

// 2.2.4.3   SMB_COM_OPEN (0x02)
type SmbComOpenResponse
{
    UCHAR WordCount where value == 0x0007
        with Documentation{Description = "This field MUST be 0x07. The length, in 2-byte words, of the remaining SMB_Parameters."};
    USHORT Fid
        with Documentation{Description = "The FID returned for the open file."};
    SmbFileAttributes FileAttrs
        with Documentation{Description = "The set of attributes currently assigned to the file. This field is formatted in the same way as the SearchAttributes field in the request."};
    Utime LastModified
        with Documentation{Description = "The time of the last modification to the opened file."};
    ULONG FileSize
        with Documentation{Description = "The current size of the opened file, in bytes."};
    SmbAccessMode AccessMode
        with Documentation{Description = "A 16-bit field for encoding the granted access mode. This field is formatted in the same way as the Request equivalent."};
    USHORT ByteCount where value == 0x0000
        with Documentation{Description = "This field MUST be 0x0000. No data is sent by this message."};
} with Documentation{EmbeddedType = true};

// 2.2.4.4   SMB_COM_CREATE (0x03)
type SmbComCreateRequest[bool IsFlags2Unicode]
{
    UCHAR WordCount where value == 0x03
        with Documentation{Description = "This field MUST be 0x03."};
    SmbFileAttributes FileAttributes
        with Documentation{Description = "A 16-bit field of 1-bit flags that represent the file attributes to assign to the file if it is created successfully."};
    Utime CreationTime
        with Documentation{Description = "The time that the file was created, represented as the number of seconds since Jan 1, 1970, 00:00:00.0."};
    USHORT ByteCount where value >= 0x0002
        with Documentation{Description = "This field MUST be greater than or equal to 0x0002."};
    DataBufferFormatCodes BufferFormat where value == 0x04
        with Documentation{Description = "This field MUST be 0x04."};
    SmbString[IsFlags2Unicode] FileName
        with Documentation{Description = "A null-terminated string that represents the fully qualified name of the file relative to the supplied TID to create or truncate on the server."};
} with Documentation{EmbeddedType = true};

// 2.2.4.4   SMB_COM_CREATE (0x03)
type SmbComCreateResponse
{
    UCHAR WordCount where value == 0x01
        with Documentation{Description = "This field MUST be 0x01."};
    USHORT Fid
        with Documentation{Description = "The FID representing the file on the server. This value MUST be supplied in the FID field of the SMB Header  in subsequent requests that manipulate the file."};
    USHORT ByteCount where value == 0x0000
        with Documentation{Description = "This field MUST be 0x0000. No data is sent by this message."};
}

// 2.2.4.5   SMB_COM_CLOSE (0x04)
type SmbComCloseRequest
{
    UCHAR WordCount where value == 0x03
        with Documentation{Description = "This field MUST be 0x03."};
    USHORT Fid
        with Documentation{Description = "The FID of the object to be closed."};
    Utime LastTimeModified
        with Documentation{Description = "A time value encoded as the number of seconds since January 1, 1970 00:00:00.0. The client can request that the last modification time for the file be updated to this time value. A value of 0x00000000 or 0xFFFFFFFF results in the server not updating the last modification time."};
    USHORT ByteCount where value == 0x0000
        with Documentation{Description = "This field MUST be 0x0000. No data is sent by this message."};
} with Documentation{EmbeddedType = true};

// 2.2.4.5   SMB_COM_CLOSE (0x04)
type SmbComCloseResponse
{
    UCHAR WordCount where value == 0x00
        with Documentation{Description = "This field MUST be 0x00. No parameters are sent by this message."};
    USHORT ByteCount where value == 0x00
        with Documentation{Description = "This field MUST be 0x00. No data is sent by this message"};
}

// 2.2.4.6   SMB_COM_FLUSH (0x05)
type SmbComFlushRequest
{
    UCHAR WordCount where value == 0x01
        with Documentation{Description = "This field MUST be 0x01."};
    USHORT Fid
        with Documentation{Description = "The FID of the file to be flushed. If this field is set to 0xFFFF (65535), all files opened by the same PID within the SMB connection are to be flushed."};
    USHORT ByteCount where value == 0x0000
        with Documentation{Description = "This field MUST be 0x0000. No data is sent by this message."};
} with Documentation{EmbeddedType = true};

// 2.2.4.6   SMB_COM_FLUSH (0x05)
type SmbComFlushResponse
{
    UCHAR WordCount where value == 0x00
        with Documentation{Description = "This field MUST be 0x00. No parameters are sent by this message."};
    USHORT ByteCount where value == 0x0000
        with Documentation{Description = "This field MUST be 0x0000. No data is sent by this message."};
}

// 2.2.4.7   SMB_COM_DELETE (0x06)
type SmbComDeleteRequest[bool IsFlags2Unicode]
{
    UCHAR WordCount where value == 0x01
        with Documentation{Description = "This field MUST be 0x01."};
    SmbFileAttributes SearchAttributes
        with Documentation{Description = "The file attributes of the file(s) to be deleted. If the value of this field is 0x0000, then only normal files MUST be matched for deletion. If the System or Hidden attributes MUST be specified, then entries with those attributes are matched in addition to the normal files. Read-only files MUST NOT be deleted. The read-only attribute of the file MUST be cleared before the file can be deleted."};
    USHORT ByteCount where value >= 0x0002
        with Documentation{Description = "This field MUST be greater than or equal to 0x0002."};
    DataBufferFormatCodes BufferFormat where value == 0x04
        with Documentation{Description = "This field MUST be 0x04."};
    SmbString[IsFlags2Unicode] FileName
        with Documentation{Description = "The pathname of the file(s) to be deleted, relative to the supplied TID. Wildcards MAY be used in the filename component of the path."};
}

// 2.2.4.7   SMB_COM_DELETE (0x06)
type SmbComDeleteResponse
{
    UCHAR WordCount where value == 0x00
        with Documentation{Description = "This field MUST be 0x00. No parameters are sent by this message."};
    USHORT ByteCount where value == 0x0000
        with Documentation{Description = "This field MUST be 0x0000. No data is sent by this message."};
}

// 2.2.4.8   SMB_COM_RENAME (0x07)
type SmbComRenameRequest[bool IsFlags2Unicode]
{
    UCHAR WordCount where value == 0x01
        with Documentation{Description = "This field MUST be 0x01."};
    SmbFileAttributes SearchAttributes
        with Documentation{Description = "Indicates the file attributes that the file(s) to be renamed MUST have. If the value of this field is 0x0000, then only normal files MUST be matched to be renamed. If the System or Hidden attributes are specified, then entries with those attributes MAY be matched in addition to the normal files. Read-only files MUST NOT be renamed. The read-only attribute of the file MUST be cleared before it can be renamed."};
    USHORT ByteCount where value >= 0x0002
        with Documentation{Description = "This field MUST be greater than or equal to 0x0002."};
    DataBufferFormatCodes BufferFormat1 where value == 0x04
        with Documentation{Description = "This field MUST be 0x04."};
    SmbString[IsFlags2Unicode] OldFileName
        with Documentation{Description = "A null-terminated string that contains the name of the file or files to be renamed. Wildcards MAY be used in the filename component of the path."};
    DataBufferFormatCodes BufferFormat2 where value == 0x04
        with Documentation{Description = "This field MUST be 0x04."};
    optional [|IsFlags2Unicode|] UCHAR Pad;
    SmbString[IsFlags2Unicode] NewFileName
        with Documentation{Description = "A null-terminated string containing the new name(s) to be given to the file(s) that matches OldFileName or the name of the destination directory into which the files matching OldFileName MUST be moved."};
}

// 2.2.4.8   SMB_COM_RENAME (0x07)
type SmbComRenameResponse
{
    UCHAR WordCount where value == 0x00
        with Documentation{Description = "This field MUST be 0x00. No parameters are sent by this message."};
    USHORT ByteCount where value == 0x0000
        with Documentation{Description = "This field MUST be 0x0000. No data is sent by this message."};
}

// 2.2.4.9   SMB_COM_QUERY_INFORMATION (0x08)
type SmbComQueryInformationRequest[bool IsFlags2Unicode]
{
    UCHAR WordCount where value == 0x00
        with Documentation{Description = "This field MUST be 0x00. No parameters are sent by this message."};
    USHORT ByteCount where value >= 0x0002
        with Documentation{Description = "This field MUST be greater than or equal to 0x0002."};
    DataBufferFormatCodes BufferFormat where value == 0x04
        with Documentation{Description = "This field MUST be 0x04."};
    SmbString[IsFlags2Unicode] FileName
        with Documentation{Description = "A null-terminated string that represents the fully qualified name of the file relative to the supplied TID. This is the file for which attributes are queried and returned."};
}

// 2.2.4.9   SMB_COM_QUERY_INFORMATION (0x08)
type SmbComQueryInformationResponse
{
    UCHAR WordCount where value == 0x0A
        with Documentation{Description = "This field MUST be 0x0A."};
    SmbFileAttributes FileAttributes
        with Documentation{Description = "This field is a 16-bit unsigned bit field encoded as SMB_FILE_ATTRIBUTES (see section )."};
    Utime LastWriteTime
        with Documentation{Description = "The time of the last write to the file."};
    ULONG FileSize
        with Documentation{Description = "This field contains the size of the file, in bytes. Because this size is limited to 32 bits, this command is inappropriate for files whose size is too large."};
    binary Reserved where value == $[00000000000000000000] with BinaryEncoding{Length = 10},
        Documentation{Description = "This field is reserved, and all entries MUST be set to 0x00."};
    USHORT ByteCount where value == 0x0000
        with Documentation{Description = "This field MUST be 0x0000. No data is sent by this message."};
}

// 2.2.4.10   SMB_COM_SET_INFORMATION (0x09)
type SmbComSetInformationRequest[bool IsFlags2Unicode]
{
    UCHAR WordCount where value == 0x08
        with Documentation{Description = "This field MUST be 0x08."};
    SmbFileAttributes FileAttributes
        with Documentation{Description = "This field is a 16-bit unsigned bit field encoded as SMB_FILE_ATTRIBUTES"};
    Utime LastWriteTime
        with Documentation{Description = "The time of the last write to the file."};
    binary Reserved where value == $[00000000000000000000] with BinaryEncoding{Length = 10},
        Documentation{Description = "This field is reserved, and all bytes MUST be set to 0x00."};
    USHORT ByteCount where value >= 0x0002
        with Documentation{Description = "This field MUST be greater than or equal to 0x0002."};
    DataBufferFormatCodes BufferFormat where value == 0x04
        with Documentation{Description = "This field MUST be 0x04."};
    SmbString[IsFlags2Unicode] FileName
        with Documentation{Description = "A null-terminated string that represents the fully qualified name of the file relative to the supplied TID. This is the file for which attributes are set."};
}

// 2.2.4.10   SMB_COM_SET_INFORMATION (0x09)
type SmbComSetInformationResponse
{
    UCHAR WordCount where value == 0x00
        with Documentation{Description = "This field MUST be 0x00. No parameters are sent by this message."};
    USHORT ByteCount where value == 0x0000
        with Documentation{Description = "This field MUST be 0x0000. No data is sent by this message."};
}

// 2.2.4.11   SMB_COM_READ (0x0A)
type SmbComReadRequest
{
    UCHAR WordCount where value == 0x05
        with Documentation{Description = "This field MUST be 0x05."};
    USHORT Fid
        with Documentation{Description = "This field MUST be a valid 16-bit signed integer indicating the file from which the data MUST be read."};
    USHORT CountOfBytesToRead
        with Documentation{Description = "This field is a 16-bit unsigned integer indicating the number of bytes to be read from the file. The client MUST ensure that the amount of data requested will fit in the negotiated maximum buffer size."};
    ULONG ReadOffsetInBytes
        with Documentation{Description = "This field is a 32-bit unsigned integer indicating the offset, in number of bytes, from which to begin reading from the file. The client MUST ensure that the amount of data requested fits in the negotiated maximum buffer size. Because this field is limited to 32 bits, this command is inappropriate for files having 64-bit offsets."};
    USHORT EstimateOfRemainingBytesToBeRead
        with Documentation{Description = "This field is a 16-bit unsigned integer indicating the remaining number of bytes that the client intends to read from the file. This is an advisory field and MAY be 0x0000."};
    USHORT ByteCount where value == 0x0000
        with Documentation{Description = "This field MUST be 0x0000. No data is sent by this message."};
}

// 2.2.4.11   SMB_COM_READ (0x0A)
type SmbComReadResponse
{
    UCHAR WordCount where value == 0x05
        with Documentation{Description = "This field MUST be 0x05."};
    USHORT CountOfBytesReturned
        with Documentation{Description = "The actual numberof bytes returned to the client. This MUST be equal to CountOfBytesToRead unless the end of file was reached before reading CoutOfBytesToRead bytes or the ReadOffsetInBytes pointed at or beyond the end of file."};
    binary Reserved where value == $[0000000000000000] with BinaryEncoding{Length = 8},
        Documentation{Description = "Reserved. All bytes MUST be 0x00."};
    USHORT ByteCount where value >= 0x0003
        with Documentation{Description = "This field MUST be 0x0003 + CountOfBytesRead."};
    DataBufferFormatCodes BufferFormat where value == 0x01
        with Documentation{Description = "This fieldMUST be 0x01."};
    USHORT CountOfBytesRead
        with Documentation{Description = "The number of bytes read that are contained in the following array of bytes."};
    binary Bytes with BinaryEncoding{Length = CountOfBytesRead}, 
        Documentation{Description = "The actual bytes read from the file."};
}

// 2.2.4.12   SMB_COM_WRITE (0x0B)
type SmbComWriteRequest
{
    UCHAR WordCount where value == 0x05
        with Documentation{Description = "This field MUST be 0x05."};
    USHORT Fid
        with Documentation{Description = "This field MUST be a valid 16-bit unsigned integer indicating the file to which the data MUST be written."};
    USHORT CountOfBytesToWrite
        with Documentation{Description = "This field is a 16-bit unsigned integer indicating the number of bytes to be written to the file. The client MUST ensure that the amount of data sent can fit in the negotiated maximum buffer size."};
    ULONG WriteOffsetInBytes
        with Documentation{Description = "This field is a 32-bit unsigned integer indicating the offset, in number of bytes, from the beginning of the file at which to begin writing to the file. The client MUST ensure that the amount of data sent fits in the negotiated maximum buffer size. Because this field is limited to 32 bits, this command is inappropriate for files that have 64-bit offsets."};
    USHORT EstimateOfRemainingBytesToBeWritten
        with Documentation{Description = "This field is a 16-bit unsigned integer indicating the remaining number of bytes that the client anticipates to write to the file. This is an advisory field and can be 0x0000. This information can be used by the server to optimize cache behavior."};
    USHORT ByteCount where value >= 0x03
        with Documentation{Description = "This field MUST be greater than or equal to 0x0003. The total value represents the size of the BufferFormat field in bytes plus the size of the DataLength field in bytes plus the value of the CountOfBytesToWrite field. See Data Buffer Format Codes for a complete description of data buffer format codes and their usages."};
    DataBufferFormatCodes BufferFormat where value == 0x01
        with Documentation{Description = "This field MUST be 0x01."};
    USHORT DataLength
        with Documentation{Description = "This field MUST match SMB_Parameters.CountOfBytesToWrite."};
    binary Data with BinaryEncoding{Length = DataLength},
        Documentation{Description = "The raw bytes to be written to the file."};
}

// 2.2.4.12   SMB_COM_WRITE (0x0B)
type SmbComWriteResponse
{
    UCHAR WordCount where value == 0x01
        with Documentation{Description = "This field MUST be 0x01."};
    USHORT CountOfBytesWritten
        with Documentation{Description = "Indicates the actual number of bytes written to the file. For successful writes, this MUST equal the CountOfBytesToWrite in the client Request. If the number of bytes written differs from the number requested and no error is indicated, then the server has no resources available to satisfy the complete write."};
    USHORT ByteCount where value == 0x0000
        with Documentation{Description = "This field MUST be 0x0000. No data is sent by this message."};
}

// 2.2.4.13   SMB_COM_LOCK_BYTE_RANGE (0x0C)
type SmbComLockByteRangeRequest
{
    UCHAR WordCount where value == 0x05
        with Documentation{Description = "This field MUST be 0x05."};
    USHORT Fid
        with Documentation{Description = "This field MUST be a valid 16-bit unsigned integer indicating the file from which the data MUST be read."};
    ULONG CountOfBytesToLock
        with Documentation{Description = "This field is a 32-bit unsigned integer indicating the number of contiguous bytes to be locked."};
    ULONG LockOffsetInBytes
        with Documentation{Description = "This field is a 32-bit unsigned integer indicating the offset, in number of bytes, from which to begin the lock. Because this field is limited to 32 bits,  this command is inappropriate for files that have 64-bit offsets."};
    USHORT ByteCount where value == 0x0000
        with Documentation{Description = "This field MUST be 0x0000. No data is sent by this message."};
}

// 2.2.4.13   SMB_COM_LOCK_BYTE_RANGE (0x0C)
type SmbComLockByteRangeResponse
{
    UCHAR WordCount where value == 0x00
        with Documentation{Description = "This field MUST be 0x00. No parameters are sent by this message."};
    USHORT ByteCount where value == 0x0000
        with Documentation{Description = "This field MUST be 0x0000. No data is sent by this message."};
}

// 2.2.4.14   SMB_COM_UNLOCK_BYTE_RANGE (0x0D)
type SmbComUnlockByteRangeRequest
{
    UCHAR WordCount where value == 0x05
        with Documentation{Description = "This field MUST be 0x05."};
    USHORT Fid
        with Documentation{Description = "This field MUST be a valid 16-bit signed integer indicating the file from which the data MUST be read."};
    ULONG CountOfBytesToUnlock
        with Documentation{Description = "This field is a 32-bit unsigned integer indicating the number of contiguous bytes to be unlocked."};
    ULONG UnlockOffsetInBytes
        with Documentation{Description = "This field is a 32-bit unsigned integer indicating the offset, in number of bytes, from which to begin the unlock. Because this field is limited to 32-bits, this command is inappropriate for files that have 64-bit offsets."};
    USHORT ByteCount where value == 0x0000
        with Documentation{Description = "This field MUST be 0x0000. No data is sent by this message."};
}

// 2.2.4.14   SMB_COM_UNLOCK_BYTE_RANGE (0x0D)
type SmbComUnlockByteRangeResponse
{
    UCHAR WordCount where value == 0x00
        with Documentation{Description = "This field MUST be 0x00. No parameters are sent by this message."};
    USHORT ByteCount where value == 0x0000
        with Documentation{Description = "This field MUST be 0x0000. No data is sent by this message."};
}

// 2.2.4.15   SMB_COM_CREATE_TEMPORARY (0x0E)
type SmbComCreateTemporaryRequest[bool IsFlags2Unicode]
{
    UCHAR WordCount where value == 0x03
        with Documentation{Description = "This field MUST be 0x03."};
    SmbFileAttributes FileAttributes
        with Documentation{Description = "This field SHOULD be ignored by the server."};
    Utime CreationTime
        with Documentation{Description = "The time that the file was created, represented as the number of seconds since Jan 1, 1970, 00:00:00.0."};
    USHORT ByteCount where value >= 0x0002
        with Documentation{Description = "This field MUST be greater than or equal to 0x0002."};
    DataBufferFormatCodes BufferFormat where value == 0x04
        with Documentation{Description = "This field MUST be 0x04."};
    SmbString[IsFlags2Unicode] DirectoryName
        with Documentation{Description = "A null-terminated string that represents the fully qualified name of the directory relative to the supplied TID in which to create the temporary file."};
}

// 2.2.4.15   SMB_COM_CREATE_TEMPORARY (0x0E)
type SmbComCreateTemporaryResponse[bool IsFlags2Unicode]
{
    UCHAR WordCount where value == 0x01
        with Documentation{Description = "This field MUST be 0x01."};
    USHORT Fid
        with Documentation{Description = "The FID representing the file on the server. This value MUST be supplied in the FID field of the SMB Header in subsequent requests that manipulate the file."};
    USHORT ByteCount where value >= 0x0002
        with Documentation{Description = "This field MUST be greater than or equal to 0x0002."};
    string TemporaryFileName
        with BinaryEncoding{TextEncoding = TextEncoding.ASCII}
        with Documentation{Description = "A null-terminated string that contains the temporary file name generated by the server.windows_nt server temporary file names begin with \"SRV\" and are followed by the character equivalents of five (5) random hexadecimal digits (0-F). There is no extension set for the file name. The client is responsible for deleting the temporary file when it is no longer needed. The string SHOULD be a null-terminated array of ASCII characters."};
}

// 2.2.4.16   SMB_COM_CREATE_NEW (0x0F)
type SmbComCreateNewRequest[bool IsFlags2Unicode]
{
    UCHAR WordCount where value == 0x03
        with Documentation{Description = "This field MUST be 0x03."};
    SmbFileAttributes FileAttributes
        with Documentation{Description = "A 16-bit field of 1-bit flags that represent the file attributes to assign to the file if it is created successfully."};
    Utime CreationTime
        with Documentation{Description = "The time that the file was created on the client, represented as the number of seconds since Jan 1, 1970, 00:00:00.0."};
    USHORT ByteCount where value >= 0x0002
        with Documentation{Description = "This field MUST be greater than or equal to 0x0002."};
    DataBufferFormatCodes BufferFormat where value == 0x04
        with Documentation{Description = "MUST be 0x04, the format code for an SMB_STRING."};
    SmbString[IsFlags2Unicode] FileName
        with Documentation{Description = "A null-terminated string that contains the fully qualified name of the file, relative to the supplied TID, to create on the server."};
}

// 2.2.4.16   SMB_COM_CREATE_NEW (0x0F)
type SmbComCreateNewResponse
{
    UCHAR WordCount where value == 0x01
        with Documentation{Description = "This field MUST be 0x01."};
    USHORT Fid
        with Documentation{Description = "The FID representing the file on the server. This value MUST be supplied in subsequent requests that manipulate the file."};
    USHORT ByteCount where value == 0x0000
        with Documentation{Description = "This field MUST be 0x0000. No data is sent by this message."};
}

// 2.2.4.17   SMB_COM_CHECK_DIRECTORY (0x10)
type SmbComCheckDirectoryRequest[bool IsFlags2Unicode]
{
    UCHAR WordCount where value == 0x00
        with Documentation{Description = "This field MUST be 0x00. No parameters are sent by this message."};
    USHORT ByteCount where value >= 0x0002
        with Documentation{Description = "This field MUST be greater than or equal to 0x0002."};
    DataBufferFormatCodes BufferFormat where value == 0x04
        with Documentation{Description = "This field MUST be 0x04. This is a buffer type indicator that identifies the next field as an SMB_STRING."};
    SmbString[IsFlags2Unicode] DirectoryName
        with Documentation{Description = "A null-terminated character string giving the pathname to be tested."};
}

// 2.2.4.17   SMB_COM_CHECK_DIRECTORY (0x10)
type SmbComCheckDirectoryResponse
{
    UCHAR WordCount where value == 0x00
        with Documentation{Description = "This field MUST be 0x00. No parameters are sent by this message."};
    USHORT ByteCount where value == 0x0000
        with Documentation{Description = "This field MUST be 0x0000. No data is sent by this message."};
}

// 2.2.4.18   SMB_COM_PROCESS_EXIT (0x11)
type SmbComProcessExitRequest
{
    UCHAR WordCount where value == 0x00
        with Documentation{Description = "MUST be 0x00. No parameters are sent."};
    USHORT ByteCount where value == 0x0000
        with Documentation{Description = "MUST be 0x0000. No data bytes are sent."};
}

// 2.2.4.18   SMB_COM_PROCESS_EXIT (0x11)
type SmbComProcessExitResponse
{
    UCHAR WordCount where value == 0x00
        with Documentation{Description = "MUST be 0x00. No parameters are returned."};
    USHORT ByteCount where value == 0x0000
        with Documentation{Description = "MUST be 0x0000. No data bytes are returned."};
}

// 2.2.4.19   SMB_COM_SEEK (0x12)
type SmbComSeekRequest
{
    UCHAR WordCount where value == 0x0004
        with Documentation{Description = "This field MUST be 0x0004."};
    USHORT Fid
        with Documentation{Description = "The File ID of the open file within which to seek."};
    SmbComSeekRequestRequestParametersWordsMode Mode
        with Documentation{Description = "The seek mode. Possible values are as follows."};
    LONG Offset
        with Documentation{Description = "A 32-bit signed long value indicating the file position, relative to the position indicated in Mode, to which to set the updated file pointer. The value of Offset ranges from -2 gigabytes to +2 gigabytes ((-2^31) to (2^31 -1) bytes).windows_nt server behavior is determined by the negotiated protocol dialect. Clients that negotiate Core Protocol can use a negative value in the Offset field to position the file pointer to the beginning of the file (BOF). Clients negotiating other protocol dialects receive an error if they supply a negative value in the Offset field."};
    USHORT ByteCount where value == 0x0000
        with Documentation{Description = "This field MUST be 0x0000. No data is sent by this message."};
}

pattern SmbComSeekRequestRequestParametersWordsMode = enum ushort
{
    FromStart = 0x0000
        with Documentation{Description = "Seek from the start of the file."},
    FromCurrent = 0x0001
        with Documentation{Description = "Seek from the current position."},
    FromEnd = 0x0002
        with Documentation{Description = "Seek from the end of the file."},
};

// 2.2.4.19   SMB_COM_SEEK (0x12)
type SmbComSeekResponse
{
    UCHAR WordCount where value == 0x0002
        with Documentation{Description = "This field MUST be 0x0002."};
    ULONG Offset
        with Documentation{Description = "A 32-bit unsigned value indicating the absolute file position relative to the start of the file at which the file pointer is currently set. The value of Offset ranges from 0 to 4 gigabytes (0 to 2^32 - 1 bytes)."};
    USHORT ByteCount where value == 0x0000
        with Documentation{Description = "This field MUST be 0x0000. No data is sent by this message."};
}

// 2.2.4.20   SMB_COM_LOCK_AND_READ (0x13)
type SmbComLockAndReadRequest
{
    UCHAR WordCount where value == 0x05
        with Documentation{Description = "This field MUST be 0x05."};
    USHORT Fid
        with Documentation{Description = "This field MUST be a valid 16-bit unsigned integer indicating the file from which the data MUST be read."};
    USHORT CountOfBytesToRead
        with Documentation{Description = "This field is a 16-bit unsigned integer indicating the number of bytes to be read from the file. The client MUST ensure that the amount of data requested will fit in the negotiated maximum buffer size."};
    ULONG ReadOffsetInBytes
        with Documentation{Description = "This field is a 32-bit unsigned integer indicating the offset in number of bytes from which to begin reading from the file. The client MUST ensure that the amount of data requested fits in the negotiated maximum buffer size. Because this field is limited to 32 bits, this command is inappropriate for files that have 64-bit offsets."};
    USHORT EstimateOfRemainingBytesToBeRead
        with Documentation{Description = "This field is a 16-bit unsigned integer indicating the remaining number of bytes that the client has designated to be read from the file. This is an advisory field and can be zero."};
    USHORT ByteCount where value == 0x0000
        with Documentation{Description = "This field MUST be 0x0000. No data is sent by this message."};
}

// 2.2.4.20   SMB_COM_LOCK_AND_READ (0x13)
type SmbComLockAndReadResponse
{
    UCHAR WordCount where value == 0x05
        with Documentation{Description = "This field MUST be 0x05."};
    USHORT CountOfBytesReturned
        with Documentation{Description = "The actual number of bytes returned to the client. This MUST be equal to CountOfBytesToRead unless the end of file was reached before reading CountOfBytesToRead bytes or the ReadOffsetInBytes pointed at or beyond the end of file."};
    binary Reserved where value == $[0000000000000000] with BinaryEncoding{Length = 8},
        Documentation{Description = "Reserved. All bytes MUST be 0x00."};
    USHORT ByteCount where value >= 0x03
        with Documentation{Description = "This field MUST be 0x0003 + CountOfBytesRead."};
    UCHAR BufferType where value == 0x01
        with Documentation{Description = "This field MUST be 0x01."};
    USHORT CountOfBytesRead
        with Documentation{Description = "The number of bytes read that are contained in the following array of bytes."};
    binary Bytes with BinaryEncoding{Length = CountOfBytesRead},
        Documentation{Description = "The array of bytes read from the file. The array is not null-terminated."};
}

// 2.2.4.21   SMB_COM_WRITE_AND_UNLOCK (0x14)
type SmbComWriteAndUnlockRequest
{
    UCHAR WordCount where value == 0x05
        with Documentation{Description = "This field MUST be 0x05."};
    USHORT Fid
        with Documentation{Description = "This field MUST be a valid 16-bit unsigned integer indicating the file to which the data MUST be written."};
    USHORT CountOfBytesToWrite
        with Documentation{Description = "This field is a 16-bit unsigned integer indicating the number of bytes to be written to the file. The client MUST ensure that the amount of data sent can fit in the negotiated maximum buffer size."};
    ULONG WriteOffsetInBytes
        with Documentation{Description = "This field is a 32-bit unsigned integer indicating the offset, in number of bytes, from the beginning of the file at which to begin writing to the file. The client MUST ensure that the amount of data sent can fit in the negotiated maximum buffer size. Because this field is limited to 32 bits, this command is inappropriate for files that have 64-bit offsets."};
    USHORT EstimateOfRemainingBytesToBeWritten
        with Documentation{Description = "This field is a 16-bit unsigned integer indicating the remaining number of bytes that the client designates to write to the file. This is an advisory field and MAY be zero. This information can be used by the server to optimize cache behavior."};
    USHORT ByteCount where value >= 0x0003
        with Documentation{Description = "This field MUST be greater than or equal to 0x0003. The total value represents the size of the BufferFormat field in bytes plus the size of the DataLength field in bytes plus the value of the CountOfBytesToWrite field. See Data Buffer Format Codes for a complete description of data buffer format codes and their usages."};
    DataBufferFormatCodes BufferFormat where value == 0x01
        with Documentation{Description = "This field MUST be 0x01."};
    USHORT DataLength
        with Documentation{Description = "This field MUST be CountOfBytesToWrite."};
    binary Data with BinaryEncoding{Length = DataLength},
        Documentation{Description = "The raw bytes to be written to the file."};
}

// 2.2.4.21   SMB_COM_WRITE_AND_UNLOCK (0x14)
type SmbComWriteAndUnlockResponse
{
    UCHAR WordCount where value == 0x01
        with Documentation{Description = "This field MUST be 0x01."};
    USHORT CountOfBytesWritten
        with Documentation{Description = "Indicates the actual number of bytes written to the file. For successful writes, this MUST equal the CountOfBytesToWrite in the client Request. If the number of bytes written differs from the number requested and no error is indicated, then the server has no resources available to satisfy the complete write."};
    USHORT ByteCount where value == 0x0000
        with Documentation{Description = "This field MUST be 0x0000. No data is sent by this message."};
}

// 2.2.4.22   SMB_COM_READ_RAW (0x1A)
type SmbComReadRawRequest
{
    UCHAR WordCount where (value == 0x08 || value == 0x0A)
        with Documentation{Description = "This field MUST be either 0x08 or 0x0A."};
    USHORT Fid
        with Documentation{Description = "This field MUST be a valid 16-bit signed integer indicating the file from which the data MUST be read."};
    ULONG Offset
        with Documentation{Description = "The offset, in bytes, from the start of the file at which the read MUST begin. This is the lower 32 bits of a 64-bit value if the WordCount is 0x0A."};
    USHORT MaxCountOfBytesToReturn
        with Documentation{Description = "The requested maximum number of bytes to read from the file and return to the client. The value MAY exceed the negotiated buffer size."};
    USHORT MinCountOfBytesToReturn
        with Documentation{Description = "The requested minimum number of bytes to read from the file and return to the client. This field is used only when reading from a named pipe or a device. It is ignored when reading from a standard file."};
    ULONG Timeout
        with Documentation{Description = "The number of milliseconds that the server is requested to wait while processing this command. This field is optionally honored only when reading from a named pipe or I/O device. It does not apply when reading from a regular file."};
    USHORT Reserved
        with Documentation{Description = "This field SHOULD be set to 0x0000."};
    optional [|WordCount == 0x0A|] ULONG OffsetHigh
        with Documentation{Description = "This field is optional, and is included only when WordCount is 0x0A. This field is the upper 32 bits of the offset, in bytes, from the start of the file at which the read MUST start. This field allows the client request to specify 64-bit file offsets."};
    USHORT ByteCount where value == 0x0000
        with Documentation{Description = "The length in bytes of the remaining SMB_Data. This field MUST be 0x0000."};
}

// 2.2.4.22   SMB_COM_READ_RAW (0x1A)
type SmbComReadRawResponse
{
    UCHAR WordCount
        with Documentation{Description = "This field MUST be 0x0002."};
    ULONG Offset
        with Documentation{Description = "A 32-bit unsigned value indicating the absolute file position relative to the start of the file at which the file pointer is currently set. The value of Offset ranges from 0 to 4 gigabytes (0 to 2^32 - 1 bytes)."};
    USHORT ByteCount
        with Documentation{Description = "This field MUST be 0x0000. No data is sent by this message."};
}

// 2.2.4.23   SMB_COM_READ_MPX (0x1B)
type SmbComReadMpxRequest
{
    UCHAR WordCount where value == 0x08
        with Documentation{Description = "This field MUST be 0x08. The length, in two-byte words, of the remaining SMB_Parameters."};
    USHORT Fid
        with Documentation{Description = "This field MUST be a valid 16-bit unsigned integer indicating the file from which the data MUST be read."};
    ULONG Offset
        with Documentation{Description = "The offset, in bytes, from the start of the file at which the read begins."};
    USHORT MaxCountOfBytesToReturn
        with Documentation{Description = "The requested maximum number of bytes to read from the file and return to the client. The value MAY exceed the negotiated buffer size."};
    USHORT MinCountOfBytesToReturn
        with Documentation{Description = "The requested minimum number of bytes to read from the file and return to the client. This field is used only when reading from a named pipe or a device. It MUST be ignored when reading from a standard file."};
    ULONG Timeout
        with Documentation{Description = "The number of milliseconds that the server is requested to wait while processing this command. This field is optionally honored only when reading from a named pipe or I/O device. It does not apply when reading from a regular file."};
    USHORT Reserved
        with Documentation{Description = "This field SHOULD be set to 0x0000."};
    USHORT ByteCount where value == 0x0000
        with Documentation{Description = "This field MUST be 0x0000. No data is sent by this message."};
}
//2.2.4.24   SMB_COM_READ_MPX_SECONDARY (0x1C)
// Obsolated

// 2.2.4.23   SMB_COM_READ_MPX (0x1B)
type SmbComReadMpxResponse
{
    UCHAR WordCount where value == 0x08
        with Documentation{Description = "This field MUST be 0x08. The length, in two-byte words, of the remaining SMB_Parameters."};
    ULONG Offset
        with Documentation{Description = "The offset, in bytes, from the start of the file at which the read occurred."};
    USHORT Count
        with Documentation{Description = "The total number of bytes designated to be returned in all responses to this request. This value usually starts at MaxCountOfBytesToReturn, but can be an overestimate. The overestimate can be reduced while the read is in progress. The last response generated by the server MUST contain the actual total number of bytes read and sent to the client in all of the responses. If the value in the last response is less than MaxCountOfBytesToReturn, the end of file was encountered during the read. If this value is exactly zero (0x0000), the original Offset into the file began at or after the end of file; in this case, only one response MUST be generated. The value of the field can (and usually does) exceed the negotiated buffer size."};
    USHORT Remaining
        with Documentation{Description = "This integer MUST be -1 for regular files. For I/O devices or named pipes, this indicates the number of bytes remaining to be read from the file after the bytes returned in the response were de-queued. Servers SHOULD return 0xFFFF if they do not support this function on I/O devices or named pipes."};
    USHORT DataCompactionMode where value == 0x0000
        with Documentation{Description = "Not used and MUST be 0x0000."};
    USHORT Reserved where value == 0x0000
        with Documentation{Description = "This field MUST be set to 0x0000."};
    USHORT DataLength
        with Documentation{Description = "This field is the number of bytes read and included in the response. The value of this field MUST NOT cause the message to exceed the client\'s maximum buffer size as specified in MaxBufferSize of the SMB_COM_SESSION_SETUP_AND_X client request."};
    USHORT DataOffset
        with Documentation{Description = "The offset, in bytes, from the beginning of the SMB Header to the start of the Buffer field in the SMB_Data.block."};
    USHORT ByteCount
        with Documentation{Description = "The length, in bytes, of the remaining SMB_Data. The length MUST be between DataLength and DataLength + 0x0003."};
    optional [|DataOffset > 51|] binary Pad with BinaryEncoding{Length = (DataOffset - 51)}, // Header 32 bytes, fields 19 bytes.
        Documentation{Description = "Padding bytes to align data on a proper address boundary. The DataOffset field points to the first byte after this field."};
    binary Buffer with BinaryEncoding{Length = DataLength}, 
        Documentation{Description = "The bytes read from the file."};
}

// 2.2.4.25   SMB_COM_WRITE_RAW (0x1D)
type SmbComWriteRawRequest
{
    UCHAR WordCount where (value == 0x0C || value == 0x0E)
        with Documentation{Description = "This field MUST be 0x0C or 0x0E"};
    USHORT Fid
        with Documentation{Description = "This field MUST be a valid 16-bit unsigned integer indicating the file, named pipe, or device to which the data MUST be written."};
    USHORT CountOfBytes
        with Documentation{Description = "The total number of bytes to be written to the file during the entire dialog. The value MAY exceed the maximum buffer size (MaxBufferSize) established for the session."};
    USHORT Reserved1
        with Documentation{Description = "This field is reserved and MUST be ignored by the server."};
    ULONG Offset
        with Documentation{Description = "The offset, in bytes, from the start of the file at which the write SHOULD begin. If WordCount is 0x0E, this is the lower 32 bits of a 64-bit value."};
    ULONG Timeout
        with Documentation{Description = "This field is the time-out, in milliseconds, to wait for the write to complete. This field is optionally honored only when writing to a named pipe or I/O device. It does not apply and MUST be 0x00000000 when writing to a regular file."};
    SmbComWriteRawRequestParametersWordsWriteMode WriteMode
        with Documentation{Description = "A 16-bit field containing flags defined as follows. The flag names below are provided for reference only."};
    ULONG Reserved2 where value == 0x00000000
        with Documentation{Description = "This field MUST be 0x00000000."};
    USHORT DataLength
        with Documentation{Description = "This field is the number of bytes included in the SMB_Data block that are to be written to the file."};
    USHORT DataOffset
        with Documentation{Description = "This field is the offset, in bytes, from the start of the SMB Header to the start of the data to be written to the file from the Data[] field. Specifying this offset allows the client to efficiently align the data buffer."};
    optional [|WordCount == 0x0E|] ULONG OffsetHigh
        with Documentation{Description = "If WordCount is 0x0E, this is the upper 32 bits of the 64-bit offset in bytes from the start of the file at which the write MUST start. Support of this field is optional."};
    USHORT ByteCount where value >= 0x0000
        with Documentation{Description = "This field MUST be greater than or equal to 0x0000."};
    optional ([|(WordCount == 0x0E ? (DataOffset > 63) : (DataOffset > 59))|] optional binary) Pad with BinaryEncoding{Length = (WordCount == 0x0E ? (DataOffset - 32 -31) : (DataOffset - 32 -27))},
        Documentation{Description = "Padding bytes for the client to align the data on an appropriate boundary for transfer of the SMB transport. The server MUST ignore these bytes."};
    binary Data with BinaryEncoding{Length = DataLength}, 
        Documentation{Description = "The bytes to be written to the file."};
}

pattern SmbComWriteRawRequestParametersWordsWriteMode = flags USHORT
{
    WritethroughMode   = 0x0001
        with Documentation{Description = "If set, the server MUST NOT respond to the client before the data is written to disk (write-through)."},
    ReadBytesAvailable = 0x0002
        with Documentation{Description = "If set, the server SHOULD set the Interim Response Response.SMB_Parameters.Available field correctly for writes to named pipes or I/O devices."},
    NamedPipeRaw       = 0x0004
        with Documentation{Description = "Applicable to named pipes only. If set, the named pipe MUST be written to in raw mode (no translation; the opposite of message mode)."},
    NamedPipeStart     = 0x0008
        with Documentation{Description = "Applicable to named pipes only. If set, this data is the start of a message."},
    Reserved           = 0xFFF0,
};

// 2.2.4.25   SMB_COM_WRITE_RAW (0x1D)
type SmbComWriteRawResponse
{
    UCHAR WordCount where value == 0x01
        with Documentation{Description = "This field MUST be 0x01."};
    USHORT AvailableOrCount
        with Documentation{Description = "This field is valid when writing to named pipe or I/O devices. This field indicates the number of bytes remaining to be written after the requested write was completed. If the client writes to a disk file, this field MUST be set to 0xFFFF.windows_nt servers always set Available to 0xFFFF."};
    USHORT ByteCount where value == 0x0000
        with Documentation{Description = "This field MUST be 0x0000. No data is sent by this message."};
}

// 2.2.4.26   SMB_COM_WRITE_MPX (0x1E)
type SmbComWriteMpxRequest
{
    UCHAR WordCount where value == 0x0C
        with Documentation{Description = "This field MUST be 0x0C. The length, in two-byte words, of the remaining SMB_Parameters."};
    USHORT Fid
        with Documentation{Description = "This field MUST be a valid 16-bit unsigned integer indicating the file to which the data should be written."};
    USHORT TotalByteCount
        with Documentation{Description = "The requested total number of bytes to write to the file. The value MAY exceed the negotiated buffer size."};
    USHORT Reserved
        with Documentation{Description = "The server MUST ignore this value."};
    ULONG ByteOffsetToBeginWrite
        with Documentation{Description = "The offset, in bytes, from the start of the file at which the write should begin. This value indicates the offset at which to write the data contained in the SMB_Data.Bytes.Buffer field of the same message."};
    ULONG Timeout
        with Documentation{Description = "This field MUST be ignored by the server.The Timeout field was used in earlier dialects. In the NT LAN Manager dialect, Write MPX is not used to write to named pipes or devices, so the Timeout field is ignored."};
    SmbComWriteMpxRequestParametersWordsWriteMode WriteMode
        with Documentation{Description = "A 16-bit field containing flags defined as follows."};
    ULONG RequestMask
        with Documentation{Description = "This field is a bit mask indicating this SMB request\'s identity to the server. The server\'s response MUST contain the logical OR of all of the RequestMask values received. This response MUST be generated."};
    USHORT DataLength
        with Documentation{Description = "This field value is the number of data bytes included in this request."};
    USHORT DataOffset
        with Documentation{Description = "This field value is the offset, in bytes, from the start of the SMB Header to the start of the data buffer."};
    USHORT ByteCount where value >= 0x0001
        with Documentation{Description = "This field MUST be greater than or equal to 0x0001."};
    optional [|DataOffset > 59|] binary Pad with BinaryEncoding{Length = (DataOffset - 59)}, 
        Documentation{Description = "Null padding bytes to align Buffer to a 16- or 32-bit boundary."};
    binary Buffer with BinaryEncoding{Length = DataLength},
        Documentation{Description = "The raw data, in bytes, that is to be written to the file."};
}

pattern SmbComWriteMpxRequestParametersWordsWriteMode = flags USHORT
{
    WritethroughMode   = 0x0001
        with Documentation{Description = "If set, the server MUST NOT respond to the client before the data is written to disk."},
    Reserved1          = 0x007E,
    ConnectionlessMode = 0x0080
        with Documentation{Description = "If set, this flag indicates that messages are being sent over a connectionless transport. This flag MUST be set."},
    Reserved2          = 0xFF00
};

type SmbComWriteMpxResponse
{
    UCHAR WordCount where value == 0x02
        with Documentation{Description = "This field MUST be 0x02."};
    ULONG ResponseMask
        with Documentation{Description = "This field is the logical OR-ing of the RequestMask value contained in each SMB_COM_WRITE_MPX received since the last sequenced SMB_COM_WRITE_MPX. The server responds only to the final (sequenced) command. This response contains the accumulated ResponseMask from all successfully received requests. The client uses the ResponseMask received to determine which packets, if any, MUST be retransmitted."};
    USHORT ByteCount where value == 0x0000
        with Documentation{Description = "This field MUST be 0x0000. No data is sent by this message."};
}

// 2.2.4.27 - 2.2.4.29
// Messages obsolated.

// 2.2.4.30   SMB_COM_SET_INFORMATION2 (0x22)
type SmbComSetInformation2Request
{
    UCHAR WordCount where value == 0x07
        with Documentation{Description = "This field MUST be 0x07."};
    USHORT Fid
        with Documentation{Description = "This is the FID representing the file for which attributes are to be set."};
    SmbDate CreateDate
        with Documentation{Description = "This is the date when the file was created."};
    SmbTime CreateTime
        with Documentation{Description = "This is the time on CreateDate when the file was created."};
    SmbDate LastAccessDate
        with Documentation{Description = "This is the date when the file was last accessed."};
    SmbTime LastAccessTime
        with Documentation{Description = "This is the time on LastAccessDate when the file was last accessed."};
    SmbDate LastWriteDate
        with Documentation{Description = "This is the date when data was last written to the file."};
    SmbTime LastWriteTime
        with Documentation{Description = "This is the time on LastWriteDate when data was last written to the file."};
    USHORT ByteCount where value == 0x0000
        with Documentation{Description = "This field MUST be 0x0000. No data is sent by this message."};
}

// 2.2.4.30   SMB_COM_SET_INFORMATION2 (0x22)
type SmbComSetInformation2Response
{
    UCHAR WordCount where value == 0x00
        with Documentation{Description = "This field MUST be 0x00. No parameters are sent by this message."};
    USHORT ByteCount where value == 0x0000
        with Documentation{Description = "This field MUST be 0x0000. No data is sent by this message."};
}

// 2.2.4.31   SMB_COM_QUERY_INFORMATION2 (0x23)
type SmbComQueryInformation2Request
{
    UCHAR WordCount where value == 0x01
        with Documentation{Description = "This field MUST be 0x01."};
    USHORT Fid
        with Documentation{Description = "This field MUST be a valid FID that the client has obtained through a previous SMB command that successfully opened the file."};
    USHORT ByteCount where value == 0x0000
        with Documentation{Description = "This field MUST be 0x0000. No data is sent by this message."};
}

// 2.2.4.31   SMB_COM_QUERY_INFORMATION2 (0x23)
type SmbComQueryInformation2Response
{
    UCHAR WordCount where value == 0x0B
        with Documentation{Description = "This field MUST be 0x0B."};
    SmbDate CreateDate
        with Documentation{Description = "This field is the date when the file was created."};
    SmbTime CreateTime
        with Documentation{Description = "This field is the time on CreateDate when the file was created."};
    SmbDate LastAccessDate
        with Documentation{Description = "This field is the date when the file was last accessed."};
    SmbTime LastAccessTime
        with Documentation{Description = "This field is the time on LastAccessDate when the file was last accessed."};
    SmbDate LastWriteDate
        with Documentation{Description = "This field is the date when data was last written to the file."};
    SmbTime LastWriteTime
        with Documentation{Description = "This field is the time on LastWriteDate when data was last written to the file."};
    ULONG FileDataSize
        with Documentation{Description = "This field contains the number of bytes in the file, in bytes. Because this size is limited to 32 bits, this command is inappropriate for files whose size is too large."};
    ULONG FileAllocationSize
        with Documentation{Description = "This field contains the allocation size of the file, in bytes. Because this size is limited to 32 bits, this command is inappropriate for files whose size is too large."};
    SmbFileAttributes FileAttributes
        with Documentation{Description = "This field is a 16-bit unsigned bit field encoding the attributes of the file."};
    USHORT ByteCount where value == 0x0000
        with Documentation{Description = "This field MUST be 0x0000. No data is sent by this message."};
}

// 2.2.4.32   SMB_COM_LOCKING_ANDX (0x24)
type SmbComLockingAndxRequest
{
    UCHAR WordCount where value == 0x08
        with Documentation{Description = "This field MUST be 0x08."};
    UCHAR AndXCommand
        with Documentation{Description = "The command code for the next SMB command in the packet. This value MUST be set to 0xFF if there are no additional SMB commands in the client request packet."};
    UCHAR AndXReserved
        with Documentation{Description = "A reserved field. This MUST be set to 0x00 when this request is sent, and the server MUST ignore this value when the message is received."};
    USHORT AndXOffset
        with Documentation{Description = "This field MUST be set to the offset, in bytes, from the start of the SMB_Header to the start of the WordCount field in the next SMB command in this packet. This field is valid only if the AndXCommand field is not set to 0xFF. If AndXCommand is 0xFF, this field MUST be ignored by the server."};
    USHORT Fid
        with Documentation{Description = "This field MUST be a valid 16-bit unsigned integer indicating the file from which the data SHOULD be read."};
    SmbComLockingAndxRequestParametersWordsTypeOfLock TypeOfLock
        with DisplayInfo{ToText = TypeOfLockToString},
        Documentation{Description = "This field is an 8-bit unsigned integer bit mask indicating the nature of the lock request and the format of the LOCKING_ANDX_RANGE data. If the negotiated protocol is NT LAN Manager or later and CAP_LARGE_FILES was negotiated, then the Locks and Unlocks arrays are in the large file 64-bit offset LOCKING_ANDX_RANGE format. This allows specification of 64-bit offsets for very large files."};
    LockingAndxRequestNewOplockLevel NewOpLockLevel
        where ValidationCheck(InRange<LockingAndxRequestNewOplockLevel>(value), null, DiagnosisLevel.Error,
                () => Format(INFRASTRUCTURE_STR_CHECK_ENUM_VALUE, ["SMB", "NewOpLockLevel", INFRASTRUCTURE_STR_TYPE, "SmbComLockingAndxRequest", INFRASTRUCTURE_STR_MUST, "0x00, 0x01", DecToHexFormat(value)]))
        with Documentation{Description = "This field is valid only in SMB_COM_LOCKING_ANDX (0x24) SMB requests sent from the server to the client in response to a change in an existing OpLock\'s state. This field is an 8-bit unsigned integer indicating the OpLock level now in effect for the FID in the request. If NewOpLockLevel is 0x00, the client possesses no OpLocks on the file at all. If NewOpLockLevel is 0x01, then the client possesses a Level II OpLock."};
    ULONG Timeout
        with Documentation{Description = "This field is a 32-bit unsigned integer value. Timeout is the maximum amount of time to wait, in milliseconds, for the byte range(s) specified in Locks to become locked. A Timeout value of 0x00000000 indicates that the server fails immediately if any lock range specified is already locked and cannot be locked by this request. A Timeout value of -1 (0xFFFFFFFF) indicates that the server waits as long as it takes (wait forever) for each byte range specified to become unlocked so that it can be locked by this request. Any other value of Timeout specifies the maximum number of milliseconds to wait for all lock ranges specified in Locks to become available and to be locked by this request."};
    USHORT NumberOfRequestedUnlocks
        with Documentation{Description = "This field is a 16-bit unsigned integer value containing the number of entries in the Unlocks array."};
    USHORT NumberOfRequestedLocks
        with Documentation{Description = "This field is a 16-bit unsigned integer value containing the number of entries in the Locks array."};
    USHORT ByteCount
        with Documentation{Description = "This field MUST be greater than or equal to 0x0000."};
    optional [|NumberOfRequestedUnlocks > 0|] ([|(TypeOfLock & 0x10) == 0x00|] array<LockingAndxRange32> | [|(TypeOfLock & 0x10) == 0x10|] array<LockingAndxRange64>) Unlocks with BinaryEncoding{Length = NumberOfRequestedUnlocks},
        Documentation{Description = "An array of byte ranges to be unlocked. If 32-bit offsets are being used, this field uses LOCKING_ANDX_RANGE32 (see below) and is (10 * NumberOfRequestedUnlocks) bytes in length. If 64-bit offsets are being used, this field uses LOCKING_ANDX_RANGE64 (see below) and is (20 * NumberOfRequestedUnlocks) bytes in length."};
    optional [|NumberOfRequestedLocks > 0|] ([|(TypeOfLock & 0x10) == 0x00|] array<LockingAndxRange32> | [|(TypeOfLock & 0x10) == 0x10|] array<LockingAndxRange64>) Locks with BinaryEncoding{Length = NumberOfRequestedLocks},
        Documentation{Description = "An array of byte ranges to be locked. If 32-bit offsets are being used, this field uses LOCKING_ANDX_RANGE32 (see following) and is (10 * NumberOfRequestedLocks) bytes in length. If 64-bit offsets are being used, this field uses LOCKING_ANDX_RANGE64 (see following) and is (20 * NumberOfRequestedLocks) bytes in length."};
    optional binary AndXPadding with Encoding{Ignore = true};
}

pattern LockingAndxRequestNewOplockLevel = enum byte
{
    NoOpLock = 0,
    LevelIIOplock = 1,
    ...
};

type LockingAndxRange32
{
    USHORT Pid
        with Documentation{Description = "The PID of the process requesting the locking change."};
    ULONG ByteOffset
        with Documentation{Description = "The 32-bit unsigned integer value that is the offset into the file at which the locking change MUST begin."};
    ULONG LengthInBytes
        with Documentation{Description = "The 32-bit unsigned integer value that is the number of bytes, beginning at OffsetInBytes, that MUST be locked or unlocked."};
}

type LockingAndxRange64
{
    USHORT Pid
        with Documentation{Description = "The PID of the process requesting the locking change."};
    USHORT Pad where ValidationCheckZero(value == 0, null, true, ReferenceType.Type, "SMB", "Pad", "LockingAndxRange64", value)
        with Documentation{Description = "This field pads the structure to DWORD alignment and MUST be zero (0x0000)."};
    ULONG ByteOffsetHigh
        with Documentation{Description = "The 32-bit unsigned integer value that is the high 32 bits of a 64-bit offset into the file at which the locking change MUST begin."};
    ULONG ByteOffsetLow
        with Documentation{Description = "The 32-bit unsigned integer value that is the low 32 bits of a 64-bit offset into the file at which the locking change MUST begin."};
    ULONG LengthInBytesHigh
        with Documentation{Description = "The 32-bit unsigned integer value that is the high 32 bits of a 64-bit value specifying the number of bytes that MUST be locked or unlocked."};
    ULONG LengthInBytesLow
        with Documentation{Description = "The 32-bit unsigned integer value that is the low 32 bits of a 64-bit value specifying the number of bytes that MUST be locked or unlocked."};
}

pattern SmbComLockingAndxRequestParametersWordsTypeOfLock = flags byte
{
    SharedLock     = 0x01
        with Documentation{Description = "Request for a shared read-only lock."},
    OplockRelease  = 0x02
        with Documentation{Description = "When sent from the server to the client in an OpLock Break Notification, this bit indicates to the client that an OpLock change has occurred on the FID supplied in the request. The client MUST set this bit when sending the OpLock Break Request message acknowledging the OpLock Break."},
    ChangeLocktype = 0x04
        with Documentation{Description = "Request to atomically change the lock type from a shared lock to an exclusive lock or vice versa for the specified Locks.windows_nt_server does not support the CHANGE_LOCKTYPE flag of TypeOfLock. A client requesting that the server atomically change the lock type from a shared lock to an exclusive lock or vice versa results in an error being returned to the client."},
    CancelLock     = 0x08
        with Documentation{Description = "Request to cancel all outstanding lock requests for the specified FID and PID.If the CANCEL_LOCK bit is set, windows_nt servers cancel only the first lock request range listed in the lock array."},
    LargeFiles     = 0x10
        with Documentation{Description = "Indicates that the LOCKING_ANDX_RANGE format is the 64-bit file offset version. If this flag is not set, then the LOCKING_ANDX_RANGE format is the 32-bit file offset version."},
    Reserved       = 0xE0,
};
        
// 2.2.4.32   SMB_COM_LOCKING_ANDX (0x24)
type SmbComLockingAndxResponse
{
    UCHAR WordCount where value == 0x02
        with Documentation{Description = "This field MUST be 0x02."};
    UCHAR AndXCommand
        with Documentation{Description = "The command code for the next SMB command in the packet. This value MUST be set to 0xFF if there are no additional SMB command responses in the server response packet."};
    UCHAR AndXReserved
        with Documentation{Description = "A reserved field. This MUST be set to 0x00 when this response is sent, and the client MUST ignore this field."};
    USHORT AndXOffset
        with Documentation{Description = "This field MUST be set to the offset, in bytes, from the start of the SMB Header to the start of the WordCount field in the next SMB command response in this packet. This field is valid only if the AndXCommand field is not set to 0xFF. If AndXCommand is 0xFF, this field MUST be ignored by the client."};
    USHORT ByteCount where value == 0x0000
        with Documentation{Description = "This field MUST be 0x0000. No data is sent by this message."};
    optional binary AndXPadding with Encoding{Ignore = true};
}

// 2.2.4.33   SMB_COM_TRANSACTION (0x25)
type SmbComTransactionRequest[bool IsFlags2Unicode]
{
    UCHAR WordCount
        with Documentation{Description = "This field MUST be Words.SetupCount (see below) plus 14 (0x0E). This value represents the total number of parameter words and MUST be greater than or equal to 14 (0x0E)."};
    USHORT TotalParameterCount
        with Documentation{Description = "The total number of transaction parameter bytes the client expects to send to the server for this request. Parameter bytes for a transaction are carried within the SMB_Data.Trans_Parameters field of the SMB_COM_TRANSACTION request. If the size of all of the required SMB_Data.Trans_Parameters for a given transaction causes the request to exceed the MaxBufferSize established during session setup, then the client MUST NOT send all of the parameters in one request. The client MUST break up the parameters and send additional requests using the SMB_COM_TRANSACTION_SECONDARY command to send the additional parameters. Any single request MUST NOT exceed the MaxBufferSize established during session setup. The client indicates to the server to expect additional parameters, and thus at least one SMB_COM_TRANSACTION_SECONDARY, by setting ParameterCount (see following) to be less than TotalParameterCount. See SMB_COM_TRANSACTION_SECONDARY for more information."};
    USHORT TotalDataCount
        with Documentation{Description = "The total number of transaction data bytes that the client attempts to send to the server for this request. Data bytes of a transaction are carried within the SMB_Data.Trans_Data field of the SMB_COM_TRANSACTION request. If the size of all of the required SMB_Data.Trans_Data for a given transaction causes the request to exceed the MaxBufferSize established during session setup, then the client MUST NOT send all of the data in one request. The client MUST break up the data and send additional requests using the SMB_COM_TRANSACTION_SECONDARY command to send the additional data. Any single request MUST NOT exceed the MaxBufferSize established during session setup. The client indicates to the server to expect additional data, and thus at least one SMB_COM_TRANSACTION_SECONDARY, by setting DataCount (see following) to be less than TotalDataCount. See SMB_COM_TRANSACTION_SECONDARY for more information."};
    USHORT MaxParameterCount
        with Documentation{Description = "The maximum number of SMB_Data.Trans_Parameters bytes that the client accepts in the transaction response. The server MUST NOT return more than this number of bytes in the SMB_Data.Trans_Parameters field of the response."};
    USHORT MaxDataCount
        with Documentation{Description = "The maximum number of SMB_Data.Trans_Data bytes that the client accepts in the transaction response. The server MUST NOT return more than this number of bytes in the SMB_Data.Trans_Data field."};
    UCHAR MaxSetupCount
        with Documentation{Description = "The maximum number of bytes that the client accepts in the Setup field of the transaction response. The server MUST NOT return more than this number of bytes in the Setup field."};
    UCHAR Reserved1 where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB", "Reserved1", "SmbComTransactionRequest", value)
        with Documentation{Description = "A padding byte. This field MUST be 0x00. Existing CIFS implementations MAY combine this field with MaxSetupCount to form a USHORT. If MaxSetupCount is defined as a USHORT, the high order byte MUST be 0x00."};
    SmbComTransactionRequestParametersWordsFlags Flags
        with Documentation{Description = "A set of bit flags that alter the behavior of the requested operation. Unused bit fields MUST be set to zero by the client sending the request, and MUST be ignored by the server receiving the request. The client can set either or both of the following bit flags."};
    ULONG Timeout
        with Documentation{Description = "The value of this field MUST be the maximum number of milliseconds that the server SHOULD wait for completion of the transaction before generating a time-out and returning a response to the client. The client SHOULD set this field to 0x00000000 to indicate that no time-out is expected. A value of 0x00000000 indicates that the server returns an error if the resource is not immediately available. If the operation does not complete within the specified time, the server MAY abort the request and send a failure response.windows_nt_server honors the Timeout field only in transaction subcommands that specifically state that the Timeout field is honored. Check the individual subcommands for details."};
    USHORT Reserved2 where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB", "Reserved2", "SmbComTransactionRequest", value)
        with Documentation{Description = "Reserved. This field MUST be 0x0000 in the client request. The server MUST ignore the contents of this field."};
    USHORT ParameterCount
        with Documentation{Description = "The number of transaction parameter bytes that the client attempts to send to the server in this request. Parameter bytes for a transaction are carried within the SMB_Data.Trans_Parameters field of the SMB_COM_TRANSACTION request. If the transaction request fits within a single SMB_COM_TRANSACTION request (the request size does not exceed MaxBufferSize), then this value SHOULD be equal to TotalParameterCount. Otherwise, the sum of the ParameterCount values in the primary and secondary transaction request messages MUST be equal to the smallest TotalParameterCount value reported to the server. If the value of this field is less than the value of TotalParameterCount, then at least one SMB_COM_TRANSACTION_SECONDARY message MUST be used to transfer the remaining transaction SMB_Data.Trans_Parameters bytes. The ParameterCount field MUST be used to determine the number of transaction SMB_Data.Trans_Parameters bytes that are contained within the SMB_COM_TRANSACTION message."};
    USHORT ParameterOffset
        with Documentation{Description = "This field MUST contain the number of bytes from the start of the SMB Header to the start of the SMB_Data.Trans_Parameters field. Server implementations MUST use this value to locate the transaction parameter block within the request. If ParameterCount is zero, the client/server MAY set this field to zero.windows always sets ParameterOffset to an offset location, relative to the start of the SMB Header, where the Trans  Parameters field should be. This behavior follows even if ParameterCount is zero."};
    USHORT DataCount
        with Documentation{Description = "The number of transaction data bytes that the client sends to the server in this request. Data bytes for a transaction are carried within the SMB_Data.Trans_Data field of the SMB_COM_TRANSACTION request. If the transaction request fits within a single SMB_COM_TRANSACTION request (the request size does not exceed MaxBufferSize), then this value SHOULD be equal to TotalDataCount. Otherwise, the sum of the DataCount values in the primary and secondary transaction request messages MUST be equal to the smallest TotalDataCount value reported to the server. If the value of this field is less than the value of TotalDataCount, then at least one SMB_COM_TRANSACTION_SECONDARY message MUST be used to transfer the remaining transaction SMB_Data.Trans_Data bytes. The DataCount field MUST be used to determine the number of transaction SMB_Data.Trans_Data bytes contained within the SMB_COM_TRANSACTION message."};
    USHORT DataOffset
        with Documentation{Description = "This field MUST be the number of bytes from the start of the SMB Header of the request to the start of the SMB_Data.Trans_Data field. Server implementations MUST use this value to locate the transaction data block within the request. If DataCount is zero, the client/server MAYwindows always sets DataCount to a value of ParameterCount + ParameterOffset. This restricts the Trans_Data field to follow after the Trans_Parameters field, although this is not strictly a protocol requirement. set this field to zero."};
    UCHAR SetupCount
        with Documentation{Description = "This field MUST be the number of setup words that are included in the transaction request."};
    UCHAR Reserved3 where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB", "Reserved3", "SmbComTransactionRequest", value)
        with Documentation{Description = "A padding byte. This field MUST be 0x00. Existing CIFS implementations MAY combine this field with SetupCount to form a USHORT. If SetupCount is defined as a USHORT, the high order byte MUST be 0x00."};
    optional [|SetupCount > 0|] SMBComTransactionSubCommand Subcommand
        where ValidationCheck(InRange<SMBComTransactionSubCommand>(value == nothing ? 0x0001 : value as SMBComTransactionSubCommand), null, DiagnosisLevel.Error, "SMB: The Subcommand field in type SmbComTransactionRequest is an undefined value. Please refer to SMB_COM_TRANSACTION (0x25) in Technical Document [MS-CIFS].")
        with Documentation{Description = "This field MUST be set to the transaction subcommand value"};
    optional [|SetupCount > 1 && (Subcommand as USHORT) in {0x01, 0x11, 0x21, 0x22, 0x23, 0x26, 0x31, 0x36, 0x37}|] USHORT Fid
        with Documentation{Description = "This field MUST be set to a valid FID from a server response for a previous SMB command to open or create a named pipe."};
    optional [|SetupCount > 1 && (Subcommand as USHORT) in {0x53, 0x54}|] USHORT Priority;
    optional [|SetupCount > 2|] array<USHORT> Setup with BinaryEncoding{Length = (SetupCount - 2)};
    USHORT ByteCount
        with Documentation{Description = "The number of bytes in the Bytes array that follows."};
    optional [|ByteCount > 0 && IsFlags2Unicode|] UCHAR Pad;
    optional [|ByteCount > 0|] SmbString[IsFlags2Unicode] Name
        with Documentation{Description = "The pathname of the mailslot or named pipe to which the transaction subcommand applies, or a client-supplied identifier that provides a name for the transaction. See the individual SMB_COM_TRANSACTION subprotocol subcommand descriptions for information about the value set for each subcommand. If the field is not specified in the section for the subcommands, the field SHOULD be set to \\pipe\\. If SMB_FLAGS2_UNICODE is set in the Flags2 field of the SMB Header (section ) of the request, this field MUST be a null-terminated array of 16-bit Unicode characters which MUST be aligned to start on a 2-byte boundary from the start of the SMB header. Otherwise, this field MUST be a null-terminated array of OEM characters. The Name field MUST be the first field in this section."};
    optional binary Pad1 with Encoding{Ignore = true},
        Documentation{Description = "This field SHOULD be used as an array of padding bytes to align the following field to a 4-byte boundary. relative to the start of the SMB Header. This constraint can cause this field to be a zero-length field. This field SHOULD be set to zero by the client/server, and MUST be ignored by the server/client."};
    optional (TransactionSubCommandsRequestParameters | Blob) TransParameters with Encoding{Ignore = true},
        Documentation{Description = "Transaction parameter bytes. See the individual SMB_COM_TRANSACTION subprotocol subcommands descriptions for information on the parameters sent for each subcommand."};
    optional binary Pad2 with Encoding{Ignore = true},
        Documentation{Description = "This field SHOULD be used as an array of padding bytes to align the following field to a 4-byte boundary. relative to the start of the SMB Header. This can cause this field to be a zero-length field. This field SHOULD be set to zero by the client/server, and MUST be ignored by the server/client."};
    optional binary TransData with Encoding{Ignore = true},
        Documentation{Description = "Transaction data bytes. See the individual SMB_COM_TRANSACTION subprotocol subcommands descriptions for information on the data sent for each subcommand."};
    override string ToString()
    {
        string summary = "";
        if (Name != nothing)
        {
            summary += ", Name: " + Name.ToString();
        }
        if (Subcommand != nothing)
        {
            summary += ", Subcommand: " + GetTransactionSubcommandName(SetupCount, Subcommand as USHORT);
        }
        if (Fid != nothing)
        {
            summary += ", Fid: " + DecToHexFormat(Fid as USHORT);
        }
        if (Subcommand != nothing && (Subcommand == 0x0001))
        {
            summary += ", " + ((TransParameters as TransactionSubCommandsRequestParameters).SmbParameters as TransSetNmpipeStateRequest).ToString();
        }
        if (summary != "")
        {
            return summary.Segment(2);
        }
        else
        {
            return "";
        }
    }
}

pattern SMBComTransactionSubCommand = enum USHORT
{
    TransSetNmpipeState = 0x0001,
    TransRawReadNmpipe = 0x0011,
    TransQueryNmpipeState = 0x0021,
    TransQueryNmpipeInfo = 0x0022,
    TransPeekNmpip = 0x0023,
    TransRawWriteNmpipe = 0x0031,
    TransReadNmpipe = 0x0036,
    TransWriteNmpipe = 0x0037,
    TransWaitNmpipe = 0x0053,
    TransCallNmpipe = 0x0054,
    TransTransactNmpipe = 0x0026,
    ...
};

// 2.2.4.33   SMB_COM_TRANSACTION (0x25)
type SmbComTransactionResponse[bool IsFlags2Unicode, optional ushort Subcommand]
{
    UCHAR WordCount
        with Documentation{Description = "The value of Words.SetupCount plus 10 (0x0A). This value represents the total number of SMB parameter words and MUST be greater than or equal to 10 (0x0A)."};
    USHORT TotalParameterCount
        with Documentation{Description = "The total number of transaction parameter bytes that the server expects to send to the client for this response. Parameter bytes for a transaction are carried within the SMB_Data.Trans_Parameters field of the SMB_COM_TRANSACTION response. If the size of all of the required SMB_Data.Trans_Parameters for a given transaction causes the response to exceed the MaxBufferSize established during session setup, then the server MUST NOT send all of the parameters in one response. The server MUST break up the parameters and send additional responses using the SMB_COM_TRANSACTION command to send the additional parameters. Any single response MUST NOT exceed the MaxBufferSize established during session setup. The server indicates to the client to expect additional parameters in at least one more SMB_COM_TRANSACTION response by setting ParameterCount (see following) to be less than TotalParameterCount."};
    USHORT TotalDataCount
        with Documentation{Description = "The total number of transaction data bytes that the server expects to send to the client for this response. Data bytes of a transaction are carried within the SMB_Data.Trans_Data field of the SMB_COM_TRANSACTION response. If the size of all of the required SMB_Data.Trans_Data for a given transaction causes the response to exceed the MaxBufferSize established during session setup, then the server MUST NOT send all of the data in one response. The server MUST break up the data and send additional responses using the SMB_COM_TRANSACTION command to send the additional data. Any single response MUST NOT exceed the MaxBufferSize established during session setup. The server indicates to the client to expect additional data in at least one more SMB_COM_TRANSACTION response by setting DataCount (see following) to be less than TotalDataCount."};
    USHORT Reserved1 where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB", "Reserved1", "SmbComTransactionResponse", value)
        with Documentation{Description = "Reserved. This field MUST be 0x0000 in the client request. The server MUST ignore the contents of this field."};
    USHORT ParameterCount
        with Documentation{Description = "The number of transaction parameter bytes being sent in this response. If the transaction fits within a single SMB_COM_TRANSACTION response, then this value MUST be equal to TotalParameterCount. Otherwise, the sum of the ParameterCount values in the transaction response messages MUST be equal to the smallest TotalParameterCount value reported by the server. The ParameterCount field MUST be used to determine the number of transaction parameter bytes contained within the response."};
    USHORT ParameterOffset
        with Documentation{Description = "This field MUST contain the number of bytes from the start of the SMB Header to the start of the SMB_Data.Trans_Parameters field. Client implementations MUST use this value to locate the transaction parameter block within the response. If ParameterCount is zero, the client/server MAY set this field to zero.windows always sets ParameterOffset to an offset location, relative to the start of the SMB Header, where the Trans_Parameters field should be. This behavior follows even if ParameterCount is zero."};
    USHORT ParameterDisplacement
        with Documentation{Description = "The offset, in bytes, relative to all of the transaction parameter bytes in this transaction response at which this block of parameter bytes SHOULD be placed. This value MUST be used by the client to correctly reassemble the transaction response parameters when the response messages are received out of order."};
    USHORT DataCount
        with Documentation{Description = "The number of transaction data bytes being sent in this response. If the transaction response fits within a single SMB_COM_TRANSACTION, then this value MUST be equal to TotalDataCount. Otherwise, the sum of the DataCount values in the primary and secondary transaction responses MUST be equal to the smallest TotalDataCount value reported to the client. If the value of this field is less than the value of TotalDataCount, then at least one additional SMB_COM_TRANSACTION response MUST be used to transfer the remaining data bytes."};
    USHORT DataOffset
        with Documentation{Description = "This field MUST be the number of bytes from the start of the SMB Header of the response to the start of the SMB_Data.Trans_Data field. Client implementations MUST use this value to locate the transaction data block within the response. If DataCount is zero, the client/server MAY set this field to zero.windows always sets DataCount to a value of ParameterOffset + ParameterCount. This action restricts the Trans_Data field to follow after the Trans_Parameters field, although this is not strictly a protocol requirement."};
    USHORT DataDisplacement
        with Documentation{Description = "The offset, in bytes, relative to all of the transaction data bytes in this transaction response at which this block of data bytes SHOULD be placed. This value MUST be used by the client to correctly reassemble the transaction data when the response messages are received out of order."};
    UCHAR SetupCount
        with Documentation{Description = "The number of setup words that are included in the transaction response."};
    UCHAR Reserved2 where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB", "Reserved2", "SmbComTransactionResponse", value)
        with Documentation{Description = "A padding byte. This field MUST be 0x00. Existing CIFS implementations can combine this field with SetupCount to form a USHORT. If SetupCount is defined as a USHORT, the high order byte MUST be zero."};
    USHORT ByteCount
        with Documentation{Description = "The number of bytes in the SMB_Data.Bytes array that follows."};
    optional [|ParameterOffset > 35 + WordCount * 2|] binary Pad1 with BinaryEncoding{Length = (ParameterOffset - 32 - WordCount * 2 - 3)},
        Documentation{Description = "This field SHOULD be used as an array of padding bytes to align the following field to a 4-byte boundary relative to the start of the SMB Header , This can cause this field to be a zero-length field. This field SHOULD be set to zero by the client/server, and MUST be ignored by the server/client."};
    optional [|ParameterCount > 0|] ([|TotalParameterCount == ParameterCount && Subcommand != nothing && (Subcommand as ushort) == 0x21|] TransQueryNmpipeStateResponseTransParameters //0x21
            | [|TotalParameterCount == ParameterCount && Subcommand != nothing && (Subcommand as ushort) == 0x23|] TransPeekNmpipeResponseTransParameters //0x23
            | [|TotalParameterCount == ParameterCount && Subcommand != nothing && (Subcommand as ushort) == 0x31|] TransRawWriteNmpipeResponseTransParameters //0x31
            | [|TotalParameterCount == ParameterCount && Subcommand != nothing && (Subcommand as ushort) == 0x37|] TransWriteNmpipeResponseTransParameters //0x37
            | [|DataOffset != ParameterOffset|] Blob[ParameterCount as uint]) TransParameters;
    optional [|ParameterOffset > 0 ? DataOffset > ParameterOffset + ParameterCount : DataOffset > 35 + WordCount * 2|] binary Pad2 with BinaryEncoding{Length = (ParameterOffset > 0 ? DataOffset - ParameterOffset - ParameterCount : DataOffset - 35 - WordCount * 2)},
        Documentation{Description = "This field SHOULD be used as an array of padding bytes to align the following field to a 4-byte boundary relative to the start of the SMB Header. This constraint can cause this field to be a zero-length field. This field SHOULD be set to zero by the client/server and MUST be ignored by the server/client."};
    optional [|DataCount > 0|] ([|TotalDataCount == DataCount && Subcommand != nothing && (Subcommand as ushort) == 0x21|] SmbNMPipeStatus //0x21
            | [|TotalDataCount == DataCount && Subcommand != nothing && (Subcommand as ushort) == 0x22|] TransQueryNmpipeInfoResponse[IsFlags2Unicode]
            | binary) TransData; // some frame may be insufficient data, so no length limited
    override string ToString()
    {
        string summary = "";
        bool comma = false;
        if (TransParameters != nothing)
        {
            summary += TransParameters.ToString();
            comma = true;
        }
        if (TransData != nothing && (TransData is TransQueryNmpipeInfoResponse))
        {
            if (comma)
            {
                summary += ", ";
            }
            summary += TransData.ToString();
        }
        return summary;
    }
}

pattern SmbComTransactionRequestParametersWordsFlags = flags USHORT
{
    DisconnectTid = 0x0001
        with Documentation{Description = "If set, following the completion of the operation the server MUST disconnect the tree connect associated with the tree identifier (TID) field received in the SMB Header of this request. The client SHOULD NOT send a subsequent SMB_COM_TREE_DISCONNECT for this tree connect."},
    NOResponse    = 0x0002
        with Documentation{Description = "This is a one-way transaction. The server MUST attempt to complete the transaction, but MUST NOT send a response to the client.One way transactions are used only when communicating with Mailslots, which means that they never occur within CIFS sessions."},
    Reserved      = 0xFFFC,
};

// 2.2.4.34   SMB_COM_TRANSACTION_SECONDARY (0x26)
type SmbComTransactionSecondaryRequest
{
    UCHAR WordCount where value == 0x08
        with Documentation{Description = "This field MUST be 0x08."};
    USHORT TotalParameterCount
        with Documentation{Description = "The total number of transaction parameter bytes to be sent to the server over the course of this transaction. This value MAY be less than or equal to the TotalParameterCount in preceding request messages that are part of the same transaction. This value represents transaction parameter bytes, not SMB parameter words."};
    USHORT TotalDataCount
        with Documentation{Description = "The total number of transaction data bytes to be sent to the server over the course of this transaction. This value MAY be less than or equal to the TotalDataCount in preceding request messages that are part of the same transaction. This value represents transaction data bytes, not SMB data bytes."};
    USHORT ParameterCount
        with Documentation{Description = "The number of transaction parameter bytes being sent in the SMB message. This value MUST be less than TotalParameterCount. The sum of the ParameterCount values across all of the request messages in a transaction MUST be equal to the TotalParameterCount reported in the last request message of the transaction."};
    USHORT ParameterOffset
        with Documentation{Description = "The offset, in bytes, from the start of the SMB_Header to the transaction parameter bytes contained in this SMB message. This MUST be the number of bytes from the start of the SMB message to the start of the SMB_Data.Bytes.Trans_Parameters field. Server implementations MUST use this value to locate the transaction parameter block within the SMB message. If ParameterCount is zero, the client/server MAY set this field to zero.windows always sets ParameterOffset to an offset location, relative to the start of the SMB Header, where the Trans_Parameters field should be. This behavior follows even if ParameterCount is zero."};
    USHORT ParameterDisplacement
        with Documentation{Description = "The offset, relative to all of the transaction parameter bytes sent to the server in this transaction, at which this block of parameter bytes MUST be placed. This value can be used by the server to correctly reassemble the transaction parameters even if the SMB request messages are received out of order."};
    USHORT DataCount
        with Documentation{Description = "The number of transaction data bytes being sent in this SMB message. This value MUST be less than the value of TotalDataCount. The sum of the DataCount values across all of the request messages in a transaction MUST be equal to the smallest TotalDataCount value reported to the server."};
    USHORT DataOffset
        with Documentation{Description = "The offset, in bytes, from the start of the SMB_Header to the transaction data bytes contained in this SMB message. This MUST be the number of bytes from the start of the SMB message to the start of the SMB_Data.Bytes.Trans_Data field. Server implementations MUST use this value to locate the transaction data block within the SMB message. If DataCount is zero, the client/server MAY set this field to zero.windows always sets DataCount to a value of ParameterOffset + ParameterCount. This restricts the Trans_Data field to follow after the Trans_Parameters field, although this is not strictly a protocol requirement."};
    USHORT DataDisplacement
        with Documentation{Description = "The offset, relative to all of the transaction data bytes sent to the server in this transaction, at which this block of parameter bytes MUST be placed. This value can be used by the server to correctly reassemble the transaction data block even if the SMB request messages are received out of order."};
    USHORT ByteCount
        with Documentation{Description = "The number of bytes in the SMB_Data.Bytes array, which follows."};
    optional [|ParameterOffset > 51|] binary Pad1 with BinaryEncoding{Length = (ParameterOffset - 51)},
        Documentation{Description = "This field SHOULD be used as an  array of padding bytes to align the following field to a 4-byte boundary relative to the start of the SMB Header. This constraint can cause this field to be a zero-length field. This field SHOULD be set to zero by the client/server and MUST be ignored by the server/client."};
    optional [|ParameterCount > 0 && DataOffset != ParameterOffset|] binary TransParameters with BinaryEncoding{Length = ParameterCount},
        Documentation{Description = "Transaction parameter bytes."};
    optional [|ParameterOffset > 0 ? DataOffset > ParameterOffset + ParameterCount : DataOffset > 35 + WordCount * 2|] binary Pad2 with BinaryEncoding{Length = (ParameterOffset > 0 ? DataOffset - ParameterOffset - ParameterCount : DataOffset - 35 - WordCount * 2)},
        Documentation{Description = "This field SHOULD be used as an array of padding bytes to align the following field to a 4-byte boundary relative to the start of the SMB Header. This constraint can cause this field to be a zero-length field. This field SHOULD be set to zero by the client/server and MUST be ignored by the server/client."};
    optional [|DataCount > 0|] binary Trans_Data with BinaryEncoding{Length = DataCount},
        Documentation{Description = "Transaction data bytes."};
}

// No response message
type SmbComTransactionSecondaryResponse
{}

// 2.2.4.35   SMB_COM_IOCTL (0x27)
type SmbComIoctlRequest
{
    UCHAR WordCount where value == 0x0E
        with Documentation{Description = "This value of this field MUST be set to 0x0E."};
    USHORT Fid
        with Documentation{Description = "The FID of the device or file to which the IOCTL is to be sent."};
    USHORT Category
        with Documentation{Description = "The implementation-dependent device category for the request."};
    USHORT Function
        with Documentation{Description = "The implementation-dependent device function for the request."};
    USHORT TotalParameterCount
        with Documentation{Description = "The total number of IOCTL parameter bytes that the client sends to the server in this request. Parameter bytes for an IOCTL are carried within the SMB_Data.Parameters field of the SMB_COM_IOCTL request. This value MUST be the same as ParameterCount."};
    USHORT TotalDataCount
        with Documentation{Description = "The total number of IOCTL data bytes that the client sends to the server in this request. Data bytes for an IOCTL are carried within the SMB_Data.Data field of the SMB_COM_IOCTL request. This value MUST be the same as DataCount."};
    USHORT MaxParameterCount
        with Documentation{Description = "The maximum number of SMB_Data.Parameters bytes that the client accepts in the IOCTL response. The server MUST NOT return more than this number of bytes in the SMB_Data.Parameters field of the response."};
    USHORT MaxDataCount
        with Documentation{Description = "The maximum number of SMB_Data.Data bytes that the client accepts in the IOCTL response. The server MUST NOT return more than this number of bytes in the SMB_Data.Data field."};
    ULONG Timeout
        with Documentation{Description = "The value of this field MUST be the maximum number of milliseconds that the server SHOULD wait for completion of the transaction before generating a time-out and returning a response to the client. The client SHOULD set this to 0x00000000 to indicate that no time-out is expected. A value of 0x00000000 indicates that the server returns an error if the resource is not immediately available. If the operation does not complete within the specified time, the server aborts the request and sends a failure response."};
    USHORT Reserved2 where value == 0x0000
        with Documentation{Description = "Reserved. This field MUST be 0x0000 in the client request. The server MUST ignore the contents of this field."};
    USHORT ParameterCount
        with Documentation{Description = "The number of IOCTL parameter bytes that the client sends to the server in this request. Parameter bytes for an IOCTL are carried within the SMB_Data.Parameters field of the SMB_COM_IOCTL request. This value MUST be the same as TotalParameterCount."};
    USHORT ParameterOffset
        with Documentation{Description = "The client SHOULD set the value of this field to 0x0000. The server MUST ignore the value of this field."};
    USHORT DataCount
        with Documentation{Description = "The total number of IOCTL data bytes that the client sends to the server in this request. Data bytes for an IOCTL are carried within the SMB_Data.Data field of the SMB_COM_IOCTL request. This value MUST be the same as TotalDataCount."};
    USHORT DataOffset
        with Documentation{Description = "The client SHOULD set the value of this field to 0x0000. The server MUST ignore the value of this field."};
    USHORT ByteCount
        with Documentation{Description = "The number of bytes in the Bytes array that follows."};
    //binary Pad1 with BinaryEncoding{Length = 0}, // ParameterOffset must be 0, so no padding.
    //    Documentation{Description = "An array of padding bytes used to align the next field to a 2-byte or 4-byte boundary."};
    optional [|ParameterCount > 0 && DataOffset != ParameterOffset|] binary Parameters with BinaryEncoding{Length = ParameterCount},
        Documentation{Description = "IOCTL parameter bytes. The contents are implementation-dependent."};
    //binary Pad2 with BinaryEncoding{Length = 0}, // DataOffset must be 0, so no padding.
    //    Documentation{Description = "An array of padding bytes, used to align the next field to a 2-byte or 4-byte boundary."};
    optional [|DataCount > 0|] binary Data with BinaryEncoding{Length = DataCount},
        Documentation{Description = "Transaction data bytes. The contents are implementation-dependent."};
}

// 2.2.4.35   SMB_COM_IOCTL (0x27)
type SmbComIoctlResponse
{
    UCHAR WordCount where value == 0x08
        with Documentation{Description = "The value of this field MUST be set to 0x08."};
    USHORT TotalParameterCount
        with Documentation{Description = "The total number of IOCTL parameter bytes that the server sends to the client in this response. Parameter bytes for an IOCTL are carried within the SMB_Data.Parameters field of the SMB_COM_IOCTL request. This value MUST be the same as ParameterCount, and this value MUST be less than or equal to the MaxParameterCount field value in the client\'s request."};
    USHORT TotalDataCount
        with Documentation{Description = "The total number of IOCTL data bytes that the server sends to the client in this response. Data bytes for an IOCTL are carried within the SMB_Data.Data field of the SMB_COM_IOCTL request. This value MUST be the same as DataCount, and this value MUST be less than or equal to the MaxDataCount field value in the client\'s request."};
    USHORT ParameterCount
        with Documentation{Description = "The total number of IOCTL parameter bytes that the server sends to the client in this response. Parameter bytes for an IOCTL are carried within the SMB_Data.Parameters field of the SMB_COM_IOCTL request. This value MUST be the same as TotalParameterCount and this value MUST be less than or equal to the MaxParameterCount field value in the client\'s request."};
    USHORT ParameterOffset
        with Documentation{Description = "This field MUST contain the number of bytes from the start of the SMB Header to the start of the SMB_Data.Parameters field. Client implementations MUST use this value to locate the IOCTL parameter block within the response."};
    USHORT ParameterDisplacement
        with Documentation{Description = "The server SHOULD set the value of this field to 0x0000. The client MUST ignore the value of this field."};
    USHORT DataCount
        with Documentation{Description = "The total number of IOCTL data bytes that the server sends to the client in this response. Data bytes for an IOCTL are carried within the SMB_Data.Data field of the SMB_COM_IOCTL request. This value MUST be the same as TotalDataCount, and this value MUST be less than or equal to the MaxDataCount field value of the client\'s request."};
    USHORT DataOffset
        with Documentation{Description = "This field MUST be the number of bytes from the start of the SMB Header of the response to the start of the SMB_Data.Data field. Client implementations MUST use this value to locate the IOCTL data block within the response."};
    USHORT DataDisplacement
        with Documentation{Description = "The server SHOULD set the value of this field to 0x0000. The client MUST ignore the value of this field."};
    USHORT ByteCount
        with Documentation{Description = "The number of bytes in the SMB_Data.Bytes array, which follows."};
    optional [|ParameterOffset > 51|] binary Pad1 with BinaryEncoding{Length = (ParameterOffset - 51)},
        Documentation{Description = "An array of padding bytes used to align the next field to a 16- or 32-bit boundary."};
    optional [|ParameterCount > 0 && DataOffset != ParameterOffset|] binary Parameters with BinaryEncoding{Length = ParameterCount},
        Documentation{Description = "IOCTL parameter bytes. The contents are implementation-dependent."};
    optional [|ParameterOffset > 0 ? DataOffset > ParameterOffset + ParameterCount : DataOffset > 35 + WordCount * 2|] binary Pad2 with BinaryEncoding{Length = (ParameterOffset > 0 ? DataOffset - ParameterOffset - ParameterCount : DataOffset - 35 - WordCount * 2)},
        Documentation{Description = "An array of padding bytes used to align the next field to a 16- or 32-bit boundary."};
    optional [|DataCount > 0|] binary Data with BinaryEncoding{Length = DataCount},
        Documentation{Description = "IOCTL data bytes. The contents are implementation-dependent."};
}

// 2.2.4.36 - 2.2.4.38
// Messages obsolated.

// 2.2.4.39   SMB_COM_ECHO (0x2B)
type SmbComEchoRequest
{
    UCHAR WordCount where value == 0x01
        with Documentation{Description = "This field MUST be 0x01."};
    USHORT EchoCount
        with Documentation{Description = "USHORT The number of times that the server SHOULD echo the contents of the SMB_Data.Data field."};
    USHORT ByteCount
        with Documentation{Description = "This field MUST be greater than or equal to 0x0000, indicating the number of bytes of data."};
    binary Data with BinaryEncoding{Length = ByteCount}, Documentation{Description = "Data to echo."};
}

// 2.2.4.39   SMB_COM_ECHO (0x2B)
type SmbComEchoResponse
{
    UCHAR WordCount where value == 0x01
        with Documentation{Description = "This field MUST be 0x01."};
    USHORT SequenceNumber
        with Documentation{Description = "The sequence number of this echo response message.Windows clients ignore the SequenceNumber field in the server response."};
    USHORT ByteCount
        with Documentation{Description = "This field MUST be the same as it was in the request."};
    binary Data with BinaryEncoding{Length = ByteCount},
        Documentation{Description = "This field MUST be the same as it was in the request."};
}

// 2.2.4.40   SMB_COM_WRITE_AND_CLOSE (0x2C)
type SmbComWriteAndCloseRequest
{
    UCHAR WordCount where (value == 0x06 || value == 0x0C)
        with Documentation{Description = "This field MUST be either 0x06 or 0x0C."};
    USHORT Fid
        with Documentation{Description = "This field MUST be a valid 16-bit unsigned integer indicating the file to which the data SHOULD be written."};
    USHORT CountOfBytesToWrite
        with Documentation{Description = "This field is a 16-bit unsigned integer indicating the number of bytes to be written to the file. The client MUST ensure that the amount of data sent can fit in the negotiated maximum buffer size. If the value of this field is zero (0x0000), the server MUST truncate or extend the file to match the WriteOffsetInBytes."};
    ULONG WriteOffsetInBytes
        with Documentation{Description = "This field is a 32-bit unsigned integer indicating the offset, in number of bytes, from the beginning of the file at which to begin writing to the file. The client MUST ensure that the amount of data sent can fit in the negotiated maximum buffer size. Because this field is limited to 32-bits, this command is inappropriate for files that have 64-bit offsets."};
    Utime LastWriteTime
        with Documentation{Description = "This field is a 32-bit unsigned integer indicating the number of seconds since Jan 1, 1970, 00:00:00.0. The server SHOULD set the last write time of the file represented by the FID to this value. If the value is zero (0x00000000), the server SHOULD use the current local time of the server to set the value. Failure to set the time MUST NOT result in an error response from the server."};
    optional [|WordCount == 0x0C|] binary Reserved with BinaryEncoding{Length = 12},
        Documentation{Description = "This field is optional. This field is reserved,  and all entries MUST be zero (0x00000000). This field is used only in the 12-word version of the request."};
    USHORT ByteCount where value >= 0x01
        with Documentation{Description = "This field MUST be 0x0001 + CountOfBytesToWrite."};
    UCHAR Pad
        with Documentation{Description = "The value of this field SHOULD be ignored. This is padding to force the byte alignment to a double word boundary."};
    optional [|CountOfBytesToWrite > 0|] binary Data with BinaryEncoding{Length = CountOfBytesToWrite},
        Documentation{Description = "The raw bytes to be written to the file."};
}

// 2.2.4.40   SMB_COM_WRITE_AND_CLOSE (0x2C)
type SmbComWriteAndCloseResponse
{
    UCHAR WordCount where value == 0x01
        with Documentation{Description = "This field MUST be 0x01."};
    USHORT CountOfBytesWritten
        with Documentation{Description = "Indicates the actual number of bytes written to the file. For successful writes, this MUST equal the CountOfBytesToWrite in the client\'s request. If the number of bytes written differs from the number requested and no error is indicated, then the server has no resources available with which to satisfy the complete write."};
    USHORT ByteCount where value == 0x0000
        with Documentation{Description = "This field MUST be 0x0000. No data is sent by this message.windows_nt_server appends three null padding bytes to this message, following the ByteCount field. These three bytes are not message data and can safely be discarded."};
}

// 2.2.4.41   SMB_COM_OPEN_ANDX (0x2D)
type SmbComOpenAndxRequest[bool IsFlags2Unicode]
{
    UCHAR WordCount where value == 0x0F
        with Documentation{Description = "This field MUST be 0x0F."};
    UCHAR AndXCommand
        with Documentation{Description = "The command code for the next SMB command in the packet. This value MUST be set to 0xFF if there are no additional SMB commands in the client request packet."};
    UCHAR AndXReserved where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB", "AndXReserved", "SmbComOpenAndxRequest", value)
        with Documentation{Description = "A reserved field. This field MUST be 0x00 when the message is sent, and the server MUST ignore this value when the message is received."};
    USHORT AndXOffset
        with Documentation{Description = "This field MUST be set to the offset, in bytes, from the start of the SMB Header to the start of the WordCount field in the next SMB command in this packet. This field is valid only if the AndXCommand field is not set to 0xFF. If AndXCommand is 0xFF, this field MUST be ignored by the server."};
    SmbComOpenAndxRequestParametersWordsFlags Flags
        with Documentation{Description = "A 16-bit field of flags for requesting attribute data and locking."};
    SmbAccessMode AccessMode
        with Documentation{Description = "A 16-bit field for encoding the requested access mode. See section  for a discussion on sharing modes."};
    SmbFileAttributes SearchAttrs
        with Documentation{Description = "The set of attributes that the file MUST have in order to be found. If none of the attribute bytes is set, the file attributes MUST refer to a regular file.windows_nt_server ignores SearchAttrs in open requests."};
    SmbFileAttributes FileAttrs
        with Documentation{Description = "The set of attributes that the file is to have if the file needs to be created. If none of the attribute bytes is set, the file attributes MUST refer to a regular file."};
    Utime CreationTime
        with Documentation{Description = "A 32-bit integer time value to be assigned to the file as the time of creation if the file is created."};
    SmbOpenMode OpenMode
        with Documentation{Description = "A 16-bit field that controls the way a file SHOULD be treated when it is opened for use by certain extended SMB requests."};
    ULONG AllocationSize
        with Documentation{Description = "The number of bytes to reserve on file creation or truncation. This field MAY be ignored by the server."};
    ULONG Timeout
        with Documentation{Description = "This field is a 32-bit unsigned integer value containing the number of milliseconds to wait on a blocked open request before returning without successfully opening the file."};
    ULONG Reserved where value == 0x00000000
        with Documentation{Description = "This field is reserved and MUST be 0x00000000."};
    USHORT ByteCount where value >= 0x0002
        with Documentation{Description = "This field MUST be greater than or equal to 0x0002."};
    optional [|IsFlags2Unicode|] UCHAR Pad;
    SmbString[IsFlags2Unicode] FileName
        with Documentation{Description = "A buffer containing the name of the file to be opened."};
    optional binary AndXPadding with Encoding{Ignore = true};
}

pattern SmbComOpenAndxRequestParametersWordsFlags = flags USHORT
{
    ReqAttrib               = 0x0001
        with Documentation{Description = "If this bit is set, the client requests that the file attribute data in the response be populated. All fields after the FID in the response are also populated. If this bit is not set, all fields after the FID in the response are zero."},
    ReqOplock               = 0x0002
        with Documentation{Description = "Client requests an exclusive OpLock on the file."},
    ReqOplockBatch          = 0x0004
        with Documentation{Description = "Client requests a Batch OpLock on the file."},
    Reserved1               = 0x0008,
    SmbOpenExtendedResponse = 0x0010
      with Documentation
             {Description = "If set, the client is requesting the extended format of the response, as described later in this section."},
    Reserved2               = 0xFFE0,
};

type SmbOpenMode
{
    byte Reserved1 with BinaryEncoding{Width = 3};
    byte CreateFile with BinaryEncoding{Width = 1}, DisplayInfo{ToText = CreateFileToText};
    byte Reserved2 with BinaryEncoding{Width = 2};
    byte FileExistsOpts with BinaryEncoding{Width = 2}, DisplayInfo{ToText = FileExistsOptsToText};
    byte Reserved3;
    
    static string CreateFileToText(any input)
    {
        if(input is byte)
        {
            byte v = input as byte;
            switch(v)
            {
                case 1 =>
                    return "If the file does not exist, return an error.";
                case 2 =>
                    return "If the file does not exist, create it.";
                default =>
                    return v as string;
            }
        }
        return input as string;
    }
    
    static string FileExistsOptsToText(any input)
    {
        if(input is byte)
        {
            byte v = input as byte;
            switch(v)
            {
                case 0 =>
                    return "The request SHOULD fail and an error returned indicating the prior existence of the file.";
                case 1 =>
                    return "The file is to be appended.";
                case 2 =>
                    return "The file is to be truncated to zero (0) length.";
                case 3 =>
                    return "Reserved";
                default =>
                    return v as string;
            }
        }
        return input as string;
    }
}

// 2.2.4.41   SMB_COM_OPEN_ANDX (0x2D)
type SmbComOpenAndxResponse
{
    UCHAR WordCount where (value == 0x0F || value == 0x13)
        with Documentation{Description = "This field MUST be 0x0F or 0x13"};
    UCHAR AndXCommand
        with Documentation{Description = "The command code for the next SMB command in the packet. This value MUST be set to 0xFF if there are no additional SMB command responses in the server response packet."};
    UCHAR AndXReserved where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB", "AndXReserved", "SmbComOpenAndxResponse", value)
        with Documentation{Description = "A reserved field. This MUST be set to 0x00 when this response is sent, and the client MUST ignore this field."};
    USHORT AndXOffset
        with Documentation{Description = "This field MUST be set to the offset, in bytes, from the start of the SMB Header  to the start of the WordCount field in the next SMB command response in this packet. This field is valid only if the AndXCommand field is not set to 0xFF. If AndXCommand is 0xFF, this field MUST be ignored by the client."};
    USHORT Fid
        with Documentation{Description = "A valid FID representing the open instance of the file."};
    SmbFileAttributes FileAttrs
        with Documentation{Description = "The actual file system attributes of the file. If none of the attribute bytes is set, the file attributes refer to a regular file."};
    Utime LastWriteTime
        with Documentation{Description = "A 32-bit integer time value of the last modification to the file."};
    ULONG FileDataSize
        with Documentation{Description = "The number of bytes in the file. This field is advisory and MAY be used."};
    SmbComOpenAndxResponseAccessRight AccessRights
        where ValidationCheck(InRange<SmbComOpenAndxResponseAccessRight>(value), null, DiagnosisLevel.Error,
                () => Format(INFRASTRUCTURE_STR_CHECK_ENUM_VALUE, ["SMB", "AccessRights", INFRASTRUCTURE_STR_TYPE, "SmbComOpenAndxResponse", INFRASTRUCTURE_STR_MUST, "0x0000, 0x0001, 0x0002", DecToHexFormat(value)]))
        with Documentation{Description = "A 16-bit field that shows granted access rights to the file."};
    SmbComOpenAndxResponseParametersWordsResourceType ResourceType
        with Documentation{Description = "A 16-bit field that shows the resource type opened."};
    SmbNMPipeStatus NmpipeStatus
        with Documentation{Description = "A 16-bit field that contains the status of the named pipe if the resource type opened is a named pipe."};
    SmbOpenResults OpenResults
        with Documentation{Description = "A 16-bit field that shows the results of the open operation."};
    ULONG ServerFid
        with Documentation{Description = "Reserved but not implemented. Intended as a 32-bit server file identifier that uniquely identifies the file on the server. "};
    USHORT Reserved1 where value == 0x0000
        with Documentation{Description = "All entries MUST be 0x0000."};
    optional [|WordCount == 0x13|] FilePipePrinterAccessMask MaximalAccessRights
        with Documentation{Description = "The maximum access rights that this user has on this object. "};
    optional [|WordCount == 0x13|] FilePipePrinterAccessMask GuestMaximalAccessRights
        with Documentation{Description = "):  The maximum access rights that the guest account has on this file. "};
    USHORT ByteCount// where value == 0x0000
        with Documentation{Description = "This field MUST be 0x0000. No data is sent by this message."};
    optional binary AndXPadding with Encoding{Ignore = true};
}

pattern SmbComOpenAndxResponseParametersWordsResourceType = enum USHORT
{
    FileTypeDisk = 0x0000
        with Documentation{Description = "Disk file or directory."},
    FileTypeByteModePipe = 0x0001
        with Documentation{Description = "Byte mode named pipe."},
    FileTypeMessageModePipe = 0x0002
        with Documentation{Description = "Message-mode named pipe."},
    FileTypePrinter = 0x0003
        with Documentation{Description = "Printer device."},
    FileTypeCommDevice = 0x0004
        with Documentation {Description = "Character-mode device. When an extended protocol has been negotiated, this value allows a device to be opened for driver-level I/O. This provides direct access to real-time and interactive devices such as modems, scanners, and so on."},
    FileTypeUnknown = 0xFFFF
        with Documentation{Description = "Unknown file type."},
};

pattern SmbComOpenAndxResponseAccessRight = enum USHORT
{
    SmbDaAccessRead = 0x0000,
    SmbDaAccessWrite = 0x0001,
    SmbDaAccessReadWrite = 0x0002,
    ...
};

type SmbOpenResults
{
    byte Reserved1 with BinaryEncoding{Width = 6};
    byte OpenResult with BinaryEncoding{Width = 2}, DisplayInfo{ToText = OpenResultToText};
    byte LockStatus with BinaryEncoding{Width = 1}, DisplayInfo{ToText = LockStatusToText};
    byte Reserved3 with BinaryEncoding{Width = 7};
    
    static string OpenResultToText(any input)
    {
        if(input is byte)
        {
            byte v = input as byte;
            switch(v)
            {
                case 1 =>
                    return "The file existed and was opened.";
                case 2 =>
                    return "The file did not exist and was therefore created.";
                case 3 =>
                    return "The file existed and was truncated.";
                default =>
                    return "Reserved";
            }
        }
        return input as string;
    }
    
    static string LockStatusToText(any input)
    {
        if(input is byte)
        {
            byte v = input as byte;
            switch(v)
            {
                case 0 =>
                    return "No OpLock was requested, the OpLock could not be granted, or the server does not support OpLocks.";
                case 1 =>
                    return "An OpLock was requested by the client and was granted by the server.";
                default =>
                    return v as string;
            }
        }
        return input as string;
    }
}

// 2.2.4.42   SMB_COM_READ_ANDX (0x2E)
type SmbComReadAndxRequest
{
    UCHAR WordCount where (value == 0x0a || value == 0x0c)
        with Documentation{Description = "This field MUST be either 0x0A or 0x0C."};
    UCHAR AndXCommand
         with Documentation{Description = "The command code for the next SMB command in the packet. This value MUST be set to 0xFF if there are no additional SMB commands in the client request packet."};
    UCHAR AndXReserved where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB", "AndXReserved", "SmbComReadAndxRequest", value)
         with Documentation{Description = "A reserved field. This MUST be set to 0x00 when this request is sent, and the server MUST ignore this value when the message is received."};
    USHORT AndXOffset
         with Documentation{Description = "This field MUST be set to the offset in bytes from the start of the SMB Header to the start of the WordCount field in the next SMB command in this packet. This field is valid only if the AndXCommand field is not set to 0xFF. If AndXCommand is 0xFF, this field MUST be ignored by the server."};
    USHORT Fid
         with Documentation{Description = "This field MUST be a valid FID indicating the file from which the data MUST be read."};
    ULONG Offset
         with Documentation{Description = "If WordCount is 0x0A, this field represents a 32-bit offset, measured in bytes, of where the read MUST start relative to the beginning of the file. If WordCount is 0x0C, this field represents the lower 32 bits of a 64-bit offset."};
    USHORT MaxCountOfBytesToReturn
         with Documentation{Description = "The maximum number of bytes to read. A single request MUST NOT return more data than permitted by the maximum negotiated buffer size (MaxBufferSize) for the session unless CAP_LARGE_READX has been negotiated as specified in sections 2.2.4.53.1 and 3.3.5.43. If MaxCountOfBytesToReturn would cause the total size of the response message to exceed the maximum negotiated buffer size, the server MUST return only the number of bytes that fit within the maximum negotiated buffer size."};
    USHORT MinCountOfBytesToReturn
         with Documentation{Description = "The requested minimum number of bytes to return. This field is used only when reading from a named pipe or a device. It is ignored when reading from a standard file."};
    ULONG TimeoutOrMaxCountHigh
         with Documentation{Description = "This field represents the amount of time, in milliseconds, that a server MUST wait before sending a response. It is used only when reading from a named pipe or I/O device and does not apply when reading from a regular file. "};
    USHORT Remaining
         with Documentation{Description = "Count of bytes remaining to satisfy client's read request. This field is not used in the NT LAN Manager dialect. Clients MUST set this field to 0x0000, and servers MUST ignore it."};
    optional [|WordCount == 0x0C|] ULONG OffsetHigh
         with Documentation{Description = "This field is optional. If WordCount is 0x0A this field is not included in the request. If WordCount is 0x0C this field represents the upper 32 bits of a 64-bit offset, measured in bytes, of where the read SHOULD start relative to the beginning of the file."};
    USHORT ByteCount where value == 0x0000
        with Documentation{Description = "This field MUST be 0x0000. No data is sent by this message."};
    optional binary AndXPadding with Encoding{Ignore = true};
}

// 2.2.4.42   SMB_COM_READ_ANDX (0x2E)
type SmbComReadAndxResponse[bool IsFlags2Unicode]
{
    UCHAR WordCount where value == 0x0C
        with Documentation{Description = "This field MUST be 0x0C."};
    UCHAR AndXCommand
        with Documentation{Description = "The command code for the next SMB command in the packet. This value MUST be set to SMB_COM_NO_ANDX_COMMAND (0xFF) if there are no additional SMB command responses in the server response packet.An AndX chain can be formed by adding an SMB_COM_CLOSE command as a follow-on to SMB_COM_READ_ANDX. SMB_COM_CLOSE is the only valid follow-on command for SMB_COM_READ_ANDX. windows_nt_server correctly processes AndX chains consisting of SMB_COM_READ_ANDX and SMB_COM_CLOSE, but does not correctly set the AndXCommand field in the response message. windows_nt_server always sets the value of AndXCommand in the SMB_COM_READ_ANDX response to SMB_COM_NO_ANDX_COMMAND (0xFF)."};
    UCHAR AndXReserved where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB", "AndXReserved", "SmbComReadAndxResponse", value)
        with Documentation{Description = "A reserved field. This MUST be set to 0x00 when this response is sent, and the client MUST ignore this field."};
    USHORT AndXOffset
        with Documentation{Description = "This field MUST be set to the offset in bytes from the start of the SMB Header to the start of the WordCount field in the next SMB command response in this packet. This field is valid only if the AndXCommand field is not set to SMB_COM_NO_ANDX_COMMAND (0xFF). If AndXCommand is SMB_COM_NO_ANDX_COMMAND, this field MUST be ignored by the client.windows_nt_server always sets this field in this message to zero, even if there is a chained SMB_COM_CLOSE follow-on response connected to the SMB_COM_READ_ANDX response message. If present, the SMB_COM_CLOSE response can be seen as three null padding bytes (representing WordCount==0x00 and ByteCount==0x0000) immediately following the SMB_Parameters of the SMB_COM_READ_ANDX portion of the message."};
    USHORT Available
        with Documentation{Description = "This field is valid when reading from named pipes or I/O devices. This field indicates the number of bytes remaining to be read after the requested read was completed. If the client reads from a disk file, this field MUST be set to -1 (0xFFFF).windows_nt servers always set the Available field to -1 (0xFFFF)."};
    USHORT DataCompactionMode
        with Documentation{Description = "Reserved and SHOULD be 0x0000."};
    USHORT Reserved1 where value == 0x0000
        with Documentation{Description = "This field MUST be 0x0000."};
    USHORT DataLength
        with Documentation{Description = "The number of data bytes included in the response. If this value is less than the value in the Request.SMB_Parameters.MaxCountOfBytesToReturn field, it indicates that the read operation has reached the end of the file (EOF)."};
    USHORT DataOffset
        with Documentation{Description = "The offset in bytes from the header of the read data."};
    USHORT DataLengthHigh
        with Documentation{Description = "If the data read is greater than or equal to 0x00010000 bytes (64KB) in length, then the server MUST set the two least-significant bytes of the length in the DataLength field of the response and the two most-significant bytes of the length in the DataLengthHigh field. Otherwise, this field MUST be set to zero."};
    binary Reserved2 with BinaryEncoding{Length = 8},
        Documentation{Description = "Reserved. All entries MUST be 0x0000. The last 5 words are reserved in order to make the SMB_COM_READ_ANDX Response the same size as the SMB_COM_WRITE_ANDX Response."};
    USHORT ByteCount where value >= 0x0000
        with Documentation{Description = "This field MUST be greater than or equal to 0x0000."};
    optional [|DataOffset > 59|] binary Pad with BinaryEncoding{Length = (DataOffset - 59)},
        Documentation{Description = "This field is optional. When using the NT LAN Manager dialect, this field can be used to align the Data field to a 16-bit boundary relative to the start of the SMB Header. If Unicode strings are being used, this field MUST be present. When used, this field MUST be one padding byte long."};
    optional binary Data with Encoding{Ignore = true},
        Documentation{Description = "The actual bytes read in response to the request."};
    optional binary AndXPadding with Encoding{Ignore = true};
}

// 2.2.4.43   SMB_COM_WRITE_ANDX (0x2F)
type SmbComWriteAndxRequest
{
    UCHAR WordCount where (value == 0x0C || value == 0x0E)
        with Documentation{Description = "This field MUST be either 0x0C or 0x0E."};
    UCHAR AndXCommand
        with Documentation{Description = "The command code for the next SMB command in the packet. This value MUST be set to 0xFF if there are no additional SMB commands in the client request packet."};
    UCHAR AndXReserved where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB", "AndXReserved", "SmbComWriteAndxRequest", value)
        with Documentation{Description = "A reserved field. This MUST be set to 0x00 when this request is sent, and the server MUST ignore this value when the message is received."};
    USHORT AndXOffset
        with Documentation{Description = "This field MUST be set to the offset in bytes from the start of the SMB Header to the start of the WordCount field in the next SMB command in this packet. This field is valid only if the AndXCommand field is not set to 0xFF. If AndXCommand is 0xFF, this field MUST be ignored by the server."};
    USHORT Fid
        with Documentation{Description = "This field MUST be a valid FID indicating the file to which the data SHOULD be written."};
    ULONG Offset
        with Documentation{Description = "If WordCount is 0x0C, this field represents a 32-bit offset, measured in bytes, of where the write SHOULD start relative to the beginning of the file. If WordCount is 0xE, this field represents the lower 32 bits of a 64-bit offset."};
    ULONG Timeout
        with Documentation{Description = "This field is the time-out, in milliseconds, to wait for the write to complete. This field is used only when writing to a named pipe or an I/O device. It does not apply and MUST be 0x00000000 when writing to a regular file."};
    SmbComWriteAndxRequestParametersWordsWriteMode WriteMode
        with Documentation{Description = "A 16-bit field containing flags defined as follows:"};
    USHORT Remaining
        with Documentation{Description = "This field is an advisory field telling the server approximately how many bytes are to be written to this file before the next non-write operation. It SHOULD include the number of bytes to be written by this request. The server MAY either ignore this field or use it to perform optimizations. If a pipe write spans multiple requests, the client MUST set this field to the number of bytes remaining to be written.windows_nt and windows_98 clients set this field to zero for non-message mode pipe writes. This field is ignored by the server if the FID indicates a file. This field is valid and relevant only for message mode pipe writes."};
    USHORT DataLengthHigh
        with Documentation{Description = "This field contains the two most significant bytes of the length of the data to write to the file."};
    USHORT DataLength
        with Documentation{Description = "This field is the number of bytes included in the SMB_Data that are to be written to the file."};
    USHORT DataOffset
        with Documentation{Description = "The offset in bytes from the start of the SMB Header to the start of the data that is to be written to the file. The offset is relative to the start of the SMB Header, regardless of the command request\'s position in an AndX chain. Specifying this offset allows a client to efficiently align the data buffer."};
    optional [|WordCount == 0x0E|] ULONG OffsetHigh
        with Documentation{Description = "This field is optional. If WordCount is 0x0C, this field is not included in the request. If WordCount is 0x0E, this field represents the upper 32 bits of a 64-bit offset, measured in bytes, of where the write SHOULD start relative to the beginning of the file."};
    USHORT ByteCount
        with Documentation{Description = "This field MUST be greater than or equal to 0x0001."};
    optional [|DataOffset > 35 + WordCount * 2|] binary Pad with BinaryEncoding{Length = (DataOffset - 35 - WordCount * 2)},
        Documentation{Description = "Padding byte that MUST be ignored."};
    optional binary Data with Encoding{Ignore = true},
        Documentation{Description = "The bytes to be written to the file."};
    optional binary AndXPadding with Encoding{Ignore = true};
}

pattern SmbComWriteAndxRequestParametersWordsWriteMode = flags USHORT
{
    WritethroughMode   = 0x0001
        with Documentation{Description = "If set the server MUST NOT respond to the client before the data is written to disk (write-through)."},
    ReadBytesAvailable = 0x0002
        with Documentation{Description = "If set the server SHOULD set the Response.SMB_Parameters.Available field correctly for writes to named pipes or I/O devices."},
    RawMode            = 0x0004
        with Documentation{Description = "Applicable to named pipes only. If set, the named pipe MUST be written to in raw mode (no translation)."},
    MsgStart           = 0x0008
        with Documentation{Description = "Applicable to named pipes only. If set, this data is the start of a message."},
    Reserved           = 0xFFF0,
};

// 2.2.4.43   SMB_COM_WRITE_ANDX (0x2F)
type SmbComWriteAndxResponse
{
    UCHAR WordCount where value == 0x06
        with Documentation{Description = "This field MUST be 0x06. The length in two-byte words of the remaining SMB_Parameters."};
    UCHAR AndXCommand
        with Documentation{Description = "The command code for the next SMB command in the packet. This value MUST be set to 0xFF if there are no additional SMB command responses in the server response packet."};
    UCHAR AndXReserved where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB", "AndXReserved", "SmbComWriteAndxResponse", value)
        with Documentation{Description = "A reserved field. This MUST be set to 0x00 when this response is sent, and the client MUST ignore this field."};
    USHORT AndXOffset
        with Documentation{Description = "This field MUST be set to the offset in bytes from the start of the SMB Header to the start of the WordCount field in the next SMB command response in this packet. This field is valid only if the AndXCommand field is not set to 0xFF. If AndXCommand is 0xFF, this field MUST be ignored by the client."};
    USHORT Count
        with Documentation{Description = "The number of bytes written to the file."};
    USHORT Available
        with Documentation{Description = "This field is valid when writing to named pipes or I/O devices. This field indicates the number of bytes remaining to be written after the requested write was completed. If the client wrote to a disk file, this field MUST be set to 0xFFFF.Windows NT servers always set Available to 0xFFFF."};
    USHORT CountHigh
        with Documentation{Description = "This field contains the two most significant bytes of the count of bytes written."};
    USHORT Reserved where value == 0x0000
        with Documentation{Description = "This field is reserved. Servers MUST set this field to zero and clients MUST ignore this field upon receipt."};
    USHORT ByteCount where value == 0x0000
        with Documentation{Description = "This field MUST be 0x0000. No data is sent by this message."};
    optional binary AndXPadding with Encoding{Ignore = true};
}

// 2.2.4.44 - 2.2.4.45
// Message obsolated.

// 2.2.4.46   SMB_COM_TRANSACTION2 (0x32)
type SmbComTransaction2Request[bool IsFlags2Unicode]
{
    UCHAR WordCount where value >= 0x0E
        with Documentation{Description = "The value of Words.SetupCount plus 14 (0x0E). This value represents the total number of SMB parameter words and MUST be greater than or equal to 14 (0x0E)."};
    USHORT TotalParameterCount
        with Documentation{Description = "The total number of SMB_COM_TRANSACTION2 parameter bytes to be sent in this transaction request. This value MAY be reduced in any or all subsequent SMB_COM_TRANSACTION2_SECONDARY requests that are part of the same transaction. This value represents transaction parameter bytes, not SMB parameter words. Transaction parameter bytes are carried in the SMB_Data block of the SMB_COM_TRANSACTION2 request."};
    USHORT TotalDataCount
        with Documentation{Description = "The total number of SMB_COM_TRANSACTION2 data bytes to be sent in this transaction request. This value MAY be reduced in any or all subsequent SMB_COM_TRANSACTION2_SECONDARY requests that are part of the same transaction. This value represents transaction data bytes, not SMB data bytes."};
    USHORT MaxParameterCount
        with Documentation{Description = "The maximum number of parameter bytes that the client will accept in the transaction reply. The server MUST NOT return more than this number of parameter bytes."};
    USHORT MaxDataCount
        with Documentation{Description = "The maximum number of data bytes that the client will accept in the transaction reply. The server MUST NOT return more than this number of data bytes."};
    UCHAR MaxSetupCount
        with Documentation{Description = "The maximum number of setup bytes that the client will accept in the transaction reply. The server MUST NOT return more than this number of setup bytes."};
    UCHAR Reserved1 where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB", "Reserved1", "SmbComTransaction2Request", value)
        with Documentation{Description = "A padding byte. This field MUST be zero. Existing CIFS implementations MAY combine this field with MaxSetupCount to form a USHORT. If MaxSetupCount is defined as a USHORT, the high order byte MUST be 0x00."};
    SmbComTransaction2RequestParametersWordsFlags Flags
        with Documentation{Description = "A set of bit flags that alter the behavior of the requested operation. Unused bit fields MUST be set to zero by the client sending the request, and MUST be ignored by the server receiving the request. The client MAY set either or both of the following bit flags:"};
    ULONG Timeout
        with Documentation{Description = "The number of milliseconds that the server waits for completion of the transaction before generating a time-out. A value of 0x00000000 indicates that the operation is not blocked.windows_nt_server honors the Timeout field only in transaction subcommands that specifically state that the Timeout field is honored. Check the individual subcommands for details."};
    USHORT Reserved2 where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB", "Reserved2", "SmbComTransaction2Request", value)
        with Documentation{Description = "Reserved. This field MUST be 0x0000 in the client request. The server MUST ignore the contents of this field."};
    USHORT ParameterCount
        with Documentation{Description = "The number of transaction parameter bytes being sent in this SMB message. If the transaction fits within a single SMB_COM_TRANSACTION2 request, then this value MUST be equal to TotalParameterCount. Otherwise, the sum of the ParameterCount values in the primary and secondary transaction request messages MUST be equal to the smallest TotalParameterCount value reported to the server. If the value of this field is less than the value of TotalParameterCount, then at least one SMB_COM_TRANSACTION2_SECONDARY message MUST be used to transfer the remaining parameter bytes. The ParameterCount field MUST be used to determine the number of transaction parameter bytes contained within the SMB_COM_TRANSACTION2 message."};
    USHORT ParameterOffset
        with Documentation{Description = "The offset, in bytes, from the start of the SMB_Header to the transaction parameter bytes. This MUST be the number of bytes from the start of the SMB message to the start of the SMB_Data.Bytes.Parameters field. Server implementations MUST use this value to locate the transaction parameter block within the SMB message. If ParameterCount is zero, the client/server MAY set this field to zero.windows always sets ParameterOffset to an offset location, relative to the start of the SMB Header , where the Trans_Parameters field should be. This behavior follows even if ParameterCount is zero."};
    USHORT DataCount
        with Documentation{Description = "The number of transaction data bytes being sent in this SMB message. If the transaction fits within a single SMB_COM_TRANSACTION2 request, then this value MUST be equal to TotalDataCount. Otherwise, the sum of the DataCount values in the primary and secondary transaction request messages MUST be equal to the smallest TotalDataCount value reported to the server. If the value of this field is less than the value of TotalDataCount, then at least one SMB_COM_TRANSACTION2_SECONDARY message MUST be used to transfer the remaining data bytes."};
    USHORT DataOffset
        with Documentation{Description = "The offset, in bytes, from the start of the SMB Header to the transaction data bytes. This MUST be the number of bytes from the start of the SMB message to the start of the SMB_Data.Bytes.Data field. Server implementations MUST use this value to locate the transaction data block within the SMB message. If DataCount is zero, the client/server MAY set this field to zero.windows always sets DataCount to a value of ParameterOffset + ParameterCount. This restricts the Trans_Data field to follow after the Trans_Parameters field, although this is not strictly a protocol requirement."};
    UCHAR SetupCount
        with Documentation{Description = "The number of setup words that are included in the transaction request."};
    UCHAR Reserved3 where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB", "Reserved3", "SmbComTransaction2Request", value)
        with Documentation{Description = "A padding byte. This field MUST be 0x00. Existing CIFS implementations MAY combine this field with SetupCount to form a USHORT. If SetupCount is defined as a USHORT, the high order byte MUST be0x00."};
    USHORT Subcommand
        with DisplayInfo{ToText = GetSubcommandString},
        Documentation{Description = "An array of two-byte words that provide transaction context to the server. The size and content of the array are specific to individual subcommands.SMB_COM_TRANSACTION2 messages MAY exceed the maximum size of a single SMB message (as determined by the value of the MaxBufferSize session parameter). If this is the case, then the client MUST use one or more SMB_COM_TRANSACTION2_SECONDARY messages to transfer transaction Data and Parameter bytes that did not fit in the initial message."};
    USHORT ByteCount
        with Documentation{Description = "The number of bytes in the SMB_Data.Bytes array."};
    // This field is present but not used in SMB_COM_TRANSACTION2 requests.
    //optional [|IsFlags2Unicode|] UCHAR Pad;
    //SmbString[IsFlags2Unicode] Name
    //    with Documentation{Description = "The pathname of the mailslot or named pipe to which the transaction subcommand applies, or a client-supplied identifier that provides a name for the transaction. See the individual SMB_COM_TRANSACTION subprotocol subcommand descriptions for information about the value set for each subcommand. If the field is not specified in the section for the subcommands, the field SHOULD be set to \\pipe\\. If SMB_FLAGS2_UNICODE is set in the Flags2 field of the SMB Header (section ) of the request, this field MUST be a null-terminated array of 16-bit Unicode characters which MUST be aligned to start on a 2-byte boundary from the start of the SMB header. Otherwise, this field MUST be a null-terminated array of OEM characters. The Name field MUST be the first field in this section."};
    optional binary Pad1 with Encoding{Ignore = true},
        Documentation{Description = "This field SHOULD be used as an array of padding bytes to align the following field to a 4-byte boundary. relative to the start of the SMB Header. This constraint can cause this field to be a zero-length field. This field SHOULD be set to zero by the client/server, and MUST be ignored by the server/client."};
    optional Trans2SubcommandRequestParameters[Subcommand, IsFlags2Unicode, ParameterCount] Trans2Parameters  with Encoding{Ignore = true},
        Documentation{Description = "Transaction parameter bytes. See the individual SMB_COM_TRANSACTION subprotocol subcommands descriptions for information on the parameters sent for each subcommand."};
    optional binary Pad2 with Encoding{Ignore = true},
        Documentation{Description = "This field SHOULD be used as an array of padding bytes to align the following field to a 4-byte boundary. relative to the start of the SMB  This can cause this field to be a zero-length field. This field SHOULD be set to zero by the client/server, and MUST be ignored by the server/client."};
    optional Trans2SubcommandRequestData Trans2Data with Encoding{Ignore = true},
        Documentation{Description = "Transaction data bytes. See the individual SMB_COM_TRANSACTION subprotocol subcommands descriptions for information on the data sent for each subcommand."};

    static string GetSubcommandString(any data)
    {
        USHORT subcommand = data as USHORT;
        return (GetTransaction2SubcommandName(subcommand) + ", " + (subcommand as string) + "(" + DecToHexFormat(4, subcommand as ushort) + ")");
    }
    override string ToString()
    {
        string summary = "Subcommand: " + GetTransaction2SubcommandName(Subcommand);
        if (Trans2Parameters != nothing && (Subcommand in {0x00, 0x01, 0x02, 0x03, 0x05, 0x06, 0x07, 0x08, 0x0D}))
        {
            summary += ", " + Trans2Parameters.ToString();
        }
        return summary;
    }
}

pattern SmbComTransaction2RequestParametersWordsFlags = flags USHORT
{
    DisconnectTid = 0x0001
        with Documentation{Description = "If set, following the completion of the operation the server MUST disconnect the tree connect associated with the tree identifier (TID) field received in the SMB Header of this request. The client SHOULD NOT send a subsequent SMB_COM_TREE_DISCONNECT for this tree connect."},
    NoResponse    = 0x0002
        with Documentation{Description = "This is a one-way transaction. The server MUST attempt to complete the transaction, but SHOULD NOT send a response to the client.One way transactions are used only when communicating with Mailslots, which means that they never occur within CIFS sessions."},
    Reserved      = 0xFFFC
};

type SmbComTransaction2InterimResponse
{
    UCHAR WordCount where value == 0;
    USHORT ByteCount where value == 0;
}

// 2.2.4.46   SMB_COM_TRANSACTION2 (0x32)
type SmbComTransaction2Response[bool IsFlags2Unicode, optional ushort Subcommand, USHORT InfoLevel, bool ResumeKeyExist]
{
    UCHAR WordCount where value >= 10
        with Documentation{Description = "The value of Words.SetupCount plus 10 (0x0A). This value represents the total number of SMB parameter words and MUST be greater than or equal to 10 (0x0A)."};
    USHORT TotalParameterCount
        with Documentation{Description = "The total number of SMB_COM_TRANSACTION2 parameter bytes to be sent in this transaction response. This value can be reduced in any or all subsequent SMB_COM_TRANSACTION2 responses that are part of the same transaction. This value represents transaction parameter bytes, not SMB parameter words. Transaction parameter bytes are carried within in the SMB_data block."};
    USHORT TotalDataCount
        with Documentation{Description = "The total number of SMB_COM_TRANSACTION2 data bytes to be sent in this transaction response. This value MAY be reduced in any or all subsequent SMB_COM_TRANSACTION2 responses that are part of the same transaction. This value represents transaction data bytes, not SMB data bytes."};
    USHORT Reserved1 where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB", "Reserved1", "SmbComTransaction2Response", value)
        with Documentation{Description = "Reserved. This field MUST be 0x0000 in the client request. The server MUST ignore the contents of this field."};
    USHORT ParameterCount
        with Documentation{Description = "The number of transaction parameter bytes being sent in this SMB message. If the transaction fits within a single SMB_COM_TRANSACTION2 response, this value MUST be equal to TotalParameterCount. Otherwise, the sum of the ParameterCount values in the transaction response messages MUST be equal to the smallest TotalParameterCount value reported by the server. The ParameterCount field MUST be used to determine the number of transaction parameter bytes contained within the SMB message."};
    USHORT ParameterOffset
        with Documentation{Description = "The offset, in bytes, from the start of the SMB_Header to the transaction parameter bytes. This MUST be the number of bytes from the start of the SMB message to the start of the SMB_Data.Bytes.Parameters field. Server implementations MUST use this value to locate the transaction parameter block within the SMB message. If ParameterCount is zero, the client/server MAY set this field to zero.windows always sets ParameterOffset to an offset location, relative to the start of the SMB Header, where the Trans_Parameters field should be. This behavior follows even if ParameterCount is zero."};
    USHORT ParameterDisplacement
        with Documentation{Description = "The offset relative to all of the transaction parameter bytes in this transaction response at which this block of parameter bytes MUST be placed. This value MAY be used by the client to correctly reassemble the transaction parameters even if the SMB response messages are received out of order."};
    USHORT DataCount
        with Documentation{Description = "The number of transaction data bytes being sent in this SMB message. If the transaction fits within a single SMB_COM_TRANSACTION2 response, then this value MUST be equal to TotalDataCount. Otherwise, the sum of the DataCount values in the transaction response messages MUST be equal to the smallest TotalDataCount value reported by the server."};
    USHORT DataOffset
        with Documentation{Description = "The offset, in bytes, from the start of the SMB_Header to the transaction data bytes. This MUST be the number of bytes from the start of the SMB message to the start of the SMB_Data.Bytes.Data field. Server implementations MUST use this value to locate the transaction data block within the SMB message. If DataCount is zero, the client/server MAY set this field to zero.windows always sets DataCount to a value of ParameterOffset + ParameterCount. This action restricts the Trans_Data field to follow after the Trans_Parameters field, although this is not strictly a protocol requirement."};
    USHORT DataDisplacement
        with Documentation{Description = "The offset relative to all of the transaction data bytes in this transaction response at which this block of data bytes MUST be placed. This value MAY be used by the client to correctly reassemble the transaction data even if the SMB response messages are received out of order."};
    UCHAR SetupCount
        with Documentation{Description = "The number of setup words that are included in the transaction response."};
    UCHAR Reserved2 where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB", "Reserved2", "SmbComTransaction2Response", value)
        with Documentation{Description = "A padding byte. This field MUST be 0x00. If SetupCount is defined as a USHORT, the high order byte MUST be 0x00."};
    optional [|SetupCount > 0|] array<USHORT> Setup with BinaryEncoding{Length = SetupCount},
        Documentation{Description = "An array of two-byte words that provides transaction results from the server. The size and content of the array are specific to individual subcommands."};
    USHORT ByteCount
        with Documentation{Description = "The number of bytes in the SMB_Data.Bytes array, which follows."};
    optional [|ParameterOffset > 35 + WordCount * 2|] binary Pad1 with BinaryEncoding{Length = (ParameterOffset - 32 - WordCount * 2 - 3)},
        Documentation{Description = "This field SHOULD be used as an array of padding bytes to align the following field to a 4-byte boundary relative to the start of the SMB  This can cause this field to be a zero-length field. This field SHOULD be set to zero by the client/server and MUST be ignored by the server/client."};
    optional [|ParameterCount > 0|] ([|TotalParameterCount == ParameterCount && Subcommand != nothing && (Subcommand as ushort) == 0x00|] Trans2Open2ResponseParameters
        | [|TotalParameterCount == ParameterCount && Subcommand != nothing && (Subcommand as ushort) == 0x01|] Trans2FindFirst2ResponseParameters
        | [|TotalParameterCount == ParameterCount && Subcommand != nothing && (Subcommand as ushort) == 0x02|] Trans2FindNext2ResponseParameters
        | [|TotalParameterCount == ParameterCount && Subcommand != nothing && (Subcommand as ushort) == 0x05|] Trans2QueryPathInformationResponseParameters
        | [|TotalParameterCount == ParameterCount && Subcommand != nothing && (Subcommand as ushort) == 0x06|] Trans2SetPathInformationResponseParameters
        | [|TotalParameterCount == ParameterCount && Subcommand != nothing && (Subcommand as ushort) == 0x07|] Trans2QueryFileInformationResponseParameters
        | [|TotalParameterCount == ParameterCount && Subcommand != nothing && (Subcommand as ushort) == 0x08|] Trans2SetFileInformationResponseParameters
        | [|TotalParameterCount == ParameterCount && Subcommand != nothing && (Subcommand as ushort) == 0x0D|] Trans2CreateDirectoryResponseParameters
        | [|DataOffset != ParameterOffset|] Blob[ParameterCount as uint]) Trans2Parameters
        with Documentation{Description = "Transaction parameter bytes. See the individual SMB_COM_TRANSACTION2 subcommand descriptions for information on parameters returned by the server for each subcommand."};
    optional [|ParameterOffset > 0 ? DataOffset > ParameterOffset + ParameterCount : DataOffset > 35 + WordCount * 2|] binary Pad2 with BinaryEncoding{Length = (ParameterOffset > 0 ? DataOffset - ParameterOffset - ParameterCount : DataOffset - 35 - WordCount * 2)},
        Documentation{Description = "This field SHOULD be used as an array of padding bytes to align the following field to a 4 byte boundary relative to the start of the SMB Header. This constraint can cause this field to be a zero-length field. This field SHOULD be set to zero by the client/server and MUST be ignored by the server/client."};
    optional [|DataCount > 0|] ([|TotalDataCount == DataCount && Subcommand != nothing && Subcommand in {0x01, 0x02}|] SmbFindInfoLevels[InfoLevel, ResumeKeyExist, IsFlags2Unicode]
                | [|TotalDataCount == DataCount && Subcommand != nothing && (Subcommand as ushort) == 0x03|] SmbQueryFsInfoLevels[InfoLevel, IsFlags2Unicode, DataCount]
                | [|TotalDataCount == DataCount && Subcommand != nothing && Subcommand in {0x05, 0x07}|] SmbQueryInfoLevels[InfoLevel, DataCount]
                | binary) Trans2Data with // some frame may be insufficient data, so no length limited
        Documentation{Description = "Transaction data bytes. See the individual SMB_COM_TRANSACTION2 subcommand descriptions for information on data returned by the server for each subcommand.windows_nt_server sends an arbitrary number of additional bytes beyond the end of the SMB response message. These additional bytes can be ignored by the recipient."};
    override string ToString()
    {
        if (Trans2Parameters != nothing && ((Trans2Parameters is Trans2Open2ResponseParameters) || (Trans2Parameters is Trans2FindFirst2ResponseParameters) || (Trans2Parameters is Trans2FindNext2ResponseParameters)))
        {
            return Trans2Parameters.ToString();
        }
        return "";
    }
}

// 2.2.4.47   SMB_COM_TRANSACTION2_SECONDARY (0x33), no response message.
type SmbComTransaction2SecondaryRequest
{
    UCHAR WordCount where value == 0x09
        with Documentation{Description = "This value represents the total number of SMB parameter words and MUST be 0x09."};
    USHORT TotalParameterCount
        with Documentation{Description = "The total number of transaction parameter bytes to be sent to the server over the course of this transaction. This value MAY be less than or equal to the TotalParameterCount in preceding request messages that are part of the same transaction. This value represents transaction parameter bytes, not SMB parameter words."};
    USHORT TotalDataCount
        with Documentation{Description = "The total number of transaction data bytes to be sent to the server over the course of this transaction. This value MAY be less than or equal to the TotalDataCount in preceding request messages that are part of the same transaction. This value represents transaction data bytes, not SMB data bytes."};
    USHORT ParameterCount
        with Documentation{Description = "The number of transaction parameter bytes being sent in the SMB message. This value MUST be less than TotalParameterCount. The sum of the ParameterCount values across all of the request messages in a transaction MUST be equal to the TotalParameterCount reported in the last request message of the transaction."};
    USHORT ParameterOffset
        with Documentation{Description = "The offset, in bytes, from the start of the SMB_Header to the transaction parameter bytes contained in this SMB message. This MUST be the number of bytes from the start of the SMB message to the start of the SMB_Data.Bytes.Trans2_Parameters field. Server implementations MUST use this value to locate the transaction parameter block within the SMB message. If ParameterCount is zero, the client/server MAY set this field to zero.windows always sets ParameterOffset to an offset location, relative to the start of the SMB Header, where the Trans_Parameters field should be. This behavior follows even if ParameterCount is zero."};
    USHORT ParameterDisplacement
        with Documentation{Description = "The offset relative to all of the transaction parameter bytes sent to the server in this transaction at which this block of parameter bytes SHOULD be placed. This value can be used by the server to correctly reassemble the transaction parameters even if the SMB request messages are received out of order."};
    USHORT DataCount
        with Documentation{Description = "The number of transaction data bytes being sent in this SMB message. This value MUST be less than the value of TotalDataCount. The sum of the DataCount values across all of the request messages in a transaction MUST be equal to the smallest TotalDataCount value reported to the server."};
    USHORT DataOffset
        with Documentation{Description = "The offset, in bytes, from the start of the SMB_Header to the transaction data bytes contained in this SMB message. This MUST be the number of bytes from the start of the SMB message to the start of the SMB_Data.Bytes.Trans2_Data field. Server implementations MUST use this value to locate the transaction data block within the SMB message. If DataCount is zero, the client/server MAY set this field to zero.windows always sets DataCount to a value of ParameterOffset + ParameterCount. This action restricts the Trans_Data field to follow after the Trans_Parameters field, although this is not strictly a protocol requirement."};
    USHORT DataDisplacement
        with Documentation{Description = "The offset relative to all of the transaction data bytes sent to the server in this transaction at which this block of parameter bytes SHOULD be placed. This value MAY be used by the server to correctly reassemble the transaction data block even if the SMB request messages are received out of order."};
    USHORT Fid
        with Documentation{Description = "Either a valid File ID returned by a previous Open or Create operation, or 0xFFFF. A FID value of 0xFFFF is, by definition, an invalid FID and indicates that no FID is being sent in this request. See the individual descriptions of the Trans2 subcommands for specific information on the use of this field."};
    USHORT ByteCount
        with Documentation{Description = "The number of bytes in the SMB_Data.Bytes array, which follows."};
    optional [|ParameterOffset > 53|] binary Pad1 with BinaryEncoding{Length = (ParameterOffset - 53)},
        Documentation{Description = "This field SHOULD be used as an array of padding bytes to align the following field to a 4-byte boundary relative to the start of the SMB Header. This constraint can cause this field to be a zero-length field. This field SHOULD be set to zero by the client/server and MUST be ignored by the server/client."};
    optional [|ParameterCount > 0 && DataOffset != ParameterOffset|] binary Trans2SecondaryParameters with BinaryEncoding{Length = ParameterCount},
        Documentation{Description = "Transaction parameter bytes."};
    optional [|ParameterOffset > 0 ? DataOffset > ParameterOffset + ParameterCount : DataOffset > 35 + WordCount * 2|] binary Pad2 with BinaryEncoding{Length = (ParameterOffset > 0 ? DataOffset - ParameterOffset - ParameterCount : DataOffset - 35 - WordCount * 2)},
        Documentation{Description = "This field SHOULD be used as an array of padding bytes to align the following field to a 4-byte boundary relative to the start of the SMB Header. This constraint can cause this field to be a zero-length field. This field SHOULD be set to zero by the client/server and MUST be ignored by the server/client."};
    optional [|DataCount > 0|] binary Trans2SecondaryData with BinaryEncoding{Length = DataCount}, Documentation{Description = "Transaction data bytes."};
}

type SmbComTransaction2SecondaryResponse
{
}

// 2.2.4.48   SMB_COM_FIND_CLOSE2 (0x34)
type SmbComFindClose2Request
{
    UCHAR WordCount where value == 0x01
        with Documentation{Description = "This field MUST be 0x01."};
    USHORT Sid
        with Documentation{Description = "A search handle, also known as a Search ID (SID). This MUST be the SID value returned in the initial TRANS2_FIND_FIRST2 subcommand request."};
    USHORT ByteCount where value == 0x0000
        with Documentation{Description = "This field MUST be 0x0000. No data is sent by this message."};
}

// 2.2.4.48   SMB_COM_FIND_CLOSE2 (0x34)
type SmbComFindClose2Response
{
    UCHAR WordCount where value == 0x00
        with Documentation{Description = "This field MUST be 0x00. No parameters are sent by this message."};
    USHORT ByteCount where value == 0x0000
        with Documentation{Description = "This field MUST be 0x0000. No data is sent by this message."};
}

// 2.2.4.49   SMB_COM_FIND_NOTIFY_CLOSE (0x35)
// Message obsolated.

// 2.2.4.50   SMB_COM_TREE_CONNECT (0x70)
type SmbComTreeConnectRequest
{
    UCHAR WordCount where value == 0x00
        with Documentation{Description = "This field MUST be 0x00. No parameters are sent by this message."};
    USHORT ByteCount where value >= 0x0006
        with Documentation{Description = "This field MUST be greater than or equal to 0x0006."};
    DataBufferFormatCodes BufferFormat1 where value == 0x04
        with Documentation{Description = "A buffer format identifier. The value of this field MUST be 0x04."};
    string Path with BinaryEncoding{TextEncoding = TextEncoding.ASCII},
        Documentation{Description = "A null-terminated string that represents the server and share name of the resource to which the client is attempting to connect. This field MUST be encoded using Universal Naming Convention (UNC) syntax. The string MUST be a null-terminated array of OEM characters, even if the client and server have negotiated to use Unicode strings."};
    DataBufferFormatCodes BufferFormat2 where value == 0x04
        with Documentation{Description = "A buffer format identifier. The value of this field MUST be 0x04."};
    string Password with BinaryEncoding{TextEncoding = TextEncoding.ASCII},
        Documentation{Description = "A null-terminated string that represents a share password in plaintext form. The string MUST be a null-terminated array of OEM characters, even if the client and server have negotiated to use Unicode strings."};
    DataBufferFormatCodes BufferFormat3 where value == 0x04
        with Documentation{Description = "A buffer format identifier. The value of this field MUST be 0x04."};
    string Service with BinaryEncoding{TextEncoding = TextEncoding.ASCII},
        Documentation{Description = "A null-terminated string representing the type of resource that the client intends to access. This field MUST be a null-terminated array of OEM characters, even if the client and server have negotiated to use Unicode strings. The valid values for this field are as follows:"};
}

// 2.2.4.50   SMB_COM_TREE_CONNECT (0x70)
type SmbComTreeConnectResponse
{
    UCHAR WordCount where value == 0x02
        with Documentation{Description = "This field MUST be set to 0x02."};
    USHORT MaxBufferSize
        with Documentation{Description = "The maximum size, in bytes, of the largest SMB message that the server can receive. This is the size of the largest SMB message that the client can send to the server. SMB message size includes the size of the SMB Header, parameter, and data blocks. This size MUST NOT include any transport-layer framing or other transport-layer data."};
    USHORT Tid
        with Documentation{Description = "The newly generated Tree ID, used in subsequent CIFS client requests to refer to a resource relative to the SMB_Data.Bytes.Path specified in the request. Most access to the server requires a valid TID, whether the resource is password protected or not. The value 0xFFFF is reserved; the server MUST NOT return a TID value of 0xFFFF."};
    USHORT ByteCount where value == 0x0000
        with Documentation{Description = "This field MUST be 0x0000. No data is sent by this message."};
}

// 2.2.4.51   SMB_COM_TREE_DISCONNECT (0x71)
type SmbComTreeDisconnectRequest
{
    UCHAR WordCount where value == 0x00
        with Documentation{Description = "This field MUST be 0x00. No parameters are sent by this message."};
    USHORT ByteCount where value == 0x0000
        with Documentation{Description = "This field MUST be 0x0000. No data is sent by this message."};
}

// 2.2.4.51   SMB_COM_TREE_DISCONNECT (0x71)
type SmbComTreeDisconnectResponse
{
    UCHAR WordCount where value == 0x00
        with Documentation{Description = "This field MUST be 0x00. No parameters are sent by this message."};
    USHORT ByteCount where value == 0x0000
        with Documentation{Description = "This field MUST be 0x0000. No data is sent by this message."};
}

// 2.2.4.52   SMB_COM_NEGOTIATE (0x72)
type SmbComNegotiateRequest
{
    UCHAR WordCount where value == 0x00
        with Documentation{Description = "This field MUST be 0x00. No parameters are sent by this message."};
    USHORT ByteCount where value >= 0x0002
        with Documentation{Description = "This field MUST be greater than or equal to 0x0002."};
    array<SmbComNegotiateRequestDialects> Dialects with DisplayInfo{ToText = DialectArrayToText},
        Documentation{Description = "This is a variable length list of dialect identifiers in order of preference from least to most preferred. The client MUST list only dialects that it supports. The structure of the list entries is as follows:"};
}

type SmbComNegotiateRequestDialects
{
    DataBufferFormatCodes BufferFormat where value == 0x02
        with Documentation{Description = "This field MUST be 0x02. This is a buffer format indicator that identifies the next field as a null-terminated array of characters."};
    string DialectString with BinaryEncoding{TextEncoding = TextEncoding.ASCII},
        Documentation{Description = "A null-terminated string identifying an SMB dialect. A list of common dialects is presented in section."};
        
    override string ToString()
    {
        return DialectString;
    }
}

// 2.2.4.52   SMB_COM_NEGOTIATE (0x72)
type SmbComNegotiateResponse[bool IsFlags2Unicode]
{
    UCHAR WordCount where value >= 0x01
        with Documentation{Description = "The value of this field MUST be greater than or equal to 0x01."};
    USHORT DialectIndex
        with Documentation{Description = "The index of the dialect selected by the server from the list presented in the request. Dialect entries are numbered starting with 0x0000, so a DialectIndex value of 0x0000 indicates that the first entry in the list has been selected. If the server does not support any of the listed dialects, it MUST return a DialectIndex of 0XFFFF."};
    ([|WordCount == 0x11|] SmbComNegotiateResponseNTLanManager[IsFlags2Unicode]
        | [|WordCount == 0x0D|] SmbComNegotiateResponseLM21[IsFlags2Unicode]
        | SmbComNegotiateResponseExtend[WordCount as uint]) NTLanManager;
}

type SmbComNegotiateResponseNTLanManager[bool IsFlags2Unicode]
{
    SmbComNegotiateSecurityMode SecurityMode
        with Documentation{Description = "An 8-bit field indicating the security modes supported or required by the server."};
    USHORT MaxMpxCount
        with Documentation{Description = "The maximum number of outstanding SMB operations that the server supports. This value includes existing OpLocks, the NT_TRANSACT_NOTIFY_CHANGE subcommand, and any other commands that are pending on the server. If the negotiated MaxMpxCount is 0x0001, then OpLock support MUST be disabled for this session. The MaxMpxCount MUST be greater than 0x0000. This parameter has no specific relationship to the SMB_COM_READ_MPX and SMB_COM_WRITE_MPX commands."};
    USHORT MaxNumberVcs
        with Documentation{Description = "The maximum number of virtual circuits that can be established between the client and the server as part of the same SMB session."};
    ULONG MaxBufferSize
        with Documentation{Description = "The maximum size, in bytes, of the largest SMB message that the server can receive. This is the size of the largest SMB message that the client can send to the server. SMB message size includes the size of the SMB header, parameter, and data blocks. This size does not include any transport-layer framing or other transport-layer data. The server MUST provide a MaxBufferSize of 1024 (0x00000400) bytes (1Kbyte) or larger. If CAP_RAW_MODE is negotiated, the SMB_COM_WRITE_RAW command can bypass the MaxBufferSize limit. Otherwise, SMB messages sent to the server MUST have a total size less than or equal to the MaxBufferSize value. This includes AndX chained messages."};
    ULONG MaxRawSize
        with Documentation{Description = "This value specifies the maximum message size when the client sends an SMB_COM_WRITE_RAW Request (section 2.2.4.25.1), and the maximum message size that the server MUST NOT exceed when sending an SMB_COM_READ_RAW Response (section 2.2.4.22.2). This value is significant only if CAP_RAW_MODE is negotiated."};
    ULONG SessionKey
        with Documentation{Description = "The server SHOULD set the value to a token generated for the connection, as specified in SessionKey Generation (section 2.2.1.6.6)."};
    SmbCapabilities Capabilities
        with Documentation{Description = "A 32-bit field providing a set of server capability indicators. This bit field is used to indicate to the client which features are supported by the server. Any value not listed in the following table is unused. The server MUST set the unused bits to 0 in a response, and the client MUST ignore these bits."};
    FILETIME SystemTime
        with Documentation{Description = "The number of 100-nanosecond intervals that have elapsed since January 1, 1601, in Coordinated Universal Time (UTC) format."};
    SHORT ServerTimeZone
        with Documentation{Description = "A signed 16-bit signed integer that represents the server's time zone, in minutes, from UTC. The time zone of the server MUST be expressed in minutes, plus or minus, from UTC."};
    UCHAR ChallengeLength 
        where ValidationCheckEnumValue(value == 0x00 || value == 0x08, null, true, ReferenceType.Type, "SMB", "ChallengeLength", "SmbComNegotiateResponseNTLanManager", "0x00, 0x08", value)
        with Documentation{Description = "This field MUST be 0x00 or 0x08. The length of the random challenge used in challenge/response authentication. If the server does not support challenge/response authentication, this field MUST be 0x00. This field is often referred to in older documentation as EncryptionKeyLength."};
    USHORT ByteCount
        with Documentation{Description = "This field MUST be greater than or equal to 0x0001. If CAP_UNICODE has been negotiated, it MUST be greater than or equal to 0x0002."};
    optional [|(Capabilities & 0x80000000) == 0x00000000 && ChallengeLength == 0x08|] binary Challenge with BinaryEncoding{Length = ChallengeLength},
        Documentation{Description = "An array of unsigned bytes that MUST be ChallengeLength bytes long and MUST represent the server challenge. This array MUST NOT be null-terminated. This field is often referred to in older documentation as EncryptionKey."};
    optional [|(Capabilities & 0x80000000) == 0x00000000|] SmbString[true] DomainName
        with Documentation{Description = "The null-terminated name of the NT domain or workgroup to which the server belongs."};
    // In MS-CIFS, section 2.2.4.52.2, ByteCount (2 bytes):  The value of this field MUST be set to 0x0000. And in MS-CIFS, the ServerName field is not present.  
    // In MS-SMB, section 2.2.4.5.2.2, In order to determine whether the SMB_Data.Bytes.ServerName field is present, the client MUST check the SMB_Data.ByteCount field to determine whether additional data is present beyond the NULL terminator of the SMB_Data.Bytes.DomainName string.
    // So, we can determine the presence of ServerName by checking if there is additional data after DomainName field.   
    optional [|(Capabilities & 0x80000000) == 0x00000000 && ByteCount > ChallengeLength + 2 * (1 + (DomainName as SmbString).Value.Count)|] SmbString[true] ServerName
        with Documentation{Description = "A variable-length, NULL-terminated Unicode string that contains the name of the Server."};
    optional [|(Capabilities & 0x80000000) == 0x80000000|] guid ServerGuid
        with Documentation{Description = "This field MUST be a GUID generated by the server to uniquely identify this server. This field SHOULD NOT be used by a client as a secure method of identifying a server because it can be forged. A client SHOULD use this information to detect whether connections to different textual names resolve to the same target server when direct TCP is used. This knowledge can then be used to set the SMB_Parameters.Words.VcNumber field in the SMB_COM_SESSION_SETUP_ANDX request (see [MS-CIFS] section 2.2.4.53.1)."};
    optional [|(Capabilities & 0x80000000) == 0x80000000|] (binary | GssapiType) SecurityBlob with BinaryEncoding{Length = (ByteCount - 16)},
        Documentation{Description = "A security binary large object (BLOB) that SHOULD contain an authentication token as produced by the GSS protocol (as specified in section 3.2.4.2.4 and [RFC2743])."};
}

pattern SmbCapabilities = flags ULONG
{
    CapRawMode                 = 0x00000001
        with Documentation{Description = "The server supports SMB_COM_READ_RAW and SMB_COM_WRITE_RAW requests.<28> Raw mode is not supported over connectionless transports."},
    CapMpxMode                 = 0x00000002
        with Documentation{Description = "The server supports SMB_COM_READ_MPX and SMB_COM_WRITE_MPX requests.<29> MPX mode is supported only over connectionless transports."},
    CapUnicode                 = 0x00000004
        with Documentation{Description = "The server supports UTF-16LE Unicode strings."},
    CapLargeFiles              = 0x00000008
        with Documentation{Description = "The server supports large files with 64-bit offsets."},
    CapNTSmbs                  = 0x00000010
        with Documentation{Description = "The server supports SMB commands particular to the NT LAN Manager dialect."},
    CapRpcRemoteApis           = 0x00000020
        with Documentation{Description = "The server supports the use of remote procedure call [MS-RPCE] for remote API calls. Similar functionality would otherwise require use of the legacy Remote Administration Protocol, as specified in [MS-RAP]."},
    CapStatus32                = 0x00000040
        with Documentation{Description = "The server is capable of responding with 32-bit status codes in the Status field of the SMB header (for more information, see [MS-CIFS] 2.2.3.1). CAP_STATUS32 can also be referred to as CAP_NT_STATUS."},
    CapLevelIIOplocks          = 0x00000080
        with Documentation{Description = "The server supports level II opportunistic locks (oplocks)."},
    CapLockAndRead             = 0x00000100
        with Documentation{Description = "The server supports the SMB_COM_LOCK_AND_READ command requests."},
    CapNTFind                  = 0x00000200
        with Documentation{Description = "The server supports the TRANS2_FIND_FIRST2, TRANS2_FIND_NEXT2, and FIND_CLOSE2 command requests. This bit SHOULD<30> be set if CAP_NT_SMBS is set."},
    Reserved1                  = 0x00000C00,
    CapDfs                     = 0x00001000
        with Documentation{Description = "The server is aware of the DFS Referral Protocol, as specified in [MS-DFSC], and can respond to DFS referral requests. For more information, see [MS-CIFS] sections 2.2.6.16.1 and 2.2.6.16.2."},
    CapInfolevelPassthru       = 0x00002000
        with Documentation{Description = "The server supports pass-through Information Levels, as specified in section 2.2.2.3. This allows the client to pass Information Level structures in QUERY and SET operations.<31>"},
    CapLargeReadx              = 0x00004000
        with Documentation{Description = "The server supports large read operations. This capability affects the maximum size, in bytes, of the server buffer for sending an SMB_COM_READ_ANDX response to the client. "},
    CapLargeWritex             = 0x00008000
        with Documentation{Description = "The server supports large write operations. This capability affects the maximum size, in bytes, of the server buffer for receiving an SMB_COM_WRITE_ANDX client request. "},
    CapLwio                    = 0x00010000
        with Documentation{Description = "The server supports new light-weight I/O control (IOCTL) and file system control (FSCTL) operations. These operations are accessed using the NT_TRANSACT_IOCTL subcommand (section 2.2.7.2).<34>"},
    Reserved2                  = 0x007E0000,
    CapUnix                    = 0x00800000
        with Documentation{Description = "The server supports UNIX extensions.<35> For more information, see [SNIA]."},
    Reserved3                  = 0x01000000,
    CapCompressedData          = 0x02000000
        with Documentation{Description = "Reserved but not implemented.<36> The server supports compressed SMB packets."},
    Reserved4                  = 0x1C000000,
    CapDynamicReauth           = 0x20000000
        with Documentation{Description = "The server supports re-authentication, if required, as specified in sections 3.3.5.1 and 3.2.5.1.<37>"},
    CapPersistentHandles       = 0x40000000
        with Documentation{Description = "Reserved but not implemented.<38> The server supports persistent handles."},
    CapExtendedSecurity        = 0x80000000
        with Documentation{Description = "The server supports extended security for authentication, as specified in section 3.2.4.2.4. This bit is used in conjunction with the SMB_FLAGS2_EXTENDED_SECURITY SMB_Header.Flags2 flag, as specified in section 2.2.3.1."},
};

pattern SmbComNegotiateSecurityMode = flags byte
{
    NegotiateUserSecurity               = 0x01
        with Documentation{Description = "If clear (0), the server supports only Share Level access control. If set (1), the server supports only User Level access control."},
    NegotiateEncryptPasswords           = 0x02
        with Documentation{Description = "If clear, the server supports only plaintext password authentication. If set, the server supports challenge/response authentication."},
    NegotiateSecuritySignaturesEnabled  = 0x04
        with Documentation{Description = "If clear, the server does not support SMB security signatures. If set, the server supports SMB security signatures for this connection."},
    NegotiateSecuritySignaturesRequired = 0x08
        with Documentation{Description = "If clear, the security signatures are optional for this connection. If set, the server requires security signatures. This bit MUST be clear if the NEGOTIATE_SECURITY_SIGNATURES_ENABLED bit is clear."},
    Reserved                            = 0xF0
};

// http://www.cifs.org/mediawiki/images/b/b9/1992-02-29-SMB-LM21.pdf
// 2.1 NegProt Resp SMB
type SmbComNegotiateResponseLM21[bool IsFlags2Unicode]
{
    USHORT SecurityMode;
    USHORT MaxXmt;
    USHORT MaxMux;
    USHORT MaxVcs;
    USHORT BlkMode;
    ULONG SessionKey;
    SmbTime ServerTime;
    SmbDate ServerDate;
    SHORT ServerTimeZone;
    USHORT CryptKeyLength;
    USHORT Reserved;
    USHORT ByteCount;
    array<byte> CryptKey with BinaryEncoding{Length = CryptKeyLength};
    optional [|IsFlags2Unicode && CryptKeyLength % 2 > 0|] byte Pad;
    SmbString[IsFlags2Unicode] DomainName;
}

type SmbComNegotiateResponseExtend[uint WordCount]
{
    binary Words with BinaryEncoding{Length = ((WordCount - 1) * 2)};
    USHORT ByteCount;
    binary Bytes with BinaryEncoding{Length = ByteCount};
}

type SmbCommandUnknown
{
    UCHAR WordCount;
    binary Words with BinaryEncoding{Length = (WordCount * 2)};
    USHORT ByteCount;
    binary Bytes with BinaryEncoding{Length = ByteCount};
}

type SmbErrorResponse
{
    byte WordCount where value == 0x00;
    ushort ByteCount where value == 0x0000;
}

// 2.2.4.53   SMB_COM_SESSION_SETUP_ANDX (0x73)
type SmbComSessionSetupAndxRequest[bool IsFlags2Unicode]
{
    UCHAR WordCount where (value == 0x0A || value == 0x0D || value == 0x0C)
        with Documentation{Description = "The value of this field MUST be 0x0A, 0x0C or 0x0D."};
    UCHAR AndXCommand
        with Documentation{Description = "This field MUST be either the command code for the next SMB command in the packet or 0xFF."};
    UCHAR AndXReserved
        with Documentation{Description = "A reserved field. This MUST be set to 0x00 when this request is sent, and the server MUST ignore this value."};
    USHORT AndXOffset
        with Documentation{Description = "This field MUST be set to the offset in bytes from the start of the SMB Header to the start of the WordCount field in the next SMB command in this packet. This field is valid only if the AndXCommand field is not set to 0xFF. If AndXCommand is 0xFF, this field MUST be ignored by the server."};
    USHORT MaxBufferSize
        with Documentation{Description = "The maximum size, in bytes, of the largest SMB message that the client can receive. This is the size of the largest SMB message that the server can send to the client. SMB message size includes the size of the SMB header, parameter, and data blocks.windows_nt clients and servers always use a MaxBufferSize value that is a multiple of four (4). MaxBufferSize values, sent or received via SMB, are always rounded down to the nearest multiple of four before they are used. This is done by masking out the two lowest-order bits of the value: MaxBufferSize &= ~3;The default MaxBufferSize on windows clients is 4356 (0x1104) bytes (4KB + 260Bytes). The MaxBufferSize can be configured through the following registry setting:HKLM\\SYSTEM\\CurrentControlSet\\Services\\LanmanServer\\Parameters\\SizReqBufIf the client\'s MaxBufferSize value in a session setup request is below a system-specified minimum value, windows CIFS servers will fail the request and return ERRSRV/ERRerror. The default minimum acceptable MaxBufferSize value is 500 (0x1F4) bytes. This value can be modified using the following registry setting:HKEY_Local_Machine\\System\\CurrentControlSet\\Services\\LanManServer\\Parameters\\MinClientBufferSize This size MUST NOT include any transport-layer framing or other transport-layer data."};
    USHORT MaxMpxCount
        with Documentation{Description = "The maximum number of pending multiplexed requests supported by the client. This value MUST be less than or equal to the MaxMpxCount value provided by the server in the SMB_COM_NEGOTIATE response."};
    USHORT VcNumber
        with Documentation{Description = "The number of this VC (virtual circuit) between the client and the server. This field SHOULD be set to a value of 0x0000 for the first virtual circuit between the client and the server and it SHOULD be set to a unique nonzero value for each additional virtual circuit.windows-based CIFS servers set a limit for the MaxNumberVcs field in the SMB_COM_NEGOTIATE response to 0x01, but do not enforce this limit. This allows a CIFS client to establish more virtual circuits than allowed by the MaxNumberVcs field value. Because this limit is not enforced on windows, CIFS clients can ignore this limit and attempt to establish more than the number of virtual circuits allowed by this value. The windows behavior of the CIFS server allows a client to exceed this limit, but other server implementations can enforce this limit and not allow this to occur."};
    ULONG SessionKey
        with Documentation{Description = "The client MUST set this to be equal to the SessionKey field in the SMB_COM_NEGOTIATE response for this SMB connection.windows_nt_server ignores the client\'s SessionKey."};
    optional [|WordCount == 0x0C|] USHORT SecurityBlobLength
        with Documentation{Description = "[MS-SMB], Section 2.2.4.6.1: This value MUST specify the length in bytes of the variable-length SecurityBlob field that is contained within the request."};
    optional [|WordCount == 0x0A || WordCount == 0x0D|] USHORT OEMPasswordLen
        with Documentation{Description = "The length, in bytes, of the contents of the SMB_Data.OEMPassword field."};
    optional [|WordCount == 0x0D|] USHORT UnicodePasswordLen
        with Documentation{Description = "The length, in bytes, of the contents of the SMB_Data.UnicodePassword field."};
    ULONG Reserved// where value == 0x00000000
        with Documentation{Description = "Reserved. This field MUST be 0x00000000. The server MUST ignore the contents of this field."};
    optional [|WordCount == 0x0C || WordCount == 0x0D|] SmbCapabilities Capabilities
        with Documentation{Description = "A 32-bit field providing a set of client capability indicators. The client uses this field to report its own set of capabilities to the server. The client capabilities are a subset of the server capabilities.The windows_98 client sends only CAP_RAW_MODE and CAP_UNICODE. windows_nt clients send only CAP_NT_STATUS, CAP_UNICODE, CAP_LEVEL_II_OPLOCKS, and CAP_NT_SMBS (the latter implies CAP_NT_FIND). windows_nt_server checks only for the following capabilities in the client\'s SMB_COM_SESSION_SETUP_ANDX request: CAP_UNICODE, CAP_LARGE_FILES, CAP_NT_SMBS, CAP_NT_FIND, CAP_NT_STATUS, and CAP_LEVEL_II_OPLOCK.For some capabilities, it is not necessary for the client to indicate support for a server capability in order to use that capability. For example, windows_98 clients do not indicate support for DFS, but still request DFS referrals from the server if the server has indicated support."};
    USHORT ByteCount
        with Documentation{Description = "The number of bytes in the SMB_Data.Bytes array, which follows."};
    optional [|(WordCount == 0x0A || WordCount == 0x0D) && (OEMPasswordLen as uint) > 0|] binary OEMPassword with BinaryEncoding{Length = OEMPasswordLen as USHORT},
        Documentation{Description = "The contents of this field depends upon the authentication methods in use:"};
    optional [|WordCount == 0x0D && (UnicodePasswordLen as uint) > 0|] binary UnicodePassword with BinaryEncoding{Length = UnicodePasswordLen as USHORT},
        Documentation{Description = "The contents of this field depends upon the authentication methods in use:"};
    optional [|WordCount == 0x0C && (SecurityBlobLength as uint) > 0|] (binary | GssapiType | NlmpMessage) SecurityBlob with BinaryEncoding{Length = SecurityBlobLength as USHORT},
        Documentation{Description = "This field MUST be the authentication token sent to the server, as specified in section 3.2.4.2.4 and in [RFC2743]."};
    optional [|IsFlags2Unicode && (WordCount == 0x0D ? ((OEMPasswordLen as uint) + (UnicodePasswordLen as uint)) % 2 == 0 : (WordCount == 0x0A ? (OEMPasswordLen as uint) % 2 == 0 : (SecurityBlobLength as uint) % 2 == 0))|] UCHAR Pad
        with Documentation{Description = "Padding bytes. If Unicode support has been enabled and SMB_FLAGS2_UNICODE is set in SMB_Header.Flags2, this field MUST contain zero (0x00) or one null padding byte as needed to ensure that the AccountName string is aligned on a 16-bit boundary. This also forces alignment of subsequent strings without additional padding."};
    optional [|WordCount == 0x0A || WordCount == 0x0D|] SmbString[IsFlags2Unicode] AccountName
        with Documentation{Description = "The name of the account (username) with which the user authenticates."};
    optional [|WordCount == 0x0A || WordCount == 0x0D|] SmbString[IsFlags2Unicode] PrimaryDomain
        with Documentation{Description = "A string representing the desired authentication domain. This MAY be the empty string. If SMB_FLAGS2_UNICODE is set in the Flags2 field of the SMB Header of the request, this string MUST be a null-terminated array of 16-bit Unicode characters. Otherwise, this string MUST be a null-terminated array of OEM characters. If this string consists of Unicode characters, this field MUST be aligned to start on a 2-byte boundary from the start of the SMB header."};
    SmbString[IsFlags2Unicode] NativeOS
        with Documentation{Description = "A string representing the native operating system of the CIFS client. If SMB_FLAGS2_UNICODE is set in the Flags2 field of the SMB Header of the request, this string MUST be a null-terminated array of 16-bit Unicode characters. Otherwise, this string MUST be a null-terminated array of OEM characters. If this string consists of Unicode characters, this field MUST be aligned to start on a 2-byte boundary from the start of the SMB Header.windows CIFS clients set this field based on the version and service pack level of the windows operating system. A list of possible values for this field includes the following:Windows OS versionNativeOS stringwindows_nt_4_0Windows NT 1381windows_nt_3_51Windows NT 1057windows_98_seWindows 4.0"};
    //optional USHORT Padding where value == 0;
    SmbString[IsFlags2Unicode] NativeLanMan
        with Documentation{Description = "A string that represents the native LAN manager type of the client. If SMB_FLAGS2_UNICODE is set in the Flags2 field of the SMB header of the request, this string MUST be a null-terminated array of 16-bit Unicode characters. Otherwise, this string MUST be a null-terminated array of OEM characters. If this string consists of Unicode characters, this field MUST be aligned to start on a 2-byte boundary from the start of the SMB Header.windows CIFS clients set this field based on the version of the windows operating system. A list of possible values for this field includes the following:Windows OS versionNativeLanMan stringwindows_nt_4_0Windows NT 4.0windows_nt_3_51Windows NT 3.51windows_98_seWindows 4.0windows_nt clients add an extra string terminator following the NativeOS field, so the NativeLanMan string appears to be the empty string. If ByteCount indicates that there are more bytes in the SMB_Data.Data block, the additional bytes are the NativeLanMan string. The NativeLanMan string also contains an extra terminating null character."};
    optional binary AndXPadding with Encoding{Ignore = true};
}

// 2.2.4.53   SMB_COM_SESSION_SETUP_ANDX (0x73)
type SmbComSessionSetupAndxResponse[bool IsFlags2Unicode]
{
    UCHAR WordCount where (value == 0x03 || value == 0x04)
        with Documentation{Description = "The value of this field MUST be 0x03."};
    UCHAR AndXCommand
        with Documentation{Description = "The command code for the next SMB command in the packet. This value MUST be set to 0xFF if there are no additional SMB command responses in the server response packet."};
    UCHAR AndXReserved
        with Documentation{Description = "A reserved field. This MUST be set to 0x00 when this response is sent, and the client MUST ignore this field."};
    USHORT AndXOffset
        with Documentation{Description = "This field MUST be set to the offset in bytes from the start of the SMB Header to the start of the WordCount field in the next SMB command response in this packet. This field is valid only if the AndXCommand field is not set to 0xFF. If AndXCommand is 0xFF, this field MUST be ignored by the client."};
    SmbComSessionSetupAndxResponseParametersWordsAction Action
        with Documentation{Description = "A 16-bit field. The two lowest-order bits have been defined:"};
    optional [|WordCount == 0x04|] USHORT SecurityBlobLength
        with Documentation{Description = "[MS-SMB], Section 2.2.4.6.2:This value MUST specify the length, in bytes, of the variable-length SecurityBlob that is contained within the response."};
    USHORT ByteCount
        with Documentation{Description = "The sum of the lengths, in bytes, of the Pad, NativeOS, NativeLanMan, and PrimaryDomain fields."};
    optional [|WordCount == 0x04 && (SecurityBlobLength as USHORT) > 0|] (binary | GssapiType | NlmpMessage) SecurityBlob with BinaryEncoding{Length = SecurityBlobLength as USHORT},
        Documentation{Description = "[MS-SMB], Section 2.2.4.6.2: This value MUST specify the length, in bytes, of the variable-length SecurityBlob that is contained within the response."};
    optional [|IsFlags2Unicode && (WordCount != 0x04 || (WordCount == 0x04 && (SecurityBlobLength as USHORT) % 2 == 0))|] UCHAR Pad
        with Documentation{Description = "Padding bytes. If Unicode support has been enabled, this field MUST contain zero or one null padding byte as needed to ensure that the NativeOS field, which follows, is aligned on a 16-bit boundary."};
    SmbString[IsFlags2Unicode] NativeOS
        with Documentation{Description = "A string that represents the native operating system of the server. If SMB_FLAGS2_UNICODE is set in the Flags2 field of the SMB Header of the response, the string MUST be a null-terminated array of 16-bit Unicode characters. Otherwise, the string MUST be a null-terminated array of OEM characters. If the string consists of Unicode characters, this field MUST be aligned to start on a 2-byte boundary from the start of the SMB Header.Windows-based CIFS servers set this field based on the version and service pack level of the Windows operating system. The following table includes a list of possible values for this field:Windows OS versionNativeOS stringwindows_nt_3_51Windows NT 1057windows_nt_4_0Windows NT 1381windows_98_seWindows 4.0windows clients ignore the NativeOS field in the server response."};
    SmbString[IsFlags2Unicode] NativeLanMan
        with Documentation{Description = "A string that represents the native LAN Manager type of the server. If SMB_FLAGS2_UNICODE is set in the Flags2 field of the SMB header of the response, the string MUST be a null-terminated array of 16-bit Unicode characters. Otherwise, the string MUST be a null-terminated array of OEM characters. If the string consists of Unicode characters, this field MUST be aligned to start on a 2-byte boundary from the start of the SMB Header.Windows-based CIFS servers set this field based on the version of the Windows operating system. The following table lists possible values for this field:Windows OS versionNativeLanMan stringwindows_nt_3_51NT LAN Manager 3.51windows_nt_4_0NT LAN Manager 4.0windows_98_seWindows 4.0windows clients ignore the NativeLanMan field in the server response."};
    optional SmbStringWithLength PrimaryDomain with Encoding{Ignore = true},
        Documentation{Description = "A string representing the primary domain or workgroup name of the server. If SMB_FLAGS2_UNICODE is set in the Flags2 field of the SMB Header of the response, the string MUST be a null-terminated array of 16-bit Unicode characters. Otherwise, the string MUST be a null-terminated array of OEM characters. If the string consists of Unicode characters, this field MUST be aligned to start on a 2-byte boundary from the start of the SMB Header.windows clients ignore the PrimaryDomain field in the server response."};
    optional binary AndXPadding with Encoding{Ignore = true};
}

pattern SmbComSessionSetupAndxResponseParametersWordsAction = flags USHORT
{
    SmbSetupGuest        = 0x0001
        with Documentation{Description = "If clear (0), the user successfully authenticated and is logged in."},
    SmbSetupUseLanmanKey = 0x0002
        with Documentation{Description = "If clear, the NTLM user session key will be used for message signing (if enabled)."},
    Reserved             = 0xFFFC
};

// 2.2.4.54   SMB_COM_LOGOFF_ANDX (0x74)
type SmbComLogoffAndxRequest
{
    UCHAR WordCount where value == 0x02
        with Documentation{Description = "The value of this field MUST be 0x02."};
    UCHAR AndXCommand
        with Documentation{Description = "The secondary SMB command request in the packet. This value MUST be set to 0xFF if there are no additional SMB command requests in the client request packet."};
    UCHAR AndXReserved
        with Documentation{Description = "A reserved field. This MUST be set to 0x00 when this request is sent, and the server MUST ignore this value when the message is received."};
    USHORT AndXOffset
        with Documentation{Description = "This field MUST be set to the offset in bytes from the start of the SMB Header to the start of the WordCount field in the next SMB command in this packet. This field is valid only if the AndXCommand field is not set to 0xFF."};
    USHORT ByteCount where value == 0x0000
        with Documentation{Description = "This field MUST be 0x0000. No data is sent by this message."};
    optional binary AndXPadding with Encoding{Ignore = true};
}

// 2.2.4.54   SMB_COM_LOGOFF_ANDX (0x74)
type SmbComLogoffAndxResponse
{
    UCHAR WordCount where value == 0x02
        with Documentation{Description = "The value of this field MUST be 0x02."};
    UCHAR AndXCommand
        with Documentation{Description = "The secondary SMB command response in the packet. This value MUST be set to 0xFF if there are no additional SMB command responses in the server response packet."};
    UCHAR AndXReserved
        with Documentation{Description = "A reserved field. This MUST be set to 0x00 when this response is sent, and the client MUST ignore this value when the message is received."};
    USHORT AndXOffset
        with Documentation{Description = "This field MUST be set to the offset in bytes from the start of the SMB Header to the start of the WordCount field in the next SMB command in this packet. This field is valid only if the AndXCommand field is not set to 0xFF."};
    USHORT ByteCount where value == 0x0000
        with Documentation{Description = "This field MUST be 0x0000. No data is sent by this message."};
    optional binary AndXPadding with Encoding{Ignore = true};
}

// 2.2.4.55   SMB_COM_TREE_CONNECT_ANDX (0x75)
type SmbComTreeConnectAndxRequest[bool IsFlags2Unicode]
{
    UCHAR WordCount where value == 0x04
        with Documentation{Description = "The value of this field MUST be 0x04."};
    UCHAR AndXCommand
        with Documentation{Description = "The command code for the next SMB command in the packet. This value MUST be set to 0xFF if there are no additional SMB command requests in the request packet."};
    UCHAR AndXReserved
        with Documentation{Description = "A reserved field. This MUST be set to 0x00 when this request is sent, and the server MUST ignore this value."};
    USHORT AndXOffset
        with Documentation{Description = "This field MUST be set to the offset in bytes from the start of the SMB Header  to the start of the WordCount field of the next SMB command request in this packet. This field is valid only if the AndXCommand field is not set to 0xFF. If AndXCommand is 0xFF, this field MUST be ignored by the server."};
    SmbComTreeConnectAndxRequestParametersWordsFlags Flags
        with Documentation{Description = "A 16-bit field used to modify the SMB_COM_TREE_CONNECT_ANDX Request . The client MUST set reserved values to 0, and the server MUST ignore them."};
    USHORT PasswordLength
        with Documentation{Description = "This field MUST be the length, in bytes, of the SMB_Data.Bytes.Password field."};
    USHORT ByteCount where value >= 0x0003
        with Documentation{Description = "The value of this field MUST be 0x0003 or greater."};
    optional [|PasswordLength > 0|] binary Password  with BinaryEncoding{Length = PasswordLength}, Documentation{Description = "An array of bytes."};
    optional [|IsFlags2Unicode && PasswordLength % 2 == 0|] UCHAR Pad
        with Documentation{Description = "Padding bytes. If Unicode support has been enabled and SMB_FLAGS2_UNICODE is set in SMB_Header.Flags2, this field MUST contain zero or one null padding bytes as needed to ensure that the Path string is aligned on a 16-bit boundary."};
    SmbString[IsFlags2Unicode] Path
        with Documentation{Description = "A null-terminated string that represents the server and share name of the resource to which the client attempts to connect. This field MUST be encoded using Universal Naming Convention (UNC) syntax. If SMB_FLAGS2_UNICODE is set in the Flags2 field of the SMB Header of the request, the string MUST be a null-terminated array of 16-bit Unicode characters. Otherwise, the string MUST be a null-terminated array of OEM characters. If the string consists of Unicode characters, this field MUST be aligned to start on a 2-byte boundary from the start of the SMB Header. A path in UNC syntax would be represented by a string in the following form:"};
    string Service with BinaryEncoding{TextEncoding = TextEncoding.ASCII},
        Documentation{Description = "The type of resource that the client attempts to access. This field MUST be a null-terminated array of OEM characters even if the client and server have negotiated to use Unicode strings. The valid values for this field are as follows:"};
    optional binary AndXPadding with Encoding{Ignore = true};
}

pattern SmbComTreeConnectAndxRequestParametersWordsFlags = flags USHORT
{
    TreeConnectAndxDisconnectTid      = 0x0001
        with Documentation{Description = "If this bit is set and the SMB_Header.TID field of the request is valid, the tree connect specified by the SMB_Header.TID field of the request SHOULD be disconnected when the server sends the response. If this tree disconnect fails, the error SHOULD be ignored. If this bit is set and the SMB_Header.TID field of the request is invalid, the server MUST ignore this bit."},
    Reserved1                         = 0x0002
        with Documentation{Description = "Reserved. SHOULD be zero.windows_98 clients set this bit. windows_nt servers ignore the setting."},
    TreeConnectAndxExtendedSignatures = 0x0004
        with Documentation{Description = "If set, then the client is requesting signing key protection, as specified in sections 3.2.4.2.5 and 3.2.5.4."},
    TreeConnectAndxExtendedResponse   = 0x0008
        with Documentation{Description = "If set, then the client is requesting extended information in the SMB_COM_TREE_CONNECT_ANDX response."},
    Reserved2                         = 0xFFF0,
};

// 2.2.4.55   SMB_COM_TREE_CONNECT_ANDX (0x75)
type SmbComTreeConnectAndxResponse[bool IsFlags2Unicode]
{
    UCHAR WordCount where (value == 0x03 || value == 0x07)
        with Documentation{Description = "The value of this field MUST be 0x03."};
    UCHAR AndXCommand
        with Documentation{Description = "The command code for the next SMB command in the packet. This value MUST be set to 0xFF if there are no additional SMB command responses in the server response packet."};
    UCHAR AndXReserved
        with Documentation{Description = "A reserved field. This MUST be set to 0x00 when this response is sent, and the client MUST ignore this field."};
    USHORT AndXOffset
        with Documentation{Description = "This field MUST be set to the offset in bytes from the start of the SMB Header  to the start of the WordCount field in the next SMB command response in this packet. This field is valid only if the AndXCommand field is not set to 0xFF. If AndXCommand is 0xFF, this field MUST be ignored by the client."};
    SmbComTreeConnectAndxResponseParametersWordsOptionalSupport OptionalSupport
        with Documentation{Description = "A 16-bit field. The following OptionalSupport field flags are defined. Any combination of the following flags MUST be supported. All undefined values are considered reserved. The server SHOULD set them to 0, and the client MUST ignore them."};
    optional [|WordCount == 0x07|] FilePipePrinterAccessMask MaximalShareAccessRights
        with Documentation{Description = "This field MUST specify the maximum rights that the user has to this share based on the security enforced by the share. This field MUST be encoded in an ACCESS_MASK format, as specified in section 2.2.1.4"};
    optional [|WordCount == 0x07|] FilePipePrinterAccessMask GuestMaximalShareAccessRights
        with Documentation{Description = "This field MUST specify the maximum rights that the guest account has on this share based on the security enforced by the share. Note that the notion of a guest account is implementation specific."};
    USHORT ByteCount where value >= 0x0002
        with Documentation{Description = "The value of this field MUST be greater than or equal to 0x0002."};
    string Service with BinaryEncoding{TextEncoding = TextEncoding.ASCII},
        Documentation{Description = "The type of the shared resource to which the TID is connected. The Service field MUST be encoded as a null-terminated array of OEM characters, even if the client and server have negotiated to use Unicode strings. The valid values for this field are as follows."};
    optional [|IsFlags2Unicode && (Service == "LPT1:" || Service == "IPC")|] UCHAR Pad;
    SmbString[IsFlags2Unicode] NativeFileSystem
        with Documentation{Description = "The name of the file system on the local resource to which the returned TID is connected. If SMB_FLAGS2_UNICODE is set in the Flags2 field of the SMB Header of the response, this value MUST be a null-terminated string of Unicode characters. Otherwise, this field MUST be a null-terminated string of OEM characters. For resources that are not backed by a file system, such as the IPC$ share used for named pipes, this field MUST be set to the empty string.windows clients ignore the NativeFileSystem field in the server response."};
    optional binary AndXPadding with Encoding{Ignore = true};
}

pattern SmbComTreeConnectAndxResponseParametersWordsOptionalSupport = flags USHORT
{
    SmbSupportSearchBits  = 0x0001
        with Documentation{Description = "If set, the server supports the use of SMB_FILE_ATTRIBUTES exclusive search attributes in client requests."},
    SmbShareISINDfs       = 0x0002
        with Documentation{Description = "If set, this share is managed by DFS, as specified in [MS-DFSC]."},
    SmbCscMask            = 0x000C
        with Documentation{Description = "0 - SMB_CSC_CACHE_MANUAL_REINT; 1 - SMB_CSC_CACHE_AUTO_REINT; 2 - SMB_CSC_CACHE_VDO; 3 - SMB_CSC_NO_CACHING"},
    SmbUniqueFileName     = 0x0010
        with Documentation{Description = "If set, then the server is using long file names only and does not support short file names. If set, then the server allows the client to assume that there is no name aliasing for this share (in other words, a single file cannot have two different names). If set, then the server permits the client to cache directory enumerations and file metadata based on the pathname."},
    SmbExtendedSignatures = 0x0020
        with Documentation{Description = "If set, then the server is using signing key protection (see section 3.3.5.4), as requested by the client."},
    Reserved              = 0xFFC0,
};

pattern SmbComTreeConnectAndxResponseDataBytesService = enum string
{
    DiskShare = "A:"
        with Documentation{Description = "Disk Share"},
    PrinterShare = "LPT1:"
        with Documentation{Description = "Printer Share"},
    NamedPipe = "IPC"
        with Documentation{Description = "Named Pipe"},
    SerialCommunicationsDevice = "COMM"
        with Documentation{Description = "Serial Communications device"},
    AnyType = "?????"
        with Documentation{Description = "Matches any type of device or resource"},
};

// 2.2.4.56   SMB_COM_SECURITY_PACKAGE_ANDX (0x7E)
// Message obsolated.

// 2.2.4.57   SMB_COM_QUERY_INFORMATION_DISK (0x80)
type SmbComQueryInformationDiskRequest
{
    UCHAR WordCount where value == 0x00
        with Documentation{Description = "This field MUST be 0x00. No parameters are sent by this command."};
    USHORT ByteCount where value == 0x0000
        with Documentation{Description = "This field MUST be 0x0000. No data is sent by this command."};
}

// 2.2.4.57   SMB_COM_QUERY_INFORMATION_DISK (0x80)
type SmbComQueryInformationDiskResponse
{
    UCHAR WordCount where value == 0x05
        with Documentation{Description = "This field MUST be 0x05."};
    USHORT TotalUnits
        with Documentation{Description = "This field is a 16-bit unsigned value that represents the total count of logical allocation units available on the volume."};
    USHORT BlockPerUnit
        with Documentation{Description = "This field is a 16-bit unsigned value that represents the number of blocks per allocation unit for the volume."};
    USHORT BlockSize
        with Documentation{Description = "This field is a 16-bit unsigned value that represents the size in bytes of each allocation unit for the volume."};
    USHORT FreeUnits
        with Documentation{Description = "This field is a 16-bit unsigned value that represents the total number of free allocation units available on the volume."};
    USHORT Reserved
        with Documentation{Description = "This field is a 16-bit unsigned field and is reserved. The client SHOULD ignore this field."};
    USHORT ByteCount where value == 0x0000
        with Documentation{Description = "This field MUST be 0x0000. No data is sent by this message."};
}

// 2.2.4.58   SMB_COM_SEARCH (0x81)
type SmbComSearchRequest[bool IsFlags2Unicode]
{
    UCHAR WordCount where value == 0x02
        with Documentation{Description = "This field MUST be 0x02."};
    USHORT MaxCount
        with Documentation{Description = "The maximum number of directory entries to return. This value represents the maximum number of entries across the entirety of the search, not just the initial response."};
    SmbFileAttributes SearchAttributes
        with Documentation{Description = "An attribute mask used to specify the standard attributes a file MUST have in order to match the search. If the value of this field is 0x0000, then only normal files are returned. If the Volume Label attribute is set, the server MUST return only the volume label (the Volume Label attribute is exclusive). If the Directory, System, or Hidden attributes are specified, then those entries are returned in addition to the normal files. Exclusive search attributes (see section ) can also be set."};
    USHORT ByteCount where value >= 0x0005
        with Documentation{Description = "This field MUST be 0x0005 or greater."};
    DataBufferFormatCodes BufferFormat1 where value == 0x04
        with Documentation{Description = "This field MUST be 0x04, which indicates that a null-terminated SMB_STRING is to follow."};
    SmbString[IsFlags2Unicode] FileName
        with Documentation{Description = "A null-terminated SMB_STRING. This is the full directory path (relative to the TID) of the file(s) being sought. Only the final component of the path MAY contain wildcards. This string MAY be the empty string."};
    DataBufferFormatCodes BufferFormat2 where value == 0x05
        with Documentation{Description = "This field MUST be 0x05, which indicates a variable block is to follow."};
    USHORT ResumeKeyLength where value in {0x0000, 0x0015}
        with Documentation{Description = "This field MUST be either 0x0000 or 21 (0x0015). If the value of this field is 0x0000, this is an initial search request. The server MUST allocate resources to maintain search state so that subsequent requests MAY be processed. If the value of this field is 21 (0x0015), this request MUST be the continuation of a previous search, and the next field MUST contain a ResumeKey previously returned by the server."};
    optional [|ResumeKeyLength == 0x0015|] SmbResumeKey ResumeKey 
        with Documentation{Description = "SMB_Resume_Key If the value of ResumeKeyLength is 21 (0x0015), this field MUST contain a ResumeKey returned by the server in response to a previous SMB_COM_SEARCH request. The ResumeKey contains data used by both the client and the server to maintain the state of the search. The structure of the ResumeKey follows:"};
}

type SmbResumeKey
{
    UCHAR Reserved
        with Documentation{Description = "This field is reserved and MUST NOT be modified by the client. Older documentation is contradictory as to whether this field is reserved for client side or server side use. New server implementations SHOULD avoid using or modifying the content of this field.windows_nt systems define this UCHAR field as follows:bit 7 (mask 0x80): Reserved for client use.bits 5,6 (mask 0x60): Reserved for system use.bits 0-4 (mask 0x1F): Reserved for server use.The above definition agrees with [SMB-CORE] as well as [CIFS], and is used in Windows NT server. [XOPEN-SMB], however, declares this field as reserved for client use. The safest course for implementers is to avoid modifying the contents of this field, whether set by the client or the server."};
    binary ServerState with BinaryEncoding{Length = 16},
        Documentation{Description = "This field is maintained by the server and MUST NOT be modified by the client. The contents of this field are server-specific.windows_nt server makes use of the ServerState field as follows:ServerState  {  UCHAR FileName[8];  UCHAR FileExt[3];  UCHAR SearchID;  ULONG FileIndex;  }FileName (8 bytes): This is the name portion of the 8.3 format file name. The name is left-justified and space-padded.FileExt (3 bytes): This is the file extension of the 8.3 format file name. It is left-justified and space-padded.This 11-byte representation of the 8.3 format name is known as the \"packed\" format.SearchID (1 byte) : This is a one-byte search identifier used by the server to uniquely identify the search operation. The use of a one-byte field implies that the NT server can manage a maximum of 256 concurrent searches per SMB session.FileIndex (4 bytes): A server-specific index used to continue the search at the correct place in the remote directory."};
    uint ClientState
        with Documentation{Description = "This field MAY be used by the client to maintain state across a series of SMB_COM_SEARCH calls. The value provided by the client MUST be returned in each ResumeKey provided in the response. The contents of this field are client-specific."};
} with Documentation{Description = "SMB_Resume_Key If the value of ResumeKeyLength is 21 (0x0015), this field MUST contain a ResumeKey returned by the server in response to a previous SMB_COM_SEARCH request. The ResumeKey contains data used by both the client and the server to maintain the state of the search. The structure of the ResumeKey follows:"},
       Documentation {EmbeddedType = true};

// 2.2.4.58   SMB_COM_SEARCH (0x81)
type SmbComSearchResponse
{
    UCHAR WordCount where value == 0x01
        with Documentation{Description = "This field MUST be 0x01."};
    USHORT Count
        with Documentation{Description = "The number of directory entries returned in this response message. This value MUST be less than or equal to the value of MaxCount in the initial request."};
    USHORT ByteCount where value >= 0x0003
        with Documentation{Description = "This field MUST be greater than or equal to 0x0003."};
    DataBufferFormatCodes BufferFormat where value == 0x05
        with Documentation{Description = "This field MUST be 0x05, which indicates that a variable-size block is to follow."};
    USHORT DataLength
        with Documentation{Description = "The size, in bytes, of the DirectoryInformationData array, which follows. This field MUST be equal to 43 times the value of SMB_Parameters.Count."};
    array<SmbDirectoryInformation> DirectoryInformationData with BinaryEncoding{Length = (DataLength / 43)},
        Documentation{Description = "Array of SMB_Directory_Information An array of zero or more SMB_Directory_Information records. The structure and contents of these records is specified below. Note that the SMB_Directory_Information record structure is a fixed 43 bytes in length."};
}

// 2.2.4.59   SMB_COM_FIND (0x82)
type SmbComFindRequest[bool IsFlags2Unicode]
{
    UCHAR WordCount where value == 0x02
        with Documentation{Description = "This field MUST be 0x02."};
    USHORT MaxCount
        with Documentation{Description = "The maximum number of directory entries to return. This value represents the maximum number of entries across the entirety of the search, not just the initial response."};
    SmbFileAttributes SearchAttributes
        with Documentation{Description = "An attribute mask used to specify the standard attributes that a file MUST have to match the search. If the value of this field is 0x0000, then only normal files MUST be returned. If the Volume Label attribute is set, the server MUST return only the volume label (the Volume Label attribute is exclusive). If the Directory, System, or Hidden attributes are specified, then those entries MUST be returned in addition to the normal files. Exclusive search attributes (see section ) can also be set."};
    USHORT ByteCount where value >= 0x0005
        with Documentation{Description = "This field MUST be 0x0005 or greater."};
    DataBufferFormatCodes BufferFormat1 where value == 0x04
        with Documentation{Description = "This field MUST be 0x04, which indicates that a null-terminated ASCII string is to follow."};
    SmbString[IsFlags2Unicode] FileName
        with Documentation{Description = "A null-terminated character string. This is the full directory path (relative to the TID) of the file(s) being sought. Only the final component of the path MAY contain wildcards. This string MAY be the empty string."};
    DataBufferFormatCodes BufferFormat2 where value == 0x05
        with Documentation{Description = "This field MUST be 0x05, which indicates that a variable block is to follow."};
    USHORT ResumeKeyLength where value in {0x0000, 0x0015}
        with Documentation{Description = "This field MUST be either 0x0000 or 21 (0x0015). If the value of this field is 0x0000, then this is an initial search request. The server MUST allocate resources to maintain search state so that subsequent requests can be processed. If the value of this field is 21 (0x0015) then this request MUST be the continuation of a previous search, and the next field MUST contain a ResumeKey previously returned by the server."};
    optional [|ResumeKeyLength == 0x0015|] SmbResumeKey ResumeKey
        with Documentation{Description = "If the value of the ResumeKeyLength field is 21 (0x0015), this field MUST contain a ResumeKey returned by the server in response to a previous SMB_COM_SEARCH request. The ResumeKey contains data used by both the client and the server to maintain the state of the search. The structure of the ResumeKey follows."};
}

// 2.2.4.59   SMB_COM_FIND (0x82)
type SmbComFindResponse
{
    UCHAR WordCount where value == 0x01
        with Documentation{Description = "This field MUST be 0x01."};
    USHORT Count
        with Documentation{Description = "The number of directory entries returned in this response message. This value MUST be less than or equal to the value of MaxCount in the initial request."};
    USHORT ByteCount where value >= 0x0003
        with Documentation{Description = "This field MUST be greater than or equal to 0x0003."};
    DataBufferFormatCodes BufferFormat where value == 0x05
        with Documentation{Description = "This field MUST be 0x05, which indicates that a variable-size block is to follow."};
    USHORT DataLength
        with Documentation{Description = "The size, in bytes, of the DirectoryInformationData array, which follows. This field MUST be equal to 43 times the value of SMB_Parameters.ParaWords.Count."};
    array<SmbDirectoryInformation> DirectoryInformationData with BinaryEncoding{Length = (DataLength / 43)},
        Documentation{Description = "An array of zero or more SMB_Directory_Information records. The structure and contents of these records is specified below. Note that the SMB_Directory_Information record structure is a fixed 43 bytes in length."};
}

// 2.2.4.60   SMB_COM_FIND_UNIQUE (0x83)
type SmbComFindUniqueRequest[bool IsFlags2Unicode]
{
    UCHAR WordCount where value == 0x02
        with Documentation{Description = "This field MUST be 0x02."};
    USHORT MaxCount
        with Documentation{Description = "The maximum number of directory entries to return."};
    SmbFileAttributes SearchAttributes
        with Documentation{Description = "An attribute mask used to specify the standard attributes that a file MUST have in order to match the search. If the value of this field is 0, then only normal files MUST be returned. If the Volume Label attribute is set, then the server MUST only return the volume label. If the Directory, System, or Hidden attributes are specified, then those entries MUST be returned in addition to the normal files. Exclusive search attributes (see section ) can also be set."};
    USHORT ByteCount where value >= 0x0005
        with Documentation{Description = "This field MUST be 0x0005 or greater."};
    DataBufferFormatCodes BufferFormat1 where value == 0x04
        with Documentation{Description = "This field MUST be 0x04, which indicates that a null-terminated ASCII string is to follow."};
    SmbString[IsFlags2Unicode] FileName
        with Documentation{Description = "A null-terminated SMB_STRING. This is the full directory path (relative to the TID) of the file(s) being sought. Only the final component of the path MAY contain wildcards. This string MAY be the empty string."};
    DataBufferFormatCodes BufferFormat2 where value == 0x05
        with Documentation{Description = "This field MUST be 0x05, which indicates that a variable block is to follow."};
    UCHAR ResumeKeyLength where value == 0x0000
        with Documentation{Description = "This field MUST be 0x0000. No Resume Key is permitted in the SMB_COM_FIND_UNIQUE request. If the server receives an SMB_COM_FIND_UNIQUE request with a nonzero ResumeKeyLength, it MUST ignore this field."};
}

// 2.2.4.60   SMB_COM_FIND_UNIQUE (0x83)
type SmbComFindUniqueResponse
{
    UCHAR WordCount where value == 0x01
        with Documentation{Description = "This field MUST be 0x01."};
    USHORT Count
        with Documentation{Description = "The number of directory entries returned in this response message. This value MUST be less than or equal to the value of MaxCount in the initial request."};
    USHORT ByteCount where value >= 0x0003
        with Documentation{Description = "This field MUST be greater than or equal to 0x0003."};
    DataBufferFormatCodes BufferFormat where value == 0x05
        with Documentation{Description = "This field MUST be 0x05, which indicates that a variable-size block is to follow."};
    USHORT DataLength
        with Documentation{Description = "The size in bytes of the DirectoryInformationData array that follows. This field MUST be equal to 43 times the value of SMB_Parameters.ParaWords.Count."};
    array<SmbDirectoryInformation> DirectoryInformationData with BinaryEncoding{Length = (DataLength / 43)},
        Documentation{Description = "Array of SMB_Directory_Information An array of zero or more SMB_Directory_Information records. The structure and contents of these records is specified following. Note that the SMB_Directory_Information record structure is a fixed 43 bytes in length."};
}

type SmbDirectoryInformation
{
    SmbResumeKey ResumeKey
        with Documentation{Description = "This field is structured as described in SMB_COM_FIND. The client MUST ignore the contents of this field in an SMB_COM_FIND_UNIQUE response."};
    UCHAR FileAttributes
        with Documentation{Description = "These are the file system attributes of the file."};
    SmbTime LastWriteTime
        with Documentation{Description = "The time when the file was last modified. The SMB_TIME structure contains a set of bit fields indicating hours, minutes, and seconds (with a 2 second resolution)."};
    SmbDate LastWriteDate
        with Documentation{Description = "The date when the file was last modified. The SMB_DATE structure contains a set of bit fields indicating the year, month, and date."};
    ULONG FileSize
        with Documentation{Description = "The size of the file, in bytes. If the file is larger than (2 ^ 32 - 1) bytes in size, the server SHOULD return the least significant 32 bits of the file size."};
    string FileName with BinaryEncoding{TextEncoding = TextEncoding.ASCII, Length = 13},
        Documentation{Description = "The null-terminated 8.3 name format file name. The file name and extension, including the \'.\' delimiter MUST be left-justified in the field. The character string MUST be padded with \" \" (space) characters, as necessary, to reach 12 bytes in length. The final byte of the field MUST contain the terminating null character."};

    override string ToString()
    {
        return "Name: " + FileName;
    }
} with Documentation{Description = "Array of SMB_Directory_Information An array of zero or more SMB_Directory_Information records. The structure and contents of these records is specified following. Note that the SMB_Directory_Information record structure is a fixed 43 bytes in length."},
       Documentation {EmbeddedType = true};

// 2.2.4.61   SMB_COM_FIND_CLOSE (0x84)
type SmbComFindCloseRequest[bool IsFlags2Unicode]
{
    UCHAR WordCount where value == 0x02
        with Documentation{Description = "This field MUST be 0x02."};
    USHORT MaxCount
        with Documentation{Description = "This field has no meaning in this context. It SHOULDwindows clients set MaxCount to nonzero values. windows servers fail the request with STATUS_INVALID_SMB if MaxCount is 0x0000. be set to 0x0000 by the client and MUST be ignored by the server."};
    SmbFileAttributes SearchAttributes
        with Documentation{Description = "This field has no meaning in this context. It SHOULD be set to 0x0000 by the client and MUST be ignored by the server."};
    USHORT ByteCount where (value == 0x001A || value == 0x001B)
        with Documentation{Description = "This field MUST be 26 (0x001A)."};
    DataBufferFormatCodes BufferFormat1 where value == 0x04
        with Documentation{Description = "This field MUST be 0x04, which indicates that a null-terminated ASCII string follows."};
    SmbString[IsFlags2Unicode] FileName
        with Documentation{Description = "SMB_STRING A null-terminated SMB_STRING. This MUST be the empty string."};
    DataBufferFormatCodes BufferFormat2 where value == 0x05
        with Documentation{Description = "This field MUST be 0x05, which indicates that a variable block follows."};
    USHORT ResumeKeyLength where value == 0x0015
        with Documentation{Description = "This field MUST be 21 (0x0015)."};
    SmbResumeKey ResumeKey
        with Documentation{Description = "SMB_Resume_Key This MUST be the last ResumeKey returned by the server in the search being closed. See SMB_COM_FIND for a description of the SMB_Resume_Key data structure."};
}

// 2.2.4.61   SMB_COM_FIND_CLOSE (0x84)
type SmbComFindCloseResponse
{
    UCHAR WordCount where value == 0x01
        with Documentation{Description = "This field MUST be 0x01."};
    USHORT Count
        with Documentation{Description = "The server SHOULD set this field to 0x0000, and the client MUST ignore the value of this field. No entries are returned in the response."};
    USHORT ByteCount
        with Documentation{Description = "This field SHOULD be 0x0003."};
    // Windows NT servers set ByteCount field to 0x0000 and do not send the BufferFormat and DataLength fields.
    optional DataBufferFormatCodes BufferFormat with Encoding{Ignore = true},
        Documentation{Description = "If sent, this field MUST be 0x05, which indicates that a variable-size block follows."};
    optional USHORT DataLength with Encoding{Ignore = true},
        Documentation{Description = "If sent, this field MUST be 0x0000. No DirectoryInformationData records are returned."};
}

// 2.2.4.62   SMB_COM_NT_TRANSACT (0xA0)
type SmbComNTTransactRequest[bool IsFlags2Unicode]
{
    UCHAR WordCount where value >= 0x13
        with Documentation{Description = "This field MUST be greater than or equal to 0x13."};
    UCHAR MaxSetupCount
        with Documentation{Description = "Maximum number of setup bytes that the client will accept in the transaction reply. This field MUST be set as specified in the subsections of Transaction Subcommands. The server MUST NOT return more than this number of setup bytes."};
    USHORT Reserved1 where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB", "Reserved1", "SmbComNTTransactRequest", value)
        with Documentation{Description = "Two padding bytes. This field MUST be 0x0000. This field is used to align the next field to a 32-bit boundary."};
    ULONG TotalParameterCount
        with Documentation{Description = "The total number of SMB_COM_NT_TRANSACT parameter bytes to be sent in this transaction request. This value MAY be reduced in any or all subsequent SMB_COM_NT_TRANSACT_SECONDARY requests that are part of the same transaction. This value represents transaction parameter bytes, not SMB parameter words. Transaction parameter bytes are carried in the SMB_Data block of the SMB_COM_NT_TRANSACT request or in subsequent SMB_COM_NT_TRANSACT_SECONDARY requests."};
    ULONG TotalDataCount
        with Documentation{Description = "The total number of SMB_COM_NT_TRANSACT data bytes to be sent in this transaction request. This value MAY be reduced in any or all subsequent SMB_COM_NT_TRANSACT_SECONDARY requests that are part of the same transaction. This value represents transaction data bytes, not SMB data bytes."};
    ULONG MaxParameterCount
        with Documentation{Description = "The maximum number of parameter bytes that the client will accept in the transaction reply. This field MUST be set as specified in the subsections of Transaction Subcommands. The server MUST NOT return more than this number of parameter bytes."};
    ULONG MaxDataCount
        with Documentation{Description = "The maximum number of data bytes that the client will accept in the transaction reply. This field MUST be set as specified in the subsections of Transaction Subcommands. The server MUST NOT return more than this number of data bytes."};
    ULONG ParameterCount
        with Documentation{Description = "The number of transaction parameter bytes being sent in this SMB message. If the transaction fits within a single SMB_COM_NT_TRANSACT request, this value MUST be equal to TotalParameterCount. Otherwise, the sum of the ParameterCount values in the primary and secondary transaction request messages MUST be equal to the smallest TotalParameterCount value reported to the server. If the value of this field is less than the value of TotalParameterCount, then at least one SMB_COM_NT_TRANSACT_SECONDARY message MUST be used to transfer the remaining parameter bytes."};
    ULONG ParameterOffset
        with Documentation{Description = "The offset, in bytes, from the start of the SMB_Header to the transaction parameter bytes. This MUST be the number of bytes from the start of the SMB message to the start of the SMB_Data.Bytes.Parameters field. Server implementations MUST use this value to locate the transaction parameter block within the SMB message. If ParameterCount is zero, the client/server MAY set this field to zero."};
    ULONG DataCount
        with Documentation{Description = "The number of transaction data bytes being sent in this SMB message. If the transaction fits within a single SMB_COM_NT_TRANSACT request, then this value MUST be equal to TotalDataCount. Otherwise, the sum of the DataCount values in the primary and secondary transaction request messages MUST be equal to the smallest TotalDataCount value reported to the server. If the value of this field is less than the value of TotalDataCount, then at least one SMB_COM_NT_TRANSACT_SECONDARY message MUST be used to transfer the remaining data bytes."};
    ULONG DataOffset
        with Documentation{Description = "The offset, in bytes, from the start of the SMB Header (section 2.2.3.1) to the transaction data bytes. This MUST be the number of bytes from the start of the SMB message to the start of the SMB_Data.Bytes.Data field. Server implementations MUST use this value to locate the transaction data block within the SMB message. If DataCount is zero, the client/server MAY set this field to zero."};
    UCHAR SetupCount
        with Documentation{Description = "The number of setup words that are included in the transaction request."};
    USHORT Function
        with DisplayInfo{ToText = GetFunctionString},
        Documentation{Description = "The transaction subcommand code, which is used to identify the operation to be performed by the server."};
    optional [|SetupCount > 0|] ([|Function == 0x02|] NTTransactIoctlRequestSetup
            | [|Function == 0x04|]NTTransactNotifyChangeRequestSetup
            | Blob[(SetupCount * 2) as uint]) Setup
        with Documentation{Description = "An array of two-byte words that provides transaction context to the server. The size and content of the array are specific to the individual subcommands."};
    USHORT ByteCount
        with Documentation{Description = "The number of bytes in the SMB_Data.Bytes array, which follows."};
    optional [|ParameterOffset > 35 + WordCount * 2|] binary Pad1 with BinaryEncoding{Length = (ParameterOffset - 32 - WordCount * 2 - 3)},
        Documentation{Description = "This field SHOULD be used as an array of padding bytes to align the following field to a 4-byte boundary relative to the start of the SMB Header. This constraint can cause this field to be a zero-length field. This field SHOULD be set to zero by the client/server and MUST be ignored by the server/client."};
    optional [|ParameterCount > 0|] ([|DataOffset != ParameterOffset && Function == 0x01|] NTTransactCreateRequestNTTransParameters[IsFlags2Unicode]
                | [|DataOffset != ParameterOffset && Function == 0x03|] NTTransactSetSecurityDescRequestNTTransParameters
                | [|DataOffset != ParameterOffset && Function == 0x06|] NTTransactQuerySecurityDescRequestNTTransParameters
                | [|DataOffset != ParameterOffset && Function == 0x07|] NTTransactQueryQuotaRequestNTTransParameters
                | [|DataOffset != ParameterOffset && Function == 0x08|] NTTransactSetQuotaRequestNTTransParameters
                | [|DataOffset != ParameterOffset|]Blob[ParameterCount as uint]) NTTransParameters
        with Documentation{Description = "Transaction parameter bytes. See the individual SMB_COM_NT_TRANSACT subcommand descriptions for information on parameters sent for each subcommand."};
    optional [|ParameterOffset > 0 ? DataOffset > ParameterOffset + ParameterCount : DataOffset > 35 + WordCount * 2|] binary Pad2 with BinaryEncoding{Length = (ParameterOffset > 0 ? DataOffset - ParameterOffset - ParameterCount : DataOffset - 35 - WordCount * 2)},
        Documentation{Description = "This field SHOULD be used as an array of padding bytes to align the following field to a 4-byte boundary relative to the start of the SMB Header. This constraint can cause this field to be a zero-length field. This field SHOULD be set to zero by the client/server, and MUST be ignored by the server/client."};
    optional [|DataCount > 0|] ([|Function == 0x01|] NTTransactCreateRequestNTTransData[(NTTransParameters as NTTransactCreateRequestNTTransParameters[IsFlags2Unicode]).SecurityDescriptorLength, (NTTransParameters as NTTransactCreateRequestNTTransParameters[IsFlags2Unicode]).EALength]
                | [|Function == 0x03|] NTTransactSetSecurityDescRequestNTTransData
                | [|Function == 0x02 && (Setup as NTTransactIoctlRequestSetup).FunctionCode == 0x001440F2|] NTTransactIoctlFsctlSrvCopyChunkRequestNTTransData
                | [|Function == 0x07 && ((NTTransParameters as NTTransactQueryQuotaRequestNTTransParameters).SidListLength > 0 || (NTTransParameters as NTTransactQueryQuotaRequestNTTransParameters).StartSidLength > 0)|] FileGetQuotaInformationList
                | [|Function == 0x08|] FileQuotaInformationList
                | binary) NTTransData with BinaryEncoding{WidthForComposedType = DataCount * 8 as int, Length = DataCount},
        Documentation{Description = "Transaction data bytes. See the individual SMB_COM_NT_TRANSACT subcommand descriptions for information on data sent for each subcommand."};
      
    static string GetFunctionString(any data)
    {
        USHORT function = data as USHORT;
        return (GetNTTransactionSubcommandName(function) + ", " + (function as string) + "(" + DecToHexFormat(4, function as ushort) + ")");
    }
    override string ToString()
    {
        string summary = "Function: " + GetNTTransactionSubcommandName(Function);
        if (Setup != nothing && Setup is NTTransactNotifyChangeRequestSetup)
        {
            summary += ", " + Setup.ToString();
        }
        if (NTTransParameters != nothing && ((NTTransParameters is NTTransactCreateRequestNTTransParameters) || 
            (NTTransParameters is NTTransactSetSecurityDescRequestNTTransParameters) || (NTTransParameters is NTTransactQuerySecurityDescRequestNTTransParameters)))
        {
              summary += ", " +  NTTransParameters.ToString(); 
        }
        return summary;
    }
}

// 2.2.4.62   SMB_COM_NT_TRANSACT (0xA0)
type SmbComNTTransactResponse[bool IsFlags2Unicode, optional ushort Function, uint IoctlFunctionCode]
{
    UCHAR WordCount where value >= 0x12
        with Documentation{Description = "The value of Words.SetupCount plus 18 (0x12). This value represents the total number of SMB parameter words and MUST be greater than or equal to 18 (0x12)."};
    binary Reserved1 with BinaryEncoding{Length = 3},
        Documentation{Description = "Reserved. This field MUST be 0x000000 in the server response. The client MUST ignore the contents of this field."};
    ULONG TotalParameterCount
        with Documentation{Description = "The total number of SMB_COM_NT_TRANSACT parameter bytes to be sent in this transaction response. This value MAY be reduced in any or all subsequent SMB_COM_NT_TRANSACT responses that are part of the same transaction. This value represents transaction parameter bytes, not SMB parameter words. Transaction parameter bytes are carried within in the SMB_data block."};
    ULONG TotalDataCount
        with Documentation{Description = "The total number of SMB_COM_NT_TRANSACT data bytes to be sent in this transaction response. This value MAY be reduced in any or all subsequent SMB_COM_NT_TRANSACT responses that are part of the same transaction. This value represents transaction data bytes, not SMB data bytes."};
    ULONG ParameterCount
        with Documentation{Description = "The number of transaction parameter bytes being sent in this SMB message. If the transaction fits within a single SMB_COM_NT_TRANSACT response, then this value MUST be equal to TotalParameterCount. Otherwise, the sum of the ParameterCount values in the transaction response messages MUST be equal to the smallest TotalParameterCount value reported by the server."};
    ULONG ParameterOffset
        with Documentation{Description = "The offset, in bytes, from the start of the SMB_Header to the transaction parameter bytes. This MUST be the number of bytes from the start of the SMB message to the start of the SMB_Data.Bytes.Parameters field. Server implementations MUST use this value to locate the transaction parameter block within the SMB message. If ParameterCount is zero, the client/server MAY set this field to zero.windows always sets ParameterOffset to an offset location, relative to the start of the SMB Header , where the Trans_Parameters field should be. This behavior follows even if ParameterCount is zero."};
    ULONG ParameterDisplacement
        with Documentation{Description = "The offset, relative to all of the transaction parameter bytes in this transaction response, at which this block of parameter bytes MUST be placed. This value can be used by the client to correctly reassemble the transaction parameters even if the SMB response messages are received out of order."};
    ULONG DataCount
        with Documentation{Description = "The number of transaction data bytes being sent in this SMB message. If the transaction fits within a single SMB_COM_NT_TRANSACT response, then this value MUST be equal to TotalDataCount. Otherwise, the sum of the DataCount values in the transaction response messages MUST be equal to the smallest TotalDataCount value reported by the server."};
    ULONG DataOffset
        with Documentation{Description = "The offset, in bytes, from the start of the SMB_Header to the transaction data bytes. This MUST be the number of bytes from the start of the SMB message to the start of the SMB_Data.Bytes.Data field. Server implementations MUST use this value to locate the transaction data block within the SMB message. If DataCount is zero, the client/server MAY set this field to zero.windows always sets DataCount to a value of ParameterOffset + ParameterCount. This action restricts the Trans_Data field to follow after the Trans_Parameters field, although this is not strictly a protocol requirement."};
    ULONG DataDisplacement
        with Documentation{Description = "The offset, relative to all of the transaction data bytes in this transaction response, at which this block of data bytes MUST be placed. This value can be used by the client to correctly reassemble the transaction data even if the SMB response messages are received out of order."};
    UCHAR SetupCount
        with Documentation{Description = "The number of Setup words that are included in the transaction response."};
    optional [|SetupCount > 0|] array<USHORT> Setup with BinaryEncoding{Length = SetupCount},
        Documentation{Description = "An array of two-byte words that provides transaction results from the server. The size and content of the array are specific to individual subcommand."};
    USHORT ByteCount where value >= 0x0000
        with Documentation{Description = "This field MUST be greater than or equal to 0x0000."};
    optional [|ParameterOffset > 35 + WordCount * 2|] binary Pad1 with BinaryEncoding{Length = (ParameterOffset - 32 - WordCount * 2 - 3)},
        Documentation{Description = "This field SHOULD be used as an array of padding bytes to align the following field to a 4-byte boundary relative to the start of the SMB Header . This constraint can cause this field to be a zero-length field. This field SHOULD be set to zero by the client/server and MUST be ignored by the server/client."};
    optional [|ParameterCount > 0|] ([|TotalParameterCount == ParameterCount && Function != nothing && (Function as ushort) == 0x01|] NTTransactCreateResponseNTTransparameters[WordCount]
                | [|TotalParameterCount == ParameterCount && Function != nothing && (Function as ushort) == 0x04|] NTTransactNotifyChangeResponseNTTransParameters[IsFlags2Unicode]
                | [|TotalParameterCount == ParameterCount && Function != nothing && (Function as ushort) == 0x06|] NTTransactQuerySecurityDescResponseNTTransParameters
                | [|TotalParameterCount == ParameterCount && Function != nothing && (Function as ushort) == 0x07|] NTTransactQueryQuotaResponseNTTransParameters
                | [|DataOffset != ParameterOffset|] Blob[ParameterCount as uint]) Parameters
        with Documentation{Description = "Transaction parameter bytes. See the individual SMB_COM_NT_TRANSACT subcommand descriptions for information on parameters returned by the server for each subcommand."};
    optional [|ParameterOffset > 0 ? DataOffset > ParameterOffset + ParameterCount : DataOffset > 35 + WordCount * 2|] binary Pad2 with BinaryEncoding{Length = (ParameterOffset > 0 ? DataOffset - ParameterOffset - ParameterCount : DataOffset - 35 - WordCount * 2)},
        Documentation{Description = "This field SHOULD be used as an array of padding bytes to align the following field to a 4-byte boundary relative to the start of the SMB Header. This constraint can cause this field to be a zero-length field. This field SHOULD be set to zero by the client/server and MUST be ignored by the server/client."};
    optional [|DataCount > 0|] ([|TotalDataCount == DataCount && Function != nothing && (Function as ushort) == 0x02 && IoctlFunctionCode == 0x00144064|] FSCTL_SRV_ENUMERATE_SNAPSHOTSResponseNTTransData
            | [|TotalDataCount == DataCount && Function != nothing && (Function as ushort) == 0x02 && IoctlFunctionCode == 0x00140078|] FSCTL_SRV_REQUEST_RESUME_KEYResponseNTTransData
            | [|TotalDataCount == DataCount && Function != nothing && (Function as ushort) == 0x02 && IoctlFunctionCode == 0x001440F2|] FSCTL_SRV_COPYCHUNKResponseNTTransData
            | [|TotalDataCount == DataCount && Function != nothing && (Function as ushort) == 0x06|] NTTransactQuerySecurityDescResponseNTTransData
            | [|TotalDataCount == DataCount && Function != nothing && (Function as ushort) == 0x07|] FileQuotaInformationList
            | binary) Data with // some frame may be insufficient data, so no length limited
        Documentation{Description = "Transaction data bytes. See the individual SMB_COM_NT_TRANSACT subcommand descriptions for information on data returned by the server for each subcommand."};
} with Documentation{EmbeddedType = true};

// 2.2.4.63   SMB_COM_NT_TRANSACT_SECONDARY (0xA1), has no response message.
type SmbComNTTransactSecondaryRequest
{
    UCHAR WordCount where value == 0x12
        with Documentation{Description = "This value represents the total number of SMB parameter words and MUST be 0x12."};
    binary Reserved1 with BinaryEncoding{Length = 3},
        Documentation{Description = "Reserved. Used to align the following fields to a 32-bit boundary. This field MUST contain null padding bytes in the server response. The client MUST ignore the contents of this field."};
    ULONG TotalParameterCount
        with Documentation{Description = "The total number of transaction parameter bytes to be sent to the server over the course of this transaction. This value MAY be less than or equal to the TotalParameterCount in preceding request messages that are part of the same transaction. This value represents transaction parameter bytes, not SMB parameter words."};
    ULONG TotalDataCount
        with Documentation{Description = "The total number of transaction data bytes to be sent to the server over the course of this transaction. This value MAY be less than or equal to the TotalDataCount in preceding request messages that are part of the same transaction. This value represents transaction data bytes, not SMB data bytes."};
    ULONG ParameterCount
        with Documentation{Description = "The number of transaction parameter bytes being sent in the SMB message. This value MUST be less than TotalParameterCount. The sum of the ParameterCount values across all of the request messages in a transaction MUST be equal to the TotalParameterCount reported in the last request message of the transaction."};
    ULONG ParameterOffset
        with Documentation{Description = "The offset, in bytes, from the start of the SMB_Header to the transaction parameter bytes contained in this SMB message. This MUST be the number of bytes from the start of the SMB message to the start of the SMB_Data.Bytes.Parameters field. Server implementations MUST use this value to locate the transaction parameter block within the SMB message. If ParameterCount is zero, the client/server MAY set this field to zero.windows always sets ParameterOffset to an offset location, relative to the start of the SMB Header , where the Trans_Parameters field should be. This behavior follows even if ParameterCount is zero."};
    ULONG ParameterDisplacement
        with Documentation{Description = "The offset, relative to all of the transaction parameter bytes sent to the server in this transaction, at which this block of parameter bytes MUST be placed. This value can be used by the server to correctly reassemble the transaction parameters even if the SMB request messages are received out of order."};
    ULONG DataCount
        with Documentation{Description = "The number of transaction data bytes being sent in this SMB message. This value MUST be less than the value of TotalDataCount. The sum of the DataCount values across all of the request messages in a transaction MUST be equal to the smallest TotalDataCount value reported to the server."};
    ULONG DataOffset
        with Documentation{Description = "The offset, in bytes, from the start of the SMB_Header to the transaction data bytes contained in this SMB message. This MUST be the number of bytes from the start of the SMB message to the start of the SMB_Data.Bytes.Data field. Server implementations MUST use this value to locate the transaction data block within the SMB message. If DataCount is zero, the client/server MAY set this field to zero.windows always sets DataCount to a value of ParameterOffset + ParameterCount. This action restricts the Trans_Data field to follow after the Trans_Parameters field, although this is not strictly a protocol requirement."};
    ULONG DataDisplacement
        with Documentation{Description = "The offset, relative to all of the transaction data bytes sent to the server in this transaction, at which this block of parameter bytes MUST be placed. This value can be used by the server to correctly reassemble the transaction data block even if the SMB request messages are received out of order."};
    UCHAR Reserved2 where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB", "Reserved2", "SmbComNTTransactSecondaryRequest", value)
        with Documentation{Description = "Reserved. MUST be 0x00. The server MUST ignore the contents of this field."};
    USHORT ByteCount
        with Documentation{Description = "The number of bytes in the SMB_Data.Bytes array, which follows."};
    optional [|ParameterOffset > 71|] binary Pad1 with BinaryEncoding{Length = (ParameterOffset - 71)},
        Documentation{Description = "This field SHOULD be used as an array of padding bytes to align the following field to a 4-byte boundary relative to the start of the SMB Header . This constraint can cause this field to be a zero-length field. This field SHOULD be set to zero by the client/server and MUST be ignored by the server/client."};
    optional [|ParameterCount > 0 && DataOffset != ParameterOffset|] binary Parameters with BinaryEncoding{Length = ParameterCount},
        Documentation{Description = "Transaction parameter bytes."};
    optional [|ParameterOffset > 0 ? DataOffset > ParameterOffset + ParameterCount : DataOffset > 35 + WordCount * 2|] binary Pad2 with BinaryEncoding{Length = (ParameterOffset > 0 ? DataOffset - ParameterOffset - ParameterCount : DataOffset - 35 - WordCount * 2)},
        Documentation{Description = "This field SHOULD be used as an array of padding bytes to align the following field to a 4-byte boundary relative to the start of the SMB Header. This constraint can cause this field to be a zero-length field. This field SHOULD be set to zero by the client/server and MUST be ignored by the server/client."};
    optional [|DataCount > 0|] binary Data with BinaryEncoding{Length = DataCount}, Documentation{Description = "Transaction data bytes."};
} with Documentation{EmbeddedType = true};

type SmbComNTTransactSecondaryResponse
{}

// 2.2.4.64   SMB_COM_NT_CREATE_ANDX (0xA2)
type SmbComNTCreateAndxRequest[bool IsFlags2Unicode]
{
    UCHAR WordCount where value == 0x18
        with Documentation{Description = "This field MUST be 0x18."};
    UCHAR AndXCommand
        with Documentation{Description = "The command code for the next SMB command in the packet. This value MUST be set to 0xFF if there are no additional SMB commands in the client request packet."};
    UCHAR AndXReserved where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB", "AndXReserved", "SmbComNTCreateAndxRequest", value)
        with Documentation{Description = "A reserved field. This MUST be set to 0x00 when this request is sent, and the server MUST ignore this value when the message is received."};
    USHORT AndXOffset
        with Documentation{Description = "This field MUST be set to the offset in bytes from the start of the SMB Header to the start of the WordCount field in the next SMB command in this packet. This field is valid only if the AndXCommand field is not set to 0xFF. If AndXCommand is 0xFF, this field MUST be ignored by the server."};
    UCHAR Reserved
        with Documentation{Description = "An unused value that SHOULD be set to 0x00 when sent and MUST be ignored on receipt."};
    USHORT NameLength
        with Documentation{Description = "This field MUST be the length of the FileName field (see following) in bytes."};
    SmbComNTCreateAndxRequestParametersWordsFlags Flags
        with Documentation{Description = "A 32-bit field containing a set of flags that modify the client request. Unused bit fields SHOULD be set to 0 when sent and MUST be ignored on receipt."};
    ULONG RootDirectoryFid
        with Documentation{Description = "If nonzero, this value is the File ID of an opened root directory, and the FileName field MUST be handled as relative to the directory specified by this RootDirectoryFID. If this value is 0x00000000, the FileName field MUST be handled as relative to the root of the share (the TID). The RootDirectoryFID MUST have been acquired in a previous message exchange."};
    SmbComNTCreateAndxRequestParametersWordsDesiredAccess DesiredAccess
        with Documentation{Description = "A 32-bit field of flags that indicate standard, specific, and generic access rights. These rights are used in access-control entries (ACEs) and are the primary means of specifying the requested or granted access to an object. If this value is 0x00000000, it represents a request to query the attributes without accessing the file."};
    long AllocationSize
            with Documentation{Description = "The client MUST set this value to the initial allocation size of the file in bytes. The server MUST ignore this field if this request is to open an existing file. This field MUST be used only if the file is created or overwritten. The value MUST be set to 0x0000000000000000 in all other cases. This does not apply to directory-related requests. This is the number of bytes to be allocated, represented as a 64-bit integer value."};
    SmbExtFileAttr ExtFileAttributes
        with Documentation{Description = "This field contains the extended file attributes of the file being requested, encoded as an SMB_EXT_FILE_ATTR data type."};
    SmbComNTCreateAndxRequestParametersWordsShareAccess ShareAccess
        with Documentation{Description = "A 32-bit field that specifies how the file SHOULD be shared with other processes. The names in the table below are provided for reference use only. If ShareAccess values of FILE_SHARE_READ, FILE_SHARE_WRITE, or FILE_SHARE_DELETE are set for a printer file or a named pipe, the server SHOULD ignore these values. The value MUST be FILE_SHARE_NONE or some combination of the other values:"};
    SmbComNTCreateAndxRequestParametersWordsCreateDisposition CreateDisposition
        where ValidationCheckEnumValue(InRange<SmbComNTCreateAndxRequestParametersWordsCreateDisposition>(value), null, true, ReferenceType.Type, "SMB", "CreateDisposition", "SmbComNTCreateAndxRequest", "0x00000000,0x00000001, 0x00000002, 0x00000003, 0x00000004, 0x00000005", value)
            with Documentation{Description = "A 32-bit value that represents the action to take if the file already exists or if the file is a new file and does not already exist.Windows NT CIFS servers allow only the FILE_OPEN option on a named pipe. All other options are ignored and considered the same as FILE_OPEN. Windows NT CIFS servers do not allow clients to \"open\" or to \"create\" a mailslot."};
    SmbCreateOptions CreateOptions
        with Documentation{Description = "A 32-bit field containing flag options to use if creating the file or directory. This field MUST be set to 0x00000000 or a combination of the following possible values. Unused bit fields SHOULD be set to 0 when sent and MUST be ignored on receipt. The following is a list of the valid values and their associated behaviors. Server implementations SHOULD reserve all bits not specified in the following definitions."};
    SmbImpersonationLevel ImpersonationLevel where ValidationCheck(InRange<SmbImpersonationLevel>(value), null, DiagnosisLevel.Error, "SMB: The ImpersonationLevel field in type SmbComNTCreateAndxRequest is an undefined value. Please refer to SMB_COM_NT_CREATE_ANDX (0xA2) in Technical Document [MS-CIFS].")
        with Documentation{Description = "This field specifies the impersonation level requested by the application that is issuing the create request, and MUST contain one of the following values. The server MUST validate this field, but otherwise ignore it."};
    SmbSecurityFlags SecurityFlags
        with Documentation{Description = "An 8-bit field containing a set of options that specify the security tracking mode. These options specify whether the server is to be given a snapshot of the client\'s security context (called static tracking) or is to be continually updated to track changes to the client\'s security context (called dynamic tracking). When bit 0 of the SecurityFlags field is clear, static tracking is requested. When bit 0 of the SecurityFlags field is set, dynamic tracking is requested. Unused bit fields SHOULD be set to 0 when sent and MUST be ignored on receipt. This field MUST be set to 0x00 or a combination of the following possible values. Value names are provided for convenience only. Supported values are:"};
    USHORT ByteCount
        with Documentation{Description = "The length in bytes of the remaining SMB_Data. If SMB_FLAGS2_UNICODE is set in the Flags2 field of the SMB Header of the request, this field has a minimum value of 0x0003. If SMB_FLAGS2_UNICODE is not set, this field has a minimum value of 0x0002. This field MUST be the total length of the Name field, plus any padding added for alignment."};
    optional [|IsFlags2Unicode|] byte Pad;
    SmbString[IsFlags2Unicode] FileName
        with Documentation{Description = "A string that represents the fully qualified name of the file relative to the supplied TID to create or truncate on the server. If SMB_FLAGS2_UNICODE is set in the Flags2 field of the SMB Header of the request, the FileName string MUST be a null-terminated array of 16-bit Unicode characters. Otherwise, the FileName string MUST be a null-terminated array of extended ASCII (OEM) characters. "};
    optional binary AndXPadding with Encoding{Ignore = true};
}

pattern SmbImpersonationLevel = enum ULONG
{
    SECURITY_ANONYMOUS = 0x00000000,
    SECURITY_IDENTIFICATION = 0x00000001,
    SECURITY_IMPERSONATION = 0x00000002,
    SECURITY_DELEGATION = 0x00000003,
    ...
} with Documentation{EmbeddedType = true};

pattern SmbComNTCreateAndxRequestParametersWordsCreateDisposition = enum ULONG
{
    FileSupersede = 0x00000000
        with Documentation{Description = "(No bits set.)\nIf the file already exists, it SHOULD be superseded (overwritten). If it does not already exist, then it SHOULD be created."},
    FileOpen = 0x00000001
        with Documentation{Description = "If the file already exists, it SHOULD be opened rather than created. If the file does not already exist, the operation MUST fail."},
    FileCreate = 0x00000002
        with Documentation{Description = "If the file already exists, the operation MUST fail. If the file does not already exist, it SHOULD be created."},
    FileOpenIf = 0x00000003
        with Documentation{Description = "If the file already exists, it SHOULD be opened. If the file does not already exist, then it SHOULD be created. This value is equivalent to (FILE_OPEN | FILE_CREATE)."},
    FileOverwrite = 0x00000004
        with Documentation{Description = "If the file already exists, it SHOULD be opened and truncated. If the file does not already exist, the operation MUST fail. The client MUST open the file with at least GENERIC_WRITE access for the command to succeed."},
    FileOverwriteIf = 0x00000005
        with Documentation{Description = "If the file already exists, it SHOULD be opened and truncated. If the file does not already exist, it SHOULD be created. The client MUST open the file with at least GENERIC_WRITE access."},
    ...
} with Documentation{EmbeddedType = true};

pattern SmbComNTCreateAndxRequestParametersWordsShareAccess = flags ULONG
{
    FileShareRead   = 0x00000001
        with Documentation{Description = "Other open operations can be performed on the file for read access."},
    FileShareWrite  = 0x00000002
        with Documentation{Description = "Other open operations can be performed on the file for write access."},
    FileShareDelete = 0x00000004
        with Documentation{Description = "Other open operations can be performed on the file for delete access."},
    Reserved        = 0xFFFFFFF8,
} with Documentation{EmbeddedType = true};

pattern SmbComNTCreateAndxRequestParametersWordsDesiredAccess = flags ULONG
{
    FileReadData         = 0x00000001
        with Documentation{Description = "Indicates the right to read data from the file."},
    FileWriteData        = 0x00000002
        with Documentation{Description = "Indicates the right to write data into the file beyond the end of the file."},
    FileAppendData       = 0x00000004
        with Documentation{Description = "Indicates the right to append data to the file beyond the end of the file only."},
    FileReadEa           = 0x00000008
        with Documentation{Description = "Indicates the right to read the extended attributes (EAs) of the file."},
    FileWriteEa          = 0x00000010
        with Documentation{Description = "Indicates the right to write or change the extended attributes (EAs) of the file."},
    FileExecute          = 0x00000020
        with Documentation{Description = "Indicates the right to execute the file."},
    Reserved1            = 0x00000040,
    FileReadAttributes   = 0x00000080
        with Documentation{Description = "Indicates the right to read the attributes of the file."},
    FileWriteAttributes  = 0x00000100
        with Documentation{Description = "Indicates the right to change the attributes of the file."},
    Reserved2            = 0x0000FE00,
    Delete               = 0x00010000
        with Documentation{Description = "Indicates the right to delete or to rename the file."},
    ReadControl          = 0x00020000
        with Documentation{Description = "Indicates the right to read the security descriptor of the file."},
    WriteDac             = 0x00040000
        with Documentation{Description = "Indicates the right to change the discretionary access control list (DACL) in the security descriptor of the file."},
    WriteOwner           = 0x00080000
        with Documentation{Description = "Indicates the right to change the owner in the security descriptor of the file."},
    SYNCHRONIZE          = 0x00100000
        with Documentation{Description = "SHOULD NOT be used by the sender and MUST be ignored by the receiver."},
    Reserved3            = 0x00E00000,
    AccessSystemSecurity = 0x01000000
        with Documentation{Description = "Indicates the right to read or change the system access control list (SACL) in the security descriptor for the file. If the SE_SECURITY_NAME privilege is not set in the access token, the server MUST fail the open request and return STATUS_PRIVILEGE_NOT_HELD."},
    MaximumAllowed       = 0x02000000
        with Documentation{Description = "Indicates that the client requests an open to the file with the highest level of access that the client has on this file. If no access is granted for the client on this file, the server MUST fail the open and return a STATUS_ACCESS_DENIED."},
    Reserved4            = 0x0C000000,
    GenericAll           = 0x10000000
        with Documentation{Description = "Indicates a request for all of the access flags that are previously listed except MAXIMUM_ALLOWED and ACCESS_SYSTEM_SECURITY."},
    GenericExecute       = 0x20000000
        with Documentation{Description = "Indicates a request for the following combination of access flags listed previously in this table: \nFILE_READ_ATTRIBUTES, FILE_EXECUTE, SYNCHRONIZE, and READ_CONTROL."},
    GenericWrite         = 0x40000000
        with Documentation{Description = "Indicates a request for the following combination of access flags listed previously in this table: FILE_WRITE_DATA, FILE_APPEND_DATA, SYNCHRONIZE, FILE_WRITE_ATTRIBUTES, and FILE_WRITE_EA."},
    GenericRead          = 0x80000000
        with Documentation{Description = "Indicates a request for the following combination of access flags listed previously in this table: \n FILE_READ_DATA, FILE_READ_ATTRIBUTES, FILE_READ_EA, and SYNCHRONIZE."},
} with Documentation{EmbeddedType = true};

pattern SmbComNTCreateAndxRequestParametersWordsFlags = flags ULONG
{
    Reserved1                       = 0x00000001,
    NTCreateRequestOplock           = 0x00000002
        with Documentation{Description = "If set, the client requests an exclusive OpLock."},
    NTCreateRequestOpbatch          = 0x00000004
        with Documentation{Description = "If set, the client requests an exclusive batch OpLock."},
    NTCreateOpenTargetDir           = 0x00000008
        with Documentation{Description = "If set, the client indicates that the parent directory of the target is to be opened."},
    NTCreateRequestExtendedResponse = 0x00000010
        with Documentation{Description = "If set, then the client is requesting extended information in the response."},
    Reserved                        = 0xFFFFFFE0,
} with Documentation{EmbeddedType = true};


// 2.2.4.64   SMB_COM_NT_CREATE_ANDX (0xA2)
type SmbComNTCreateAndxResponse
{
    UCHAR WordCount where (value == 0x22 || value == 0x2A)
        with Documentation{Description = "This field MUST be 0x22 or 0x2A."};
    UCHAR AndXCommand
        with Documentation{Description = "The command code for the next SMB command in the packet. This value MUST be set to 0xFF if there are no additional SMB command responses in the server response packet."};
    UCHAR AndXReserved where ValidationCheckReservedZero(value == 0, null, true, ReferenceType.Type, "SMB", "AndXReserved", "SmbComNTCreateAndxResponse", value)
        with Documentation{Description = "A reserved field. The server MUST set this field to 0x00 when this response is sent, and the client MUST ignore this field."};
    USHORT AndXOffset
        with Documentation{Description = "This field MUST be set to the offset in bytes from the start of the SMB Header to the start of the WordCount field in the next SMB command response in this packet. This field is valid only if the AndXCommand field is not set to 0xFF. If AndXCommand is 0xFF, this field MUST be ignored by the client."};
    SmbOpLockLevel OpLockLevel
        with Documentation{Description = "The OpLock level granted to the client process."};
    USHORT Fid
        with Documentation{Description = "A FID representing the file or directory that was created or opened."};
    SmbComNTCreateAndxResponseParametersWordsCreateDisposition CreateDisposition
        where ValidationCheckEnumValue(InRange<SmbComNTCreateAndxRequestParametersWordsCreateDisposition>(value), null, true, ReferenceType.Type, "SMB", "CreateDisposition", "SmbComNTCreateAndxResponse", "0x00000000,0x00000001, 0x00000002, 0x00000003, 0x00000004, 0x00000005", value)
            with Documentation{Description = "A 32-bit value that represents the action to take if the file already exists or if the file is a new file and does not already exist."};
    FILETIME CreateTime
        with Documentation{Description = "A 64-bit integer value representing the time that the file was created. The time value is a signed 64-bit integer representing either an absolute time or a time interval. Times are specified in units of 100ns. A positive value expresses an absolute time, where the base time (the 64- bit integer with value 0x0000000000000000) is the beginning of the year 1601 AD in the Gregorian calendar. A negative value expresses a time interval relative to some base time, usually the current time."};
    FILETIME LastAccessTime
        with Documentation{Description = "The time that the file was last accessed encoded in the same format as CreateTime."};
    FILETIME LastWriteTime
        with Documentation{Description = "The time that the file was last written, encoded in the same format as CreateTime."};
    FILETIME LastChangeTime
        with Documentation{Description = "The time that the file was last changed, encoded in the same format as CreateTime."};
    SmbExtFileAttr ExtFileAttributes
        with Documentation{Description = "This field contains the extended file attributes that the server assigned to the file or directory as a result of the command, encoded as an SMB_EXT_FILE_ATTR data type."};
    LARGE_INTEGER AllocationSize
        with Documentation{Description = "The number of bytes allocated to the file by the server."};
    LARGE_INTEGER EndOfFile
        with Documentation{Description = "The end of file offset value."};
    SmbComNTCreateAndxResponseResourceType ResourceType
        with Documentation{Description = "The file type. This field MUST be interpreted as follows."};
    SmbNMPipeStatus NmpipeStatus
        with Documentation{Description = "A 16-bit field that shows the status of the named pipe if the resource type opened is a named pipe. This field is formatted as an SMB_NMPIPE_STATUS."};
    UCHAR Directory
        with Documentation{Description = "If the returned FID represents a directory, the server MUST set this value to a nonzero value (0x01 is commonly used). If the FID is not a directory, the server MUST set this value to 0x00 (FALSE)."};
    optional [|WordCount == 0x2A|] guid VolumeGuid
        with Documentation{Description = "This field MUST be a GUID value that uniquely identifies the volume on which the file resides."};
    optional [|WordCount == 0x2A|] LARGE_INTEGER FileID
        with Documentation{Description = "This field MUST be a 64-bit opaque value that uniquely identifies this file on a volume."};
    optional [|WordCount == 0x2A|] ULONG MaximalAccessRights with DisplayInfo{ToText = GetAccessRightToTextMethod(Directory)},
        Documentation{Description = "The maximum access rights that the user opening the file has been granted for this file open."};
    optional [|WordCount == 0x2A|] ULONG GuestMaximalAccessRights with DisplayInfo{ToText = GetAccessRightToTextMethod(Directory)},
        Documentation{Description = "The maximum access rights that the guest account has when opening this file."};
    USHORT ByteCount// where value == 0x0000
        with Documentation{Description = "This field MUST be 0x0000. No data is sent by this message."};
    optional binary AndXPadding with Encoding{Ignore = true};
} with Documentation{EmbeddedType = true};

string(any) GetAccessRightToTextMethod(UCHAR Directory)
{
    if (Directory == 0x00)
    {
        return FilePipePrinterAccessMaskToText;
    }
    else
    {
        return DirectoryAccessMaskToText;
    }
}

static string FilePipePrinterAccessMaskToText(any input)
{
    var data = input as (optional FilePipePrinterAccessMask);
    if (data == nothing)
    {
        return "";
    }
    var v = data as FilePipePrinterAccessMask;
    return EnumToString(v, "SMB.FilePipePrinterAccessMask");
}

static string DirectoryAccessMaskToText(any input)
{
    var data = input as (optional DirectoryAccessMask);
    if (data == nothing)
    {
        return "";
    }
    var v = data as DirectoryAccessMask;
    return EnumToString(v, "SMB.DirectoryAccessMask");
}

pattern SmbOpLockLevel = enum UCHAR
{
    NoOpLock = 0x00
        with Documentation{Description = "No OpLock granted."},
    ExclusiveOpLock = 0x01
        with Documentation{Description = "Exclusive OpLock granted."},
    BatchOpLock = 0x02
        with Documentation{Description = "Batch OpLock granted."},
   LevelIIOpLock = 0x03
        with Documentation{Description = "Level II OpLock granted."},
} with Documentation{EmbeddedType = true};

pattern SmbComNTCreateAndxResponseParametersWordsCreateDisposition = enum ULONG
{
    FileSupersede = 0x00000000
        with Documentation{Description = "The file has been superseded."},
    FileOpen = 0x00000001
        with Documentation{Description = "The file or directory has been opened."},
    FileCreate = 0x00000002
        with Documentation{Description = "The file or directory has been created."},
    FileOpenIf = 0x00000003
        with Documentation{Description = "The file has been overwritten."},
    FileOverwrite = 0x00000004
        with Documentation{Description = "The file already exists."},
    FileOverwriteIf = 0x00000005
        with Documentation{Description = "The file does not exist."},
    ...
} with Documentation{EmbeddedType = true};

pattern SmbComNTCreateAndxResponseResourceType = enum USHORT
{
    FileTypeDisk = 0x00
        with Documentation{Description = "File or directory"},
    FileTypeByteModePipe = 0x01
        with Documentation{Description = "Byte mode named pipe"},
    FileTypeMessageModePipe = 0x02
        with Documentation{Description = "Message mode named pipe"},
    FileTypePrinter = 0x03
        with Documentation{Description = "Printer device"},
    FileTypeCommDevice = 0x04
        with Documentation{Description = "Character mode device."},
} with Documentation{EmbeddedType = true};


// 2.2.4.65   SMB_COM_NT_CANCEL (0xA4), no response.
type SmbComNTCancelRequest
{
    UCHAR WordCount where value == 0x00
        with Documentation{Description = "This field MUST be set to 0x00. No parameters are sent by this message."};
    USHORT ByteCount where value == 0x0000
        with Documentation{Description = "This field MUST be set to 0x0000. No data is sent by this message."};
}

type SmbComNTCancelResponse
{}

// 2.2.4.66   SMB_COM_NT_RENAME (0xA5)
type SmbComNTRenameRequest[bool IsFlags2Unicode]
{
    UCHAR WordCount where value == 0x04 with Documentation{Description = "This field MUST be 0x04."};
    SmbFileAttributes SearchAttributes
        with Documentation{Description = "This field indicates the attributes that the target file(s) MUST have. If the attribute is 0x0000, then only normal files are renamed or linked. If the system file or hidden attributes are specified, then the rename is inclusive of both special types."};
    SmbComNTRenameRequestInformationLevel InformationLevel where ValidationCheck(InRange<SmbComNTRenameRequestInformationLevel>(value), null, DiagnosisLevel.Error, "SMB: The InformationLevel field in type SmbComNTRenameRequest is an undefined value. Please refer to SMB_COM_NT_RENAME (0xA5) in Technical Document [MS-CIFS].")
        with Documentation{Description = "This field MUST be one of the three values shown in the following table."};
    ULONG Reserved
        with Documentation{Description = "This field SHOULD be set to 0x00000000 by the client and MUST be ignored by the server.This field was previously designated ClusterCount (as listed in [SNIA] section 2.4.13). ClusterCount is not implemented in windows."};
    USHORT ByteCount
        with Documentation{Description = "This field MUST be greater than or equal to 0x0004."};
    DataBufferFormatCodes BufferFormat1 where value == 0x04
        with Documentation{Description = "This field MUST be 0x04."};
    SmbString[IsFlags2Unicode] OldFileName
        with Documentation{Description = "A null-terminated string containing the full path name of the file to be manipulated. Wildcards are not supported."};
    DataBufferFormatCodes BufferFormat2 where value == 0x04
        with Documentation{Description = "This field MUST be 0x04."};
    optional [|IsFlags2Unicode|] UCHAR Pad;
    SmbString[IsFlags2Unicode] NewFileName
        with Documentation{Description = "A null-terminated string containing the new full path name to be assigned to the file provided in OldFileName or the full path into which the file is to be moved."};
}

pattern SmbComNTRenameRequestInformationLevel = enum USHORT
{
    SMB_NT_RENAME_SET_LINK_INFO = 0x0103
        with Documentation{Description = "Create a hard link to the original file."},
    SMB_NT_RENAME_RENAME_FILE  = 0x0104
        with Documentation{Description = "An in-place rename of the file. Windows clients never send an SMB_COM_NT_RENAME Request using this information level. Instead, they use SMB_COM_RENAME to perform rename operations. windows servers process SMB_COM_NT_RENAME Requests with this information level in the same way as an SMB_COM_RENAME Request, with the exception that they do not allow wildcards in the request."},
    SMB_NT_RENAME_MOVE_FILE    = 0x0105
        with Documentation{Description = "Move the file within the path hierarchy. This information level is obsolete. Clients MUST NOT use this value in a request.windows clients do not send SMB_COM_NT_RENAME Requests with the SMB_NT_RENAME_MOVE_FILE information level. windows_nt servers do not fully implement this information level, and perform a file copy instead of a rename or move if SMB_NT_RENAME_MOVE_FILE is specified."},
    ...
} with Documentation{EmbeddedType = true};

// 2.2.4.66   SMB_COM_NT_RENAME (0xA5)
type SmbComNTRenameResponse
{
    UCHAR WordCount where value == 0x00
        with Documentation{Description = "This field MUST be set to 0x00. No parameters are sent by this message."};
    USHORT ByteCount where value == 0x00
        with Documentation{Description = "This field MUST be set to 0x0000. No data is sent by this message."};
}

// 2.2.4.67   SMB_COM_OPEN_PRINT_FILE (0xC0)
type SmbComOpenPrintFileRequest[bool IsFlags2Unicode]
{
    UCHAR WordCount where value == 0x02
        with Documentation{Description = "This field MUST be 0x02."};
    USHORT SetupLength
        with Documentation{Description = "Length, in bytes, of the printer-specific control data that is to be included as the first part of the spool file. The server MUST pass this initial portion of the spool file to the printer unmodified."};
    SmbComOpenPrintFileRequestParametersWordsMode Mode
        with Documentation{Description = "A 16-bit field that contains a flag that specifies the print file mode."};
    USHORT ByteCount where value >= 0x0002
        with Documentation{Description = "This field MUST be greater than or equal to 0x0002."};
    DataBufferFormatCodes BufferFormat where value == 0x04
        with Documentation{Description = "This field MUST be 0x04, representing an ASCII string."};
    SmbString[IsFlags2Unicode] Identifier
        with Documentation{Description = "A null-terminated string containing a suggested name for the spool file. The server can ignore, modify, or use this information to identify the print job.Windows NT4.SP6 server ignores the Identifier."};
} with Documentation{EmbeddedType = true};

pattern SmbComOpenPrintFileRequestParametersWordsMode = enum USHORT
{
    TextMode = 0
        with Documentation{Description = "Text mode. Starting SetupLength bytes into the spool file, the server MAY modify character sequences to normalize them for printer output. For example, the printer can convert tab characters in the spool file to sequences of spaces, or normalize end-of-line sequences."},
    BinaryMode = 1
        with Documentation{Description = "Binary mode. The server MUST NOT modify the contents of the spool file before sending it to the printer."},
} with Documentation{EmbeddedType = true};

// 2.2.4.67   SMB_COM_OPEN_PRINT_FILE (0xC0)
type SmbComOpenPrintFileResponse
{
    UCHAR WordCount where value == 0x01
        with Documentation{Description = "This field MUST be 0x01."};
    USHORT Fid
        with Documentation{Description = "The returned file handle that MUST be used by subsequent write and close operations on the spool file. When the spool file is closed, the file is queued and printed."};
    USHORT ByteCount where value == 0x0000
        with Documentation{Description = "This field MUST be 0x0000. No data is sent by this message."};
} with Documentation{EmbeddedType = true};

// 2.2.4.68   SMB_COM_WRITE_PRINT_FILE (0xC1)
type SmbComWritePrintFileRequest
{
    UCHAR WordCount where value == 0x01
        with Documentation{Description = "This field MUST be 0x01."};
    USHORT Fid
        with Documentation{Description = "This field MUST be a valid FID that is created using the SMB_COM_OPEN_PRINT_FILE command."};
    USHORT ByteCount where value >= 0x0003
        with Documentation{Description = "This field MUST be greater than or equal to 0x0003."};
    DataBufferFormatCodes BufferFormat where value == 0x01
        with Documentation{Description = "This field MUST be 0x01."};
    USHORT DataLength
        with Documentation{Description = "Length, in bytes, of the following data block."};
    binary Data with BinaryEncoding{Length = DataLength}, 
        Documentation{Description = "STRING Bytes to be written to the spool file indicated by FID."};
}

// 2.2.4.68   SMB_COM_WRITE_PRINT_FILE (0xC1)
type SmbComWritePrintFileResponse
{
    UCHAR WordCount where value == 0x00
        with Documentation{Description = "This field MUST be 0x00. No parameters are sent by this message."};
    USHORT ByteCount// where value == 0x0000
        with Documentation{Description = "This field MUST be 0x0000. No data is sent by this message."};
}

// 2.2.4.69   SMB_COM_CLOSE_PRINT_FILE (0xC2)
type SmbComClosePrintFileRequest
{
    UCHAR WordCount// where value == 0x01
        with Documentation{Description = "This field MUST be 0x01."};
    USHORT Fid
        with Documentation{Description = "This field MUST be a valid FID created using the SMB_COM_OPEN_PRINT_FILE command. Following successful execution of this command, this FID MUST be invalidated."};
    USHORT ByteCount where value == 0x0000
        with Documentation{Description = "This field MUST be 0x0000. No data is sent by this message."};
} with Documentation{EmbeddedType = true};

// 2.2.4.69   SMB_COM_CLOSE_PRINT_FILE (0xC2)
type SmbComClosePrintFileResponse
{
    UCHAR WordCount where value == 0x00
        with Documentation{Description = "This field MUST be 0x00. No parameters are sent by this message"};
    USHORT ByteCount where value == 0x0000
        with Documentation{Description = "This field MUST be 0x0000. No data is sent by this message."};
} with Documentation{EmbeddedType = true};

// 2.2.4.70 - 2.2.4.75
// Messages obsolated.


// Unrecongnized message command.
type UnimplementedMessage
{
    UCHAR WordCount;
    optional [|WordCount > 0|] binary Words with BinaryEncoding{Length = WordCount};
    USHORT ByteCount;
    optional [|ByteCount > 0|] binary Bytes with BinaryEncoding{Length = ByteCount};
}

// Used in SmbComTransactionRequest message, 2.2.4.33
// 2.2.5   Transaction Subcommands, no specified response.
type TransactionSubCommandsRequestParameters[ushort Subcommand, ushort Length]
{
    ([|Subcommand == 0x0001|] TransSetNmpipeStateRequest
        | [|Subcommand == 0x0022|] TransQueryNmpipeInfoRequest
        | Blob[Length as uint]) SmbParameters;
}

// 2.2.5.1   TRANS_SET_NMPIPE_STATE (0x0001)
type TransSetNmpipeStateRequest
{
    TransSetNmpipeStateRequestParametersPipeState PipeState
        with Documentation{Description = "This field contains the value that defines the state being set on the pipe. Any combination of the following flags MUST be valid for the set operation. All other flags are considered unused and SHOULD be set to 0 when this message is sent. The server MUST ignore the unused bits when the message is received."};
    override string ToString()
    {
        return "PipeState: " + EnumToString(PipeState, "SMB.TransSetNmpipeStateRequestParametersPipeState");
    }
} with Documentation{EmbeddedType = true};

pattern TransSetNmpipeStateRequestParametersPipeState = flags USHORT
{
    Reserved1   = 0x00FF,
    ReadMode    = 0x0100
        with Documentation{Description = "If set, the named pipe is operating in message mode. If not set, the named pipe is operating in byte mode. In message mode, the system treats the bytes read or written in each I/O operation to the pipe as a message unit. The system MUST perform write operations on message-type pipes as if write-through mode were enabled."},
    Reserved2   = 0x7E00,
    Nonblocking = 0x8000
        with Documentation{Description = "If set, a read or a raw read request returns all data available to be read from the named pipe, up to the maximum read size set in the request. A write request returns after writing data to the named pipe without waiting for the data to be consumed. Named pipe non-blocking raw writes are not allowed. Raw writes MUST be performed in blocking mode."},
} with Documentation{EmbeddedType = true};

// 2.2.5.3   TRANS_QUERY_NMPIPE_STATE (0x0021)
type TransQueryNmpipeStateResponseTransParameters
{
    SmbNMPipeStatus NmpipeStatus
        with Documentation{Description = "A 16-bit field that shows the status of the named pipe. This field is formatted as an SMB_NMPIPE_STATUS."};
    override string ToString()
    {
        return NmpipeStatus.ToString();
    }
} with Documentation{EmbeddedType = true};

// 2.2.5.4   TRANS_QUERY_NMPIPE_INFO (0x0022)
type TransQueryNmpipeInfoRequest
{
    USHORT Level
        with Documentation{Description = "This field MUST be set to 0x0001. This value (as specified in [MS-DTYP] section ) describes the information level being queried for the pipe. If the server receives any other value, it MUST fail the request with a status of STATUS_INVALID_PARAMETER (ERRDOS/ERRinvalidparam)."};
} with Documentation{EmbeddedType = true};

type TransQueryNmpipeInfoResponse[bool IsFlags2Unicode]
{
    USHORT OutputBufferSize
        with Documentation{Description = "This field MUST be the actual size of the buffer for outgoing (server) I/O."};
    USHORT InputBufferSize
        with Documentation{Description = "This field MUST be the actual size of the buffer for incoming (client) I/O."};
    UCHAR MaximumInstances
        with Documentation{Description = "This field MUST be the maximum number of allowed instances of the named pipe."};
    UCHAR CurrentInstances
        with Documentation{Description = "This field MUST be the current number of named pipe instances. The count increments when the server creates a named pipe and decrements when the server closes the named pipe for an unconnected pipe, or when both the server and the client close the named pipe for a connected pipe."};
    UCHAR PipeNameLength
        with Documentation{Description = "This field MUST be the length in bytes of the pipe name, including the terminating null character."};
    optional [|IsFlags2Unicode|] UCHAR Pad;
    SmbString[IsFlags2Unicode] PipeName
        with Documentation{Description = "This field MUST be a null-terminated string containing the name of the named pipe, not including the initial \\\\NodeName string (that is, of the form \\PIPE\\pipename). If SMB_FLAGS2_UNICODE is set in the Flags2 field of the SMB Header of the response, the name string MUST be in a null-terminated array of 16-bit Unicode characters. Otherwise, the name string MUST be a null-terminated array of OEM characters. If the PipeName field consists of Unicode characters, this field MUST be aligned to start on a 2-byte boundary from the start of the SMB Header."};
    override string ToString()
    {
        return "PipeName: " + PipeName.ToString();        
    }
} with Documentation{EmbeddedType = true};

// 2.2.5.5   TRANS_PEEK_NMPIPE (0x0023)
type TransPeekNmpipeResponseTransParameters
{
    USHORT ReadDataAvailable
        with Documentation{Description = "This field contains the total number of bytes available to be read from the pipe."};
    USHORT MessageBytesLength
        with Documentation{Description = "If the named pipe is a message mode pipe, this MUST be set to the number of bytes remaining in the message that was peeked (the number of bytes in the message minus the number of bytes read). If the entire message was read, this value is 0x0000. If the named pipe is a byte mode pipe, this value MUST be set to 0x0000."};
    TransPeekNmpipeResponseTransParametersNamedPipeState NamedPipeState
        with Documentation{Description = "The status of the named pipe."};
    override string ToString()
    {
        return "ReadDataAvailable: " + (ReadDataAvailable as string) + ", MessageBytesLength: " + (MessageBytesLength as string) + ", NamedPipeState: " + EnumToString(NamedPipeState, "SMB.TransPeekNmpipeResponseTransParametersNamedPipeState");
    }
} with Documentation{EmbeddedType = true};

pattern TransPeekNmpipeResponseTransParametersNamedPipeState = enum USHORT
{
    Disconnected  = 0x0001
        with Documentation{Description = "Named pipe was disconnected by server."},
    Listening = 0x0002
        with Documentation{Description = "Named pipe is listening."},
    ConnectionOkey  = 0x0003
        with Documentation{Description = "Named pipe connection to the server is okay."},
    Closed = 0x0004
        with Documentation{Description = "Server end of named pipe is closed."},
} with Documentation{EmbeddedType = true};

// 2.2.5.7   TRANS_RAW_WRITE_NMPIPE (0x0031)
type TransRawWriteNmpipeResponseTransParameters
{
    USHORT BytesWritten
        with Documentation{Description = "This field MUST be set to the number of bytes written to the pipe."};
    override string ToString()
    {
        return "BytesWritten: " + (BytesWritten as string);
    }
} with Documentation{EmbeddedType = true};

// 2.2.5.9   TRANS_WRITE_NMPIPE (0x0037)
type TransWriteNmpipeResponseTransParameters
{
    USHORT BytesWritten
        with Documentation{Description = "This field MUST be set to the number of bytes written to the pipe."};
    override string ToString()
    {
        return "BytesWritten: " + (BytesWritten as string);
    }
}

// Used in SMB_COM_TRANSACTION2 message, 2.2.4.46
type Trans2SubcommandRequestParameters[USHORT Subcommand, bool IsFlags2Unicode, USHORT Length]
{
    ([|Subcommand == 0x00|] Trans2Open2RequestParameters[IsFlags2Unicode]
        | [|Subcommand == 0x01|] Trans2FindFirst2RequestParameters[IsFlags2Unicode]
        | [|Subcommand == 0x02|] Trans2FindNext2RequestParameters[IsFlags2Unicode]
        | [|Subcommand == 0x03|] Trans2QueryFSInformationRequestParameters
        | [|Subcommand == 0x04|] Trans2SetFSInformationRequestParameters
        | [|Subcommand == 0x05|] Trans2QueryPathInformationRequestParameters[IsFlags2Unicode]
        | [|Subcommand == 0x06|] Trans2SetPathInformationRequestParameters[IsFlags2Unicode]
        | [|Subcommand == 0x07|] Trans2QueryFileInformationRequestParameters
        | [|Subcommand == 0x08|] Trans2SetFileInformationRequestParameters
        | [|Subcommand == 0x0D|] Trans2CreateDirectoryRequestParameters[IsFlags2Unicode]
        | Blob[Length as uint]) Parameters;
    override string ToString()
    {
        return Parameters.ToString();
    }
}

type Trans2SubcommandRequestData[USHORT Subcommand, USHORT InformationLevel, USHORT Length]
{
    ([|Subcommand == 0x00|] Trans2Open2RequestData
        | [|Subcommand == 0x01|] Trans2FindFirst2RequestData
        | [|Subcommand == 0x02|] Trans2FindNext2RequestData
        | [|Subcommand == 0x04|] Trans2SetFSInformationRequestData[InformationLevel, Length]
        | [|Subcommand == 0x05|] Trans2QueryPathInformationRequestData
        | [|Subcommand == 0x06|] SmbSetInfoLevels[InformationLevel, Length]
        | [|Subcommand == 0x07|] Trans2QueryFileInformationRequestData
        | [|Subcommand == 0x08|] SmbSetInfoLevels[InformationLevel, Length]
        | [|Subcommand == 0x0D|] Trans2CreateDirectoryRequestData
        | Blob[Length as uint]) Data;
}

// 2.2.6.1   TRANS2_OPEN2 (0x0000)
type Trans2Open2RequestParameters[bool IsFlags2Unicode]
{
    Trans2Open2RequestParametersFlags Flags
        with Documentation{Description = "This 16-bit field of flags is used to request that the server take certain actions."};
    SmbAccessMode AccessMode
        with Documentation{Description = "A 16-bit field for encoding the requested access mode. See section  for a discussion on sharing modes."};
    USHORT Reserved1 where value == 0x0000
        with Documentation{Description = "This field MUST be set to zero (0x0000) and MUST be ignored by the server."};
    SmbFileAttributes FileAttributes
        with Documentation{Description = "Attributes to apply to the file if it needs to be created."};
    Utime CreationTime
        with Documentation{Description = "A 32-bit integer time value to be assigned to the file as the time of creation if the file is to be created."};
    SmbOpenMode OpenMode
        with Documentation{Description = "A 16-bit field that controls the way that a file SHOULD be treated when it is opened for use by certain extended SMB requests."};
    ULONG AllocationSize
        with Documentation{Description = "The number of bytes to reserve for the file if the file is being created or truncated."};
    binary Reserved with BinaryEncoding{Length = 10},
        Documentation{Description = "All entries in this field MUST be set to zero (0x0000)."};
    SmbString[IsFlags2Unicode] FileName
        with Documentation{Description = "A buffer containing the name of the file to be opened, created, or truncated. The string MUST be null terminated."};
    override string ToString()
    {
        return "FileName: " + FileName.ToString();
    }
} with Documentation{Description = "The TRANS2_OPEN2 request and response formats are a special case of SMB_COM_TRANSACTION2SMB. Only the TRANS2_OPEN2 request specifics are described here."};

type Trans2Open2RequestData
{
    SmbFeaList ExtendedAttributeList
        with Documentation{Description = "A list of extended attribute (EA) name/value pairs that are to be assigned to the file."};
} with Documentation{Description = "A buffer containing the name of the file to be opened, created, or truncated. The string MUST be null terminated."},
       Documentation {EmbeddedType = true};

pattern Trans2Open2RequestParametersFlags = flags USHORT
{
    ReqAttrib  = 0x0001
        with Documentation{Description = "Return additional information in the response; populate the CreationTime, FileDataSize, AccessMode, ResourceType, and NMPipeStatus fields in the response."},
    ReqOplock  = 0x0002
        with Documentation{Description = "Exclusive OpLock requested."},
    ReqOpbatch = 0x0004
        with Documentation{Description = "Batch OpLock requested."},
    ReqEasize  = 0x0008
        with Documentation{Description = "Return total length of Extended Attributes (EAs); populate the ExtendedAttributeLength field in the response."},
    Reserved   = 0xFFF0,
} with Documentation{EmbeddedType = true};

// 2.2.6.1   TRANS2_OPEN2 (0x0000)
type Trans2Open2ResponseParameters
{
    USHORT Fid
        with Documentation{Description = "This field contains the FID of the opened file."};
    SmbFileAttributes FileAttributes
        with Documentation{Description = "The file attributes assigned to the file after the open or create has occurred."};
    Utime CreationTime
        with Documentation{Description = "A 32-bit integer time value to be assigned to the file as the time of creation if the file is to be created."};
    ULONG FileDataSize
        with Documentation{Description = "The current size of the file in bytes."};
    SmbAccessMode AccessMode
        with Documentation{Description = "A 16-bit field for encoding the granted access mode. This field is formatted in the same way as the equivalent field in the request."};
    USHORT ResourceType
        with Documentation{Description = "The file type. This field MUST be interpreted as follows:"};
    SmbNMPipeStatus NmpipeStatus
        with Documentation{Description = "A 16-bit field that contains the status of the named pipe if the resource type opened is a named pipe instance. This field is formatted as an SMB_NMPIPE_STATUS."};
    USHORT ActionTaken
        with Documentation{Description = "A 16-bit field that shows the results of the open operation."};
    ULONG Reserved where value == 0x00000000
        with Documentation{Description = "This field SHOULD be set to zero (0x00000000) and MUST be ignored by the server."};
    USHORT ExtendedAttributeErrorOffset
        with Documentation{Description = "If an error was detected while applying the entries in the ExtendedAttributeList, this field contains the offset in bytes to the specific ExtendedAttributeList.FEAList entry in the request that caused the error."};
    ULONG ExtendedAttributeLength
        with Documentation{Description = "The total size of the extended attributes for the opened file."};
    override string ToString()
    {
        return "Fid: " + DecToHexFormat(Fid);
    }
} with Documentation{Description = "Trans2_Parameters"};

// 2.2.6.2   TRANS2_FIND_FIRST2 (0x0001)
type Trans2FindFirst2RequestParameters[bool IsFlags2Unicode]
{
    SmbFileAttributes SearchAttributes
        with Documentation{Description = "File attributes to apply as a constraint to the file search. Exclusive search attributes (see section ) can also be set."};
    USHORT SearchCount
        with Documentation{Description = "The server MUST NOT return more entries than indicated by the value of this field."};
    Trans2FindFlags Flags
        with Documentation{Description = "This bit field contains flags used to request that the server manage the state of the transaction based on how the client attempts to traverse the results."};
    FindInformationLevelCodes InformationLevel
        where ValidationCheck(InRange<FindInformationLevelCodes>(value), null, DiagnosisLevel.Error, "SMB: The InformationLevel field in type Trans2FindFirst2RequestParameters is an undefined value. Please refer to TRANS2_FIND_FIRST2 (0x0001) in Technical Document [MS-CIFS].")
        with Documentation{Description = "This field contains an information level code, which determines the information contained in the response. The list of valid information level codes is specified in section . A client that has not negotiated long names support MUST request only SMB_INFO_STANDARD. If a client that has not negotiated long names support requests an InformationLevel other than SMB_INFO_STANDARD, the server MUST return a status of STATUS_INVALID_PARAMETER (ERRDOS/ERRinvalidparam)."};
    ULONG SearchStorageType
        where ValidationCheckZero(value == 0, null, true, ReferenceType.Type, "SMB", "SearchStorageType", "Trans2FindFirst2RequestParameters", value);
    SmbString[IsFlags2Unicode] FileName
        with Documentation{Description = "The file pattern to search for. This field MAY contain wildcard characters."};
        
    override string ToString()
    {
        return "FileName: " + FileName.ToString();
    }
} with Documentation{Description = "The TRANS2_FIND_FIRST2 request and response formats are special cases of the SMB_COM_TRANSACTION2SMB. Only the TRANS2_FIND_FIRST2 specifics are described here."};

type Trans2FindFirst2RequestData
{
    SmbGeaList GetExtendedAttributeList
        with Documentation{Description = "A list of extended attribute (EA) names. The value of the AttributeName fields MUST be used by the server to query the set of extended attributes that match the set of AttributeName values provided in this list. "};
}

// 2.2.6.2.2   Response
type Trans2FindFirst2ResponseParameters
{
    USHORT Sid
        with Documentation{Description = "The server-generated search identifier for this transaction. It MUST be provided in TRANS2_FIND_NEXT2 transactions."};
    USHORT SearchCount
        with Documentation{Description = "The number of entries returned by the search."};
    USHORT EndOfSearch
        with Documentation{Description = "This field MUST be zero (0x0000) if the search can be continued using the TRANS2_FIND_NEXT2 transaction. This field MUST be nonzero if this response is the last and the find has reached the end of the search results."};
    USHORT EaErrorOffset
        with Documentation{Description = "If Request.Trans2_Parameters.InformationLevel is not SMB_INFO_QUERY_EAS_FROM_LIST, this field MUST be zero (0x0000). If InformationLevel is SMB_INFO_QUERY_EAS_FROM_LIST, this field marks the offset to an extended attribute name, the retrieval of which caused an error. This field MUST contain the offset in bytes to the SMB_GEA entry in the Trans2_Data.GetExtendedAttributesList that identifies the extended attribute that caused the error, or zero (0x0000) if no error was encountered."};
    USHORT LastNameOffset
        with Documentation{Description = "If the server cannot resume the search, this field MUST be zero (0x0000). If the server can resume the search, this field contains the offset in bytes into the Trans2_Data structure at which the file name of the last entry returned by the server is located. This value can be used in the Trans2_Parameters structure of the request to continue a search. See TRANS2_FIND_NEXT2 (section 2.2.6.3) for more information."};
    override string ToString()
    {
        return "Sid: " + (Sid as string) + ", SearchCount: " + (SearchCount as string);
    }
}

// 2.2.6.3   TRANS2_FIND_NEXT2 (0x0002)
type Trans2FindNext2RequestParameters[bool IsFlags2Unicode]
{
    USHORT Sid
        with Documentation{Description = "This field MUST be the search identifier (SID) returned in TRANS2_FIND_FIRST2 response."};
    USHORT SearchCount
        with Documentation{Description = "This field MUST be the maximum number of entries to return in the response."};
    FindInformationLevelCodes InformationLevel
        where ValidationCheck(InRange<FindInformationLevelCodes>(value), null, DiagnosisLevel.Error, "SMB: The InformationLevel field in type Trans2FindNext2RequestParameters is an undefined value. Please refer to TRANS2_FIND_NEXT2 (0x0002) in Technical Document [MS-CIFS].")
        with Documentation{Description = "This field contains an information level code, which determines the information contained in the response. The list of valid information level codes is specified in section . A client that has not negotiated long names support MUST request only SMB_INFO_STANDARD. If a client that has not negotiated long names support requests an InformationLevel other than SMB_INFO_STANDARD, the server MUST return a status of STATUS_INVALID_PARAMETER (ERRDOS/ERRinvalidparam)."};
    ULONG ResumeKey
        with Documentation{Description = "This field MUST be the value of a ResumeKey field returned in the response from a TRANS2_FIND_FIRST2 or TRANS2_FIND_NEXT2 that is part of the same search (same SID)."};
    Trans2FindFlags Flags
        with Documentation{Description = "This bit mask field is used to request that the server manage the state of the transaction based on how the client attempts to traverse the results."};
    SmbString[IsFlags2Unicode] FileName
        with Documentation{Description = "A filename pattern. The server re-runs the search based on the search criteria defined by the FileName field in the TRANS2_FIND_FIRST2 Request, and the file names are returned starting after the first file that matches the filename pattern. This field can contain wildcard characters.If the client sends an empty string (0x00 or 0x0000) in the FileName field for the TRANS2_FIND_NEXT2 Request, windows_nt servers return no data in the Trans2_Data block. The SearchCount field value in the Trans2_Parameters block is set to zero (0x0000)."};
        
    override string ToString()
    {
        return "Sid: " + (Sid as string) + ", FileName: " + FileName.ToString();
    }
} with Documentation{EmbeddedType = true};

pattern Trans2FindFlags = flags USHORT
{
    SmbFindCloseAfterRequest = 0x0001
        with Documentation{Description = "Close the search after this request."},
    SmbFindCloseATEos        = 0x0002
        with Documentation{Description = "Close search when end of search is reached."},
    SmbFindReturnResumeKeys  = 0x0004
        with Documentation{Description = "Return resume keys for each entry found."},
    SmbFindContinueFromLast  = 0x0008
        with Documentation{Description = "Continue search from previous ending place."},
    SmbFindWithBackupIntent  = 0x0010
        with Documentation{Description = "Find with backup intent."},
    Reserved                 = 0xFFE0,
} with Documentation{EmbeddedType = true};

type Trans2FindNext2RequestData
{
    SmbGeaList GetExtendedAttributeList
        with Documentation{Description = "A list of extended attribute (EA) names. The value of the AttributeName field MUST be used by the server to further constrain the find query to files having the set of extended attributes that match the set of AttributeName values provided in this list."};
} with Documentation{Description = "The Trans2_Data MUST be included if the  Trans2_Parameters.InformationLevel field is set to SMB_INFO_QUERY_EAS_FROM_LIST; else, it MUST NOT be included."},
       Documentation {EmbeddedType = true};

// 2.2.6.3   TRANS2_FIND_NEXT2 (0x0002)
type Trans2FindNext2ResponseParameters
{
    USHORT SearchCount
        with Documentation{Description = "The number of entries returned by the search."};
    USHORT EndOfSearch
        with Documentation{Description = "This field MUST be zero (0x0000) if the search can be continued using the TRANS2_FIND_NEXT2 transaction. This field MUST be nonzero if this response is the last and the find has reached the end of the search results."};
    USHORT EaErrorOffset
        with Documentation{Description = "If the Request.Trans2_Parameters.InformationLevel field is not SMB_INFO_QUERY_EAS_FROM_LIST, this field MUST be zero (0x0000). If the InformationLevel field is SMB_INFO_QUERY_EAS_FROM_LIST, this field marks the offset to an extended attribute name, the retrieval of which caused an error. This field MUST contain the offset in bytes to the SMB_GEA entry in the Trans2_Data.GetExtendedAttributesList field that identifies the extended attribute that caused the error, or zero (0x0000) if no error was encountered."};
    USHORT LastNameOffset
        with Documentation{Description = "If the server cannot resume the search, this field MUST be zero (0x0000). If the server can resume the search, this field contains the offset in bytes into the Trans2_Data structure at which the file name of the last entry returned by the server is located. This value can be used in the Trans2_Parameters structure of the request to continue a search."};
    override string ToString()
    {
        return "SearchCount: " + (SearchCount as string);
    }
} with Documentation{EmbeddedType = true};

// 2.2.6.4   TRANS2_QUERY_FS_INFORMATION (0x0003)
type Trans2QueryFSInformationRequestParameters
{
    QueryFSInformationLevelCodes InformationLevel with DisplayInfo{ToText = InformationLevelToText},
        Documentation{Description = "This field contains an information level code, which determines the information contained in the response. The list of valid information level codes is specified in section 2.2.2.3.2"};
      
    static string InformationLevelToText(any data)
    {
        ushort informationLevel = data as ushort;
        if (InRange<QueryFSInformationLevelCodes>(informationLevel))
        {
            return EnumToString(informationLevel, "SMB.QueryFSInformationLevelCodes") + "(" + DecToHexFormat(4, informationLevel) + ")";
        }
        else
        {
            return FileSystemInformationClassesToText((informationLevel - SmbInfoPassthrough) as byte);
        }
    }
    override string ToString()
    {
        return "InformationLevel: " + InformationLevelToText(InformationLevel);
    }
}

// SMB 2.2.6.4   TRANS2_SET_FS_INFORMATION (0x0004)
type Trans2SetFSInformationRequestParameters
{
    USHORT Fid
        with Documentation{Description = "A valid Fid that represents the open file on the server that is to have its file attributes changed."};
    USHORT InformationLevel with DisplayInfo{ToText = InformationLevelToText},
        Documentation{Description = "The Information Level of the request. This field MUST be a pass-through Information Level, as described in section 2.2.2.3.5."};
    
    static string InformationLevelToText(any data)
    {
        ushort informationLevel = data as ushort;
        return FileSystemInformationClassesToText((informationLevel - SmbInfoPassthrough) as byte);
    }
}

// SMB 2.2.6.4   TRANS2_SET_FS_INFORMATION (0x0004)
type Trans2SetFSInformationRequestData[USHORT InfoLevel, USHORT Length]
{
    optional ([|InfoLevel == SmbInfoPassthrough + FileSystemInformationClasses.FileFsVolumeInformation|] FileFsVolumeInformation       //0x03E9
        | [|InfoLevel == SmbInfoPassthrough + FileSystemInformationClasses.FileFsLabelInformation|] FileFsLabelInformation             //0x03EA
        | [|InfoLevel == SmbInfoPassthrough + FileSystemInformationClasses.FileFsSizeInformation|] FileFsSizeInformation               //0x03EB
        | [|InfoLevel == SmbInfoPassthrough + FileSystemInformationClasses.FileFsDeviceInformation|] FileFsDeviceInformation           //0x03EC
        | [|InfoLevel == SmbInfoPassthrough + FileSystemInformationClasses.FileFsAttributeInformation|] FileFsAttributeInformation     //0x03ED
        | [|InfoLevel == SmbInfoPassthrough + FileSystemInformationClasses.FileFsControlInformation|] FileFsControlInformation         //0x03EE
        | [|InfoLevel == SmbInfoPassthrough + FileSystemInformationClasses.FileFsFullSizeInformation|] FileFsFullSizeInformation       //0x03EF
        | [|InfoLevel == SmbInfoPassthrough + FileSystemInformationClasses.FileFsObjectIdInformation|] FileFsObjectIdInformation       //0x03F0
        | [|InfoLevel == SmbInfoPassthrough + FileSystemInformationClasses.FileFsDriverPathInformation|] FileFsDriverPathInformation   //0x03F1
        | [|InfoLevel == SmbInfoPassthrough + FileSystemInformationClasses.FileFsSectorSizeInformation|] FileFsSectorSizeInformation   //0x03F3
        | Blob[Length as uint]) SetFsInfoLevels;
}

// 2.2.6.6   TRANS2_QUERY_PATH_INFORMATION (0x0005)
type Trans2QueryPathInformationRequestParameters[bool IsFlags2Unicode]
{
    USHORT InformationLevel with DisplayInfo{ToText = InformationLevelToText},
        Documentation{Description = "This field contains an information level code, which determines the information contained in the response. The list of valid information level codes is specified in section 2.2.2.3.3."};
    ULONG Reserved where value == 0x00000000
        with Documentation{Description = "This field is reserved and MUST be zero (0x00000000)."};
    SmbString[IsFlags2Unicode] FileName
        with Documentation{Description = "The file name or directory name for which to retrieve the information."};
    
    static string InformationLevelToText(any data)
    {
        ushort informationLevel = data as ushort;
        if (InRange<QueryInformationLevelCodes>(informationLevel))
        {
            return EnumToString(informationLevel, "SMB.QueryInformationLevelCodes") + "(" + DecToHexFormat(4, informationLevel) + ")";
        }
        else
        {
            return FileInformationClassesToText((informationLevel - SmbInfoPassthrough) as byte);
        }
    }
    override string ToString()
    {
        return "InformationLevel: " + InformationLevelToText(InformationLevel) + ", FileName: " + FileName.ToString();
    }
}

type Trans2QueryPathInformationRequestData
{
    SmbGeaList GetExtendedAttributeList
        with Documentation{Description = "A list of extended attribute (EA) names. The value of the AttributeName fields MUST be used by the server to query the set of extended attributes that match the set of AttributeName values provided in this list. "};
}

// 2.2.6.6   TRANS2_QUERY_PATH_INFORMATION (0x0005)
type Trans2QueryPathInformationResponseParameters
{
    USHORT EaErrorOffset
        with Documentation{Description = "If Request.Trans2_Parameters.InformationLevel is not SMB_INFO_QUERY_EAS_FROM_LIST, this field MUST be zero (0x0000). If InformationLevel is SMB_INFO_QUERY_EAS_FROM_LIST, this field marks the offset to an extended attribute, the retrieval of which caused an error. This field MUST contain the offset in bytes to the SMB_GEA entry in Trans2_Data.GetExtendedAttributesList that caused the error or zero (0x0000) if no error was encountered."};
}
        
// 2.2.6.7   TRANS2_SET_PATH_INFORMATION (0x0006)
type Trans2SetPathInformationRequestParameters[bool IsFlags2Unicode]
{
    USHORT InformationLevel with DisplayInfo{ToText = InformationLevelToText},
        Documentation{Description = "This field contains an information level code, which determines the information contained in the Trans2_Data block. The list of valid information level codes is specified in section 2.2.2.3.4."};
    ULONG Reserved where value == 0x00000000
        with Documentation{Description = "This field is reserved and MUST be zero (0x00000000)."};
    SmbString[IsFlags2Unicode] FileName
        with Documentation{Description = "The file name or directory name for which to retrieve the information."};
    
    static string InformationLevelToText(any data)
    {
        ushort informationLevel = data as ushort;
        if (InRange<SetInformationLevelCodes>(informationLevel))
        {
            return EnumToString(informationLevel, "SMB.SetInformationLevelCodes") + "(" + DecToHexFormat(4, informationLevel) + ")";
        }
        else
        {
            return FileInformationClassesToText((informationLevel - SmbInfoPassthrough) as byte);
        }
    }
    override string ToString()
    {
        return "InformationLevel: " + InformationLevelToText(InformationLevel) + ", FileName: " + FileName.ToString();
    }
}

// 2.2.6.7   TRANS2_SET_PATH_INFORMATION (0x0006)
type Trans2SetPathInformationResponseParameters
{
    USHORT EaErrorOffset
        with Documentation{Description = "This field contains the offset in bytes into the ExtendedAttributeList that identifies the attribute that caused an error. This field is meaningful only when the request\'s Trans2_Parameters.InformationLevel is set to SMB_INFO_SET_EAS."};
} with Documentation{EmbeddedType = true};

// 2.2.6.8   TRANS2_QUERY_FILE_INFORMATION (0x0007)
type Trans2QueryFileInformationRequestParameters
{
    USHORT Fid
        with Documentation{Description = "This field MUST contain a valid FID returned from a previously successful SMB open command."};
    USHORT InformationLevel with DisplayInfo{ToText = InformationLevelToText},
        Documentation{Description = "This field contains an information level code, which determines the information contained in the response. The list of valid information level codes is specified in section . A client that has not negotiated long names support MUST request only SMB_INFO_STANDARD. If a client that has not negotiated long names support requests an InformationLevel other than SMB_INFO_STANDARD, the server MUST return a status of STATUS_INVALID_PARAMETER (ERRDOS/ERRinvalidparam)."};
        
    static string InformationLevelToText(any data)
    {
        ushort informationLevel = data as ushort;
        if (InRange<QueryInformationLevelCodes>(informationLevel))
        {
            return EnumToString(informationLevel, "SMB.QueryInformationLevelCodes") + "(" + DecToHexFormat(4, informationLevel) + ")";
        }
        else
        {
            return FileInformationClassesToText((informationLevel - SmbInfoPassthrough) as byte);
        }
    }
    override string ToString()
    {
        return "Fid: " + DecToHexFormat(Fid) + ", InformationLevel: " + InformationLevelToText(InformationLevel);
    }
} with Documentation{Description = "The TRANS2_QUERY_FILE_INFORMATION request and response formats are special cases of SMB_COM_TRANSACTION2 SMB. Only the TRANS2_QUERY_FILE_INFORMATION Request specifics are described here."};

type Trans2QueryFileInformationRequestData
{
    SmbGeaList GetExtendedAttributeList
        with Documentation{Description = "A list of extended attribute (EA) names. The value of the AttributeName fields MUST be used by the server to query the set of extended attributes that match the set of AttributeName values provided in this list. "};
}

// 2.2.6.8   TRANS2_QUERY_FILE_INFORMATION (0x0007)
type Trans2QueryFileInformationResponseParameters
{
    ushort EaErrorOffset
        with Documentation{Description = "If Request.Trans2_Parameters.InformationLevel is not SMB_INFO_QUERY_EAS_FROM_LIST, this field MUST be zero (0x0000). If InformationLevel is SMB_INFO_QUERY_EAS_FROM_LIST, this field marks the offset to an extended attribute, the retrieval of which caused an error. This field MUST contain the offset, in bytes, to the SMB_GEA (section 2.2.1.2.1) entry in Trans2_Data.ExtendedAttributesList that caused the error, or zero (0x0000) if no error was encountered."};
}

// 2.2.6.9   TRANS2_SET_FILE_INFORMATION (0x0008)
type Trans2SetFileInformationRequestParameters
{
    USHORT Fid
        with Documentation{Description = "This field MUST contain a valid FID returned from a previously successful SMB open command."};
    USHORT InformationLevel with DisplayInfo{ToText = InformationLevelToText},
        Documentation{Description = "This field determines the information contained in the response. See TRANS2_SET_PATH_INFORMATION for complete details."};
    USHORT Reserved
        with Documentation{Description = "MUST be set to zero when sent and MUST be ignored on receipt."};
    
    static string InformationLevelToText(any data)
    {
        ushort informationLevel = data as ushort;
        if (InRange<SetInformationLevelCodes>(informationLevel))
        {
            return EnumToString(informationLevel, "SMB.SetInformationLevelCodes") + "(" + DecToHexFormat(4, informationLevel) + ")";
        }
        else
        {
            return FileInformationClassesToText((informationLevel - SmbInfoPassthrough) as byte);
        }
    }
    
    override string ToString()
    {
        return "Fid: " + DecToHexFormat(Fid) + ", InformationLevel: " + InformationLevelToText(InformationLevel);        
    }
} with Documentation{Description = "The TRANS2_SET_FILE_INFORMATION request and response formats are special cases of SMB_COM_TRANSACTION2SMB. Only the TRANS2_SET_FILE_INFORMATION specifics are described here."};

// 2.2.6.9   TRANS2_SET_FILE_INFORMATION (0x0008)
type Trans2SetFileInformationResponseParameters
{
    USHORT EaErrorOffset
        with Documentation{Description = "This field contains the offset, in bytes, into the ExtendedAttributeList that identifies the attribute that caused an error. This field is meaningful only when the request's Trans2_Parameters.InformationLevel is set to SMB_INFO_SET_EAS."};
}

// 2.2.6.10 - 2.2.6.13
// Message not implemented.

// 2.2.6.14   TRANS2_CREATE_DIRECTORY (0x000D)
type Trans2CreateDirectoryRequestParameters[bool IsFlags2Unicode]
{
    ULONG Reserved where value == 0x00000000
        with Documentation{Description = "This field is reserved and MUST be zero (0x00000000)."};
    SmbString[IsFlags2Unicode] DirectoryName
        with Documentation{Description = "The directory name to assign to the new directory."};
    override string ToString()
    {
        return "DirectoryName: " + DirectoryName.ToString();        
    }
}

type Trans2CreateDirectoryRequestData
{
    SmbFeaList ExtendedAttributeList
        with Documentation{Description = "A list of extended attribute name/value pairs."};
}

// 2.2.6.14   TRANS2_CREATE_DIRECTORY (0x000D)
type Trans2CreateDirectoryResponseParameters
{
    USHORT EaErrorOffset
        with Documentation{Description = "This field contains the offset in bytes into the ExtendedAttributeList.FEAList that identifies the attribute that caused an error. This field is meaningful only when the request included Trans2_Data."};
} with Documentation{EmbeddedType = true};

// 2.2.6.15   TRANS2_SESSION_SETUP (0x000E)
// Message not implemented.

// 2.2.7.1   NT_TRANSACT_CREATE (0x0001)
type NTTransactCreateRequestNTTransData[ULONG SecurityDescriptorLength, ULONG EALength]
{
    optional [|SecurityDescriptorLength > 0|] SECURITY_DESCRIPTOR_NonRpc SECURITY_DESCRIPTOR
        with Documentation{Description = "SECURITY_DESCRIPTOR The security descriptor to use when requesting access to the file. The self-relative form of a SECURITY_DESCRIPTOR MUST be used. See SECURITY_DESCRIPTOR ([MS-DTYP] section ) for details. This field MUST be NT_Trans_Parameters.SecurityDescriptorLength in bytes."};
    optional [|EALength > 0|] FileFullEaInformation ExtendedAttributes
        with Documentation{Description = "The extended attributes that SHOULD be applied to the new file MUST be in the format that is specified for FILE_FULL_EA_INFORMATION in ([MS-FSCC] section ).windows_nt_server requires that this field be aligned to a 32-bit boundary. No padding is required, however, because the NT_Trans_Data block is aligned, and the SECURITY_DESCRIPTOR field is always a multiple of 32 bits."};
} with Documentation{Description = "The NT_Trans_Data provides the Security Descriptor and Extended Attributes data, if any."},
       Documentation {EmbeddedType = true};

type NTTransactCreateRequestNTTransParameters[bool IsFlags2Unicode]
{
    NTTransactCreateRequestNTTransParametersFlags Flags
        with Documentation{Description = "ULONG A 32-bit field containing a set of flags that modify the client request. Unused bits SHOULD be set to 0 by the client when sending a message and MUST be ignored when received by the server."};
    ULONG RootDirectoryFid
        with Documentation{Description = "ULONG If nonzero, this value is the FID of an opened root directory, and the Name field MUST be handled as relative to the directory specified by this FID. If this value is zero (0x00000000), the Name field MUST be handled as relative to the root of the share (the TID). The FID MUST have been acquired in a previous message exchange."};
    NTTransactCreateRequestNTTransParametersDesiredAccess DesiredAccess
        with Documentation{Description = "ULONG A 32-bit field containing standard, specific, and generic access rights. These rights are used in access-control entries (ACEs) and are the primary means of specifying the requested or granted access to an object. If this value is 0x00000000, it represents a request to query the attributes without accessing the file. If the value is not 0x00000000, the bits represent requests for the following types of access:"};
    LARGE_INTEGER AllocationSize
        with Documentation{Description = "LARGE_INTEGER The client MUST set this value to the initial allocation size of the file in bytes. The server MUST ignore this field if this request is to open an existing file. This field MUST be used only if the file is created or overwritten. The value MUST be set to 0x0000000000000000 in all other cases. This does not apply to directory-related requests. This is the number of bytes to be allocated, represented as a 64-bit integer value."};
    SmbExtFileAttr ExtFileAttributes
        with Documentation{Description = "This field contains the extended file attributes of the file being requested, encoded as an SMB_EXT_FILE_ATTR data type."};
    NTTransactCreateRequestNTTransParametersShareAccess ShareAccess
        with Documentation{Description = "ULONG A 32-bit field that specifies how the file SHOULD be shared with other processes. The names in the table below are provided for reference use only. The value MUST be FILE_SHARE_NONE or some combination of the other values:"};
    NTTransactCreateRequestNTTransParametersCreateDisposition CreateDisposition
        where ValidationCheckEnumValue(InRange<NTTransactCreateRequestNTTransParametersCreateDisposition>(value), null, true, ReferenceType.Type, "SMB", "CreateDisposition", "SmbComNTCreateAndxRequest", "0x00000000,0x00000001, 0x00000002, 0x00000003, 0x00000004, 0x00000005", value)
            with Documentation{Description = "ULONG A 32-bit value that represents the action to take if the file already exists or if the file is a new file and does not already exist."};
    SmbCreateOptions CreateOptions
        with Documentation{Description = "ULONG A 32-bit field containing flag options to use if creating the file or directory. This field MUST be set to 0x00000000 or a combination of the following possible values. Unused bit fields SHOULD be set to 0 by the client when sending a request and SHOULD be ignored when received by the server. Below is a list of the valid values and their associated behaviors."};
    ULONG SecurityDescriptorLength
        with Documentation{Description = "ULONG Length of the NT_Trans_Data.SECURITY_DESCRIPTOR field, in bytes."};
    ULONG EALength
        with Documentation{Description = "ULONG Length of the NT_Trans_Data.ExtendedAttributes field, in bytes."};
    ULONG NameLength
        with Documentation{Description = "ULONG Length of the Name field in characters."};
    SmbImpersonationLevel ImpersonationLevel
        with Documentation{Description = "ULONG This field specifies the impersonation level requested by the application that is issuing the create request, and MUST contain one of the following values. The server MUST validate this field, but otherwise ignore it."};
    SmbSecurityFlags SecurityFlags
        with Documentation{Description = "UCHAR An 8-bit field containing a set of options that specify the security tracking mode. These options specify whether the server is to be given a snapshot of the client\'s security context (called static tracking) or is to be continually updated to track changes to the client\'s security context (called dynamic tracking). When bit 0 of the SecurityFlags field is set to 0, static tracking is requested. When bit 0 the SecurityFlags field is set to 1, dynamic tracking is requested. Unused bit fields SHOULD be set to 0 by the client when sending a request and MUST be ignored when received by the server. This field MUST be set to 0x00 or a combination of the following possible values. Value names are provided for convenience only. Supported values are:"};
    optional [|IsFlags2Unicode|] UCHAR Pad;
    SmbStringWithLength[IsFlags2Unicode, (IsFlags2Unicode ? NameLength / 2 : NameLength) as uint] Name
    //string Name with BinaryEncoding{Length = (IsFlags2Unicode ? NameLength / 2 : NameLength), TextEncoding = ((IsFlags2Unicode == false) ? TextEncoding.ASCII : TextEncoding.UTF16)},
        with Documentation{Description = "The name of the file; not null-terminated. If SMB_FLAGS2_UNICODE is set in the Flags2 field of the SMB Header of the request, this field MUST be an array of 16-bit Unicode characters. Otherwise, it MUST be an array of extended ASCII (OEM) characters. If the Name consists of Unicode characters, this field MUST be aligned to start on a 2-byte boundary from the start of the NT_Trans_Parameters."};
    override string ToString()
    {
        return "Name: " + Name.Value;
    }
} with Documentation{Description = "The format of the parameters is very similar to the SMB_COM_NT_CREATE_ANDX command."},
       Documentation {EmbeddedType = true};

pattern SmbSecurityFlags = flags UCHAR
{
    SmbSecurityContextTracking = 0x01
        with Documentation{Description = "When set, dynamic tracking is requested. When this bit field is not set, static tracking is requested."},
    SmbSecurityEffectiveOnly   = 0x02
        with Documentation{Description = "Specifies that only the enabled aspects of the client\'s security context are available to the server. If this flag is not specified, all aspects of the client\'s security context are available. This flag allows the client to limit the groups and privileges that a server can use while impersonating the client."},
    Reserved                   = 0xFC,
} with Documentation{EmbeddedType = true};

pattern SmbCreateOptions = flags ULONG
{
    FileDirectoryFile           = 0x00000001
        with Documentation{Description = "The file being created or opened is a directory file. With this option, the CreateDisposition field MUST be set to FILE_CREATE, FILE_OPEN, or FILE_OPEN_IF. When this bit field is set, other compatible CreateOptions include only the following: FILE_WRITE_THROUGH, FILE_OPEN_FOR_BACKUP_INTENT, and FILE_OPEN_BY_FILE_ID."},
    FileWriteThrough            = 0x00000002
        with Documentation{Description = "Applications that write data to the file MUST actually transfer the data into the file before any write request qualifies as semantically complete.  If FILE_NO_INTERMEDIATE_BUFFERING is set, the server MUST process the request as if FILE_WRITE_THROUGH is set in the create request, even if not set by the client."},
    FileSequentialOnly          = 0x00000004
        with Documentation{Description = "This option indicates that access to the file MAY be sequential. The server can use this information to influence its caching and read-ahead strategy for this file. The file MAY in fact be accessed randomly, but the server can optimize its caching and read-ahead policy for sequential access."},
    FileNOIntermediateBuffering = 0x00000008
        with Documentation{Description = "The file SHOULD NOT be cached or buffered in an internal buffer by the server. This option is incompatible when the FILE_APPEND_DATA bit field is set in the DesiredAccess field."},
    FileSynchronousIOAlert      = 0x00000010
        with Documentation{Description = "This flag MUST be ignored by the server, and clients SHOULD set it to 0."},
    FileSynchronousIONonalert   = 0x00000020
        with Documentation{Description = "This flag MUST be ignored by the server, and clients SHOULD set it to 0."},
    FileNonDirectoryFile        = 0x00000040
        with Documentation{Description = "If the file being opened is a directory, the server MUST fail the request with STATUS_FILE_IS_A_DIRECTORY in the Status field of the SMB Header in the server response."},
    FileCreateTreeConnection    = 0x00000080
        with Documentation{Description = "This option SHOULD NOT be sent by the clients, and this option MUST be ignored by the server."},
    FileCompleteIFOplocked      = 0x00000100
        with Documentation{Description = "This option SHOULD NOT be sent by the clients, and this option MUST be ignored by the server."},
    FileNOEAKnowledge           = 0x00000200
        with Documentation{Description = "The application that initiated the client\'s request does not support extended attributes (EAs). If the EAs on an existing file being opened indicate that the caller SHOULD support EAs to correctly interpret the file, the server SHOULD fail this request with STATUS_ACCESS_DENIED (ERRDOS/ERRnoaccess) in the Status field of the SMB Header in the server response."},
    FileOpenForRecovery         = 0x00000400
        with Documentation{Description = "This option SHOULD NOT be sent by the clients, and this option MUST be ignored if received by the server."},
    FileRandomAccess            = 0x00000800
        with Documentation{Description = "Indicates that access to the file MAY be random. The server MAY use this information to influence its caching and read-ahead strategy for this file. This is a hint to the server that sequential read-ahead operations might not be appropriate on the file."},
    FileDeleteONClose           = 0x00001000
        with Documentation{Description = "The file SHOULD be automatically deleted when the last open request on this file is closed. When this option is set, the DesiredAccess field MUST include the DELETE flag. This option is often used for temporary files."},
    FileOpenBYFileId            = 0x00002000
        with Documentation{Description = "Opens a file based on the FileId. If this option is set, the server MUST fail the request with STATUS_NOT_SUPPORTED in the Status field of the SMB Header in the server response."},
    FileOpenForBackupIntent     = 0x00004000
        with Documentation{Description = "The file is opened or created for the purposes of either a backup or a restore operation. Thus, the server can check to ensure that the caller is capable of overriding whatever security checks have been placed on the file to allow a backup or restore operation to occur. The server can check for access rights to the file before checking the DesiredAccess field."},
    FileNOCompression           = 0x00008000
        with Documentation{Description = "When a new file is created, the file MUST NOT be compressed, even if it is on a compressed volume. The flag MUST be ignored when opening an existing file."},
    Reserved1                   = 0x000F0000,
    FileReserveOpfilter         = 0x00100000
        with Documentation{Description = "This option SHOULD NOT be sent by the clients, and this option MUST be ignored if received by the server."},
    FILE_OPEN_REPARSE_POINT     = 0x00200000
        with Documentation{Description = "If the file or directory being opened is a reparse point, open the reparse point itself rather than the target that the reparse point references."},
    FileOpenNORecall            = 0x00400000
        with Documentation{Description = "In a hierarchical storage management environment, this option requests that the file SHOULD NOT be recalled from tertiary storage such as tape. A file recall can take up to several minutes in a hierarchical storage management environment. The clients can specify this option to avoid such delays."},
    FileOpenForFreeSpaceQuery   = 0x00800000
        with Documentation{Description = "This option SHOULD NOT be sent by the clients, and this option MUST be ignored if received by the server."},
    Reserved3                   = 0xFF000000,
} with Documentation{EmbeddedType = true};

pattern NTTransactCreateRequestNTTransParametersCreateDisposition = enum ULONG
{
    FileSupersede = 0x00000000
        with Documentation{Description = "(No bits set.)"},
    FileOpen = 0x00000001
        with Documentation{Description = "If the file already exists, it SHOULD be opened rather than creating a new file. If the file does not already exist, the operation MUST fail."},
    FileCreate = 0x00000002
        with Documentation{Description = "If the file already exists, the operation MUST fail. If the file does not already exist, it SHOULD be created."},
    FileOpenIf = 0x00000003
        with Documentation{Description = "If the file already exists, it SHOULD be opened. If the file does not already exist, it SHOULD be created."},
    FileOverwrite = 0x00000004
        with Documentation{Description = "If the file already exists, it SHOULD be opened and truncated. If the file does not already exist, the operation MUST fail. The client MUST open the file with at least GENERIC_WRITE access for the command to succeed."},
    FileOverwriteIf = 0x00000005
        with Documentation{Description = "If the file already exists, it SHOULD be opened and truncated. If the file does not already exist, it SHOULD be created. The client MUST open the file with at least GENERIC_WRITE access."},
    ...
} with Documentation{EmbeddedType = true};

pattern NTTransactCreateRequestNTTransParametersShareAccess = flags ULONG
{
    FileShareRead   = 0x00000001
        with Documentation{Description = "Other open operations can be performed on the file for read access."},
    FileShareWrite  = 0x00000002
        with Documentation{Description = "Other open operations can be performed on the file for write access."},
    FileShareDelete = 0x00000004
        with Documentation{Description = "Other open operations can be performed on the file for delete access."},
    Reserved        = 0xFFFFFFF8,

} with Documentation{EmbeddedType = true};

// SMB 2.2.1.4.1   File_Pipe_Printer_Access_Mask
pattern FilePipePrinterAccessMask  = flags ULONG
{
    FileReadData         = 0x00000001
        with Documentation{Description = "This value indicates the right to read data from the file or named pipe."},
    FileWriteData        = 0x00000002
        with Documentation{Description = "This value indicates the right to write data into the file, named pipe, or printer beyond the end of the file."},
    FileAppendData       = 0x00000004
        with Documentation{Description = "This value indicates the right to append data into the file, named pipe, or printer."},
    FileReadEa           = 0x00000008
        with Documentation{Description = "This value indicates the right to read the extended attributes of the file or named pipe."},
    FileWriteEa          = 0x00000010
        with Documentation{Description = "This value indicates the right to write or change the extended attributes to the file or named pipe."},
    FileExecute          = 0x00000020
        with Documentation{Description = "This value indicates the right to execute the file."},
    FileDeleteChild      = 0x00000040
        with Documentation{Description = "This value indicates the right to delete entries within a directory."},
    FileReadAttributes   = 0x00000080
        with Documentation{Description = "This value indicates the right to read the attributes of the file."},
    FileWriteAttributes  = 0x00000100
        with Documentation{Description = "This value indicates the right to change the attributes of the file."},
    Delete               = 0x00010000
        with Documentation{Description = "This value indicates the right to delete the file."},
    ReadControl          = 0x00020000
        with Documentation{Description = "This value indicates the right to read the security descriptor for the file or named pipe."},
    WriteDac             = 0x00040000
        with Documentation{Description = "This value indicates the right to change the discretionary access control list (DACL) in the security descriptor for the file or named pipe. For the DACL data structure, see ACL in [MS-DTYP] section 2.4.5."},
    WriteOwner           = 0x00080000
        with Documentation{Description = "This value indicates the right to change the owner in the security descriptor for the file or named pipe."},
    Synchronize          = 0x00100000
        with Documentation{Description = "This flag SHOULD NOT be used by the client and MUST be ignored by the server unless on a named pipe as discussed in section 3.2.4.3.1 and section 3.3.5.5."},
    AccessSystemSecurity = 0x01000000
        with Documentation{Description = "This value indicates the right to read or change the system access control list (SACL) in the security descriptor for the file or named pipe. For the SACL data structure, see ACL in [MS-DTYP] section 2.4.5."},
    MaximumAllowed       = 0x02000000
        with Documentation{Description = "This value indicates that the client is requesting an open to the file with the highest level of access the client has on this file. If no access is granted for the client on this file, the server MUST fail the open with STATUS_ACCESS_DENIED."},
    GenericAll           = 0x10000000
        with Documentation{Description = "This value indicates a request for all the access flags that are previously listed, except MAXIMUM_ALLOWED and ACCESS_SYSTEM_SECURITY."},
    GenericExecute       = 0x20000000
        with Documentation{Description = "This value indicates a request for the following combination of access flags listed above: FILE_READ_ATTRIBUTES, FILE_EXECUTE, SYNCHRONIZE, and READ_CONTROL."},
    GenericWrite         = 0x40000000
        with Documentation{Description = "This value indicates a request for the following combination of access flags listed above: FILE_WRITE_DATA, FILE_APPEND_DATA, FILE_WRITE_ATTRIBUTES, FILE_WRITE_EA, SYNCHRONIZE, and READ_CONTROL."},
    GenericRead          = 0x80000000
        with Documentation{Description = "This value indicates a request for the following combination of access flags listed above: FILE_READ_DATA, FILE_READ_ATTRIBUTES, FILE_READ_EA, SYNCHRONIZE, and READ_CONTROL."},
    ...
};

// SMB 2.2.1.4.2   Directory_Access_Mask
pattern DirectoryAccessMask = flags ULONG
{
    FileListDirectory    = 0x00000001
        with Documentation{Description = "This value indicates the right to enumerate the contents of the directory."},
    FileAddFile          = 0x00000002
        with Documentation{Description = "This value indicates the right to create a file under the directory."},
    FileAddSubdirectory  = 0x00000004
        with Documentation{Description = "This value indicates the right to add a sub-directory under the directory."},
    FileReadEA           = 0x00000008
        with Documentation{Description = "This value indicates the right to read the extended attributes of the directory."},
    FileWriteEA          = 0x00000010
        with Documentation{Description = "This value indicates the right to write or change the extended attributes of the directory."},
    FileTraverse         = 0x00000020
        with Documentation{Description = "This value indicates the right to traverse this directory if the server enforces traversal checking."},
    FileDeleteChild      = 0x00000040
        with Documentation{Description = "This value indicates the right to delete the files and directories within this directory."},
    FileReadAttributes   = 0x00000080
        with Documentation{Description = "This value indicates the right to read the attributes of the directory."},
    FileWriteattributes  = 0x00000100
        with Documentation{Description = "This value indicates the right to change the attributes of the directory."},
    Delete               = 0x00010000
        with Documentation{Description = "This value indicates the right to delete the directory."},
    ReadControl          = 0x00020000
        with Documentation{Description = "This value indicates the right to read the security descriptor for the directory."},
    WriteDac             = 0x00040000
        with Documentation{Description = "This value indicates the right to change the DACL in the security descriptor for the directory. For the DACL data structure, see ACL in [MS-DTYP] section ."},
    WriteOwner           = 0x00080000
        with Documentation{Description = "This value indicates the right to change the owner in the security descriptor for the directory."},
    Synchronize          = 0x00100000
        with Documentation{Description = "This flag SHOULD be ignored by both clients and servers."},
    AccessSYstemSecurity = 0x01000000
        with Documentation{Description = "This value indicates the right to read or change the SACL in the security descriptor for the directory. For the SACL data structure, see ACL in [MS-DTYP] section ."},
    MaximumAllowed       = 0x02000000
        with Documentation{Description = "This value indicates that the client is requesting an open to the directory with the highest level of access that the client has on this directory. If no access is granted for the client on this directory, then the server MUST fail the open with STATUS_ACCESS_DENIED."},
    GenericAll           = 0x10000000
        with Documentation{Description = "This value indicates a request for all of the access flags that are listed above, except MAXIMUM_ALLOWED and ACCESS_SYSTEM_SECURITY."},
    GenericExecute       = 0x20000000
        with Documentation{Description = "This value indicates a request for the following access flags listed above: FILE_READ_ATTRIBUTES, FILE_TRAVERSE, SYNCHRONIZE, and READ_CONTROL."},
    GenericWrite         = 0x40000000
        with Documentation{Description = "This value indicates a request for the following access flags listed above: FILE_ADD_FILE, FILE_ADD_SUBDIRECTORY, FILE_WRITE_ATTRIBUTES, FILE_WRITE_EA, SYNCHRONIZE, and READ_CONTROL."},
    GenericRead          = 0x80000000
        with Documentation{Description = "This value indicates a request for the following access flags listed above: FILE_LIST_DIRECTORY, FILE_READ_ATTRIBUTES, FILE_READ_EA, SYNCHRONIZE, and READ_CONTROL."},
    ...
};

pattern NTTransactCreateRequestNTTransParametersDesiredAccess = flags ULONG
{
    FileReadData         = 0x00000001
        with Documentation{Description = "Indicates the right to read data from the file."},
    FileWriteData        = 0x00000002
        with Documentation{Description = "Indicates the right to write data into the file beyond the end of the file."},
    FileAppendData       = 0x00000004
        with Documentation{Description = "Indicates the right to append data to the file beyond the end of the file only."},
    FileReadEa           = 0x00000008
        with Documentation{Description = "Indicates the right to read the extended attributes of the file."},
    FileWriteEa          = 0x00000010
        with Documentation{Description = "Indicates the right to write or change the extended attributes of the file."},
    FileExecute          = 0x00000020
        with Documentation{Description = "Indicates the right to execute the file."},
    Reserved1            = 0x00000040,
    FileReadAttributes   = 0x00000080
        with Documentation{Description = "Indicates the right to read the attributes of the file."},
    FileWriteAttributes  = 0x00000100
        with Documentation{Description = "Indicates the right to change the attributes of the file."},
    Reserved2            = 0x0000FE00,
    Delete               = 0x00010000
        with Documentation{Description = "Indicates the right to delete or to rename the file."},
    ReadControl          = 0x00020000
        with Documentation{Description = "Indicates the right to read the security descriptor of the file."},
    WriteDac             = 0x00040000
        with Documentation{Description = "Indicates the right to change the discretionary access control list (DACL) in the security descriptor of the file."},
    WriteOwner           = 0x00080000
        with Documentation{Description = "Indicates the right to change the owner in the security descriptor of the file."},
    Synchronize          = 0x00100000
        with Documentation{Description = "SHOULD NOT be used by the sender and MUST be ignored by the receiver."},
    Reserved3            = 0x00E00000,
    AccessSystemSecurity = 0x01000000
        with Documentation{Description = "Indicates the right to read or change the system access control list (SACL) in the security descriptor for the file. If the SE_SECURITY_NAME privilege ([MS-LSAD] section ) is not set in the access token, the server MUST fail the open request and return STATUS_PRIVILEGE_NOT_HELD."},
    MaximumAllowed       = 0x02000000
        with Documentation{Description = "Indicates that the client requests an open to the file with the highest level of access that the client has on this file. If no access is granted for the client on this file, the server MUST fail the open and return a STATUS_ACCESS_DENIED."},
    Reserved4            = 0x0C000000,
    GenericAll           = 0x10000000
        with Documentation{Description = "Indicates a request for all of the access flags that are previously listed, except MAXIMUM_ALLOWED and ACCESS_SYSTEM_SECURITY."},
    GenericExecute       = 0x20000000
        with Documentation{Description = "Indicates a request for the following combination of access flags listed previously in this table:"},
    GenericWrite         = 0x40000000
        with Documentation{Description = "Indicates a request for the following combination of access flags listed previously in this table:"},
    GenericRead          = 0x80000000
        with Documentation{Description = "Indicates a request for the following combination of access flags listed previously in this table:"},
} with Documentation{EmbeddedType = true};

pattern NTTransactCreateRequestNTTransParametersFlags = flags ULONG
{
    Reserved1              = 0x00000001,
    NTCreateRequestOplock  = 0x00000002
        with Documentation{Description = "Level I (exclusive) OpLock requested."},
    NTCreateRequestOpbatch = 0x00000004
        with Documentation{Description = "Batch OpLock requested."},
    NTCreateOpenTargetDir  = 0x00000008
        with Documentation{Description = "The parent directory of the target is to be opened."},
    Reserved2              = 0xFFFFFFF0,
} with Documentation{EmbeddedType = true};

// 2.2.7.1   NT_TRANSACT_CREATE (0x0001)
type NTTransactCreateResponseNTTransparameters[UCHAR WordCount]
{
    NTTransactCreateResponseNTTransParametersOplockLevel OplockLevel
        with Documentation{Description = "UCHAR The OpLock level granted to the client process."};
    UCHAR ResponseType
        with Documentation{Description = "UCHAR Reserved and MUST be zero (0x00)."};
    USHORT Fid
        with Documentation{Description = "USHORT The file ID value representing the file or directory that was created or opened."};
    ULONG CreateAction
        with Documentation{Description = "ULONG The action taken in establishing the open. This field MUST contain one of the following values:"};
    ULONG EAErrorOffset
        with Documentation{Description = "ULONG Offset of the extended attribute that caused an error if an error occurred with an extended attribute."};
    FILETIME CreationTime
        with Documentation{Description = "FILETIME A 64-bit integer value representing the time that the file was created. The time value is a signed 64-bit integer representing either an absolute time or a time interval. Times are specified in units of 100ns. A positive value expresses an absolute time, where the base time (the 64- bit integer with value 0) is the beginning of the year 1601 AD in the Gregorian calendar. A negative value expresses a time interval relative to some base time, usually the current time."};
    FILETIME LastAccessTime
        with Documentation{Description = "FILETIME The time that the file was last accessed, encoded in the same format as CreationTime."};
    FILETIME LastWriteTime
        with Documentation{Description = "FILETIME The time that the file was last written, encoded in the same format as CreationTime."};
    FILETIME LastChangeTime
        with Documentation{Description = "FILETIME The time that the file was last changed, encoded in the same format as CreationTime."};
    SmbExtFileAttr ExtFileAttributes
        with Documentation{Description = "This field contains the extended file attributes the file, encoded as an SMB_EXT_FILE_ATTR data type."};
    LARGE_INTEGER AllocationSize
        with Documentation{Description = "LARGE_INTEGER The number of bytes allocated to the file by the server."};
    LARGE_INTEGER EndOfFile
        with Documentation{Description = "LARGE_INTEGER The end of file offset value."};
    SmbComNTCreateAndxResponseResourceType ResourceType
        with Documentation{Description = "The file type. This field MUST be interpreted as follows."};
    SmbNMPipeStatus NmpipeStatus
        with Documentation{Description = "A 16-bit field that shows the status of the named pipe if the resource type created is a named pipe. This field is formatted as an SMB_NMPIPE_STATUS."};
    UCHAR Directory
        with Documentation{Description = "UCHAR If the returned FID represents a directory, the server MUST set this value to a nonzero (0x00) value. If the FID is not a directory, the server MUST set this value to 0x00 (FALSE)."};
    optional [|WordCount == 0x2A|] guid VolumeGuid
        with Documentation{Description = "This field MUST be a GUID value that uniquely identifies the volume on which the file resides."};
    optional [|WordCount == 0x2A|] LARGE_INTEGER FileID
        with Documentation{Description = "This field MUST be a 64-bit opaque value that uniquely identifies this file on a volume."};
    optional [|WordCount == 0x2A|] FilePipePrinterAccessMask MaximalAccessRights
        with Documentation{Description = "The maximum access rights that the user opening the file has been granted for this file open."};
    optional [|WordCount == 0x2A|] FilePipePrinterAccessMask GuestMaximalAccessRights
        with Documentation{Description = "The maximum access rights that the guest account has when opening this file."};
    override string ToString()
    {
        return "Fid: " + DecToHexFormat(Fid) + ", ResourceType: " + EnumToString(ResourceType, "SMB.SmbComNTCreateAndxResponseResourceType");
    }
} with Documentation{EmbeddedType = true};

pattern NTTransactCreateResponseNTTransParametersOplockLevel = enum UCHAR
{
    NoOpLockGranted = 0x00
        with Documentation{Description = "No OpLock granted."},
    ExclusiveOpLockGranted = 0x01
        with Documentation{Description = "Exclusive OpLock granted."},
    BatchOpLockGranted = 0x02
        with Documentation{Description = "Batch OpLock granted."},
    LevelIIOpLockGranted = 0x03
        with Documentation{Description = "Level II OpLock granted."},
} with Documentation{EmbeddedType = true};

// 2.2.7.2   NT_TRANSACT_IOCTL (0x0002)
type NTTransactIoctlRequestSetup
{
    ULONG FunctionCode with DisplayInfo{ToText = SMB.CtlCodeToText},
        Documentation{Description = "ULONG The control code of the file system control or device control (FSCTL/IOCTL) method. The values are defined in [MS-FSCC] section ."};
    USHORT Fid
        with Documentation{Description = "USHORT MUST contain a valid FID obtained from a previously successful SMB open command. The FID MUST be for either an I/O device or for a file system control device. The type of FID being supplied is specified by IsFctl."};
    BOOLEAN IsFsctl
        with Documentation{Description = "BOOLEAN This field is TRUE if the command is a file system control command and the FID is a file system control device. Otherwise, the command is a device control command and FID is an I/O device."};
    BOOLEAN IsFlags
        with Documentation{Description = "BOOLEAN If bit 0 is set, the command is to be applied to a share root handle. The share MUST be a Distributed File System (DFS) type."};
} with Documentation{EmbeddedType = true};

string CtlCodeToText(any ctlCode)
{
    uint code = ctlCode as uint;
    if (InRange<SMBIoctlCtlCode>(code))
    {
        return EnumToString(code, "SMB.SMBIoctlCtlCode");
    }
    else
    {
        return FSCC.CtlCodeToText(code);
    }
}

pattern SMBIoctlCtlCode = enum ULONG
{
    FSCTL_SRV_ENUMERATE_SNAPSHOTS                  = 0x00144064,
    FSCTL_SRV_REQUEST_RESUME_KEY                   = 0x00140078,
    FSCTL_SRV_COPYCHUNK                            = 0x001440F2,
};

type NTTransactIoctlFsctlSrvCopyChunkRequestNTTransData
{
    binary CopychunkResumeKey with BinaryEncoding{Length = 24};
    ULONG ChunkCount;
    ULONG Reserved;
    array<NTTransactIoctlSrvCopyChunk> CopychunkList with BinaryEncoding{Length = ChunkCount};
}

// SMB 2.2.7.2.1.1   SRV_COPYCHUNK (NT_TRANSACT_IOCTL (0x0002))
type NTTransactIoctlSrvCopyChunk
{
    LARGE_INTEGER SourceOffset
        with Documentation{Description = "The offset, in bytes, into the source file from which data is being copied."};
    LARGE_INTEGER DestinationOffset
        with Documentation{Description = "The offset, in bytes, into the destination file to which data is being copied."};
    ULONG CopyLength
        with Documentation{Description = "The number of bytes to copy from the source file to the destination file."};
    ULONG Reserved
        with Documentation{Description = "This field SHOULD be set to zero by the client and MUST be ignored upon receipt by the server."};
}

// SMB 2.2.7.2.2.1   FSCTL_SRV_ENUMERATE_SNAPSHOTS Response (NT_TRANSACT_IOCTL (0x0002))
type FSCTL_SRV_ENUMERATE_SNAPSHOTSResponseNTTransData
{
    ULONG NumberOfSnapShots
        with Documentation{Description = "The number of snapshots that the underlying object store contains of this file."};
    ULONG NumberOfSnapShotsReturned
        with Documentation{Description = "This value MUST be the number of snapshots that are returned in this response. If this value is less than NumberofSnapshots, then there are more snapshots than were able to fit in this response."};
    ULONG SnapShotArraySize
        with Documentation{Description = "The length, in bytes, of the SnapShotMultiSZ field."};
    ([|NumberOfSnapShotsReturned > 0|] SMBSnapShotMultiSZ[NumberOfSnapShotsReturned] | [|NumberOfSnapShotsReturned == 0|] ULONG) SnapShotMultiSZ 
        with Documentation{Description = "A concatenated list of available snapshots. Each snapshot MUST be encoded as a NULL-terminated sequence of 16-bit Unicode characters, and MUST take on the following form: @GMT-YYYY.MM.DD-HH.MM.SS. The concatenated list MUST be terminated by two additional 16-bit Unicode NULL characters. If the response contains no snapshots, then the server MUST set this field to two 16-bitUnicode NULL characters."};
}

// SnapShotMultiSZ (variable):  A concatenated list of available snapshots. Each snapshot MUST be encoded as a NULL-terminated sequence of 16-bit Unicode characters, and MUST take on the following form: @GMT-YYYY.MM.DD-HH.MM.SS. 
// The concatenated list MUST be terminated by two additional 16-bit Unicode NULL characters. If the response contains no snapshots, then the server MUST set this field to two 16-bitUnicode NULL characters.
type SMBSnapShotMultiSZ[ULONG numberOfSnapShotsReturned]
{
    array<SnapShotString> SnapShot with BinaryEncoding{Length = numberOfSnapShotsReturned};
    USHORT NullTerminator;
}

pattern SnapShotString = string with BinaryEncoding{TextEncoding = TextEncoding.UTF16};

// SMB 2.2.7.2.2.2   FSCTL_SRV_REQUEST_RESUME_KEY Response (NT_TRANSACT_IOCTL (0x0002))
type FSCTL_SRV_REQUEST_RESUME_KEYResponseNTTransData
{
    binary CopychunkResumeKey with BinaryEncoding{Length = 24},
        Documentation{Description = "A 24-byte copychunk resume key generated by the server that can be subsequently used by the client to uniquely identify the open source file in a FSCTL_SRV_COPYCHUNK request. The client MUST NOT attach any interpretation to this key and MUST treat it as an opaque value. For more information, see section 3.3.5.10.1."};
    ULONG ContextLength
        with Documentation{Description = "The length, in bytes, of the Context field. Since this feature is not used, this field SHOULD be set to zero by the server and MUST be ignored by the client."};
    optional [|ContextLength > 0|] binary Context with BinaryEncoding{Length = ContextLength},
        Documentation{Description = "The copychunk resume key's extended context information. Since this feature is not used, this field SHOULD<65> be zero bytes in length. The client MUST ignore it on receipt."};
}

// SMB 2.2.7.2.2.3   FSCTL_SRV_COPYCHUNK Response (NT_TRANSACT_IOCTL (0x0002))
type FSCTL_SRV_COPYCHUNKResponseNTTransData
{
    ULONG ChunksWritten
        with Documentation{Description = "This field MUST represent the number of copychunk operations successfully processed by the server."};
    ULONG ChunkBytesWritten
        with Documentation{Description = "This field is unused. This field MUST be set to zero by the server and MUST be ignored by the client."};
    ULONG TotalBytesWritten
        with Documentation{Description = "This field MUST represent the total number of bytes written to the destination file across all copychunk operations."};
}

// 2.2.7.3   NT_TRANSACT_SET_SECURITY_DESC (0x0003)
type NTTransactSetSecurityDescRequestNTTransData
{
    SECURITY_DESCRIPTOR_NonRpc SECURITY_DESCRIPTOR
        with Documentation{Description = "SECURITY_DESCRIPTOR The requested security descriptor structure. The self-relative form of a SECURITY_DESCRIPTOR is required. For details, see [MS-DTYP] SECURITY_DESCRIPTOR (section )."};
} with Documentation{EmbeddedType = true};

type NTTransactSetSecurityDescRequestNTTransParameters
{
    USHORT Fid
        with Documentation{Description = "USHORT File identifier or handle of the target file."};
    USHORT Reserved where value == 0x0000
        with Documentation{Description = "USHORT Reserved. This value MUST be 0x0000."};
    NTTransactSetSecurityDescRequestNTTransParametersSecurityInformation SECURITY_INFORMATION
        with Documentation{Description = "ULONG Fields of security descriptor to be set. This is a bit field. These values can be logically OR-ed together to set several descriptors in one request. The server MUST set only the descriptors requested by SECURITY_INFORMATION."};
    override string ToString()
    {
        return "Fid: " + DecToHexFormat(Fid);
    }
} with Documentation{EmbeddedType = true};

pattern NTTransactSetSecurityDescRequestNTTransParametersSecurityInformation = flags ULONG
{
    OwnerSecurityInformation    = 0x00000001
        with Documentation{Description = "Owner of the object or resource."},
    GroupSecurityInformation    = 0x00000002
        with Documentation{Description = "Group associated with the object or resource."},
    DaclSecurityInformation     = 0x00000004
        with Documentation{Description = "Discretionary access control list (DACL) associated with the object or resource."},
    SaclSecurityInformation     = 0x00000008
        with Documentation{Description = "System access control list (SACL) associated with the object or resource."},
    LabelSecurityInformation    = 0x00000010
        with Documentation{Description = "Integrity label in the security descriptor of the file or named pipe."},
    AttributeSecurityInformation = 0x00000020
        with Documentation{Description = "Resource attribute in the security descriptor of the file or named pipe."},
    ScopeSecurityInformation    = 0x00000040
        with Documentation{Description = "Central access policy of resource in the security descriptor of the file or named pipe."},
    BackupSecurityInformation   = 0x00000080
        with Documentation{Description = "Security descriptor information used for backup operation."},
    Reserved                    = 0xFFFFFF00,
} with Documentation{EmbeddedType = true};

// 2.2.7.4   NT_TRANSACT_NOTIFY_CHANGE (0x0004)
type NTTransactNotifyChangeRequestSetup
{
    NTTransactNotifyChangeRequestSetupCompletionFilter CompletionFilter
        with Documentation{Description = "A 32-bit field of flags that specify the types of operations to monitor."};
    USHORT Fid
        with Documentation{Description = "The FID of the directory to monitor."};
    BOOLEAN WatchTree
        with Documentation{Description = "If all subdirectories are to be watched, then this field MUST be set to TRUE; otherwise, it MUST be set to FALSE."};
    UCHAR Reserved where value == 0x00
        with Documentation{Description = "Reserved. This value MUST be 0x00."};
    override string ToString()
    {
        return "CompletionFilter: " + EnumToString(CompletionFilter, "SMB.NTTransactNotifyChangeRequestSetupCompletionFilter") + ", Fid: " + DecToHexFormat(Fid);
    }
} with Documentation{EmbeddedType = true};

pattern NTTransactNotifyChangeRequestSetupCompletionFilter = flags ULONG
{
    FileNotifyChangeFileName    = 0x00000001,
    FileNotifyChangeDirName     = 0x00000002,
    FileNotifyChangeName        = 0x00000003,
    FileNotifyChangeAttributes  = 0x00000004,
    FileNotifyChangeSize        = 0x00000008,
    FileNotifyChangeLastWrite   = 0x00000010,
    FileNotifyChangeLastAccess  = 0x00000020,
    FileNotifyChangeCreation    = 0x00000040,
    FileNotifyChangeEa          = 0x00000080,
    FileNotifyChangeSecurity    = 0x00000100,
    FileNotifyChangeStreamName  = 0x00000200,
    FileNotifyChangeStreamSize  = 0x00000400,
    FileNotifyChangeStreamWrite = 0x00000800,
    Reserved                    = 0xFFFFF000
} with Documentation{EmbeddedType = true};

// 2.2.7.4   NT_TRANSACT_NOTIFY_CHANGE (0x0004)
type NTTransactNotifyChangeResponseNTTransParameters[bool IsFlags2Unicode]
{
    NTTransactNotifyChangeResponseNTTransParametersFileNotifyInformationList[IsFlags2Unicode] FileNotifyInformation
        with Documentation{Description = "Array of FILE_NOTIFY_INFORMATION The response contains FILE_NOTIFY_INFORMATION structures, as defined following. The NextEntryOffset field of the structure specifies the offset, in bytes, from the start of the current entry to the next entry in the list. If this is the last entry in the list, this field is 0x00000000. Each entry in the list MUST be DWORD aligned (32-bit aligned), so NextEntryOffset MUST be a multiple of 4."};
} with Documentation{EmbeddedType = true};

type NTTransactNotifyChangeResponseNTTransParametersFileNotifyInformationList[bool IsFlags2Unicode]
{
    NTTransactNotifyChangeResponseNTTransParametersFileNotifyInformation[IsFlags2Unicode] Entry;
    optional [|Entry.NextEntryOffset != 0|] NTTransactNotifyChangeResponseNTTransParametersFileNotifyInformationList[IsFlags2Unicode] NextEntry;
}

type NTTransactNotifyChangeResponseNTTransParametersFileNotifyInformation[bool IsFlags2Unicode]
{
    ULONG NextEntryOffset
        with Documentation{Description = "ULONG Offset, in bytes, from the start of the current entry to the next entry in the list. Each entry in the list MUST be 4-byte aligned, so NextEntryOffset MUST be a multiple of 4. If this is the last entry in the list, the value is 0x00000000."};
    NTTransactNotifyChangeResponseNTTransParametersFileNotifyInformationAction Action
        with Documentation{Description = "ULONG Action taken for the specified file name."};
    ULONG FileNameLength
        with Documentation{Description = "ULONG Length, in bytes, of the name of the changed file."};
    string FileName1 with BinaryEncoding{TextEncoding = ((IsFlags2Unicode == false) ? TextEncoding.ASCII : TextEncoding.UTF16), Length = (IsFlags2Unicode ? FileNameLength / 2 : FileNameLength)},
        Documentation{Description = "Array of UCHAR The file name of the file that has been changed. The name MUST NOT be null-terminated. The name is either in the OEM character set or in Unicode characters, depending upon the state of the SMB_FLAGS2_UNICODE bit in the Flags2 field of the SMB The windows_nt_server implementation of NT_TRANSACT_NOTIFY_CHANGE always returns the names of changed files in Unicode format."};
    optional [|NextEntryOffset > 12 + FileNameLength|] binary Padding with BinaryEncoding{Length = (NextEntryOffset - 12 - FileNameLength)};
} with Documentation{Description = "Array of FILE_NOTIFY_INFORMATION The response contains FILE_NOTIFY_INFORMATION structures, as defined following. The NextEntryOffset field of the structure specifies the offset, in bytes, from the start of the current entry to the next entry in the list. If this is the last entry in the list, this field is 0x00000000. Each entry in the list MUST be DWORD aligned (32-bit aligned), so NextEntryOffset MUST be a multiple of 4."},
       Documentation {EmbeddedType = true};

pattern NTTransactNotifyChangeResponseNTTransParametersFileNotifyInformationAction = enum ULONG
{
    FileActionAdded          = 0x00000001,
    FileActionRemoved        = 0x00000002,
    FileActionModified       = 0x00000003,
    FileActionRenamedOldName = 0x00000004,
    FileActionRenamedNewName = 0x00000005,
    FileActionAddedStream    = 0x00000006,
    FileActionRemovedStream  = 0x00000007,
    FileActionModifiedStream = 0x00000008
} with Documentation{EmbeddedType = true};

// 2.2.7.5   NT_TRANSACT_RENAME (0x0005)
// Message not implemented.

// 2.2.7.6   NT_TRANSACT_QUERY_SECURITY_DESC (0x0006)
type NTTransactQuerySecurityDescRequestNTTransParameters
{
    USHORT Fid
        with Documentation{Description = "USHORT FID of the target file. The FID MUST have been obtained through a previously successful SMB open request."};
    USHORT Reserved where value == 0x0000
        with Documentation{Description = "USHORT Reserved. This value MUST be 0x0000."};
    RequestNTTransParametersSecurityInfoFields SecurityInfoFields
        with Documentation{Description = "ULONG A 32-bit field representing the requested fields of the security descriptor to be retrieved. These values can be logically OR-ed together to request several descriptors in one request. The descriptor response format contains storage for all of the descriptors. The client MUST ignore the values returned for descriptors corresponding to bits that were not included in this field as part of the request."};
    override string ToString()
    {
        return "Fid: " + DecToHexFormat(Fid);
    }
} with Documentation{EmbeddedType = true};

pattern RequestNTTransParametersSecurityInfoFields = flags ULONG
{
    OwnerSecurityInformation    = 0x00000001
        with Documentation{Description = "Owner of the object or resource."},
    GroupSecurityInformation    = 0x00000002
        with Documentation{Description = "Group associated with the object or resource."},
    DaclSecurityInformation     = 0x00000004
        with Documentation{Description = "Discretionary access control list (DACL) associated with the object or resource."},
    SaclSecurityInformation     = 0x00000008
        with Documentation{Description = "System access control list (SACL) associated with the object or resource."},
    LabelSecurityInformation    = 0x00000010
        with Documentation{Description = "Integrity label in the security descriptor of the file or named pipe."},
    AttributeSecurityInformation = 0x00000020
        with Documentation{Description = "Resource attribute in the security descriptor of the file or named pipe."},
    ScopeSecurityInformation    = 0x00000040
        with Documentation{Description = "Central access policy of resource in the security descriptor of the file or named pipe."},
    BackupSecurityInformation   = 0x00000080
        with Documentation{Description = "Security descriptor information used for backup operation."},
    Reserved                    = 0xFFFFFFF0,
} with Documentation{EmbeddedType = true};

// 2.2.7.6   NT_TRANSACT_QUERY_SECURITY_DESC (0x0006)
type NTTransactQuerySecurityDescResponseNTTransData
{
    SECURITY_DESCRIPTOR_NonRpc SECURITY_DESCRIPTOR
        with Documentation{Description = "The requested security descriptor structure. The self-relative form of a SECURITY_DESCRIPTOR structure is returned. For details, see SECURITY_DESCRIPTOR ([MS-DTYP] section )."};
} with Documentation{EmbeddedType = true};

type NTTransactQuerySecurityDescResponseNTTransParameters
{
    ULONG LengthNeeded
        with Documentation{Description = "The length of the returned SECURITY_DESCRIPTOR field."};
} with Documentation{EmbeddedType = true};

// SMB 2.2.7.5   NT_TRANSACT_QUERY_QUOTA (0x0007)
type NTTransactQueryQuotaRequestNTTransParameters
{
    USHORT Fid
        with Documentation{Description = "An Fid to a file or directory. The quota information of the object store underlying the file or directory MUST be queried."};
    UCHAR ReturnSingleEntry
        with Documentation{Description = "If TRUE (any non-zero value), then this field indicates that the server behavior is to be restricted to only return a single SID's quota information instead of filling the entire buffer."};
    UCHAR RestartScan
        with Documentation{Description = "If TRUE (any non-zero value), then this field indicates that the scan of quota information is to be restarted."};
    ULONG SidListLength
        with Documentation{Description = "If non-zero, then this field indicates that the client is requesting quota information of a particular set of SIDs and MUST represent the length of the NT_Trans_Data.SidList field."};
    ULONG StartSidLength
        with Documentation{Description = "If non-zero, then this field indicates that the SidList field contains a start SID (that is, a single SID entry indicating to the server where to start user quota information enumeration) and MUST represent the length, in bytes, of that SidList entry."};
    ULONG StartSidOffset
        with Documentation{Description = "If StartSidLength is non-zero, then this field MUST represent the offset from the start of the NT_Trans_Data to the specific SidList entry at which to begin user quota information enumeration. Otherwise, this field SHOULD be set to zero and MUST be ignored by the server."};
} with Documentation{EmbeddedType = true};

type NTTransactQueryQuotaResponseNTTransParameters
{
    ULONG DataLength
        with Documentation{Description = "The length, in bytes, of the returned user quota information. This field MUST be equal to the SMB_Parameters.Words.TotalDataCount field."};
} with Documentation{EmbeddedType = true};

// SMB 2.2.7.6   NT_TRANSACT_SET_QUOTA (0x0008)
type NTTransactSetQuotaRequestNTTransParameters
{
    USHORT Fid
        with Documentation{Description = "An Fid to a file or directory. The quota information of the object store underlying the file or directory MUST be queried."};
} with Documentation{EmbeddedType = true};

// 2.2.8.1   FIND Information Levels
type SmbFindInfoLevels[USHORT InfoLevel, bool ResumeKeyExist, bool IsFlags2Unicode]
{
    array<([|InfoLevel == FindInformationLevelCodes.SMB_INFO_STANDARD|] SmbFindInfoStandard[ResumeKeyExist, IsFlags2Unicode]                            //0x0001
        | [|InfoLevel == FindInformationLevelCodes.SMB_INFO_QUERY_EA_SIZE|] SmbFindInfoQueryEASize[ResumeKeyExist, IsFlags2Unicode]                       //0x0002
        | [|InfoLevel == FindInformationLevelCodes.SMB_INFO_QUERY_EAS_FROM_LIST|] SmbFindInfoQueryEasFromList[ResumeKeyExist, IsFlags2Unicode]             //0x0003
        | [|InfoLevel == FindInformationLevelCodes.SMB_FIND_FILE_DIRECTORY_INFO|] SmbFindInfoFileDirectory[IsFlags2Unicode]                               //0x0101
        | [|InfoLevel == FindInformationLevelCodes.SMB_FIND_FILE_FULL_DIRECTORY_INFO|] SmbFindInfoFileFullDirectory[IsFlags2Unicode]                       //0x0102
        | [|InfoLevel == FindInformationLevelCodes.SMB_FIND_FILE_NAMES_INFO|] SmbFindInfoFileNames[IsFlags2Unicode]                                       //0x0103
        | [|InfoLevel == FindInformationLevelCodes.SMB_FIND_FILE_BOTH_DIRECTORY_INFO|] SmbFindInfoFileBothDirectory[IsFlags2Unicode]                       //0x0104
        | [|InfoLevel == FindInformationLevelCodes.SMB_FIND_FILE_ID_FULL_DIRECTORY_INFO|] SmbFindFileIDFullDirectoryInfo[IsFlags2Unicode]                   //0x0105
        | [|InfoLevel == FindInformationLevelCodes.SMB_FIND_FILE_ID_BOTH_DIRECTORY_INFO|] SmbFindFileIDBothDirectoryInfo[IsFlags2Unicode])> FindInfoLevels; //0x0106
}

// 2.2.8.1.1   SMB_INFO_STANDARD
type SmbFindInfoStandard[bool ResumeKeyExist, bool IsFlags2Unicode]
{
    optional [|ResumeKeyExist|] ULONG ResumeKey
        with Documentation{Description = "(4 bytes): This field is optional. If the SMB_FIND_RETURN_RESUME_KEYS bit is set in the Flags field of the TRANS2_FIND_FIRST2 Request parameters, this field MUST contain the server-generated resume key. The resume key MUST be supplied in subsequent TRANS2_FIND_NEXT2 Requests to continue the search. If the SMB_FIND_RETURN_RESUME_KEYS bit is not set, then the server MUST NOT include this field."};
    SmbDate CreationDate
        with Documentation{Description = "(2 bytes): This field contains the date when the file was created."};
    SmbTime CreationTime
        with Documentation{Description = "(2 bytes): This field contains the time when the file was created."};
    SmbDate LastAccessDate
        with Documentation{Description = "(2 bytes): This field contains the date when the file was last accessed."};
    SmbTime LastAccessTime
        with Documentation{Description = "(2 bytes): This field contains the time when the file was last accessed."};
    SmbDate LastWriteDate
        with Documentation{Description = "(2 bytes): This field contains the date when data was last written to the file."};
    SmbTime LastWriteTime
        with Documentation{Description = "(2 bytes): This field contains the time when data was last written to the file."};
    ULONG FileDataSize
        with Documentation{Description = "(4 bytes): This field contains the file size, in filesystem allocation units."};
    ULONG AllocationSize
        with Documentation{Description = "(4 bytes): This field contains the size of the filesystem allocation unit, in bytes."};
    SmbFileAttributes Attributes
        with Documentation{Description = "(2 bytes): This field contains the file attributes."};
    UCHAR FileNameLength
        with Documentation{Description = "(1 byte): This field contains the length of the FileName field, in bytes."};
    optional [|IsFlags2Unicode|] UCHAR Pad;
    SmbStringWithLength[IsFlags2Unicode, (IsFlags2Unicode ? FileNameLength / 2 : FileNameLength) as uint] FileName
        with Documentation{Description = "(variable): This field contains the name of the file.windows_nt servers append a single NULL padding character to this field. If CAP_UNICODE has been negotiated, the server appends two NULL bytes to this field; otherwise, one NULL byte is appended. The length of the terminating NULL character is not included in the value of the FileNameLength field."};
} with Documentation{Description = "This information level structure is used in TRANS2_FIND_FIRST2 and TRANS2_FIND_NEXT2 responses to return the following information for all files that match the request\'s search criteria:"};

// 2.2.8.1.2   SMB_INFO_QUERY_EA_SIZE
type SmbFindInfoQueryEASize[bool ResumeKeyExist, bool IsFlags2Unicode]
{
    optional [|ResumeKeyExist|] ULONG ResumeKey
        with Documentation{Description = "(4 bytes): This field is optional. If the SMB_FIND_RETURN_RESUME_KEYS bit is set in the Flags field of the TRANS2_FIND_FIRST2 Request parameters, then this field MUST contain the server-generated resume key. The resume key MUST be supplied in subsequent TRANS2_FIND_NEXT2 Requests to continue the search. If the SMB_FIND_RETURN_RESUME_KEYS bit is not set, then the server MUST NOT include this field."};
    SmbDate CreationDate
        with Documentation{Description = "(2 bytes): This field contains the date when the file was created."};
    SmbTime CreationTime
        with Documentation{Description = "(2 bytes): This field contains the time when the file was created."};
    SmbDate LastAccessDate
        with Documentation{Description = "(2 bytes): This field contains the date when the file was last accessed."};
    SmbTime LastAccessTime
        with Documentation{Description = "(2 bytes): This field contains the time when the file was last accessed."};
    SmbDate LastWriteDate
        with Documentation{Description = "(2 bytes): This field contains the date when data was last written to the file."};
    SmbTime LastWriteTime
        with Documentation{Description = "(2 bytes): This field contains the time when data was last written to the file."};
    ULONG FileDataSize
        with Documentation{Description = "(4 bytes): This field contains the file size, in filesystem allocation units."};
    ULONG AllocationSize
        with Documentation{Description = "(4 bytes): This field contains the size of the filesystem allocation unit, in bytes."};
    SmbFileAttributes Attributes
        with Documentation{Description = "(2 bytes): This field contains the file attributes."};
    ULONG EaSize
        with Documentation{Description = "(4 bytes): This field contains the size of the file\'s extended attribute (EA) information, in bytes."};
    UCHAR FileNameLength
        with Documentation{Description = "(1 byte): This field contains the length of the FileName field, in bytes."};
    optional [|IsFlags2Unicode|] UCHAR Pad;
    SmbStringWithLength[IsFlags2Unicode, (IsFlags2Unicode ? FileNameLength / 2 : FileNameLength) as uint] FileName
        with Documentation{Description = "(variable): This field contains the name of the file.windows_nt servers always append a single NULL padding byte to the FileName field. The length of this additional byte is not included in the value of the FileNameLength field."};
} with Documentation{Description = "This information level structure is used in TRANS2_FIND_FIRST2 and TRANS2_FIND_NEXT2 responses to return the SMB_INFO_STANDARD data along with the size of a file\'s extended attributes (EAs) list for all files that match the request\'s search criteria."};

// 2.2.8.1.3   SMB_INFO_QUERY_EAS_FROM_LIST
type SmbFindInfoQueryEasFromList[bool ResumeKeyExist, bool IsFlags2Unicode]
{
    optional [|ResumeKeyExist|] ULONG ResumeKey
        with Documentation{Description = "(4 bytes): This field is optional. If the SMB_FIND_RETURN_RESUME_KEYS bit is set in the Flags field of the TRANS2_FIND_FIRST2 Request parameters, this field MUST contain the server-generated resume key. The resume key MUST be supplied in subsequent TRANS2_FIND_NEXT2 Requests to continue the search. If the SMB_FIND_RETURN_RESUME_KEYS bit is not set, the server MUST NOT include this field."};
    SmbDate CreationDate
        with Documentation{Description = "(2 bytes): This field contains the date when the file was created."};
    SmbTime CreationTime
        with Documentation{Description = "(2 bytes): This field contains the time when the file was created."};
    SmbDate LastAccessDate
        with Documentation{Description = "(2 bytes): This field contains the date when the file was last accessed."};
    SmbTime LastAccessTime
        with Documentation{Description = "(2 bytes): This field contains the time when the file was last accessed."};
    SmbDate LastWriteDate
        with Documentation{Description = "(2 bytes): This field contains the date when data was last written to the file."};
    SmbTime LastWriteTime
        with Documentation{Description = "(2 bytes): This field contains the time when data was last written to the file."};
    ULONG FileDataSize
        with Documentation{Description = "(4 bytes): This field contains the file size, in filesystem allocation units."};
    ULONG AllocationSize
        with Documentation{Description = "(4 bytes): This field contains the size of the filesystem allocation unit, in bytes."};
    SmbFileAttributes Attributes
        with Documentation{Description = "(2 bytes): This field contains the file attributes."};
    SmbFeaList ExtendedAttributeList
        with Documentation{Description = "(variable): A list of all of the extended attribute (EA) name/value pairs assigned to the file."};
    UCHAR FileNameLength
        with Documentation{Description = "(1 byte): This field contains the length of the FileName field, in bytes.If CAP_UNICODE has been negotiated, windows_nt servers set the FileNameLength field to an arbitrary value."};
    optional [|IsFlags2Unicode|] UCHAR Pad;
    SmbStringWithLength[IsFlags2Unicode, (IsFlags2Unicode ? FileNameLength / 2 : FileNameLength) as uint] FileName
        with Documentation{Description = "(variable): This field contains the name of the file.windows_nt servers always append a single NULL padding byte to the FileName field.  The length of this additional byte is not included in the value of the FileNameLength field."};
} with Documentation{Description = "This information level structure is used in TRANS2_FIND_FIRST2 and TRANS2_FIND_NEXT2 responses to return the SMB_INFO_QUERY_EA_SIZE data along with a specific list of EAs for all files that match the request\'s search criteria. The requested EAs are provided in the Trans2_Data block of the request."};

// 2.2.8.1.4   SMB_FIND_FILE_DIRECTORY_INFO
type SmbFindInfoFileDirectory[bool IsFlags2Unicode]
{
    ULONG NextEntryOffset
        with Documentation{Description = "(4 bytes): This field contains the offset, in bytes, from this entry in the list to the next entry in the list. If there are no additional entries the value MUST be zero (0x00000000)."};
    ULONG FileIndex
        with Documentation{Description = "(4 bytes): This field SHOULDwindows-based CIFS servers set the FileIndex field to a nonzero value if the underlying object store supports indicating the position of a file within the parent directory. be set to zero when sent in a response and SHOULD be ignored when received by the client."};
    FILETIME CreateTime
        with Documentation{Description = "(8 bytes): This field contains the date and time when the file was created."};
    FILETIME LastAccessTime
        with Documentation{Description = "(8 bytes): This field contains the date and time when the file was last accessed."};
    FILETIME LastWriteTime
        with Documentation{Description = "(8 bytes): This field contains the date and time when data was last written to the file."};
    FILETIME LastAttrChangeTime
        with Documentation{Description = "(8 bytes): This field contains the date and time when the file attributes where last changed."};
    LARGE_INTEGER EndOfFile
        with Documentation{Description = "(8 bytes): This field contains the offset, in bytes, to the start of the file to the first byte after the end of the file."};
    LARGE_INTEGER AllocationSize
        with Documentation{Description = "(8 bytes): This field contains the file allocation size, in bytes. Usually, this value is a multiple of the sector or cluster size of the underlying physical device."};
    SmbExtFileAttr ExtFileAttributes
        with Documentation{Description = "(4 bytes): This field contains the extended file attributes of the file, encoded as an SMB_EXT_FILE_ATTR data type."};
    ULONG FileNameLength
        with Documentation{Description = "(4 bytes): This field contains the length of the FileName field, in bytes.If CAP_UNICODE has not been negotiated, windows_nt servers include the length of the terminating NULL byte in the value of the FileNameLength field."};
    SmbStringWithLength[IsFlags2Unicode, (IsFlags2Unicode ? FileNameLength / 2 : FileNameLength)] FileName
        with Documentation{Description = "(variable): This field contains the name of the file.windows_nt servers append an arbitrary number of extra NULL padding bytes to the FileName field. The length of these additional NULL bytes is not included in the value of the FileNameLength field unless CAP_UNICODE has not been negotiated. If CAP_UNICODE has not been negotiated, only the length of the first NULL byte is included in the value of the FileNameLength field."};
    optional [|NextEntryOffset > 64 + FileNameLength|] binary Padding with BinaryEncoding{Length = (NextEntryOffset - 64 - FileNameLength)};
} with Documentation{Description = "This information level structure is used in TRANS2_FIND_FIRST2 and TRANS2_FIND_NEXT2 responses to return the following information for all files that match the request\'s search criteria:"};

// 2.2.8.1.5   SMB_FIND_FILE_FULL_DIRECTORY_INFO
type SmbFindInfoFileFullDirectory[bool IsFlags2Unicode]
{
    ULONG NextEntryOffset
        with Documentation{Description = "(4 bytes): This field contains the offset, in bytes, from this entry in the list to the next entry in the list. If there are no additional entries, the value MUST be zero (0x00000000)."};
    ULONG FileIndex
        with Documentation{Description = "(4 bytes): This field SHOULDwindows-based CIFS servers set the FileIndex field to a nonzero value if the underlying object store supports indicating the position of a file within the parent directory. be set to zero when sent in a response and SHOULD be ignored when received by the client."};
    FILETIME CreationTime
        with Documentation{Description = "(8 bytes): This field contains the date and time when the file was created."};
    FILETIME LastAccessTime
        with Documentation{Description = "(8 bytes): This field contains the date and time when the file was last accessed."};
    FILETIME LastWriteTime
        with Documentation{Description = "(8 bytes): This field contains the date and time when data was last written to the file."};
    FILETIME LastAttrChangeTime
        with Documentation{Description = "(8 bytes): This field contains the date and time when the file attributes where last changed."};
    LARGE_INTEGER EndOfFile
        with Documentation{Description = "(8 bytes): This field contains the offset, in bytes, from the start of the file to the first byte after the end of the file."};
    LARGE_INTEGER AllocationSize
        with Documentation{Description = "(8 bytes): This field contains the file allocation size, in bytes. Usually, this value is a multiple of the sector or cluster size of the underlying physical device."};
    SmbExtFileAttr ExtFileAttributes
        with Documentation{Description = "(4 bytes): This field contains the extended file attributes of the file, encoded as an SMB_EXT_FILE_ATTR data type."};
    ULONG FileNameLength
        with Documentation{Description = "(4 bytes): This field contains the length of the FileName field, in bytes.If CAP_UNICODE has not been negotiated, windows_nt servers include the length of one NULL padding byte in the FileNameLength field value."};
    ULONG EaSize
        with Documentation{Description = "(4 bytes): This field contains the size of the file\'s extended attribute (EA) information, in bytes."};
    SmbStringWithLength[IsFlags2Unicode, (IsFlags2Unicode ? FileNameLength / 2 : FileNameLength)] FileName
        with Documentation{Description = "(variable): This field contains the name of the file.windows_nt servers append an arbitrary number of extra NULL padding bytes to the FileName field. The length of these additional NULL bytes is not included in the value of the FileNameLength field unless CAP_UNICODE has not been negotiated.  If CAP_UNICODE has not been negotiated, only the length of the first NULL byte is included in the value of the FileNameLength field."};
    optional [|NextEntryOffset > 68 + FileNameLength|] binary Padding with BinaryEncoding{Length = (NextEntryOffset - 68 - FileNameLength)};
} with Documentation{Description = "This information level structure is used in TRANS2_FIND_FIRST2 and TRANS2_FIND_NEXT2 responses to return the SMB_FIND_FILE_DIRECTORY_INFO data along with the size of a file\'s extended attributes (EAs) list for all files that match the request\'s search criteria."};

// 2.2.8.1.6   SMB_FIND_FILE_NAMES_INFO
type SmbFindInfoFileNames[bool IsFlags2Unicode]
{
    ULONG NextEntryOffset
        with Documentation{Description = "(4 bytes): This field contains the offset, in bytes, from this entry in the list to the next entry in the list. If there are no additional entries, the value MUST be zero (0x00000000)."};
    ULONG FileIndex
        with Documentation{Description = "(4 bytes): This field SHOULDwindows-based CIFS servers set the FileIndex field to a nonzero value if the underlying object store supports indicating the position of a file within the parent directory. be set to zero when sent in a response and SHOULD be ignored when received by the client."};
    ULONG FileNameLength
        with Documentation{Description = "(4 bytes): This field MUST contain the length of the FileName field, in bytes.If CAP_UNICODE has not been negotiated, windows_nt servers include the length of one NULL padding byte in the FileNameLength field value."};
    SmbStringWithLength[IsFlags2Unicode, (IsFlags2Unicode ? FileNameLength / 2 : FileNameLength)] FileName
        with Documentation{Description = "(variable): This field contains the name of the file.windows_nt servers append an arbitrary number of extra NULL padding bytes to the FileName field. The length of these additional NULL bytes is not included in the value of the FileNameLength field unless CAP_UNICODE has not been negotiated.  If CAP_UNICODE has not been negotiated, only the length of the first NULL byte is included in the value of the FileNameLength field."};
    optional [|NextEntryOffset > 12 + FileNameLength|] binary Padding with BinaryEncoding{Length = (NextEntryOffset - 12 - FileNameLength)};
} with Documentation{Description = "This information level structure is used in TRANS2_FIND_FIRST2 and TRANS2_FIND_NEXT2 responses to return the file name for all files that match the request\'s search criteria."};

// 2.2.8.1.7   SMB_FIND_FILE_BOTH_DIRECTORY_INFO
type SmbFindInfoFileBothDirectory[bool IsFlags2Unicode]
{
    ULONG NextEntryOffset
        with Documentation{Description = "(4 bytes): This field contains the offset, in bytes, from this entry in the list to the next entry in the list. If there are no additional entries the value MUST be zero (0x00000000)."};
    ULONG FileIndex
        with Documentation{Description = "(4 bytes): This field SHOULDwindows-based CIFS servers set the FileIndex field to a nonzero value if the underlying object store supports indicating the position of a file within the parent directory. be set to zero when sent in a response and SHOULD be ignored when received by the client."};
    FILETIME CreationTime
        with Documentation{Description = "(8 bytes): This field contains the date and time when the file was created."};
    FILETIME LastAccessTime
        with Documentation{Description = "(8 bytes): This field contains the date and time when the file was last accessed."};
    FILETIME LastWriteTime
        with Documentation{Description = "(8 bytes): This field contains the date and time when data was last written to the file."};
    FILETIME LastChangeTime
        with Documentation{Description = "(8 bytes): This field contains the date and time when the file was last changed."};
    LARGE_INTEGER EndOfFile
        with Documentation{Description = "(8 bytes): The absolute new end-of-file position as a byte offset from the start of the file. EndOfFile specifies the byte offset to the end of the file. Because this value is zero-based, it actually refers to the first free byte in the file. In other words, EndOfFile is the offset to the byte immediately following the last valid byte in the file."};
    LARGE_INTEGER AllocationSize
        with Documentation{Description = "(8 bytes): This field contains the file allocation size, in bytes. Usually, this value is a multiple of the sector or cluster size of the underlying physical device."};
    SmbExtFileAttr ExtFileAttributes
        with Documentation{Description = "(4 bytes): This field contains the extended file attributes of the file, encoded as an SMB_EXT_FILE_ATTR data type."};
    ULONG FileNameLength
        with Documentation{Description = "(4 bytes): This field MUST contain the length of the FileName field, in bytes.If CAP_UNICODE has not been negotiated, windows_nt servers include the length of one NULL padding byte in the FileNameLength field value."};
    ULONG EaSize
        with Documentation{Description = "(4 bytes): This field MUST contain the length of the FEAList, in bytes."};
    UCHAR ShortNameLength
        with Documentation{Description = "(1 byte): This field MUST contain the length of the ShortName, in bytes."};
    UCHAR Reserved
        with Documentation{Description = "(1 byte): This field is reserved and MUST be zero (0x00)."};
    string ShortName with BinaryEncoding{Length = 12},
        Documentation{Description = "(24 bytes): This field MUST contain the 8.3 name of the file in Unicode format."};
    SmbStringWithLength[IsFlags2Unicode, (IsFlags2Unicode ? FileNameLength / 2 : FileNameLength)] FileName
        with Documentation{Description = "(variable): This field contains the long name of the file.windows_nt servers append an arbitrary number of extra NULL padding bytes to the FileName field. The length of these additional NULL bytes is not included in the value of the FileNameLength field unless CAP_UNICODE has not been negotiated.  If CAP_UNICODE has not been negotiated, only the length of the first NULL byte is included in the value of the FileNameLength field."};
    optional [|NextEntryOffset > 94 + FileNameLength|] binary Padding with BinaryEncoding{Length = (NextEntryOffset - 94 - FileNameLength)};
} with Documentation{Description = "This information level structure is used in TRANS2_FIND_FIRST2 and TRANS2_FIND_NEXT2 responses to return a combination of the SMB_FILE_FULL_DIRECTORY_INFO and SMB_FIND_FILE_NAMES_INFO data for all files that match the request\'s search criteria."};

// SMB 2.2.8.1.2   SMB_FIND_FILE_ID_FULL_DIRECTORY_INFO
type SmbFindFileIDFullDirectoryInfo[bool IsFlags2Unicode]
{
    ULONG NextEntryOffset
        with Documentation{Description = "(4 bytes): This field contains the offset, in bytes, from this entry in the list to the next entry in the list. If there are no additional entries the value MUST be zero (0x00000000)."};
    ULONG FileIndex
        with Documentation{Description = "(4 bytes): This field SHOULDwindows-based CIFS servers set the FileIndex field to a nonzero value if the underlying object store supports indicating the position of a file within the parent directory. be set to zero when sent in a response and SHOULD be ignored when received by the client."};
    FILETIME CreationTime
        with Documentation{Description = "(8 bytes): This field contains the date and time when the file was created."};
    FILETIME LastAccessTime
        with Documentation{Description = "(8 bytes): This field contains the date and time when the file was last accessed."};
    FILETIME LastWriteTime
        with Documentation{Description = "(8 bytes): This field contains the date and time when data was last written to the file."};
    FILETIME LastAttrChangeTime
        with Documentation{Description = "(8 bytes): This field contains the date and time when the file was last changed."};
    LARGE_INTEGER EndOfFile
        with Documentation{Description = "(8 bytes): The absolute new end-of-file position as a byte offset from the start of the file. EndOfFile specifies the byte offset to the end of the file. Because this value is zero-based, it actually refers to the first free byte in the file. In other words, EndOfFile is the offset to the byte immediately following the last valid byte in the file."};
    LARGE_INTEGER AllocationSize
        with Documentation{Description = "(8 bytes): This field contains the file allocation size, in bytes. Usually, this value is a multiple of the sector or cluster size of the underlying physical device."};
    SmbExtFileAttr ExtFileAttributes
        with Documentation{Description = "(4 bytes): This field contains the extended file attributes of the file, encoded as an SMB_EXT_FILE_ATTR data type."};
    ULONG FileNameLength
        with Documentation{Description = "(4 bytes): This field MUST contain the length of the FileName field, in bytes.If CAP_UNICODE has not been negotiated, windows_nt servers include the length of one NULL padding byte in the FileNameLength field value."};
    ULONG EaSize
        with Documentation{Description = "(4 bytes): This field MUST contain the length of the FEAList, in bytes."};
    ULONG Reserved where ValidationCheckZero(value == 0, null, true, ReferenceType.Type, "SMB", "SearchStorageType", "Trans2FindFirst2RequestParameters", value)
        with Documentation{Description = "(4 bytes): This field SHOULD be set to 0x00000000 in the server response. The client MUST ignore this field."};
    LARGE_INTEGER FileID
        with Documentation{Description = "A LARGE_INTEGER that serves as an internal file system identifier. This number MUST be unique for each file on a given volume. If a remote file system does not support unique FileId values, then the FileId field MUST be set to zero."};
    SmbStringWithLength[IsFlags2Unicode, (IsFlags2Unicode ? FileNameLength / 2 : FileNameLength)] FileName
        with Documentation{Description = "(variable): This field contains the long name of the file.windows_nt servers append an arbitrary number of extra NULL padding bytes to the FileName field. The length of these additional NULL bytes is not included in the value of the FileNameLength field unless CAP_UNICODE has not been negotiated.  If CAP_UNICODE has not been negotiated, only the length of the first NULL byte is included in the value of the FileNameLength field."};
    optional [|NextEntryOffset > 80 + FileNameLength|] binary Padding with BinaryEncoding{Length = (NextEntryOffset - 80 - FileNameLength)};
} with Documentation{Description = "This information level structure is used in TRANS2_FIND_FIRST2 and TRANS2_FIND_NEXT2 responses to return a combination of the SMB_FILE_FULL_DIRECTORY_INFO and SMB_FIND_FILE_NAMES_INFO data for all files that match the request\'s search criteria."};

// SMB 2.2.8.1.3   SMB_FIND_FILE_ID_BOTH_DIRECTORY_INFO
type SmbFindFileIDBothDirectoryInfo[bool IsFlags2Unicode]
{
    ULONG NextEntryOffset
        with Documentation{Description = "(4 bytes): This field contains the offset, in bytes, from this entry in the list to the next entry in the list. If there are no additional entries the value MUST be zero (0x00000000)."};
    ULONG FileIndex
        with Documentation{Description = "(4 bytes): This field SHOULDwindows-based CIFS servers set the FileIndex field to a nonzero value if the underlying object store supports indicating the position of a file within the parent directory. be set to zero when sent in a response and SHOULD be ignored when received by the client."};
    FILETIME CreationTime
        with Documentation{Description = "(8 bytes): This field contains the date and time when the file was created."};
    FILETIME LastAccessTime
        with Documentation{Description = "(8 bytes): This field contains the date and time when the file was last accessed."};
    FILETIME LastWriteTime
        with Documentation{Description = "(8 bytes): This field contains the date and time when data was last written to the file."};
    FILETIME LastChangeTime
        with Documentation{Description = "(8 bytes): This field contains the date and time when the file was last changed."};
    LARGE_INTEGER EndOfFile
        with Documentation{Description = "(8 bytes): The absolute new end-of-file position as a byte offset from the start of the file. EndOfFile specifies the byte offset to the end of the file. Because this value is zero-based, it actually refers to the first free byte in the file. In other words, EndOfFile is the offset to the byte immediately following the last valid byte in the file."};
    LARGE_INTEGER AllocationSize
        with Documentation{Description = "(8 bytes): This field contains the file allocation size, in bytes. Usually, this value is a multiple of the sector or cluster size of the underlying physical device."};
    SmbExtFileAttr ExtFileAttributes
        with Documentation{Description = "(4 bytes): This field contains the extended file attributes of the file, encoded as an SMB_EXT_FILE_ATTR data type."};
    ULONG FileNameLength
        with Documentation{Description = "(4 bytes): This field MUST contain the length of the FileName field, in bytes.If CAP_UNICODE has not been negotiated, windows_nt servers include the length of one NULL padding byte in the FileNameLength field value."};
    ULONG EaSize
        with Documentation{Description = "(4 bytes): This field MUST contain the length of the FEAList, in bytes."};
    UCHAR ShortNameLength
        with Documentation{Description = "(1 byte): This field MUST contain the length of the ShortName, in bytes."};
    UCHAR Reserved
        with Documentation{Description = "(1 byte): This field is reserved and MUST be zero (0x00)."};
    string ShortName with BinaryEncoding{Length = 12},
        Documentation{Description = "(24 bytes): This field MUST contain the 8.3 name of the file in Unicode format."};
    USHORT Reserved2
        with Documentation{Description = "A 16-bit unsigned integer that is used to maintain 64-bit alignment. This member MUST be 0x0000. "};
    LARGE_INTEGER FileID
        with Documentation{Description = "A LARGE_INTEGER that serves as an internal file system identifier. This number MUST be unique for each file on a given volume. If a remote file system does not support unique FileId values, then the FileId field MUST be set to zero."};
    SmbStringWithLength[IsFlags2Unicode, (IsFlags2Unicode ? FileNameLength / 2 : FileNameLength)] FileName
        with Documentation{Description = "(variable): This field contains the long name of the file.windows_nt servers append an arbitrary number of extra NULL padding bytes to the FileName field. The length of these additional NULL bytes is not included in the value of the FileNameLength field unless CAP_UNICODE has not been negotiated.  If CAP_UNICODE has not been negotiated, only the length of the first NULL byte is included in the value of the FileNameLength field."};
    optional [|NextEntryOffset > 104 + FileNameLength|] binary Padding with BinaryEncoding{Length = (NextEntryOffset - 104 - FileNameLength)};
} with Documentation{Description = "This information level structure is used in TRANS2_FIND_FIRST2 and TRANS2_FIND_NEXT2 responses to return a combination of the SMB_FILE_FULL_DIRECTORY_INFO and SMB_FIND_FILE_NAMES_INFO data for all files that match the request\'s search criteria."};

// 2.2.8.2   QUERY_FS Information Levels
type SmbQueryFsInfoLevels[USHORT InfoLevel, bool IsFlags2Unicode, USHORT Length]
{
    optional ([|InfoLevel == QueryFSInformationLevelCodes.SMB_INFO_ALLOCATION|] SmbInfoAllocation                       //0x0001
        | [|InfoLevel == QueryFSInformationLevelCodes.SMB_INFO_VOLUME|] SmbInfoVolume[IsFlags2Unicode]                  //0x0002
        | [|InfoLevel == QueryFSInformationLevelCodes.SMB_QUERY_FS_VOLUME_INFO|] SmbQueryFSVolumeInfo                     //0x0102
        | [|InfoLevel == QueryFSInformationLevelCodes.SMB_QUERY_FS_SIZE_INFO|] SmbQueryFSSizeInfo                         //0x0103
        | [|InfoLevel == QueryFSInformationLevelCodes.SMB_QUERY_FS_DEVICE_INFO|] SmbQueryFSDeviceInfo                     //0x0104
        | [|InfoLevel == QueryFSInformationLevelCodes.SMB_QUERY_FS_ATTRIBUTE_INFO|] SmbQueryFSAttributeInfo               //0x0105
        | [|InfoLevel == SmbInfoPassthrough + FileSystemInformationClasses.FileFsVolumeInformation|] FileFsVolumeInformation           //0x03E9
        | [|InfoLevel == SmbInfoPassthrough + FileSystemInformationClasses.FileFsLabelInformation|] FileFsLabelInformation             //0x03EA
        | [|InfoLevel == SmbInfoPassthrough + FileSystemInformationClasses.FileFsSizeInformation|] FileFsSizeInformation               //0x03EB
        | [|InfoLevel == SmbInfoPassthrough + FileSystemInformationClasses.FileFsDeviceInformation|] FileFsDeviceInformation           //0x03EC
        | [|InfoLevel == SmbInfoPassthrough + FileSystemInformationClasses.FileFsAttributeInformation|] FileFsAttributeInformation     //0x03ED
        | [|InfoLevel == SmbInfoPassthrough + FileSystemInformationClasses.FileFsControlInformation|] FileFsControlInformation         //0x03EE
        | [|InfoLevel == SmbInfoPassthrough + FileSystemInformationClasses.FileFsFullSizeInformation|] FileFsFullSizeInformation       //0x03EF
        | [|InfoLevel == SmbInfoPassthrough + FileSystemInformationClasses.FileFsObjectIdInformation|] FileFsObjectIdInformation       //0x03F0
        | [|InfoLevel == SmbInfoPassthrough + FileSystemInformationClasses.FileFsDriverPathInformation|] FileFsDriverPathInformation   //0x03F1
        | [|InfoLevel == SmbInfoPassthrough + FileSystemInformationClasses.FileFsSectorSizeInformation|] FileFsSectorSizeInformation   //0x03F3
        | Blob[Length as uint]) QueryFsInfoLevels;
}

// 2.2.8.2.1   SMB_INFO_ALLOCATION
type SmbInfoAllocation
{
    ULONG FileSystem
        with Documentation{Description = "(4 bytes): This field contains a file system identifier.windows servers always return zero (0x00000000)."};
    ULONG SectorUnit
        with Documentation{Description = "(4 bytes): This field contains the number of sectors per allocation unit."};
    ULONG Unit
        with Documentation{Description = "(4 bytes): This field contains the total number of allocation units."};
    ULONG Available
        with Documentation{Description = "(4 bytes): This field contains the total number of available allocation units."};
    USHORT Sector
        with Documentation{Description = "(2 bytes): This field contains the number of bytes per sector."};
} with Documentation{Description = "This information level structure is used in TRANS2_QUERY_FS_INFORMATION Responses to return allocation and size information of the object store underlying the share specified in the request."};

// 2.2.8.2.2   SMB_INFO_VOLUME
type SmbInfoVolume[bool IsFlags2Unicode]
{
    ULONG VolSerialNbr
        with Documentation{Description = "(4 bytes): This field contains the serial number of the volume."};
    UCHAR CharCount
        with Documentation{Description = "(1 byte): This field contains the number of characters in the VolumeLabel field."};
    SmbStringWithLength[IsFlags2Unicode, CharCount as uint] VolumeLabel
        with Documentation{Description = "(variable): This field contains the volume label.windows_nt servers use the FileFsVolumeInformation information class to retrieve file system volume information. See [MS-FSCC], section .If the VolumeLabelLength field of the FILE_FS_VOLUME_INFORMATION data element contains a value greater than 13, an error response is returned to the client with a status of STATUS_BUFFER_OVERFLOW (ERRDOS/ERRmoredata). Otherwise, the ulVolSerialNbr field is copied from the VolumeSerialNumber field of the FILE_FS_VOLUME_INFORMATION data element. VolumeLabelLength is copied to cCharCount and VolumeLabel is copied to VolumeLabel.windows clients request SMB_INFO_VOLUME only if CAP_NT_SMBS has not been negotiated. If CAP_NT_SMBS has been negotiated, windows clients request SMB_QUERY_FS_VOLUME_INFO instead of SMB_INFO_VOLUME.If CAP_UNICODE has been negotiated, the contents of the VolumeLabel field returned by windows_nt servers is undefined.If CAP_UNICODE has not been negotiated, windows_nt servers append an arbitrary number of extra NULL padded bytes to the VolumeLabel field."};
} with Documentation{Description = "This information level structure is used in TRANS2_QUERY_FS_INFORMATION Responses to return volume information of the object store underlying the share specified in the request."};

// 2.2.8.2.3   SMB_QUERY_FS_VOLUME_INFO
type SmbQueryFSVolumeInfo
{
    FILETIME VolumeCreationTime
        with Documentation{Description = "(8 bytes): This field contains the date and time when the volume was created."};
    ULONG SerialNumber
        with Documentation{Description = "(4 bytes): This field contains the serial number of the volume."};
    ULONG VolumeLabelSize
        with Documentation{Description = "(4 bytes): This field contains the size of the VolumeLabel field, in bytes."};
    USHORT Reserved;
    string VolumeLabel with BinaryEncoding{Length = (VolumeLabelSize / 2)},
        Documentation{Description = "(variable): This field contains the Unicode-encoded volume label."};
} with Documentation{Description = "This information level structure is used in TRANS2_QUERY_FS_INFORMATION Responses to return extended volume information of the object store underlying the share specified in the request.windows_nt_server servers use the FileFsVolumeInformation ([MS-FSCC] section ) information class to retrieve file system volume information."};

// 2.2.8.2.4   SMB_QUERY_FS_SIZE_INFO
type SmbQueryFSSizeInfo
{
    LARGE_INTEGER TotalAllocationUnits
        with Documentation{Description = "(8 bytes): This field contains the total number of allocation units assigned to the volume."};
    LARGE_INTEGER TotalFreeAllocationUnits
        with Documentation{Description = "(8 bytes): This field contains the total number of unallocated or free allocation units for the volume."};
    ULONG SectorsPerAllocationUnit
        with Documentation{Description = "(4 bytes): This field contains the number of sectors per allocation unit."};
    ULONG BytesPerSector
        with Documentation{Description = "(4 bytes): This field contains the bytes per sector."};
} with Documentation{Description = "This information level structure is used in TRANS2_QUERY_FS_INFORMATION Responses to return extended allocation and size information of the object store underlying the share specified in the request.windows_nt servers use the FileFsSizeInformation ([MS-FSCC] section ) information class to retrieve file system allocation and size information."};

// 2.2.8.2.5   SMB_QUERY_FS_DEVICE_INFO
type SmbQueryFSDeviceInfo
{
    ULONG DeviceType
        with Documentation{Description = "(4 bytes): This field contains the device type on which the volume resides."};
    ULONG DeviceCharacteristics
        with Documentation{Description = "(4 bytes): This 32-bit field of flags contains the device characteristics. The individual flags are as follows."};
} with Documentation{Description = "This information level structure is used in TRANS2_QUERY_FS_INFORMATION Responses to return device information of the object store underlying the share specified in the request.windows_nt servers use the FileFsDeviceInformation ([MS-FSCC] section ) information class to retrieve file system device information."};

// 2.2.8.2.6   SMB_QUERY_FS_ATTRIBUTE_INFO
type SmbQueryFSAttributeInfo
{
    ULONG FileSystemAttributes
        with Documentation{Description = "(4 bytes): This 32-bit field of flags contains the file system\'s attributes. The individual flags are as follows."};
    LONG MaxFileNameLengthInBytes
        with Documentation{Description = "(4 bytes): This field contains the maximum size, in bytes, of a file name on the file system."};
    ULONG LengthOfFileSystemName
        with Documentation{Description = "(4 bytes): This field contains the size, in bytes, of the FileSystemName field."};
    string FileSystemName with BinaryEncoding{Length = (LengthOfFileSystemName / 2)},
        Documentation{Description = "(variable): This field contains the Unicode-encoded name of the file system."};
} with Documentation{Description = "This information level is used to query file system attributes.windows_nt_server use the FileFsAttributeInformation ([MS-FSCC] section ) informationclass to retrieve file system attribute information.SMB_QUERY_FS_ATTRIBUTE_INFO  {  ULONG FileSystemAttributes;  LONG  MaxFileNameLengthInBytes;  ULONG LengthOfFileSystemName;  WCHAR FileSystemName[LengthOfFileSystemName/2];  }"};

// 2.2.8.3   QUERY Information Levels
type SmbQueryInfoLevels[USHORT InfoLevel, USHORT Length]
{
    optional ([|InfoLevel == QueryInformationLevelCodes.SMB_INFO_STANDARD|] SmbQueryInfoStandard
        | [|InfoLevel == QueryInformationLevelCodes.SMB_INFO_QUERY_EA_SIZE|] SmbQueryInfoEaSize
        | [|InfoLevel == QueryInformationLevelCodes.SMB_INFO_QUERY_EAS_FROM_LIST|] SmbInfoQueryEasFromListInQuery
        | [|InfoLevel == QueryInformationLevelCodes.SMB_INFO_QUERY_ALL_EAS|] SmbInfoQueryAllEas
        | [|InfoLevel == QueryInformationLevelCodes.SMB_QUERY_FILE_BASIC_INFO|] SmbQueryFileBasicInfo
        | [|InfoLevel == QueryInformationLevelCodes.SMB_QUERY_FILE_STANDARD_INFO|] SmbQueryFileStandardInfo
        | [|InfoLevel == QueryInformationLevelCodes.SMB_QUERY_FILE_EA_INFO|] SmbQueryFileEAInfo
        | [|InfoLevel == QueryInformationLevelCodes.SMB_QUERY_FILE_NAME_INFO|] SmbQueryFileNameInfo
        | [|InfoLevel == QueryInformationLevelCodes.SMB_QUERY_FILE_ALL_INFO|] SmbQueryFileAllInfo
        | [|InfoLevel == QueryInformationLevelCodes.SMB_QUERY_FILE_ALT_NAME_INFO|] SmbQueryFileAltNameInfo
        | [|InfoLevel == QueryInformationLevelCodes.SMB_QUERY_FILE_STREAM_INFO|] SmbQueryFileStreamInfo
        | [|InfoLevel == QueryInformationLevelCodes.SMB_QUERY_FILE_COMPRESSION_INFO|] SmbQueryFileComressionInfo
        | [|InfoLevel == SmbInfoPassthrough + FileInformationClasses.FileDirectoryInformation|] FileDirectoryInformationList
        | [|InfoLevel == SmbInfoPassthrough + FileInformationClasses.FileFullDirectoryInformation|] FileFullDirectoryInformationList
        | [|InfoLevel == SmbInfoPassthrough + FileInformationClasses.FileBothDirectoryInformation|] FileBothDirectoryInformationList
        | [|InfoLevel == SmbInfoPassthrough + FileInformationClasses.FileBasicInformation|] FileBasicInformation
        | [|InfoLevel == SmbInfoPassthrough + FileInformationClasses.FileStandardInformation|] FileStandardInformation
        | [|InfoLevel == SmbInfoPassthrough + FileInformationClasses.FileInternalInformation|] FileInternalInformation
        | [|InfoLevel == SmbInfoPassthrough + FileInformationClasses.FileEaInformation|] FileEaInformation
        | [|InfoLevel == SmbInfoPassthrough + FileInformationClasses.FileAccessInformation|] FileAccessInformation
        | [|InfoLevel == SmbInfoPassthrough + FileInformationClasses.FileNameInformation|] FileNameInformation
        | [|InfoLevel == SmbInfoPassthrough + FileInformationClasses.FileRenameInformation|] FileRenameInformationForSMB
        | [|InfoLevel == SmbInfoPassthrough + FileInformationClasses.FileLinkInformation|] FileLinkInformationForSMB
        | [|InfoLevel == SmbInfoPassthrough + FileInformationClasses.FileNamesInformation|] FileNamesInformationList
        | [|InfoLevel == SmbInfoPassthrough + FileInformationClasses.FileDispositionInformation|] FileDispositionInformation
        | [|InfoLevel == SmbInfoPassthrough + FileInformationClasses.FilePositionInformation|] FilePositionInformation
        | [|InfoLevel == SmbInfoPassthrough + FileInformationClasses.FileFullEaInformation|] FileFullEaInformation
        | [|InfoLevel == SmbInfoPassthrough + FileInformationClasses.FileModeInformation|] FileModeInformation
        | [|InfoLevel == SmbInfoPassthrough + FileInformationClasses.FileAlignmentInformation|] FileAlignmentInformation
        | [|InfoLevel == SmbInfoPassthrough + FileInformationClasses.FileAllInformation|] FileAllInformation
        | [|InfoLevel == SmbInfoPassthrough + FileInformationClasses.FileAllocationInformation|] FileAllocationInformation
        | [|InfoLevel == SmbInfoPassthrough + FileInformationClasses.FileEndOfFileInformation|] FileEndOfFileInformation
        | [|InfoLevel == SmbInfoPassthrough + FileInformationClasses.FileAlternateNameInformation|] FileAlternateNameInformation
        | [|InfoLevel == SmbInfoPassthrough + FileInformationClasses.FileStreamInformation|] FileStreamInformationList
        | [|InfoLevel == SmbInfoPassthrough + FileInformationClasses.FilePipeInformation|] FilePipeInformation
        | [|InfoLevel == SmbInfoPassthrough + FileInformationClasses.FilePipeLocalInformation|] FilePipeLocalInformation
        | [|InfoLevel == SmbInfoPassthrough + FileInformationClasses.FilePipeRemoteInformation|] FilePipeRemoteInformation
        | [|InfoLevel == SmbInfoPassthrough + FileInformationClasses.FileMailslotQueryInformation|] FileMailslotQueryInformation
        | [|InfoLevel == SmbInfoPassthrough + FileInformationClasses.FileMailslotSetInformation|] FileMailslotSetInformation
        | [|InfoLevel == SmbInfoPassthrough + FileInformationClasses.FileCompressionInformation|] FileCompressionInformation
        | [|InfoLevel == SmbInfoPassthrough + FileInformationClasses.FileObjectIdInformation|] FileObjectIdInformationType2
        | [|InfoLevel == SmbInfoPassthrough + FileInformationClasses.FileQuotaInformation|] FileQuotaInformationList
        | [|InfoLevel == SmbInfoPassthrough + FileInformationClasses.FileReparsePointInformation|] FileReparsePointInformation
        | [|InfoLevel == SmbInfoPassthrough + FileInformationClasses.FileNetworkOpenInformation|] FileNetworkOpenInformation
        | [|InfoLevel == SmbInfoPassthrough + FileInformationClasses.FileAttributeTagInformation|] FileAttributeTagInformation
        | [|InfoLevel == SmbInfoPassthrough + FileInformationClasses.FileIdBothDirectoryInformation|] FileIdBothDirectoryInformationList
        | [|InfoLevel == SmbInfoPassthrough + FileInformationClasses.FileIdFullDirectoryInformation|] FileIdFullDirectoryInformationList
        | [|InfoLevel == SmbInfoPassthrough + FileInformationClasses.FileValidDataLengthInformation|] FileValidDataLengthInformation
        | [|InfoLevel == SmbInfoPassthrough + FileInformationClasses.FileShortNameInformation|] FileShortNameInformation
        | [|InfoLevel == SmbInfoPassthrough + FileInformationClasses.FileSfioReserveInformation|] FileSfioReserveInformation
        | [|InfoLevel == SmbInfoPassthrough + FileInformationClasses.FileHardLinkInformation|] FileHardLinkInformation
        | [|InfoLevel == SmbInfoPassthrough + FileInformationClasses.FileIdGlobalTxDirectoryInformation|] FileIdGlobalTxDirectoryInformationList
        | [|InfoLevel == SmbInfoPassthrough + FileInformationClasses.FileStandardLinkInformation|] FileStandardLinkInformation
        | Blob[Length as uint]) QueryInfoLevels;
}

// 2.2.8.3.1   SMB_INFO_STANDARD
type SmbQueryInfoStandard
{
    SmbDate CreationDate
        with Documentation{Description = "(2 bytes): This field contains the date when the file was created."};
    SmbTime CreationTime
        with Documentation{Description = "(2 bytes): This field contains the time when the file was created."};
    SmbDate LastAccessDate
        with Documentation{Description = "(2 bytes): This field contains the date when the file was last accessed."};
    SmbTime LastAccessTime
        with Documentation{Description = "(2 bytes): This field contains the time when the file was last accessed."};
    SmbDate LastWriteDate
        with Documentation{Description = "(2 bytes): This field contains the date when data was last written to the file."};
    SmbTime LastWriteTime
        with Documentation{Description = "(2 bytes): This field contains the time when data was last written to the file."};
    ULONG FileDataSize
        with Documentation{Description = "(4 bytes): This field contains the file size, in filesystem allocation units."};
    ULONG AllocationSize
        with Documentation{Description = "(4 bytes): This field contains the size of the filesystem allocation unit, in bytes."};
    SmbFileAttributes Attributes
        with Documentation{Description = "(2 bytes): This field contains the file attributes."};
} with Documentation{Description = "This information level structure is used in TRANS2_QUERY_PATH_INFORMATION and TRANS2_QUERY_FILE_INFORMATION responses to return the following information for all files that match the request\'s search criteria:"};

// 2.2.8.3.2   SMB_INFO_QUERY_EA_SIZE
type SmbQueryInfoEaSize
{
    SmbDate CreationDate
        with Documentation{Description = "(2 bytes): This field contains the date when the file was created."};
    SmbTime CreationTime
        with Documentation{Description = "(2 bytes): This field contains the time when the file was created."};
    SmbDate LastAccessDate
        with Documentation{Description = "(2 bytes): This field contains the date when the file was last accessed."};
    SmbTime LastAccessTime
        with Documentation{Description = "(2 bytes): This field contains the time when the file was last accessed."};
    SmbDate LastWriteDate
        with Documentation{Description = "(2 bytes): This field contains the date when data was last written to the file."};
    SmbTime LastWriteTime
        with Documentation{Description = "(2 bytes): This field contains the time when data was last written to the file."};
    ULONG FileDataSize
        with Documentation{Description = "(4 bytes): This field contains the file size, in filesystem allocation units."};
    ULONG AllocationSize
        with Documentation{Description = "(4 bytes): This field contains the size of the filesystem allocation unit, in bytes."};
    SmbFileAttributes Attributes
        with Documentation{Description = "(2 bytes): This field contains the file attributes."};
    ULONG EaSize
        with Documentation{Description = "(4 bytes): This field contains the size of the file's extended attribute (EA) information in bytes."};
}

// 2.2.8.3.3   SMB_INFO_QUERY_EAS_FROM_LIST
type SmbInfoQueryEasFromListInQuery
{
    SmbFeaList ExtendedAttributeList
        with Documentation{Description = "(variable): A list of extended attribute (EA) name/value pairs where the AttributeName field values match those that were provided in the request."};
} with Documentation{Description = "This information level structure is used in TRANS2_QUERY_PATH_INFORMATION and TRANS2_QUERY_FILE_INFORMATION responses to return a list of specificl extended attributes (EAs) on the file specified in the request. The requested EAs are provided in the Trans2_Data block of the request."};

// 2.2.8.3.4   SMB_INFO_QUERY_ALL_EAS
type SmbInfoQueryAllEas
{
    SmbFeaList ExtendedAttributeList
        with Documentation{Description = "(variable): A list of all of the extended attribute (EA) name/value pairs assigned to the file."};
} with Documentation{Description = "This information level structure is used in TRANS2_QUERY_PATH_INFORMATION and TRANS2_QUERY_FILE_INFORMATION responses to return a list of specific extended attributes (EAs) on the file specified in the request."};

// 2.2.8.3.6   SMB_QUERY_FILE_BASIC_INFO
type SmbQueryFileBasicInfo
{
    FILETIME CreationTime
        with Documentation{Description = "(8 bytes): This field contains the date and time when the file was created."};
    FILETIME LastAccessTime
        with Documentation{Description = "(8 bytes): This field contains the date and time when the file was last accessed."};
    FILETIME LastWriteTime
        with Documentation{Description = "(8 bytes): This field contains the date and time when data was last written to the file."};
    FILETIME LastChangeTime
        with Documentation{Description = "(8 bytes): This field contains the date and time when the file was last changed."};
    SmbExtFileAttr ExtFileAttributes
        with Documentation{Description = "(4 bytes): This field contains the extended file attributes of the file, encoded as an SMB_EXT_FILE_ATTR data type."};
    ULONG Reserved
        with Documentation{Description = "(4 bytes): MUST be set to zero when sent and MUST be ignored on receipt."};
} with Documentation{Description = "This information level structure is used in TRANS2_QUERY_PATH_INFORMATION and TRANS2_QUERY_FILE_INFORMATION responses to return the following information for the file specified in the request:windows_nt_server use the FileBasicInformation ([MS-FSCC] section ) information class to retrieve timestamp and extended file attribute information for a file."};

// 2.2.8.3.7   SMB_QUERY_FILE_STANDARD_INFO
type SmbQueryFileStandardInfo
{
    LARGE_INTEGER AllocationSize
        with Documentation{Description = "(8 bytes): This field contains the number of bytes that are allocated to the file."};
    LARGE_INTEGER EndOfFile
        with Documentation{Description = "(8 bytes): This field contains the offset, in bytes, from the start of the file to the first byte after the end of the file."};
    ULONG NumberOfLinks
        with Documentation{Description = "(4 bytes): This field contains the number of hard links to the file."};
    UCHAR DeletePending
        with Documentation{Description = "(1 byte): This field indicates whether there is a delete action pending for the file."};
    UCHAR Directory
        with Documentation{Description = "(1 byte): This field indicates whether the file is a directory."};
} with Documentation{Description = "This information level structure is used in TRANS2_QUERY_PATH_INFORMATION and TRANS2_QUERY_FILE_INFORMATION responses to return the following information for the file specified in the request.windows_nt servers use the FileStandardInformation ([MS-FSCC] section ) information class to retrieve the specified standard information for a file."};

// 2.2.8.3.8   SMB_QUERY_FILE_EA_INFO
type SmbQueryFileEAInfo
{
    ULONG EASize
        with Documentation{Description = "(4 bytes): This field MUST contain the length of a file\'s list of extended attributes in bytes."};
} with Documentation{Description = "This information level structure is used in TRANS2_QUERY_PATH_INFORMATION and TRANS2_QUERY_FILE_INFORMATION responses to return the size of a file\'s extended attributes (EAs) list for the file specified in the request.windows_nt_server use the FileEaInformation ([MS-FSCC] section ) information class to EA  size information for a file."};

// 2.2.8.3.9   SMB_QUERY_FILE_NAME_INFO
type SmbQueryFileNameInfo
{
    ULONG FileNameLength
        with Documentation{Description = "(4 bytes): This field MUST contain the length of the FileName field in bytes."};
    string FileName with BinaryEncoding{Length = (FileNameLength / 2)},
        Documentation{Description = "(variable): This field contains the name of the file."};
} with Documentation{Description = "This information level structure is used in TRANS2_QUERY_PATH_INFORMATION and TRANS2_QUERY_FILE_INFORMATION responses to return the Unicode-formatted long file name of the file specified in the request.windows_nt_server use the FileNameInformation ([MS-FSCC]  section ) information class to retrieve the long name for a file."};

// 2.2.8.3.10   SMB_QUERY_FILE_ALL_INFO
type SmbQueryFileAllInfo
{
    FILETIME CreationTime
        with Documentation{Description = "(8 bytes): This field contains the date and time when the file was created."};
    FILETIME LastAccessTime
        with Documentation{Description = "(8 bytes): This field contains the date and time when the file was last accessed."};
    FILETIME LastWriteTime
        with Documentation{Description = "(8 bytes): This field contains the date and time when data was last written to the file."};
    FILETIME LastChangeTime
        with Documentation{Description = "(8 bytes): This field contains the date and time when the file was last changed."};
    SmbExtFileAttr ExtFileAttributes
        with Documentation{Description = "(4 bytes): This field contains the extended file attributes of the file, encoded as an SMB_EXT_FILE_ATTR data type."};
    ULONG Reserved1
        with Documentation{Description = "(4 bytes): Reserved. This field SHOULD be set to 0x00000000 by the server and MUST be ignored by the client."};
    LARGE_INTEGER AllocationSize
        with Documentation{Description = "(8 bytes): This field contains the number of bytes that are allocated to the file."};
    LARGE_INTEGER EndOfFile
        with Documentation{Description = "(8 bytes): This field contains the offset, in bytes, from the start of the file to the first byte after the end of the file."};
    ULONG NumberOfLinks
        with Documentation{Description = "(4 bytes): This field contains the number of hard links to the file."};
    UCHAR DeletePending
        with Documentation{Description = "(1 byte): This field indicates whether there is a delete action pending for the file."};
    UCHAR Directory
        with Documentation{Description = "(1 byte): This field indicates whether the file is a directory."};
    USHORT Reserved2
        with Documentation{Description = "(2 bytes): Reserved. This field SHOULD be set to 0x0000 by the server and MUST be ignored by the client."};
    ULONG EaSize
        with Documentation{Description = "(4 bytes): This field MUST contain the length of a file\'s list of extended attributes in bytes."};
    ULONG FileNameLength
        with Documentation{Description = "(4 bytes): This field MUST contain the length, in bytes, of the FileName field."};
    string FileName with BinaryEncoding{TextEncoding = TextEncoding.UTF16, Length = (FileNameLength / 2)},
        Documentation{Description = "(variable): This field contains the name of the file."};
} with Documentation{Description = "This information level structure is used in TRANS2_QUERY_PATH_INFORMATION and TRANS2_QUERY_FILE_INFORMATION responses to return the SMB_QUERY_FILE_BASIC_INFO, SMB_FILE_QUERY_STANDARD_INFO, SMB_FILE_EA_INFO, and SMB_QUERY_FILE_NAME_INFO data as well as access flags, access mode, and alignment information in a single request for the file specified in the request."};

// 2.2.8.3.11   SMB_QUERY_FILE_ALT_NAME_INFO
type SmbQueryFileAltNameInfo
{
    ULONG FileNameLength
        with Documentation{Description = "(4 bytes): This field contains the length, in bytes, of the FileName field."};
    string FileName with BinaryEncoding{TextEncoding = TextEncoding.UTF16, Length = (FileNameLength / 2)},
        Documentation{Description = "(variable): This field contains the 8.3 name of the file in Unicode. The string is not null-terminated."};
} with Documentation{Description = "This information level structure is used in TRANS2_QUERY_PATH_INFORMATION and TRANS2_QUERY_FILE_INFORMATION responses to return the 8.3 format file name of the file in the request.windows_nt servers use the FileAlternateNameInformation ([MS-FSCC] section ) information class to retrieve the 8.3 format name for a file."};

// 2.2.8.3.12   SMB_QUERY_FILE_STREAM_INFO
type SmbQueryFileStreamInfo
{
    ULONG NextEntryOffset
        with Documentation{Description = "(4 bytes): A 32-bit unsigned integer that contains the byte offset from the beginning of this entry, at which the next FILE_ STREAM _INFORMATION entry is located, if multiple entries are present in a buffer. This member is 0x00000000 if no other entries follow this one. An implementation MUST use this value to determine the location of the next entry (if multiple entries are present in a buffer) and MUST NOT assume that the value of NextEntryOffset is the same as the size of the current entry."};
    ULONG StreamNameLength
        with Documentation{Description = "(4 bytes): A 32-bit unsigned integer that contains the length, in bytes, of the stream name string."};
    LARGE_INTEGER StreamSize
        with Documentation{Description = "(8 bytes): A 64-bit signed integer that contains the size, in bytes, of the stream. The value of this field MUST be greater than or equal to 0x0000000000000000."};
    LARGE_INTEGER StreamAllocationSize
        with Documentation{Description = "(8 bytes): A 64-bit signed integer that contains the file stream allocation size in bytes. Usually, this value is a multiple of the sector or cluster size of the underlying physical device. The value of this field MUST be greater than or equal to 0x0000000000000000."};
    string StreamName with BinaryEncoding{TextEncoding = TextEncoding.UTF16, Length = (StreamNameLength / 2)},
        Documentation{Description = "(variable): A sequence of Unicode characters containing the name of the stream using the form \":streamname:$DATA\", or \"::$DATA\" for the default stream. The :$DATA string that follows streamname is an internal data type tag that is unintentionally exposed. The leading \':\' and trailing \':$DATA\' characters are not part of the stream name and MUST be stripped from this field to derive the actual stream name. A resulting empty string for the stream name denotes the default stream. Because this field might not be null-terminated, it MUST be handled as a sequence of StreamNameLength bytes."};
    optional [|NextEntryOffset > 24 + StreamNameLength|] binary Padding with BinaryEncoding{Length = (NextEntryOffset - 24 - StreamNameLength)};
} with Documentation{Description = "This information level structure is used in TRANS2_QUERY_PATH_INFORMATION and TRANS2_QUERY_FILE_INFORMATION  responses to return the stream information for the file in the request.windows_nt_server use the FileStreamInformation ([MS-FSCC] section ) information class to retrieve the stream information for a file."};

// 2.2.8.3.13   SMB_QUERY_FILE_COMRESSION_INFO
type SmbQueryFileComressionInfo
{
    LARGE_INTEGER CompressedFileSize
        with Documentation{Description = "(8 bytes): A 64-bit signed integer that contains the size, in bytes, of the compressed file. This value MUST be greater than or equal to 0x0000000000000000."};
    USHORT CompressionFormat
        with Documentation{Description = "(2 bytes): A 16-bit unsigned integer that contains the compression format. The actual compression operation associated with each of these compression format values is implementation-dependent. An implementation can associate any local compression algorithm with the values described in the following table, because the compressed data does not travel across the wire in the context of this transaction. The following compression formats are valid only for NTFS."};
    UCHAR CompressionUnitShift
        with Documentation{Description = "(1 byte): An 8-bit unsigned integer that contains the compression unit shift that is the number of bits by which to left-shift a 1 bit to arrive at the compression unit size. The compression unit size is the number of bytes in a compression unit, that is, the number of bytes to be compressed. This value is implementation-defined."};
    UCHAR ChunkShift
        with Documentation{Description = "(1 byte): An 8-bit unsigned integer that contains the compression chunk size in bytes in log 2 format. The chunk size is the number of bytes that the operating system\'s implementation of the Lempel-Ziv compression algorithm tries to compress at one time. This value is implementation-defined."};
    UCHAR ClusterShift
        with Documentation{Description = "(1 byte): An 8-bit unsigned integer that specifies, in log 2 format, the amount of space that MUST be saved by compression to successfully compress a compression unit. If that amount of space is not saved by compression, the data in that compression unit MUST be stored uncompressed. Each successfully compressed compression unit MUST occupy at least one cluster that is less in bytes than an uncompressed compression unit. Therefore, the cluster shift is the number of bits by which to left shift a 1 bit to arrive at the size of a cluster. This value is implementation-defined."};
    binary Reserved with BinaryEncoding{Length = 3},
        Documentation{Description = "(3 bytes): A 24-bit reserved value. This field SHOULD be set to 0x000000 and MUST be ignored."};
} with Documentation{Description = "This information level structure is used in TRANS2_QUERY_PATH_INFORMATION and TRANS2_QUERY_FILE_INFORMATION responses to return the compression information for the file in the request.windows_nt_server use the FileCompressionInformation ([MS-FSCC] section ) information class to retrieve the compression information for a file."};

// 2.2.8.4   SET Information levels
type SmbSetInfoLevels[USHORT InfoLevel, USHORT Length]
{
    optional ([|InfoLevel == SetInformationLevelCodes.SMB_INFO_STANDARD|] SmbInfoStandardInSet
        | [|InfoLevel == SetInformationLevelCodes.SMB_INFO_SET_EAS|] SmbInfoSetEas
        | [|InfoLevel == SetInformationLevelCodes.SMB_SET_FILE_BASIC_INFO|] SmbSetFileBasicInfo
        | [|InfoLevel == SetInformationLevelCodes.SMB_SET_FILE_DISPOSITION_INFO|] SmbSetFileDispositionInfo
        | [|InfoLevel == SetInformationLevelCodes.SMB_SET_FILE_ALLOCATION_INFO|] SmbSetFileAllocationInfo
        | [|InfoLevel == SetInformationLevelCodes.SMB_SET_FILE_END_OF_FILE_INFO|] SmbSetFileEndOFFileInfo
        | [|InfoLevel == SmbInfoPassthrough + FileInformationClasses.FileDirectoryInformation|] FileDirectoryInformationList
        | [|InfoLevel == SmbInfoPassthrough + FileInformationClasses.FileFullDirectoryInformation|] FileFullDirectoryInformationList
        | [|InfoLevel == SmbInfoPassthrough + FileInformationClasses.FileBothDirectoryInformation|] FileBothDirectoryInformationList
        | [|InfoLevel == SmbInfoPassthrough + FileInformationClasses.FileBasicInformation|] FileBasicInformation
        | [|InfoLevel == SmbInfoPassthrough + FileInformationClasses.FileStandardInformation|] FileStandardInformation
        | [|InfoLevel == SmbInfoPassthrough + FileInformationClasses.FileInternalInformation|] FileInternalInformation
        | [|InfoLevel == SmbInfoPassthrough + FileInformationClasses.FileEaInformation|] FileEaInformation
        | [|InfoLevel == SmbInfoPassthrough + FileInformationClasses.FileAccessInformation|] FileAccessInformation
        | [|InfoLevel == SmbInfoPassthrough + FileInformationClasses.FileNameInformation|] FileNameInformation
        | [|InfoLevel == SmbInfoPassthrough + FileInformationClasses.FileRenameInformation|] FileRenameInformationForSMB
        | [|InfoLevel == SmbInfoPassthrough + FileInformationClasses.FileLinkInformation|] FileLinkInformationForSMB
        | [|InfoLevel == SmbInfoPassthrough + FileInformationClasses.FileNamesInformation|] FileNamesInformationList
        | [|InfoLevel == SmbInfoPassthrough + FileInformationClasses.FileDispositionInformation|] FileDispositionInformation
        | [|InfoLevel == SmbInfoPassthrough + FileInformationClasses.FilePositionInformation|] FilePositionInformation
        | [|InfoLevel == SmbInfoPassthrough + FileInformationClasses.FileFullEaInformation|] FileFullEaInformation
        | [|InfoLevel == SmbInfoPassthrough + FileInformationClasses.FileModeInformation|] FileModeInformation
        | [|InfoLevel == SmbInfoPassthrough + FileInformationClasses.FileAlignmentInformation|] FileAlignmentInformation
        | [|InfoLevel == SmbInfoPassthrough + FileInformationClasses.FileAllInformation|] FileAllInformation
        | [|InfoLevel == SmbInfoPassthrough + FileInformationClasses.FileAllocationInformation|] FileAllocationInformation
        | [|InfoLevel == SmbInfoPassthrough + FileInformationClasses.FileEndOfFileInformation|] FileEndOfFileInformation
        | [|InfoLevel == SmbInfoPassthrough + FileInformationClasses.FileAlternateNameInformation|] FileAlternateNameInformation
        | [|InfoLevel == SmbInfoPassthrough + FileInformationClasses.FileStreamInformation|] FileStreamInformationList
        | [|InfoLevel == SmbInfoPassthrough + FileInformationClasses.FilePipeInformation|] FilePipeInformation
        | [|InfoLevel == SmbInfoPassthrough + FileInformationClasses.FilePipeLocalInformation|] FilePipeLocalInformation
        | [|InfoLevel == SmbInfoPassthrough + FileInformationClasses.FilePipeRemoteInformation|] FilePipeRemoteInformation
        | [|InfoLevel == SmbInfoPassthrough + FileInformationClasses.FileMailslotQueryInformation|] FileMailslotQueryInformation
        | [|InfoLevel == SmbInfoPassthrough + FileInformationClasses.FileMailslotSetInformation|] FileMailslotSetInformation
        | [|InfoLevel == SmbInfoPassthrough + FileInformationClasses.FileCompressionInformation|] FileCompressionInformation
        | [|InfoLevel == SmbInfoPassthrough + FileInformationClasses.FileObjectIdInformation|] FileObjectIdInformationType2
        | [|InfoLevel == SmbInfoPassthrough + FileInformationClasses.FileQuotaInformation|] FileQuotaInformationList
        | [|InfoLevel == SmbInfoPassthrough + FileInformationClasses.FileReparsePointInformation|] FileReparsePointInformation
        | [|InfoLevel == SmbInfoPassthrough + FileInformationClasses.FileNetworkOpenInformation|] FileNetworkOpenInformation
        | [|InfoLevel == SmbInfoPassthrough + FileInformationClasses.FileAttributeTagInformation|] FileAttributeTagInformation
        | [|InfoLevel == SmbInfoPassthrough + FileInformationClasses.FileIdBothDirectoryInformation|] FileIdBothDirectoryInformationList
        | [|InfoLevel == SmbInfoPassthrough + FileInformationClasses.FileIdFullDirectoryInformation|] FileIdFullDirectoryInformationList
        | [|InfoLevel == SmbInfoPassthrough + FileInformationClasses.FileValidDataLengthInformation|] FileValidDataLengthInformation
        | [|InfoLevel == SmbInfoPassthrough + FileInformationClasses.FileShortNameInformation|] FileShortNameInformation
        | [|InfoLevel == SmbInfoPassthrough + FileInformationClasses.FileSfioReserveInformation|] FileSfioReserveInformation
        | [|InfoLevel == SmbInfoPassthrough + FileInformationClasses.FileHardLinkInformation|] FileHardLinkInformation
        | [|InfoLevel == SmbInfoPassthrough + FileInformationClasses.FileIdGlobalTxDirectoryInformation|] FileIdGlobalTxDirectoryInformationList
        | [|InfoLevel == SmbInfoPassthrough + FileInformationClasses.FileStandardLinkInformation|] FileStandardLinkInformation
        | Blob[Length as uint]) SetInfoLevels;
}

// 2.2.8.4.1   SMB_INFO_STANDARD
type SmbInfoStandardInSet
{
    SmbDate CreationDate
        with Documentation{Description = "(2 bytes): This field contains the date when the file was created."};
    SmbTime CreationTime
        with Documentation{Description = "(2 bytes): This field contains the time when the file was created."};
    SmbDate LastAccessDate
        with Documentation{Description = "(2 bytes): This field contains the date when the file was last accessed."};
    SmbTime LastAccessTime
        with Documentation{Description = "(2 bytes): This field contains the time when the file was last accessed."};
    SmbDate LastWriteDate
        with Documentation{Description = "(2 bytes): This field contains the date when data was last written to the file."};
    SmbTime LastWriteTime
        with Documentation{Description = "(2 bytes): This field contains the time when data was last written to the file."};
    binary Reserved with BinaryEncoding{Length = 10},
        Documentation{Description = "(10 bytes): MUST be set to zero when sent and MUST be ignored on receipt."};
} with Documentation{Description = "This information level structure is used in TRANS2_SET_PATH_INFORMATION and TRANS2_SET_FILE_INFORMATION requests to set timestamp information for the file specified in the request"};

// 2.2.8.4.2   SMB_INFO_SET_EAS
type SmbInfoSetEas
{
    SmbFeaList ExtendedAttributeList
        with Documentation{Description = "(variable): A list of EA name/value pairs."};
} with Documentation{Description = "This information level structure is used in TRANS2_SET_PATH_INFORMATION and TRANS2_SET_FILE_INFORMATION requests to set specific extended attribute (EA) information for the file specified in the request."};

// 2.2.8.4.3   SMB_SET_FILE_BASIC_INFO
type SmbSetFileBasicInfo
{
    FILETIME CreationTime
        with Documentation{Description = "(8 bytes): A 64-bit unsigned integer that contains the time when the file was created. A valid time for this field is an integer greater than 0x0000000000000000. When setting file attributes, a value of 0x0000000000000000 indicates to the server that it MUST NOT change this attribute. When setting file attributes, a value of -1 (0xFFFFFFFFFFFFFFFF) indicates to the server that it MUST NOT change this attribute for all subsequent operations on the same file handle. This field MUST NOT be set to a value less than -1 (0xFFFFFFFFFFFFFFFF)."};
    FILETIME LastAccessTime
        with Documentation{Description = "(8 bytes): A 64-bit unsigned integer that contains the last time that the file was accessed, in the format of a FILETIME structure. A valid time for this field is an integer greater than 0x0000000000000000. When setting file attributes, a value of 0x0000000000000000 indicates to the server that it MUST NOT change this attribute. When setting file attributes, a value of -1 (0xFFFFFFFFFFFFFFFF) indicates to the server that it MUST NOT change this attribute for all subsequent operations on the same file handle. This field MUST NOT be set to a value less than -1 (0xFFFFFFFFFFFFFFFF)."};
    FILETIME LastWriteTime
        with Documentation{Description = "(8 bytes): A 64-bit unsigned integer that contains the last time that information was written to the file, in the format of a FILETIME structure. A valid time for this field is an integer greater than 0x0000000000000000. When setting file attributes, a value of 0x0000000000000000 indicates to the server that it MUST NOT change this attribute. When setting file attributes, a value of -1 (0xFFFFFFFFFFFFFFFF) indicates to the server that it MUST NOT change this attribute for all subsequent operations on the same file handle. This field MUST NOT be set to a value less than -1 (0xFFFFFFFFFFFFFFFF)."};
    FILETIME ChangeTime
        with Documentation{Description = "(8 bytes): A 64-bit unsigned integer that contains the last time that the file was changed, in the format of a FILETIME structure. A valid time for this field is an integer greater than 0x0000000000000000. When setting file attributes, a value of 0x0000000000000000 indicates to the server that it MUST NOT change this attribute. When setting file attributes, a value of -1 (0xFFFFFFFFFFFFFFFF) indicates to the server that it MUST NOT change this attribute for all subsequent operations on the same file handle. This field MUST NOT be set to a value less than -1 (0xFFFFFFFFFFFFFFFF)."};
    SmbExtFileAttr ExtFileAttributes
        with Documentation{Description = "(4 bytes): This field contains the extended file attributes of the file, encoded as an SMB_EXT_FILE_ATTR data type (section )."};
    ULONG Reserved
        with Documentation{Description = "(4 bytes): A 32-bit reserved field that can be set to any value and MUST be ignored."};
} with Documentation{Description = "This information level structure is used in TRANS2_SET_FILE_INFORMATION requests to set the following information for the file specified in the request.windows_nt servers use the FileBasicInformation ([MS-FSCC] section ) information class to set timestamp and extended file attribute information for a file."};

// 2.2.8.4.4   SMB_SET_FILE_DISPOSITION_INFO
type SmbSetFileDispositionInfo
{
    UCHAR DeletePending
        with Documentation{Description = "(1 byte): An 8-bit field that is set to 0x01 to indicate that a file SHOULD be deleted when it is closed; otherwise, to 0x00."};
} with Documentation{Description = "This information level structure is used in TRANS2_SET_FILE_INFORMATION requests to mark or unmark the file specified in the request for deletion.windows_nt servers use the FileDispositionInformation ([MS-FSCC] section ) information class to mark or unmark a file for deletion.)"};

// 2.2.8.4.5   SMB_SET_FILE_ALLOCATION_INFO
type SmbSetFileAllocationInfo
{
    LARGE_INTEGER AllocationSize
        with Documentation{Description = "(8 bytes): A 64-bit signed integer containing the file allocation size, in bytes. Usually, this value is a multiple of the sector or cluster size of the underlying physical device. This value MUST be greater than or equal to 0x0000000000000000. All unused allocation (beyond EOF) is freed."};
} with Documentation{Description = "This information level structure is used in TRANS2_SET_FILE_INFORMATION requests to set allocation size information for the file specified in the request.windows_nt servers use the FileAllocationInformation ([MS-FSCC] section ) information class to set allocation size information for a file."};

// 2.2.8.4.6   SMB_SET_FILE_END_OF_FILE_INFO
type SmbSetFileEndOFFileInfo
{
    LARGE_INTEGER EndOfFile
        with Documentation{Description = "(8 bytes): A 64-bit signed integer that contains the absolute new end-of-file position as a byte offset from the start of the file. EndOfFile specifies the offset from the beginning of the file to the byte following the last byte in the file. It is the offset from the beginning of the file at which new bytes appended to the file are to be written. The value of this field MUST be greater than or equal to 0x0000000000000000."};
} with Documentation{Description = "This information level structure is used in TRANS2_SET_FILE_INFORMATION requests to set end-of-file information for the file specified in the request.windows_nt servers use the FileEndOfFileInformation ([MS-FSCC] section ) information class to set end-of-file information for a file."};

pattern SmbCommand = enum byte
{
    SMB_COM_CREATE_DIRECTORY       = 0x00,
    SMB_COM_DELETE_DIRECTORY       = 0x01,
    SMB_COM_OPEN                   = 0x02,
    SMB_COM_CREATE                 = 0x03,
    SMB_COM_CLOSE                  = 0x04,
    SMB_COM_FLUSH                  = 0x05,
    SMB_COM_DELETE                 = 0x06,
    SMB_COM_RENAME                 = 0x07,
    SMB_COM_QUERY_INFORMATION      = 0x08,
    SMB_COM_SET_INFORMATION        = 0x09,
    SMB_COM_READ                   = 0x0A,
    SMB_COM_WRITE                  = 0x0B,
    SMB_COM_LOCK_BYTE_RANGE        = 0x0C,
    SMB_COM_UNLOCK_BYTE_RANGE      = 0x0D,
    SMB_COM_CREATE_TEMPORARY       = 0x0E,
    SMB_COM_CREATE_NEW             = 0x0F,
    SMB_COM_CHECK_DIRECTORY        = 0x10,
    SMB_COM_PROCESS_EXIT           = 0x11,
    SMB_COM_SEEK                   = 0x12,
    SMB_COM_LOCK_AND_READ          = 0x13,
    SMB_COM_WRITE_AND_UNLOCK       = 0x14,
    SMB_COM_READ_RAW               = 0x1A,
    SMB_COM_READ_MPX               = 0x1B,
    SMB_COM_READ_MPX_SECONDARY     = 0x1C,
    SMB_COM_WRITE_RAW              = 0x1D,
    SMB_COM_WRITE_MPX              = 0x1E,
    SMB_COM_WRITE_MPX_SECONDARY    = 0x1F, // Obsolated
    SMB_COM_WRITE_COMPLETE         = 0x20, // Obsolated
    SMB_COM_QUERY_SERVER           = 0x21, // Obsolated
    SMB_COM_SET_INFORMATION2       = 0x22,
    SMB_COM_QUERY_INFORMATION2     = 0x23,
    SMB_COM_LOCKING_ANDX           = 0x24,
    SMB_COM_TRANSACTION            = 0x25,
    SMB_COM_TRANSACTION_SECONDARY  = 0x26,
    SMB_COM_IOCTL                  = 0x27,
    SMB_COM_IOCTL_SECONDARY        = 0x28, // Obsolated
    SMB_COM_COPY                   = 0x29, // Obsolated
    SMB_COM_MOVE                   = 0x2A, // Obsolated
    SMB_COM_ECHO                   = 0x2B,
    SMB_COM_WRITE_AND_CLOSE        = 0x2C,
    SMB_COM_OPEN_ANDX              = 0x2D,
    SMB_COM_READ_ANDX              = 0x2E,
    SMB_COM_WRITE_ANDX             = 0x2F,
    SMB_COM_NEW_FILE_SIZE          = 0x30, // Obsolated
    SMB_COM_CLOSE_AND_TREE_DISC    = 0x31, // Obsolated
    SMB_COM_TRANSACTION2           = 0x32,
    SMB_COM_TRANSACTION2_SECONDARY = 0x33,
    SMB_COM_FIND_CLOSE2            = 0x34,
    SMB_COM_FIND_NOTIFY_CLOSE      = 0x35, // Obsolated
    SMB_COM_TREE_CONNECT           = 0x70,
    SMB_COM_TREE_DISCONNECT        = 0x71,
    SMB_COM_NEGOTIATE              = 0x72,
    SMB_COM_SESSION_SETUP_ANDX     = 0x73,
    SMB_COM_LOGOFF_ANDX            = 0x74,
    SMB_COM_TREE_CONNECT_ANDX      = 0x75,
    SMB_COM_SECURITY_PACKAGE_ANDX  = 0x7E, // Obsolated
    SMB_COM_QUERY_INFORMATION_DISK = 0x80,
    SMB_COM_SEARCH                 = 0x81,
    SMB_COM_FIND                   = 0x82,
    SMB_COM_FIND_UNIQUE            = 0x83,
    SMB_COM_FIND_CLOSE             = 0x84,
    SMB_COM_NT_TRANSACT            = 0xA0,
    SMB_COM_NT_TRANSACT_SECONDARY  = 0xA1,
    SMB_COM_NT_CREATE_ANDX         = 0xA2,
    SMB_COM_NT_CANCEL              = 0xA4,
    SMB_COM_NT_RENAME              = 0xA5,
    SMB_COM_OPEN_PRINT_FILE        = 0xC0,
    SMB_COM_WRITE_PRINT_FILE       = 0xC1,
    SMB_COM_CLOSE_PRINT_FILE       = 0xC2,
    SMB_COM_GET_PRINT_QUEUE        = 0xC3, // Obsolated
    SMB_COM_READ_BULK              = 0xD8, // Obsolated
    SMB_COM_WRITE_BULK             = 0xD9, // Obsolated
    SMB_COM_WRITE_BULK_DATA        = 0xDA, // Obsolated
    SMB_COM_INVALID                = 0xFE, // Obsolated
    SMB_COM_NO_ANDX                = 0xFF, // Obsolated
    ...
};

const map<byte, string> SmbCommandNameMap = 
{
    0x00 -> "ComCreateDirectory",
    0x01 -> "ComDeleteDirectory",
    0x02 -> "ComOpen",
    0x03 -> "ComCreate",
    0x04 -> "ComClose",
    0x05 -> "ComFlush",
    0x06 -> "ComDelete",
    0x07 -> "ComRename",
    0x08 -> "ComQueryInformation",
    0x09 -> "ComSetInformation",
    0x0A -> "ComRead",
    0x0B -> "ComWrite",
    0x0C -> "ComLockByteRange",
    0x0D -> "ComUnlockByteRange",
    0x0E -> "ComCreateTemporary",
    0x0F -> "ComCreateNew",
    0x10 -> "ComCheckDirectory",
    0x11 -> "ComProcessExit",
    0x12 -> "ComSeek",
    0x13 -> "ComLockAndRead",
    0x14 -> "ComWriteAndUnlock",
    0x1A -> "ComReadRaw",
    0x1B -> "ComReadMpx",
    0x1C -> "ComReadMpxSecondary",
    0x1D -> "ComWriteRaw",
    0x1E -> "ComWriteMpx",
    0x1F -> "ComWrtieMpxSecondary",
    0x20 -> "ComWriteComplete",
    0x21 -> "ComQueryServer",
    0x22 -> "ComSetInformation2",
    0x23 -> "ComQueryInformation2",
    0x24 -> "ComLockingAndx",
    0x25 -> "ComTransaction",
    0x26 -> "ComTransactionSecondary",
    0x27 -> "ComIoctl",
    0x28 -> "ComIoctlSecondary",
    0x29 -> "ComCopy",
    0x2A -> "ComMove",
    0x2B -> "ComEcho",
    0x2C -> "ComWriteAndClose",
    0x2D -> "ComOpenAndx",
    0x2E -> "ComReadAndx",
    0x2F -> "ComWriteAdnx",
    0x30 -> "ComNewFileSize",
    0x31 -> "ComCloseAndTreeDisc",
    0x32 -> "ComTransaction2",
    0x33 -> "ComTransaction2Secondary",
    0x34 -> "ComFindClose2",
    0x35 -> "ComFindNotifyClose",
    0x70 -> "ComTreeConnect",
    0x71 -> "ComTreeDisconnect",
    0x72 -> "ComNegotiate",
    0x73 -> "ComSessionSetupAndx",
    0x74 -> "ComLogoffAndx",
    0x75 -> "ComTreeConnectAndx",
    0x7E -> "ComSecurityPackageAndx",
    0x80 -> "ComQueryInformationDisk",
    0x81 -> "ComSearch",
    0x82 -> "ComFind",
    0x83 -> "ComFindUnique",
    0x84 -> "ComFindClose",
    0xA0 -> "ComNTTransact",
    0xA1 -> "ComNTTransactSecondary",
    0xA2 -> "ComNTCreateAndx",
    0xA4 -> "ComNTCancel",
    0xA5 -> "ComNTRename",
    0xC0 -> "ComOpenPrintFile",
    0xC1 -> "ComWritePrintFile",
    0xC2 -> "ComClosePrintFile",
    0xC3 -> "ComGetPrintQueue",
    0xD8 -> "ComReadBulk",
    0xD9 -> "ComWriteBulk",
    0xDA -> "ComWriteBulkData",
    0xFE -> "ComInvalid",
    0xFF -> "ComNoAndx",
};

pattern FileSmbCommand = enum byte // used for LowestServer endpoint, commands related with FID
{
    SMB_COM_OPEN                   = 0x02,
    SMB_COM_CREATE                 = 0x03,
    SMB_COM_CLOSE                  = 0x04,
    SMB_COM_FLUSH                  = 0x05,
    SMB_COM_READ                   = 0x0A,
    SMB_COM_WRITE                  = 0x0B,
    SMB_COM_LOCK_BYTE_RANGE        = 0x0C,
    SMB_COM_UNLOCK_BYTE_RANGE      = 0x0D,
    SMB_COM_CREATE_TEMPORARY       = 0x0E,
    SMB_COM_CREATE_NEW             = 0x0F,
    SMB_COM_SEEK                   = 0x12,
    SMB_COM_LOCK_AND_READ          = 0x13,
    SMB_COM_WRITE_AND_UNLOCK       = 0x14,
    SMB_COM_READ_RAW               = 0x1A,
    SMB_COM_READ_MPX               = 0x1B,
    SMB_COM_WRITE_RAW              = 0x1D,
    SMB_COM_WRITE_MPX              = 0x1E,
    SMB_COM_SET_INFORMATION2       = 0x22,
    SMB_COM_QUERY_INFORMATION2     = 0x23,
    SMB_COM_LOCKING_ANDX           = 0x24,
    SMB_COM_TRANSACTION            = 0x25,
    SMB_COM_IOCTL                  = 0x27,
    SMB_COM_WRITE_AND_CLOSE        = 0x2C,
    SMB_COM_OPEN_ANDX              = 0x2D,
    SMB_COM_READ_ANDX              = 0x2E,
    SMB_COM_WRITE_ANDX             = 0x2F,
    SMB_COM_NT_CREATE_ANDX         = 0xA2,
    SMB_COM_OPEN_PRINT_FILE        = 0xC0,
    SMB_COM_WRITE_PRINT_FILE       = 0xC1,
    SMB_COM_CLOSE_PRINT_FILE       = 0xC2
};

string GetTransactionSubcommandName(UCHAR setupCount, USHORT subcommand)
{
    if (setupCount <= 2)
    {
        switch (subcommand)
        {
            case 0x01 => return "Named Pipe, Set named pipe state";
            case 0x11 => return "Named Pipe, Raw read named pipe";
            case 0x21 => return "Named Pipe, Query named pipe state";
            case 0x22 => return "Named Pipe, Query named pipe info";
            case 0x23 => return "Named Pipe, peek named pipe";
            case 0x26 => return "Named Pipe, Transact named pipe";
            case 0x31 => return "Named Pipe, Raw write named pipe";
            case 0x36 => return "Named Pipe, Read named pipe";
            case 0x37 => return "Named Pipe, Write named pipe";
            case 0x53 => return "Named Pipe, Wait named pipe";
            case 0x54 => return "Named Pipe, Call named pipe";
            default   => return "Named Pipe, Unknown(" + DecToHexFormat(subcommand) + ")";
        }
    }
    else if (setupCount > 2)
    {
        switch (subcommand)
        {
            case 0x01 => return "Mail slot, Mail slot write";
            default   => return "Mail slot, Unknown(" + DecToHexFormat(subcommand) + ")";
        }
    }
    else
    {
        return "Unknown(" + DecToHexFormat(setupCount) + ")";
    }
}

string GetTransaction2SubcommandName(USHORT subcommand)
{
    switch (subcommand)
    {
        case 0x00 => return "Open2";
        case 0x01 => return "Find First2";
        case 0x02 => return "Find Next2";
        case 0x03 => return "Query FS Infomation";
        case 0x04 => return "Set FS Infomation";
        case 0x05 => return "Query Path Infomation";
        case 0x06 => return "Set Path Infomation";
        case 0x07 => return "Query File Infomation";
        case 0x08 => return "Set File Infomation";
        case 0x09 => return "Fsctl";
        case 0x0A => return "Ioctl2";
        case 0x0B => return "Find Notify First";
        case 0x0C => return "Find Notify Next";
        case 0x0D => return "Create Directory";
        case 0x0E => return "Session Setup";
        case 0x10 => return "Get DFS Referral";
        case 0x11 => return "Report DFS Inconsistency";
        default   => return "Unknown(" + DecToHexFormat(subcommand) + ")";
    }
}

string GetNTTransactionSubcommandName(USHORT subcommand)
{
    switch (subcommand)
    {
        case 0x01 => return "Create";
        case 0x02 => return "Ioctl";
        case 0x03 => return "Set Security Desc";
        case 0x04 => return "Notify Change";
        case 0x05 => return "Rename";
        case 0x06 => return "Query Security Desc";
        case 0x07 => return "Query Quota";
        case 0x08 => return "Set Quota";
        default   => return "Unknown(" + DecToHexFormat(subcommand) + ")";
    }
}

pattern Utime = uint with DisplayInfo{ToText = UtimeToText};

string TypeOfLockToString(any input)
{
    if(!(input is byte))
    {
        return "";
    }
    byte b = input as byte;
    
    string summary = "";
    if((b & 0x01) == 0)
    {
        summary += "ReadWriteLock";
        if(b == 0)
        {
            return summary;
        }
        return summary + "|" + EnumToString(b, "SMB.SmbComLockingAndxRequestParametersWordsTypeOfLock");
    }
    
    return EnumToString(b, "SMB.SmbComLockingAndxRequestParametersWordsTypeOfLock");
}

string UtimeToText(any input)
{
    if(!(input is uint))
    {
        return "";
    }
    uint data = input as uint;
    
    return CreateDateTime(1970, 1, 1).AddSeconds(data as double).ToLocalTime().ToString();
}

// List of ignored error code for ErrorCodeIf check
array<uint> IgnoredErrorCode = [0xC0000016, // STATUS_MORE_PROCESSING_REQUIRED
                                0xC000019C];  // STATUS_FS_DRIVER_REQUIRED

// 2.2.2.3.5   Pass-through Information Level Codes
const ushort SmbInfoPassthrough = 0x03E8;

// This method is used to report more detailed diagnostic message when dispatching header only message.
void ReportDiagnosticMessageForHeaderOnly(bool isGreater, byte wordCount, stream s, string messageName, any message m)
{
    if (wordCount == 0xFF) // Some messages (eg. Messages.ComTransactionSecondaryResponse) do not have message body, use 0xFF to mark them.
    {
        return;
    }
    if (s.ByteLength > 32)  // 32 is value of the length of header.
    { 
        byte wordCountValue = s.PeekByte(32 * 8);
        // wordCount in some messages (eg. Messages.ComReadRawRequest) has multiple valid values (eg. 0x08 or 0x0A),
        // use isGreater to mark them must not be less than the smallest one.
        if ((!isGreater && wordCountValue != wordCount) || (isGreater && wordCountValue < wordCount))
        {
            ValidationCheck(false, m, DiagnosisLevel.Error, "SMB: " + messageName + " cannot be decoded successfully due to wrong WordCount value: " + (wordCountValue as string) + ". WordCount must be " + (wordCount as string) +".");
            return;
        }
    }
    if (s.ByteLength < (33 + (wordCount * 2)))
    {
        ReportInsufficientData(m, DiagnosisLevel.Error, "SMB: " + messageName + " cannot be decoded successfully due to insufficient data.");
    }
}

string get FileName(this FileRequest msg)
{
    if (msg#SMBFileName is nothing)
    {
        return "";
    }
    return msg#SMBFileName as string;
}

string get FileName(this FileResponse msg)
{
    if (msg#SMBFileName is nothing)
    {
        return "";
    }
    return msg#SMBFileName as string;
}

string get FileNameReference(this FileRequest msg)
{
    string fileName = msg.FileName;
    int index = fileName.LastIndexOf("@");
    if (index < 0)
    {
        return fileName;
    }
    else
    {
        return fileName.Segment(0, index);
    }
}

string get FileNameReference(this FileResponse msg)
{
    string fileName = msg.FileName;
    int index = fileName.LastIndexOf("@");
    if (index < 0)
    {
        return fileName;
    }
    else
    {
        return fileName.Segment(0, index);
    }
}

bool SmbStatusErrorCodeIf(SmbHeader msg, DiagnosisLevel level)
{
    if (msg.Status is s:ERREF.NTSTATUS && s.Value is val:uint && val != 0 && ((val in SmbNtStatusMap) || (val in NtStatusMap)) && !(val in IgnoredErrorCode))
    {
        return ErrorCodeIf(true, msg, level,  "SMB: The Status of the message is " + SmbStatusValuesToText(msg.Status) + "(" + DecToHexFormat(val) + "). Please refer to " + SmbStatusValuesToText(msg.Status) + " in Technical Document MS-SMB.");
    }
    return true;
}

string SmbErrorToText(SMBSTATUS status)
{
    switch (status.ErrorClass)
    { 
        case SmbErrorClass.SUCCESS =>
            return "Success";
        case SmbErrorClass.ERRDOS =>
            return EnumToStringInSummary<ErrdosClassErrorCode>(status.ErrorCode);
        case SmbErrorClass.ERRSRV =>
            return EnumToStringInSummary<ErrsrvClassErrorCode>(status.ErrorCode);
        case SmbErrorClass.ERRHRD =>
            return EnumToStringInSummary<ErrhrdClassErrorCode>(status.ErrorCode);
        default =>
            return "Unknown(Class: " + DecToHexFormat(status.ErrorClass) + ", ErrorCode: " + DecToHexFormat(status.ErrorCode) + ")";
    }
}

// [MS-CIFS] 2.2.2.4   SMB Error Classes and Codes
pattern SmbErrorClass = enum UCHAR
{
    SUCCESS = 0x00,
    ERRDOS = 0x01,
    ERRSRV = 0x02,
    ERRHRD = 0x03,
    ...
};

pattern SuccessClassErrorCode = enum USHORT 
{
    SUCCESS = 0x0000
};
 
pattern ErrdosClassErrorCode = enum USHORT
{
    ERRbadfunc = 0x0001,
    ERRbadfile = 0x0002,
    ERRbadpath = 0x0003,
    ERRnofids = 0x0004,
    ERRnoaccess = 0x0005,
    ERRbadfid = 0x0006,
    ERRbadmcb = 0x0007,
    ERRnomem = 0x0008,
    ERRbadmem = 0x0009,
    ERRbadenv = 0x000A,
    ERRbadformat = 0x000B,
    ERRbadaccess = 0x000C,
    ERRbaddata = 0x000D,
    ERRbaddrive = 0x000F,
    ERRremcd = 0x0010,
    ERRdiffdevice = 0x0011,
    ERRnofiles = 0x0012,
    ERRgeneral = 0x001F,
    ERRbadshare = 0x0020,
    ERRlock = 0x0021,
    ERReof = 0x0026,
    ERRunsup = 0x0032,
    ERRfilexists = 0x0050,
    ERRinvalidparam = 0x0057,
    ERRunknownlevel = 0x007C,
    ERRinvalidseek = 0x0083,
    ERROR_NOT_LOCKED = 0x009E,
    ERROR_NO_MORE_SEARCH_HANDLES = 0x0071,
    ERROR_CANCEL_VIOLATION = 0x00AD,
    ERROR_ATOMIC_LOCKS_NOT_SUPPORTED = 0x00AE,
    ERRbadpipe = 0x00E6,
    ERROR_CANNOT_COPY = 0x010A,
    ERRpipebusy = 0x00E7,
    ERRpipeclosing = 0x00E8,
    ERRnotconnected = 0x00E9,
    ERRmoredata = 0x00EA,
    ERRbadealist = 0x00FF,
    ERROR_EAS_DIDNT_FIT = 0x0113,
    ERROR_EAS_NOT_SUPPORTED = 0x011A,
    ERROR_EA_ACCESS_DENIED = 0x03E2,
    ERR_NOTIFY_ENUM_DIR = 0x03FE,
    ...
};

pattern ErrsrvClassErrorCode = enum USHORT
{
    ERRerror = 0x0001,
    ERRbadpw = 0x0002,
    ERRbadpath = 0x0003,
    ERRaccess = 0x0004,
    ERRinvtid = 0x0005,
    ERRinvnetname = 0x0006,
    ERRinvdevice = 0x0007,
    ERRinvsess = 0x0010,
    ERRworking = 0x0011,
    ERRnotme = 0x0012,
    ERRbadcmd = 0x0016,
    ERRqfull = 0x0031,
    ERRqtoobig = 0x0032,
    ERRqeof = 0x0033,
    ERRinvpfid = 0x0034,
    ERRsmbcmd = 0x0040,
    ERRsrverror = 0x0041,
    ERRfilespecs = 0x0043,
    ERRbadpermits = 0x0045,
    ERRsetattrmode = 0x0047,
    ERRtimeout = 0x0058,
    ERRnoresource = 0x0059,
    ERRtoomanyuids = 0x005A,
    ERRbaduid = 0x005B,
    ERRnotconnected = 0x00E9,
    ERRusempx = 0x00FA,
    ERRusestd = 0x00FB,
    ERRcontmpx = 0x00FC,
    ERRaccountExpired = 0x08BF,
    ERRbadClient = 0x08C0,
    ERRbadLogonTime = 0x08C1,
    ERRpasswordExpired = 0x08C2,
    ERRnosupport = 0xFFFF,
    ...
};

pattern ErrhrdClassErrorCode = enum USHORT
{
    ERRnowrite = 0x0013,
    ERRbadunit = 0x0014,
    ERRnotready = 0x0015,
    ERRbadcmd = 0x0016,
    ERRdata = 0x0017,
    ERRbadreq = 0x0018,
    ERRseek = 0x0019,
    ERRbadmedia = 0x001A,
    ERRbadsector = 0x001B,
    ERRnopaper = 0x001C,
    ERRwrite = 0x001D,
    ERRread = 0x001E,
    ERRgeneral = 0x001F,
    ERRbadshare = 0x0020,
    ERRlock = 0x0021,
    ERRwrongdisk = 0x0022,
    ERRFCBUnavail = 0x0023,
    ERRsharebufexc = 0x0024,
    ERRdiskfull = 0x0027,
    ...
};

uint GetStatusCode(SmbStatusOrNtstatus status)
{
    if (status is nts:ERREF.NTSTATUS)
    {
        return nts.Value;
    }
    else
    {
        return (status as SMBSTATUS).Value;
    }
}
