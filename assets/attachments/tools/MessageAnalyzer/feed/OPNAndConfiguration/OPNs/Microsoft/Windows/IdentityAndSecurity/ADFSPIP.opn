protocol ADFSPIP with 
Documentation
{
    ProtocolName = "Active Directory Federation Services and Proxy Integration Protocol",
    ShortName = "ADFSPIP",
    Description = ""
},
OPNAuthoring
{
    Copyright = "(c) Microsoft Corporation",
    References = 
        [
            new Reference{Name = "MS-ADFSPIP", Version = "7.0", Date = "09/12/2018", ProgramName = ProgramName.MCPP},
        ],
    RevisionSummary = 
        [
            new Revision{Class = RevisionClass.Major, Version = "381522", Date = "09/22/2017"}
        ]
};

using Standard;
using HTTP;
using Utility;
using X509;

// --------------------- endpoint and actor ------------------------ 
endpoint Server
    over HTTP.Server
    provides Contract;

client endpoint Client connected to Server;

autostart actor ADFSPIPOverHTTP(HTTP.Server http)
{
    process http accepts httpReq:HttpContract.Request where IsADFSPIP(httpReq.Uri)
    {
        string absPath = httpReq.Uri.AbsPath as string;
        // Store field value(if current message defines) in Uri
        string filedValueInUri;
        
        if (IsAdfspipMessageByUri(absPath, ProxyEstablishTrust, out filedValueInUri))
        {
            switch (httpReq.Payload)
            {
                case req:Contract.EstablishTrustRequest from JsonDecoder<Contract.EstablishTrustRequest> =>
                    dispatch endpoint Server over http accepts req;
                default =>
                    ThrowDecodingException("ADFSPIP", "EstablishTrustRequest");
            }
        }
        else if (IsAdfspipMessageByUri(absPath, ProxyRenewTrust, out filedValueInUri))
        {
            switch (httpReq.Payload)
            {
                case req:Contract.RenewTrustRequest from JsonDecoder<Contract.RenewTrustRequest> =>
                    dispatch endpoint Server over http accepts req;
                default =>
                    ThrowDecodingException("ADFSPIP", "RenewTrustRequest");
            }
        }
        else if (IsAdfspipMessageByUri(absPath, ProxyWebApplicationProxyTrust, out filedValueInUri))
        {
            if (httpReq.Method == "GET")
            {
                var req = new Contract.GetProxyRelyingPartTrustRequest{Key = filedValueInUri};
                dispatch endpoint Server over http accepts req;
            }
            else if (httpReq.Method == "POST")
            {
                switch (httpReq.Payload)
                {
                    case req:Contract.CreateProxyRelyingPartTrustRequest from JsonDecoder<Contract.CreateProxyRelyingPartTrustRequest> =>
                        dispatch endpoint Server over http accepts req;
                    default =>
                        ThrowDecodingException("ADFSPIP", "CreateProxyRelyingPartTrustRequest");
                }
            }
            else if (httpReq.Method == "DELETE")
            {
                var req = new Contract.RemoveProxyRelyingPartTrustRequest{};
                dispatch endpoint Server over http accepts req;
            }
            else
            {
                reject;
            }
        }
        else if (IsAdfspipMessageByUri(absPath, ProxyGetConfiguration, out filedValueInUri))
        {
            var req = new Contract.GetConfigurationRequest{};
            dispatch endpoint Server over http accepts req;
        }
        else if (IsAdfspipMessageByUri(absPath, ProxyRelyingPartyTrustsAll, out filedValueInUri))
        {
            var req = new Contract.GetRelyingTrustListRequest{Identifier = filedValueInUri};
            dispatch endpoint Server over http accepts req;
        }
        else if (IsAdfspipMessageByUri(absPath, ProxyRelyingPartyTrusts, out filedValueInUri))
        {
            var req = new Contract.GetRelyingTrustRequest{};
            dispatch endpoint Server over http accepts req;
        }
        else if (IsAdfspipMessageByUri(absPath, ProxyWebApplicationProxyStoreAll, out filedValueInUri))
        {
            var req = new Contract.GetStoreEntryListRequest{Key = filedValueInUri};
            dispatch endpoint Server over http accepts req;
        }
        else if (IsAdfspipMessageByUri(absPath, ProxyWebApplicationProxyStore, out filedValueInUri))
        {
            if (httpReq.Method == "GET")
            {
                var req = new Contract.GetStoreEntryRequest{};
                dispatch endpoint Server over http accepts req;
            }
            else if (httpReq.Method == "POST")
            {
                switch (httpReq.Payload)
                {
                    case req:Contract.CreateStoreEntryRequest from JsonDecoder<Contract.CreateStoreEntryRequest> =>
                        dispatch endpoint Server over http accepts req;
                    default =>
                        ThrowDecodingException("ADFSPIP", "CreateStoreEntryRequest");
                }
            }
            else if (httpReq.Method == "PUT")
            {
                switch (httpReq.Payload)
                {
                    case req:Contract.UpdateStoreEntryRequest from JsonDecoder<Contract.UpdateStoreEntryRequest> =>
                        dispatch endpoint Server over http accepts req;
                    default =>
                        ThrowDecodingException("ADFSPIP", "UpdateStoreEntryRequest");
                }
            }
            else if (httpReq.Method == "DELETE")
            {
                var req = new Contract.RemoveStoreEntryRequest{};
                dispatch endpoint Server over http accepts req;
            }
            else
            {
                reject;
            }
        }
        else if (IsAdfspipMessageByUri(absPath, ProxyRelyingPartyTrustsPublishingSettings, out filedValueInUri))
        {
            if (httpReq.Method == "POST")
            {
                switch (httpReq.Payload)
                {
                    case req:Contract.CreatePublishingSettingRequest from JsonDecoder<Contract.CreatePublishingSettingRequest> =>
                        req.Identifier = filedValueInUri;
                        dispatch endpoint Server over http accepts req;
                    default =>
                        ThrowDecodingException("ADFSPIP", "CreatePublishingSettingRequest");
                }
            }
            else if (httpReq.Method == "DELETE")
            {
                switch (httpReq.Payload)
                {
                    case req:Contract.RemovePublishingSettingRequest from JsonDecoder<Contract.RemovePublishingSettingRequest> =>
                        req.Identifier = filedValueInUri;
                        dispatch endpoint Server over http accepts req;
                    default =>
                        ThrowDecodingException("ADFSPIP", "RemovePublishingSettingRequest");
                }
            }
            else 
            {
                ThrowDecodingException("ADFSPIP");
            }
        }
        else if (IsAdfspipMessageByUri(absPath, BackEndProxyTLS, out filedValueInUri))
        {
            switch (httpReq.Payload)
            {
                case req:Contract.PostCertificateRequest from JsonDecoder<Contract.PostCertificateRequest> =>
                    dispatch endpoint Server over http accepts req;
                default =>
                    ThrowDecodingException("ADFSPIP", "PostCertificateRequest");
            }
        }
        else if (IsAdfspipMessageByUri(absPath, ProxyPreauthenticationUri, out filedValueInUri))
        {
            var req = new Contract.ProxyPreauthenticationRequest{};
            if (httpReq.Uri.Query != nothing && httpReq.Uri.Query is query:map<string, string>)
            {
                req.UriQueryParameters = ParsePercentEncodedQuery(query);
            }
            dispatch endpoint Server over http accepts req;
        }
        else if (IsAdfspipMessageByUri(absPath, ProxyPreauthenticationForActiveClients, out filedValueInUri))
        {
            switch (httpReq.Payload)
            {
                case req:Contract.ProxyPreauthenticationForActiveClientsRequest from JsonDecoder<Contract.ProxyPreauthenticationForActiveClientsRequest> =>
                    dispatch endpoint Server over http accepts req;
                default =>
                    ThrowDecodingException("ADFSPIP", "ProxyPreauthenticationForActiveClientsRequest");
            }
        }
        else 
        {
            reject;
        }
    }
    
    process http issues httpRes:HttpContract.Response where httpRes#Uri != nothing && IsADFSPIP(httpRes#Uri as UriType)
    {
        var uri = httpRes#Uri as UriType;
        string absPath = uri.AbsPath as string;
        string method = httpRes#HttpMethod == nothing ? "" : httpRes#HttpMethod.ToString();
        string filedValueInUri;
        
        if (IsAdfspipMessageByUri(absPath, ProxyEstablishTrust, out filedValueInUri))
        {
            var res = new Contract.EstablishTrustResponse{StatusCode = httpRes.StatusCode};
            dispatch endpoint Server over http issues res;
        }
        else if (IsAdfspipMessageByUri(absPath, ProxyRenewTrust, out filedValueInUri))
        {
            var res = new Contract.RenewTrustResponse{StatusCode = httpRes.StatusCode};
            dispatch endpoint Server over http issues res;
        }
        else if (IsAdfspipMessageByUri(absPath, ProxyWebApplicationProxyTrust, out filedValueInUri))
        {
            if (method == "GET")
            {
                if (httpRes.StatusCode == 200)
                {
                    switch (httpRes.Payload)
                    {
                        case res:Contract.GetProxyRelyingPartTrustResponse from JsonDecoder<Contract.GetProxyRelyingPartTrustResponse> =>
                            res.StatusCode = 200;
                            dispatch endpoint Server over http issues res;
                        default =>
                            ThrowDecodingException("ADFSPIP", "GetProxyRelyingPartTrustResponse");
                    }
                }
                else 
                {
                    var err = new Contract.GetProxyRelyingPartTrustResponse{StatusCode = httpRes.StatusCode};
                    dispatch endpoint Server over http issues err;
                }
            }
            else if (method == "POST")
            {
                var res = new Contract.CreateProxyRelyingPartTrustResponse{StatusCode = httpRes.StatusCode};
                dispatch endpoint Server over http issues res;
            }
            else if (method == "DELETE")
            {
                var res = new Contract.RemoveProxyRelyingPartTrustResponse{StatusCode = httpRes.StatusCode};
                dispatch endpoint Server over http issues res;
            }
            else
            {
                reject;
            }
        }
        else if (IsAdfspipMessageByUri(absPath, ProxyGetConfiguration, out filedValueInUri))
        {
            if (httpRes.StatusCode == 200)
            {
                switch (httpRes.Payload)
                {
                    case res:Contract.GetConfigurationResponse from JsonDecoder<Contract.GetConfigurationResponse> =>
                        res.StatusCode = 200;
                        dispatch endpoint Server over http issues res;
                    default =>
                        ThrowDecodingException("ADFSPIP", "GetConfigurationResponse");
                }
            }
            else
            {
                var err = new Contract.GetConfigurationResponse{StatusCode = httpRes.StatusCode};
                dispatch endpoint Server over http issues err;
            }
        }
        else if (IsAdfspipMessageByUri(absPath, ProxyRelyingPartyTrustsAll, out filedValueInUri))
        {
            if (httpRes.StatusCode == 200)
            {
                switch (httpRes.Payload)
                {
                    case res:Contract.GetRelyingTrustListResponse from JsonDecoder<Contract.GetRelyingTrustListResponse> =>
                        res.StatusCode = 200;
                        dispatch endpoint Server over http issues res;
                    default =>
                        ThrowDecodingException("ADFSPIP", "GetRelyingTrustListResponse");
                }
            }
            else
            {
                var err = new Contract.GetRelyingTrustListResponse{StatusCode = httpRes.StatusCode};
                dispatch endpoint Server over http issues err;
            }
        }
        else if (IsAdfspipMessageByUri(absPath, ProxyWebApplicationProxyStoreAll, out filedValueInUri))
        {
            if (httpRes.StatusCode == 200)
            {
                switch (httpRes.Payload)
                {
                    case res:Contract.GetStoreEntryListResponse from JsonDecoder<Contract.GetStoreEntryListResponse> =>
                        res.StatusCode = 200;
                        dispatch endpoint Server over http issues res;
                    default =>
                        ThrowDecodingException("ADFSPIP", "GetStoreEntryListResponse");
                }
            }
            else
            {
                var err = new Contract.GetStoreEntryListResponse{StatusCode = httpRes.StatusCode};
                dispatch endpoint Server over http issues err;
            }
        }
        else if (IsAdfspipMessageByUri(absPath, ProxyWebApplicationProxyStore, out filedValueInUri))
        {
            if (method == "GET")
            {
                if (httpRes.StatusCode == 200)
                {
                    switch (httpRes.Payload)
                    {
                        case res:Contract.GetStoreEntryResponse from JsonDecoder<Contract.GetStoreEntryResponse> =>
                            res.StatusCode = 200;
                            dispatch endpoint Server over http issues res;
                        default =>
                            ThrowDecodingException("ADFSPIP", "GetStoreEntryResponse");
                    }
                }
                else
                {
                    var err = new Contract.GetStoreEntryResponse{StatusCode = httpRes.StatusCode};
                    dispatch endpoint Server over http issues err;
                }
            }
            else if (method == "POST")
            {
                var res = new Contract.CreateStoreEntryResponse{StatusCode = httpRes.StatusCode};
                dispatch endpoint Server over http issues res;
            }
            else if (method == "PUT")
            {
                var res = new Contract.UpdateStoreEntryResponse{StatusCode = httpRes.StatusCode};
                dispatch endpoint Server over http issues res;
            }
            else if (method == "DELETE")
            {
                var res = new Contract.RemoveStoreEntryResponse{StatusCode = httpRes.StatusCode};
                dispatch endpoint Server over http issues res;
            }
            else
            {
                reject;
            }
        }
        else if (IsAdfspipMessageByUri(absPath, ProxyRelyingPartyTrustsPublishingSettings, out filedValueInUri))
        {
            if (method == "POST")
            {
                var res = new Contract.CreatePublishingSettingResponse{StatusCode = httpRes.StatusCode};
                dispatch endpoint Server over http issues res;
            }
            else if (method == "DELETE")
            {
                var res = new Contract.RemovePublishingSettingResponse{StatusCode = httpRes.StatusCode};
                dispatch endpoint Server over http issues res;
            }
            else 
            {
                reject;
            }
        }
        else if (IsAdfspipMessageByUri(absPath, BackEndProxyTLS, out filedValueInUri))
        {
            var res = new Contract.PostCertificateResponse{StatusCode = httpRes.StatusCode};
            dispatch endpoint Server over http issues res;
        }
        else if (IsAdfspipMessageByUri(absPath, ProxyPreauthenticationUri, out filedValueInUri))
        {
            // Server returns authToken in redirectin way.
            if (httpRes.StatusCode in {302, 307})
            {
                var res1 = new Contract.ProxyPreauthenticationResponse{StatusCode = httpRes.StatusCode};
                if ("Location" in httpRes.Headers && httpRes.Headers["Location"] is u:UriType && u.Query is query:map<string, string>)
                {
                    query = ParsePercentEncodedQuery(query);
                    res1.authToken = ("authToken" in query) ? query["authToken"] : nothing;
                }
                dispatch endpoint Server over http issues res1;
            }
            else
            {
                var err = new Contract.ProxyPreauthenticationResponse{StatusCode = httpRes.StatusCode};
                dispatch endpoint Server over http issues err;
            }
        }
        else if (IsAdfspipMessageByUri(absPath, ProxyPreauthenticationForActiveClients, out filedValueInUri))
        {
            if (httpRes.StatusCode == 200)
            {
                switch (httpRes.Payload)
                {
                    case res:Contract.ProxyPreauthenticationForActiveClientsResponse from JsonDecoder<Contract.ProxyPreauthenticationForActiveClientsResponse> =>
                        dispatch endpoint Server over http issues res;
                    default =>
                        ThrowDecodingException("ADFSPIP", "ProxyPreauthenticationForActiveClientsResponse");
                }
            }
            else
            {
                switch (httpRes.Payload)
                {
                    case err:Contract.ErrorMessage from JsonDecoder<Contract.ErrorMessage> =>
                        dispatch endpoint Server over http issues err;
                    default =>
                        ThrowDecodingException("ADFSPIP", "ErrorMessage");
                }
            }
        }
        else 
        {
            reject;
        }
    }
}

// --------------------- type ------------------------ 
// 2.2.2.1   Proxy Trust
type ProxyTrust
{
    X509.Certificate SerializedTrustCertificate 
        with Encoding{SourcePattern = TypeOf<string>(), SourceConverter = Base64StringToBinary, Decoder = Asn1BerDecoder<X509.Certificate>};
}

// 2.2.2.2   Proxy Trust Renewal
type ProxyTrustRenewal
{
    X509.Certificate SerializedReplacementCertificate
        with Encoding{SourcePattern = TypeOf<string>(), SourceConverter = Base64StringToBinary, Decoder = Asn1BerDecoder<X509.Certificate>};
}

// 2.2.2.3   Proxy Relying Party Trust
type ProxyRelyingPartyTrust
{
    string Identifier;
}

// 2.2.2.4   Configuration
type Configuration
{
    ServiceConfiguration ServiceConfiguration;
    EndpointConfiguration EndpointConfiguration;
    optional string FarmBehavior;
    optional bool IgnoreTokenBinding;
    optional uint UpdatedFarmBehaviorLevel;

    override string ToString()
    {
        return ServiceConfiguration.ToString();
    }
}

type ServiceConfiguration
{
    string ServiceHostName;
    uint HttpPort;
    uint HttpsPort;
    uint HttpsPortForUserTlsAuth;
    array<X509.Certificate> DeviceCertificateIssuers
        with Encoding{SourcePattern = TypeOf<array<string>>(), Decoder = DeviceCertificateIssuers_Decoder};
    uint ProxyTrustCertificateLifetime;
    array<string> DiscoveredUpnSuffixes;
    array<string> CustomUpnSuffixes;
    
    override string ToString()
    {
        return "ServiceHostName: " + ServiceHostName;
    }

    optional array<X509.Certificate> DeviceCertificateIssuers_Decoder(array<string> strs)
    {
        if (strs.Count == 0) return [];
        array<X509.Certificate> decodeRet = [];
        foreach (string s in strs)
        {
            if (Base64StringToBinary(s) is bin:binary && Asn1BerDecoder<X509.Certificate>(bin) is cert:X509.Certificate)
            {
                decodeRet += [cert];
            }
        }
        return decodeRet;
    }
}
 
type EndpointConfiguration
{
    array<Endpoint> Endpoints;
}

type Endpoint
{
    string Path;
    PortType PortType;
    CredentialCollectionScheme AuthenticationSchemes;
    TLSQueryBehavior ClientCertificateQueryMode;
    CertificateValidation CertificateValidation;
    bool SupportsNtlm;
    string ServicePath;
    PortType ServicePortType;
}

// 2.2.2.5   Relying Party Trust List
type RelyingPartyTrustList
{
    array<RelyingPartyTrustListElement> RelyingPartyTrustList;
}

type RelyingPartyTrustListElement
{
    string objectIdentifier;
    string name;
    bool publishedThroughProxy;
    bool nonClaimsAware;
    bool enabled;
}

// 2.2.2.6   Relying Party Trust
type RelyingPartyTrust
{
    string objectIdentifier;
    string name;
    bool publishedThroughProxy;
    bool nonClaimsAware;
    bool enable;
    array<string> identifiers;
    array<string> proxyTrustedEndpoints;
    array<proxyEndpointMapping> proxyEndpointMappings;
}

type proxyEndpointMapping
{
    string Key;
    string Value;
}

// 2.2.2.7   Relying Party Trust Publishing Settings
type RelyingPartyTrustPublishingSettings
{
    string externalUrl;
    string internalUrl;
    string proxyTrustedEndpointUrl;
}

// 2.2.2.8   Store Entry List
type StoreEntryList
{
    array<StoreEntry> StoreEntryList with JsonEncoding{SkipWrapping = true};
}

// 2.2.2.9   Store Entry
type StoreEntry
{
    string $"key";
    string version;
    optional string $"value";
}

// 2.2.2.10   Store Entry Key and Value
type StoreEntryKeyAndValue
{
    string $"key";
    string $"vlaue";
}

// 2.2.2.11   Serialized Request with Certificate
type SerializedRequestWithCertificate
{
    RequestType Request;
    X509.Certificate SerializedClientCertificate
        with Encoding{SourcePattern = TypeOf<string>(), SourceConverter = Base64StringToBinary, Decoder = Asn1BerDecoder<X509.Certificate>};
    CertificateType CertificateUsage;
    optional ErrorType ErrorType;
    optional int ErrorCode;
}

type RequestType
{
    array<string> AcceptTypes;
    array<byte> Content;
    string ContentEncoding;
    uint ContentLength;
    string ContentType;
    array<CookiesType> Cookies;
    array<HeadersType> Headers;
    string HttpMethod;
    string RequestUri;
    array<QueryStringType> QueryString;
    string UserAgent;
    string UserHostAddress;
    string UserHostName;
    array<string> UserLanguages;
}

type CookiesType
{
    string Name;
    string Value;
    string Path;
    string Domain;
    string Expires;
    string Version;
}

type HeadersType
{
    string Name;
    string Value;
}

type QueryStringType
{
    string Name;
    string Value;
}

// 2.2.2.12   Port Type
pattern PortType = enum byte
{
    HttpPort,
    HttpsPort,
    HttpsPortForUserTlsAuth,
    ...
};

// 2.2.2.13   Credential Collection Scheme
pattern CredentialCollectionScheme = enum uint
{
    Basic       = 8,
    Anonymous   = 32768, 
    ...
};

// 2.2.2.14   TLS Query Behavior
pattern TLSQueryBehavior = enum string
{
    None                = "None",
    QueryAndAccept      = "QueryAndAccept",
    QueryAndRequire     = "QueryAndRequire",
    ...
};

// 2.2.2.15   Certificate Validation
pattern CertificateValidation = enum string
{
    None        = "None",
    User        = "User",
    Device      = "Device",
    ...
};

// 2.2.2.16   Certificate Type
pattern CertificateType = enum string
{
    User        = "User",
    Device      = "Device",
    ...
};

// 2.2.2.17   Error Type
pattern ErrorType = enum string
{
    None        = "None",
    Certificate = "Certificate",
    ...
};

// 2.2.2.18   Proxy Token
type ProxyToken
{
    string ver where ValidationCheck(value == "1.0", null, "ADFSPIP: The ver field in type ProxyToken must be 1.0, not " + value + ".");
    string aud;
    uint iat;
    uint exp;
    string iss;
    guid relyingpartytrustid;
    optional guid deviceregid;
    string authinstant;
    string authmethod;
    string upn;

    override string ToString()
    {
        return "ver: " + ver + ", aud: " + aud;
    }
}

optional ProxyToken ProxyTokenDecoder(string s)
{
    array<string> parts = s.Split(['.']);
    if (parts.Count == 3)
    {
        if (Base64StringToBinary(parts[1]) is bin:binary && JsonDecoder<ProxyToken>(bin) is token:ProxyToken)
        {
            return token;
        }
    }
    return nothing;
}

// 2.2.2.19   Combined Token
type CombinedToken
{
    ProxyToken proxy_token;
    ProxyToken access_token;
}

// 2.2.2.20 Proxy Token Wrapper
type ProxyTokenWrapper
{
    ProxyToken authToken 
        with Encoding{SourcePattern = TypeOf<string>(), Decoder = ProxyTokenDecoder};
    override string ToString()
    {
        return authToken.ToString();
    }
}

// 2.2.2.21 Authentication Request
type AuthenticationRequest
{
    string appRealm;
    string realm;
    string username;
    string password; // base64
    X509.Certificate deviceCertificate
        with Encoding{SourcePattern = TypeOf<string>(), SourceConverter = Base64StringToBinary, Decoder = Asn1BerDecoder<X509.Certificate>};
    X509.Certificate userCertificate
        with Encoding{SourcePattern = TypeOf<string>(), SourceConverter = Base64StringToBinary, Decoder = Asn1BerDecoder<X509.Certificate>};
    array<httpHeadersType> httpHeaders;

    override string ToString()
    {
        return "appRealm: " + appRealm + ", realm: " + realm + ", username: " + username;
    }
}

type httpHeadersType
{
    string Key;
    string Value;
}

// 2.2.2.22 Error Response
type ErrorResponse
{
    ErrorId id;
    string $"message";
    string $"type";

    override string ToString()
    {
        return "id: " + EnumToStringInSummary<ErrorId>(id) + ", message: " + $"message";
    }
}

pattern ErrorId = enum uint
{
    Unauthorized            = 401,
    Forbidden               = 403,
    $"Not Found"            = 404,
    $"Precondition Failed"  = 412,
    ...
};

// --------------------- message and virtual operation ------------------------ 
contract Contract
{
    // 3.2.5.1.1   Proxy/EstablishTrust -- POST
    accepts message EstablishTrustRequest
    {
        ProxyTrust ProxyTrust with JsonEncoding{SkipWrapping = true};
        
        override string ToString()
        {
            return "EstablishTrustRequest";
        }
    }
    
    issues message EstablishTrustResponse
    {
        uint StatusCode with DisplayInfo{ToText = GetStatusCodeMeaning};
        override string ToString()
        {
            return "EstablishTrustResponse, StatusCode: " + StatusCode.ToString();
        }
    }
    
    issues virtual operation EstablishTrust
    {
        in ProxyTrust ProxyTrust = proxyTrust;
        out uint StatusCode = status with DisplayInfo{ToText = GetStatusCodeMeaning};
        
        override string ToString()
        {
            return "EstablishTrust, StatusCode: " + StatusCode.ToString();
        }
    }
    = 
    accepts Contract.EstablishTrustRequest{ProxyTrust is var proxyTrust}
    issues Contract.EstablishTrustResponse{StatusCode is status:uint};
    
    // 3.2.5.2.1   Proxy/RenewTrust -- POST
    accepts message RenewTrustRequest
    {
        ProxyTrustRenewal ProxyTrustRenewal with JsonEncoding{SkipWrapping = true};
        
        override string ToString()
        {
            return "RenewTrustRequest";
        }
    }
    
    issues message RenewTrustResponse
    {
        uint StatusCode with DisplayInfo{ToText = GetStatusCodeMeaning};
        
        override string ToString()
        {
            return "RenewTrustResponse, StatusCode: " + StatusCode.ToString();
        }
    }
    
    issues virtual operation RenewTrust
    {
        in ProxyTrustRenewal ProxyTrustRenewal = renewal;
        out uint StatusCode = status with DisplayInfo{ToText = GetStatusCodeMeaning};
        
        override string ToString()
        {
            return "EstablishTrust, StatusCode: " + StatusCode.ToString();
        }
    }
    =
    accepts Contract.RenewTrustRequest{ProxyTrustRenewal is var renewal}
    issues Contract.RenewTrustResponse{StatusCode is status:uint};
    
    // 3.2.5.3.1   Proxy/WebApplicationProxy/Trust -- GET
    accepts message GetProxyRelyingPartTrustRequest
    {
        string Key;
        override string ToString()
        {
            return "GetProxyRelyingPartTrustRequest";
        }
    }
    
    issues message GetProxyRelyingPartTrustResponse
    {
        uint StatusCode with Encoding{Ignore = true}, DisplayInfo{ToText = GetStatusCodeMeaning};
        optional ProxyRelyingPartyTrust ProxyRelyingPartyTrust with JsonEncoding{SkipWrapping = true};
        
        override string ToString()
        {
            return "GetProxyRelyingPartTrustResponse, StatusCode: " + StatusCode.ToString();
        }
    }
    
    issues virtual operation GetProxyRelyingPartTrust
    {
        in string Key = k;
        out uint StatusCode = status with DisplayInfo{ToText = GetStatusCodeMeaning};
        out optional ProxyRelyingPartyTrust ProxyRelyingPartyTrust = trust;
        
        override string ToString()
        {
            return "GetProxyRelyingPartTrust, StatusCode: " + StatusCode.ToString();
        }
    }
    = 
    accepts Contract.GetProxyRelyingPartTrustRequest{Key is k:string}
    issues Contract.GetProxyRelyingPartTrustResponse{StatusCode is status:uint, ProxyRelyingPartyTrust is var trust};
    
    // 3.2.5.3.2   Proxy/WebApplicationProxy/Trust -- POST
    accepts message CreateProxyRelyingPartTrustRequest
    {
        ProxyRelyingPartyTrust ProxyRelyingPartyTrust with JsonEncoding{SkipWrapping = true};
        
        override string ToString()
        {
            return "CreateProxyRelyingPartTrustRequest";
        }
    }
    
    issues message CreateProxyRelyingPartTrustResponse
    {
        uint StatusCode with DisplayInfo{ToText = GetStatusCodeMeaning};
        
        override string ToString()
        {
            return "CreateProxyRelyingPartTrustResponse, StatusCode: " + StatusCode.ToString();
        }
    }
    
    issues virtual operation CreateProxyRelyingPartTrust
    {
        out uint StatusCode = status with DisplayInfo{ToText = GetStatusCodeMeaning};
        in optional ProxyRelyingPartyTrust ProxyRelyingPartyTrust = trust;
        
        override string ToString()
        {
            return "CreateProxyRelyingPartTrust, StatusCode: " + StatusCode.ToString();
        }
    }
    = 
    accepts Contract.CreateProxyRelyingPartTrustRequest{ProxyRelyingPartyTrust is var trust}
    issues Contract.CreateProxyRelyingPartTrustResponse{StatusCode is status:uint};
    
    // 3.2.5.3.3   Proxy/WebApplicationProxy/Trust -- DELETE
    accepts message RemoveProxyRelyingPartTrustRequest
    {
        override string ToString()
        {
            return "RemoveProxyRelyingPartTrustRequest";
        }
    }
    
    issues message RemoveProxyRelyingPartTrustResponse
    {
        uint StatusCode with DisplayInfo{ToText = GetStatusCodeMeaning};
        
        override string ToString()
        {
            return "RemoveProxyRelyingPartTrustResponse, StatusCode: " + StatusCode.ToString();
        }
    }
    
    issues virtual operation RemoveProxyRelyingPartTrust
    {
        out uint StatusCode = status with DisplayInfo{ToText = GetStatusCodeMeaning};
        
        override string ToString()
        {
            return "RemoveProxyRelyingPartTrust, StatusCode: " + StatusCode.ToString();
        }
    }
    =
    accepts Contract.RemoveProxyRelyingPartTrustRequest{}
    issues Contract.RemoveProxyRelyingPartTrustResponse{StatusCode is status:uint};
    
    // 3.4.5.1.1   Proxy/GetConfiguration -- GET
    accepts message GetConfigurationRequest
    {
        override string ToString()
        {
            return "GetConfigurationRequest";
        }
    }
    
    issues message GetConfigurationResponse
    {
        uint StatusCode with
            Encoding{Ignore = true},
            DisplayInfo{ToText = GetStatusCodeMeaning};
        optional Configuration Configuration with JsonEncoding{SkipWrapping = true};
        
        override string ToString()
        {
            return "GetConfigurationResponse, StatusCode: " + StatusCode.ToString() + ", " + Configuration.ToString();
        }
    }
    
    issues virtual operation GetConfiguration
    {
        out uint StatusCode = status with DisplayInfo{ToText = GetStatusCodeMeaning};
        out optional Configuration Configuration = config;
        
        override string ToString()
        {
            return "GetConfiguration, StatusCode: " + StatusCode.ToString() + 
                (Configuration == nothing ? "" : (", " + (Configuration as Configuration).ToString()));
        }
    }
    =
    accepts Contract.GetConfigurationRequest{}
    issues Contract.GetConfigurationResponse{StatusCode is status:uint, Configuration is var config};
    
    // 3.4.5.2.1   Proxy/RelyingPartyTrusts -- GET
    accepts message GetRelyingTrustListRequest
    {
        string Identifier;
        override string ToString()
        {
            return "GetRelyingTrustListRequest, Identifier: " + Identifier;
        }
    }
    
    issues message GetRelyingTrustListResponse
    {
        uint StatusCode with Encoding{Ignore = true}, DisplayInfo{ToText = GetStatusCodeMeaning};
        optional RelyingPartyTrustList RelyingPartyTrustList with JsonEncoding{SkipWrapping = true};
        
        override string ToString()
        {
            return "GetRelyingTrustListResponse, StatusCode: " + StatusCode.ToString();
        }
    }
    
    issues virtual operation GetRelyingTrustList
    {
        in string Identifier = id;
        out uint StatusCode = status with DisplayInfo{ToText = GetStatusCodeMeaning};
        out optional RelyingPartyTrustList RelyingPartyTrustList = trustList;
        override string ToString()
        {
            return "GetRelyingTrustList, StatusCode: " + StatusCode.ToString() + ", Identifier: " + Identifier;
        }
    }
    =
    accepts Contract.GetRelyingTrustListRequest{Identifier is id:string}
    issues Contract.GetRelyingTrustListResponse{StatusCode is status:uint, RelyingPartyTrustList is var trustList};
    
    // 3.4.5.3.1   Proxy/RelyingPartyTrusts/ -- GET
    accepts message GetRelyingTrustRequest
    {
        override string ToString()
        {
            return "GetRelyingTrustRequest";
        }
    }
    
    issues message GetRelyingTrustResponse
    {
        uint StatusCode with 
            Encoding{Ignore = true},
            DisplayInfo{ToText = GetStatusCodeMeaning};
        optional RelyingPartyTrust RelyingPartyTrust with JsonEncoding{SkipWrapping = true};
        
        override string ToString()
        {
            return "GetRelyingTrustResponse, StatusCode: " + StatusCode.ToString();
        }
    }
    
    issues virtual operation GetRelyingTrust
    {
        out uint StatusCode = status with DisplayInfo{ToText = GetStatusCodeMeaning};
        out optional RelyingPartyTrust RelyingPartyTrust = trust;
        
        override string ToString()
        {
            return "GetRelyingTrust, StatusCode: " + StatusCode.ToString();
        }
    }
    =
    accepts Contract.GetRelyingTrustRequest{}
    issues Contract.GetRelyingTrustResponse{StatusCode is status:uint, RelyingPartyTrust is var trust};
    
    // 3.6.5.1.1   Proxy/WebApplicationProxy/Store -- GET
    accepts message GetStoreEntryListRequest
    {
        string Key;
        override string ToString()
        {
            return "GetStoreEntryListRequest, Key: " + Key;
        }
    }
    
    issues message GetStoreEntryListResponse
    {
        uint StatusCode with Encoding{Ignore = true}, DisplayInfo{ToText = GetStatusCodeMeaning};
        optional StoreEntryList StoreEntryList with JsonEncoding{SkipWrapping = true};
        
        override string ToString()
        {
            return "GetStoreEntryListResponse, StatusCode: " + StatusCode.ToString();
        }
    }
    
    issues virtual operation GetStoreEntryList
    {
        in string Key = k;
        out uint StatusCode = status with DisplayInfo{ToText = GetStatusCodeMeaning};
        out optional StoreEntryList StoreEntryList = entryList;
        
        override string ToString()
        {
            return "GetStoreEntryList, StatusCode: " + StatusCode.ToString() + ", Key: " + Key;
        }
    }
    =
    accepts Contract.GetStoreEntryListRequest{Key is k:string}
    issues Contract.GetStoreEntryListResponse{StatusCode is status:uint, StoreEntryList is var entryList};
    
    // 3.6.5.2.1   Proxy/WebApplicationProxy/Store/ -- GET
    accepts message GetStoreEntryRequest
    {
        override string ToString()
        {
            return "GetStoreEntryRequest";
        }
    }
    
    issues message GetStoreEntryResponse
    {
        uint StatusCode with Encoding{Ignore = true}, DisplayInfo{ToText = GetStatusCodeMeaning};
        optional StoreEntry StoreEntry with JsonEncoding{SkipWrapping = true};
        
        override string ToString()
        {
            return "GetStoreEntryListResponse, StatusCode: " + StatusCode.ToString();
        }
    }
    
    issues virtual operation GetStoreEntry
    {
        out uint StatusCode = status with DisplayInfo{ToText = GetStatusCodeMeaning};
        out optional StoreEntry StoreEntry = entry;
        
        override string ToString()
        {
            return "GetStoreEntry, StatusCode: " + StatusCode.ToString();
        }
    }
    =
    accepts Contract.GetStoreEntryRequest{}
    issues Contract.GetStoreEntryResponse{StatusCode is status:uint, StoreEntry is var entry};
   
    // 3.6.5.2.2   Proxy/WebApplicationProxy/Store/ -- POST
    accepts message CreateStoreEntryRequest
    {
        StoreEntryKeyAndValue StoreEntryKeyAndValue with JsonEncoding{SkipWrapping = true};
        
        override string ToString()
        {
            return "CreateStoreEntryRequest";
        }
    }
    
    issues message CreateStoreEntryResponse
    {
        uint StatusCode with DisplayInfo{ToText = GetStatusCodeMeaning};
        
        override string ToString()
        {
            return "CreateStoreEntryResponse, StatusCode: " + StatusCode.ToString();
        }
    }
    
    issues virtual operation CreateStoreEntry
    {
        in StoreEntryKeyAndValue StoreEntryKeyAndValue = kvalue;
        out uint StatusCode = status with DisplayInfo{ToText = GetStatusCodeMeaning};
        
        override string ToString()
        {
            return "CreateStoreEntry, StatusCode: " + StatusCode.ToString();
        }
    }
    =
    accepts Contract.CreateStoreEntryRequest{StoreEntryKeyAndValue is var kvalue}
    issues Contract.CreateStoreEntryResponse{StatusCode is status:uint};
    
    // 3.6.5.2.3   Proxy/WebApplicationProxy/Store/ -- PUT
    accepts message UpdateStoreEntryRequest
    {
        StoreEntry StoreEntry with JsonEncoding{SkipWrapping = true};
        
        override string ToString()
        {
            return "UpdateStoreEntryRequest";
        }
    }
    
    issues message UpdateStoreEntryResponse
    {
        uint StatusCode with DisplayInfo{ToText = GetStatusCodeMeaning};
        
        override string ToString()
        {
            return "UpdateStoreEntryResponse, StatusCode: " + StatusCode.ToString();
        }
    }
    
    issues virtual operation UpdateStoreEntry
    {
        in StoreEntry StoreEntry = entry;
        out uint StatusCode = status with DisplayInfo{ToText = GetStatusCodeMeaning};
        
        override string ToString()
        {
            return "UpdateStoreEntry, StatusCode: " + StatusCode.ToString();
        }
    }
    =
    accepts Contract.UpdateStoreEntryRequest{StoreEntry is var entry}
    issues Contract.UpdateStoreEntryResponse{StatusCode is status:uint};
    
    // 3.6.5.2.4   Proxy/WebApplicationProxy/Store/ -- DELETE
    accepts message RemoveStoreEntryRequest
    {
        override string ToString()
        {
            return "RemoveStoreEntryRequest";
        }
    }
    
    issues message RemoveStoreEntryResponse
    {
        uint StatusCode with DisplayInfo{ToText = GetStatusCodeMeaning};
        
        override string ToString()
        {
            return "RemoveStoreEntryResponse, StatusCode: " + StatusCode.ToString();
        }
    }
    
    issues virtual operation RemoveStoreEntry
    {
        out uint StatusCode = status with DisplayInfo{ToText = GetStatusCodeMeaning};
        
        override string ToString()
        {
            return "RemoveStoreEntry, StatusCode: " + StatusCode.ToString();
        }
    }
    =
    accepts Contract.RemoveStoreEntryRequest{}
    issues Contract.RemoveStoreEntryResponse{StatusCode is status:uint};
    
    // 3.8.5.1.1   Proxy/RelyingPartyTrusts/{Identifier}/PublishingSettings -- POST
    accepts message CreatePublishingSettingRequest
    {
        string Identifier with Encoding{Ignore = true};
        RelyingPartyTrustPublishingSettings RelyingPartyTrustPublishingSettings with JsonEncoding{SkipWrapping = true};
        
        override string ToString()
        {
            return "CreatePublishingSettingRequest, Identifier: " + Identifier;
        }
    }
    
    issues message CreatePublishingSettingResponse
    {
        uint StatusCode with DisplayInfo{ToText = GetStatusCodeMeaning};
        
        override string ToString()
        {
            return "CreatePublishingSettingResponse, StatusCode: " + StatusCode.ToString();
        }
    }
    
    issues virtual operation CreatePublishingSetting
    {
        in string Identifier = id;
        in RelyingPartyTrustPublishingSettings RelyingPartyTrustPublishingSettings = settings;
        out uint StatusCode = status with DisplayInfo{ToText = GetStatusCodeMeaning};
        
        override string ToString()
        {
            return "CreatePublishingSetting, StatusCode: " + StatusCode.ToString() + ", Identifier: " + Identifier;
        }
    }
    = 
    accepts Contract.CreatePublishingSettingRequest{RelyingPartyTrustPublishingSettings is var settings, Identifier is id: string}
    issues Contract.CreatePublishingSettingResponse{StatusCode is status:uint};
    
    // 3.8.5.1.2   Proxy/RelyingPartyTrusts/{Identifier}/PublishingSettings -- DELETE
    accepts message RemovePublishingSettingRequest
    {
        string Identifier with Encoding{Ignore = true};
        RelyingPartyTrustPublishingSettings RelyingPartyTrustPublishingSettings with JsonEncoding{SkipWrapping = true};
        
        override string ToString()
        {
            return "RemovePublishingSettingRequest";
        }
    }
    
    issues message RemovePublishingSettingResponse
    {
        uint StatusCode with DisplayInfo{ToText = GetStatusCodeMeaning};
        
        override string ToString()
        {
            return "RemovePublishingSettingResponse, StatusCode: " + StatusCode.ToString();
        }
    }
    
    issues virtual operation RemovePublishingSetting
    {
        in string Identifier = id;
        in RelyingPartyTrustPublishingSettings RelyingPartyTrustPublishingSettings = settings;
        out uint StatusCode = status with DisplayInfo{ToText = GetStatusCodeMeaning};
        
        override string ToString()
        {
            return "RemovePublishingSetting, StatusCode: " + StatusCode.ToString() + ", Identifier: " + Identifier;
        }
    }
    =
    accepts Contract.RemovePublishingSettingRequest{RelyingPartyTrustPublishingSettings is var settings, Identifier is id:string}
    issues Contract.RemovePublishingSettingResponse{StatusCode is status:uint};
    
    // 3.10.5.1.1   BackEndProxyTLS -- POST
    accepts message PostCertificateRequest
    {
        SerializedRequestWithCertificate SerializedRequestWithCertificate with JsonEncoding{SkipWrapping = true};
        
        override string ToString()
        {
            return "PostCertificateRequest";
        }
    }
    
    issues message PostCertificateResponse
    {
        uint StatusCode with DisplayInfo{ToText = GetStatusCodeMeaning};
        
        override string ToString()
        {
            return "PostCertificateResponse, StatusCode: " + StatusCode.ToString();
        }
    }
    
    issues virtual operation PostCertificate
    {
        in SerializedRequestWithCertificate SerializedRequestWithCertificate = cert;
        out uint StatusCode = status with DisplayInfo{ToText = GetStatusCodeMeaning};
        
        override string ToString()
        {
            return "PostCertificate, StatusCode: " + StatusCode.ToString();
        }
    }
    =
    accepts Contract.PostCertificateRequest{SerializedRequestWithCertificate is var cert}
    issues Contract.PostCertificateResponse{StatusCode is status:uint};
    
    // 3.12.5.1.1   Proxy Preauthentication -- GET
    accepts message ProxyPreauthenticationRequest
    {
        map<string, string> UriQueryParameters;
        override string ToString()
        {
            return "ProxyPreauthenticationRequest";
        }
    }
    
    issues message ProxyPreauthenticationResponse
    {
        uint StatusCode with DisplayInfo{ToText = GetStatusCodeMeaning};
        optional string authToken;
        
        override string ToString()
        {
            return "ProxyPreauthenticationResponse, StatusCode: " + StatusCode.ToString();
        }
    }
    
    issues virtual operation ProxyPreauthentication
    {
        in map<string, string> UriQueryParameters = paras;
        out uint StatusCode = status with DisplayInfo{ToText = GetStatusCodeMeaning};
        out optional string authToken = token;
        
        override string ToString()
        {
            return "ProxyPreauthentication, StatusCode: " + StatusCode.ToString();
        }
    }
    =
    accepts Contract.ProxyPreauthenticationRequest{UriQueryParameters is var paras}
    issues Contract.ProxyPreauthenticationResponse{StatusCode is status:uint, authToken is var token};

    // 3.12.5.1.5   Proxy Preauthentication for Active Clients -- POST
    // adfs/proxy/relyingpartytoken?api-version=1
    accepts ProxyPreauthenticationForActiveClientsRequest
    {
        AuthenticationRequest Reqeust with JsonEncoding{SkipWrapping = true};
        override string ToString()
        {
            return "ProxyPreauthenticationForActiveClientsRequest, " + Reqeust.ToString();
        }
    };

    issues ProxyPreauthenticationForActiveClientsResponse
    {
        ProxyTokenWrapper Response with JsonEncoding{SkipWrapping = true};
        override string ToString()
        {
            return "ProxyPreauthenticationForActiveClientsResponse, " + Response.ToString();
        }
    };

    issues ErrorMessage
    {
        ErrorResponse ErrorResponse with JsonEncoding{SkipWrapping = true};
        override string ToString()
        {
            return ErrorResponse.ToString();
        }
    };

    issues virtual operation ProxyPreauthenticationForActiveClients
    {
        AuthenticationRequest Reqeust = req;
        optional ProxyTokenWrapper Response = res == null ? nothing : res;
        optional ErrorResponse ErrorResponse = err == null ? nothing : err;

        override string ToString()
        {
            string summary = "ProxyPreauthenticationForActiveClients, ";
            if (ErrorResponse is errRes:ErrorResponse && errRes != null)
            {
                summary += errRes.ToString();
            }
            else if (Response is successRes:ProxyTokenWrapper && successRes != null)
            {
                summary += successRes.ToString();
            }
            return summary + Reqeust.ToString();
        }
    }
    = 
    accepts Contract.ProxyPreauthenticationForActiveClientsRequest{Reqeust is req:AuthenticationRequest}
    (
        issues Contract.ProxyPreauthenticationForActiveClientsResponse{Response is res:ProxyTokenWrapper}  
        |
        issues Contract.ErrorMessage{ErrorResponse is err:ErrorResponse}
    );
}

//------------- Function and syntax
// entry condition of actor
bool IsADFSPIP(HTTP.UriType uri)
{
    if (uri.AbsPath != nothing)
    {
        string absPath = uri.AbsPath.ToString().ToLower();
        if (absPath.IndexOf("/adfs/proxy/") == 0 || absPath.IndexOf("/adfs/backendproxytls") == 0)
        {
            return true;
        }
        else if (absPath == "/adfs/ls" && uri.Query is uriQuery:map<string, string>)
        {
            // Uri Query contains "realm=urn:appproxy.com"
            return ("realm" in uriQuery) && uriQuery["realm"].ToLower() == "urn%3aappproxy%3acom";
        }
    }
    return false;
}

// Check if current message is ADFSPIP message indicated by uri.
bool IsAdfspipMessageByUri(string absPath, (optional string)(stream) uriChecker, out string filedInAbsPath)
{
    absPath = absPath.ToLower();
    if (absPath.IndexOf("adfs/") is index:int && index > 0)
    {
        // remove the possible leading parts
        absPath = absPath.Segment(index);
    }
    else
    {
        return false;
    }
    // now the 'absPath' starts with "adfs/".
    if (uriChecker(absPath) is v:string)
    {
        filedInAbsPath = v;
        return true;
    }
    else
    {
        return false;
    }
}

// adfs/proxy/ [PrimaryWriter/] EstablishTrust
syntax ProxyEstablishTrust = "adfs/proxy/" "primarywriter/"? "establishtrust";

// adfs/proxy/ [PrimaryWriter/] RenewTrust
syntax ProxyRenewTrust = "adfs/proxy/" "primaryWriter/"? "renewtrust";

// adfs/proxy/WebApplicationProxy/ [PrimaryWriter/] trust
syntax ProxyWebApplicationProxyTrust = "adfs/proxy/webapplicationproxy/" "primarywriter/"? "trust";

// adfs/proxy/GetConfiguration
syntax ProxyGetConfiguration = "adfs/proxy/getconfiguration";

// adfs/proxy/RelyingPartyTrusts
syntax ProxyRelyingPartyTrustsAll = "adfs/proxy/" regex{relyingpartytrusts$};

// adfs/proxy/RelyingPartyTrusts/{Identifier}
syntax ProxyRelyingPartyTrusts = "adfs/proxy/relyingpartytrusts/" id:regex{[^/]+$} => id;

// adfs/proxy/WebApplicationProxy/Store
syntax ProxyWebApplicationProxyStoreAll = "adfs/proxy/" regex{webapplicationproxy/store$};

// adfs/proxy/ [PrimaryWriter/] WebApplicationProxy/Store/{Key}?
syntax ProxyWebApplicationProxyStore = "adfs/proxy/" "webapplicationproxy/"? "store/" k:regex{[^?]+} => k;

// adfs/proxy/RelyingPartyTrusts/{Identifier}/PublishingSettings?api-version=1
// adfs/proxy/PrimaryWriter/RelyingPartyTrusts/{Identifier}/PublishingSettings?api-version=1
syntax ProxyRelyingPartyTrustsPublishingSettings = "adfs/proxy/" "primarywriter/"? "relyingpartytrusts/" id:regex{[^/]+} "/publishedsettings" => id;

syntax BackEndProxyTLS = "adfs/backendproxytls";

syntax ProxyPreauthenticationUri = "adfs/ls";

// adfs/proxy/relyingpartytoken?api-version=1
syntax ProxyPreauthenticationForActiveClients = "adfs/proxy/relyingpartytoken";

string GetStatusCodeMeaning(any data)
{
    uint code = data as uint;
    if (code in StatusCodes)
    {
        return code.ToString() + ", " + StatusCodes[code];
    }
    else
    {
        return code.ToString() + ", Undefined status code";
    }
}

map<uint, string> StatusCodes = 
{
    200 -> "The operation has succeeded.",
    400 -> "The request is not valid.",
    401 -> "Unauthorized for specified user credentials or for client TLS certificate.",
    403 -> "The access is forbidden.",
    404 -> "The object does not exist.",
    405 -> "Invalid verb used in request (GET, DELETE, POST, PUT).",
    409 -> "The object already exists.",
    412 -> "A precondition failed.",
    500 -> "Version is not specified where required or any other internal error.",
    501 -> "Version specified (api-version) is invalid (only valid value is 1).",
};
