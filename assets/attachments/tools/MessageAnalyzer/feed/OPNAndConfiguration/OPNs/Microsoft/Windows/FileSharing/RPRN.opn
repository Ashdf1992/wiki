protocol RPRN with 
Documentation
{
    ProtocolName = "Print System Remote Protocol",
    ProtocolType = "rpc",
    ShortName = "RPRN",
    DocumentName = "MS-RPRN",
    Description = ""
},
OPNAuthoring
{
    Copyright = "(c) Microsoft Corporation",
    References = 
    [
        new Reference {Name = "MS-RPRN", Version = "29.0", Date = "06/01/2017", ProgramName = ProgramName.WSPP}
    ],
    RevisionSummary = 
    [
        new Revision {Class = RevisionClass.Major, Version = "4764740", Date = "01/26/2016"}
    ]
};

using Technologies.IDL;
using DTYP;
using MSRPCE;
using ERREF;
using Utility;
using Diagnostics;
using FileSharingResources;

endpoint RprnService over MSRPCE.Server provides WinSpool;

// --- AOP Generated OPN code starts ---
// Use manual AOP because some operations (e.g. RpcEnumPrinters/RpcEnumForms) requires context variable and NdrInfo 
// to decode marshaled structures, decoders must be declared in message level.
pattern _WinSpoolOpnums =
    enum ushort
    {
        RpcEnumPrinters = 0,
        RpcOpenPrinter = 1,
        RpcSetJob = 2,
        RpcGetJob = 3,
        RpcEnumJobs = 4,
        RpcAddPrinter = 5,
        RpcDeletePrinter = 6,
        RpcSetPrinter = 7,
        RpcGetPrinter = 8,
        RpcAddPrinterDriver = 9,
        RpcEnumPrinterDrivers = 10,
        RpcGetPrinterDriver = 11,
        RpcGetPrinterDriverDirectory = 12,
        RpcDeletePrinterDriver = 13,
        RpcAddPrintProcessor = 14,
        RpcEnumPrintProcessors = 15,
        RpcGetPrintProcessorDirectory = 16,
        RpcStartDocPrinter = 17,
        RpcStartPagePrinter = 18,
        RpcWritePrinter = 19,
        RpcEndPagePrinter = 20,
        RpcAbortPrinter = 21,
        RpcReadPrinter = 22,
        RpcEndDocPrinter = 23,
        RpcAddJob = 24,
        RpcScheduleJob = 25,
        RpcGetPrinterData = 26,
        RpcSetPrinterData = 27,
        RpcWaitForPrinterChange = 28,
        RpcClosePrinter = 29,
        RpcAddForm = 30,
        RpcDeleteForm = 31,
        RpcGetForm = 32,
        RpcSetForm = 33,
        RpcEnumForms = 34,
        RpcEnumPorts = 35,
        RpcEnumMonitors = 36,
        Opnum37NotUsedOnWire = 37,
        Opnum38NotUsedOnWire = 38,
        RpcDeletePort = 39,
        RpcCreatePrinterIC = 40,
        RpcPlayGdiScriptOnPrinterIC = 41,
        RpcDeletePrinterIC = 42,
        Opnum43NotUsedOnWire = 43,
        Opnum44NotUsedOnWire = 44,
        Opnum45NotUsedOnWire = 45,
        RpcAddMonitor = 46,
        RpcDeleteMonitor = 47,
        RpcDeletePrintProcessor = 48,
        Opnum49NotUsedOnWire = 49,
        Opnum50NotUsedOnWire = 50,
        RpcEnumPrintProcessorDatatypes = 51,
        RpcResetPrinter = 52,
        RpcGetPrinterDriver2 = 53,
        Opnum54NotUsedOnWire = 54,
        Opnum55NotUsedOnWire = 55,
        RpcFindClosePrinterChangeNotification = 56,
        Opnum57NotUsedOnWire = 57,
        RpcReplyOpenPrinter = 58,
        RpcRouterReplyPrinter = 59,
        RpcReplyClosePrinter = 60,
        RpcAddPortEx = 61,
        RpcRemoteFindFirstPrinterChangeNotification = 62,
        Opnum63NotUsedOnWire = 63,
        Opnum64NotUsedOnWire = 64,
        RpcRemoteFindFirstPrinterChangeNotificationEx = 65,
        RpcRouterReplyPrinterEx = 66,
        RpcRouterRefreshPrinterChangeNotification = 67,
        Opnum68NotUsedOnWire = 68,
        RpcOpenPrinterEx = 69,
        RpcAddPrinterEx = 70,
        RpcSetPort = 71,
        RpcEnumPrinterData = 72,
        RpcDeletePrinterData = 73,
        Opnum74NotUsedOnWire = 74,
        Opnum75NotUsedOnWire = 75,
        Opnum76NotUsedOnWire = 76,
        RpcSetPrinterDataEx = 77,
        RpcGetPrinterDataEx = 78,
        RpcEnumPrinterDataEx = 79,
        RpcEnumPrinterKey = 80,
        RpcDeletePrinterDataEx = 81,
        RpcDeletePrinterKey = 82,
        Opnum83NotUsedOnWire = 83,
        RpcDeletePrinterDriverEx = 84,
        RpcAddPerMachineConnection = 85,
        RpcDeletePerMachineConnection = 86,
        RpcEnumPerMachineConnections = 87,
        RpcXcvData = 88,
        RpcAddPrinterDriverEx = 89,
        Opnum90NotUsedOnWire = 90,
        Opnum91NotUsedOnWire = 91,
        Opnum92NotUsedOnWire = 92,
        Opnum93NotUsedOnWire = 93,
        Opnum94NotUsedOnWire = 94,
        Opnum95NotUsedOnWire = 95,
        RpcFlushPrinter = 96,
        RpcSendRecvBidiData = 97,
        Opnum98NotUsedOnWire = 98,
        Opnum99NotUsedOnWire = 99,
        Opnum100NotUsedOnWire = 100,
        Opnum101NotUsedOnWire = 101,
        RpcGetCorePrinterDrivers = 102,
        Opnum103NotUsedOnWire = 103,
        RpcGetPrinterDriverPackagePath = 104,
        Opnum105NotUsedOnWire = 105,
        Opnum106NotUsedOnWire = 106,
        Opnum107NotUsedOnWire = 107,
        Opnum108NotUsedOnWire = 108,
        Opnum109NotUsedOnWire = 109,
        RpcGetJobNamedPropertyValue = 110,
        RpcSetJobNamedProperty = 111,
        RpcDeleteJobNamedProperty = 112,
        RpcEnumJobNamedProperties = 113,
        Opnum114NotUsedOnWire = 114,
        Opnum115NotUsedOnWire = 115,
        RpcLogJobInfoForBranchOffice = 116
        ...
    };

contract _ExtendedWinSpool
{
    accepts operation EncryptedOperation
    {
        ushort Opnum;
        override string ToString()
        {
            return EnumToString(Opnum, "RPRN._WinSpoolOpnums") +
                "(Encrypted, Opnum " + Opnum.ToString() + ")";
        }
    }
    accepts operation UnknownOperation
    {
        ushort Opnum;
        override string ToString()
        {
            return "Unknown Operation (Opnum " + Opnum.ToString() + ")";
        }
    }
}

contract _ExtendedWinSpoolMessages
{
    accepts message EncryptedRequest
    {
        binary EncryptedData;
        override string ToString()
        {
            return EnumToString(this#RpcOpnum as ushort, "RPRN._WinSpoolOpnums") + " Request(Encrypted)";
        }
    }
    issues message EncryptedResponse
    {
        binary EncryptedData;
        override string ToString()
        {
            return EnumToString(this#RpcOpnum as ushort, "RPRN._WinSpoolOpnums") + " Response(Encrypted)";
        }
    }
    accepts message UnknownRequest
    {
        binary UnknownData;
        override string ToString()
        {
            return "Unknown Request";
        }
    }
    issues message UnknownResponse
    {
        binary UnknownData;
        override string ToString()
        {
            return "Unknown Response";
        }
    }
}

contract _WinSpoolMessages
{
    accepts message _RpcEnumPrintersRequest
    {
        PrinterEnumerationFlags Flags
            with Encoding
                     {Decoder = PatternDecoder<PrinterEnumerationFlags>,
                      SourcePattern = TypeOf<DWORD>()};
        string Name
            with Technologies.IDL.IDL
                     {PointerType = PointerKind.UniquePtr,
                      BaseStringType = TypeOf<STRING_HANDLE>(),
                      String = true};
        PrinterInfoLevel Level
            with Encoding{Decoder = PatternDecoder<PrinterInfoLevel>,
                          SourcePattern = TypeOf<DWORD>()};
        array<BYTE> pPrinterEnum
            with Technologies.IDL.IDL{Size_is = [cbBuf], PointerType = PointerKind.UniquePtr, IndirectionLevel = 1};
        DWORD cbBuf;
    }
    issues message _RpcEnumPrintersResponse[PrinterInfoLevel Level, DWORD cbBuf]
    {
        (array<BYTE> | PrinterInfoPattern) pPrinterEnum
            with Technologies.IDL.IDL{Size_is = [cbBuf], PointerType = PointerKind.UniquePtr, IndirectionLevel = 1};
        DWORD pcbNeeded
            with Technologies.IDL.IDL{IndirectionLevel = 1};
        DWORD pcReturned
            with Encoding{Decoder = PrinterInfoDecoder, SourcePattern = TypeOf<DWORD>()}
            with Technologies.IDL.IDL{IndirectionLevel = 1};
        DWORD ReturnValue;

        optional DWORD PrinterInfoDecoder(DWORD pcRet)
        {
            if (pPrinterEnum is arrayByte:array<byte> && arrayByte.Count > 0)
            {
                binary binData = arrayByte as binary;
                InfoStructLevel infoStructureLevel;
                switch (Level)
                {
                    case 0 => infoStructureLevel = InfoStructLevel._PRINTER_INFO_STRESS;
                    case 1 => infoStructureLevel = InfoStructLevel._PRINTER_INFO_1;
                    case 2 => infoStructureLevel = InfoStructLevel._PRINTER_INFO_2;
                    case 3 => infoStructureLevel = InfoStructLevel._PRINTER_INFO_3;
                    case 4 => infoStructureLevel = InfoStructLevel._PRINTER_INFO_4;
                    case 5 => infoStructureLevel = InfoStructLevel._PRINTER_INFO_5;
                    case 6 => infoStructureLevel = InfoStructLevel._PRINTER_INFO_6;
                    case 7 => infoStructureLevel = InfoStructLevel._PRINTER_INFO_7;
                    case 8 => infoStructureLevel = InfoStructLevel._PRINTER_INFO_8;
                    default => infoStructureLevel = InfoStructLevel.UndefinedLevel;
                }
                var result = CustomInfoStrucutureDecoder<PrinterInfoPattern>(binData as stream, infoStructureLevel, pcRet);
                if (result != nothing)
                {
                    switch (Level)
                    {
                        case 0 => pPrinterEnum = result as _PRINTER_INFO_STRESS;
                        case 1 => pPrinterEnum = result as _PRINTER_INFO_1;
                        case 2 => pPrinterEnum = result as _PRINTER_INFO_2;
                        case 3 => pPrinterEnum = result as _PRINTER_INFO_3;
                        case 4 => pPrinterEnum = result as _PRINTER_INFO_4;
                        case 5 => pPrinterEnum = result as _PRINTER_INFO_5;
                        case 6 => pPrinterEnum = result as _PRINTER_INFO_6;
                        case 7 => pPrinterEnum = result as _PRINTER_INFO_7;
                        case 8 => pPrinterEnum = result as _PRINTER_INFO_8;
                    }
                }
            }
            return pcRet;
        }
    }
    accepts message _RpcOpenPrinterRequest
    {
        string pPrinterName
            with Technologies.IDL.IDL
                     {PointerType = PointerKind.UniquePtr,
                      BaseStringType = TypeOf<STRING_HANDLE>(),
                      String = true};
        string pDatatype
            with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                      BaseStringType = TypeOf<wchar_t>(),
                                      String = true,
                                      IndirectionLevel = 1};
        DEVMODE_CONTAINER pDevModeContainer
            with Technologies.IDL.IDL{IndirectionLevel = 1};
        AccessValuesFlags AccessRequired
            where ValidationCheckCombinationValueTooManyItems(InRange<AccessValuesFlags>(value), this, true, ReferenceType.Message,
                "RPRN", "AccessRequired", "RpcOpenPrinter", "Access Values", "[MS-RPRN]")
            with Encoding{Decoder = PatternDecoder<AccessMaskFlags>,
                          SourcePattern = TypeOf<DWORD>()};
    }
    issues message _RpcOpenPrinterResponse
    {
        PRINTER_HANDLE pHandle
            with Technologies.IDL.IDL{IndirectionLevel = 1};
        DWORD ReturnValue;
    }
    accepts message _RpcSetJobRequest
    {
        PRINTER_HANDLE hPrinter;
        DWORD JobId where ValidationCheckValue(value != 0, null, true, ReferenceType.Type, "RPRN",
                                               "JobId", "RpcSetJob", "not 0", value);
        JOB_CONTAINER pJobContainer
            with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                      IndirectionLevel = 1};
        JobControlCommand Command
            where ValidationCheckEnumValue(InRange<JobControlCommand>(value), null, true, ReferenceType.Type, "RPRN",
                                           "Command", "RpcSetJob", "in [0, 9]", value);
    }
    issues message _RpcSetJobResponse
    {
        DWORD ReturnValue;
    }
    accepts message _RpcGetJobRequest
    {
        PRINTER_HANDLE hPrinter;
        DWORD JobId where ValidationCheckValue(value != 0, null, true, ReferenceType.Type, "RPRN",
                                               "JobId", "RpcGetJob", "not 0", value);
        JobInfoLevel Level
            where ValidationCheckValue(value in [1, 2, 3, 4], null, true, ReferenceType.Type, "RPRN",
                                       "Level", "RpcGetJob", "1, 2, 3, 4", value)
            with Encoding{Decoder = PatternDecoder<JobInfoLevel>,
                          SourcePattern = TypeOf<DWORD>()};
        array<BYTE> pJob
            with Technologies.IDL.IDL{Size_is = [cbBuf],
                                      PointerType = PointerKind.UniquePtr,
                                      IndirectionLevel = 1};
        DWORD cbBuf;
    }
    issues message _RpcGetJobResponse[JobInfoLevel Level, DWORD cbBuf]
    {
        (array<BYTE> | JobInfoPattern) pJob
            with Technologies.IDL.IDL{Size_is = [cbBuf], PointerType = PointerKind.UniquePtr,
                                      IndirectionLevel = 1};
        DWORD pcbNeeded
            with Encoding{Decoder = JobInfoDecoder, SourcePattern = TypeOf<DWORD>()}
            with Technologies.IDL.IDL{IndirectionLevel = 1};
        DWORD ReturnValue;

        optional DWORD JobInfoDecoder(DWORD needed)
        {
            if (pJob is arrayByte:array<byte> && arrayByte.Count > 0)
            {
                binary binData = arrayByte as binary;
                InfoStructLevel infoStructureLevel;
                switch (Level)
                {
                    case 1 => infoStructureLevel = InfoStructLevel._JOB_INFO_1;
                    case 2 => infoStructureLevel = InfoStructLevel._JOB_INFO_2;
                    case 3 => infoStructureLevel = InfoStructLevel._JOB_INFO_3;
                    case 4 => infoStructureLevel = InfoStructLevel._JOB_INFO_4;
                    default => infoStructureLevel = InfoStructLevel.UndefinedLevel;
                }
                var result = CustomInfoStrucutureDecoder<JobInfoPattern>(binData as stream, infoStructureLevel, 1);
                if (result != nothing)
                {
                    switch (Level)
                    {
                        case 1 => pJob = result as _JOB_INFO_1;
                        case 2 => pJob = result as _JOB_INFO_2;
                        case 3 => pJob = result as _JOB_INFO_3;
                        case 4 => pJob = result as _JOB_INFO_4;
                    }
                }
            }
            return needed;
        }
    }
    accepts message _RpcEnumJobsRequest
    {
        PRINTER_HANDLE hPrinter;
        DWORD FirstJob;
        DWORD NoJobs;
        JobInfoLevel Level
            where ValidationCheckValue(value in [1, 2, 3, 4], null, true, ReferenceType.Type, "RPRN",
                                       "Level", "RpcGetJob", "1, 2, 3, 4", value)
            with Encoding{Decoder = PatternDecoder<JobInfoLevel>,
                          SourcePattern = TypeOf<DWORD>()};
        array<BYTE> pJob
            with Technologies.IDL.IDL{Size_is = [cbBuf],
                                      PointerType = PointerKind.UniquePtr,
                                      IndirectionLevel = 1};
        DWORD cbBuf;
    }
    issues message _RpcEnumJobsResponse[JobInfoLevel Level, DWORD cbBuf]
    {
        (array<BYTE> | JobInfoPattern) pJob
            with Technologies.IDL.IDL{Size_is = [cbBuf], PointerType = PointerKind.UniquePtr,
                                      IndirectionLevel = 1};
        DWORD pcbNeeded
            with Technologies.IDL.IDL{IndirectionLevel = 1};
        DWORD pcReturned
            with Encoding{Decoder = JobInfoDecoder, SourcePattern = TypeOf<DWORD>()}
            with Technologies.IDL.IDL{IndirectionLevel = 1};
        DWORD ReturnValue;

        optional DWORD JobInfoDecoder(DWORD pcRet)
        {
            if (pJob is arrayByte:array<byte> && arrayByte.Count > 0)
            {
                binary binData = arrayByte as binary;
                InfoStructLevel infoStructureLevel;
                switch (Level)
                {
                    case 1 => infoStructureLevel = InfoStructLevel._JOB_INFO_1;
                    case 2 => infoStructureLevel = InfoStructLevel._JOB_INFO_2;
                    case 3 => infoStructureLevel = InfoStructLevel._JOB_INFO_3;
                    case 4 => infoStructureLevel = InfoStructLevel._JOB_INFO_4;
                    default => infoStructureLevel = InfoStructLevel.UndefinedLevel;
                }
                var result = CustomInfoStrucutureDecoder<JobInfoPattern>(binData as stream, infoStructureLevel, pcRet);
                if (result != nothing)
                {
                    switch (Level)
                    {
                        case 1 => pJob = result as _JOB_INFO_1;
                        case 2 => pJob = result as _JOB_INFO_2;
                        case 3 => pJob = result as _JOB_INFO_3;
                        case 4 => pJob = result as _JOB_INFO_4;
                    }
                }
            }
            return pcRet;
        }
    }
    accepts message _RpcAddPrinterRequest
    {
        string pName
            with Technologies.IDL.IDL
                     {PointerType = PointerKind.UniquePtr,
                      BaseStringType = TypeOf<STRING_HANDLE>(),
                      String = true};
        PRINTER_CONTAINER pPrinterContainer
            with Technologies.IDL.IDL{IndirectionLevel = 1};
        DEVMODE_CONTAINER pDevModeContainer
            with Technologies.IDL.IDL{IndirectionLevel = 1};
        SECURITY_CONTAINER pSecurityContainer
            with Technologies.IDL.IDL{IndirectionLevel = 1};
    }
    issues message _RpcAddPrinterResponse
    {
        PRINTER_HANDLE pHandle
            with Technologies.IDL.IDL{IndirectionLevel = 1};
        DWORD ReturnValue;
    }
    accepts message _RpcDeletePrinterRequest
    {
        PRINTER_HANDLE hPrinter;
    }
    issues message _RpcDeletePrinterResponse
    {
        DWORD ReturnValue;
    }
    accepts message _RpcSetPrinterRequest
    {
        PRINTER_HANDLE hPrinter;
        PRINTER_CONTAINER pPrinterContainer
            with Technologies.IDL.IDL{IndirectionLevel = 1};
        DEVMODE_CONTAINER pDevModeContainer
            with Technologies.IDL.IDL{IndirectionLevel = 1};
        SECURITY_CONTAINER pSecurityContainer
            with Technologies.IDL.IDL{IndirectionLevel = 1};
        PrinterControlCommand Command
            with Encoding{Decoder = PatternDecoder<PrinterControlCommand>,
                          SourcePattern = TypeOf<DWORD>()};
    }
    issues message _RpcSetPrinterResponse
    {
        DWORD ReturnValue;
    }
    accepts message _RpcGetPrinterRequest
    {
        PRINTER_HANDLE hPrinter;
        PrinterInfoLevel Level
            with Encoding{Decoder = PatternDecoder<PrinterInfoLevel>,
                          SourcePattern = TypeOf<DWORD>()};
        array<BYTE> pPrinter
            with Technologies.IDL.IDL{Size_is = [cbBuf],
                                      PointerType = PointerKind.UniquePtr,
                                      IndirectionLevel = 1};
        DWORD cbBuf;
    }
    issues message _RpcGetPrinterResponse[PrinterInfoLevel Level, DWORD cbBuf]
    {
        (array<BYTE> | PrinterInfoPattern) pPrinter
            with Technologies.IDL.IDL{Size_is = [cbBuf],
                                      PointerType = PointerKind.UniquePtr,
                                      IndirectionLevel = 1};
        DWORD pcbNeeded
            with Encoding{Decoder = PrinterInfoDecoder, SourcePattern = TypeOf<DWORD>()}
            with Technologies.IDL.IDL{IndirectionLevel = 1};
        DWORD ReturnValue;

        optional DWORD PrinterInfoDecoder(DWORD needed)
        {
            if (pPrinter is arrayByte:array<byte> && arrayByte.Count > 0)
            {
                binary binData = arrayByte as binary;
                InfoStructLevel infoStructureLevel;
                switch (Level)
                {
                    case 0 => infoStructureLevel = InfoStructLevel._PRINTER_INFO_STRESS;
                    case 1 => infoStructureLevel = InfoStructLevel._PRINTER_INFO_1;
                    case 2 => infoStructureLevel = InfoStructLevel._PRINTER_INFO_2;
                    case 3 => infoStructureLevel = InfoStructLevel._PRINTER_INFO_3;
                    case 4 => infoStructureLevel = InfoStructLevel._PRINTER_INFO_4;
                    case 5 => infoStructureLevel = InfoStructLevel._PRINTER_INFO_5;
                    case 6 => infoStructureLevel = InfoStructLevel._PRINTER_INFO_6;
                    case 7 => infoStructureLevel = InfoStructLevel._PRINTER_INFO_7;
                    case 8 => infoStructureLevel = InfoStructLevel._PRINTER_INFO_8;
                    default => infoStructureLevel = InfoStructLevel.UndefinedLevel;
                }
                var result = CustomInfoStrucutureDecoder<PrinterInfoPattern>(binData as stream, infoStructureLevel, 1);
                if (result != nothing)
                {
                    switch (Level)
                    {
                        case 0 => pPrinter = result as _PRINTER_INFO_STRESS;
                        case 1 => pPrinter = result as _PRINTER_INFO_1;
                        case 2 => pPrinter = result as _PRINTER_INFO_2;
                        case 3 => pPrinter = result as _PRINTER_INFO_3;
                        case 4 => pPrinter = result as _PRINTER_INFO_4;
                        case 5 => pPrinter = result as _PRINTER_INFO_5;
                        case 6 => pPrinter = result as _PRINTER_INFO_6;
                        case 7 => pPrinter = result as _PRINTER_INFO_7;
                        case 8 => pPrinter = result as _PRINTER_INFO_8;
                    }
                }
            }
            return needed;
        }
    }
    accepts message _RpcAddPrinterDriverRequest
    {
        string pName
            with Technologies.IDL.IDL
                     {PointerType = PointerKind.UniquePtr,
                      BaseStringType = TypeOf<STRING_HANDLE>(),
                      String = true};
        DRIVER_CONTAINER pDriverContainer
            with Technologies.IDL.IDL{IndirectionLevel = 1};
    }
    issues message _RpcAddPrinterDriverResponse
    {
        DWORD ReturnValue;
    }
    accepts message _RpcEnumPrinterDriversRequest
    {
        string pName
            with Technologies.IDL.IDL
                     {PointerType = PointerKind.UniquePtr,
                      BaseStringType = TypeOf<STRING_HANDLE>(),
                      String = true};
        string pEnvironment
            with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                      BaseStringType = TypeOf<wchar_t>(),
                                      String = true,
                                      IndirectionLevel = 1};
        DriverInfoLevel Level
            with Encoding{Decoder = PatternDecoder<DriverInfoLevel>,
                          SourcePattern = TypeOf<DWORD>()};
        array<BYTE> pDrivers
            with Technologies.IDL.IDL{Size_is = [cbBuf],PointerType = PointerKind.UniquePtr,
                                      IndirectionLevel = 1};
        DWORD cbBuf;
    }
    issues message _RpcEnumPrinterDriversResponse[DriverInfoLevel Level, DWORD cbBuf]
    {
        (array<BYTE> | DriverInfoPattern) pDrivers
            with Technologies.IDL.IDL{Size_is = [cbBuf], PointerType = PointerKind.UniquePtr,
                                      IndirectionLevel = 1};
        DWORD pcbNeeded
            with Technologies.IDL.IDL{IndirectionLevel = 1};
        DWORD pcReturned
            with Encoding{Decoder = DriverInfoDecoder, SourcePattern = TypeOf<DWORD>()}
            with Technologies.IDL.IDL{IndirectionLevel = 1};
        DWORD ReturnValue;

        optional DWORD DriverInfoDecoder(DWORD pcRet)
        {
            if (pDrivers is arrayByte:array<byte> && arrayByte.Count > 0)
            {
                binary binData = arrayByte as binary;
                InfoStructLevel infoStructureLevel;
                switch (Level)
                {
                    case 1 => infoStructureLevel = InfoStructLevel._DRIVER_INFO_1;
                    case 2 => infoStructureLevel = InfoStructLevel._DRIVER_INFO_2;
                    case 3 => infoStructureLevel = InfoStructLevel._DRIVER_INFO_3;
                    case 4 => infoStructureLevel = InfoStructLevel._DRIVER_INFO_4;
                    case 5 => infoStructureLevel = InfoStructLevel._DRIVER_INFO_5;
                    case 6 => infoStructureLevel = InfoStructLevel._DRIVER_INFO_6;
                    case 8 => infoStructureLevel = InfoStructLevel._DRIVER_INFO_8;
                    case 9 => infoStructureLevel = InfoStructLevel._DRIVER_INFO_101;
                    default => infoStructureLevel = InfoStructLevel.UndefinedLevel;
                }
                var result = CustomInfoStrucutureDecoder<DriverInfoPattern>(binData as stream, infoStructureLevel, pcRet);
                if (result != nothing)
                {
                    switch (Level)
                    {
                        case 1 => pDrivers = result as _DRIVER_INFO_1;
                        case 2 => pDrivers = result as _DRIVER_INFO_2;
                        case 3 => pDrivers = result as _DRIVER_INFO_3;
                        case 4 => pDrivers = result as _DRIVER_INFO_4;
                        case 5 => pDrivers = result as _DRIVER_INFO_5;
                        case 6 => pDrivers = result as _DRIVER_INFO_6;
                        case 8 => pDrivers = result as _DRIVER_INFO_8;
                        case 9 => pDrivers = result as _DRIVER_INFO_101;
                    }
                }
            }
            return pcRet;
        }
    }
    accepts message _RpcGetPrinterDriverRequest
    {
        PRINTER_HANDLE hPrinter;
        string pEnvironment
            with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                      BaseStringType = TypeOf<wchar_t>(),
                                      String = true,
                                      IndirectionLevel = 1};
        DriverInfoLevel Level
            with Encoding{Decoder = PatternDecoder<DriverInfoLevel>,
                          SourcePattern = TypeOf<DWORD>()};
        array<BYTE> pDriver
            with Technologies.IDL.IDL{Size_is = [cbBuf],
                                      PointerType = PointerKind.UniquePtr,
                                      IndirectionLevel = 1};
        DWORD cbBuf;
    }
    issues message _RpcGetPrinterDriverResponse[DriverInfoLevel Level, DWORD cbBuf]
    {
        (array<BYTE> | DriverInfoPattern) pDriver
            with Technologies.IDL.IDL{Size_is = [cbBuf],
                                      PointerType = PointerKind.UniquePtr,
                                      IndirectionLevel = 1};
        DWORD pcbNeeded
            with Encoding{Decoder = DriverInfoDecoder, SourcePattern = TypeOf<DWORD>()}
            with Technologies.IDL.IDL{IndirectionLevel = 1};
        DWORD ReturnValue;

        optional DWORD DriverInfoDecoder(DWORD needed)
        {
            if (pDriver is arrayByte:array<byte> && arrayByte.Count > 0)
            {
                binary binData = arrayByte as binary;
                InfoStructLevel infoStructureLevel;
                switch (Level)
                {
                    case 1 => infoStructureLevel = InfoStructLevel._DRIVER_INFO_1;
                    case 2 => infoStructureLevel = InfoStructLevel._DRIVER_INFO_2;
                    case 3 => infoStructureLevel = InfoStructLevel._DRIVER_INFO_3;
                    case 4 => infoStructureLevel = InfoStructLevel._DRIVER_INFO_4;
                    case 5 => infoStructureLevel = InfoStructLevel._DRIVER_INFO_5;
                    case 6 => infoStructureLevel = InfoStructLevel._DRIVER_INFO_6;
                    case 8 => infoStructureLevel = InfoStructLevel._DRIVER_INFO_8;
                    case 9 => infoStructureLevel = InfoStructLevel._DRIVER_INFO_101;
                    default => infoStructureLevel = InfoStructLevel.UndefinedLevel;
                }
                var result = CustomInfoStrucutureDecoder<DriverInfoPattern>(binData as stream, infoStructureLevel, 1);
                if (result != nothing)
                {
                    switch (Level)
                    {
                        case 1 => pDriver = result as _DRIVER_INFO_1;
                        case 2 => pDriver = result as _DRIVER_INFO_2;
                        case 3 => pDriver = result as _DRIVER_INFO_3;
                        case 4 => pDriver = result as _DRIVER_INFO_4;
                        case 5 => pDriver = result as _DRIVER_INFO_5;
                        case 6 => pDriver = result as _DRIVER_INFO_6;
                        case 8 => pDriver = result as _DRIVER_INFO_8;
                        case 9 => pDriver = result as _DRIVER_INFO_101;
                    }
                }
            }
            return needed;
        }
    }
    accepts message _RpcGetPrinterDriverDirectoryRequest
    {
        string pName
            with Technologies.IDL.IDL
                     {PointerType = PointerKind.UniquePtr,
                      BaseStringType = TypeOf<STRING_HANDLE>(),
                      String = true};
        string pEnvironment
            with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                      BaseStringType = TypeOf<wchar_t>(),
                                      String = true,
                                      IndirectionLevel = 1};
        DWORD Level
            where ValidationCheckValue(value == 1, null, true, ReferenceType.Type, "RPRN",
                                       "Level", "RpcGetPrinterDriverDirectory", "1", value);
        array<BYTE> pDriverDirectory
            with Technologies.IDL.IDL{Size_is = [cbBuf],
                                      PointerType = PointerKind.UniquePtr,
                                      IndirectionLevel = 1};
        DWORD cbBuf;
    }
    issues message _RpcGetPrinterDriverDirectoryResponse[DWORD cbBuf]
    {
        (array<BYTE> | array<string>) pDriverDirectory
            with Technologies.IDL.IDL{Size_is = [cbBuf],
                                      PointerType = PointerKind.UniquePtr,
                                      IndirectionLevel = 1};
        DWORD pcbNeeded
            with Encoding{Decoder = DriverDirectoryDecoder, SourcePattern = TypeOf<DWORD>()}
            with Technologies.IDL.IDL{IndirectionLevel = 1};
        DWORD ReturnValue;

        optional DWORD DriverDirectoryDecoder(DWORD needed)
        {
            if (pDriverDirectory is arrayByte:array<byte> && arrayByte.Count > 0)
            {
                binary binData = arrayByte as binary;
                var result = StringQueryDecoder(binData as stream);
                if (result is arr:array<string>)
                    pDriverDirectory = arr;
            }
            return needed;
        }
    }
    accepts message _RpcDeletePrinterDriverRequest
    {
        string pName
            with Technologies.IDL.IDL
                     {PointerType = PointerKind.UniquePtr,
                      BaseStringType = TypeOf<STRING_HANDLE>(),
                      String = true};
        string pEnvironment
            with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                      String = true,
                                      IndirectionLevel = 1};
        string pDriverName
            with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                      String = true,
                                      IndirectionLevel = 1};
    }
    issues message _RpcDeletePrinterDriverResponse
    {
        DWORD ReturnValue;
    }
    accepts message _RpcAddPrintProcessorRequest
    {
        string pName
            with Technologies.IDL.IDL
                     {PointerType = PointerKind.UniquePtr,
                      BaseStringType = TypeOf<STRING_HANDLE>(),
                      String = true};
        string pEnvironment
            with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                      String = true,
                                      IndirectionLevel = 1};
        string pPathName
            with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                      String = true,
                                      IndirectionLevel = 1};
        string pPrintProcessorName
            with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                      String = true,
                                      IndirectionLevel = 1};
    }
    issues message _RpcAddPrintProcessorResponse
    {
        DWORD ReturnValue;
    }
    accepts message _RpcEnumPrintProcessorsRequest
    {
        string pName
            with Technologies.IDL.IDL
                     {PointerType = PointerKind.UniquePtr,
                      BaseStringType = TypeOf<STRING_HANDLE>(),
                      String = true};
        string pEnvironment
            with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                      BaseStringType = TypeOf<wchar_t>(),
                                      String = true,
                                      IndirectionLevel = 1};
        DWORD Level
            where ValidationCheckValue(value == 1, null, true, ReferenceType.Type, "RPRN",
                                       "Level", "RpcEnumPrintProcessors", "1", value);
        array<BYTE> pPrintProcessorInfo
            with Technologies.IDL.IDL{Size_is = [cbBuf],
                                      PointerType = PointerKind.UniquePtr,
                                      IndirectionLevel = 1};
        DWORD cbBuf;
    }
    issues message _RpcEnumPrintProcessorsResponse[DWORD cbBuf]
    {
        (array<BYTE> | PRINTPROCESSOR_INFO_1) pPrintProcessorInfo
            with Technologies.IDL.IDL{Size_is = [cbBuf],
                                      PointerType = PointerKind.UniquePtr,
                                      IndirectionLevel = 1};
        DWORD pcbNeeded
            with Technologies.IDL.IDL{IndirectionLevel = 1};
        DWORD pcReturned
            with Encoding{Decoder = PrintProcessorInfo1Decoder, SourcePattern = TypeOf<DWORD>()}
            with Technologies.IDL.IDL{IndirectionLevel = 1};
        DWORD ReturnValue;

        optional DWORD PrintProcessorInfo1Decoder(DWORD pcRet)
        {
            if (pPrintProcessorInfo is arrayByte:array<byte> && arrayByte.Count > 0)
            {
                binary binData = arrayByte as binary;
                var result = CustomInfoStrucutureDecoder<PRINTPROCESSOR_INFO_1>(binData as stream, 
                                                                                InfoStructLevel.PRINTPROCESSOR_INFO_1, 
                                                                                pcRet);
                if (result != nothing)
                    pPrintProcessorInfo = result as PRINTPROCESSOR_INFO_1;
            }
            return pcRet;
        }
    }
    accepts message _RpcGetPrintProcessorDirectoryRequest
    {
        string pName
            with Technologies.IDL.IDL
                     {PointerType = PointerKind.UniquePtr,
                      BaseStringType = TypeOf<STRING_HANDLE>(),
                      String = true};
        string pEnvironment
            with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                      BaseStringType = TypeOf<wchar_t>(),
                                      String = true,
                                      IndirectionLevel = 1};
        DWORD Level
            where ValidationCheckValue(value == 1, null, true, ReferenceType.Type, "RPRN",
                                       "Level", "RpcGetPrintProcessorDirectory", "1", value);
        array<BYTE> pPrintProcessorDirectory
            with Technologies.IDL.IDL{Size_is = [cbBuf],
                                      PointerType = PointerKind.UniquePtr,
                                      IndirectionLevel = 1};
        DWORD cbBuf;
    }
    issues message _RpcGetPrintProcessorDirectoryResponse[DWORD cbBuf]
    {
        (array<BYTE> | array<string>) pPrintProcessorDirectory
            with Technologies.IDL.IDL{Size_is = [cbBuf],
                                      PointerType = PointerKind.UniquePtr,
                                      IndirectionLevel = 1};
        DWORD pcbNeeded
            with Encoding{Decoder = DriverDirectoryDecoder, SourcePattern = TypeOf<DWORD>()}
            with Technologies.IDL.IDL{IndirectionLevel = 1};
        DWORD ReturnValue;

        optional DWORD DriverDirectoryDecoder(DWORD needed)
        {
            if (pPrintProcessorDirectory is arrayByte:array<byte> && arrayByte.Count > 0)
            {
                binary binData = arrayByte as binary;
                InfoStructLevel infoStructureLevel;
                var result = StringQueryDecoder(binData as stream);
                if (result is arr:array<string>)
                    pPrintProcessorDirectory = arr;
            }
            return needed;
        }
    }
    accepts message _RpcStartDocPrinterRequest
    {
        PRINTER_HANDLE hPrinter;
        DOC_INFO_CONTAINER pDocInfoContainer
            with Technologies.IDL.IDL{IndirectionLevel = 1};
    }
    issues message _RpcStartDocPrinterResponse
    {
        DWORD pJobId with Technologies.IDL.IDL{IndirectionLevel = 1};
        DWORD ReturnValue;
    }
    accepts message _RpcStartPagePrinterRequest
    {
        PRINTER_HANDLE hPrinter;
    }
    issues message _RpcStartPagePrinterResponse
    {
        DWORD ReturnValue;
    }
    accepts message _RpcWritePrinterRequest
    {
        PRINTER_HANDLE hPrinter;
        array<BYTE> pBuf
            with Technologies.IDL.IDL
                     {Size_is = [cbBuf], IndirectionLevel = 1};
        DWORD cbBuf;
    }
    issues message _RpcWritePrinterResponse
    {
        DWORD pcWritten
            with Technologies.IDL.IDL{IndirectionLevel = 1};
        DWORD ReturnValue;
    }
    accepts message _RpcEndPagePrinterRequest
    {
        PRINTER_HANDLE hPrinter;
    }
    issues message _RpcEndPagePrinterResponse
    {
        DWORD ReturnValue;
    }
    accepts message _RpcAbortPrinterRequest
    {
        PRINTER_HANDLE hPrinter;
    }
    issues message _RpcAbortPrinterResponse
    {
        DWORD ReturnValue;
    }
    accepts message _RpcReadPrinterRequest
    {
        PRINTER_HANDLE hPrinter;
        DWORD cbBuf;
    }
    issues message _RpcReadPrinterResponse[DWORD cbBuf]
    {
        array<BYTE> pBuf
            with Technologies.IDL.IDL
                     {Size_is = [cbBuf], IndirectionLevel = 1};
        DWORD pcNoBytesRead
            with Technologies.IDL.IDL{IndirectionLevel = 1};
        DWORD ReturnValue;
    }
    accepts message _RpcEndDocPrinterRequest
    {
        PRINTER_HANDLE hPrinter;
    }
    issues message _RpcEndDocPrinterResponse
    {
        DWORD ReturnValue;
    }
    accepts message _RpcAddJobRequest
    {
        PRINTER_HANDLE hPrinter;
        DWORD Level where ValidationCheckValue(value in [1, 2, 3], null, true, ReferenceType.Type, "RPRN",
                                               "Level", "RpcAddJob", "1, 2, 3", value);
        array<BYTE> pAddJob
            with Technologies.IDL.IDL{Size_is = [cbBuf],
                                      PointerType = PointerKind.UniquePtr,
                                      IndirectionLevel = 1};
        DWORD cbBuf;
    }
    issues message _RpcAddJobResponse[DWORD cbBuf]
    {
        array<BYTE> pAddJob
            with Technologies.IDL.IDL{Size_is = [cbBuf],
                                      PointerType = PointerKind.UniquePtr,
                                      IndirectionLevel = 1};
        DWORD pcbNeeded
            with Technologies.IDL.IDL{IndirectionLevel = 1};
        DWORD ReturnValue;
    }
    accepts message _RpcScheduleJobRequest
    {
        PRINTER_HANDLE hPrinter;
        DWORD JobId;
    }
    issues message _RpcScheduleJobResponse
    {
        DWORD ReturnValue;
    }
    accepts message _RpcGetPrinterDataRequest
    {
        PRINTER_HANDLE hPrinter;
        string pValueName
            with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                      String = true,
                                      IndirectionLevel = 1};
        DWORD nSize;
    }
    issues message _RpcGetPrinterDataResponse
    {
        RegistryTypeValues pType;
        DynamicallyTypedQuery[pType] pData
            with Technologies.IDL.IDL{IndirectionLevel = 1};
        DWORD pcbNeeded
            with Technologies.IDL.IDL{IndirectionLevel = 1};
        DWORD ReturnValue;
    }
    accepts message _RpcSetPrinterDataRequest
    {
        PRINTER_HANDLE hPrinter;
        string pValueName
            with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                      String = true,
                                      IndirectionLevel = 1};
        RegistryTypeValues Type;
        DynamicallyTypedQuery[Type] pData
            with Technologies.IDL.IDL{IndirectionLevel = 1};
        DWORD cbData;
    }
    issues message _RpcSetPrinterDataResponse
    {
        DWORD ReturnValue;
    }
    accepts message _RpcWaitForPrinterChangeRequest
    {
        PRINTER_HANDLE hPrinter;
        PrinterChangeFlags Flags
            with Encoding{Decoder = PatternDecoder<PrinterChangeFlags>,
                          SourcePattern = TypeOf<DWORD>()};
    }
    issues message _RpcWaitForPrinterChangeResponse
    {
        PrinterChangeFlags pFlags
            with Technologies.IDL.IDL{IndirectionLevel = 1},
                 Encoding{Decoder = PatternDecoder<PrinterChangeFlags>,
                          SourcePattern = TypeOf<DWORD>()};
        DWORD ReturnValue;
    }
    accepts message _RpcClosePrinterRequest
    {
        PRINTER_HANDLE phPrinter
            with Technologies.IDL.IDL{IndirectionLevel = 1};
    }
    issues message _RpcClosePrinterResponse
    {
        PRINTER_HANDLE phPrinter
            with Technologies.IDL.IDL{IndirectionLevel = 1};
        DWORD ReturnValue;
    }
    accepts message _RpcAddFormRequest
    {
        PRINTER_HANDLE hPrinter;
        FORM_CONTAINER pFormInfoContainer
            with Technologies.IDL.IDL{IndirectionLevel = 1};
    }
    issues message _RpcAddFormResponse
    {
        DWORD ReturnValue;
    }
    accepts message _RpcDeleteFormRequest
    {
        PRINTER_HANDLE hPrinter;
        string pFormName
            with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                      String = true,
                                      IndirectionLevel = 1};
    }
    issues message _RpcDeleteFormResponse
    {
        DWORD ReturnValue;
    }
    accepts message _RpcGetFormRequest
    {
        PRINTER_HANDLE hPrinter;
        string pFormName
            with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                      String = true,
                                      IndirectionLevel = 1};
        FormInfoLevel Level
            with Encoding{Decoder = PatternDecoder<FormInfoLevel>,
                          SourcePattern = TypeOf<DWORD>()};
        array<BYTE> pForm
            with Technologies.IDL.IDL{Size_is = [cbBuf],
                                      PointerType = PointerKind.UniquePtr,
                                      IndirectionLevel = 1};
        DWORD cbBuf;
    }
    issues message _RpcGetFormResponse[FormInfoLevel Level, DWORD cbBuf]
    {
        (array<BYTE> | FormInfoPattern) pForm
            with Technologies.IDL.IDL{Size_is = [cbBuf],
                                      PointerType = PointerKind.UniquePtr,
                                      IndirectionLevel = 1};
        DWORD pcbNeeded
            with Encoding{Decoder = FormInfoDecoder, SourcePattern = TypeOf<DWORD>()}
            with Technologies.IDL.IDL{IndirectionLevel = 1};
        DWORD ReturnValue;

        optional DWORD FormInfoDecoder(DWORD needed)
        {
            if (pForm is arrayByte:array<byte> && arrayByte.Count > 0)
            {
                binary binData = arrayByte as binary;
                InfoStructLevel infoStructureLevel;
                switch (Level)
                {
                    case 1 => infoStructureLevel = InfoStructLevel._FORM_INFO_1;
                    case 2 => infoStructureLevel = InfoStructLevel._FORM_INFO_2;
                    default => infoStructureLevel = InfoStructLevel.UndefinedLevel;
                }
                var result = CustomInfoStrucutureDecoder<FormInfoPattern>(binData as stream, infoStructureLevel, 1);
                if (result != nothing)
                {
                    switch (Level)
                    {
                        case 1 => pForm = result as _FORM_INFO_1;
                        case 2 => pForm = result as _FORM_INFO_2;
                    }
                }
            }
            return needed;
        }
    }
    accepts message _RpcSetFormRequest
    {
        PRINTER_HANDLE hPrinter;
        string pFormName
            with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                      String = true,
                                      IndirectionLevel = 1};
        FORM_CONTAINER pFormInfoContainer
            with Technologies.IDL.IDL{IndirectionLevel = 1};
    }
    issues message _RpcSetFormResponse
    {
        DWORD ReturnValue;
    }
    accepts message _RpcEnumFormsRequest
    {
        PRINTER_HANDLE hPrinter;
        FormInfoLevel Level
            with Encoding{Decoder = PatternDecoder<FormInfoLevel>,
                          SourcePattern = TypeOf<DWORD>()};
        array<BYTE> pForm
            with Technologies.IDL.IDL{Size_is = [cbBuf],
                                      PointerType = PointerKind.UniquePtr,
                                      IndirectionLevel = 1};
        DWORD cbBuf;
    }
    issues message _RpcEnumFormsResponse[FormInfoLevel Level, DWORD cbBuf]
    {
        (array<BYTE> | FormInfoPattern) pForm
            with Technologies.IDL.IDL{Size_is = [cbBuf],
                                      PointerType = PointerKind.UniquePtr,
                                      IndirectionLevel = 1};
        DWORD pcbNeeded
            with Technologies.IDL.IDL{IndirectionLevel = 1};
        DWORD pcReturned
            with Encoding{Decoder = FormInfoDecoder, SourcePattern = TypeOf<DWORD>()}
            with Technologies.IDL.IDL{IndirectionLevel = 1};
        DWORD ReturnValue;

        optional DWORD FormInfoDecoder(DWORD pcReturn)
        {
            if (pcReturn > 0 && pForm is arrayByte:array<byte> && arrayByte.Count > 0)
            {
                binary binData = arrayByte as binary;
                InfoStructLevel infoStructureLevel;
                switch (Level)
                {
                    case 1 => infoStructureLevel = InfoStructLevel._FORM_INFO_1;
                    case 2 => infoStructureLevel = InfoStructLevel._FORM_INFO_2;
                    default => infoStructureLevel = InfoStructLevel.UndefinedLevel;
                }
                var result = CustomInfoStrucutureDecoder<FormInfoPattern>(binData as stream, infoStructureLevel, pcReturn);
                if (result != nothing)
                {
                    switch (Level)
                    {
                        case 1 => pForm = result as _FORM_INFO_1;
                        case 2 => pForm = result as _FORM_INFO_2;
                    }
                }
            }
            return pcReturn;
        }
    }
    accepts message _RpcEnumPortsRequest
    {
        string pName
            with Technologies.IDL.IDL
                     {PointerType = PointerKind.UniquePtr,
                      BaseStringType = TypeOf<STRING_HANDLE>(),
                      String = true};
        PortInfoLevel Level
            with Encoding{Decoder = PatternDecoder<PortInfoLevel>,
                          SourcePattern = TypeOf<DWORD>()};
        array<BYTE> pPort
            with Technologies.IDL.IDL{Size_is = [cbBuf],
                                      PointerType = PointerKind.UniquePtr,
                                      IndirectionLevel = 1};
        DWORD cbBuf;
    }
    issues message _RpcEnumPortsResponse[PortInfoLevel Level,
                                         DWORD cbBuf]
    {
        (array<BYTE> | PortInfoPattern) pPort
            with Technologies.IDL.IDL{Size_is = [cbBuf],
                                      PointerType = PointerKind.UniquePtr,
                                      IndirectionLevel = 1};
        DWORD pcbNeeded
            with Technologies.IDL.IDL{IndirectionLevel = 1};
        DWORD pcReturned
            with Encoding{Decoder = PortInfoDecoder, SourcePattern = TypeOf<DWORD>()}
            with Technologies.IDL.IDL{IndirectionLevel = 1};
        DWORD ReturnValue;

        optional DWORD PortInfoDecoder(DWORD pcRet)
        {
            if (pPort is arrayByte:array<byte> && arrayByte.Count > 0)
            {
                binary binData = arrayByte as binary;
                InfoStructLevel infoStructureLevel;
                switch (Level)
                {
                    case 1 => infoStructureLevel = InfoStructLevel._PORT_INFO_1;
                    case 2 => infoStructureLevel = InfoStructLevel._PORT_INFO_2;
                    default => infoStructureLevel = InfoStructLevel.UndefinedLevel;
                }
                var result = CustomInfoStrucutureDecoder<PortInfoPattern>(binData as stream, infoStructureLevel, pcRet);
                if (result != nothing)
                {
                    switch (Level)
                    {
                        case 1 => pPort = result as _PORT_INFO_1;
                        case 2 => pPort = result as _PORT_INFO_2;
                    }
                }
            }
            return pcRet;
        }
    }
    accepts message _RpcEnumMonitorsRequest
    {
        string pName
            with Technologies.IDL.IDL
                     {PointerType = PointerKind.UniquePtr,
                      BaseStringType = TypeOf<STRING_HANDLE>(),
                      String = true};
        MonitorInfoLevel Level
            with Encoding{Decoder = PatternDecoder<MonitorInfoLevel>,
                          SourcePattern = TypeOf<DWORD>()};
        array<BYTE> pMonitor
            with Technologies.IDL.IDL{Size_is = [cbBuf],
                                      PointerType = PointerKind.UniquePtr,
                                      IndirectionLevel = 1};
        DWORD cbBuf;
    }
    issues message _RpcEnumMonitorsResponse[MonitorInfoLevel Level, DWORD cbBuf]
    {
        (array<BYTE> | MonitorInfoPattern) pMonitor
            with Technologies.IDL.IDL{Size_is = [cbBuf],
                                      PointerType = PointerKind.UniquePtr,
                                      IndirectionLevel = 1};
        DWORD pcbNeeded
            with Technologies.IDL.IDL{IndirectionLevel = 1};
        DWORD pcReturned
            with Encoding{Decoder = MonitorInfoDecoder, SourcePattern = TypeOf<DWORD>()}
            with Technologies.IDL.IDL{IndirectionLevel = 1};
        DWORD ReturnValue;

        optional DWORD MonitorInfoDecoder(DWORD pcRet)
        {
            if (pMonitor is arrayByte:array<byte> && arrayByte.Count > 0)
            {
                binary binData = arrayByte as binary;
                InfoStructLevel infoStructureLevel;
                switch (Level)
                {
                    case 1 => infoStructureLevel = InfoStructLevel._MONITOR_INFO_1;
                    case 2 => infoStructureLevel = InfoStructLevel._MONITOR_INFO_2;
                    default => infoStructureLevel = InfoStructLevel.UndefinedLevel;
                }
                var result = CustomInfoStrucutureDecoder<MonitorInfoPattern>(binData as stream, infoStructureLevel, pcRet);
                if (result != nothing)
                {
                    switch (Level)
                    {
                        case 1 => pMonitor = result as _MONITOR_INFO_1;
                        case 2 => pMonitor = result as _MONITOR_INFO_2;
                    }
                }
            }
            return pcRet;
        }
    }
    accepts message _Opnum37NotUsedOnWireRequest
    {
    }
    issues message _Opnum37NotUsedOnWireResponse
    {
    }
    accepts message _Opnum38NotUsedOnWireRequest
    {
    }
    issues message _Opnum38NotUsedOnWireResponse
    {
    }
    accepts message _RpcDeletePortRequest
    {
        string pName
            with Technologies.IDL.IDL
                     {PointerType = PointerKind.UniquePtr,
                      BaseStringType = TypeOf<STRING_HANDLE>(),
                      String = true};
        ULONG_PTR hWnd;
        string pPortName
            with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                      String = true,
                                      IndirectionLevel = 1};
    }
    issues message _RpcDeletePortResponse
    {
        DWORD ReturnValue;
    }
    accepts message _RpcCreatePrinterICRequest
    {
        PRINTER_HANDLE hPrinter;
        DEVMODE_CONTAINER pDevModeContainer
            with Technologies.IDL.IDL{IndirectionLevel = 1};
    }
    issues message _RpcCreatePrinterICResponse
    {
        GDI_HANDLE pHandle
            with Technologies.IDL.IDL{IndirectionLevel = 1};
        DWORD ReturnValue;
    }
    accepts message _RpcPlayGdiScriptOnPrinterICRequest
    {
        GDI_HANDLE hPrinterIC;
        array<BYTE> pIn
            with Technologies.IDL.IDL
                     {Size_is = [cIn], IndirectionLevel = 1};
        DWORD cIn;
        DWORD cOut;
        DWORD ul;
    }
    issues message _RpcPlayGdiScriptOnPrinterICResponse[DWORD cOut]
    {
        UniversalFonts pOut
            with Technologies.IDL.IDL
                     {Size_is = [cOut], IndirectionLevel = 1};
        DWORD ReturnValue;
    }
    accepts message _RpcDeletePrinterICRequest
    {
        GDI_HANDLE phPrinterIC
            with Technologies.IDL.IDL{IndirectionLevel = 1};
    }
    issues message _RpcDeletePrinterICResponse
    {
        GDI_HANDLE phPrinterIC
            with Technologies.IDL.IDL{IndirectionLevel = 1};
        DWORD ReturnValue;
    }
    accepts message _Opnum43NotUsedOnWireRequest
    {
    }
    issues message _Opnum43NotUsedOnWireResponse
    {
    }
    accepts message _Opnum44NotUsedOnWireRequest
    {
    }
    issues message _Opnum44NotUsedOnWireResponse
    {
    }
    accepts message _Opnum45NotUsedOnWireRequest
    {
    }
    issues message _Opnum45NotUsedOnWireResponse
    {
    }
    accepts message _RpcAddMonitorRequest
    {
        string Name
            with Technologies.IDL.IDL
                     {PointerType = PointerKind.UniquePtr,
                      BaseStringType = TypeOf<STRING_HANDLE>(),
                      String = true};
        MONITOR_CONTAINER pMonitorContainer
            with Technologies.IDL.IDL{IndirectionLevel = 1};
    }
    issues message _RpcAddMonitorResponse
    {
        DWORD ReturnValue;
    }
    accepts message _RpcDeleteMonitorRequest
    {
        string Name
            with Technologies.IDL.IDL
                     {PointerType = PointerKind.UniquePtr,
                      BaseStringType = TypeOf<STRING_HANDLE>(),
                      String = true};
        string pEnvironment
            with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                      BaseStringType = TypeOf<wchar_t>(),
                                      String = true,
                                      IndirectionLevel = 1};
        string pMonitorName
            with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                      String = true,
                                      IndirectionLevel = 1};
    }
    issues message _RpcDeleteMonitorResponse
    {
        DWORD ReturnValue;
    }
    accepts message _RpcDeletePrintProcessorRequest
    {
        string Name
            with Technologies.IDL.IDL
                     {PointerType = PointerKind.UniquePtr,
                      BaseStringType = TypeOf<STRING_HANDLE>(),
                      String = true};
        string pEnvironment
            with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                      BaseStringType = TypeOf<wchar_t>(),
                                      String = true,
                                      IndirectionLevel = 1};
        string pPrintProcessorName
            with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                      String = true,
                                      IndirectionLevel = 1};
    }
    issues message _RpcDeletePrintProcessorResponse
    {
        DWORD ReturnValue;
    }
    accepts message _Opnum49NotUsedOnWireRequest
    {
    }
    issues message _Opnum49NotUsedOnWireResponse
    {
    }
    accepts message _Opnum50NotUsedOnWireRequest
    {
    }
    issues message _Opnum50NotUsedOnWireResponse
    {
    }
    accepts message _RpcEnumPrintProcessorDatatypesRequest
    {
        string pName
            with Technologies.IDL.IDL
                     {PointerType = PointerKind.UniquePtr,
                      BaseStringType = TypeOf<STRING_HANDLE>(),
                      String = true};
        string pPrintProcessorName
            with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                      BaseStringType = TypeOf<wchar_t>(),
                                      String = true,
                                      IndirectionLevel = 1};
        DWORD Level where ValidationCheckValue(value == 1, null, true, ReferenceType.Type, "RPRN",
                                               "Level", "RpcGetJob", "1", value);
        array<BYTE> pDatatypes
            with Technologies.IDL.IDL{Size_is = [cbBuf],
                                      PointerType = PointerKind.UniquePtr,
                                      IndirectionLevel = 1};
        DWORD cbBuf;
    }
    issues message _RpcEnumPrintProcessorDatatypesResponse[DWORD cbBuf]
    {
        (array<BYTE> | _DATATYPES_INFO_1) pDatatypes
            with Technologies.IDL.IDL{Size_is = [cbBuf],
                                      PointerType = PointerKind.UniquePtr,
                                      IndirectionLevel = 1};
        DWORD pcbNeeded
            with Technologies.IDL.IDL{IndirectionLevel = 1};
        DWORD pcReturned
            with Encoding{Decoder = DatatypesInfoDecoder, SourcePattern = TypeOf<DWORD>()}
            with Technologies.IDL.IDL{IndirectionLevel = 1};
        DWORD ReturnValue;

        optional DWORD DatatypesInfoDecoder(DWORD pcRet)
        {
            if (pDatatypes is arrayByte:array<byte> && arrayByte.Count > 0)
            {
                binary binData = arrayByte as binary;
                var result = CustomInfoStrucutureDecoder<_DATATYPES_INFO_1>(binData as stream, 
                                                                            InfoStructLevel._DATATYPES_INFO_1, 
                                                                            pcRet);
                if (result != nothing)
                    pDatatypes = result as _DATATYPES_INFO_1;
            }
            return pcRet;
        }
    }
    accepts message _RpcResetPrinterRequest
    {
        PRINTER_HANDLE hPrinter;
        string pDatatype
            with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                      BaseStringType = TypeOf<wchar_t>(),
                                      String = true,
                                      IndirectionLevel = 1};
        DEVMODE_CONTAINER pDevModeContainer
            with Technologies.IDL.IDL{IndirectionLevel = 1};
    }
    issues message _RpcResetPrinterResponse
    {
        DWORD ReturnValue;
    }
    accepts message _RpcGetPrinterDriver2Request
    {
        PRINTER_HANDLE hPrinter;
        string pEnvironment
            with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                      BaseStringType = TypeOf<wchar_t>(),
                                      String = true,
                                      IndirectionLevel = 1};
        DriverInfoLevel Level
            with Encoding{Decoder = PatternDecoder<DriverInfoLevel>,
                          SourcePattern = TypeOf<DWORD>()};
        array<BYTE> pDriver
            with Technologies.IDL.IDL{Size_is = [cbBuf],
                                      PointerType = PointerKind.UniquePtr,
                                      IndirectionLevel = 1};
        DWORD cbBuf;
        DWORD dwClientMajorVersion;
        DWORD dwClientMinorVersion;
    }
    issues message _RpcGetPrinterDriver2Response[DriverInfoLevel Level,
                                                 DWORD cbBuf]
    {
        (array<BYTE> | DriverInfoPattern) pDriver
            with Technologies.IDL.IDL{Size_is = [cbBuf],
                                      PointerType = PointerKind.UniquePtr,
                                      IndirectionLevel = 1};
        DWORD pcbNeeded
            with Encoding{Decoder = DriverInfoDecoder, SourcePattern = TypeOf<DWORD>()}
            with Technologies.IDL.IDL{IndirectionLevel = 1};
        DWORD pdwServerMaxVersion
            with Technologies.IDL.IDL{IndirectionLevel = 1};
        DWORD pdwServerMinVersion
            with Technologies.IDL.IDL{IndirectionLevel = 1};
        DWORD ReturnValue;

        optional DWORD DriverInfoDecoder(DWORD needed)
        {
            if (pDriver is arrayByte:array<byte> && arrayByte.Count > 0)
            {
                binary binData = arrayByte as binary;
                InfoStructLevel infoStructureLevel;
                switch (Level)
                {
                    case 1 => infoStructureLevel = InfoStructLevel._DRIVER_INFO_1;
                    case 2 => infoStructureLevel = InfoStructLevel._DRIVER_INFO_2;
                    case 3 => infoStructureLevel = InfoStructLevel._DRIVER_INFO_3;
                    case 4 => infoStructureLevel = InfoStructLevel._DRIVER_INFO_4;
                    case 5 => infoStructureLevel = InfoStructLevel._DRIVER_INFO_5;
                    case 6 => infoStructureLevel = InfoStructLevel._DRIVER_INFO_6;
                    case 8 => infoStructureLevel = InfoStructLevel._DRIVER_INFO_8;
                    case 9 => infoStructureLevel = InfoStructLevel._DRIVER_INFO_101;
                    default => infoStructureLevel = InfoStructLevel.UndefinedLevel;
                }
                var result = CustomInfoStrucutureDecoder<DriverInfoPattern>(binData as stream, infoStructureLevel, 1);
                if (result != nothing)
                {
                    switch (Level)
                    {
                        case 1 => pDriver = result as _DRIVER_INFO_1;
                        case 2 => pDriver = result as _DRIVER_INFO_2;
                        case 3 => pDriver = result as _DRIVER_INFO_3;
                        case 4 => pDriver = result as _DRIVER_INFO_4;
                        case 5 => pDriver = result as _DRIVER_INFO_5;
                        case 6 => pDriver = result as _DRIVER_INFO_6;
                        case 8 => pDriver = result as _DRIVER_INFO_8;
                        case 9 => pDriver = result as _DRIVER_INFO_101;
                    }
                }
            }
            return needed;
        }
    }
    accepts message _Opnum54NotUsedOnWireRequest
    {
    }
    issues message _Opnum54NotUsedOnWireResponse
    {
    }
    accepts message _Opnum55NotUsedOnWireRequest
    {
    }
    issues message _Opnum55NotUsedOnWireResponse
    {
    }
    accepts message _RpcFindClosePrinterChangeNotificationRequest
    {
        PRINTER_HANDLE hPrinter;
    }
    issues message _RpcFindClosePrinterChangeNotificationResponse
    {
        DWORD ReturnValue;
    }
    accepts message _Opnum57NotUsedOnWireRequest
    {
    }
    issues message _Opnum57NotUsedOnWireResponse
    {
    }
    accepts message _RpcReplyOpenPrinterRequest
    {
        string pMachine
            with Technologies.IDL.IDL
                     {BaseStringType = TypeOf<STRING_HANDLE>(),
                      String = true};
        DWORD dwPrinterRemote;
        DWORD dwType where ValidationCheckValue(value == 1, null, true, ReferenceType.Type, "RPRN",
                                                "Level", "RpcGetJob", "1", value);
        DWORD cbBuffer
            with Technologies.IDL.IDL
                     {Range = new RangePattern{Low = 0, High = 512}};
        array<BYTE> pBuffer
            with Technologies.IDL.IDL{Size_is = [cbBuffer],
                                      PointerType = PointerKind.UniquePtr,
                                      IndirectionLevel = 1};
    }
    issues message _RpcReplyOpenPrinterResponse
    {
        PRINTER_HANDLE phPrinterNotify
            with Technologies.IDL.IDL{IndirectionLevel = 1};
        DWORD ReturnValue;
    }
    accepts message _RpcRouterReplyPrinterRequest
    {
        PRINTER_HANDLE hNotify;
        PrinterChangeFlags fdwFlags
            with Encoding{Decoder = PatternDecoder<PrinterChangeFlags>,
                          SourcePattern = TypeOf<DWORD>()};
        DWORD cbBuffer
            with Technologies.IDL.IDL
                     {Range = new RangePattern{Low = 0, High = 512}};
        array<BYTE> pBuffer
            with Technologies.IDL.IDL{Size_is = [cbBuffer],
                                      PointerType = PointerKind.UniquePtr,
                                      IndirectionLevel = 1};
    }
    issues message _RpcRouterReplyPrinterResponse
    {
        DWORD ReturnValue;
    }
    accepts message _RpcReplyClosePrinterRequest
    {
        PRINTER_HANDLE phNotify
            with Technologies.IDL.IDL{IndirectionLevel = 1};
    }
    issues message _RpcReplyClosePrinterResponse
    {
        PRINTER_HANDLE phNotify
            with Technologies.IDL.IDL{IndirectionLevel = 1};
        DWORD ReturnValue;
    }
    accepts message _RpcAddPortExRequest
    {
        string pName
            with Technologies.IDL.IDL
                     {PointerType = PointerKind.UniquePtr,
                      BaseStringType = TypeOf<STRING_HANDLE>(),
                      String = true};
        PORT_CONTAINER pPortContainer
            with Technologies.IDL.IDL{IndirectionLevel = 1};
        PORT_VAR_CONTAINER pPortVarContainer
            with Technologies.IDL.IDL{IndirectionLevel = 1};
        string pMonitorName
            with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                      String = true,
                                      IndirectionLevel = 1};
    }
    issues message _RpcAddPortExResponse
    {
        DWORD ReturnValue;
    }
    accepts message _RpcRemoteFindFirstPrinterChangeNotificationRequest
    {
        PRINTER_HANDLE hPrinter;
        PrinterChangeFlags fdwFlags
            with Encoding{Decoder = PatternDecoder<PrinterChangeFlags>,
                          SourcePattern = TypeOf<DWORD>()};
        PrinterNotificationValues fdwOptions
            where ValidationCheckEnumValue(InRange<PrinterNotificationValues>(value),
                                           null,
                                           true,
                                           ReferenceType.Type,
                                           "RPRN",
                                           "fdwOptions",
                                           "RpcRemoteFindFirstPrinterChangeNotification",
                                           "0x00000000, 0x00010000, 0x00020000",
                                           value);
        string pszLocalMachine
            with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                      BaseStringType = TypeOf<wchar_t>(),
                                      String = true,
                                      IndirectionLevel = 1};
        DWORD dwPrinterLocal;
        DWORD cbBuffer
            with Technologies.IDL.IDL
                     {Range = new RangePattern{Low = 0, High = 512}};
        array<BYTE> pBuffer
            where ValidationCheckValue(value == null, null, true, ReferenceType.Type, "RPRN",
                                       "pBuffer", "RpcRemoteFindFirstPrinterChangeNotification", "null", value)
            with Technologies.IDL.IDL{Size_is = [cbBuffer],
                                      PointerType = PointerKind.UniquePtr,
                                      IndirectionLevel = 1};
    }
    issues message _RpcRemoteFindFirstPrinterChangeNotificationResponse[DWORD
                                                                            cbBuffer]
    {
        array<BYTE> pBuffer
            where ValidationCheckValue(value == null, null, true, ReferenceType.Type, "RPRN",
                                       "pBuffer", "RpcRemoteFindFirstPrinterChangeNotification", "null", value)
            with Technologies.IDL.IDL{Size_is = [cbBuffer],
                                      PointerType = PointerKind.UniquePtr,
                                      IndirectionLevel = 1};
        DWORD ReturnValue;
    }
    accepts message _Opnum63NotUsedOnWireRequest
    {
    }
    issues message _Opnum63NotUsedOnWireResponse
    {
    }
    accepts message _Opnum64NotUsedOnWireRequest
    {
    }
    issues message _Opnum64NotUsedOnWireResponse
    {
    }
    accepts message _RpcRemoteFindFirstPrinterChangeNotificationExRequest
    {
        PRINTER_HANDLE hPrinter;
        PrinterChangeFlags fdwFlags
            with Encoding{Decoder = PatternDecoder<PrinterChangeFlags>,
                          SourcePattern = TypeOf<DWORD>()};
        PrinterNotificationValues fdwOptions
            where ValidationCheckEnumValue(InRange<PrinterNotificationValues>(value),
                                           null,
                                           true,
                                           ReferenceType.Type,
                                           "RPRN",
                                           "fdwOptions",
                                           "RpcRemoteFindFirstPrinterChangeNotificationEx",
                                           "0x00000000, 0x00010000, 0x00020000",
                                           value);
        string pszLocalMachine
            with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                      BaseStringType = TypeOf<wchar_t>(),
                                      String = true,
                                      IndirectionLevel = 1};
        DWORD dwPrinterLocal;
        RPC_V2_NOTIFY_OPTIONS pOptions
            with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                      IndirectionLevel = 1};
    }
    issues message _RpcRemoteFindFirstPrinterChangeNotificationExResponse
    {
        DWORD ReturnValue;
    }
    accepts message _RpcRouterReplyPrinterExRequest
    {
        PRINTER_HANDLE hNotify;
        DWORD dwColor;
        PrinterChangeFlags fdwFlags
            with Encoding{Decoder = PatternDecoder<PrinterChangeFlags>,
                          SourcePattern = TypeOf<DWORD>()};
        DWORD dwReplyType
            where ValidationCheckValue(value == 0, null, true, ReferenceType.Type, "RPRN",
                                       "Level", "RpcGetJob", "0", value);
        RPC_V2_UREPLY_PRINTER[dwReplyType] Reply
            with Technologies.IDL.IDL{Switch_Is = dwReplyType};
    }
    issues message _RpcRouterReplyPrinterExResponse
    {
        ChangeNotificationFlags pdwResult
            with Technologies.IDL.IDL{IndirectionLevel = 1};
        DWORD ReturnValue;
    }
    accepts message _RpcRouterRefreshPrinterChangeNotificationRequest
    {
        PRINTER_HANDLE hPrinter;
        DWORD dwColor;
        RPC_V2_NOTIFY_OPTIONS pOptions
            with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                      IndirectionLevel = 1};
    }
    issues message _RpcRouterRefreshPrinterChangeNotificationResponse
    {
        RPC_V2_NOTIFY_INFO ppInfo
            with Technologies.IDL.IDL{IndirectionLevel = 2};
        DWORD ReturnValue;
    }
    accepts message _Opnum68NotUsedOnWireRequest
    {
    }
    issues message _Opnum68NotUsedOnWireResponse
    {
    }
    accepts message _RpcOpenPrinterExRequest
    {
        string pPrinterName
            with Technologies.IDL.IDL
                     {PointerType = PointerKind.UniquePtr,
                      BaseStringType = TypeOf<STRING_HANDLE>(),
                      String = true};
        string pDatatype
            with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                      BaseStringType = TypeOf<wchar_t>(),
                                      String = true,
                                      IndirectionLevel = 1};
        DEVMODE_CONTAINER pDevModeContainer
            with Technologies.IDL.IDL{IndirectionLevel = 1};
        AccessValuesFlags AccessRequired
            where ValidationCheckCombinationValueTooManyItems(InRange<AccessValuesFlags>(value), this, true, ReferenceType.Message,
                "RPRN", "AccessRequired", "RpcOpenPrinterEx", "Access Values", "[MS-RPRN]")
            with Encoding{Decoder = PatternDecoder<AccessMaskFlags>,
                          SourcePattern = TypeOf<DWORD>()};
        SPLCLIENT_CONTAINER pClientInfo
            with Technologies.IDL.IDL{IndirectionLevel = 1};
    }
    issues message _RpcOpenPrinterExResponse
    {
        PRINTER_HANDLE pHandle
            with Technologies.IDL.IDL{IndirectionLevel = 1};
        DWORD ReturnValue;
    }
    accepts message _RpcAddPrinterExRequest
    {
        string pName
            with Technologies.IDL.IDL
                     {PointerType = PointerKind.UniquePtr,
                      BaseStringType = TypeOf<STRING_HANDLE>(),
                      String = true};
        PRINTER_CONTAINER pPrinterContainer
            with Technologies.IDL.IDL{IndirectionLevel = 1};
        DEVMODE_CONTAINER pDevModeContainer
            with Technologies.IDL.IDL{IndirectionLevel = 1};
        SECURITY_CONTAINER pSecurityContainer
            with Technologies.IDL.IDL{IndirectionLevel = 1};
        SPLCLIENT_CONTAINER pClientInfo
            with Technologies.IDL.IDL{IndirectionLevel = 1};
    }
    issues message _RpcAddPrinterExResponse
    {
        PRINTER_HANDLE pHandle
            with Technologies.IDL.IDL{IndirectionLevel = 1};
        DWORD ReturnValue;
    }
    accepts message _RpcSetPortRequest
    {
        string pName
            with Technologies.IDL.IDL
                     {PointerType = PointerKind.UniquePtr,
                      BaseStringType = TypeOf<STRING_HANDLE>(),
                      String = true};
        string pPortName
            with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                      BaseStringType = TypeOf<wchar_t>(),
                                      String = true,
                                      IndirectionLevel = 1};
        PORT_CONTAINER pPortContainer
            with Technologies.IDL.IDL{IndirectionLevel = 1};
    }
    issues message _RpcSetPortResponse
    {
        DWORD ReturnValue;
    }
    accepts message _RpcEnumPrinterDataRequest
    {
        PRINTER_HANDLE hPrinter;
        DWORD dwIndex;
        DWORD cbValueName;
        DWORD cbData;
    }
    issues message _RpcEnumPrinterDataResponse[DWORD cbValueName]
    {
        array<UnicodeString> pValueName
            with Encoding{Decoder = UnicodeStringArrayDecoder,
                          SourceConverter = ConvertArrayWCHAR2Stream,
                          SourcePattern = TypeOf<array<wchar_t>>()},
                 Technologies.IDL.IDL
                     {Size_is = [cbValueName / SizeOf<wchar_t>()],
                      IndirectionLevel = 1};
        DWORD pcbValueName
            with Technologies.IDL.IDL{IndirectionLevel = 1};
        RegistryTypeValues pType;
        DynamicallyTypedQuery[pType] pData
            with Technologies.IDL.IDL{IndirectionLevel = 1};
        DWORD pcbData with Technologies.IDL.IDL{IndirectionLevel = 1};
        DWORD ReturnValue;
    }
    accepts message _RpcDeletePrinterDataRequest
    {
        PRINTER_HANDLE hPrinter;
        string pValueName
            with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                      String = true,
                                      IndirectionLevel = 1};
    }
    issues message _RpcDeletePrinterDataResponse
    {
        DWORD ReturnValue;
    }
    accepts message _Opnum74NotUsedOnWireRequest
    {
    }
    issues message _Opnum74NotUsedOnWireResponse
    {
    }
    accepts message _Opnum75NotUsedOnWireRequest
    {
    }
    issues message _Opnum75NotUsedOnWireResponse
    {
    }
    accepts message _Opnum76NotUsedOnWireRequest
    {
    }
    issues message _Opnum76NotUsedOnWireResponse
    {
    }
    accepts message _RpcSetPrinterDataExRequest
    {
        PRINTER_HANDLE hPrinter;
        string pKeyName
            with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                      String = true,
                                      IndirectionLevel = 1};
        string pValueName
            with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                      String = true,
                                      IndirectionLevel = 1};
        RegistryTypeValues Type;
        DynamicallyTypedQuery[Type] pData
            with Technologies.IDL.IDL{IndirectionLevel = 1};
        DWORD cbData;
    }
    issues message _RpcSetPrinterDataExResponse
    {
        DWORD ReturnValue;
    }
    accepts message _RpcGetPrinterDataExRequest
    {
        PRINTER_HANDLE hPrinter;
        string pKeyName
            with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                      String = true,
                                      IndirectionLevel = 1};
        string pValueName
            with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                      String = true,
                                      IndirectionLevel = 1};
        DWORD nSize;
    }
    issues message _RpcGetPrinterDataExResponse
    {
        RegistryTypeValues pType;
        DynamicallyTypedQuery[pType] pData
            with Technologies.IDL.IDL{IndirectionLevel = 1};
        DWORD pcbNeeded
            with Technologies.IDL.IDL{IndirectionLevel = 1};
        DWORD ReturnValue;
    }
    accepts message _RpcEnumPrinterDataExRequest
    {
        PRINTER_HANDLE hPrinter;
        string pKeyName
            with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                      String = true,
                                      IndirectionLevel = 1};
        DWORD cbEnumValues;
    }
    issues message _RpcEnumPrinterDataExResponse[DWORD cbEnumValues]
    {
        (array<BYTE> | PRINTER_ENUM_VALUES) pEnumValues
            with Technologies.IDL.IDL{Size_is = [cbEnumValues], IndirectionLevel = 1};
        DWORD pcbEnumValues
            with Technologies.IDL.IDL{IndirectionLevel = 1};
        DWORD pnEnumValues
            with Encoding{Decoder = PrinterEnumValuesDecoder, SourcePattern = TypeOf<DWORD>()}
            with Technologies.IDL.IDL{IndirectionLevel = 1};
        DWORD ReturnValue;

        optional DWORD PrinterEnumValuesDecoder(DWORD pnEnum)
        {
            if (pEnumValues is arrayByte:array<byte> && arrayByte.Count > 0)
            {
                binary binData = arrayByte as binary;
                var result = CustomInfoStrucutureDecoder<PRINTER_ENUM_VALUES>(binData as stream, InfoStructLevel.PRINTER_ENUM_VALUES, pnEnum);
                if (result != nothing)
                    pEnumValues = result as PRINTER_ENUM_VALUES;
            }
            return pnEnum;
        }
    }
    accepts message _RpcEnumPrinterKeyRequest
    {
        PRINTER_HANDLE hPrinter;
        string pKeyName
            with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                      String = true,
                                      IndirectionLevel = 1};
        DWORD cbSubkey;
    }
    issues message _RpcEnumPrinterKeyResponse[DWORD cbSubkey]
    {
        (array<wchar_t> | array<string>) pSubkey
            with Technologies.IDL.IDL
                     {Size_is = [cbSubkey / SizeOf<wchar_t>()],
                      IndirectionLevel = 1};
        DWORD pcbSubkey
            with Encoding{Decoder = SubkeyDecoder, SourcePattern = TypeOf<DWORD>()}
            with Technologies.IDL.IDL{IndirectionLevel = 1};
        DWORD ReturnValue;

        optional DWORD SubkeyDecoder(DWORD needed)
        {
            if (pSubkey is arrayWchar:array<wchar_t> && arrayWchar.Count > 0)
            {
                var result = StringQueryDecoder(ConvertArrayWCHAR2Stream(arrayWchar) as stream);
                if (result is arr:array<string>)
                    pSubkey = arr;
                else
                {
                    array<string> key = [];
                    pSubkey = key; // display string type instead of array<wchar_t>
                }
            }
            return needed;
        }
    }
    accepts message _RpcDeletePrinterDataExRequest
    {
        PRINTER_HANDLE hPrinter;
        string pKeyName
            with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                      String = true,
                                      IndirectionLevel = 1};
        string pValueName
            with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                      String = true,
                                      IndirectionLevel = 1};
    }
    issues message _RpcDeletePrinterDataExResponse
    {
        DWORD ReturnValue;
    }
    accepts message _RpcDeletePrinterKeyRequest
    {
        PRINTER_HANDLE hPrinter;
        string pKeyName
            with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                      String = true,
                                      IndirectionLevel = 1};
    }
    issues message _RpcDeletePrinterKeyResponse
    {
        DWORD ReturnValue;
    }
    accepts message _Opnum83NotUsedOnWireRequest
    {
    }
    issues message _Opnum83NotUsedOnWireResponse
    {
    }
    accepts message _RpcDeletePrinterDriverExRequest
    {
        string pName
            with Technologies.IDL.IDL
                     {PointerType = PointerKind.UniquePtr,
                      BaseStringType = TypeOf<STRING_HANDLE>(),
                      String = true};
        string pEnvironment
            with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                      String = true,
                                      IndirectionLevel = 1};
        string pDriverName
            with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                      String = true,
                                      IndirectionLevel = 1};
        DeletePrinterDriverFlags dwDeleteFlag
            with Encoding
                     {Decoder = PatternDecoder<DeletePrinterDriverFlags>,
                      SourcePattern = TypeOf<DWORD>()};
        DWORD dwVersionNum;
    }
    issues message _RpcDeletePrinterDriverExResponse
    {
        DWORD ReturnValue;
    }
    accepts message _RpcAddPerMachineConnectionRequest
    {
        string pServer
            with Technologies.IDL.IDL
                     {PointerType = PointerKind.UniquePtr,
                      BaseStringType = TypeOf<STRING_HANDLE>(),
                      String = true};
        string pPrinterName
            with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                      String = true,
                                      IndirectionLevel = 1};
        string pPrintServer
            with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                      String = true,
                                      IndirectionLevel = 1};
        string pProvider
            with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                      String = true,
                                      IndirectionLevel = 1};
    }
    issues message _RpcAddPerMachineConnectionResponse
    {
        DWORD ReturnValue;
    }
    accepts message _RpcDeletePerMachineConnectionRequest
    {
        string pServer
            with Technologies.IDL.IDL
                     {PointerType = PointerKind.UniquePtr,
                      BaseStringType = TypeOf<STRING_HANDLE>(),
                      String = true};
        string pPrinterName
            with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                      String = true,
                                      IndirectionLevel = 1};
    }
    issues message _RpcDeletePerMachineConnectionResponse
    {
        DWORD ReturnValue;
    }
    accepts message _RpcEnumPerMachineConnectionsRequest
    {
        string pServer
            with Technologies.IDL.IDL
                     {PointerType = PointerKind.UniquePtr,
                      BaseStringType = TypeOf<STRING_HANDLE>(),
                      String = true};
        array<BYTE> pPrinterEnum
            with Technologies.IDL.IDL{Size_is = [cbBuf],
                                      PointerType = PointerKind.UniquePtr,
                                      IndirectionLevel = 1};
        DWORD cbBuf;
    }
    issues message _RpcEnumPerMachineConnectionsResponse[DWORD cbBuf]
    {
        (array<BYTE> | _PRINTER_INFO_4) pPrinterEnum
            with Technologies.IDL.IDL{Size_is = [cbBuf],
                                      PointerType = PointerKind.UniquePtr,
                                      IndirectionLevel = 1};
        DWORD pcbNeeded
            with Technologies.IDL.IDL{IndirectionLevel = 1};
        DWORD pcReturned
            with Encoding{Decoder = PrinterInfoDecoder, SourcePattern = TypeOf<DWORD>()}
            with Technologies.IDL.IDL{IndirectionLevel = 1};
        DWORD ReturnValue;

        optional DWORD PrinterInfoDecoder(DWORD pcRet)
        {
            if (pPrinterEnum is arrayByte:array<byte> && arrayByte.Count > 0)
            {
                binary binData = arrayByte as binary;
                var result = CustomInfoStrucutureDecoder<_PRINTER_INFO_4>(binData as stream,
                                                                          InfoStructLevel._PRINTER_INFO_4,
                                                                          pcRet);
                if (result != nothing)
                    pPrinterEnum= result as _PRINTER_INFO_4;
            }
            return pcRet;
        }
    }
    accepts message _RpcXcvDataRequest
    {
        PRINTER_HANDLE hXcv;
        string pszDataName
            with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                      String = true,
                                      IndirectionLevel = 1};
        array<BYTE> pInputData
            with Technologies.IDL.IDL
                     {Size_is = [cbInputData], IndirectionLevel = 1};
        DWORD cbInputData;
        DWORD cbOutputData;
        DWORD pdwStatus
            with Technologies.IDL.IDL{IndirectionLevel = 1};
    }
    issues message _RpcXcvDataResponse[DWORD cbOutputData]
    {
        array<BYTE> pOutputData
            with Technologies.IDL.IDL{Size_is = [cbOutputData], IndirectionLevel = 1};
        DWORD pcbOutputNeeded
            with Technologies.IDL.IDL{IndirectionLevel = 1};
        DWORD pdwStatus
            with Technologies.IDL.IDL{IndirectionLevel = 1};
        DWORD ReturnValue;
    }
    accepts message _RpcAddPrinterDriverExRequest
    {
        string pName
            with Technologies.IDL.IDL
                     {PointerType = PointerKind.UniquePtr,
                      BaseStringType = TypeOf<STRING_HANDLE>(),
                      String = true};
        DRIVER_CONTAINER pDriverContainer
            with Technologies.IDL.IDL{IndirectionLevel = 1};
        FileCopyFlags dwFileCopyFlags;
    }
    issues message _RpcAddPrinterDriverExResponse
    {
        DWORD ReturnValue;
    }
    accepts message _Opnum90NotUsedOnWireRequest
    {
    }
    issues message _Opnum90NotUsedOnWireResponse
    {
    }
    accepts message _Opnum91NotUsedOnWireRequest
    {
    }
    issues message _Opnum91NotUsedOnWireResponse
    {
    }
    accepts message _Opnum92NotUsedOnWireRequest
    {
    }
    issues message _Opnum92NotUsedOnWireResponse
    {
    }
    accepts message _Opnum93NotUsedOnWireRequest
    {
    }
    issues message _Opnum93NotUsedOnWireResponse
    {
    }
    accepts message _Opnum94NotUsedOnWireRequest
    {
    }
    issues message _Opnum94NotUsedOnWireResponse
    {
    }
    accepts message _Opnum95NotUsedOnWireRequest
    {
    }
    issues message _Opnum95NotUsedOnWireResponse
    {
    }
    accepts message _RpcFlushPrinterRequest
    {
        PRINTER_HANDLE hPrinter;
        array<BYTE> pBuf
            with Technologies.IDL.IDL{Size_is = [cbBuf], IndirectionLevel = 1};
        DWORD cbBuf;
        DWORD cSleep;
    }
    issues message _RpcFlushPrinterResponse
    {
        DWORD pcWritten
            with Technologies.IDL.IDL{IndirectionLevel = 1};
        DWORD ReturnValue;
    }
    accepts message _RpcSendRecvBidiDataRequest
    {
        PRINTER_HANDLE hPrinter;
        string pAction
            with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                      BaseStringType = TypeOf<wchar_t>(),
                                      String = true,
                                      IndirectionLevel = 1};
        RPC_BIDI_REQUEST_CONTAINER pReqData
            with Technologies.IDL.IDL{IndirectionLevel = 1};
    }
    issues message _RpcSendRecvBidiDataResponse
    {
        RPC_BIDI_RESPONSE_CONTAINER ppRespData
            with Technologies.IDL.IDL{IndirectionLevel = 2};
        DWORD ReturnValue;
    }
    accepts message _Opnum98NotUsedOnWireRequest
    {
    }
    issues message _Opnum98NotUsedOnWireResponse
    {
    }
    accepts message _Opnum99NotUsedOnWireRequest
    {
    }
    issues message _Opnum99NotUsedOnWireResponse
    {
    }
    accepts message _Opnum100NotUsedOnWireRequest
    {
    }
    issues message _Opnum100NotUsedOnWireResponse
    {
    }
    accepts message _Opnum101NotUsedOnWireRequest
    {
    }
    issues message _Opnum101NotUsedOnWireResponse
    {
    }
    accepts message _RpcGetCorePrinterDriversRequest
    {
        string pszServer
            with Technologies.IDL.IDL
                     {PointerType = PointerKind.UniquePtr,
                      BaseStringType = TypeOf<STRING_HANDLE>(),
                      String = true};
        string pszEnvironment
            with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                      String = true,
                                      IndirectionLevel = 1};
        DWORD cchCoreDrivers;
        UnicodeString pszzCoreDriverDependencies
            with Encoding{Decoder = BinaryDecoder<UnicodeString>,
                          SourceConverter = ConvertArrayWCHAR2Stream,
                          SourcePattern = TypeOf<array<wchar_t>>()},
                 Technologies.IDL.IDL
                     {Size_is = [cchCoreDrivers], IndirectionLevel = 1};
        DWORD cCorePrinterDrivers;
    }
    issues message _RpcGetCorePrinterDriversResponse[DWORD
                                                         cCorePrinterDrivers]
    {
        array<CORE_PRINTER_DRIVER> pCorePrinterDrivers
            with Technologies.IDL.IDL{Size_is = [cCorePrinterDrivers],
                                      IndirectionLevel = 1};
        DWORD ReturnValue;
    }
    accepts message _Opnum103NotUsedOnWireRequest
    {
    }
    issues message _Opnum103NotUsedOnWireResponse
    {
    }
    accepts message _RpcGetPrinterDriverPackagePathRequest
    {
        string pszServer
            with Technologies.IDL.IDL
                     {PointerType = PointerKind.UniquePtr,
                      BaseStringType = TypeOf<STRING_HANDLE>(),
                      String = true};
        string pszEnvironment
            with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                      String = true,
                                      IndirectionLevel = 1};
        string pszLanguage
            with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                      BaseStringType = TypeOf<wchar_t>(),
                                      String = true,
                                      IndirectionLevel = 1};
        string pszPackageID
            with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                      String = true,
                                      IndirectionLevel = 1};
        UnicodeString pszDriverPackageCab
            with Encoding{Decoder = BinaryDecoder<UnicodeString>,
                          SourceConverter = ConvertArrayWCHAR2Stream,
                          SourcePattern = TypeOf<array<wchar_t>>()},
                 Technologies.IDL.IDL{Size_is = [cchDriverPackageCab],
                                      PointerType = PointerKind.UniquePtr,
                                      IndirectionLevel = 1};
        DWORD cchDriverPackageCab;
    }
    issues message _RpcGetPrinterDriverPackagePathResponse[DWORD
                                                               cchDriverPackageCab]
    {
        UnicodeString pszDriverPackageCab
            with Encoding{Decoder = BinaryDecoder<UnicodeString>,
                          SourceConverter = ConvertArrayWCHAR2Stream,
                          SourcePattern = TypeOf<array<wchar_t>>()},
                 Technologies.IDL.IDL{Size_is = [cchDriverPackageCab],
                                      PointerType = PointerKind.UniquePtr,
                                      IndirectionLevel = 1};
        IDLUlong pcchRequiredSize
            with Technologies.IDL.IDL{IndirectionLevel = 1};
        ERREF.HRESULT ReturnValue;
    }
    accepts message _Opnum105NotUsedOnWireRequest
    {
    }
    issues message _Opnum105NotUsedOnWireResponse
    {
    }
    accepts message _Opnum106NotUsedOnWireRequest
    {
    }
    issues message _Opnum106NotUsedOnWireResponse
    {
    }
    accepts message _Opnum107NotUsedOnWireRequest
    {
    }
    issues message _Opnum107NotUsedOnWireResponse
    {
    }
    accepts message _Opnum108NotUsedOnWireRequest
    {
    }
    issues message _Opnum108NotUsedOnWireResponse
    {
    }
    accepts message _Opnum109NotUsedOnWireRequest
    {
    }
    issues message _Opnum109NotUsedOnWireResponse
    {
    }
    accepts message _RpcGetJobNamedPropertyValueRequest
    {
        PRINTER_HANDLE hPrinter;
        DWORD JobId
            where ValidationCheckValue(value != 0, null, true, ReferenceType.Type, "RPRN",
                                       "JobId", "RpcGetJobNamedPropertyValue", "not 0", value);
        string pszName
            with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                      String = true,
                                      IndirectionLevel = 1};
    }
    issues message _RpcGetJobNamedPropertyValueResponse
    {
        RPC_PrintPropertyValue pValue
            with Technologies.IDL.IDL{IndirectionLevel = 1};
        DWORD ReturnValue;
    }
    accepts message _RpcSetJobNamedPropertyRequest
    {
        PRINTER_HANDLE hPrinter;
        DWORD JobId
            where ValidationCheckValue(value != 0, null, true, ReferenceType.Type, "RPRN",
                                       "JobId","RpcSetJobNamedProperty", "not 0", value);
        RPC_PrintNamedProperty pProperty
            with Technologies.IDL.IDL{IndirectionLevel = 1};
    }
    issues message _RpcSetJobNamedPropertyResponse
    {
        DWORD ReturnValue;
    }
    accepts message _RpcDeleteJobNamedPropertyRequest
    {
        PRINTER_HANDLE hPrinter;
        DWORD JobId
            where ValidationCheckValue(value != 0, null, true, ReferenceType.Type, "RPRN",
                                       "JobId", "RpcDeleteJobNamedProperty", "not 0", value);
        string pszName
            with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                      String = true,
                                      IndirectionLevel = 1};
    }
    issues message _RpcDeleteJobNamedPropertyResponse
    {
        DWORD ReturnValue;
    }
    accepts message _RpcEnumJobNamedPropertiesRequest
    {
        PRINTER_HANDLE hPrinter;
        DWORD JobId
            where ValidationCheckValue(value != 0, null, true, ReferenceType.Type, "RPRN", "JobId",
                                       "RpcEnumJobNamedProperties", "not 0", value);
    }
    issues message _RpcEnumJobNamedPropertiesResponse
    {
        DWORD pcProperties
            with Technologies.IDL.IDL{IndirectionLevel = 1};
        array<RPC_PrintNamedProperty> ppProperties
            with Technologies.IDL.IDL{Size_is = [null, pcProperties],
                                      IndirectionLevel = 2};
        DWORD ReturnValue;
    }
    accepts message _Opnum114NotUsedOnWireRequest
    {
    }
    issues message _Opnum114NotUsedOnWireResponse
    {
    }
    accepts message _Opnum115NotUsedOnWireRequest
    {
    }
    issues message _Opnum115NotUsedOnWireResponse
    {
    }
    accepts message _RpcLogJobInfoForBranchOfficeRequest
    {
        PRINTER_HANDLE hPrinter;
        RPC_BranchOfficeJobDataContainer pBranchOfficeJobDataContainer
            with Technologies.IDL.IDL{PointerType = PointerKind.RefPtr,
                                      IndirectionLevel = 1};
    }
    issues message _RpcLogJobInfoForBranchOfficeResponse
    {
        DWORD ReturnValue;
    }
}

autostart actor _WinSpoolActor(MSRPCE.Server server)
{
    map<uint, any message> requestCache = {};
    process server accepts
                rpcMsg:RpcconnRequestHdrT
                    where server.MatchInterface(rpcMsg.PContId, {12345678-1234-abcd-ef00-0123456789ab}, 1)
    {
        any message req;
        if (rpcMsg.IsEncrypted && rpcMsg.Opnum is _WinSpoolOpnums)
        {
            req = BinaryDecoder<_ExtendedWinSpoolMessages.EncryptedRequest>(rpcMsg.StubData) as _ExtendedWinSpoolMessages.EncryptedRequest;
            req#RpcOpnum = rpcMsg.Opnum;
        }
        else
        {
            NdrInfo ndrInfo =
                new NdrInfo
                    {isBigEndian = rpcMsg.IsBigEndian,
                     isNdr64 = server.IsNdr64(rpcMsg.PContId),
                     isMsUnion = false,
                     defaultPointerKind = 2};
            switch (rpcMsg.Opnum)
            {
                case $ 0 =>
                    optional _WinSpoolMessages._RpcEnumPrintersRequest m = NdrDecoder<_WinSpoolMessages._RpcEnumPrintersRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: RpcEnumPrinters request (opnum 0) is not decoded successfully";
                    req = m as _WinSpoolMessages._RpcEnumPrintersRequest;
                case $ 1 =>
                    optional _WinSpoolMessages._RpcOpenPrinterRequest m = NdrDecoder<_WinSpoolMessages._RpcOpenPrinterRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: RpcOpenPrinter request (opnum 1) is not decoded successfully";
                    req = m as _WinSpoolMessages._RpcOpenPrinterRequest;
                case $ 2 =>
                    optional _WinSpoolMessages._RpcSetJobRequest m = NdrDecoder<_WinSpoolMessages._RpcSetJobRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: RpcSetJob request (opnum 2) is not decoded successfully";
                    req = m as _WinSpoolMessages._RpcSetJobRequest;
                case $ 3 =>
                    optional _WinSpoolMessages._RpcGetJobRequest m = NdrDecoder<_WinSpoolMessages._RpcGetJobRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: RpcGetJob request (opnum 3) is not decoded successfully";
                    req = m as _WinSpoolMessages._RpcGetJobRequest;
                case $ 4 =>
                    optional _WinSpoolMessages._RpcEnumJobsRequest m = NdrDecoder<_WinSpoolMessages._RpcEnumJobsRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: RpcEnumJobs request (opnum 4) is not decoded successfully";
                    req = m as _WinSpoolMessages._RpcEnumJobsRequest;
                case $ 5 =>
                    optional _WinSpoolMessages._RpcAddPrinterRequest m = NdrDecoder<_WinSpoolMessages._RpcAddPrinterRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: RpcAddPrinter request (opnum 5) is not decoded successfully";
                    req = m as _WinSpoolMessages._RpcAddPrinterRequest;
                case $ 6 =>
                    optional _WinSpoolMessages._RpcDeletePrinterRequest m = NdrDecoder<_WinSpoolMessages._RpcDeletePrinterRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: RpcDeletePrinter request (opnum 6) is not decoded successfully";
                    req = m as _WinSpoolMessages._RpcDeletePrinterRequest;
                case $ 7 =>
                    optional _WinSpoolMessages._RpcSetPrinterRequest m = NdrDecoder<_WinSpoolMessages._RpcSetPrinterRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: RpcSetPrinter request (opnum 7) is not decoded successfully";
                    req = m as _WinSpoolMessages._RpcSetPrinterRequest;
                case $ 8 =>
                    optional _WinSpoolMessages._RpcGetPrinterRequest m = NdrDecoder<_WinSpoolMessages._RpcGetPrinterRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: RpcGetPrinter request (opnum 8) is not decoded successfully";
                    req = m as _WinSpoolMessages._RpcGetPrinterRequest;
                case $ 9 =>
                    optional _WinSpoolMessages._RpcAddPrinterDriverRequest m = NdrDecoder<_WinSpoolMessages._RpcAddPrinterDriverRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: RpcAddPrinterDriver request (opnum 9) is not decoded successfully";
                    req = m as _WinSpoolMessages._RpcAddPrinterDriverRequest;
                case $ 10 =>
                    optional _WinSpoolMessages._RpcEnumPrinterDriversRequest m = NdrDecoder<_WinSpoolMessages._RpcEnumPrinterDriversRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: RpcEnumPrinterDrivers request (opnum 10) is not decoded successfully";
                    req = m as _WinSpoolMessages._RpcEnumPrinterDriversRequest;
                case $ 11 =>
                    optional _WinSpoolMessages._RpcGetPrinterDriverRequest m = NdrDecoder<_WinSpoolMessages._RpcGetPrinterDriverRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: RpcGetPrinterDriver request (opnum 11) is not decoded successfully";
                    req = m as _WinSpoolMessages._RpcGetPrinterDriverRequest;
                case $ 12 =>
                    optional _WinSpoolMessages._RpcGetPrinterDriverDirectoryRequest m = NdrDecoder<_WinSpoolMessages._RpcGetPrinterDriverDirectoryRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: RpcGetPrinterDriverDirectory request (opnum 12) is not decoded successfully";
                    req = m as _WinSpoolMessages._RpcGetPrinterDriverDirectoryRequest;
                case $ 13 =>
                    optional _WinSpoolMessages._RpcDeletePrinterDriverRequest m = NdrDecoder<_WinSpoolMessages._RpcDeletePrinterDriverRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: RpcDeletePrinterDriver request (opnum 13) is not decoded successfully";
                    req = m as _WinSpoolMessages._RpcDeletePrinterDriverRequest;
                case $ 14 =>
                    optional _WinSpoolMessages._RpcAddPrintProcessorRequest m = NdrDecoder<_WinSpoolMessages._RpcAddPrintProcessorRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: RpcAddPrintProcessor request (opnum 14) is not decoded successfully";
                    req = m as _WinSpoolMessages._RpcAddPrintProcessorRequest;
                case $ 15 =>
                    optional _WinSpoolMessages._RpcEnumPrintProcessorsRequest m = NdrDecoder<_WinSpoolMessages._RpcEnumPrintProcessorsRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: RpcEnumPrintProcessors request (opnum 15) is not decoded successfully";
                    req = m as _WinSpoolMessages._RpcEnumPrintProcessorsRequest;
                case $ 16 =>
                    optional _WinSpoolMessages._RpcGetPrintProcessorDirectoryRequest m = NdrDecoder<_WinSpoolMessages._RpcGetPrintProcessorDirectoryRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: RpcGetPrintProcessorDirectory request (opnum 16) is not decoded successfully";
                    req = m as _WinSpoolMessages._RpcGetPrintProcessorDirectoryRequest;
                case $ 17 =>
                    optional _WinSpoolMessages._RpcStartDocPrinterRequest m = NdrDecoder<_WinSpoolMessages._RpcStartDocPrinterRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: RpcStartDocPrinter request (opnum 17) is not decoded successfully";
                    req = m as _WinSpoolMessages._RpcStartDocPrinterRequest;
                case $ 18 =>
                    optional _WinSpoolMessages._RpcStartPagePrinterRequest m = NdrDecoder<_WinSpoolMessages._RpcStartPagePrinterRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: RpcStartPagePrinter request (opnum 18) is not decoded successfully";
                    req = m as _WinSpoolMessages._RpcStartPagePrinterRequest;
                case $ 19 =>
                    optional _WinSpoolMessages._RpcWritePrinterRequest m = NdrDecoder<_WinSpoolMessages._RpcWritePrinterRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: RpcWritePrinter request (opnum 19) is not decoded successfully";
                    req = m as _WinSpoolMessages._RpcWritePrinterRequest;
                case $ 20 =>
                    optional _WinSpoolMessages._RpcEndPagePrinterRequest m = NdrDecoder<_WinSpoolMessages._RpcEndPagePrinterRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: RpcEndPagePrinter request (opnum 20) is not decoded successfully";
                    req = m as _WinSpoolMessages._RpcEndPagePrinterRequest;
                case $ 21 =>
                    optional _WinSpoolMessages._RpcAbortPrinterRequest m = NdrDecoder<_WinSpoolMessages._RpcAbortPrinterRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: RpcAbortPrinter request (opnum 21) is not decoded successfully";
                    req = m as _WinSpoolMessages._RpcAbortPrinterRequest;
                case $ 22 =>
                    optional _WinSpoolMessages._RpcReadPrinterRequest m = NdrDecoder<_WinSpoolMessages._RpcReadPrinterRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: RpcReadPrinter request (opnum 22) is not decoded successfully";
                    req = m as _WinSpoolMessages._RpcReadPrinterRequest;
                case $ 23 =>
                    optional _WinSpoolMessages._RpcEndDocPrinterRequest m = NdrDecoder<_WinSpoolMessages._RpcEndDocPrinterRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: RpcEndDocPrinter request (opnum 23) is not decoded successfully";
                    req = m as _WinSpoolMessages._RpcEndDocPrinterRequest;
                case $ 24 =>
                    optional _WinSpoolMessages._RpcAddJobRequest m = NdrDecoder<_WinSpoolMessages._RpcAddJobRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: RpcAddJob request (opnum 24) is not decoded successfully";
                    req = m as _WinSpoolMessages._RpcAddJobRequest;
                case $ 25 =>
                    optional _WinSpoolMessages._RpcScheduleJobRequest m = NdrDecoder<_WinSpoolMessages._RpcScheduleJobRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: RpcScheduleJob request (opnum 25) is not decoded successfully";
                    req = m as _WinSpoolMessages._RpcScheduleJobRequest;
                case $ 26 =>
                    optional _WinSpoolMessages._RpcGetPrinterDataRequest m = NdrDecoder<_WinSpoolMessages._RpcGetPrinterDataRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: RpcGetPrinterData request (opnum 26) is not decoded successfully";
                    req = m as _WinSpoolMessages._RpcGetPrinterDataRequest;
                case $ 27 =>
                    optional _WinSpoolMessages._RpcSetPrinterDataRequest m = NdrDecoder<_WinSpoolMessages._RpcSetPrinterDataRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: RpcSetPrinterData request (opnum 27) is not decoded successfully";
                    req = m as _WinSpoolMessages._RpcSetPrinterDataRequest;
                case $ 28 =>
                    optional _WinSpoolMessages._RpcWaitForPrinterChangeRequest m = NdrDecoder<_WinSpoolMessages._RpcWaitForPrinterChangeRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: RpcWaitForPrinterChange request (opnum 28) is not decoded successfully";
                    req = m as _WinSpoolMessages._RpcWaitForPrinterChangeRequest;
                case $ 29 =>
                    optional _WinSpoolMessages._RpcClosePrinterRequest m = NdrDecoder<_WinSpoolMessages._RpcClosePrinterRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: RpcClosePrinter request (opnum 29) is not decoded successfully";
                    req = m as _WinSpoolMessages._RpcClosePrinterRequest;
                case $ 30 =>
                    optional _WinSpoolMessages._RpcAddFormRequest m = NdrDecoder<_WinSpoolMessages._RpcAddFormRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: RpcAddForm request (opnum 30) is not decoded successfully";
                    req = m as _WinSpoolMessages._RpcAddFormRequest;
                case $ 31 =>
                    optional _WinSpoolMessages._RpcDeleteFormRequest m = NdrDecoder<_WinSpoolMessages._RpcDeleteFormRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: RpcDeleteForm request (opnum 31) is not decoded successfully";
                    req = m as _WinSpoolMessages._RpcDeleteFormRequest;
                case $ 32 =>
                    optional _WinSpoolMessages._RpcGetFormRequest m = NdrDecoder<_WinSpoolMessages._RpcGetFormRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: RpcGetForm request (opnum 32) is not decoded successfully";
                    req = m as _WinSpoolMessages._RpcGetFormRequest;
                case $ 33 =>
                    optional _WinSpoolMessages._RpcSetFormRequest m = NdrDecoder<_WinSpoolMessages._RpcSetFormRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: RpcSetForm request (opnum 33) is not decoded successfully";
                    req = m as _WinSpoolMessages._RpcSetFormRequest;
                case $ 34 =>
                    optional _WinSpoolMessages._RpcEnumFormsRequest m = NdrDecoder<_WinSpoolMessages._RpcEnumFormsRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: RpcEnumForms request (opnum 34) is not decoded successfully";
                    req = m as _WinSpoolMessages._RpcEnumFormsRequest;
                case $ 35 =>
                    optional _WinSpoolMessages._RpcEnumPortsRequest m = NdrDecoder<_WinSpoolMessages._RpcEnumPortsRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: RpcEnumPorts request (opnum 35) is not decoded successfully";
                    req = m as _WinSpoolMessages._RpcEnumPortsRequest;
                case $ 36 =>
                    optional _WinSpoolMessages._RpcEnumMonitorsRequest m = NdrDecoder<_WinSpoolMessages._RpcEnumMonitorsRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: RpcEnumMonitors request (opnum 36) is not decoded successfully";
                    req = m as _WinSpoolMessages._RpcEnumMonitorsRequest;
                case $ 37 =>
                    optional _WinSpoolMessages._Opnum37NotUsedOnWireRequest m = NdrDecoder<_WinSpoolMessages._Opnum37NotUsedOnWireRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: Opnum37NotUsedOnWire request (opnum 37) is not decoded successfully";
                    req = m as _WinSpoolMessages._Opnum37NotUsedOnWireRequest;
                case $ 38 =>
                    optional _WinSpoolMessages._Opnum38NotUsedOnWireRequest m = NdrDecoder<_WinSpoolMessages._Opnum38NotUsedOnWireRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: Opnum38NotUsedOnWire request (opnum 38) is not decoded successfully";
                    req = m as _WinSpoolMessages._Opnum38NotUsedOnWireRequest;
                case $ 39 =>
                    optional _WinSpoolMessages._RpcDeletePortRequest m = NdrDecoder<_WinSpoolMessages._RpcDeletePortRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: RpcDeletePort request (opnum 39) is not decoded successfully";
                    req = m as _WinSpoolMessages._RpcDeletePortRequest;
                case $ 40 =>
                    optional _WinSpoolMessages._RpcCreatePrinterICRequest m = NdrDecoder<_WinSpoolMessages._RpcCreatePrinterICRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: RpcCreatePrinterIC request (opnum 40) is not decoded successfully";
                    req = m as _WinSpoolMessages._RpcCreatePrinterICRequest;
                case $ 41 =>
                    optional _WinSpoolMessages._RpcPlayGdiScriptOnPrinterICRequest m = NdrDecoder<_WinSpoolMessages._RpcPlayGdiScriptOnPrinterICRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: RpcPlayGdiScriptOnPrinterIC request (opnum 41) is not decoded successfully";
                    req = m as _WinSpoolMessages._RpcPlayGdiScriptOnPrinterICRequest;
                case $ 42 =>
                    optional _WinSpoolMessages._RpcDeletePrinterICRequest m = NdrDecoder<_WinSpoolMessages._RpcDeletePrinterICRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: RpcDeletePrinterIC request (opnum 42) is not decoded successfully";
                    req = m as _WinSpoolMessages._RpcDeletePrinterICRequest;
                case $ 43 =>
                    optional _WinSpoolMessages._Opnum43NotUsedOnWireRequest m = NdrDecoder<_WinSpoolMessages._Opnum43NotUsedOnWireRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: Opnum43NotUsedOnWire request (opnum 43) is not decoded successfully";
                    req = m as _WinSpoolMessages._Opnum43NotUsedOnWireRequest;
                case $ 44 =>
                    optional _WinSpoolMessages._Opnum44NotUsedOnWireRequest m = NdrDecoder<_WinSpoolMessages._Opnum44NotUsedOnWireRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: Opnum44NotUsedOnWire request (opnum 44) is not decoded successfully";
                    req = m as _WinSpoolMessages._Opnum44NotUsedOnWireRequest;
                case $ 45 =>
                    optional _WinSpoolMessages._Opnum45NotUsedOnWireRequest m = NdrDecoder<_WinSpoolMessages._Opnum45NotUsedOnWireRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: Opnum45NotUsedOnWire request (opnum 45) is not decoded successfully";
                    req = m as _WinSpoolMessages._Opnum45NotUsedOnWireRequest;
                case $ 46 =>
                    optional _WinSpoolMessages._RpcAddMonitorRequest m = NdrDecoder<_WinSpoolMessages._RpcAddMonitorRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: RpcAddMonitor request (opnum 46) is not decoded successfully";
                    req = m as _WinSpoolMessages._RpcAddMonitorRequest;
                case $ 47 =>
                    optional _WinSpoolMessages._RpcDeleteMonitorRequest m = NdrDecoder<_WinSpoolMessages._RpcDeleteMonitorRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: RpcDeleteMonitor request (opnum 47) is not decoded successfully";
                    req = m as _WinSpoolMessages._RpcDeleteMonitorRequest;
                case $ 48 =>
                    optional _WinSpoolMessages._RpcDeletePrintProcessorRequest m = NdrDecoder<_WinSpoolMessages._RpcDeletePrintProcessorRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: RpcDeletePrintProcessor request (opnum 48) is not decoded successfully";
                    req = m as _WinSpoolMessages._RpcDeletePrintProcessorRequest;
                case $ 49 =>
                    optional _WinSpoolMessages._Opnum49NotUsedOnWireRequest m = NdrDecoder<_WinSpoolMessages._Opnum49NotUsedOnWireRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: Opnum49NotUsedOnWire request (opnum 49) is not decoded successfully";
                    req = m as _WinSpoolMessages._Opnum49NotUsedOnWireRequest;
                case $ 50 =>
                    optional _WinSpoolMessages._Opnum50NotUsedOnWireRequest m = NdrDecoder<_WinSpoolMessages._Opnum50NotUsedOnWireRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: Opnum50NotUsedOnWire request (opnum 50) is not decoded successfully";
                    req = m as _WinSpoolMessages._Opnum50NotUsedOnWireRequest;
                case $ 51 =>
                    optional _WinSpoolMessages._RpcEnumPrintProcessorDatatypesRequest m = NdrDecoder<_WinSpoolMessages._RpcEnumPrintProcessorDatatypesRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: RpcEnumPrintProcessorDatatypes request (opnum 51) is not decoded successfully";
                    req = m as _WinSpoolMessages._RpcEnumPrintProcessorDatatypesRequest;
                case $ 52 =>
                    optional _WinSpoolMessages._RpcResetPrinterRequest m = NdrDecoder<_WinSpoolMessages._RpcResetPrinterRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: RpcResetPrinter request (opnum 52) is not decoded successfully";
                    req = m as _WinSpoolMessages._RpcResetPrinterRequest;
                case $ 53 =>
                    optional _WinSpoolMessages._RpcGetPrinterDriver2Request m = NdrDecoder<_WinSpoolMessages._RpcGetPrinterDriver2Request>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: RpcGetPrinterDriver2 request (opnum 53) is not decoded successfully";
                    req = m as _WinSpoolMessages._RpcGetPrinterDriver2Request;
                case $ 54 =>
                    optional _WinSpoolMessages._Opnum54NotUsedOnWireRequest m = NdrDecoder<_WinSpoolMessages._Opnum54NotUsedOnWireRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: Opnum54NotUsedOnWire request (opnum 54) is not decoded successfully";
                    req = m as _WinSpoolMessages._Opnum54NotUsedOnWireRequest;
                case $ 55 =>
                    optional _WinSpoolMessages._Opnum55NotUsedOnWireRequest m = NdrDecoder<_WinSpoolMessages._Opnum55NotUsedOnWireRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: Opnum55NotUsedOnWire request (opnum 55) is not decoded successfully";
                    req = m as _WinSpoolMessages._Opnum55NotUsedOnWireRequest;
                case $ 56 =>
                    optional _WinSpoolMessages._RpcFindClosePrinterChangeNotificationRequest m = NdrDecoder<_WinSpoolMessages._RpcFindClosePrinterChangeNotificationRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: RpcFindClosePrinterChangeNotification request (opnum 56) is not decoded successfully";
                    req = m as _WinSpoolMessages._RpcFindClosePrinterChangeNotificationRequest;
                case $ 57 =>
                    optional _WinSpoolMessages._Opnum57NotUsedOnWireRequest m = NdrDecoder<_WinSpoolMessages._Opnum57NotUsedOnWireRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: Opnum57NotUsedOnWire request (opnum 57) is not decoded successfully";
                    req = m as _WinSpoolMessages._Opnum57NotUsedOnWireRequest;
                case $ 58 =>
                    optional _WinSpoolMessages._RpcReplyOpenPrinterRequest m = NdrDecoder<_WinSpoolMessages._RpcReplyOpenPrinterRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: RpcReplyOpenPrinter request (opnum 58) is not decoded successfully";
                    req = m as _WinSpoolMessages._RpcReplyOpenPrinterRequest;
                case $ 59 =>
                    optional _WinSpoolMessages._RpcRouterReplyPrinterRequest m = NdrDecoder<_WinSpoolMessages._RpcRouterReplyPrinterRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: RpcRouterReplyPrinter request (opnum 59) is not decoded successfully";
                    req = m as _WinSpoolMessages._RpcRouterReplyPrinterRequest;
                case $ 60 =>
                    optional _WinSpoolMessages._RpcReplyClosePrinterRequest m = NdrDecoder<_WinSpoolMessages._RpcReplyClosePrinterRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: RpcReplyClosePrinter request (opnum 60) is not decoded successfully";
                    req = m as _WinSpoolMessages._RpcReplyClosePrinterRequest;
                case $ 61 =>
                    optional _WinSpoolMessages._RpcAddPortExRequest m = NdrDecoder<_WinSpoolMessages._RpcAddPortExRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: RpcAddPortEx request (opnum 61) is not decoded successfully";
                    req = m as _WinSpoolMessages._RpcAddPortExRequest;
                case $ 62 =>
                    optional _WinSpoolMessages._RpcRemoteFindFirstPrinterChangeNotificationRequest m = NdrDecoder<_WinSpoolMessages._RpcRemoteFindFirstPrinterChangeNotificationRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: RpcRemoteFindFirstPrinterChangeNotification request (opnum 62) is not decoded successfully";
                    req = m as _WinSpoolMessages._RpcRemoteFindFirstPrinterChangeNotificationRequest;
                case $ 63 =>
                    optional _WinSpoolMessages._Opnum63NotUsedOnWireRequest m = NdrDecoder<_WinSpoolMessages._Opnum63NotUsedOnWireRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: Opnum63NotUsedOnWire request (opnum 63) is not decoded successfully";
                    req = m as _WinSpoolMessages._Opnum63NotUsedOnWireRequest;
                case $ 64 =>
                    optional _WinSpoolMessages._Opnum64NotUsedOnWireRequest m = NdrDecoder<_WinSpoolMessages._Opnum64NotUsedOnWireRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: Opnum64NotUsedOnWire request (opnum 64) is not decoded successfully";
                    req = m as _WinSpoolMessages._Opnum64NotUsedOnWireRequest;
                case $ 65 =>
                    optional _WinSpoolMessages._RpcRemoteFindFirstPrinterChangeNotificationExRequest m = NdrDecoder<_WinSpoolMessages._RpcRemoteFindFirstPrinterChangeNotificationExRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: RpcRemoteFindFirstPrinterChangeNotificationEx request (opnum 65) is not decoded successfully";
                    req = m as _WinSpoolMessages._RpcRemoteFindFirstPrinterChangeNotificationExRequest;
                case $ 66 =>
                    optional _WinSpoolMessages._RpcRouterReplyPrinterExRequest m = NdrDecoder<_WinSpoolMessages._RpcRouterReplyPrinterExRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: RpcRouterReplyPrinterEx request (opnum 66) is not decoded successfully";
                    req = m as _WinSpoolMessages._RpcRouterReplyPrinterExRequest;
                case $ 67 =>
                    optional _WinSpoolMessages._RpcRouterRefreshPrinterChangeNotificationRequest m = NdrDecoder<_WinSpoolMessages._RpcRouterRefreshPrinterChangeNotificationRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: RpcRouterRefreshPrinterChangeNotification request (opnum 67) is not decoded successfully";
                    req = m as _WinSpoolMessages._RpcRouterRefreshPrinterChangeNotificationRequest;
                case $ 68 =>
                    optional _WinSpoolMessages._Opnum68NotUsedOnWireRequest m = NdrDecoder<_WinSpoolMessages._Opnum68NotUsedOnWireRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: Opnum68NotUsedOnWire request (opnum 68) is not decoded successfully";
                    req = m as _WinSpoolMessages._Opnum68NotUsedOnWireRequest;
                case $ 69 =>
                    optional _WinSpoolMessages._RpcOpenPrinterExRequest m = NdrDecoder<_WinSpoolMessages._RpcOpenPrinterExRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: RpcOpenPrinterEx request (opnum 69) is not decoded successfully";
                    req = m as _WinSpoolMessages._RpcOpenPrinterExRequest;
                case $ 70 =>
                    optional _WinSpoolMessages._RpcAddPrinterExRequest m = NdrDecoder<_WinSpoolMessages._RpcAddPrinterExRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: RpcAddPrinterEx request (opnum 70) is not decoded successfully";
                    req = m as _WinSpoolMessages._RpcAddPrinterExRequest;
                case $ 71 =>
                    optional _WinSpoolMessages._RpcSetPortRequest m = NdrDecoder<_WinSpoolMessages._RpcSetPortRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: RpcSetPort request (opnum 71) is not decoded successfully";
                    req = m as _WinSpoolMessages._RpcSetPortRequest;
                case $ 72 =>
                    optional _WinSpoolMessages._RpcEnumPrinterDataRequest m = NdrDecoder<_WinSpoolMessages._RpcEnumPrinterDataRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: RpcEnumPrinterData request (opnum 72) is not decoded successfully";
                    req = m as _WinSpoolMessages._RpcEnumPrinterDataRequest;
                case $ 73 =>
                    optional _WinSpoolMessages._RpcDeletePrinterDataRequest m = NdrDecoder<_WinSpoolMessages._RpcDeletePrinterDataRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: RpcDeletePrinterData request (opnum 73) is not decoded successfully";
                    req = m as _WinSpoolMessages._RpcDeletePrinterDataRequest;
                case $ 74 =>
                    optional _WinSpoolMessages._Opnum74NotUsedOnWireRequest m = NdrDecoder<_WinSpoolMessages._Opnum74NotUsedOnWireRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: Opnum74NotUsedOnWire request (opnum 74) is not decoded successfully";
                    req = m as _WinSpoolMessages._Opnum74NotUsedOnWireRequest;
                case $ 75 =>
                    optional _WinSpoolMessages._Opnum75NotUsedOnWireRequest m = NdrDecoder<_WinSpoolMessages._Opnum75NotUsedOnWireRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: Opnum75NotUsedOnWire request (opnum 75) is not decoded successfully";
                    req = m as _WinSpoolMessages._Opnum75NotUsedOnWireRequest;
                case $ 76 =>
                    optional _WinSpoolMessages._Opnum76NotUsedOnWireRequest m = NdrDecoder<_WinSpoolMessages._Opnum76NotUsedOnWireRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: Opnum76NotUsedOnWire request (opnum 76) is not decoded successfully";
                    req = m as _WinSpoolMessages._Opnum76NotUsedOnWireRequest;
                case $ 77 =>
                    optional _WinSpoolMessages._RpcSetPrinterDataExRequest m = NdrDecoder<_WinSpoolMessages._RpcSetPrinterDataExRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: RpcSetPrinterDataEx request (opnum 77) is not decoded successfully";
                    req = m as _WinSpoolMessages._RpcSetPrinterDataExRequest;
                case $ 78 =>
                    optional _WinSpoolMessages._RpcGetPrinterDataExRequest m = NdrDecoder<_WinSpoolMessages._RpcGetPrinterDataExRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: RpcGetPrinterDataEx request (opnum 78) is not decoded successfully";
                    req = m as _WinSpoolMessages._RpcGetPrinterDataExRequest;
                case $ 79 =>
                    optional _WinSpoolMessages._RpcEnumPrinterDataExRequest m = NdrDecoder<_WinSpoolMessages._RpcEnumPrinterDataExRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: RpcEnumPrinterDataEx request (opnum 79) is not decoded successfully";
                    req = m as _WinSpoolMessages._RpcEnumPrinterDataExRequest;
                case $ 80 =>
                    optional _WinSpoolMessages._RpcEnumPrinterKeyRequest m = NdrDecoder<_WinSpoolMessages._RpcEnumPrinterKeyRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: RpcEnumPrinterKey request (opnum 80) is not decoded successfully";
                    req = m as _WinSpoolMessages._RpcEnumPrinterKeyRequest;
                case $ 81 =>
                    optional _WinSpoolMessages._RpcDeletePrinterDataExRequest m = NdrDecoder<_WinSpoolMessages._RpcDeletePrinterDataExRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: RpcDeletePrinterDataEx request (opnum 81) is not decoded successfully";
                    req = m as _WinSpoolMessages._RpcDeletePrinterDataExRequest;
                case $ 82 =>
                    optional _WinSpoolMessages._RpcDeletePrinterKeyRequest m = NdrDecoder<_WinSpoolMessages._RpcDeletePrinterKeyRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: RpcDeletePrinterKey request (opnum 82) is not decoded successfully";
                    req = m as _WinSpoolMessages._RpcDeletePrinterKeyRequest;
                case $ 83 =>
                    optional _WinSpoolMessages._Opnum83NotUsedOnWireRequest m = NdrDecoder<_WinSpoolMessages._Opnum83NotUsedOnWireRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: Opnum83NotUsedOnWire request (opnum 83) is not decoded successfully";
                    req = m as _WinSpoolMessages._Opnum83NotUsedOnWireRequest;
                case $ 84 =>
                    optional _WinSpoolMessages._RpcDeletePrinterDriverExRequest m = NdrDecoder<_WinSpoolMessages._RpcDeletePrinterDriverExRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: RpcDeletePrinterDriverEx request (opnum 84) is not decoded successfully";
                    req = m as _WinSpoolMessages._RpcDeletePrinterDriverExRequest;
                case $ 85 =>
                    optional _WinSpoolMessages._RpcAddPerMachineConnectionRequest m = NdrDecoder<_WinSpoolMessages._RpcAddPerMachineConnectionRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: RpcAddPerMachineConnection request (opnum 85) is not decoded successfully";
                    req = m as _WinSpoolMessages._RpcAddPerMachineConnectionRequest;
                case $ 86 =>
                    optional _WinSpoolMessages._RpcDeletePerMachineConnectionRequest m = NdrDecoder<_WinSpoolMessages._RpcDeletePerMachineConnectionRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: RpcDeletePerMachineConnection request (opnum 86) is not decoded successfully";
                    req = m as _WinSpoolMessages._RpcDeletePerMachineConnectionRequest;
                case $ 87 =>
                    optional _WinSpoolMessages._RpcEnumPerMachineConnectionsRequest m = NdrDecoder<_WinSpoolMessages._RpcEnumPerMachineConnectionsRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: RpcEnumPerMachineConnections request (opnum 87) is not decoded successfully";
                    req = m as _WinSpoolMessages._RpcEnumPerMachineConnectionsRequest;
                case $ 88 =>
                    optional _WinSpoolMessages._RpcXcvDataRequest m = NdrDecoder<_WinSpoolMessages._RpcXcvDataRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: RpcXcvData request (opnum 88) is not decoded successfully";
                    req = m as _WinSpoolMessages._RpcXcvDataRequest;
                case $ 89 =>
                    optional _WinSpoolMessages._RpcAddPrinterDriverExRequest m = NdrDecoder<_WinSpoolMessages._RpcAddPrinterDriverExRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: RpcAddPrinterDriverEx request (opnum 89) is not decoded successfully";
                    req = m as _WinSpoolMessages._RpcAddPrinterDriverExRequest;
                case $ 90 =>
                    optional _WinSpoolMessages._Opnum90NotUsedOnWireRequest m = NdrDecoder<_WinSpoolMessages._Opnum90NotUsedOnWireRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: Opnum90NotUsedOnWire request (opnum 90) is not decoded successfully";
                    req = m as _WinSpoolMessages._Opnum90NotUsedOnWireRequest;
                case $ 91 =>
                    optional _WinSpoolMessages._Opnum91NotUsedOnWireRequest m = NdrDecoder<_WinSpoolMessages._Opnum91NotUsedOnWireRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: Opnum91NotUsedOnWire request (opnum 91) is not decoded successfully";
                    req = m as _WinSpoolMessages._Opnum91NotUsedOnWireRequest;
                case $ 92 =>
                    optional _WinSpoolMessages._Opnum92NotUsedOnWireRequest m = NdrDecoder<_WinSpoolMessages._Opnum92NotUsedOnWireRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: Opnum92NotUsedOnWire request (opnum 92) is not decoded successfully";
                    req = m as _WinSpoolMessages._Opnum92NotUsedOnWireRequest;
                case $ 93 =>
                    optional _WinSpoolMessages._Opnum93NotUsedOnWireRequest m = NdrDecoder<_WinSpoolMessages._Opnum93NotUsedOnWireRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: Opnum93NotUsedOnWire request (opnum 93) is not decoded successfully";
                    req = m as _WinSpoolMessages._Opnum93NotUsedOnWireRequest;
                case $ 94 =>
                    optional _WinSpoolMessages._Opnum94NotUsedOnWireRequest m = NdrDecoder<_WinSpoolMessages._Opnum94NotUsedOnWireRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: Opnum94NotUsedOnWire request (opnum 94) is not decoded successfully";
                    req = m as _WinSpoolMessages._Opnum94NotUsedOnWireRequest;
                case $ 95 =>
                    optional _WinSpoolMessages._Opnum95NotUsedOnWireRequest m = NdrDecoder<_WinSpoolMessages._Opnum95NotUsedOnWireRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: Opnum95NotUsedOnWire request (opnum 95) is not decoded successfully";
                    req = m as _WinSpoolMessages._Opnum95NotUsedOnWireRequest;
                case $ 96 =>
                    optional _WinSpoolMessages._RpcFlushPrinterRequest m = NdrDecoder<_WinSpoolMessages._RpcFlushPrinterRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: RpcFlushPrinter request (opnum 96) is not decoded successfully";
                    req = m as _WinSpoolMessages._RpcFlushPrinterRequest;
                case $ 97 =>
                    optional _WinSpoolMessages._RpcSendRecvBidiDataRequest m = NdrDecoder<_WinSpoolMessages._RpcSendRecvBidiDataRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: RpcSendRecvBidiData request (opnum 97) is not decoded successfully";
                    req = m as _WinSpoolMessages._RpcSendRecvBidiDataRequest;
                case $ 98 =>
                    optional _WinSpoolMessages._Opnum98NotUsedOnWireRequest m = NdrDecoder<_WinSpoolMessages._Opnum98NotUsedOnWireRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: Opnum98NotUsedOnWire request (opnum 98) is not decoded successfully";
                    req = m as _WinSpoolMessages._Opnum98NotUsedOnWireRequest;
                case $ 99 =>
                    optional _WinSpoolMessages._Opnum99NotUsedOnWireRequest m = NdrDecoder<_WinSpoolMessages._Opnum99NotUsedOnWireRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: Opnum99NotUsedOnWire request (opnum 99) is not decoded successfully";
                    req = m as _WinSpoolMessages._Opnum99NotUsedOnWireRequest;
                case $ 100 =>
                    optional _WinSpoolMessages._Opnum100NotUsedOnWireRequest m = NdrDecoder<_WinSpoolMessages._Opnum100NotUsedOnWireRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: Opnum100NotUsedOnWire request (opnum 100) is not decoded successfully";
                    req = m as _WinSpoolMessages._Opnum100NotUsedOnWireRequest;
                case $ 101 =>
                    optional _WinSpoolMessages._Opnum101NotUsedOnWireRequest m = NdrDecoder<_WinSpoolMessages._Opnum101NotUsedOnWireRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: Opnum101NotUsedOnWire request (opnum 101) is not decoded successfully";
                    req = m as _WinSpoolMessages._Opnum101NotUsedOnWireRequest;
                case $ 102 =>
                    optional _WinSpoolMessages._RpcGetCorePrinterDriversRequest m = NdrDecoder<_WinSpoolMessages._RpcGetCorePrinterDriversRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: RpcGetCorePrinterDrivers request (opnum 102) is not decoded successfully";
                    req = m as _WinSpoolMessages._RpcGetCorePrinterDriversRequest;
                case $ 103 =>
                    optional _WinSpoolMessages._Opnum103NotUsedOnWireRequest m = NdrDecoder<_WinSpoolMessages._Opnum103NotUsedOnWireRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: Opnum103NotUsedOnWire request (opnum 103) is not decoded successfully";
                    req = m as _WinSpoolMessages._Opnum103NotUsedOnWireRequest;
                case $ 104 =>
                    optional _WinSpoolMessages._RpcGetPrinterDriverPackagePathRequest m = NdrDecoder<_WinSpoolMessages._RpcGetPrinterDriverPackagePathRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: RpcGetPrinterDriverPackagePath request (opnum 104) is not decoded successfully";
                    req = m as _WinSpoolMessages._RpcGetPrinterDriverPackagePathRequest;
                case $ 105 =>
                    optional _WinSpoolMessages._Opnum105NotUsedOnWireRequest m = NdrDecoder<_WinSpoolMessages._Opnum105NotUsedOnWireRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: Opnum105NotUsedOnWire request (opnum 105) is not decoded successfully";
                    req = m as _WinSpoolMessages._Opnum105NotUsedOnWireRequest;
                case $ 106 =>
                    optional _WinSpoolMessages._Opnum106NotUsedOnWireRequest m = NdrDecoder<_WinSpoolMessages._Opnum106NotUsedOnWireRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: Opnum106NotUsedOnWire request (opnum 106) is not decoded successfully";
                    req = m as _WinSpoolMessages._Opnum106NotUsedOnWireRequest;
                case $ 107 =>
                    optional _WinSpoolMessages._Opnum107NotUsedOnWireRequest m = NdrDecoder<_WinSpoolMessages._Opnum107NotUsedOnWireRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: Opnum107NotUsedOnWire request (opnum 107) is not decoded successfully";
                    req = m as _WinSpoolMessages._Opnum107NotUsedOnWireRequest;
                case $ 108 =>
                    optional _WinSpoolMessages._Opnum108NotUsedOnWireRequest m = NdrDecoder<_WinSpoolMessages._Opnum108NotUsedOnWireRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: Opnum108NotUsedOnWire request (opnum 108) is not decoded successfully";
                    req = m as _WinSpoolMessages._Opnum108NotUsedOnWireRequest;
                case $ 109 =>
                    optional _WinSpoolMessages._Opnum109NotUsedOnWireRequest m = NdrDecoder<_WinSpoolMessages._Opnum109NotUsedOnWireRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: Opnum109NotUsedOnWire request (opnum 109) is not decoded successfully";
                    req = m as _WinSpoolMessages._Opnum109NotUsedOnWireRequest;
                case $ 110 =>
                    optional _WinSpoolMessages._RpcGetJobNamedPropertyValueRequest m = NdrDecoder<_WinSpoolMessages._RpcGetJobNamedPropertyValueRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: RpcGetJobNamedPropertyValue request (opnum 110) is not decoded successfully";
                    req = m as _WinSpoolMessages._RpcGetJobNamedPropertyValueRequest;
                case $ 111 =>
                    optional _WinSpoolMessages._RpcSetJobNamedPropertyRequest m = NdrDecoder<_WinSpoolMessages._RpcSetJobNamedPropertyRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: RpcSetJobNamedProperty request (opnum 111) is not decoded successfully";
                    req = m as _WinSpoolMessages._RpcSetJobNamedPropertyRequest;
                case $ 112 =>
                    optional _WinSpoolMessages._RpcDeleteJobNamedPropertyRequest m = NdrDecoder<_WinSpoolMessages._RpcDeleteJobNamedPropertyRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: RpcDeleteJobNamedProperty request (opnum 112) is not decoded successfully";
                    req = m as _WinSpoolMessages._RpcDeleteJobNamedPropertyRequest;
                case $ 113 =>
                    optional _WinSpoolMessages._RpcEnumJobNamedPropertiesRequest m = NdrDecoder<_WinSpoolMessages._RpcEnumJobNamedPropertiesRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: RpcEnumJobNamedProperties request (opnum 113) is not decoded successfully";
                    req = m as _WinSpoolMessages._RpcEnumJobNamedPropertiesRequest;
                case $ 114 =>
                    optional _WinSpoolMessages._Opnum114NotUsedOnWireRequest m = NdrDecoder<_WinSpoolMessages._Opnum114NotUsedOnWireRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: Opnum114NotUsedOnWire request (opnum 114) is not decoded successfully";
                    req = m as _WinSpoolMessages._Opnum114NotUsedOnWireRequest;
                case $ 115 =>
                    optional _WinSpoolMessages._Opnum115NotUsedOnWireRequest m = NdrDecoder<_WinSpoolMessages._Opnum115NotUsedOnWireRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: Opnum115NotUsedOnWire request (opnum 115) is not decoded successfully";
                    req = m as _WinSpoolMessages._Opnum115NotUsedOnWireRequest;
                case $ 116 =>
                    optional _WinSpoolMessages._RpcLogJobInfoForBranchOfficeRequest m = NdrDecoder<_WinSpoolMessages._RpcLogJobInfoForBranchOfficeRequest>(rpcMsg.StubData, ndrInfo);
                    if (m == nothing)
                        throw "RPRN: RpcLogJobInfoForBranchOffice request (opnum 116) is not decoded successfully";
                    req = m as _WinSpoolMessages._RpcLogJobInfoForBranchOfficeRequest;
                default =>
                    req = BinaryDecoder<_ExtendedWinSpoolMessages.UnknownRequest>(rpcMsg.StubData) as _ExtendedWinSpoolMessages.UnknownRequest;
            }
        }
        req.Origins = [rpcMsg as any message];
        if (rpcMsg.CallId in requestCache)
        {
            ReportInsufficientData(requestCache[rpcMsg.CallId],
                                   DiagnosisLevel.Warning,
                                   "RPRN: Incomplete WinSpool operation due to response is missing when operation is constructed.");
            dispatch endpoint  _ExtendedRprnService over server accepts requestCache[rpcMsg.CallId];
        }
        requestCache[rpcMsg.CallId] = req;
    }
    process server issues
                rpcMsg:RpcconnResponseHdrT
                    where server.MatchInterface(rpcMsg.PContId, {12345678-1234-abcd-ef00-0123456789ab}, 1)
    {
        if (rpcMsg#RpcOpnum == nothing)
        {
            assert !(rpcMsg.CallId in requestCache) ,
                "Found request with CallId " +
                (rpcMsg.CallId.ToString() +
                 " but the response with same CallId doesn\'t have annotation #RpcOpnum attached!");
            var res = BinaryDecoder<_ExtendedWinSpoolMessages.UnknownResponse>(rpcMsg.StubData) as _ExtendedWinSpoolMessages.UnknownResponse;
            ReportInsufficientData(res,
                                   DiagnosisLevel.Warning,
                                   "RPRN: Incomplete WinSpool operation due to request is missing when operation is constructed.");
            dispatch endpoint  _ExtendedRprnService over server issues res;
            return;
        }
        any message req;
        if (rpcMsg.CallId in requestCache)
        {
            req = requestCache[rpcMsg.CallId];
            requestCache = requestCache.Remove(rpcMsg.CallId);
        }
        if (rpcMsg.IsEncrypted &&
            (rpcMsg#RpcOpnum as ushort) is _WinSpoolOpnums)
        {
            var res = BinaryDecoder<_ExtendedWinSpoolMessages.EncryptedResponse>(rpcMsg.StubData) as _ExtendedWinSpoolMessages.EncryptedResponse;
            res#RpcOpnum = rpcMsg#RpcOpnum as ushort;
            res.Origins = [rpcMsg as any message];
            if (req == null)
            {
                ReportInsufficientData(res,
                                       DiagnosisLevel.Warning,
                                       "RPRN: Incomplete WinSpool operation due to request is missing when operation is constructed.");
                dispatch endpoint  _ExtendedRprnService over server issues res;
            }
            else
            {
                var op = new _ExtendedWinSpool.EncryptedOperation{Opnum = rpcMsg#RpcOpnum as ushort};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  _ExtendedRprnService over server accepts op;
            }
            return;
        }
        NdrInfo ndrInfo =
            new NdrInfo {isBigEndian = rpcMsg.IsBigEndian,
                         isNdr64 = server.IsNdr64(rpcMsg.PContId),
                         isMsUnion = false,
                         defaultPointerKind = 2};
        switch (rpcMsg#RpcOpnum as ushort)
        {
            case $ 0 =>
                if (req == null ||
                    !(req is
                           _WinSpoolMessages._RpcEnumPrintersRequest))
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    ReportInsufficientData(req,
                                           DiagnosisLevel.Warning,
                                           "RPRN: RpcEnumPrinters response (opnum 0) is not decoded successfully, because the request is missing.");
                    return;
                }
                _WinSpoolMessages._RpcEnumPrintersRequest req0 = req as _WinSpoolMessages._RpcEnumPrintersRequest;
                optional _WinSpoolMessages._RpcEnumPrintersResponse[req0.Level, req0.cbBuf] m = NdrDecoder<_WinSpoolMessages._RpcEnumPrintersResponse[req0.Level, req0.cbBuf]>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: RpcEnumPrinters response (opnum 0) is not decoded successfully";
                }
                _WinSpoolMessages._RpcEnumPrintersResponse[req0.Level, req0.cbBuf] res = m as _WinSpoolMessages._RpcEnumPrintersResponse;
                res.Origins = [rpcMsg as any message];
                WinSpool.RpcEnumPrinters op = new WinSpool.RpcEnumPrinters
                        {Flags = req0.Flags,
                         Name = req0.Name,
                         Level = req0.Level,
                         pPrinterEnum = res.pPrinterEnum,
                         cbBuf = req0.cbBuf,
                         pcbNeeded = res.pcbNeeded,
                         pcReturned = res.pcReturned,
                         ReturnValue = res.ReturnValue};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 1 =>
                _WinSpoolMessages._RpcOpenPrinterRequest req0 = req as _WinSpoolMessages._RpcOpenPrinterRequest;
                optional _WinSpoolMessages._RpcOpenPrinterResponse m = NdrDecoder<_WinSpoolMessages._RpcOpenPrinterResponse>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: RpcOpenPrinter response (opnum 1) is not decoded successfully";
                }
                _WinSpoolMessages._RpcOpenPrinterResponse res = m as _WinSpoolMessages._RpcOpenPrinterResponse;
                if (req0 == null)
                {
                    if (req != null)
                    {
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                        ReportInsufficientData(req,
                                               DiagnosisLevel.Warning,
                                               "RPRN: Operation can\'t be constructed, because the response is missing.");
                    }
                    dispatch endpoint _ExtendedRprnService over server issues res;
                    ReportInsufficientData(res,
                                           DiagnosisLevel.Warning,
                                           "RPRN: Operation can\'t be constructed, because the request is missing.");
                    return;
                }
                res.Origins = [rpcMsg as any message];
                WinSpool.RpcOpenPrinter op = new WinSpool.RpcOpenPrinter
                        {pPrinterName = req0.pPrinterName,
                         pHandle = res.pHandle,
                         pDatatype = req0.pDatatype,
                         pDevModeContainer = req0.pDevModeContainer,
                         AccessRequired = req0.AccessRequired,
                         ReturnValue = res.ReturnValue};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 2 =>
                _WinSpoolMessages._RpcSetJobRequest req0 = req as _WinSpoolMessages._RpcSetJobRequest;
                optional _WinSpoolMessages._RpcSetJobResponse m = NdrDecoder<_WinSpoolMessages._RpcSetJobResponse>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: RpcSetJob response (opnum 2) is not decoded successfully";
                }
                _WinSpoolMessages._RpcSetJobResponse res = m as _WinSpoolMessages._RpcSetJobResponse;
                if (req0 == null)
                {
                    if (req != null)
                    {
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                        ReportInsufficientData(req,
                                               DiagnosisLevel.Warning,
                                               "RPRN: Operation can\'t be constructed, because the response is missing.");
                    }
                    dispatch endpoint _ExtendedRprnService over server issues res;
                    ReportInsufficientData(res,
                                           DiagnosisLevel.Warning,
                                           "RPRN: Operation can\'t be constructed, because the request is missing.");
                    return;
                }
                res.Origins = [rpcMsg as any message];
                WinSpool.RpcSetJob op = new WinSpool.RpcSetJob
                        {hPrinter = req0.hPrinter,
                         JobId = req0.JobId,
                         pJobContainer = req0.pJobContainer,
                         Command = req0.Command,
                         ReturnValue = res.ReturnValue};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 3 =>
                if (req == null ||
                    !(req is _WinSpoolMessages._RpcGetJobRequest))
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    ReportInsufficientData(req,
                                           DiagnosisLevel.Warning,
                                           "RPRN: RpcGetJob response (opnum 3) is not decoded successfully, because the request is missing.");
                    return;
                }
                _WinSpoolMessages._RpcGetJobRequest req0 = req as _WinSpoolMessages._RpcGetJobRequest;
                optional _WinSpoolMessages._RpcGetJobResponse[req0.Level, req0.cbBuf] m = NdrDecoder<_WinSpoolMessages._RpcGetJobResponse[req0.Level, req0.cbBuf]>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: RpcGetJob response (opnum 3) is not decoded successfully";
                }
                _WinSpoolMessages._RpcGetJobResponse[req0.Level, req0.cbBuf] res = m as _WinSpoolMessages._RpcGetJobResponse;
                res.Origins = [rpcMsg as any message];
                WinSpool.RpcGetJob op = new WinSpool.RpcGetJob
                        {hPrinter = req0.hPrinter,
                         JobId = req0.JobId,
                         Level = req0.Level,
                         pJob = res.pJob,
                         cbBuf = req0.cbBuf,
                         pcbNeeded = res.pcbNeeded,
                         ReturnValue = res.ReturnValue};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 4 =>
                if (req == null ||
                    !(req is _WinSpoolMessages._RpcEnumJobsRequest))
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    ReportInsufficientData(req,
                                           DiagnosisLevel.Warning,
                                           "RPRN: RpcEnumJobs response (opnum 4) is not decoded successfully, because the request is missing.");
                    return;
                }
                _WinSpoolMessages._RpcEnumJobsRequest req0 = req as _WinSpoolMessages._RpcEnumJobsRequest;
                optional _WinSpoolMessages._RpcEnumJobsResponse[req0.Level, req0.cbBuf] m = 
                    NdrDecoder<_WinSpoolMessages._RpcEnumJobsResponse[req0.Level, req0.cbBuf]>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: RpcEnumJobs response (opnum 4) is not decoded successfully";
                }
                _WinSpoolMessages._RpcEnumJobsResponse[req0.Level, req0.cbBuf] res = m as _WinSpoolMessages._RpcEnumJobsResponse;
                res.Origins = [rpcMsg as any message];
                WinSpool.RpcEnumJobs op = new WinSpool.RpcEnumJobs
                        {hPrinter = req0.hPrinter,
                         FirstJob = req0.FirstJob,
                         NoJobs = req0.NoJobs,
                         Level = req0.Level,
                         pJob = res.pJob,
                         cbBuf = req0.cbBuf,
                         pcbNeeded = res.pcbNeeded,
                         pcReturned = res.pcReturned,
                         ReturnValue = res.ReturnValue};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 5 =>
                _WinSpoolMessages._RpcAddPrinterRequest req0 = req as _WinSpoolMessages._RpcAddPrinterRequest;
                optional _WinSpoolMessages._RpcAddPrinterResponse m = NdrDecoder<_WinSpoolMessages._RpcAddPrinterResponse>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: RpcAddPrinter response (opnum 5) is not decoded successfully";
                }
                _WinSpoolMessages._RpcAddPrinterResponse res = m as _WinSpoolMessages._RpcAddPrinterResponse;
                if (req0 == null)
                {
                    if (req != null)
                    {
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                        ReportInsufficientData(req,
                                               DiagnosisLevel.Warning,
                                               "RPRN: Operation can\'t be constructed, because the response is missing.");
                    }
                    dispatch endpoint _ExtendedRprnService over server issues res;
                    ReportInsufficientData(res,
                                           DiagnosisLevel.Warning,
                                           "RPRN: Operation can\'t be constructed, because the request is missing.");
                    return;
                }
                res.Origins = [rpcMsg as any message];
                WinSpool.RpcAddPrinter op = new WinSpool.RpcAddPrinter
                        {pName = req0.pName,
                         pPrinterContainer = req0.pPrinterContainer,
                         pDevModeContainer = req0.pDevModeContainer,
                         pSecurityContainer = req0.pSecurityContainer,
                         pHandle = res.pHandle,
                         ReturnValue = res.ReturnValue};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 6 =>
                _WinSpoolMessages._RpcDeletePrinterRequest req0 = req as _WinSpoolMessages._RpcDeletePrinterRequest;
                optional _WinSpoolMessages._RpcDeletePrinterResponse m = NdrDecoder<_WinSpoolMessages._RpcDeletePrinterResponse>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: RpcDeletePrinter response (opnum 6) is not decoded successfully";
                }
                _WinSpoolMessages._RpcDeletePrinterResponse res = m as _WinSpoolMessages._RpcDeletePrinterResponse;
                if (req0 == null)
                {
                    if (req != null)
                    {
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                        ReportInsufficientData(req,
                                               DiagnosisLevel.Warning,
                                               "RPRN: Operation can\'t be constructed, because the response is missing.");
                    }
                    dispatch endpoint _ExtendedRprnService over server issues res;
                    ReportInsufficientData(res,
                                           DiagnosisLevel.Warning,
                                           "RPRN: Operation can\'t be constructed, because the request is missing.");
                    return;
                }
                res.Origins = [rpcMsg as any message];
                WinSpool.RpcDeletePrinter op = new WinSpool.RpcDeletePrinter
                        {hPrinter = req0.hPrinter,
                         ReturnValue = res.ReturnValue};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 7 =>
                _WinSpoolMessages._RpcSetPrinterRequest req0 = req as _WinSpoolMessages._RpcSetPrinterRequest;
                optional _WinSpoolMessages._RpcSetPrinterResponse m = NdrDecoder<_WinSpoolMessages._RpcSetPrinterResponse>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: RpcSetPrinter response (opnum 7) is not decoded successfully";
                }
                _WinSpoolMessages._RpcSetPrinterResponse res = m as _WinSpoolMessages._RpcSetPrinterResponse;
                if (req0 == null)
                {
                    if (req != null)
                    {
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                        ReportInsufficientData(req,
                                               DiagnosisLevel.Warning,
                                               "RPRN: Operation can\'t be constructed, because the response is missing.");
                    }
                    dispatch endpoint _ExtendedRprnService over server issues res;
                    ReportInsufficientData(res,
                                           DiagnosisLevel.Warning,
                                           "RPRN: Operation can\'t be constructed, because the request is missing.");
                    return;
                }
                res.Origins = [rpcMsg as any message];
                WinSpool.RpcSetPrinter op = new WinSpool.RpcSetPrinter
                        {hPrinter = req0.hPrinter,
                         pPrinterContainer = req0.pPrinterContainer,
                         pDevModeContainer = req0.pDevModeContainer,
                         pSecurityContainer = req0.pSecurityContainer,
                         Command = req0.Command,
                         ReturnValue = res.ReturnValue};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 8 =>
                if (req == null ||
                    !(req is _WinSpoolMessages._RpcGetPrinterRequest))
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    ReportInsufficientData(req,
                                           DiagnosisLevel.Warning,
                                           "RPRN: RpcGetPrinter response (opnum 8) is not decoded successfully, because the request is missing.");
                    return;
                }
                _WinSpoolMessages._RpcGetPrinterRequest req0 = req as _WinSpoolMessages._RpcGetPrinterRequest;
                optional _WinSpoolMessages._RpcGetPrinterResponse[req0.Level, req0.cbBuf] m = NdrDecoder<_WinSpoolMessages._RpcGetPrinterResponse[req0.Level, req0.cbBuf]>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: RpcGetPrinter response (opnum 8) is not decoded successfully";
                }
                _WinSpoolMessages._RpcGetPrinterResponse[req0.Level, req0.cbBuf] res = m as _WinSpoolMessages._RpcGetPrinterResponse;
                res.Origins = [rpcMsg as any message];
                WinSpool.RpcGetPrinter op = new WinSpool.RpcGetPrinter
                        {hPrinter = req0.hPrinter,
                         Level = req0.Level,
                         pPrinter = res.pPrinter,
                         cbBuf = req0.cbBuf,
                         pcbNeeded = res.pcbNeeded,
                         ReturnValue = res.ReturnValue};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 9 =>
                _WinSpoolMessages._RpcAddPrinterDriverRequest req0 = req as _WinSpoolMessages._RpcAddPrinterDriverRequest;
                optional _WinSpoolMessages._RpcAddPrinterDriverResponse m = NdrDecoder<_WinSpoolMessages._RpcAddPrinterDriverResponse>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: RpcAddPrinterDriver response (opnum 9) is not decoded successfully";
                }
                _WinSpoolMessages._RpcAddPrinterDriverResponse res = m as _WinSpoolMessages._RpcAddPrinterDriverResponse;
                if (req0 == null)
                {
                    if (req != null)
                    {
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                        ReportInsufficientData(req,
                                               DiagnosisLevel.Warning,
                                               "RPRN: Operation can\'t be constructed, because the response is missing.");
                    }
                    dispatch endpoint _ExtendedRprnService over server issues res;
                    ReportInsufficientData(res,
                                           DiagnosisLevel.Warning,
                                           "RPRN: Operation can\'t be constructed, because the request is missing.");
                    return;
                }
                res.Origins = [rpcMsg as any message];
                WinSpool.RpcAddPrinterDriver op = new WinSpool.RpcAddPrinterDriver
                        {pName = req0.pName,
                         pDriverContainer = req0.pDriverContainer,
                         ReturnValue = res.ReturnValue};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 10 =>
                if (req == null ||
                    !(req is
                           _WinSpoolMessages._RpcEnumPrinterDriversRequest))
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    ReportInsufficientData(req,
                                           DiagnosisLevel.Warning,
                                           "RPRN: RpcEnumPrinterDrivers response (opnum 10) is not decoded successfully, because the request is missing.");
                    return;
                }
                _WinSpoolMessages._RpcEnumPrinterDriversRequest req0 = req as _WinSpoolMessages._RpcEnumPrinterDriversRequest;
                optional _WinSpoolMessages._RpcEnumPrinterDriversResponse[req0.Level, req0.cbBuf] m = NdrDecoder<_WinSpoolMessages._RpcEnumPrinterDriversResponse[req0.Level, req0.cbBuf]>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: RpcEnumPrinterDrivers response (opnum 10) is not decoded successfully";
                }
                _WinSpoolMessages._RpcEnumPrinterDriversResponse[req0.Level, req0.cbBuf] res = m as _WinSpoolMessages._RpcEnumPrinterDriversResponse;
                res.Origins = [rpcMsg as any message];
                WinSpool.RpcEnumPrinterDrivers op = new WinSpool.RpcEnumPrinterDrivers
                        {pName = req0.pName,
                         pEnvironment = req0.pEnvironment,
                         Level = req0.Level,
                         pDrivers = res.pDrivers,
                         cbBuf = req0.cbBuf,
                         pcbNeeded = res.pcbNeeded,
                         pcReturned = res.pcReturned,
                         ReturnValue = res.ReturnValue};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 11 =>
                if (req == null ||
                    !(req is
                           _WinSpoolMessages._RpcGetPrinterDriverRequest))
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    ReportInsufficientData(req,
                                           DiagnosisLevel.Warning,
                                           "RPRN: RpcGetPrinterDriver response (opnum 11) is not decoded successfully, because the request is missing.");
                    return;
                }
                _WinSpoolMessages._RpcGetPrinterDriverRequest req0 = req as _WinSpoolMessages._RpcGetPrinterDriverRequest;
                optional _WinSpoolMessages._RpcGetPrinterDriverResponse[req0.Level, req0.cbBuf] m = NdrDecoder<_WinSpoolMessages._RpcGetPrinterDriverResponse[req0.Level, req0.cbBuf]>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: RpcGetPrinterDriver response (opnum 11) is not decoded successfully";
                }
                _WinSpoolMessages._RpcGetPrinterDriverResponse[req0.Level, req0.cbBuf] res = m as _WinSpoolMessages._RpcGetPrinterDriverResponse;
                res.Origins = [rpcMsg as any message];
                WinSpool.RpcGetPrinterDriver op = new WinSpool.RpcGetPrinterDriver
                        {hPrinter = req0.hPrinter,
                         pEnvironment = req0.pEnvironment,
                         Level = req0.Level,
                         pDriver = res.pDriver,
                         cbBuf = req0.cbBuf,
                         pcbNeeded = res.pcbNeeded,
                         ReturnValue = res.ReturnValue};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 12 =>
                if (req == null ||
                    !(req is
                           _WinSpoolMessages._RpcGetPrinterDriverDirectoryRequest))
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    ReportInsufficientData(req,
                                           DiagnosisLevel.Warning,
                                           "RPRN: RpcGetPrinterDriverDirectory response (opnum 12) is not decoded successfully, because the request is missing.");
                    return;
                }
                _WinSpoolMessages._RpcGetPrinterDriverDirectoryRequest req0 = req as _WinSpoolMessages._RpcGetPrinterDriverDirectoryRequest;
                optional _WinSpoolMessages._RpcGetPrinterDriverDirectoryResponse[req0.cbBuf] m = NdrDecoder<_WinSpoolMessages._RpcGetPrinterDriverDirectoryResponse[req0.cbBuf]>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: RpcGetPrinterDriverDirectory response (opnum 12) is not decoded successfully";
                }
                _WinSpoolMessages._RpcGetPrinterDriverDirectoryResponse[req0.cbBuf] res = m as _WinSpoolMessages._RpcGetPrinterDriverDirectoryResponse;
                res.Origins = [rpcMsg as any message];
                WinSpool.RpcGetPrinterDriverDirectory op = new WinSpool.RpcGetPrinterDriverDirectory
                        {pName = req0.pName,
                         pEnvironment = req0.pEnvironment,
                         Level = req0.Level,
                         pDriverDirectory = res.pDriverDirectory,
                         cbBuf = req0.cbBuf,
                         pcbNeeded = res.pcbNeeded,
                         ReturnValue = res.ReturnValue};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 13 =>
                _WinSpoolMessages._RpcDeletePrinterDriverRequest req0 = req as _WinSpoolMessages._RpcDeletePrinterDriverRequest;
                optional _WinSpoolMessages._RpcDeletePrinterDriverResponse m = NdrDecoder<_WinSpoolMessages._RpcDeletePrinterDriverResponse>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: RpcDeletePrinterDriver response (opnum 13) is not decoded successfully";
                }
                _WinSpoolMessages._RpcDeletePrinterDriverResponse res = m as _WinSpoolMessages._RpcDeletePrinterDriverResponse;
                if (req0 == null)
                {
                    if (req != null)
                    {
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                        ReportInsufficientData(req,
                                               DiagnosisLevel.Warning,
                                               "RPRN: Operation can\'t be constructed, because the response is missing.");
                    }
                    dispatch endpoint _ExtendedRprnService over server issues res;
                    ReportInsufficientData(res,
                                           DiagnosisLevel.Warning,
                                           "RPRN: Operation can\'t be constructed, because the request is missing.");
                    return;
                }
                res.Origins = [rpcMsg as any message];
                WinSpool.RpcDeletePrinterDriver op = new WinSpool.RpcDeletePrinterDriver
                        {pName = req0.pName,
                         pEnvironment = req0.pEnvironment,
                         pDriverName = req0.pDriverName,
                         ReturnValue = res.ReturnValue};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 14 =>
                _WinSpoolMessages._RpcAddPrintProcessorRequest req0 = req as _WinSpoolMessages._RpcAddPrintProcessorRequest;
                optional _WinSpoolMessages._RpcAddPrintProcessorResponse m = NdrDecoder<_WinSpoolMessages._RpcAddPrintProcessorResponse>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: RpcAddPrintProcessor response (opnum 14) is not decoded successfully";
                }
                _WinSpoolMessages._RpcAddPrintProcessorResponse res = m as _WinSpoolMessages._RpcAddPrintProcessorResponse;
                if (req0 == null)
                {
                    if (req != null)
                    {
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                        ReportInsufficientData(req,
                                               DiagnosisLevel.Warning,
                                               "RPRN: Operation can\'t be constructed, because the response is missing.");
                    }
                    dispatch endpoint _ExtendedRprnService over server issues res;
                    ReportInsufficientData(res,
                                           DiagnosisLevel.Warning,
                                           "RPRN: Operation can\'t be constructed, because the request is missing.");
                    return;
                }
                res.Origins = [rpcMsg as any message];
                WinSpool.RpcAddPrintProcessor op = new WinSpool.RpcAddPrintProcessor
                        {pName = req0.pName,
                         pEnvironment = req0.pEnvironment,
                         pPathName = req0.pPathName,
                         pPrintProcessorName = req0.pPrintProcessorName,
                         ReturnValue = res.ReturnValue};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 15 =>
                if (req == null ||
                    !(req is
                           _WinSpoolMessages._RpcEnumPrintProcessorsRequest))
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    ReportInsufficientData(req,
                                           DiagnosisLevel.Warning,
                                           "RPRN: RpcEnumPrintProcessors response (opnum 15) is not decoded successfully, because the request is missing.");
                    return;
                }
                _WinSpoolMessages._RpcEnumPrintProcessorsRequest req0 = req as _WinSpoolMessages._RpcEnumPrintProcessorsRequest;
                optional _WinSpoolMessages._RpcEnumPrintProcessorsResponse[req0.cbBuf] m = NdrDecoder<_WinSpoolMessages._RpcEnumPrintProcessorsResponse[req0.cbBuf]>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: RpcEnumPrintProcessors response (opnum 15) is not decoded successfully";
                }
                _WinSpoolMessages._RpcEnumPrintProcessorsResponse[req0.cbBuf] res = m as _WinSpoolMessages._RpcEnumPrintProcessorsResponse;
                res.Origins = [rpcMsg as any message];
                WinSpool.RpcEnumPrintProcessors op = new WinSpool.RpcEnumPrintProcessors
                        {pName = req0.pName,
                         pEnvironment = req0.pEnvironment,
                         Level = req0.Level,
                         pPrintProcessorInfo = res.pPrintProcessorInfo,
                         cbBuf = req0.cbBuf,
                         pcbNeeded = res.pcbNeeded,
                         pcReturned = res.pcReturned,
                         ReturnValue = res.ReturnValue};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 16 =>
                if (req == null ||
                    !(req is
                           _WinSpoolMessages._RpcGetPrintProcessorDirectoryRequest))
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    ReportInsufficientData(req,
                                           DiagnosisLevel.Warning,
                                           "RPRN: RpcGetPrintProcessorDirectory response (opnum 16) is not decoded successfully, because the request is missing.");
                    return;
                }
                _WinSpoolMessages._RpcGetPrintProcessorDirectoryRequest req0 = 
                    req as _WinSpoolMessages._RpcGetPrintProcessorDirectoryRequest;
                optional _WinSpoolMessages._RpcGetPrintProcessorDirectoryResponse[req0.cbBuf] m = 
                    NdrDecoder<_WinSpoolMessages._RpcGetPrintProcessorDirectoryResponse[req0.cbBuf]>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: RpcGetPrintProcessorDirectory response (opnum 16) is not decoded successfully";
                }
                _WinSpoolMessages._RpcGetPrintProcessorDirectoryResponse[req0.cbBuf] res = m as _WinSpoolMessages._RpcGetPrintProcessorDirectoryResponse;
                res.Origins = [rpcMsg as any message];
                WinSpool.RpcGetPrintProcessorDirectory op = new WinSpool.RpcGetPrintProcessorDirectory
                        {pName = req0.pName,
                         pEnvironment = req0.pEnvironment,
                         Level = req0.Level,
                         pPrintProcessorDirectory = res.pPrintProcessorDirectory,
                         cbBuf = req0.cbBuf,
                         pcbNeeded = res.pcbNeeded,
                         ReturnValue = res.ReturnValue};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 17 =>
                _WinSpoolMessages._RpcStartDocPrinterRequest req0 = req as _WinSpoolMessages._RpcStartDocPrinterRequest;
                optional _WinSpoolMessages._RpcStartDocPrinterResponse m = NdrDecoder<_WinSpoolMessages._RpcStartDocPrinterResponse>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: RpcStartDocPrinter response (opnum 17) is not decoded successfully";
                }
                _WinSpoolMessages._RpcStartDocPrinterResponse res = m as _WinSpoolMessages._RpcStartDocPrinterResponse;
                if (req0 == null)
                {
                    if (req != null)
                    {
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                        ReportInsufficientData(req,
                                               DiagnosisLevel.Warning,
                                               "RPRN: Operation can\'t be constructed, because the response is missing.");
                    }
                    dispatch endpoint _ExtendedRprnService over server issues res;
                    ReportInsufficientData(res,
                                           DiagnosisLevel.Warning,
                                           "RPRN: Operation can\'t be constructed, because the request is missing.");
                    return;
                }
                res.Origins = [rpcMsg as any message];
                WinSpool.RpcStartDocPrinter op = new WinSpool.RpcStartDocPrinter
                        {hPrinter = req0.hPrinter,
                         pDocInfoContainer = req0.pDocInfoContainer,
                         pJobId = res.pJobId,
                         ReturnValue = res.ReturnValue};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 18 =>
                _WinSpoolMessages._RpcStartPagePrinterRequest req0 = req as _WinSpoolMessages._RpcStartPagePrinterRequest;
                optional _WinSpoolMessages._RpcStartPagePrinterResponse m = NdrDecoder<_WinSpoolMessages._RpcStartPagePrinterResponse>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: RpcStartPagePrinter response (opnum 18) is not decoded successfully";
                }
                _WinSpoolMessages._RpcStartPagePrinterResponse res = m as _WinSpoolMessages._RpcStartPagePrinterResponse;
                if (req0 == null)
                {
                    if (req != null)
                    {
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                        ReportInsufficientData(req,
                                               DiagnosisLevel.Warning,
                                               "RPRN: Operation can\'t be constructed, because the response is missing.");
                    }
                    dispatch endpoint _ExtendedRprnService over server issues res;
                    ReportInsufficientData(res,
                                           DiagnosisLevel.Warning,
                                           "RPRN: Operation can\'t be constructed, because the request is missing.");
                    return;
                }
                res.Origins = [rpcMsg as any message];
                WinSpool.RpcStartPagePrinter op = new WinSpool.RpcStartPagePrinter
                        {hPrinter = req0.hPrinter,
                         ReturnValue = res.ReturnValue};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 19 =>
                _WinSpoolMessages._RpcWritePrinterRequest req0 = req as _WinSpoolMessages._RpcWritePrinterRequest;
                optional _WinSpoolMessages._RpcWritePrinterResponse m = NdrDecoder<_WinSpoolMessages._RpcWritePrinterResponse>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: RpcWritePrinter response (opnum 19) is not decoded successfully";
                }
                _WinSpoolMessages._RpcWritePrinterResponse res = m as _WinSpoolMessages._RpcWritePrinterResponse;
                if (req0 == null)
                {
                    if (req != null)
                    {
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                        ReportInsufficientData(req,
                                               DiagnosisLevel.Warning,
                                               "RPRN: Operation can\'t be constructed, because the response is missing.");
                    }
                    dispatch endpoint _ExtendedRprnService over server issues res;
                    ReportInsufficientData(res,
                                           DiagnosisLevel.Warning,
                                           "RPRN: Operation can\'t be constructed, because the request is missing.");
                    return;
                }
                res.Origins = [rpcMsg as any message];
                WinSpool.RpcWritePrinter op = new WinSpool.RpcWritePrinter
                        {hPrinter = req0.hPrinter,
                         pBuf = req0.pBuf,
                         cbBuf = req0.cbBuf,
                         pcWritten = res.pcWritten,
                         ReturnValue = res.ReturnValue};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 20 =>
                _WinSpoolMessages._RpcEndPagePrinterRequest req0 = req as _WinSpoolMessages._RpcEndPagePrinterRequest;
                optional _WinSpoolMessages._RpcEndPagePrinterResponse m = NdrDecoder<_WinSpoolMessages._RpcEndPagePrinterResponse>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: RpcEndPagePrinter response (opnum 20) is not decoded successfully";
                }
                _WinSpoolMessages._RpcEndPagePrinterResponse res = m as _WinSpoolMessages._RpcEndPagePrinterResponse;
                if (req0 == null)
                {
                    if (req != null)
                    {
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                        ReportInsufficientData(req,
                                               DiagnosisLevel.Warning,
                                               "RPRN: Operation can\'t be constructed, because the response is missing.");
                    }
                    dispatch endpoint _ExtendedRprnService over server issues res;
                    ReportInsufficientData(res,
                                           DiagnosisLevel.Warning,
                                           "RPRN: Operation can\'t be constructed, because the request is missing.");
                    return;
                }
                res.Origins = [rpcMsg as any message];
                WinSpool.RpcEndPagePrinter op = new WinSpool.RpcEndPagePrinter
                        {hPrinter = req0.hPrinter,
                         ReturnValue = res.ReturnValue};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 21 =>
                _WinSpoolMessages._RpcAbortPrinterRequest req0 = req as _WinSpoolMessages._RpcAbortPrinterRequest;
                optional _WinSpoolMessages._RpcAbortPrinterResponse m = NdrDecoder<_WinSpoolMessages._RpcAbortPrinterResponse>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: RpcAbortPrinter response (opnum 21) is not decoded successfully";
                }
                _WinSpoolMessages._RpcAbortPrinterResponse res = m as _WinSpoolMessages._RpcAbortPrinterResponse;
                if (req0 == null)
                {
                    if (req != null)
                    {
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                        ReportInsufficientData(req,
                                               DiagnosisLevel.Warning,
                                               "RPRN: Operation can\'t be constructed, because the response is missing.");
                    }
                    dispatch endpoint _ExtendedRprnService over server issues res;
                    ReportInsufficientData(res,
                                           DiagnosisLevel.Warning,
                                           "RPRN: Operation can\'t be constructed, because the request is missing.");
                    return;
                }
                res.Origins = [rpcMsg as any message];
                WinSpool.RpcAbortPrinter op = new WinSpool.RpcAbortPrinter
                        {hPrinter = req0.hPrinter,
                         ReturnValue = res.ReturnValue};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 22 =>
                if (req == null ||
                    !(req is _WinSpoolMessages._RpcReadPrinterRequest))
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    ReportInsufficientData(req,
                                           DiagnosisLevel.Warning,
                                           "RPRN: RpcReadPrinter response (opnum 22) is not decoded successfully, because the request is missing.");
                    return;
                }
                _WinSpoolMessages._RpcReadPrinterRequest req0 = req as _WinSpoolMessages._RpcReadPrinterRequest;
                optional _WinSpoolMessages._RpcReadPrinterResponse[req0.cbBuf] m = NdrDecoder<_WinSpoolMessages._RpcReadPrinterResponse[req0.cbBuf]>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: RpcReadPrinter response (opnum 22) is not decoded successfully";
                }
                _WinSpoolMessages._RpcReadPrinterResponse[req0.cbBuf] res = m as _WinSpoolMessages._RpcReadPrinterResponse;
                res.Origins = [rpcMsg as any message];
                WinSpool.RpcReadPrinter op = new WinSpool.RpcReadPrinter
                        {hPrinter = req0.hPrinter,
                         pBuf = res.pBuf,
                         cbBuf = req0.cbBuf,
                         pcNoBytesRead = res.pcNoBytesRead,
                         ReturnValue = res.ReturnValue};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 23 =>
                _WinSpoolMessages._RpcEndDocPrinterRequest req0 = req as _WinSpoolMessages._RpcEndDocPrinterRequest;
                optional _WinSpoolMessages._RpcEndDocPrinterResponse m = NdrDecoder<_WinSpoolMessages._RpcEndDocPrinterResponse>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: RpcEndDocPrinter response (opnum 23) is not decoded successfully";
                }
                _WinSpoolMessages._RpcEndDocPrinterResponse res = m as _WinSpoolMessages._RpcEndDocPrinterResponse;
                if (req0 == null)
                {
                    if (req != null)
                    {
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                        ReportInsufficientData(req,
                                               DiagnosisLevel.Warning,
                                               "RPRN: Operation can\'t be constructed, because the response is missing.");
                    }
                    dispatch endpoint _ExtendedRprnService over server issues res;
                    ReportInsufficientData(res,
                                           DiagnosisLevel.Warning,
                                           "RPRN: Operation can\'t be constructed, because the request is missing.");
                    return;
                }
                res.Origins = [rpcMsg as any message];
                WinSpool.RpcEndDocPrinter op = new WinSpool.RpcEndDocPrinter
                        {hPrinter = req0.hPrinter,
                         ReturnValue = res.ReturnValue};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 24 =>
                if (req == null ||
                    !(req is _WinSpoolMessages._RpcAddJobRequest))
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    ReportInsufficientData(req,
                                           DiagnosisLevel.Warning,
                                           "RPRN: RpcAddJob response (opnum 24) is not decoded successfully, because the request is missing.");
                    return;
                }
                _WinSpoolMessages._RpcAddJobRequest req0 = req as _WinSpoolMessages._RpcAddJobRequest;
                optional _WinSpoolMessages._RpcAddJobResponse[req0.cbBuf] m = NdrDecoder<_WinSpoolMessages._RpcAddJobResponse[req0.cbBuf]>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: RpcAddJob response (opnum 24) is not decoded successfully";
                }
                _WinSpoolMessages._RpcAddJobResponse[req0.cbBuf] res = m as _WinSpoolMessages._RpcAddJobResponse;
                res.Origins = [rpcMsg as any message];
                WinSpool.RpcAddJob op = new WinSpool.RpcAddJob
                        {hPrinter = req0.hPrinter,
                         Level = req0.Level,
                         pAddJob = res.pAddJob,
                         cbBuf = req0.cbBuf,
                         pcbNeeded = res.pcbNeeded,
                         ReturnValue = res.ReturnValue};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 25 =>
                _WinSpoolMessages._RpcScheduleJobRequest req0 = req as _WinSpoolMessages._RpcScheduleJobRequest;
                optional _WinSpoolMessages._RpcScheduleJobResponse m = NdrDecoder<_WinSpoolMessages._RpcScheduleJobResponse>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: RpcScheduleJob response (opnum 25) is not decoded successfully";
                }
                _WinSpoolMessages._RpcScheduleJobResponse res = m as _WinSpoolMessages._RpcScheduleJobResponse;
                if (req0 == null)
                {
                    if (req != null)
                    {
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                        ReportInsufficientData(req,
                                               DiagnosisLevel.Warning,
                                               "RPRN: Operation can\'t be constructed, because the response is missing.");
                    }
                    dispatch endpoint _ExtendedRprnService over server issues res;
                    ReportInsufficientData(res,
                                           DiagnosisLevel.Warning,
                                           "RPRN: Operation can\'t be constructed, because the request is missing.");
                    return;
                }
                res.Origins = [rpcMsg as any message];
                WinSpool.RpcScheduleJob op = new WinSpool.RpcScheduleJob
                        {hPrinter = req0.hPrinter,
                         JobId = req0.JobId,
                         ReturnValue = res.ReturnValue};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 26 =>
                _WinSpoolMessages._RpcGetPrinterDataRequest req0 = req as _WinSpoolMessages._RpcGetPrinterDataRequest;
                optional _WinSpoolMessages._RpcGetPrinterDataResponse m = NdrDecoder<_WinSpoolMessages._RpcGetPrinterDataResponse>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: RpcGetPrinterData response (opnum 26) is not decoded successfully";
                }
                _WinSpoolMessages._RpcGetPrinterDataResponse res = m as _WinSpoolMessages._RpcGetPrinterDataResponse;
                if (req0 == null)
                {
                    if (req != null)
                    {
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                        ReportInsufficientData(req,
                                               DiagnosisLevel.Warning,
                                               "RPRN: Operation can\'t be constructed, because the response is missing.");
                    }
                    dispatch endpoint _ExtendedRprnService over server issues res;
                    ReportInsufficientData(res,
                                           DiagnosisLevel.Warning,
                                           "RPRN: Operation can\'t be constructed, because the request is missing.");
                    return;
                }
                res.Origins = [rpcMsg as any message];
                WinSpool.RpcGetPrinterData op = new WinSpool.RpcGetPrinterData
                        {hPrinter = req0.hPrinter,
                         pValueName = req0.pValueName,
                         pType = res.pType,
                         pData = res.pData,
                         nSize = req0.nSize,
                         pcbNeeded = res.pcbNeeded,
                         ReturnValue = res.ReturnValue};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 27 =>
                _WinSpoolMessages._RpcSetPrinterDataRequest req0 = req as _WinSpoolMessages._RpcSetPrinterDataRequest;
                optional _WinSpoolMessages._RpcSetPrinterDataResponse m = NdrDecoder<_WinSpoolMessages._RpcSetPrinterDataResponse>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: RpcSetPrinterData response (opnum 27) is not decoded successfully";
                }
                _WinSpoolMessages._RpcSetPrinterDataResponse res = m as _WinSpoolMessages._RpcSetPrinterDataResponse;
                if (req0 == null)
                {
                    if (req != null)
                    {
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                        ReportInsufficientData(req,
                                               DiagnosisLevel.Warning,
                                               "RPRN: Operation can\'t be constructed, because the response is missing.");
                    }
                    dispatch endpoint _ExtendedRprnService over server issues res;
                    ReportInsufficientData(res,
                                           DiagnosisLevel.Warning,
                                           "RPRN: Operation can\'t be constructed, because the request is missing.");
                    return;
                }
                res.Origins = [rpcMsg as any message];
                WinSpool.RpcSetPrinterData op = new WinSpool.RpcSetPrinterData
                        {hPrinter = req0.hPrinter,
                         pValueName = req0.pValueName,
                         Type = req0.Type,
                         pData = req0.pData,
                         cbData = req0.cbData,
                         ReturnValue = res.ReturnValue};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 28 =>
                _WinSpoolMessages._RpcWaitForPrinterChangeRequest req0 = req as _WinSpoolMessages._RpcWaitForPrinterChangeRequest;
                optional _WinSpoolMessages._RpcWaitForPrinterChangeResponse m = NdrDecoder<_WinSpoolMessages._RpcWaitForPrinterChangeResponse>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: RpcWaitForPrinterChange response (opnum 28) is not decoded successfully";
                }
                _WinSpoolMessages._RpcWaitForPrinterChangeResponse res = m as _WinSpoolMessages._RpcWaitForPrinterChangeResponse;
                if (req0 == null)
                {
                    if (req != null)
                    {
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                        ReportInsufficientData(req,
                                               DiagnosisLevel.Warning,
                                               "RPRN: Operation can\'t be constructed, because the response is missing.");
                    }
                    dispatch endpoint _ExtendedRprnService over server issues res;
                    ReportInsufficientData(res,
                                           DiagnosisLevel.Warning,
                                           "RPRN: Operation can\'t be constructed, because the request is missing.");
                    return;
                }
                res.Origins = [rpcMsg as any message];
                WinSpool.RpcWaitForPrinterChange op = new WinSpool.RpcWaitForPrinterChange
                        {hPrinter = req0.hPrinter,
                         Flags = req0.Flags,
                         pFlags = res.pFlags,
                         ReturnValue = res.ReturnValue};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 29 =>
                _WinSpoolMessages._RpcClosePrinterRequest req0 = req as _WinSpoolMessages._RpcClosePrinterRequest;
                optional _WinSpoolMessages._RpcClosePrinterResponse m = NdrDecoder<_WinSpoolMessages._RpcClosePrinterResponse>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: RpcClosePrinter response (opnum 29) is not decoded successfully";
                }
                _WinSpoolMessages._RpcClosePrinterResponse res = m as _WinSpoolMessages._RpcClosePrinterResponse;
                if (req0 == null)
                {
                    if (req != null)
                    {
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                        ReportInsufficientData(req,
                                               DiagnosisLevel.Warning,
                                               "RPRN: Operation can\'t be constructed, because the response is missing.");
                    }
                    dispatch endpoint _ExtendedRprnService over server issues res;
                    ReportInsufficientData(res,
                                           DiagnosisLevel.Warning,
                                           "RPRN: Operation can\'t be constructed, because the request is missing.");
                    return;
                }
                res.Origins = [rpcMsg as any message];
                WinSpool.RpcClosePrinter op = new WinSpool.RpcClosePrinter
                        {phPrinter = res.phPrinter,
                         ReturnValue = res.ReturnValue};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 30 =>
                _WinSpoolMessages._RpcAddFormRequest req0 = req as _WinSpoolMessages._RpcAddFormRequest;
                optional _WinSpoolMessages._RpcAddFormResponse m = NdrDecoder<_WinSpoolMessages._RpcAddFormResponse>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: RpcAddForm response (opnum 30) is not decoded successfully";
                }
                _WinSpoolMessages._RpcAddFormResponse res = m as _WinSpoolMessages._RpcAddFormResponse;
                if (req0 == null)
                {
                    if (req != null)
                    {
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                        ReportInsufficientData(req,
                                               DiagnosisLevel.Warning,
                                               "RPRN: Operation can\'t be constructed, because the response is missing.");
                    }
                    dispatch endpoint _ExtendedRprnService over server issues res;
                    ReportInsufficientData(res,
                                           DiagnosisLevel.Warning,
                                           "RPRN: Operation can\'t be constructed, because the request is missing.");
                    return;
                }
                res.Origins = [rpcMsg as any message];
                WinSpool.RpcAddForm op = new WinSpool.RpcAddForm
                        {hPrinter = req0.hPrinter,
                         pFormInfoContainer = req0.pFormInfoContainer,
                         ReturnValue = res.ReturnValue};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 31 =>
                _WinSpoolMessages._RpcDeleteFormRequest req0 = req as _WinSpoolMessages._RpcDeleteFormRequest;
                optional _WinSpoolMessages._RpcDeleteFormResponse m = NdrDecoder<_WinSpoolMessages._RpcDeleteFormResponse>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: RpcDeleteForm response (opnum 31) is not decoded successfully";
                }
                _WinSpoolMessages._RpcDeleteFormResponse res = m as _WinSpoolMessages._RpcDeleteFormResponse;
                if (req0 == null)
                {
                    if (req != null)
                    {
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                        ReportInsufficientData(req,
                                               DiagnosisLevel.Warning,
                                               "RPRN: Operation can\'t be constructed, because the response is missing.");
                    }
                    dispatch endpoint _ExtendedRprnService over server issues res;
                    ReportInsufficientData(res,
                                           DiagnosisLevel.Warning,
                                           "RPRN: Operation can\'t be constructed, because the request is missing.");
                    return;
                }
                res.Origins = [rpcMsg as any message];
                WinSpool.RpcDeleteForm op = new WinSpool.RpcDeleteForm
                        {hPrinter = req0.hPrinter,
                         pFormName = req0.pFormName,
                         ReturnValue = res.ReturnValue};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 32 =>
                if (req == null ||
                    !(req is _WinSpoolMessages._RpcGetFormRequest))
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    ReportInsufficientData(req,
                                           DiagnosisLevel.Warning,
                                           "RPRN: RpcGetForm response (opnum 32) is not decoded successfully, because the request is missing.");
                    return;
                }
                _WinSpoolMessages._RpcGetFormRequest req0 = req as _WinSpoolMessages._RpcGetFormRequest;
                optional _WinSpoolMessages._RpcGetFormResponse[req0.Level, req0.cbBuf] m = NdrDecoder<_WinSpoolMessages._RpcGetFormResponse[req0.Level, req0.cbBuf]>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: RpcGetForm response (opnum 32) is not decoded successfully";
                }
                _WinSpoolMessages._RpcGetFormResponse[req0.Level, req0.cbBuf] res = m as _WinSpoolMessages._RpcGetFormResponse;
                res.Origins = [rpcMsg as any message];
                WinSpool.RpcGetForm op = new WinSpool.RpcGetForm
                        {hPrinter = req0.hPrinter,
                         pFormName = req0.pFormName,
                         Level = req0.Level,
                         cbBuf = req0.cbBuf,
                         pForm = res.pForm,
                         pcbNeeded = res.pcbNeeded,
                         ReturnValue = res.ReturnValue};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 33 =>
                _WinSpoolMessages._RpcSetFormRequest req0 = req as _WinSpoolMessages._RpcSetFormRequest;
                optional _WinSpoolMessages._RpcSetFormResponse m = NdrDecoder<_WinSpoolMessages._RpcSetFormResponse>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: RpcSetForm response (opnum 33) is not decoded successfully";
                }
                _WinSpoolMessages._RpcSetFormResponse res = m as _WinSpoolMessages._RpcSetFormResponse;
                if (req0 == null)
                {
                    if (req != null)
                    {
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                        ReportInsufficientData(req,
                                               DiagnosisLevel.Warning,
                                               "RPRN: Operation can\'t be constructed, because the response is missing.");
                    }
                    dispatch endpoint _ExtendedRprnService over server issues res;
                    ReportInsufficientData(res,
                                           DiagnosisLevel.Warning,
                                           "RPRN: Operation can\'t be constructed, because the request is missing.");
                    return;
                }
                res.Origins = [rpcMsg as any message];
                WinSpool.RpcSetForm op = new WinSpool.RpcSetForm
                        {hPrinter = req0.hPrinter,
                         pFormName = req0.pFormName,
                         pFormInfoContainer = req0.pFormInfoContainer,
                         ReturnValue = res.ReturnValue};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 34 =>
                if (req == null ||
                    !(req is _WinSpoolMessages._RpcEnumFormsRequest))
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    ReportInsufficientData(req,
                                           DiagnosisLevel.Warning,
                                           "RPRN: RpcEnumForms response (opnum 34) is not decoded successfully, because the request is missing.");
                    return;
                }
                _WinSpoolMessages._RpcEnumFormsRequest req0 = req as _WinSpoolMessages._RpcEnumFormsRequest;
                optional _WinSpoolMessages._RpcEnumFormsResponse[req0.Level, req0.cbBuf] m = NdrDecoder<_WinSpoolMessages._RpcEnumFormsResponse[req0.Level, req0.cbBuf]>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: RpcEnumForms response (opnum 34) is not decoded successfully";
                }
                _WinSpoolMessages._RpcEnumFormsResponse[req0.Level, req0.cbBuf] res = m as _WinSpoolMessages._RpcEnumFormsResponse;
                res.Origins = [rpcMsg as any message];
                WinSpool.RpcEnumForms op = new WinSpool.RpcEnumForms
                        {hPrinter = req0.hPrinter,
                         Level = req0.Level,
                         cbBuf = req0.cbBuf,
                         pForm = res.pForm,
                         pcbNeeded = res.pcbNeeded,
                         pcReturned = res.pcReturned,
                         ReturnValue = res.ReturnValue};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 35 =>
                if (req == null ||
                    !(req is _WinSpoolMessages._RpcEnumPortsRequest))
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    ReportInsufficientData(req,
                                           DiagnosisLevel.Warning,
                                           "RPRN: RpcEnumPorts response (opnum 35) is not decoded successfully, because the request is missing.");
                    return;
                }
                _WinSpoolMessages._RpcEnumPortsRequest req0 = req as _WinSpoolMessages._RpcEnumPortsRequest;
                optional _WinSpoolMessages._RpcEnumPortsResponse[req0.Level, req0.cbBuf] m = NdrDecoder<_WinSpoolMessages._RpcEnumPortsResponse[req0.Level, req0.cbBuf]>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: RpcEnumPorts response (opnum 35) is not decoded successfully";
                }
                _WinSpoolMessages._RpcEnumPortsResponse[req0.Level, req0.cbBuf] res = m as _WinSpoolMessages._RpcEnumPortsResponse;
                res.Origins = [rpcMsg as any message];
                WinSpool.RpcEnumPorts op = new WinSpool.RpcEnumPorts
                        {pName = req0.pName,
                         Level = req0.Level,
                         pPort = res.pPort,
                         cbBuf = req0.cbBuf,
                         pcbNeeded = res.pcbNeeded,
                         pcReturned = res.pcReturned,
                         ReturnValue = res.ReturnValue};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 36 =>
                if (req == null ||
                    !(req is
                           _WinSpoolMessages._RpcEnumMonitorsRequest))
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    ReportInsufficientData(req,
                                           DiagnosisLevel.Warning,
                                           "RPRN: RpcEnumMonitors response (opnum 36) is not decoded successfully, because the request is missing.");
                    return;
                }
                _WinSpoolMessages._RpcEnumMonitorsRequest req0 = req as _WinSpoolMessages._RpcEnumMonitorsRequest;
                optional _WinSpoolMessages._RpcEnumMonitorsResponse[req0.Level, req0.cbBuf] m = NdrDecoder<_WinSpoolMessages._RpcEnumMonitorsResponse[req0.Level, req0.cbBuf]>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: RpcEnumMonitors response (opnum 36) is not decoded successfully";
                }
                _WinSpoolMessages._RpcEnumMonitorsResponse[req0.Level, req0.cbBuf] res = m as _WinSpoolMessages._RpcEnumMonitorsResponse;
                res.Origins = [rpcMsg as any message];
                WinSpool.RpcEnumMonitors op = new WinSpool.RpcEnumMonitors
                        {pName = req0.pName,
                         Level = req0.Level,
                         pMonitor = res.pMonitor,
                         cbBuf = req0.cbBuf,
                         pcbNeeded = res.pcbNeeded,
                         pcReturned = res.pcReturned,
                         ReturnValue = res.ReturnValue};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 37 =>
                _WinSpoolMessages._Opnum37NotUsedOnWireRequest req0 = req as _WinSpoolMessages._Opnum37NotUsedOnWireRequest;
                optional _WinSpoolMessages._Opnum37NotUsedOnWireResponse m = NdrDecoder<_WinSpoolMessages._Opnum37NotUsedOnWireResponse>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: Opnum37NotUsedOnWire response (opnum 37) is not decoded successfully";
                }
                _WinSpoolMessages._Opnum37NotUsedOnWireResponse res = m as _WinSpoolMessages._Opnum37NotUsedOnWireResponse;
                if (req0 == null)
                {
                    if (req != null)
                    {
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                        ReportInsufficientData(req,
                                               DiagnosisLevel.Warning,
                                               "RPRN: Operation can\'t be constructed, because the response is missing.");
                    }
                    dispatch endpoint _ExtendedRprnService over server issues res;
                    ReportInsufficientData(res,
                                           DiagnosisLevel.Warning,
                                           "RPRN: Operation can\'t be constructed, because the request is missing.");
                    return;
                }
                res.Origins = [rpcMsg as any message];
                WinSpool.Opnum37NotUsedOnWire op = new WinSpool.Opnum37NotUsedOnWire {};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 38 =>
                _WinSpoolMessages._Opnum38NotUsedOnWireRequest req0 = req as _WinSpoolMessages._Opnum38NotUsedOnWireRequest;
                optional _WinSpoolMessages._Opnum38NotUsedOnWireResponse m = NdrDecoder<_WinSpoolMessages._Opnum38NotUsedOnWireResponse>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: Opnum38NotUsedOnWire response (opnum 38) is not decoded successfully";
                }
                _WinSpoolMessages._Opnum38NotUsedOnWireResponse res = m as _WinSpoolMessages._Opnum38NotUsedOnWireResponse;
                if (req0 == null)
                {
                    if (req != null)
                    {
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                        ReportInsufficientData(req,
                                               DiagnosisLevel.Warning,
                                               "RPRN: Operation can\'t be constructed, because the response is missing.");
                    }
                    dispatch endpoint _ExtendedRprnService over server issues res;
                    ReportInsufficientData(res,
                                           DiagnosisLevel.Warning,
                                           "RPRN: Operation can\'t be constructed, because the request is missing.");
                    return;
                }
                res.Origins = [rpcMsg as any message];
                WinSpool.Opnum38NotUsedOnWire op = new WinSpool.Opnum38NotUsedOnWire {};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 39 =>
                _WinSpoolMessages._RpcDeletePortRequest req0 = req as _WinSpoolMessages._RpcDeletePortRequest;
                optional _WinSpoolMessages._RpcDeletePortResponse m = NdrDecoder<_WinSpoolMessages._RpcDeletePortResponse>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: RpcDeletePort response (opnum 39) is not decoded successfully";
                }
                _WinSpoolMessages._RpcDeletePortResponse res = m as _WinSpoolMessages._RpcDeletePortResponse;
                if (req0 == null)
                {
                    if (req != null)
                    {
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                        ReportInsufficientData(req,
                                               DiagnosisLevel.Warning,
                                               "RPRN: Operation can\'t be constructed, because the response is missing.");
                    }
                    dispatch endpoint _ExtendedRprnService over server issues res;
                    ReportInsufficientData(res,
                                           DiagnosisLevel.Warning,
                                           "RPRN: Operation can\'t be constructed, because the request is missing.");
                    return;
                }
                res.Origins = [rpcMsg as any message];
                WinSpool.RpcDeletePort op = new WinSpool.RpcDeletePort
                        {pName = req0.pName,
                         hWnd = req0.hWnd,
                         pPortName = req0.pPortName,
                         ReturnValue = res.ReturnValue};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 40 =>
                _WinSpoolMessages._RpcCreatePrinterICRequest req0 = req as _WinSpoolMessages._RpcCreatePrinterICRequest;
                optional _WinSpoolMessages._RpcCreatePrinterICResponse m = NdrDecoder<_WinSpoolMessages._RpcCreatePrinterICResponse>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: RpcCreatePrinterIC response (opnum 40) is not decoded successfully";
                }
                _WinSpoolMessages._RpcCreatePrinterICResponse res = m as _WinSpoolMessages._RpcCreatePrinterICResponse;
                if (req0 == null)
                {
                    if (req != null)
                    {
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                        ReportInsufficientData(req,
                                               DiagnosisLevel.Warning,
                                               "RPRN: Operation can\'t be constructed, because the response is missing.");
                    }
                    dispatch endpoint _ExtendedRprnService over server issues res;
                    ReportInsufficientData(res,
                                           DiagnosisLevel.Warning,
                                           "RPRN: Operation can\'t be constructed, because the request is missing.");
                    return;
                }
                res.Origins = [rpcMsg as any message];
                WinSpool.RpcCreatePrinterIC op = new WinSpool.RpcCreatePrinterIC
                        {hPrinter = req0.hPrinter,
                         pHandle = res.pHandle,
                         pDevModeContainer = req0.pDevModeContainer,
                         ReturnValue = res.ReturnValue};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 41 =>
                if (req == null ||
                    !(req is
                           _WinSpoolMessages._RpcPlayGdiScriptOnPrinterICRequest))
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    ReportInsufficientData(req,
                                           DiagnosisLevel.Warning,
                                           "RPRN: RpcPlayGdiScriptOnPrinterIC response (opnum 41) is not decoded successfully, because the request is missing.");
                    return;
                }
                _WinSpoolMessages._RpcPlayGdiScriptOnPrinterICRequest req0 = 
                    req as _WinSpoolMessages._RpcPlayGdiScriptOnPrinterICRequest;
                optional _WinSpoolMessages._RpcPlayGdiScriptOnPrinterICResponse[req0.cOut] m = 
                    NdrDecoder<_WinSpoolMessages._RpcPlayGdiScriptOnPrinterICResponse[req0.cOut]>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: RpcPlayGdiScriptOnPrinterIC response (opnum 41) is not decoded successfully";
                }
                _WinSpoolMessages._RpcPlayGdiScriptOnPrinterICResponse[req0.cOut] res = m as _WinSpoolMessages._RpcPlayGdiScriptOnPrinterICResponse;
                res.Origins = [rpcMsg as any message];
                WinSpool.RpcPlayGdiScriptOnPrinterIC op = new WinSpool.RpcPlayGdiScriptOnPrinterIC
                        {hPrinterIC = req0.hPrinterIC,
                         pIn = req0.pIn,
                         cIn = req0.cIn,
                         pOut = res.pOut,
                         cOut = req0.cOut,
                         ul = req0.ul,
                         ReturnValue = res.ReturnValue};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 42 =>
                _WinSpoolMessages._RpcDeletePrinterICRequest req0 = req as _WinSpoolMessages._RpcDeletePrinterICRequest;
                optional _WinSpoolMessages._RpcDeletePrinterICResponse m = NdrDecoder<_WinSpoolMessages._RpcDeletePrinterICResponse>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: RpcDeletePrinterIC response (opnum 42) is not decoded successfully";
                }
                _WinSpoolMessages._RpcDeletePrinterICResponse res = m as _WinSpoolMessages._RpcDeletePrinterICResponse;
                if (req0 == null)
                {
                    if (req != null)
                    {
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                        ReportInsufficientData(req,
                                               DiagnosisLevel.Warning,
                                               "RPRN: Operation can\'t be constructed, because the response is missing.");
                    }
                    dispatch endpoint _ExtendedRprnService over server issues res;
                    ReportInsufficientData(res,
                                           DiagnosisLevel.Warning,
                                           "RPRN: Operation can\'t be constructed, because the request is missing.");
                    return;
                }
                res.Origins = [rpcMsg as any message];
                WinSpool.RpcDeletePrinterIC op = new WinSpool.RpcDeletePrinterIC
                        {phPrinterIC = res.phPrinterIC,
                         ReturnValue = res.ReturnValue};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 43 =>
                _WinSpoolMessages._Opnum43NotUsedOnWireRequest req0 = req as _WinSpoolMessages._Opnum43NotUsedOnWireRequest;
                optional _WinSpoolMessages._Opnum43NotUsedOnWireResponse m = NdrDecoder<_WinSpoolMessages._Opnum43NotUsedOnWireResponse>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: Opnum43NotUsedOnWire response (opnum 43) is not decoded successfully";
                }
                _WinSpoolMessages._Opnum43NotUsedOnWireResponse res = m as _WinSpoolMessages._Opnum43NotUsedOnWireResponse;
                if (req0 == null)
                {
                    if (req != null)
                    {
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                        ReportInsufficientData(req,
                                               DiagnosisLevel.Warning,
                                               "RPRN: Operation can\'t be constructed, because the response is missing.");
                    }
                    dispatch endpoint _ExtendedRprnService over server issues res;
                    ReportInsufficientData(res,
                                           DiagnosisLevel.Warning,
                                           "RPRN: Operation can\'t be constructed, because the request is missing.");
                    return;
                }
                res.Origins = [rpcMsg as any message];
                WinSpool.Opnum43NotUsedOnWire op = new WinSpool.Opnum43NotUsedOnWire {};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 44 =>
                _WinSpoolMessages._Opnum44NotUsedOnWireRequest req0 = req as _WinSpoolMessages._Opnum44NotUsedOnWireRequest;
                optional _WinSpoolMessages._Opnum44NotUsedOnWireResponse m = NdrDecoder<_WinSpoolMessages._Opnum44NotUsedOnWireResponse>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: Opnum44NotUsedOnWire response (opnum 44) is not decoded successfully";
                }
                _WinSpoolMessages._Opnum44NotUsedOnWireResponse res = m as _WinSpoolMessages._Opnum44NotUsedOnWireResponse;
                if (req0 == null)
                {
                    if (req != null)
                    {
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                        ReportInsufficientData(req,
                                               DiagnosisLevel.Warning,
                                               "RPRN: Operation can\'t be constructed, because the response is missing.");
                    }
                    dispatch endpoint _ExtendedRprnService over server issues res;
                    ReportInsufficientData(res,
                                           DiagnosisLevel.Warning,
                                           "RPRN: Operation can\'t be constructed, because the request is missing.");
                    return;
                }
                res.Origins = [rpcMsg as any message];
                WinSpool.Opnum44NotUsedOnWire op = new WinSpool.Opnum44NotUsedOnWire {};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 45 =>
                _WinSpoolMessages._Opnum45NotUsedOnWireRequest req0 = req as _WinSpoolMessages._Opnum45NotUsedOnWireRequest;
                optional _WinSpoolMessages._Opnum45NotUsedOnWireResponse m = NdrDecoder<_WinSpoolMessages._Opnum45NotUsedOnWireResponse>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: Opnum45NotUsedOnWire response (opnum 45) is not decoded successfully";
                }
                _WinSpoolMessages._Opnum45NotUsedOnWireResponse res = m as _WinSpoolMessages._Opnum45NotUsedOnWireResponse;
                if (req0 == null)
                {
                    if (req != null)
                    {
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                        ReportInsufficientData(req,
                                               DiagnosisLevel.Warning,
                                               "RPRN: Operation can\'t be constructed, because the response is missing.");
                    }
                    dispatch endpoint _ExtendedRprnService over server issues res;
                    ReportInsufficientData(res,
                                           DiagnosisLevel.Warning,
                                           "RPRN: Operation can\'t be constructed, because the request is missing.");
                    return;
                }
                res.Origins = [rpcMsg as any message];
                WinSpool.Opnum45NotUsedOnWire op = new WinSpool.Opnum45NotUsedOnWire {};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 46 =>
                _WinSpoolMessages._RpcAddMonitorRequest req0 = req as _WinSpoolMessages._RpcAddMonitorRequest;
                optional _WinSpoolMessages._RpcAddMonitorResponse m = NdrDecoder<_WinSpoolMessages._RpcAddMonitorResponse>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: RpcAddMonitor response (opnum 46) is not decoded successfully";
                }
                _WinSpoolMessages._RpcAddMonitorResponse res = m as _WinSpoolMessages._RpcAddMonitorResponse;
                if (req0 == null)
                {
                    if (req != null)
                    {
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                        ReportInsufficientData(req,
                                               DiagnosisLevel.Warning,
                                               "RPRN: Operation can\'t be constructed, because the response is missing.");
                    }
                    dispatch endpoint _ExtendedRprnService over server issues res;
                    ReportInsufficientData(res,
                                           DiagnosisLevel.Warning,
                                           "RPRN: Operation can\'t be constructed, because the request is missing.");
                    return;
                }
                res.Origins = [rpcMsg as any message];
                WinSpool.RpcAddMonitor op = new WinSpool.RpcAddMonitor
                        {Name = req0.Name,
                         pMonitorContainer = req0.pMonitorContainer,
                         ReturnValue = res.ReturnValue};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 47 =>
                _WinSpoolMessages._RpcDeleteMonitorRequest req0 = req as _WinSpoolMessages._RpcDeleteMonitorRequest;
                optional _WinSpoolMessages._RpcDeleteMonitorResponse m = NdrDecoder<_WinSpoolMessages._RpcDeleteMonitorResponse>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: RpcDeleteMonitor response (opnum 47) is not decoded successfully";
                }
                _WinSpoolMessages._RpcDeleteMonitorResponse res = m as _WinSpoolMessages._RpcDeleteMonitorResponse;
                if (req0 == null)
                {
                    if (req != null)
                    {
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                        ReportInsufficientData(req,
                                               DiagnosisLevel.Warning,
                                               "RPRN: Operation can\'t be constructed, because the response is missing.");
                    }
                    dispatch endpoint _ExtendedRprnService over server issues res;
                    ReportInsufficientData(res,
                                           DiagnosisLevel.Warning,
                                           "RPRN: Operation can\'t be constructed, because the request is missing.");
                    return;
                }
                res.Origins = [rpcMsg as any message];
                WinSpool.RpcDeleteMonitor op = new WinSpool.RpcDeleteMonitor
                        {Name = req0.Name,
                         pEnvironment = req0.pEnvironment,
                         pMonitorName = req0.pMonitorName,
                         ReturnValue = res.ReturnValue};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 48 =>
                _WinSpoolMessages._RpcDeletePrintProcessorRequest req0 = req as _WinSpoolMessages._RpcDeletePrintProcessorRequest;
                optional _WinSpoolMessages._RpcDeletePrintProcessorResponse m = NdrDecoder<_WinSpoolMessages._RpcDeletePrintProcessorResponse>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: RpcDeletePrintProcessor response (opnum 48) is not decoded successfully";
                }
                _WinSpoolMessages._RpcDeletePrintProcessorResponse res = m as _WinSpoolMessages._RpcDeletePrintProcessorResponse;
                if (req0 == null)
                {
                    if (req != null)
                    {
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                        ReportInsufficientData(req,
                                               DiagnosisLevel.Warning,
                                               "RPRN: Operation can\'t be constructed, because the response is missing.");
                    }
                    dispatch endpoint _ExtendedRprnService over server issues res;
                    ReportInsufficientData(res,
                                           DiagnosisLevel.Warning,
                                           "RPRN: Operation can\'t be constructed, because the request is missing.");
                    return;
                }
                res.Origins = [rpcMsg as any message];
                WinSpool.RpcDeletePrintProcessor op = new WinSpool.RpcDeletePrintProcessor
                        {Name = req0.Name,
                         pEnvironment = req0.pEnvironment,
                         pPrintProcessorName = req0.pPrintProcessorName,
                         ReturnValue = res.ReturnValue};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 49 =>
                _WinSpoolMessages._Opnum49NotUsedOnWireRequest req0 = req as _WinSpoolMessages._Opnum49NotUsedOnWireRequest;
                optional _WinSpoolMessages._Opnum49NotUsedOnWireResponse m = NdrDecoder<_WinSpoolMessages._Opnum49NotUsedOnWireResponse>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: Opnum49NotUsedOnWire response (opnum 49) is not decoded successfully";
                }
                _WinSpoolMessages._Opnum49NotUsedOnWireResponse res = m as _WinSpoolMessages._Opnum49NotUsedOnWireResponse;
                if (req0 == null)
                {
                    if (req != null)
                    {
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                        ReportInsufficientData(req,
                                               DiagnosisLevel.Warning,
                                               "RPRN: Operation can\'t be constructed, because the response is missing.");
                    }
                    dispatch endpoint _ExtendedRprnService over server issues res;
                    ReportInsufficientData(res,
                                           DiagnosisLevel.Warning,
                                           "RPRN: Operation can\'t be constructed, because the request is missing.");
                    return;
                }
                res.Origins = [rpcMsg as any message];
                WinSpool.Opnum49NotUsedOnWire op = new WinSpool.Opnum49NotUsedOnWire {};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 50 =>
                _WinSpoolMessages._Opnum50NotUsedOnWireRequest req0 = req as _WinSpoolMessages._Opnum50NotUsedOnWireRequest;
                optional _WinSpoolMessages._Opnum50NotUsedOnWireResponse m = NdrDecoder<_WinSpoolMessages._Opnum50NotUsedOnWireResponse>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: Opnum50NotUsedOnWire response (opnum 50) is not decoded successfully";
                }
                _WinSpoolMessages._Opnum50NotUsedOnWireResponse res = m as _WinSpoolMessages._Opnum50NotUsedOnWireResponse;
                if (req0 == null)
                {
                    if (req != null)
                    {
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                        ReportInsufficientData(req,
                                               DiagnosisLevel.Warning,
                                               "RPRN: Operation can\'t be constructed, because the response is missing.");
                    }
                    dispatch endpoint _ExtendedRprnService over server issues res;
                    ReportInsufficientData(res,
                                           DiagnosisLevel.Warning,
                                           "RPRN: Operation can\'t be constructed, because the request is missing.");
                    return;
                }
                res.Origins = [rpcMsg as any message];
                WinSpool.Opnum50NotUsedOnWire op = new WinSpool.Opnum50NotUsedOnWire {};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 51 =>
                if (req == null ||
                    !(req is
                           _WinSpoolMessages._RpcEnumPrintProcessorDatatypesRequest))
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    ReportInsufficientData(req,
                                           DiagnosisLevel.Warning,
                                           "RPRN: RpcEnumPrintProcessorDatatypes response (opnum 51) is not decoded successfully, because the request is missing.");
                    return;
                }
                _WinSpoolMessages._RpcEnumPrintProcessorDatatypesRequest req0 = 
                    req as _WinSpoolMessages._RpcEnumPrintProcessorDatatypesRequest;
                optional _WinSpoolMessages._RpcEnumPrintProcessorDatatypesResponse[req0.cbBuf] m = 
                    NdrDecoder<_WinSpoolMessages._RpcEnumPrintProcessorDatatypesResponse[req0.cbBuf]>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: RpcEnumPrintProcessorDatatypes response (opnum 51) is not decoded successfully";
                }
                _WinSpoolMessages._RpcEnumPrintProcessorDatatypesResponse[req0.cbBuf] res = 
                    m as _WinSpoolMessages._RpcEnumPrintProcessorDatatypesResponse;
                res.Origins = [rpcMsg as any message];
                WinSpool.RpcEnumPrintProcessorDatatypes op = new WinSpool.RpcEnumPrintProcessorDatatypes
                        {pName = req0.pName,
                         pPrintProcessorName = req0.pPrintProcessorName,
                         Level = req0.Level,
                         pDatatypes = res.pDatatypes,
                         cbBuf = req0.cbBuf,
                         pcbNeeded = res.pcbNeeded,
                         pcReturned = res.pcReturned,
                         ReturnValue = res.ReturnValue};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 52 =>
                _WinSpoolMessages._RpcResetPrinterRequest req0 = req as _WinSpoolMessages._RpcResetPrinterRequest;
                optional _WinSpoolMessages._RpcResetPrinterResponse m = NdrDecoder<_WinSpoolMessages._RpcResetPrinterResponse>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: RpcResetPrinter response (opnum 52) is not decoded successfully";
                }
                _WinSpoolMessages._RpcResetPrinterResponse res = m as _WinSpoolMessages._RpcResetPrinterResponse;
                if (req0 == null)
                {
                    if (req != null)
                    {
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                        ReportInsufficientData(req,
                                               DiagnosisLevel.Warning,
                                               "RPRN: Operation can\'t be constructed, because the response is missing.");
                    }
                    dispatch endpoint _ExtendedRprnService over server issues res;
                    ReportInsufficientData(res,
                                           DiagnosisLevel.Warning,
                                           "RPRN: Operation can\'t be constructed, because the request is missing.");
                    return;
                }
                res.Origins = [rpcMsg as any message];
                WinSpool.RpcResetPrinter op = new WinSpool.RpcResetPrinter
                        {hPrinter = req0.hPrinter,
                         pDatatype = req0.pDatatype,
                         pDevModeContainer = req0.pDevModeContainer,
                         ReturnValue = res.ReturnValue};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 53 =>
                if (req == null ||
                    !(req is
                           _WinSpoolMessages._RpcGetPrinterDriver2Request))
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    ReportInsufficientData(req,
                                           DiagnosisLevel.Warning,
                                           "RPRN: RpcGetPrinterDriver2 response (opnum 53) is not decoded successfully, because the request is missing.");
                    return;
                }
                _WinSpoolMessages._RpcGetPrinterDriver2Request req0 = req as _WinSpoolMessages._RpcGetPrinterDriver2Request;
                optional _WinSpoolMessages._RpcGetPrinterDriver2Response[req0.Level, req0.cbBuf] m = 
                    NdrDecoder<_WinSpoolMessages._RpcGetPrinterDriver2Response[req0.Level, req0.cbBuf]>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: RpcGetPrinterDriver2 response (opnum 53) is not decoded successfully";
                }
                _WinSpoolMessages._RpcGetPrinterDriver2Response[req0.Level, req0.cbBuf] res = 
                    m as _WinSpoolMessages._RpcGetPrinterDriver2Response;
                res.Origins = [rpcMsg as any message];
                WinSpool.RpcGetPrinterDriver2 op = new WinSpool.RpcGetPrinterDriver2
                        {hPrinter = req0.hPrinter,
                         pEnvironment = req0.pEnvironment,
                         Level = req0.Level,
                         pDriver = res.pDriver,
                         cbBuf = req0.cbBuf,
                         pcbNeeded = res.pcbNeeded,
                         dwClientMajorVersion = req0.dwClientMajorVersion,
                         dwClientMinorVersion = req0.dwClientMinorVersion,
                         pdwServerMaxVersion = res.pdwServerMaxVersion,
                         pdwServerMinVersion = res.pdwServerMinVersion,
                         ReturnValue = res.ReturnValue};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 54 =>
                _WinSpoolMessages._Opnum54NotUsedOnWireRequest req0 = req as _WinSpoolMessages._Opnum54NotUsedOnWireRequest;
                optional _WinSpoolMessages._Opnum54NotUsedOnWireResponse m = NdrDecoder<_WinSpoolMessages._Opnum54NotUsedOnWireResponse>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: Opnum54NotUsedOnWire response (opnum 54) is not decoded successfully";
                }
                _WinSpoolMessages._Opnum54NotUsedOnWireResponse res = m as _WinSpoolMessages._Opnum54NotUsedOnWireResponse;
                if (req0 == null)
                {
                    if (req != null)
                    {
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                        ReportInsufficientData(req,
                                               DiagnosisLevel.Warning,
                                               "RPRN: Operation can\'t be constructed, because the response is missing.");
                    }
                    dispatch endpoint _ExtendedRprnService over server issues res;
                    ReportInsufficientData(res,
                                           DiagnosisLevel.Warning,
                                           "RPRN: Operation can\'t be constructed, because the request is missing.");
                    return;
                }
                res.Origins = [rpcMsg as any message];
                WinSpool.Opnum54NotUsedOnWire op = new WinSpool.Opnum54NotUsedOnWire {};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 55 =>
                _WinSpoolMessages._Opnum55NotUsedOnWireRequest req0 = req as _WinSpoolMessages._Opnum55NotUsedOnWireRequest;
                optional _WinSpoolMessages._Opnum55NotUsedOnWireResponse m = NdrDecoder<_WinSpoolMessages._Opnum55NotUsedOnWireResponse>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: Opnum55NotUsedOnWire response (opnum 55) is not decoded successfully";
                }
                _WinSpoolMessages._Opnum55NotUsedOnWireResponse res = m as _WinSpoolMessages._Opnum55NotUsedOnWireResponse;
                if (req0 == null)
                {
                    if (req != null)
                    {
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                        ReportInsufficientData(req,
                                               DiagnosisLevel.Warning,
                                               "RPRN: Operation can\'t be constructed, because the response is missing.");
                    }
                    dispatch endpoint _ExtendedRprnService over server issues res;
                    ReportInsufficientData(res,
                                           DiagnosisLevel.Warning,
                                           "RPRN: Operation can\'t be constructed, because the request is missing.");
                    return;
                }
                res.Origins = [rpcMsg as any message];
                WinSpool.Opnum55NotUsedOnWire op = new WinSpool.Opnum55NotUsedOnWire {};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 56 =>
                _WinSpoolMessages._RpcFindClosePrinterChangeNotificationRequest req0 = 
                    req as _WinSpoolMessages._RpcFindClosePrinterChangeNotificationRequest;
                optional _WinSpoolMessages._RpcFindClosePrinterChangeNotificationResponse m = 
                    NdrDecoder<_WinSpoolMessages._RpcFindClosePrinterChangeNotificationResponse>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: RpcFindClosePrinterChangeNotification response (opnum 56) is not decoded successfully";
                }
                _WinSpoolMessages._RpcFindClosePrinterChangeNotificationResponse res = m as _WinSpoolMessages._RpcFindClosePrinterChangeNotificationResponse;
                if (req0 == null)
                {
                    if (req != null)
                    {
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                        ReportInsufficientData(req,
                                               DiagnosisLevel.Warning,
                                               "RPRN: Operation can\'t be constructed, because the response is missing.");
                    }
                    dispatch endpoint _ExtendedRprnService over server issues res;
                    ReportInsufficientData(res,
                                           DiagnosisLevel.Warning,
                                           "RPRN: Operation can\'t be constructed, because the request is missing.");
                    return;
                }
                res.Origins = [rpcMsg as any message];
                WinSpool.RpcFindClosePrinterChangeNotification op = new WinSpool.RpcFindClosePrinterChangeNotification
                        {hPrinter = req0.hPrinter,
                         ReturnValue = res.ReturnValue};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 57 =>
                _WinSpoolMessages._Opnum57NotUsedOnWireRequest req0 = req as _WinSpoolMessages._Opnum57NotUsedOnWireRequest;
                optional _WinSpoolMessages._Opnum57NotUsedOnWireResponse m = NdrDecoder<_WinSpoolMessages._Opnum57NotUsedOnWireResponse>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: Opnum57NotUsedOnWire response (opnum 57) is not decoded successfully";
                }
                _WinSpoolMessages._Opnum57NotUsedOnWireResponse res = m as _WinSpoolMessages._Opnum57NotUsedOnWireResponse;
                if (req0 == null)
                {
                    if (req != null)
                    {
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                        ReportInsufficientData(req,
                                               DiagnosisLevel.Warning,
                                               "RPRN: Operation can\'t be constructed, because the response is missing.");
                    }
                    dispatch endpoint _ExtendedRprnService over server issues res;
                    ReportInsufficientData(res,
                                           DiagnosisLevel.Warning,
                                           "RPRN: Operation can\'t be constructed, because the request is missing.");
                    return;
                }
                res.Origins = [rpcMsg as any message];
                WinSpool.Opnum57NotUsedOnWire op = new WinSpool.Opnum57NotUsedOnWire {};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 58 =>
                _WinSpoolMessages._RpcReplyOpenPrinterRequest req0 = req as _WinSpoolMessages._RpcReplyOpenPrinterRequest;
                optional _WinSpoolMessages._RpcReplyOpenPrinterResponse m = NdrDecoder<_WinSpoolMessages._RpcReplyOpenPrinterResponse>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: RpcReplyOpenPrinter response (opnum 58) is not decoded successfully";
                }
                _WinSpoolMessages._RpcReplyOpenPrinterResponse res = m as _WinSpoolMessages._RpcReplyOpenPrinterResponse;
                if (req0 == null)
                {
                    if (req != null)
                    {
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                        ReportInsufficientData(req,
                                               DiagnosisLevel.Warning,
                                               "RPRN: Operation can\'t be constructed, because the response is missing.");
                    }
                    dispatch endpoint _ExtendedRprnService over server issues res;
                    ReportInsufficientData(res,
                                           DiagnosisLevel.Warning,
                                           "RPRN: Operation can\'t be constructed, because the request is missing.");
                    return;
                }
                res.Origins = [rpcMsg as any message];
                WinSpool.RpcReplyOpenPrinter op = new WinSpool.RpcReplyOpenPrinter
                        {pMachine = req0.pMachine,
                         phPrinterNotify = res.phPrinterNotify,
                         dwPrinterRemote = req0.dwPrinterRemote,
                         dwType = req0.dwType,
                         cbBuffer = req0.cbBuffer,
                         pBuffer = req0.pBuffer,
                         ReturnValue = res.ReturnValue};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 59 =>
                _WinSpoolMessages._RpcRouterReplyPrinterRequest req0 = req as _WinSpoolMessages._RpcRouterReplyPrinterRequest;
                optional _WinSpoolMessages._RpcRouterReplyPrinterResponse m = NdrDecoder<_WinSpoolMessages._RpcRouterReplyPrinterResponse>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: RpcRouterReplyPrinter response (opnum 59) is not decoded successfully";
                }
                _WinSpoolMessages._RpcRouterReplyPrinterResponse res = m as _WinSpoolMessages._RpcRouterReplyPrinterResponse;
                if (req0 == null)
                {
                    if (req != null)
                    {
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                        ReportInsufficientData(req,
                                               DiagnosisLevel.Warning,
                                               "RPRN: Operation can\'t be constructed, because the response is missing.");
                    }
                    dispatch endpoint _ExtendedRprnService over server issues res;
                    ReportInsufficientData(res,
                                           DiagnosisLevel.Warning,
                                           "RPRN: Operation can\'t be constructed, because the request is missing.");
                    return;
                }
                res.Origins = [rpcMsg as any message];
                WinSpool.RpcRouterReplyPrinter op = new WinSpool.RpcRouterReplyPrinter
                        {hNotify = req0.hNotify,
                         fdwFlags = req0.fdwFlags,
                         cbBuffer = req0.cbBuffer,
                         pBuffer = req0.pBuffer,
                         ReturnValue = res.ReturnValue};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 60 =>
                _WinSpoolMessages._RpcReplyClosePrinterRequest req0 = req as _WinSpoolMessages._RpcReplyClosePrinterRequest;
                optional _WinSpoolMessages._RpcReplyClosePrinterResponse m = NdrDecoder<_WinSpoolMessages._RpcReplyClosePrinterResponse>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: RpcReplyClosePrinter response (opnum 60) is not decoded successfully";
                }
                _WinSpoolMessages._RpcReplyClosePrinterResponse res = m as _WinSpoolMessages._RpcReplyClosePrinterResponse;
                if (req0 == null)
                {
                    if (req != null)
                    {
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                        ReportInsufficientData(req,
                                               DiagnosisLevel.Warning,
                                               "RPRN: Operation can\'t be constructed, because the response is missing.");
                    }
                    dispatch endpoint _ExtendedRprnService over server issues res;
                    ReportInsufficientData(res,
                                           DiagnosisLevel.Warning,
                                           "RPRN: Operation can\'t be constructed, because the request is missing.");
                    return;
                }
                res.Origins = [rpcMsg as any message];
                WinSpool.RpcReplyClosePrinter op = new WinSpool.RpcReplyClosePrinter
                        {phNotify = res.phNotify,
                         ReturnValue = res.ReturnValue};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 61 =>
                _WinSpoolMessages._RpcAddPortExRequest req0 = req as _WinSpoolMessages._RpcAddPortExRequest;
                optional _WinSpoolMessages._RpcAddPortExResponse m = NdrDecoder<_WinSpoolMessages._RpcAddPortExResponse>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: RpcAddPortEx response (opnum 61) is not decoded successfully";
                }
                _WinSpoolMessages._RpcAddPortExResponse res = m as _WinSpoolMessages._RpcAddPortExResponse;
                if (req0 == null)
                {
                    if (req != null)
                    {
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                        ReportInsufficientData(req,
                                               DiagnosisLevel.Warning,
                                               "RPRN: Operation can\'t be constructed, because the response is missing.");
                    }
                    dispatch endpoint _ExtendedRprnService over server issues res;
                    ReportInsufficientData(res,
                                           DiagnosisLevel.Warning,
                                           "RPRN: Operation can\'t be constructed, because the request is missing.");
                    return;
                }
                res.Origins = [rpcMsg as any message];
                WinSpool.RpcAddPortEx op = new WinSpool.RpcAddPortEx
                        {pName = req0.pName,
                         pPortContainer = req0.pPortContainer,
                         pPortVarContainer = req0.pPortVarContainer,
                         pMonitorName = req0.pMonitorName,
                         ReturnValue = res.ReturnValue};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 62 =>
                if (req == null ||
                    !(req is
                           _WinSpoolMessages._RpcRemoteFindFirstPrinterChangeNotificationRequest))
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    ReportInsufficientData(req,
                                           DiagnosisLevel.Warning,
                                           "RPRN: RpcRemoteFindFirstPrinterChangeNotification response (opnum 62) is not decoded successfully, because the request is missing.");
                    return;
                }
                _WinSpoolMessages._RpcRemoteFindFirstPrinterChangeNotificationRequest req0 = 
                    req as _WinSpoolMessages._RpcRemoteFindFirstPrinterChangeNotificationRequest;
                optional _WinSpoolMessages._RpcRemoteFindFirstPrinterChangeNotificationResponse[req0.cbBuffer] m = 
                    NdrDecoder<_WinSpoolMessages._RpcRemoteFindFirstPrinterChangeNotificationResponse[req0.cbBuffer]>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: RpcRemoteFindFirstPrinterChangeNotification response (opnum 62) is not decoded successfully";
                }
                _WinSpoolMessages._RpcRemoteFindFirstPrinterChangeNotificationResponse[req0.cbBuffer] res = 
                    m as _WinSpoolMessages._RpcRemoteFindFirstPrinterChangeNotificationResponse;
                res.Origins = [rpcMsg as any message];
                WinSpool.RpcRemoteFindFirstPrinterChangeNotification
                    op = new WinSpool.RpcRemoteFindFirstPrinterChangeNotification
                        {hPrinter = req0.hPrinter,
                         fdwFlags = req0.fdwFlags,
                         fdwOptions = req0.fdwOptions,
                         pszLocalMachine = req0.pszLocalMachine,
                         dwPrinterLocal = req0.dwPrinterLocal,
                         cbBuffer = req0.cbBuffer,
                         pBuffer = res.pBuffer,
                         ReturnValue = res.ReturnValue};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 63 =>
                _WinSpoolMessages._Opnum63NotUsedOnWireRequest req0 = req as _WinSpoolMessages._Opnum63NotUsedOnWireRequest;
                optional _WinSpoolMessages._Opnum63NotUsedOnWireResponse m = NdrDecoder<_WinSpoolMessages._Opnum63NotUsedOnWireResponse>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: Opnum63NotUsedOnWire response (opnum 63) is not decoded successfully";
                }
                _WinSpoolMessages._Opnum63NotUsedOnWireResponse res = m as _WinSpoolMessages._Opnum63NotUsedOnWireResponse;
                if (req0 == null)
                {
                    if (req != null)
                    {
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                        ReportInsufficientData(req,
                                               DiagnosisLevel.Warning,
                                               "RPRN: Operation can\'t be constructed, because the response is missing.");
                    }
                    dispatch endpoint _ExtendedRprnService over server issues res;
                    ReportInsufficientData(res,
                                           DiagnosisLevel.Warning,
                                           "RPRN: Operation can\'t be constructed, because the request is missing.");
                    return;
                }
                res.Origins = [rpcMsg as any message];
                WinSpool.Opnum63NotUsedOnWire op = new WinSpool.Opnum63NotUsedOnWire {};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 64 =>
                _WinSpoolMessages._Opnum64NotUsedOnWireRequest req0 = req as _WinSpoolMessages._Opnum64NotUsedOnWireRequest;
                optional _WinSpoolMessages._Opnum64NotUsedOnWireResponse m = NdrDecoder<_WinSpoolMessages._Opnum64NotUsedOnWireResponse>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: Opnum64NotUsedOnWire response (opnum 64) is not decoded successfully";
                }
                _WinSpoolMessages._Opnum64NotUsedOnWireResponse res = m as _WinSpoolMessages._Opnum64NotUsedOnWireResponse;
                if (req0 == null)
                {
                    if (req != null)
                    {
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                        ReportInsufficientData(req,
                                               DiagnosisLevel.Warning,
                                               "RPRN: Operation can\'t be constructed, because the response is missing.");
                    }
                    dispatch endpoint _ExtendedRprnService over server issues res;
                    ReportInsufficientData(res,
                                           DiagnosisLevel.Warning,
                                           "RPRN: Operation can\'t be constructed, because the request is missing.");
                    return;
                }
                res.Origins = [rpcMsg as any message];
                WinSpool.Opnum64NotUsedOnWire op = new WinSpool.Opnum64NotUsedOnWire {};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 65 =>
                _WinSpoolMessages._RpcRemoteFindFirstPrinterChangeNotificationExRequest req0 = 
                    req as _WinSpoolMessages._RpcRemoteFindFirstPrinterChangeNotificationExRequest;
                optional _WinSpoolMessages._RpcRemoteFindFirstPrinterChangeNotificationExResponse m = 
                    NdrDecoder<_WinSpoolMessages._RpcRemoteFindFirstPrinterChangeNotificationExResponse>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: RpcRemoteFindFirstPrinterChangeNotificationEx response (opnum 65) is not decoded successfully";
                }
                _WinSpoolMessages._RpcRemoteFindFirstPrinterChangeNotificationExResponse res = m as _WinSpoolMessages._RpcRemoteFindFirstPrinterChangeNotificationExResponse;
                if (req0 == null)
                {
                    if (req != null)
                    {
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                        ReportInsufficientData(req,
                                               DiagnosisLevel.Warning,
                                               "RPRN: Operation can\'t be constructed, because the response is missing.");
                    }
                    dispatch endpoint _ExtendedRprnService over server issues res;
                    ReportInsufficientData(res,
                                           DiagnosisLevel.Warning,
                                           "RPRN: Operation can\'t be constructed, because the request is missing.");
                    return;
                }
                res.Origins = [rpcMsg as any message];
                WinSpool.RpcRemoteFindFirstPrinterChangeNotificationEx
                    op = new WinSpool.RpcRemoteFindFirstPrinterChangeNotificationEx
                        {hPrinter = req0.hPrinter,
                         fdwFlags = req0.fdwFlags,
                         fdwOptions = req0.fdwOptions,
                         pszLocalMachine = req0.pszLocalMachine,
                         dwPrinterLocal = req0.dwPrinterLocal,
                         pOptions = req0.pOptions,
                         ReturnValue = res.ReturnValue};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 66 =>
                _WinSpoolMessages._RpcRouterReplyPrinterExRequest req0 = req as _WinSpoolMessages._RpcRouterReplyPrinterExRequest;
                optional _WinSpoolMessages._RpcRouterReplyPrinterExResponse m = NdrDecoder<_WinSpoolMessages._RpcRouterReplyPrinterExResponse>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: RpcRouterReplyPrinterEx response (opnum 66) is not decoded successfully";
                }
                _WinSpoolMessages._RpcRouterReplyPrinterExResponse res = m as _WinSpoolMessages._RpcRouterReplyPrinterExResponse;
                if (req0 == null)
                {
                    if (req != null)
                    {
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                        ReportInsufficientData(req,
                                               DiagnosisLevel.Warning,
                                               "RPRN: Operation can\'t be constructed, because the response is missing.");
                    }
                    dispatch endpoint _ExtendedRprnService over server issues res;
                    ReportInsufficientData(res,
                                           DiagnosisLevel.Warning,
                                           "RPRN: Operation can\'t be constructed, because the request is missing.");
                    return;
                }
                res.Origins = [rpcMsg as any message];
                WinSpool.RpcRouterReplyPrinterEx op = new WinSpool.RpcRouterReplyPrinterEx
                        {hNotify = req0.hNotify,
                         dwColor = req0.dwColor,
                         fdwFlags = req0.fdwFlags,
                         pdwResult = res.pdwResult,
                         dwReplyType = req0.dwReplyType,
                         Reply = req0.Reply,
                         ReturnValue = res.ReturnValue};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 67 =>
                _WinSpoolMessages._RpcRouterRefreshPrinterChangeNotificationRequest req0 = 
                    req as _WinSpoolMessages._RpcRouterRefreshPrinterChangeNotificationRequest;
                optional _WinSpoolMessages._RpcRouterRefreshPrinterChangeNotificationResponse m = 
                    NdrDecoder<_WinSpoolMessages._RpcRouterRefreshPrinterChangeNotificationResponse>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: RpcRouterRefreshPrinterChangeNotification response (opnum 67) is not decoded successfully";
                }
                _WinSpoolMessages._RpcRouterRefreshPrinterChangeNotificationResponse res = m as _WinSpoolMessages._RpcRouterRefreshPrinterChangeNotificationResponse;
                if (req0 == null)
                {
                    if (req != null)
                    {
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                        ReportInsufficientData(req,
                                               DiagnosisLevel.Warning,
                                               "RPRN: Operation can\'t be constructed, because the response is missing.");
                    }
                    dispatch endpoint _ExtendedRprnService over server issues res;
                    ReportInsufficientData(res,
                                           DiagnosisLevel.Warning,
                                           "RPRN: Operation can\'t be constructed, because the request is missing.");
                    return;
                }
                res.Origins = [rpcMsg as any message];
                WinSpool.RpcRouterRefreshPrinterChangeNotification op = new WinSpool.RpcRouterRefreshPrinterChangeNotification
                        {hPrinter = req0.hPrinter,
                         dwColor = req0.dwColor,
                         pOptions = req0.pOptions,
                         ppInfo = res.ppInfo,
                         ReturnValue = res.ReturnValue};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 68 =>
                _WinSpoolMessages._Opnum68NotUsedOnWireRequest req0 = req as _WinSpoolMessages._Opnum68NotUsedOnWireRequest;
                optional _WinSpoolMessages._Opnum68NotUsedOnWireResponse m = NdrDecoder<_WinSpoolMessages._Opnum68NotUsedOnWireResponse>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: Opnum68NotUsedOnWire response (opnum 68) is not decoded successfully";
                }
                _WinSpoolMessages._Opnum68NotUsedOnWireResponse res = m as _WinSpoolMessages._Opnum68NotUsedOnWireResponse;
                if (req0 == null)
                {
                    if (req != null)
                    {
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                        ReportInsufficientData(req,
                                               DiagnosisLevel.Warning,
                                               "RPRN: Operation can\'t be constructed, because the response is missing.");
                    }
                    dispatch endpoint _ExtendedRprnService over server issues res;
                    ReportInsufficientData(res,
                                           DiagnosisLevel.Warning,
                                           "RPRN: Operation can\'t be constructed, because the request is missing.");
                    return;
                }
                res.Origins = [rpcMsg as any message];
                WinSpool.Opnum68NotUsedOnWire op = new WinSpool.Opnum68NotUsedOnWire {};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 69 =>
                _WinSpoolMessages._RpcOpenPrinterExRequest req0 = req as _WinSpoolMessages._RpcOpenPrinterExRequest;
                optional _WinSpoolMessages._RpcOpenPrinterExResponse m = NdrDecoder<_WinSpoolMessages._RpcOpenPrinterExResponse>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: RpcOpenPrinterEx response (opnum 69) is not decoded successfully";
                }
                _WinSpoolMessages._RpcOpenPrinterExResponse res = m as _WinSpoolMessages._RpcOpenPrinterExResponse;
                if (req0 == null)
                {
                    if (req != null)
                    {
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                        ReportInsufficientData(req,
                                               DiagnosisLevel.Warning,
                                               "RPRN: Operation can\'t be constructed, because the response is missing.");
                    }
                    dispatch endpoint _ExtendedRprnService over server issues res;
                    ReportInsufficientData(res,
                                           DiagnosisLevel.Warning,
                                           "RPRN: Operation can\'t be constructed, because the request is missing.");
                    return;
                }
                res.Origins = [rpcMsg as any message];
                WinSpool.RpcOpenPrinterEx op = new WinSpool.RpcOpenPrinterEx
                        {pPrinterName = req0.pPrinterName,
                         pHandle = res.pHandle,
                         pDatatype = req0.pDatatype,
                         pDevModeContainer = req0.pDevModeContainer,
                         AccessRequired = req0.AccessRequired,
                         pClientInfo = req0.pClientInfo,
                         ReturnValue = res.ReturnValue};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 70 =>
                _WinSpoolMessages._RpcAddPrinterExRequest req0 = req as _WinSpoolMessages._RpcAddPrinterExRequest;
                optional _WinSpoolMessages._RpcAddPrinterExResponse m = NdrDecoder<_WinSpoolMessages._RpcAddPrinterExResponse>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: RpcAddPrinterEx response (opnum 70) is not decoded successfully";
                }
                _WinSpoolMessages._RpcAddPrinterExResponse res = m as _WinSpoolMessages._RpcAddPrinterExResponse;
                if (req0 == null)
                {
                    if (req != null)
                    {
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                        ReportInsufficientData(req,
                                               DiagnosisLevel.Warning,
                                               "RPRN: Operation can\'t be constructed, because the response is missing.");
                    }
                    dispatch endpoint _ExtendedRprnService over server issues res;
                    ReportInsufficientData(res,
                                           DiagnosisLevel.Warning,
                                           "RPRN: Operation can\'t be constructed, because the request is missing.");
                    return;
                }
                res.Origins = [rpcMsg as any message];
                WinSpool.RpcAddPrinterEx op = new WinSpool.RpcAddPrinterEx
                        {pName = req0.pName,
                         pPrinterContainer = req0.pPrinterContainer,
                         pDevModeContainer = req0.pDevModeContainer,
                         pSecurityContainer = req0.pSecurityContainer,
                         pClientInfo = req0.pClientInfo,
                         pHandle = res.pHandle,
                         ReturnValue = res.ReturnValue};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 71 =>
                _WinSpoolMessages._RpcSetPortRequest req0 = req as _WinSpoolMessages._RpcSetPortRequest;
                optional _WinSpoolMessages._RpcSetPortResponse m = NdrDecoder<_WinSpoolMessages._RpcSetPortResponse>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: RpcSetPort response (opnum 71) is not decoded successfully";
                }
                _WinSpoolMessages._RpcSetPortResponse res = m as _WinSpoolMessages._RpcSetPortResponse;
                if (req0 == null)
                {
                    if (req != null)
                    {
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                        ReportInsufficientData(req,
                                               DiagnosisLevel.Warning,
                                               "RPRN: Operation can\'t be constructed, because the response is missing.");
                    }
                    dispatch endpoint _ExtendedRprnService over server issues res;
                    ReportInsufficientData(res,
                                           DiagnosisLevel.Warning,
                                           "RPRN: Operation can\'t be constructed, because the request is missing.");
                    return;
                }
                res.Origins = [rpcMsg as any message];
                WinSpool.RpcSetPort op = new WinSpool.RpcSetPort
                        {pName = req0.pName,
                         pPortName = req0.pPortName,
                         pPortContainer = req0.pPortContainer,
                         ReturnValue = res.ReturnValue};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 72 =>
                if (req == null ||
                    !(req is
                           _WinSpoolMessages._RpcEnumPrinterDataRequest))
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    ReportInsufficientData(req,
                                           DiagnosisLevel.Warning,
                                           "RPRN: RpcEnumPrinterData response (opnum 72) is not decoded successfully, because the request is missing.");
                    return;
                }
                _WinSpoolMessages._RpcEnumPrinterDataRequest req0 = req as _WinSpoolMessages._RpcEnumPrinterDataRequest;
                optional _WinSpoolMessages._RpcEnumPrinterDataResponse[req0.cbValueName] m = NdrDecoder<_WinSpoolMessages._RpcEnumPrinterDataResponse[req0.cbValueName]>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: RpcEnumPrinterData response (opnum 72) is not decoded successfully";
                }
                _WinSpoolMessages._RpcEnumPrinterDataResponse[req0.cbValueName] res = m as _WinSpoolMessages._RpcEnumPrinterDataResponse;
                res.Origins = [rpcMsg as any message];
                WinSpool.RpcEnumPrinterData op = new WinSpool.RpcEnumPrinterData
                        {hPrinter = req0.hPrinter,
                         dwIndex = req0.dwIndex,
                         pValueName = res.pValueName,
                         cbValueName = req0.cbValueName,
                         pcbValueName = res.pcbValueName,
                         pType = res.pType,
                         pData = res.pData,
                         cbData = req0.cbData,
                         pcbData = res.pcbData,
                         ReturnValue = res.ReturnValue};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 73 =>
                _WinSpoolMessages._RpcDeletePrinterDataRequest req0 = req as _WinSpoolMessages._RpcDeletePrinterDataRequest;
                optional _WinSpoolMessages._RpcDeletePrinterDataResponse m = NdrDecoder<_WinSpoolMessages._RpcDeletePrinterDataResponse>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: RpcDeletePrinterData response (opnum 73) is not decoded successfully";
                }
                _WinSpoolMessages._RpcDeletePrinterDataResponse res = m as _WinSpoolMessages._RpcDeletePrinterDataResponse;
                if (req0 == null)
                {
                    if (req != null)
                    {
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                        ReportInsufficientData(req,
                                               DiagnosisLevel.Warning,
                                               "RPRN: Operation can\'t be constructed, because the response is missing.");
                    }
                    dispatch endpoint _ExtendedRprnService over server issues res;
                    ReportInsufficientData(res,
                                           DiagnosisLevel.Warning,
                                           "RPRN: Operation can\'t be constructed, because the request is missing.");
                    return;
                }
                res.Origins = [rpcMsg as any message];
                WinSpool.RpcDeletePrinterData op = new WinSpool.RpcDeletePrinterData
                        {hPrinter = req0.hPrinter,
                         pValueName = req0.pValueName,
                         ReturnValue = res.ReturnValue};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 74 =>
                _WinSpoolMessages._Opnum74NotUsedOnWireRequest req0 = req as _WinSpoolMessages._Opnum74NotUsedOnWireRequest;
                optional _WinSpoolMessages._Opnum74NotUsedOnWireResponse m = NdrDecoder<_WinSpoolMessages._Opnum74NotUsedOnWireResponse>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: Opnum74NotUsedOnWire response (opnum 74) is not decoded successfully";
                }
                _WinSpoolMessages._Opnum74NotUsedOnWireResponse res = m as _WinSpoolMessages._Opnum74NotUsedOnWireResponse;
                if (req0 == null)
                {
                    if (req != null)
                    {
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                        ReportInsufficientData(req,
                                               DiagnosisLevel.Warning,
                                               "RPRN: Operation can\'t be constructed, because the response is missing.");
                    }
                    dispatch endpoint _ExtendedRprnService over server issues res;
                    ReportInsufficientData(res,
                                           DiagnosisLevel.Warning,
                                           "RPRN: Operation can\'t be constructed, because the request is missing.");
                    return;
                }
                res.Origins = [rpcMsg as any message];
                WinSpool.Opnum74NotUsedOnWire op = new WinSpool.Opnum74NotUsedOnWire {};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 75 =>
                _WinSpoolMessages._Opnum75NotUsedOnWireRequest req0 = req as _WinSpoolMessages._Opnum75NotUsedOnWireRequest;
                optional _WinSpoolMessages._Opnum75NotUsedOnWireResponse m = NdrDecoder<_WinSpoolMessages._Opnum75NotUsedOnWireResponse>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: Opnum75NotUsedOnWire response (opnum 75) is not decoded successfully";
                }
                _WinSpoolMessages._Opnum75NotUsedOnWireResponse res = m as _WinSpoolMessages._Opnum75NotUsedOnWireResponse;
                if (req0 == null)
                {
                    if (req != null)
                    {
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                        ReportInsufficientData(req,
                                               DiagnosisLevel.Warning,
                                               "RPRN: Operation can\'t be constructed, because the response is missing.");
                    }
                    dispatch endpoint _ExtendedRprnService over server issues res;
                    ReportInsufficientData(res,
                                           DiagnosisLevel.Warning,
                                           "RPRN: Operation can\'t be constructed, because the request is missing.");
                    return;
                }
                res.Origins = [rpcMsg as any message];
                WinSpool.Opnum75NotUsedOnWire op = new WinSpool.Opnum75NotUsedOnWire {};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 76 =>
                _WinSpoolMessages._Opnum76NotUsedOnWireRequest req0 = req as _WinSpoolMessages._Opnum76NotUsedOnWireRequest;
                optional _WinSpoolMessages._Opnum76NotUsedOnWireResponse m = NdrDecoder<_WinSpoolMessages._Opnum76NotUsedOnWireResponse>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: Opnum76NotUsedOnWire response (opnum 76) is not decoded successfully";
                }
                _WinSpoolMessages._Opnum76NotUsedOnWireResponse res = m as _WinSpoolMessages._Opnum76NotUsedOnWireResponse;
                if (req0 == null)
                {
                    if (req != null)
                    {
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                        ReportInsufficientData(req,
                                               DiagnosisLevel.Warning,
                                               "RPRN: Operation can\'t be constructed, because the response is missing.");
                    }
                    dispatch endpoint _ExtendedRprnService over server issues res;
                    ReportInsufficientData(res,
                                           DiagnosisLevel.Warning,
                                           "RPRN: Operation can\'t be constructed, because the request is missing.");
                    return;
                }
                res.Origins = [rpcMsg as any message];
                WinSpool.Opnum76NotUsedOnWire op = new WinSpool.Opnum76NotUsedOnWire {};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 77 =>
                _WinSpoolMessages._RpcSetPrinterDataExRequest req0 = req as _WinSpoolMessages._RpcSetPrinterDataExRequest;
                optional _WinSpoolMessages._RpcSetPrinterDataExResponse m = NdrDecoder<_WinSpoolMessages._RpcSetPrinterDataExResponse>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: RpcSetPrinterDataEx response (opnum 77) is not decoded successfully";
                }
                _WinSpoolMessages._RpcSetPrinterDataExResponse res = m as _WinSpoolMessages._RpcSetPrinterDataExResponse;
                if (req0 == null)
                {
                    if (req != null)
                    {
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                        ReportInsufficientData(req,
                                               DiagnosisLevel.Warning,
                                               "RPRN: Operation can\'t be constructed, because the response is missing.");
                    }
                    dispatch endpoint _ExtendedRprnService over server issues res;
                    ReportInsufficientData(res,
                                           DiagnosisLevel.Warning,
                                           "RPRN: Operation can\'t be constructed, because the request is missing.");
                    return;
                }
                res.Origins = [rpcMsg as any message];
                WinSpool.RpcSetPrinterDataEx op = new WinSpool.RpcSetPrinterDataEx
                        {hPrinter = req0.hPrinter,
                         pKeyName = req0.pKeyName,
                         pValueName = req0.pValueName,
                         Type = req0.Type,
                         pData = req0.pData,
                         cbData = req0.cbData,
                         ReturnValue = res.ReturnValue};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 78 =>
                _WinSpoolMessages._RpcGetPrinterDataExRequest req0 = req as _WinSpoolMessages._RpcGetPrinterDataExRequest;
                optional _WinSpoolMessages._RpcGetPrinterDataExResponse m = NdrDecoder<_WinSpoolMessages._RpcGetPrinterDataExResponse>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: RpcGetPrinterDataEx response (opnum 78) is not decoded successfully";
                }
                _WinSpoolMessages._RpcGetPrinterDataExResponse res = m as _WinSpoolMessages._RpcGetPrinterDataExResponse;
                if (req0 == null)
                {
                    if (req != null)
                    {
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                        ReportInsufficientData(req,
                                               DiagnosisLevel.Warning,
                                               "RPRN: Operation can\'t be constructed, because the response is missing.");
                    }
                    dispatch endpoint _ExtendedRprnService over server issues res;
                    ReportInsufficientData(res,
                                           DiagnosisLevel.Warning,
                                           "RPRN: Operation can\'t be constructed, because the request is missing.");
                    return;
                }
                res.Origins = [rpcMsg as any message];
                WinSpool.RpcGetPrinterDataEx op = new WinSpool.RpcGetPrinterDataEx
                        {hPrinter = req0.hPrinter,
                         pKeyName = req0.pKeyName,
                         pValueName = req0.pValueName,
                         pType = res.pType,
                         pData = res.pData,
                         nSize = req0.nSize,
                         pcbNeeded = res.pcbNeeded,
                         ReturnValue = res.ReturnValue};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 79 =>
                if (req == null ||
                    !(req is
                           _WinSpoolMessages._RpcEnumPrinterDataExRequest))
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    ReportInsufficientData(req,
                                           DiagnosisLevel.Warning,
                                           "RPRN: RpcEnumPrinterDataEx response (opnum 79) is not decoded successfully, because the request is missing.");
                    return;
                }
                _WinSpoolMessages._RpcEnumPrinterDataExRequest req0 = req as _WinSpoolMessages._RpcEnumPrinterDataExRequest;
                optional _WinSpoolMessages._RpcEnumPrinterDataExResponse[req0.cbEnumValues] m = NdrDecoder<_WinSpoolMessages._RpcEnumPrinterDataExResponse[req0.cbEnumValues]>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: RpcEnumPrinterDataEx response (opnum 79) is not decoded successfully";
                }
                _WinSpoolMessages._RpcEnumPrinterDataExResponse[req0.cbEnumValues] res = m as _WinSpoolMessages._RpcEnumPrinterDataExResponse;
                res.Origins = [rpcMsg as any message];
                WinSpool.RpcEnumPrinterDataEx op = new WinSpool.RpcEnumPrinterDataEx
                        {hPrinter = req0.hPrinter,
                         pKeyName = req0.pKeyName,
                         pEnumValues = res.pEnumValues,
                         cbEnumValues = req0.cbEnumValues,
                         pcbEnumValues = res.pcbEnumValues,
                         pnEnumValues = res.pnEnumValues,
                         ReturnValue = res.ReturnValue};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 80 =>
                if (req == null ||
                    !(req is
                           _WinSpoolMessages._RpcEnumPrinterKeyRequest))
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    ReportInsufficientData(req,
                                           DiagnosisLevel.Warning,
                                           "RPRN: RpcEnumPrinterKey response (opnum 80) is not decoded successfully, because the request is missing.");
                    return;
                }
                _WinSpoolMessages._RpcEnumPrinterKeyRequest req0 = req as _WinSpoolMessages._RpcEnumPrinterKeyRequest;
                optional _WinSpoolMessages._RpcEnumPrinterKeyResponse[req0.cbSubkey] m = NdrDecoder<_WinSpoolMessages._RpcEnumPrinterKeyResponse[req0.cbSubkey]>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: RpcEnumPrinterKey response (opnum 80) is not decoded successfully";
                }
                _WinSpoolMessages._RpcEnumPrinterKeyResponse[req0.cbSubkey] res = m as _WinSpoolMessages._RpcEnumPrinterKeyResponse;
                res.Origins = [rpcMsg as any message];
                WinSpool.RpcEnumPrinterKey op = new WinSpool.RpcEnumPrinterKey
                        {hPrinter = req0.hPrinter,
                         pKeyName = req0.pKeyName,
                         pSubkey = res.pSubkey,
                         cbSubkey = req0.cbSubkey,
                         pcbSubkey = res.pcbSubkey,
                         ReturnValue = res.ReturnValue};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 81 =>
                _WinSpoolMessages._RpcDeletePrinterDataExRequest req0 = req as _WinSpoolMessages._RpcDeletePrinterDataExRequest;
                optional _WinSpoolMessages._RpcDeletePrinterDataExResponse m = NdrDecoder<_WinSpoolMessages._RpcDeletePrinterDataExResponse>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: RpcDeletePrinterDataEx response (opnum 81) is not decoded successfully";
                }
                _WinSpoolMessages._RpcDeletePrinterDataExResponse res = m as _WinSpoolMessages._RpcDeletePrinterDataExResponse;
                if (req0 == null)
                {
                    if (req != null)
                    {
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                        ReportInsufficientData(req,
                                               DiagnosisLevel.Warning,
                                               "RPRN: Operation can\'t be constructed, because the response is missing.");
                    }
                    dispatch endpoint _ExtendedRprnService over server issues res;
                    ReportInsufficientData(res,
                                           DiagnosisLevel.Warning,
                                           "RPRN: Operation can\'t be constructed, because the request is missing.");
                    return;
                }
                res.Origins = [rpcMsg as any message];
                WinSpool.RpcDeletePrinterDataEx op = new WinSpool.RpcDeletePrinterDataEx
                        {hPrinter = req0.hPrinter,
                         pKeyName = req0.pKeyName,
                         pValueName = req0.pValueName,
                         ReturnValue = res.ReturnValue};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 82 =>
                _WinSpoolMessages._RpcDeletePrinterKeyRequest req0 = req as _WinSpoolMessages._RpcDeletePrinterKeyRequest;
                optional _WinSpoolMessages._RpcDeletePrinterKeyResponse m = NdrDecoder<_WinSpoolMessages._RpcDeletePrinterKeyResponse>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: RpcDeletePrinterKey response (opnum 82) is not decoded successfully";
                }
                _WinSpoolMessages._RpcDeletePrinterKeyResponse res = m as _WinSpoolMessages._RpcDeletePrinterKeyResponse;
                if (req0 == null)
                {
                    if (req != null)
                    {
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                        ReportInsufficientData(req,
                                               DiagnosisLevel.Warning,
                                               "RPRN: Operation can\'t be constructed, because the response is missing.");
                    }
                    dispatch endpoint _ExtendedRprnService over server issues res;
                    ReportInsufficientData(res,
                                           DiagnosisLevel.Warning,
                                           "RPRN: Operation can\'t be constructed, because the request is missing.");
                    return;
                }
                res.Origins = [rpcMsg as any message];
                WinSpool.RpcDeletePrinterKey op = new WinSpool.RpcDeletePrinterKey
                        {hPrinter = req0.hPrinter,
                         pKeyName = req0.pKeyName,
                         ReturnValue = res.ReturnValue};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 83 =>
                _WinSpoolMessages._Opnum83NotUsedOnWireRequest req0 = req as _WinSpoolMessages._Opnum83NotUsedOnWireRequest;
                optional _WinSpoolMessages._Opnum83NotUsedOnWireResponse m = NdrDecoder<_WinSpoolMessages._Opnum83NotUsedOnWireResponse>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: Opnum83NotUsedOnWire response (opnum 83) is not decoded successfully";
                }
                _WinSpoolMessages._Opnum83NotUsedOnWireResponse res = m as _WinSpoolMessages._Opnum83NotUsedOnWireResponse;
                if (req0 == null)
                {
                    if (req != null)
                    {
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                        ReportInsufficientData(req,
                                               DiagnosisLevel.Warning,
                                               "RPRN: Operation can\'t be constructed, because the response is missing.");
                    }
                    dispatch endpoint _ExtendedRprnService over server issues res;
                    ReportInsufficientData(res,
                                           DiagnosisLevel.Warning,
                                           "RPRN: Operation can\'t be constructed, because the request is missing.");
                    return;
                }
                res.Origins = [rpcMsg as any message];
                WinSpool.Opnum83NotUsedOnWire op = new WinSpool.Opnum83NotUsedOnWire {};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 84 =>
                _WinSpoolMessages._RpcDeletePrinterDriverExRequest req0 = req as _WinSpoolMessages._RpcDeletePrinterDriverExRequest;
                optional _WinSpoolMessages._RpcDeletePrinterDriverExResponse m = NdrDecoder<_WinSpoolMessages._RpcDeletePrinterDriverExResponse>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: RpcDeletePrinterDriverEx response (opnum 84) is not decoded successfully";
                }
                _WinSpoolMessages._RpcDeletePrinterDriverExResponse res = m as _WinSpoolMessages._RpcDeletePrinterDriverExResponse;
                if (req0 == null)
                {
                    if (req != null)
                    {
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                        ReportInsufficientData(req,
                                               DiagnosisLevel.Warning,
                                               "RPRN: Operation can\'t be constructed, because the response is missing.");
                    }
                    dispatch endpoint _ExtendedRprnService over server issues res;
                    ReportInsufficientData(res,
                                           DiagnosisLevel.Warning,
                                           "RPRN: Operation can\'t be constructed, because the request is missing.");
                    return;
                }
                res.Origins = [rpcMsg as any message];
                WinSpool.RpcDeletePrinterDriverEx op = new WinSpool.RpcDeletePrinterDriverEx
                        {pName = req0.pName,
                         pEnvironment = req0.pEnvironment,
                         pDriverName = req0.pDriverName,
                         dwDeleteFlag = req0.dwDeleteFlag,
                         dwVersionNum = req0.dwVersionNum,
                         ReturnValue = res.ReturnValue};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 85 =>
                _WinSpoolMessages._RpcAddPerMachineConnectionRequest req0 = req as _WinSpoolMessages._RpcAddPerMachineConnectionRequest;
                optional _WinSpoolMessages._RpcAddPerMachineConnectionResponse m = NdrDecoder<_WinSpoolMessages._RpcAddPerMachineConnectionResponse>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: RpcAddPerMachineConnection response (opnum 85) is not decoded successfully";
                }
                _WinSpoolMessages._RpcAddPerMachineConnectionResponse res = m as _WinSpoolMessages._RpcAddPerMachineConnectionResponse;
                if (req0 == null)
                {
                    if (req != null)
                    {
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                        ReportInsufficientData(req,
                                               DiagnosisLevel.Warning,
                                               "RPRN: Operation can\'t be constructed, because the response is missing.");
                    }
                    dispatch endpoint _ExtendedRprnService over server issues res;
                    ReportInsufficientData(res,
                                           DiagnosisLevel.Warning,
                                           "RPRN: Operation can\'t be constructed, because the request is missing.");
                    return;
                }
                res.Origins = [rpcMsg as any message];
                WinSpool.RpcAddPerMachineConnection op = new WinSpool.RpcAddPerMachineConnection
                        {pServer = req0.pServer,
                         pPrinterName = req0.pPrinterName,
                         pPrintServer = req0.pPrintServer,
                         pProvider = req0.pProvider,
                         ReturnValue = res.ReturnValue};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 86 =>
                _WinSpoolMessages._RpcDeletePerMachineConnectionRequest req0 = req as _WinSpoolMessages._RpcDeletePerMachineConnectionRequest;
                optional _WinSpoolMessages._RpcDeletePerMachineConnectionResponse m = NdrDecoder<_WinSpoolMessages._RpcDeletePerMachineConnectionResponse>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: RpcDeletePerMachineConnection response (opnum 86) is not decoded successfully";
                }
                _WinSpoolMessages._RpcDeletePerMachineConnectionResponse res = m as _WinSpoolMessages._RpcDeletePerMachineConnectionResponse;
                if (req0 == null)
                {
                    if (req != null)
                    {
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                        ReportInsufficientData(req,
                                               DiagnosisLevel.Warning,
                                               "RPRN: Operation can\'t be constructed, because the response is missing.");
                    }
                    dispatch endpoint _ExtendedRprnService over server issues res;
                    ReportInsufficientData(res,
                                           DiagnosisLevel.Warning,
                                           "RPRN: Operation can\'t be constructed, because the request is missing.");
                    return;
                }
                res.Origins = [rpcMsg as any message];
                WinSpool.RpcDeletePerMachineConnection op = new WinSpool.RpcDeletePerMachineConnection
                        {pServer = req0.pServer,
                         pPrinterName = req0.pPrinterName,
                         ReturnValue = res.ReturnValue};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 87 =>
                if (req == null ||
                    !(req is
                           _WinSpoolMessages._RpcEnumPerMachineConnectionsRequest))
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    ReportInsufficientData(req,
                                           DiagnosisLevel.Warning,
                                           "RPRN: RpcEnumPerMachineConnections response (opnum 87) is not decoded successfully, because the request is missing.");
                    return;
                }
                _WinSpoolMessages._RpcEnumPerMachineConnectionsRequest req0 = req as _WinSpoolMessages._RpcEnumPerMachineConnectionsRequest;
                optional _WinSpoolMessages._RpcEnumPerMachineConnectionsResponse[req0.cbBuf] m = 
                    NdrDecoder<_WinSpoolMessages._RpcEnumPerMachineConnectionsResponse[req0.cbBuf]>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: RpcEnumPerMachineConnections response (opnum 87) is not decoded successfully";
                }
                _WinSpoolMessages._RpcEnumPerMachineConnectionsResponse[req0.cbBuf] res = m as _WinSpoolMessages._RpcEnumPerMachineConnectionsResponse;
                res.Origins = [rpcMsg as any message];
                WinSpool.RpcEnumPerMachineConnections op = new WinSpool.RpcEnumPerMachineConnections
                        {pServer = req0.pServer,
                         pPrinterEnum = res.pPrinterEnum,
                         cbBuf = req0.cbBuf,
                         pcbNeeded = res.pcbNeeded,
                         pcReturned = res.pcReturned,
                         ReturnValue = res.ReturnValue};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 88 =>
                if (req == null || !(req is _WinSpoolMessages._RpcXcvDataRequest))
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    ReportInsufficientData(req,
                                           DiagnosisLevel.Warning,
                                           "RPRN: RpcXcvData response (opnum 88) is not decoded successfully, because the request is missing.");
                    return;
                }
                _WinSpoolMessages._RpcXcvDataRequest req0 = req as _WinSpoolMessages._RpcXcvDataRequest;
                optional _WinSpoolMessages._RpcXcvDataResponse[req0.cbOutputData] m = NdrDecoder<_WinSpoolMessages._RpcXcvDataResponse[req0.cbOutputData]>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: RpcXcvData response (opnum 88) is not decoded successfully";
                }
                _WinSpoolMessages._RpcXcvDataResponse[req0.cbOutputData] res = m as _WinSpoolMessages._RpcXcvDataResponse;
                res.Origins = [rpcMsg as any message];
                WinSpool.RpcXcvData op = new WinSpool.RpcXcvData
                        {hXcv = req0.hXcv,
                         pszDataName = req0.pszDataName,
                         pInputData = req0.pInputData,
                         cbInputData = req0.cbInputData,
                         pOutputData = res.pOutputData,
                         cbOutputData = req0.cbOutputData,
                         pcbOutputNeeded = res.pcbOutputNeeded,
                         pdwStatus = res.pdwStatus,
                         ReturnValue = res.ReturnValue};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 89 =>
                _WinSpoolMessages._RpcAddPrinterDriverExRequest req0 = req as _WinSpoolMessages._RpcAddPrinterDriverExRequest;
                optional _WinSpoolMessages._RpcAddPrinterDriverExResponse m = NdrDecoder<_WinSpoolMessages._RpcAddPrinterDriverExResponse>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: RpcAddPrinterDriverEx response (opnum 89) is not decoded successfully";
                }
                _WinSpoolMessages._RpcAddPrinterDriverExResponse res = m as _WinSpoolMessages._RpcAddPrinterDriverExResponse;
                if (req0 == null)
                {
                    if (req != null)
                    {
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                        ReportInsufficientData(req,
                                               DiagnosisLevel.Warning,
                                               "RPRN: Operation can\'t be constructed, because the response is missing.");
                    }
                    dispatch endpoint _ExtendedRprnService over server issues res;
                    ReportInsufficientData(res,
                                           DiagnosisLevel.Warning,
                                           "RPRN: Operation can\'t be constructed, because the request is missing.");
                    return;
                }
                res.Origins = [rpcMsg as any message];
                WinSpool.RpcAddPrinterDriverEx op = new WinSpool.RpcAddPrinterDriverEx
                        {pName = req0.pName,
                         pDriverContainer = req0.pDriverContainer,
                         dwFileCopyFlags = req0.dwFileCopyFlags,
                         ReturnValue = res.ReturnValue};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 90 =>
                _WinSpoolMessages._Opnum90NotUsedOnWireRequest req0 = req as _WinSpoolMessages._Opnum90NotUsedOnWireRequest;
                optional _WinSpoolMessages._Opnum90NotUsedOnWireResponse m = NdrDecoder<_WinSpoolMessages._Opnum90NotUsedOnWireResponse>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: Opnum90NotUsedOnWire response (opnum 90) is not decoded successfully";
                }
                _WinSpoolMessages._Opnum90NotUsedOnWireResponse res = m as _WinSpoolMessages._Opnum90NotUsedOnWireResponse;
                if (req0 == null)
                {
                    if (req != null)
                    {
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                        ReportInsufficientData(req,
                                               DiagnosisLevel.Warning,
                                               "RPRN: Operation can\'t be constructed, because the response is missing.");
                    }
                    dispatch endpoint _ExtendedRprnService over server issues res;
                    ReportInsufficientData(res,
                                           DiagnosisLevel.Warning,
                                           "RPRN: Operation can\'t be constructed, because the request is missing.");
                    return;
                }
                res.Origins = [rpcMsg as any message];
                WinSpool.Opnum90NotUsedOnWire op = new WinSpool.Opnum90NotUsedOnWire {};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 91 =>
                _WinSpoolMessages._Opnum91NotUsedOnWireRequest req0 = req as _WinSpoolMessages._Opnum91NotUsedOnWireRequest;
                optional _WinSpoolMessages._Opnum91NotUsedOnWireResponse m = NdrDecoder<_WinSpoolMessages._Opnum91NotUsedOnWireResponse>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: Opnum91NotUsedOnWire response (opnum 91) is not decoded successfully";
                }
                _WinSpoolMessages._Opnum91NotUsedOnWireResponse res = m as _WinSpoolMessages._Opnum91NotUsedOnWireResponse;
                if (req0 == null)
                {
                    if (req != null)
                    {
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                        ReportInsufficientData(req,
                                               DiagnosisLevel.Warning,
                                               "RPRN: Operation can\'t be constructed, because the response is missing.");
                    }
                    dispatch endpoint _ExtendedRprnService over server issues res;
                    ReportInsufficientData(res,
                                           DiagnosisLevel.Warning,
                                           "RPRN: Operation can\'t be constructed, because the request is missing.");
                    return;
                }
                res.Origins = [rpcMsg as any message];
                WinSpool.Opnum91NotUsedOnWire op = new WinSpool.Opnum91NotUsedOnWire {};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 92 =>
                _WinSpoolMessages._Opnum92NotUsedOnWireRequest req0 = req as _WinSpoolMessages._Opnum92NotUsedOnWireRequest;
                optional _WinSpoolMessages._Opnum92NotUsedOnWireResponse m = NdrDecoder<_WinSpoolMessages._Opnum92NotUsedOnWireResponse>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: Opnum92NotUsedOnWire response (opnum 92) is not decoded successfully";
                }
                _WinSpoolMessages._Opnum92NotUsedOnWireResponse res = m as _WinSpoolMessages._Opnum92NotUsedOnWireResponse;
                if (req0 == null)
                {
                    if (req != null)
                    {
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                        ReportInsufficientData(req,
                                               DiagnosisLevel.Warning,
                                               "RPRN: Operation can\'t be constructed, because the response is missing.");
                    }
                    dispatch endpoint _ExtendedRprnService over server issues res;
                    ReportInsufficientData(res,
                                           DiagnosisLevel.Warning,
                                           "RPRN: Operation can\'t be constructed, because the request is missing.");
                    return;
                }
                res.Origins = [rpcMsg as any message];
                WinSpool.Opnum92NotUsedOnWire op = new WinSpool.Opnum92NotUsedOnWire {};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 93 =>
                _WinSpoolMessages._Opnum93NotUsedOnWireRequest req0 = req as _WinSpoolMessages._Opnum93NotUsedOnWireRequest;
                optional _WinSpoolMessages._Opnum93NotUsedOnWireResponse m = NdrDecoder<_WinSpoolMessages._Opnum93NotUsedOnWireResponse>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: Opnum93NotUsedOnWire response (opnum 93) is not decoded successfully";
                }
                _WinSpoolMessages._Opnum93NotUsedOnWireResponse res = m as _WinSpoolMessages._Opnum93NotUsedOnWireResponse;
                if (req0 == null)
                {
                    if (req != null)
                    {
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                        ReportInsufficientData(req,
                                               DiagnosisLevel.Warning,
                                               "RPRN: Operation can\'t be constructed, because the response is missing.");
                    }
                    dispatch endpoint _ExtendedRprnService over server issues res;
                    ReportInsufficientData(res,
                                           DiagnosisLevel.Warning,
                                           "RPRN: Operation can\'t be constructed, because the request is missing.");
                    return;
                }
                res.Origins = [rpcMsg as any message];
                WinSpool.Opnum93NotUsedOnWire op = new WinSpool.Opnum93NotUsedOnWire {};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 94 =>
                _WinSpoolMessages._Opnum94NotUsedOnWireRequest req0 = req as _WinSpoolMessages._Opnum94NotUsedOnWireRequest;
                optional _WinSpoolMessages._Opnum94NotUsedOnWireResponse m = NdrDecoder<_WinSpoolMessages._Opnum94NotUsedOnWireResponse>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: Opnum94NotUsedOnWire response (opnum 94) is not decoded successfully";
                }
                _WinSpoolMessages._Opnum94NotUsedOnWireResponse res = m as _WinSpoolMessages._Opnum94NotUsedOnWireResponse;
                if (req0 == null)
                {
                    if (req != null)
                    {
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                        ReportInsufficientData(req,
                                               DiagnosisLevel.Warning,
                                               "RPRN: Operation can\'t be constructed, because the response is missing.");
                    }
                    dispatch endpoint _ExtendedRprnService over server issues res;
                    ReportInsufficientData(res,
                                           DiagnosisLevel.Warning,
                                           "RPRN: Operation can\'t be constructed, because the request is missing.");
                    return;
                }
                res.Origins = [rpcMsg as any message];
                WinSpool.Opnum94NotUsedOnWire op = new WinSpool.Opnum94NotUsedOnWire {};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 95 =>
                _WinSpoolMessages._Opnum95NotUsedOnWireRequest req0 = req as _WinSpoolMessages._Opnum95NotUsedOnWireRequest;
                optional _WinSpoolMessages._Opnum95NotUsedOnWireResponse m = NdrDecoder<_WinSpoolMessages._Opnum95NotUsedOnWireResponse>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: Opnum95NotUsedOnWire response (opnum 95) is not decoded successfully";
                }
                _WinSpoolMessages._Opnum95NotUsedOnWireResponse res = m as _WinSpoolMessages._Opnum95NotUsedOnWireResponse;
                if (req0 == null)
                {
                    if (req != null)
                    {
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                        ReportInsufficientData(req,
                                               DiagnosisLevel.Warning,
                                               "RPRN: Operation can\'t be constructed, because the response is missing.");
                    }
                    dispatch endpoint _ExtendedRprnService over server issues res;
                    ReportInsufficientData(res,
                                           DiagnosisLevel.Warning,
                                           "RPRN: Operation can\'t be constructed, because the request is missing.");
                    return;
                }
                res.Origins = [rpcMsg as any message];
                WinSpool.Opnum95NotUsedOnWire op = new WinSpool.Opnum95NotUsedOnWire {};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 96 =>
                _WinSpoolMessages._RpcFlushPrinterRequest req0 = req as _WinSpoolMessages._RpcFlushPrinterRequest;
                optional _WinSpoolMessages._RpcFlushPrinterResponse m = NdrDecoder<_WinSpoolMessages._RpcFlushPrinterResponse>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: RpcFlushPrinter response (opnum 96) is not decoded successfully";
                }
                _WinSpoolMessages._RpcFlushPrinterResponse res = m as _WinSpoolMessages._RpcFlushPrinterResponse;
                if (req0 == null)
                {
                    if (req != null)
                    {
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                        ReportInsufficientData(req,
                                               DiagnosisLevel.Warning,
                                               "RPRN: Operation can\'t be constructed, because the response is missing.");
                    }
                    dispatch endpoint _ExtendedRprnService over server issues res;
                    ReportInsufficientData(res,
                                           DiagnosisLevel.Warning,
                                           "RPRN: Operation can\'t be constructed, because the request is missing.");
                    return;
                }
                res.Origins = [rpcMsg as any message];
                WinSpool.RpcFlushPrinter op = new WinSpool.RpcFlushPrinter
                        {hPrinter = req0.hPrinter,
                         pBuf = req0.pBuf,
                         cbBuf = req0.cbBuf,
                         pcWritten = res.pcWritten,
                         cSleep = req0.cSleep,
                         ReturnValue = res.ReturnValue};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 97 =>
                _WinSpoolMessages._RpcSendRecvBidiDataRequest req0 = req as _WinSpoolMessages._RpcSendRecvBidiDataRequest;
                optional _WinSpoolMessages._RpcSendRecvBidiDataResponse m = NdrDecoder<_WinSpoolMessages._RpcSendRecvBidiDataResponse>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: RpcSendRecvBidiData response (opnum 97) is not decoded successfully";
                }
                _WinSpoolMessages._RpcSendRecvBidiDataResponse res = m as _WinSpoolMessages._RpcSendRecvBidiDataResponse;
                if (req0 == null)
                {
                    if (req != null)
                    {
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                        ReportInsufficientData(req,
                                               DiagnosisLevel.Warning,
                                               "RPRN: Operation can\'t be constructed, because the response is missing.");
                    }
                    dispatch endpoint _ExtendedRprnService over server issues res;
                    ReportInsufficientData(res,
                                           DiagnosisLevel.Warning,
                                           "RPRN: Operation can\'t be constructed, because the request is missing.");
                    return;
                }
                res.Origins = [rpcMsg as any message];
                WinSpool.RpcSendRecvBidiData op = new WinSpool.RpcSendRecvBidiData
                        {hPrinter = req0.hPrinter,
                         pAction = req0.pAction,
                         pReqData = req0.pReqData,
                         ppRespData = res.ppRespData,
                         ReturnValue = res.ReturnValue};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 98 =>
                _WinSpoolMessages._Opnum98NotUsedOnWireRequest req0 = req as _WinSpoolMessages._Opnum98NotUsedOnWireRequest;
                optional _WinSpoolMessages._Opnum98NotUsedOnWireResponse m = NdrDecoder<_WinSpoolMessages._Opnum98NotUsedOnWireResponse>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: Opnum98NotUsedOnWire response (opnum 98) is not decoded successfully";
                }
                _WinSpoolMessages._Opnum98NotUsedOnWireResponse res = m as _WinSpoolMessages._Opnum98NotUsedOnWireResponse;
                if (req0 == null)
                {
                    if (req != null)
                    {
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                        ReportInsufficientData(req,
                                               DiagnosisLevel.Warning,
                                               "RPRN: Operation can\'t be constructed, because the response is missing.");
                    }
                    dispatch endpoint _ExtendedRprnService over server issues res;
                    ReportInsufficientData(res,
                                           DiagnosisLevel.Warning,
                                           "RPRN: Operation can\'t be constructed, because the request is missing.");
                    return;
                }
                res.Origins = [rpcMsg as any message];
                WinSpool.Opnum98NotUsedOnWire op = new WinSpool.Opnum98NotUsedOnWire {};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 99 =>
                _WinSpoolMessages._Opnum99NotUsedOnWireRequest req0 = req as _WinSpoolMessages._Opnum99NotUsedOnWireRequest;
                optional _WinSpoolMessages._Opnum99NotUsedOnWireResponse m = NdrDecoder<_WinSpoolMessages._Opnum99NotUsedOnWireResponse>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: Opnum99NotUsedOnWire response (opnum 99) is not decoded successfully";
                }
                _WinSpoolMessages._Opnum99NotUsedOnWireResponse res = m as _WinSpoolMessages._Opnum99NotUsedOnWireResponse;
                if (req0 == null)
                {
                    if (req != null)
                    {
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                        ReportInsufficientData(req,
                                               DiagnosisLevel.Warning,
                                               "RPRN: Operation can\'t be constructed, because the response is missing.");
                    }
                    dispatch endpoint _ExtendedRprnService over server issues res;
                    ReportInsufficientData(res,
                                           DiagnosisLevel.Warning,
                                           "RPRN: Operation can\'t be constructed, because the request is missing.");
                    return;
                }
                res.Origins = [rpcMsg as any message];
                WinSpool.Opnum99NotUsedOnWire op = new WinSpool.Opnum99NotUsedOnWire {};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 100 =>
                _WinSpoolMessages._Opnum100NotUsedOnWireRequest req0 = req as _WinSpoolMessages._Opnum100NotUsedOnWireRequest;
                optional _WinSpoolMessages._Opnum100NotUsedOnWireResponse m = NdrDecoder<_WinSpoolMessages._Opnum100NotUsedOnWireResponse>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: Opnum100NotUsedOnWire response (opnum 100) is not decoded successfully";
                }
                _WinSpoolMessages._Opnum100NotUsedOnWireResponse res = m as _WinSpoolMessages._Opnum100NotUsedOnWireResponse;
                if (req0 == null)
                {
                    if (req != null)
                    {
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                        ReportInsufficientData(req,
                                               DiagnosisLevel.Warning,
                                               "RPRN: Operation can\'t be constructed, because the response is missing.");
                    }
                    dispatch endpoint _ExtendedRprnService over server issues res;
                    ReportInsufficientData(res,
                                           DiagnosisLevel.Warning,
                                           "RPRN: Operation can\'t be constructed, because the request is missing.");
                    return;
                }
                res.Origins = [rpcMsg as any message];
                WinSpool.Opnum100NotUsedOnWire op = new WinSpool.Opnum100NotUsedOnWire {};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 101 =>
                _WinSpoolMessages._Opnum101NotUsedOnWireRequest req0 = req as _WinSpoolMessages._Opnum101NotUsedOnWireRequest;
                optional _WinSpoolMessages._Opnum101NotUsedOnWireResponse m = NdrDecoder<_WinSpoolMessages._Opnum101NotUsedOnWireResponse>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: Opnum101NotUsedOnWire response (opnum 101) is not decoded successfully";
                }
                _WinSpoolMessages._Opnum101NotUsedOnWireResponse res = m as _WinSpoolMessages._Opnum101NotUsedOnWireResponse;
                if (req0 == null)
                {
                    if (req != null)
                    {
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                        ReportInsufficientData(req,
                                               DiagnosisLevel.Warning,
                                               "RPRN: Operation can\'t be constructed, because the response is missing.");
                    }
                    dispatch endpoint _ExtendedRprnService over server issues res;
                    ReportInsufficientData(res,
                                           DiagnosisLevel.Warning,
                                           "RPRN: Operation can\'t be constructed, because the request is missing.");
                    return;
                }
                res.Origins = [rpcMsg as any message];
                WinSpool.Opnum101NotUsedOnWire op = new WinSpool.Opnum101NotUsedOnWire {};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 102 =>
                if (req == null || !(req is _WinSpoolMessages._RpcGetCorePrinterDriversRequest))
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    ReportInsufficientData(req,
                                           DiagnosisLevel.Warning,
                                           "RPRN: RpcGetCorePrinterDrivers response (opnum 102) is not decoded successfully, because the request is missing.");
                    return;
                }
                _WinSpoolMessages._RpcGetCorePrinterDriversRequest req0 = req as _WinSpoolMessages._RpcGetCorePrinterDriversRequest;
                optional _WinSpoolMessages._RpcGetCorePrinterDriversResponse[req0.cCorePrinterDrivers] m = 
                    NdrDecoder<_WinSpoolMessages._RpcGetCorePrinterDriversResponse[req0.cCorePrinterDrivers]>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: RpcGetCorePrinterDrivers response (opnum 102) is not decoded successfully";
                }
                _WinSpoolMessages._RpcGetCorePrinterDriversResponse[req0.cCorePrinterDrivers] res = m as _WinSpoolMessages._RpcGetCorePrinterDriversResponse;
                res.Origins = [rpcMsg as any message];
                WinSpool.RpcGetCorePrinterDrivers op = new WinSpool.RpcGetCorePrinterDrivers
                        {pszServer = req0.pszServer,
                         pszEnvironment = req0.pszEnvironment,
                         cchCoreDrivers = req0.cchCoreDrivers,
                         pszzCoreDriverDependencies = req0.pszzCoreDriverDependencies,
                         cCorePrinterDrivers = req0.cCorePrinterDrivers,
                         pCorePrinterDrivers = res.pCorePrinterDrivers,
                         ReturnValue = res.ReturnValue};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 103 =>
                _WinSpoolMessages._Opnum103NotUsedOnWireRequest req0 = req as _WinSpoolMessages._Opnum103NotUsedOnWireRequest;
                optional _WinSpoolMessages._Opnum103NotUsedOnWireResponse m = NdrDecoder<_WinSpoolMessages._Opnum103NotUsedOnWireResponse>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: Opnum103NotUsedOnWire response (opnum 103) is not decoded successfully";
                }
                _WinSpoolMessages._Opnum103NotUsedOnWireResponse res = m as _WinSpoolMessages._Opnum103NotUsedOnWireResponse;
                if (req0 == null)
                {
                    if (req != null)
                    {
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                        ReportInsufficientData(req,
                                               DiagnosisLevel.Warning,
                                               "RPRN: Operation can\'t be constructed, because the response is missing.");
                    }
                    dispatch endpoint _ExtendedRprnService over server issues res;
                    ReportInsufficientData(res,
                                           DiagnosisLevel.Warning,
                                           "RPRN: Operation can\'t be constructed, because the request is missing.");
                    return;
                }
                res.Origins = [rpcMsg as any message];
                WinSpool.Opnum103NotUsedOnWire op = new WinSpool.Opnum103NotUsedOnWire {};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 104 =>
                if (req == null || !(req is _WinSpoolMessages._RpcGetPrinterDriverPackagePathRequest))
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    ReportInsufficientData(req,
                                           DiagnosisLevel.Warning,
                                           "RPRN: RpcGetPrinterDriverPackagePath response (opnum 104) is not decoded successfully, because the request is missing.");
                    return;
                }
                _WinSpoolMessages._RpcGetPrinterDriverPackagePathRequest req0 = req as _WinSpoolMessages._RpcGetPrinterDriverPackagePathRequest;
                optional _WinSpoolMessages._RpcGetPrinterDriverPackagePathResponse[req0.cchDriverPackageCab] m = 
                    NdrDecoder<_WinSpoolMessages._RpcGetPrinterDriverPackagePathResponse[req0.cchDriverPackageCab]>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: RpcGetPrinterDriverPackagePath response (opnum 104) is not decoded successfully";
                }
                _WinSpoolMessages._RpcGetPrinterDriverPackagePathResponse[req0.cchDriverPackageCab] res = m as _WinSpoolMessages._RpcGetPrinterDriverPackagePathResponse;
                res.Origins = [rpcMsg as any message];
                WinSpool.RpcGetPrinterDriverPackagePath op = new WinSpool.RpcGetPrinterDriverPackagePath
                        {pszServer = req0.pszServer,
                         pszEnvironment = req0.pszEnvironment,
                         pszLanguage = req0.pszLanguage,
                         pszPackageID = req0.pszPackageID,
                         pszDriverPackageCab = res.pszDriverPackageCab,
                         cchDriverPackageCab = req0.cchDriverPackageCab,
                         pcchRequiredSize = res.pcchRequiredSize,
                         ReturnValue = res.ReturnValue};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 105 =>
                _WinSpoolMessages._Opnum105NotUsedOnWireRequest req0 = req as _WinSpoolMessages._Opnum105NotUsedOnWireRequest;
                optional _WinSpoolMessages._Opnum105NotUsedOnWireResponse m = NdrDecoder<_WinSpoolMessages._Opnum105NotUsedOnWireResponse>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: Opnum105NotUsedOnWire response (opnum 105) is not decoded successfully";
                }
                _WinSpoolMessages._Opnum105NotUsedOnWireResponse res = m as _WinSpoolMessages._Opnum105NotUsedOnWireResponse;
                if (req0 == null)
                {
                    if (req != null)
                    {
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                        ReportInsufficientData(req,
                                               DiagnosisLevel.Warning,
                                               "RPRN: Operation can\'t be constructed, because the response is missing.");
                    }
                    dispatch endpoint _ExtendedRprnService over server issues res;
                    ReportInsufficientData(res,
                                           DiagnosisLevel.Warning,
                                           "RPRN: Operation can\'t be constructed, because the request is missing.");
                    return;
                }
                res.Origins = [rpcMsg as any message];
                WinSpool.Opnum105NotUsedOnWire op = new WinSpool.Opnum105NotUsedOnWire {};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 106 =>
                _WinSpoolMessages._Opnum106NotUsedOnWireRequest req0 = req as _WinSpoolMessages._Opnum106NotUsedOnWireRequest;
                optional _WinSpoolMessages._Opnum106NotUsedOnWireResponse m = NdrDecoder<_WinSpoolMessages._Opnum106NotUsedOnWireResponse>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: Opnum106NotUsedOnWire response (opnum 106) is not decoded successfully";
                }
                _WinSpoolMessages._Opnum106NotUsedOnWireResponse res = m as _WinSpoolMessages._Opnum106NotUsedOnWireResponse;
                if (req0 == null)
                {
                    if (req != null)
                    {
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                        ReportInsufficientData(req,
                                               DiagnosisLevel.Warning,
                                               "RPRN: Operation can\'t be constructed, because the response is missing.");
                    }
                    dispatch endpoint _ExtendedRprnService over server issues res;
                    ReportInsufficientData(res,
                                           DiagnosisLevel.Warning,
                                           "RPRN: Operation can\'t be constructed, because the request is missing.");
                    return;
                }
                res.Origins = [rpcMsg as any message];
                WinSpool.Opnum106NotUsedOnWire op = new WinSpool.Opnum106NotUsedOnWire {};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 107 =>
                _WinSpoolMessages._Opnum107NotUsedOnWireRequest req0 = req as _WinSpoolMessages._Opnum107NotUsedOnWireRequest;
                optional _WinSpoolMessages._Opnum107NotUsedOnWireResponse m = NdrDecoder<_WinSpoolMessages._Opnum107NotUsedOnWireResponse>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: Opnum107NotUsedOnWire response (opnum 107) is not decoded successfully";
                }
                _WinSpoolMessages._Opnum107NotUsedOnWireResponse res = m as _WinSpoolMessages._Opnum107NotUsedOnWireResponse;
                if (req0 == null)
                {
                    if (req != null)
                    {
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                        ReportInsufficientData(req,
                                               DiagnosisLevel.Warning,
                                               "RPRN: Operation can\'t be constructed, because the response is missing.");
                    }
                    dispatch endpoint _ExtendedRprnService over server issues res;
                    ReportInsufficientData(res,
                                           DiagnosisLevel.Warning,
                                           "RPRN: Operation can\'t be constructed, because the request is missing.");
                    return;
                }
                res.Origins = [rpcMsg as any message];
                WinSpool.Opnum107NotUsedOnWire op = new WinSpool.Opnum107NotUsedOnWire {};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 108 =>
                _WinSpoolMessages._Opnum108NotUsedOnWireRequest req0 = req as _WinSpoolMessages._Opnum108NotUsedOnWireRequest;
                optional _WinSpoolMessages._Opnum108NotUsedOnWireResponse m = NdrDecoder<_WinSpoolMessages._Opnum108NotUsedOnWireResponse>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: Opnum108NotUsedOnWire response (opnum 108) is not decoded successfully";
                }
                _WinSpoolMessages._Opnum108NotUsedOnWireResponse res = m as _WinSpoolMessages._Opnum108NotUsedOnWireResponse;
                if (req0 == null)
                {
                    if (req != null)
                    {
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                        ReportInsufficientData(req,
                                               DiagnosisLevel.Warning,
                                               "RPRN: Operation can\'t be constructed, because the response is missing.");
                    }
                    dispatch endpoint _ExtendedRprnService over server issues res;
                    ReportInsufficientData(res,
                                           DiagnosisLevel.Warning,
                                           "RPRN: Operation can\'t be constructed, because the request is missing.");
                    return;
                }
                res.Origins = [rpcMsg as any message];
                WinSpool.Opnum108NotUsedOnWire op = new WinSpool.Opnum108NotUsedOnWire {};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 109 =>
                _WinSpoolMessages._Opnum109NotUsedOnWireRequest req0 = req as _WinSpoolMessages._Opnum109NotUsedOnWireRequest;
                optional _WinSpoolMessages._Opnum109NotUsedOnWireResponse m = NdrDecoder<_WinSpoolMessages._Opnum109NotUsedOnWireResponse>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: Opnum109NotUsedOnWire response (opnum 109) is not decoded successfully";
                }
                _WinSpoolMessages._Opnum109NotUsedOnWireResponse res = m as _WinSpoolMessages._Opnum109NotUsedOnWireResponse;
                if (req0 == null)
                {
                    if (req != null)
                    {
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                        ReportInsufficientData(req,
                                               DiagnosisLevel.Warning,
                                               "RPRN: Operation can\'t be constructed, because the response is missing.");
                    }
                    dispatch endpoint _ExtendedRprnService over server issues res;
                    ReportInsufficientData(res,
                                           DiagnosisLevel.Warning,
                                           "RPRN: Operation can\'t be constructed, because the request is missing.");
                    return;
                }
                res.Origins = [rpcMsg as any message];
                WinSpool.Opnum109NotUsedOnWire op = new WinSpool.Opnum109NotUsedOnWire {};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 110 =>
                _WinSpoolMessages._RpcGetJobNamedPropertyValueRequest req0 = req as _WinSpoolMessages._RpcGetJobNamedPropertyValueRequest;
                optional _WinSpoolMessages._RpcGetJobNamedPropertyValueResponse m = NdrDecoder<_WinSpoolMessages._RpcGetJobNamedPropertyValueResponse>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: RpcGetJobNamedPropertyValue response (opnum 110) is not decoded successfully";
                }
                _WinSpoolMessages._RpcGetJobNamedPropertyValueResponse res = m as _WinSpoolMessages._RpcGetJobNamedPropertyValueResponse;
                if (req0 == null)
                {
                    if (req != null)
                    {
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                        ReportInsufficientData(req,
                                               DiagnosisLevel.Warning,
                                               "RPRN: Operation can\'t be constructed, because the response is missing.");
                    }
                    dispatch endpoint _ExtendedRprnService over server issues res;
                    ReportInsufficientData(res,
                                           DiagnosisLevel.Warning,
                                           "RPRN: Operation can\'t be constructed, because the request is missing.");
                    return;
                }
                res.Origins = [rpcMsg as any message];
                WinSpool.RpcGetJobNamedPropertyValue op = new WinSpool.RpcGetJobNamedPropertyValue
                        {hPrinter = req0.hPrinter,
                         JobId = req0.JobId,
                         pszName = req0.pszName,
                         pValue = res.pValue,
                         ReturnValue = res.ReturnValue};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 111 =>
                _WinSpoolMessages._RpcSetJobNamedPropertyRequest req0 = req as _WinSpoolMessages._RpcSetJobNamedPropertyRequest;
                optional _WinSpoolMessages._RpcSetJobNamedPropertyResponse m = NdrDecoder<_WinSpoolMessages._RpcSetJobNamedPropertyResponse>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: RpcSetJobNamedProperty response (opnum 111) is not decoded successfully";
                }
                _WinSpoolMessages._RpcSetJobNamedPropertyResponse res = m as _WinSpoolMessages._RpcSetJobNamedPropertyResponse;
                if (req0 == null)
                {
                    if (req != null)
                    {
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                        ReportInsufficientData(req,
                                               DiagnosisLevel.Warning,
                                               "RPRN: Operation can\'t be constructed, because the response is missing.");
                    }
                    dispatch endpoint _ExtendedRprnService over server issues res;
                    ReportInsufficientData(res,
                                           DiagnosisLevel.Warning,
                                           "RPRN: Operation can\'t be constructed, because the request is missing.");
                    return;
                }
                res.Origins = [rpcMsg as any message];
                WinSpool.RpcSetJobNamedProperty op = new WinSpool.RpcSetJobNamedProperty
                        {hPrinter = req0.hPrinter,
                         JobId = req0.JobId,
                         pProperty = req0.pProperty,
                         ReturnValue = res.ReturnValue};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 112 =>
                _WinSpoolMessages._RpcDeleteJobNamedPropertyRequest req0 = req as _WinSpoolMessages._RpcDeleteJobNamedPropertyRequest;
                optional _WinSpoolMessages._RpcDeleteJobNamedPropertyResponse m = NdrDecoder<_WinSpoolMessages._RpcDeleteJobNamedPropertyResponse>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: RpcDeleteJobNamedProperty response (opnum 112) is not decoded successfully";
                }
                _WinSpoolMessages._RpcDeleteJobNamedPropertyResponse res = m as _WinSpoolMessages._RpcDeleteJobNamedPropertyResponse;
                if (req0 == null)
                {
                    if (req != null)
                    {
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                        ReportInsufficientData(req,
                                               DiagnosisLevel.Warning,
                                               "RPRN: Operation can\'t be constructed, because the response is missing.");
                    }
                    dispatch endpoint _ExtendedRprnService over server issues res;
                    ReportInsufficientData(res,
                                           DiagnosisLevel.Warning,
                                           "RPRN: Operation can\'t be constructed, because the request is missing.");
                    return;
                }
                res.Origins = [rpcMsg as any message];
                WinSpool.RpcDeleteJobNamedProperty op = new WinSpool.RpcDeleteJobNamedProperty
                        {hPrinter = req0.hPrinter,
                         JobId = req0.JobId,
                         pszName = req0.pszName,
                         ReturnValue = res.ReturnValue};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 113 =>
                _WinSpoolMessages._RpcEnumJobNamedPropertiesRequest req0 = req as _WinSpoolMessages._RpcEnumJobNamedPropertiesRequest;
                optional _WinSpoolMessages._RpcEnumJobNamedPropertiesResponse m = NdrDecoder<_WinSpoolMessages._RpcEnumJobNamedPropertiesResponse>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: RpcEnumJobNamedProperties response (opnum 113) is not decoded successfully";
                }
                _WinSpoolMessages._RpcEnumJobNamedPropertiesResponse res = m as _WinSpoolMessages._RpcEnumJobNamedPropertiesResponse;
                if (req0 == null)
                {
                    if (req != null)
                    {
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                        ReportInsufficientData(req,
                                               DiagnosisLevel.Warning,
                                               "RPRN: Operation can\'t be constructed, because the response is missing.");
                    }
                    dispatch endpoint _ExtendedRprnService over server issues res;
                    ReportInsufficientData(res,
                                           DiagnosisLevel.Warning,
                                           "RPRN: Operation can\'t be constructed, because the request is missing.");
                    return;
                }
                res.Origins = [rpcMsg as any message];
                WinSpool.RpcEnumJobNamedProperties op = new WinSpool.RpcEnumJobNamedProperties
                        {hPrinter = req0.hPrinter,
                         JobId = req0.JobId,
                         pcProperties = res.pcProperties,
                         ppProperties = res.ppProperties,
                         ReturnValue = res.ReturnValue};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 114 =>
                _WinSpoolMessages._Opnum114NotUsedOnWireRequest req0 = req as _WinSpoolMessages._Opnum114NotUsedOnWireRequest;
                optional _WinSpoolMessages._Opnum114NotUsedOnWireResponse m = NdrDecoder<_WinSpoolMessages._Opnum114NotUsedOnWireResponse>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: Opnum114NotUsedOnWire response (opnum 114) is not decoded successfully";
                }
                _WinSpoolMessages._Opnum114NotUsedOnWireResponse res = m as _WinSpoolMessages._Opnum114NotUsedOnWireResponse;
                if (req0 == null)
                {
                    if (req != null)
                    {
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                        ReportInsufficientData(req,
                                               DiagnosisLevel.Warning,
                                               "RPRN: Operation can\'t be constructed, because the response is missing.");
                    }
                    dispatch endpoint _ExtendedRprnService over server issues res;
                    ReportInsufficientData(res,
                                           DiagnosisLevel.Warning,
                                           "RPRN: Operation can\'t be constructed, because the request is missing.");
                    return;
                }
                res.Origins = [rpcMsg as any message];
                WinSpool.Opnum114NotUsedOnWire op = new WinSpool.Opnum114NotUsedOnWire {};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 115 =>
                _WinSpoolMessages._Opnum115NotUsedOnWireRequest req0 = req as _WinSpoolMessages._Opnum115NotUsedOnWireRequest;
                optional _WinSpoolMessages._Opnum115NotUsedOnWireResponse m = NdrDecoder<_WinSpoolMessages._Opnum115NotUsedOnWireResponse>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: Opnum115NotUsedOnWire response (opnum 115) is not decoded successfully";
                }
                _WinSpoolMessages._Opnum115NotUsedOnWireResponse res = m as _WinSpoolMessages._Opnum115NotUsedOnWireResponse;
                if (req0 == null)
                {
                    if (req != null)
                    {
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                        ReportInsufficientData(req,
                                               DiagnosisLevel.Warning,
                                               "RPRN: Operation can\'t be constructed, because the response is missing.");
                    }
                    dispatch endpoint _ExtendedRprnService over server issues res;
                    ReportInsufficientData(res,
                                           DiagnosisLevel.Warning,
                                           "RPRN: Operation can\'t be constructed, because the request is missing.");
                    return;
                }
                res.Origins = [rpcMsg as any message];
                WinSpool.Opnum115NotUsedOnWire op = new WinSpool.Opnum115NotUsedOnWire {};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            case $ 116 =>
                _WinSpoolMessages._RpcLogJobInfoForBranchOfficeRequest req0 = req as _WinSpoolMessages._RpcLogJobInfoForBranchOfficeRequest;
                optional _WinSpoolMessages._RpcLogJobInfoForBranchOfficeResponse m = NdrDecoder<_WinSpoolMessages._RpcLogJobInfoForBranchOfficeResponse>(rpcMsg.StubData, ndrInfo);
                if (m == nothing)
                {
                    if (req != null)
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                    throw "RPRN: RpcLogJobInfoForBranchOffice response (opnum 116) is not decoded successfully";
                }
                _WinSpoolMessages._RpcLogJobInfoForBranchOfficeResponse res = m as _WinSpoolMessages._RpcLogJobInfoForBranchOfficeResponse;
                if (req0 == null)
                {
                    if (req != null)
                    {
                        dispatch endpoint _ExtendedRprnService over server accepts req;
                        ReportInsufficientData(req,
                                               DiagnosisLevel.Warning,
                                               "RPRN: Operation can\'t be constructed, because the response is missing.");
                    }
                    dispatch endpoint _ExtendedRprnService over server issues res;
                    ReportInsufficientData(res,
                                           DiagnosisLevel.Warning,
                                           "RPRN: Operation can\'t be constructed, because the request is missing.");
                    return;
                }
                res.Origins = [rpcMsg as any message];
                WinSpool.RpcLogJobInfoForBranchOffice op = new WinSpool.RpcLogJobInfoForBranchOffice
                        {hPrinter = req0.hPrinter,
                         pBranchOfficeJobDataContainer = req0.pBranchOfficeJobDataContainer,
                         ReturnValue = res.ReturnValue};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  RprnService over server accepts op;
            default =>
                var res =
                    BinaryDecoder<_ExtendedWinSpoolMessages.UnknownResponse>(rpcMsg.StubData) as _ExtendedWinSpoolMessages.UnknownResponse;
                res.Origins = [rpcMsg as any message];
                assert req != null;
                var op = new _ExtendedWinSpool.UnknownOperation{Opnum = rpcMsg#RpcOpnum as ushort};
                op.Origins = [req as any message, res as any message];
                dispatch endpoint  _ExtendedRprnService over server accepts op;
        }
    }
    ~endpoint(MSRPCE.Server server)
    {
        foreach (var req in requestCache.Values)
        {
            ReportInsufficientData(req,
                                   DiagnosisLevel.Warning,
                                   "RPRN: Incomplete operation due to response is missing.");
            release req;
        }
        requestCache = null;
    }
}

endpoint _ExtendedRprnService
    over MSRPCE.Server accepts any message issues any message;
// --- AOP Generated OPN code ends ---

contract WinSpool
{
    accepts operation RpcEnumPrinters
    {
        in PrinterEnumerationFlags Flags
            with Encoding{Decoder = PatternDecoder<PrinterEnumerationFlags>, SourcePattern = TypeOf<DWORD>()};
        in string Name
               with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                         BaseStringType = TypeOf<STRING_HANDLE>(),
                                         String = true};
        in PrinterInfoLevel Level 
            with Encoding{Decoder = PatternDecoder<PrinterInfoLevel>, SourcePattern = TypeOf<DWORD>()};
        in out (array<BYTE> | PrinterInfoPattern) pPrinterEnum
                   with Technologies.IDL.IDL{Size_is = [cbBuf], PointerType = PointerKind.UniquePtr,
                                             IndirectionLevel = 1};
        in DWORD cbBuf;
        out DWORD pcbNeeded with Technologies.IDL.IDL{IndirectionLevel = 1};
        out DWORD pcReturned with Technologies.IDL.IDL{IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RpcEnumPrinters" + ", ReturnValue: " + Win32ErrorCodesToText(ReturnValue) + 
                ", Flags: " + Flags.ToString() + ", Name: " +
                Name.ToString() + ", Level: " + Level.ToString() +
                ", pPrinterEnum: " + pPrinterEnum.ToString() + 
                ", pcReturned: " + pcReturned.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 0};
    
    accepts operation RpcOpenPrinter
    {
        in string pPrinterName
               with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                         BaseStringType = TypeOf<STRING_HANDLE>(),
                                         String = true};
        out PRINTER_HANDLE pHandle
                with Technologies.IDL.IDL{IndirectionLevel = 1};
        in string pDatatype
               with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                         BaseStringType = TypeOf<wchar_t>(),
                                         String = true,
                                         IndirectionLevel = 1};
        in DEVMODE_CONTAINER pDevModeContainer
               with Technologies.IDL.IDL{IndirectionLevel = 1};
        in AccessValuesFlags AccessRequired
            with Encoding{Decoder = PatternDecoder<AccessMaskFlags>, SourcePattern = TypeOf<DWORD>()};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RpcOpenPrinter" + ", ReturnValue: " + Win32ErrorCodesToText(ReturnValue) + 
                ", pPrinterName: " + pPrinterName.ToString() +
                ", pHandle: " + pHandle.ToString() + ", pDatatype: " +
                pDatatype.ToString() + ", pDevModeContainer: " +
                pDevModeContainer.ToString() + ", AccessRequired: " +
                AccessRequired.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 1};
    
    accepts operation RpcSetJob
    {
        in PRINTER_HANDLE hPrinter;
        in DWORD JobId where ValidationCheckValue(value != 0, null, true, ReferenceType.Type, 
                                                  "RPRN", "JobId", "RpcSetJob", "not 0", value);
        in JOB_CONTAINER pJobContainer
               with Technologies.IDL.IDL
                        {PointerType = PointerKind.UniquePtr, IndirectionLevel = 1};
        in JobControlCommand Command
            where ValidationCheckEnumValue(InRange<JobControlCommand>(value), null, true, ReferenceType.Type, 
                                           "RPRN", "Command", "RpcSetJob", "in [0, 9]", value);
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RpcSetJob" + ", ReturnValue: " + Win32ErrorCodesToText(ReturnValue) + 
                ", hPrinter: " + hPrinter.ToString() + ", JobId: " +
                JobId.ToString() + ", pJobContainer: " + (pJobContainer == null ? "" : pJobContainer.ToString()) + 
                ", Command: " + Command.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 2};
    
    accepts operation RpcGetJob
    {
        in PRINTER_HANDLE hPrinter;
        in DWORD JobId where ValidationCheckValue(value != 0, null, true, ReferenceType.Type, 
                                                  "RPRN", "JobId", "RpcGetJob", "not 0", value);
        in JobInfoLevel Level
            where ValidationCheckValue(value in [1, 2, 3, 4], null, true, ReferenceType.Type, 
                                       "RPRN", "Level", "RpcGetJob", "1, 2, 3, 4", value)
            with Encoding{Decoder = PatternDecoder<JobInfoLevel>, SourcePattern = TypeOf<DWORD>()};
        in out (array<BYTE> | JobInfoPattern) pJob
                   with Technologies.IDL.IDL{Size_is = [cbBuf], PointerType = PointerKind.UniquePtr,
                                             IndirectionLevel = 1};
        in DWORD cbBuf;
        out DWORD pcbNeeded with Technologies.IDL.IDL{IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RpcGetJob" + ", ReturnValue: " + Win32ErrorCodesToText(ReturnValue) + 
                ", hPrinter: " + hPrinter.ToString() + ", JobId: " +
                JobId.ToString() + ", Level: " + Level.ToString() + ", pJob: " + pJob.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 3};
    
    accepts operation RpcEnumJobs
    {
        in PRINTER_HANDLE hPrinter;
        in DWORD FirstJob;
        in DWORD NoJobs;
        in JobInfoLevel Level
             where ValidationCheckValue(value in [1, 2, 3, 4], null, true, ReferenceType.Type, 
                                        "RPRN", "Level", "RpcGetJob", "1, 2, 3, 4", value)
             with Encoding{Decoder = PatternDecoder<JobInfoLevel>, SourcePattern = TypeOf<DWORD>()};
        in out (array<BYTE> | JobInfoPattern) pJob
                with Technologies.IDL.IDL{Size_is = [cbBuf], PointerType = PointerKind.UniquePtr,
                                            IndirectionLevel = 1};
        in DWORD cbBuf;
        out DWORD pcbNeeded with Technologies.IDL.IDL{IndirectionLevel = 1};
        out DWORD pcReturned with Technologies.IDL.IDL{IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RpcEnumJobs" + ", ReturnValue: " + Win32ErrorCodesToText(ReturnValue) + 
                ", hPrinter: " + hPrinter.ToString() +
                ", FirstJob: " + FirstJob.ToString() + ", NoJobs: " +
                NoJobs.ToString() + ", Level: " + Level.ToString() + ", pJob: " +
                pJob.ToString() + ", pcReturned: " +
                pcReturned.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 4};
    
    accepts operation RpcAddPrinter
    {
        in string pName
               with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                         BaseStringType = TypeOf<STRING_HANDLE>(),
                                         String = true};
        in PRINTER_CONTAINER pPrinterContainer
               with Technologies.IDL.IDL{IndirectionLevel = 1};
        in DEVMODE_CONTAINER pDevModeContainer
               with Technologies.IDL.IDL{IndirectionLevel = 1};
        in SECURITY_CONTAINER pSecurityContainer
               with Technologies.IDL.IDL{IndirectionLevel = 1};
        out PRINTER_HANDLE pHandle
                with Technologies.IDL.IDL{IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RpcAddPrinter" + ", ReturnValue: " + Win32ErrorCodesToText(ReturnValue) + 
                ", pName: " + pName.ToString() +
                ", pPrinterContainer: " + pPrinterContainer.ToString() +
                ", pDevModeContainer: " + pDevModeContainer.ToString() +
                ", pSecurityContainer: " + pSecurityContainer.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 5};
    
    accepts operation RpcDeletePrinter
    {
        in PRINTER_HANDLE hPrinter;
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RpcDeletePrinter" + ", ReturnValue: " + Win32ErrorCodesToText(ReturnValue) + 
                ", hPrinter: " + hPrinter.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 6};
    
    accepts operation RpcSetPrinter
    {
        in PRINTER_HANDLE hPrinter;
        in PRINTER_CONTAINER pPrinterContainer
               with Technologies.IDL.IDL{IndirectionLevel = 1};
        in DEVMODE_CONTAINER pDevModeContainer
               with Technologies.IDL.IDL{IndirectionLevel = 1};
        in SECURITY_CONTAINER pSecurityContainer
               with Technologies.IDL.IDL{IndirectionLevel = 1};
        in PrinterControlCommand Command 
            with Encoding{Decoder = PatternDecoder<PrinterControlCommand>, SourcePattern = TypeOf<DWORD>()};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RpcSetPrinter" + ", ReturnValue: " +
                Win32ErrorCodesToText(ReturnValue) + ", hPrinter: " + hPrinter.ToString() +
                ", pPrinterContainer: " + pPrinterContainer.ToString() +
                ", pDevModeContainer: " + pDevModeContainer.ToString() +
                ", pSecurityContainer: " + pSecurityContainer.ToString() +
                ", Command: " + Command.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 7};
    
    accepts operation RpcGetPrinter
    {
        in PRINTER_HANDLE hPrinter;
        in PrinterInfoLevel Level 
            with Encoding{Decoder = PatternDecoder<PrinterInfoLevel>, SourcePattern = TypeOf<DWORD>()};
        in out (array<BYTE> | PrinterInfoPattern) pPrinter
                with Technologies.IDL.IDL{Size_is = [cbBuf],
                                          PointerType = PointerKind.UniquePtr,
                                          IndirectionLevel = 1};
        in DWORD cbBuf;
        out DWORD pcbNeeded with Technologies.IDL.IDL{IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RpcGetPrinter" + ", ReturnValue: " + Win32ErrorCodesToText(ReturnValue) + 
                ", hPrinter: " + hPrinter.ToString() + 
                ", Level: " + Level.ToString() + ", pPrinter: " + pPrinter.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 8};
    
    accepts operation RpcAddPrinterDriver
    {
        in string pName
               with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                         BaseStringType = TypeOf<STRING_HANDLE>(),
                                         String = true};
        in DRIVER_CONTAINER pDriverContainer
               with Technologies.IDL.IDL{IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RpcAddPrinterDriver" + ", ReturnValue: " + Win32ErrorCodesToText(ReturnValue) + 
                ", pName: " + pName.ToString() + ", pDriverContainer: " + pDriverContainer.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 9};
    
    accepts operation RpcEnumPrinterDrivers
    {
        in string pName
               with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                         BaseStringType = TypeOf<STRING_HANDLE>(),
                                         String = true};
        in string pEnvironment
               with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                         BaseStringType = TypeOf<wchar_t>(),
                                         String = true,
                                         IndirectionLevel = 1};
        in DriverInfoLevel Level 
            with Encoding{Decoder = PatternDecoder<DriverInfoLevel>, SourcePattern = TypeOf<DWORD>()};
        in out (array<byte> | DriverInfoPattern) pDrivers
                   with Technologies.IDL.IDL{Size_is = [cbBuf], PointerType = PointerKind.UniquePtr,
                                             IndirectionLevel = 1};
        in DWORD cbBuf;
        out DWORD pcbNeeded with Technologies.IDL.IDL{IndirectionLevel = 1};
        out DWORD pcReturned with Technologies.IDL.IDL{IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RpcEnumPrinterDrivers" + ", ReturnValue: " + Win32ErrorCodesToText(ReturnValue) + 
                ", pName: " + pName.ToString() + ", pEnvironment: " + pEnvironment.ToString() + 
                ", Level: " + Level.ToString() + ", pDrivers: " + pDrivers.ToString() + 
                ", pcReturned: " + pcReturned.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 10};
    
    accepts operation RpcGetPrinterDriver
    {
        in PRINTER_HANDLE hPrinter;
        in string pEnvironment
               with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                         BaseStringType = TypeOf<wchar_t>(),
                                         String = true,
                                         IndirectionLevel = 1};
        in DriverInfoLevel Level 
            with Encoding{Decoder = PatternDecoder<DriverInfoLevel>, SourcePattern = TypeOf<DWORD>()};
        in out (array<BYTE> | DriverInfoPattern) pDriver
                with Technologies.IDL.IDL{Size_is = [cbBuf],
                                            PointerType = PointerKind.UniquePtr,
                                            IndirectionLevel = 1};
        in DWORD cbBuf;
        out DWORD pcbNeeded with Technologies.IDL.IDL{IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RpcGetPrinterDriver" + ", ReturnValue: " + Win32ErrorCodesToText(ReturnValue) + 
                ", hPrinter: " + hPrinter.ToString() +
                ", pEnvironment: " + pEnvironment.ToString() + ", Level: " +
                Level.ToString() + ", pDriver: " + pDriver.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 11};
    
    accepts operation RpcGetPrinterDriverDirectory
    {
        in string pName
               with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                         BaseStringType = TypeOf<STRING_HANDLE>(),
                                         String = true};
        in string pEnvironment
               with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                         BaseStringType = TypeOf<wchar_t>(),
                                         String = true,
                                         IndirectionLevel = 1};
        in DWORD Level where ValidationCheckValue(value == 1, null, true, ReferenceType.Type, 
                                                  "RPRN", "Level", "RpcGetPrinterDriverDirectory", "1", value);
        in out (array<BYTE> | array<string>) pDriverDirectory
                   with Technologies.IDL.IDL{Size_is = [cbBuf],
                                             PointerType = PointerKind.UniquePtr,
                                             IndirectionLevel = 1};
        in DWORD cbBuf;
        out DWORD pcbNeeded with Technologies.IDL.IDL{IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RpcGetPrinterDriverDirectory" + ", ReturnValue: " + Win32ErrorCodesToText(ReturnValue) + 
                ", pName: " + pName + ", pEnvironment: " + pEnvironment.ToString() + ", Level: " + Level.ToString() + 
                ", pDriverDirectory: " + pDriverDirectory.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 12};
    
    accepts operation RpcDeletePrinterDriver
    {
        in string pName
               with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                         BaseStringType = TypeOf<STRING_HANDLE>(),
                                         String = true};
        in string pEnvironment
               with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                         String = true,
                                         IndirectionLevel = 1};
        in string pDriverName
               with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                         String = true,
                                         IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RpcDeletePrinterDriver" + ", ReturnValue: " +
                Win32ErrorCodesToText(ReturnValue) + ", pName: " + pName.ToString() +
                ", pEnvironment: " + pEnvironment.ToString() + ", pDriverName: " +
                pDriverName.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 13};
    
    accepts operation RpcAddPrintProcessor
    {
        in string pName
               with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                         BaseStringType = TypeOf<STRING_HANDLE>(),
                                         String = true};
        in string pEnvironment
               with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                         String = true,
                                         IndirectionLevel = 1};
        in string pPathName
               with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                         String = true,
                                         IndirectionLevel = 1};
        in string pPrintProcessorName
               with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                         String = true,
                                         IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RpcAddPrintProcessor" + ", ReturnValue: " +
                Win32ErrorCodesToText(ReturnValue) + ", pName: " + pName.ToString() +
                ", pEnvironment: " + pEnvironment.ToString() + ", pPathName: " +
                pPathName.ToString() + ", pPrintProcessorName: " +
                pPrintProcessorName.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 14};
    
    accepts operation RpcEnumPrintProcessors
    {
        in string pName
               with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                         BaseStringType = TypeOf<STRING_HANDLE>(),
                                         String = true};
        in string pEnvironment
               with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                         BaseStringType = TypeOf<wchar_t>(),
                                         String = true,
                                         IndirectionLevel = 1};
        in DWORD Level where ValidationCheckValue(value == 1, null, true, ReferenceType.Type, 
                                                  "RPRN", "Level", "RpcEnumPrintProcessors", "1", value);
        in out (array<BYTE> | PRINTPROCESSOR_INFO_1) pPrintProcessorInfo
                   with Technologies.IDL.IDL{Size_is = [cbBuf],
                                             PointerType = PointerKind.UniquePtr,
                                             IndirectionLevel = 1};
        in DWORD cbBuf;
        out DWORD pcbNeeded with Technologies.IDL.IDL{IndirectionLevel = 1};
        out DWORD pcReturned with Technologies.IDL.IDL{IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RpcEnumPrintProcessors" + ", ReturnValue: " + Win32ErrorCodesToText(ReturnValue) + 
                ", pName: " + pName.ToString() +
                ", pEnvironment: " + pEnvironment.ToString() + ", Level: " + Level.ToString() + 
                ", pPrintProcessorInfo: " + pPrintProcessorInfo.ToString() + 
                ", pcReturned: " + pcReturned.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 15}

    accepts operation RpcGetPrintProcessorDirectory
    {
        in string pName
               with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                         BaseStringType = TypeOf<STRING_HANDLE>(),
                                         String = true};
        in string pEnvironment
               with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                         BaseStringType = TypeOf<wchar_t>(),
                                         String = true,
                                         IndirectionLevel = 1};
        in DWORD Level where ValidationCheckValue(value == 1, null, true, ReferenceType.Type, 
                                                  "RPRN", "Level", "RpcGetPrintProcessorDirectory", "1", value);
        in out (array<BYTE> | array<string>) pPrintProcessorDirectory
                   with Technologies.IDL.IDL{Size_is = [cbBuf],
                                             PointerType = PointerKind.UniquePtr,
                                             IndirectionLevel = 1};
        in DWORD cbBuf;
        out DWORD pcbNeeded with Technologies.IDL.IDL{IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RpcGetPrintProcessorDirectory" + 
                ", ReturnValue: " + Win32ErrorCodesToText(ReturnValue) + ", pName: " + pName.ToString() +
                ", pEnvironment: " + pEnvironment.ToString() + ", Level: " +
                Level.ToString() + ", pPrintProcessorDirectory: " + pPrintProcessorDirectory.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 16};
    
    accepts operation RpcStartDocPrinter
    {
        in PRINTER_HANDLE hPrinter;
        in DOC_INFO_CONTAINER pDocInfoContainer
               with Technologies.IDL.IDL{IndirectionLevel = 1};
        out DWORD pJobId with Technologies.IDL.IDL{IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RpcStartDocPrinter" + ", ReturnValue: " +
                Win32ErrorCodesToText(ReturnValue) + ", hPrinter: " + hPrinter.ToString() +
                ", pDocInfoContainer: " + pDocInfoContainer.ToString() +
                ", pJobId: " + pJobId.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 17};
    
    accepts operation RpcStartPagePrinter
    {
        in PRINTER_HANDLE hPrinter;
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RpcStartPagePrinter" + ", hPrinter: " + hPrinter.ToString() +
                ", ReturnValue: " + Win32ErrorCodesToText(ReturnValue);
        }
    }
    with Technologies.IDL.IDL{Opnum = 18};
    
    accepts operation RpcWritePrinter
    {
        in PRINTER_HANDLE hPrinter;
        in array<BYTE> pBuf // No structure
               with Technologies.IDL.IDL{Size_is = [cbBuf], IndirectionLevel = 1};
        in DWORD cbBuf;
        out DWORD pcWritten with Technologies.IDL.IDL{IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RpcWritePrinter" + ", ReturnValue: " +
                Win32ErrorCodesToText(ReturnValue) + ", hPrinter: " + hPrinter.ToString() +
                ", cbBuf: " + cbBuf.ToString() + ", pcWritten: " + pcWritten.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 19};
    
    accepts operation RpcEndPagePrinter
    {
        in PRINTER_HANDLE hPrinter;
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RpcEndPagePrinter" + ", ReturnValue: " + 
                Win32ErrorCodesToText(ReturnValue) + ", hPrinter: " + hPrinter.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 20};
    
    accepts operation RpcAbortPrinter
    {
        in PRINTER_HANDLE hPrinter;
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RpcAbortPrinter" + ", ReturnValue: " + Win32ErrorCodesToText(ReturnValue) + 
                ", hPrinter: " + hPrinter.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 21};
    
    accepts operation RpcReadPrinter
    {
        in PRINTER_HANDLE hPrinter;
        out array<BYTE> pBuf // Binary data
                with Technologies.IDL.IDL{Size_is = [cbBuf], IndirectionLevel = 1};
        in DWORD cbBuf;
        out DWORD pcNoBytesRead with Technologies.IDL.IDL{IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RpcReadPrinter" + ", ReturnValue: " + Win32ErrorCodesToText(ReturnValue) + 
                ", hPrinter: " + hPrinter.ToString() +
                ", pBuf: " + pBuf.ToString() + ", cbBuf: " + cbBuf.ToString() +
                ", pcNoBytesRead: " + pcNoBytesRead.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 22};
    
    accepts operation RpcEndDocPrinter
    {
        in PRINTER_HANDLE hPrinter;
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RpcEndDocPrinter" + ", ReturnValue: " + 
                Win32ErrorCodesToText(ReturnValue) + ", hPrinter: " + hPrinter.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 23};
    
    accepts operation RpcAddJob
    {
        in PRINTER_HANDLE hPrinter;
        in DWORD Level where ValidationCheckValue(value in [1, 2, 3], null, true, ReferenceType.Type, 
                                                  "RPRN", "Level", "RpcAddJob", "1, 2, 3", value);
        in out array<BYTE> pAddJob // Undefined values, binary data
                   with Technologies.IDL.IDL{Size_is = [cbBuf],
                                             PointerType = PointerKind.UniquePtr,
                                             IndirectionLevel = 1};
        in DWORD cbBuf;
        out DWORD pcbNeeded with Technologies.IDL.IDL{IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RpcAddJob" + ", ReturnValue: " +
                Win32ErrorCodesToText(ReturnValue) + ", hPrinter: " + hPrinter.ToString() + ", Level: " +
                Level.ToString() + ", cbBuf: " + cbBuf.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 24};
    
    accepts operation RpcScheduleJob
    {
        in PRINTER_HANDLE hPrinter;
        in DWORD JobId;
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RpcScheduleJob" + ", ReturnValue: " +
                Win32ErrorCodesToText(ReturnValue) + ", hPrinter: " + hPrinter.ToString() +
                ", JobId: " + JobId.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 25};
    
    accepts operation RpcGetPrinterData
    {
        in PRINTER_HANDLE hPrinter;
        in string pValueName
               with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                         String = true,
                                         IndirectionLevel = 1};
        out RegistryTypeValues pType;
        out DynamicallyTypedQuery[pType] pData with Technologies.IDL.IDL{IndirectionLevel = 1};
        in DWORD nSize;
        out DWORD pcbNeeded with Technologies.IDL.IDL{IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RpcGetPrinterData" + ", ReturnValue: " + 
                Win32ErrorCodesToText(ReturnValue) + ", hPrinter: " + hPrinter.ToString() +
                ", pValueName: " + pValueName.ToString() + ", pType: " +
                pType.ToString() + ", pData: " + pData.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 26};
    
    accepts operation RpcSetPrinterData
    {
        in PRINTER_HANDLE hPrinter;
        in string pValueName
               with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                         String = true,
                                         IndirectionLevel = 1};
        in RegistryTypeValues Type;
        in DynamicallyTypedQuery[Type] pData with Technologies.IDL.IDL{IndirectionLevel = 1};
        in DWORD cbData;
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RpcSetPrinterData" + ", ReturnValue: " + Win32ErrorCodesToText(ReturnValue) + 
                ", hPrinter: " + hPrinter.ToString() +
                ", pValueName: " + pValueName.ToString() + ", Type: " +
                Type.ToString() + ", pData: " + pData.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 27};
    
    accepts operation RpcWaitForPrinterChange
    {
        in PRINTER_HANDLE hPrinter;
        in PrinterChangeFlags Flags with Encoding
                                        {
                                            Decoder = PatternDecoder<PrinterChangeFlags>, 
                                            SourcePattern = TypeOf<DWORD>()
                                        };
        out PrinterChangeFlags pFlags with Technologies.IDL.IDL{IndirectionLevel = 1},
                                            Encoding
                                            {
                                                Decoder = PatternDecoder<PrinterChangeFlags>, 
                                                SourcePattern = TypeOf<DWORD>()
                                            };
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RpcWaitForPrinterChange" + ", ReturnValue: " + Win32ErrorCodesToText(ReturnValue) + 
                ", hPrinter: " + hPrinter.ToString() +
                ", Flags: " + Flags.ToString() + ", pFlags: " +
                pFlags.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 28};
    
    accepts operation RpcClosePrinter
    {
        in out PRINTER_HANDLE phPrinter
                   with Technologies.IDL.IDL{IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RpcClosePrinter" + ", ReturnValue: " + Win32ErrorCodesToText(ReturnValue) + 
                ", phPrinter: " + phPrinter.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 29};
    
    accepts operation RpcAddForm
    {
        in PRINTER_HANDLE hPrinter;
        in FORM_CONTAINER pFormInfoContainer
               with Technologies.IDL.IDL{IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RpcAddForm" + ", ReturnValue: " + Win32ErrorCodesToText(ReturnValue) + 
                ", hPrinter: " + hPrinter.ToString() +
                ", pFormInfoContainer: " + pFormInfoContainer.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 30};
    
    accepts operation RpcDeleteForm
    {
        in PRINTER_HANDLE hPrinter;
        in string pFormName
               with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                         String = true,
                                         IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RpcDeleteForm" + ", ReturnValue: " +
                Win32ErrorCodesToText(ReturnValue) + ", hPrinter: " + hPrinter.ToString() +
                ", pFormName: " + pFormName.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 31};
    
    accepts operation RpcGetForm
    {
        in PRINTER_HANDLE hPrinter;
        in string pFormName
               with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                         String = true,
                                         IndirectionLevel = 1};
        in FormInfoLevel Level 
            with Encoding{Decoder = PatternDecoder<FormInfoLevel>, SourcePattern = TypeOf<DWORD>()};
        in out (array<byte> | FormInfoPattern) pForm
                with Technologies.IDL.IDL{Size_is = [cbBuf],
                                            PointerType = PointerKind.UniquePtr,
                                            IndirectionLevel = 1};
        in DWORD cbBuf;
        out DWORD pcbNeeded with Technologies.IDL.IDL{IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RpcGetForm" + ", ReturnValue: " + Win32ErrorCodesToText(ReturnValue) + 
                ", hPrinter: " + hPrinter.ToString() +
                ", pFormName: " + pFormName.ToString() + ", Level: " + Level.ToString() + 
                ", pForm: " + pForm.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 32};
    
    accepts operation RpcSetForm
    {
        in PRINTER_HANDLE hPrinter;
        in string pFormName
               with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                         String = true,
                                         IndirectionLevel = 1};
        in FORM_CONTAINER pFormInfoContainer
               with Technologies.IDL.IDL{IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RpcSetForm" + ", ReturnValue: " + Win32ErrorCodesToText(ReturnValue) + 
                ", hPrinter: " + hPrinter.ToString() +
                ", pFormName: " + pFormName.ToString() +
                ", pFormInfoContainer: " + pFormInfoContainer.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 33};
    
    accepts operation RpcEnumForms
    {
        in PRINTER_HANDLE hPrinter;
        in FormInfoLevel Level 
            with Encoding{Decoder = PatternDecoder<FormInfoLevel>, SourcePattern = TypeOf<DWORD>()};
        in out (array<byte> | FormInfoPattern) pForm
                   with Technologies.IDL.IDL{Size_is = [cbBuf],
                                             PointerType = PointerKind.UniquePtr,
                                             IndirectionLevel = 1};
        in DWORD cbBuf;
        out DWORD pcbNeeded with Technologies.IDL.IDL{IndirectionLevel = 1};
        out DWORD pcReturned
                    with Technologies.IDL.IDL{IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RpcEnumForms" + ", ReturnValue: " + Win32ErrorCodesToText(ReturnValue) + 
                ", hPrinter: " + hPrinter.ToString() + ", Level: " + Level.ToString() + 
                ", pForm: " + pForm.ToString() + ", pcReturned: " +
                pcReturned.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 34};
    
    accepts operation RpcEnumPorts
    {
        in string pName
               with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                         BaseStringType = TypeOf<STRING_HANDLE>(),
                                         String = true};
        in PortInfoLevel Level 
            with Encoding{Decoder = PatternDecoder<PortInfoLevel>, SourcePattern = TypeOf<DWORD>()};
        in out (array<BYTE> | PortInfoPattern) pPort
                   with Technologies.IDL.IDL{Size_is = [cbBuf],
                                             PointerType = PointerKind.UniquePtr,
                                             IndirectionLevel = 1};
        in DWORD cbBuf;
        out DWORD pcbNeeded with Technologies.IDL.IDL{IndirectionLevel = 1};
        out DWORD pcReturned with Technologies.IDL.IDL{IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RpcEnumPorts" + ", ReturnValue: " + Win32ErrorCodesToText(ReturnValue) + 
                ", pName: " + pName.ToString() + ", Level: " +
                Level.ToString() + ", pPort: " + pPort.ToString() + 
                ", pcReturned: " + pcReturned.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 35};
    
    accepts operation RpcEnumMonitors
    {
        in string pName
               with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                         BaseStringType = TypeOf<STRING_HANDLE>(),
                                         String = true};
        in MonitorInfoLevel Level 
            with Encoding{Decoder = PatternDecoder<MonitorInfoLevel>, SourcePattern = TypeOf<DWORD>()};
        in out (array<BYTE> | MonitorInfoPattern) pMonitor
                   with Technologies.IDL.IDL{Size_is = [cbBuf],
                                             PointerType = PointerKind.UniquePtr,
                                             IndirectionLevel = 1};
        in DWORD cbBuf;
        out DWORD pcbNeeded with Technologies.IDL.IDL{IndirectionLevel = 1};
        out DWORD pcReturned with Technologies.IDL.IDL{IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RpcEnumMonitors" + ", ReturnValue: " + Win32ErrorCodesToText(ReturnValue) + 
                ", pName: " + pName.ToString() + ", Level: " +
                Level.ToString() + ", pMonitor: " + pMonitor.ToString() +
                ", pcReturned: " + pcReturned.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 36};
    
    accepts operation Opnum37NotUsedOnWire
    {
    }
    with Technologies.IDL.IDL{Opnum = 37};
    
    accepts operation Opnum38NotUsedOnWire
    {
    }
    with Technologies.IDL.IDL{Opnum = 38};
    
    accepts operation RpcDeletePort
    {
        in string pName
               with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                         BaseStringType = TypeOf<STRING_HANDLE>(),
                                         String = true};
        in ULONG_PTR hWnd;
        in string pPortName
               with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                         String = true,
                                         IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RpcDeletePort" + ", ReturnValue: " + Win32ErrorCodesToText(ReturnValue) + 
                ", pName: " + pName.ToString() + ", hWnd: " +
                hWnd.ToString() + ", pPortName: " + pPortName.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 39};
    
    accepts operation RpcCreatePrinterIC
    {
        in PRINTER_HANDLE hPrinter;
        out GDI_HANDLE pHandle with Technologies.IDL.IDL{IndirectionLevel = 1};
        in DEVMODE_CONTAINER pDevModeContainer
               with Technologies.IDL.IDL{IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RpcCreatePrinterIC" + ", ReturnValue: " +
                Win32ErrorCodesToText(ReturnValue) + ", hPrinter: " + hPrinter.ToString() +
                ", pHandle: " + pHandle.ToString() + ", pDevModeContainer: " +
                pDevModeContainer.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 40};
    
    accepts operation RpcPlayGdiScriptOnPrinterIC
    {
        in GDI_HANDLE hPrinterIC;
        in array<BYTE> pIn with Technologies.IDL.IDL{Size_is = [cIn], IndirectionLevel = 1};
        in DWORD cIn;
        out UniversalFonts pOut with Technologies.IDL.IDL{Size_is = [cOut], IndirectionLevel = 1};
        in DWORD cOut;
        in DWORD ul;
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RpcPlayGdiScriptOnPrinterIC" + ", ReturnValue: " +
                Win32ErrorCodesToText(ReturnValue) + ", hPrinterIC: " +
                hPrinterIC.ToString() + ", pIn: " + pIn.ToString() + ", cIn: " +
                cIn.ToString() + ", pOut: " + pOut.ToString() + ", cOut: " +
                cOut.ToString() + ", ul: " + ul.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 41};
    
    accepts operation RpcDeletePrinterIC
    {
        in out GDI_HANDLE phPrinterIC
                   with Technologies.IDL.IDL{IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RpcDeletePrinterIC" + ", ReturnValue: " +
                Win32ErrorCodesToText(ReturnValue) + ", phPrinterIC: " + phPrinterIC.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 42};
    
    accepts operation Opnum43NotUsedOnWire
    {
    }
    with Technologies.IDL.IDL{Opnum = 43};
    
    accepts operation Opnum44NotUsedOnWire
    {
    }
    with Technologies.IDL.IDL{Opnum = 44};
    
    accepts operation Opnum45NotUsedOnWire
    {
    }
    with Technologies.IDL.IDL{Opnum = 45};
    
    accepts operation RpcAddMonitor
    {
        in string Name
               with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                         BaseStringType = TypeOf<STRING_HANDLE>(),
                                         String = true};
        in MONITOR_CONTAINER pMonitorContainer
               with Technologies.IDL.IDL{IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RpcAddMonitor" +
                ", ReturnValue: " + Win32ErrorCodesToText(ReturnValue) + 
                ", Name: " + Name.ToString() +
                ", pMonitorContainer: " + pMonitorContainer.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 46};
    
    accepts operation RpcDeleteMonitor
    {
        in string Name
               with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                         BaseStringType = TypeOf<STRING_HANDLE>(),
                                         String = true};
        in string pEnvironment
               with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                         BaseStringType = TypeOf<wchar_t>(),
                                         String = true,
                                         IndirectionLevel = 1};
        in string pMonitorName
               with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                         String = true,
                                         IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RpcDeleteMonitor" + ", ReturnValue: " +
                Win32ErrorCodesToText(ReturnValue) + ", Name: " + Name.ToString() +
                ", pEnvironment: " + pEnvironment.ToString() +
                ", pMonitorName: " + pMonitorName.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 47};
    
    accepts operation RpcDeletePrintProcessor
    {
        in string Name
               with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                         BaseStringType = TypeOf<STRING_HANDLE>(),
                                         String = true};
        in string pEnvironment
               with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                         BaseStringType = TypeOf<wchar_t>(),
                                         String = true,
                                         IndirectionLevel = 1};
        in string pPrintProcessorName
               with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                         String = true,
                                         IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RpcDeletePrintProcessor" +
                ", ReturnValue: " + Win32ErrorCodesToText(ReturnValue) + 
                ", Name: " + Name.ToString() +
                ", pEnvironment: " + pEnvironment.ToString() +
                ", pPrintProcessorName: " + pPrintProcessorName.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 48};
    
    accepts operation Opnum49NotUsedOnWire
    {
    }
    with Technologies.IDL.IDL{Opnum = 49};
    
    accepts operation Opnum50NotUsedOnWire
    {
    }
    with Technologies.IDL.IDL{Opnum = 50};
    
    accepts operation RpcEnumPrintProcessorDatatypes
    {
        in string pName
               with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                         BaseStringType = TypeOf<STRING_HANDLE>(),
                                         String = true};
        in string pPrintProcessorName
               with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                         BaseStringType = TypeOf<wchar_t>(),
                                         String = true,
                                         IndirectionLevel = 1};
        in DWORD Level where ValidationCheckValue(value == 1, null, true, ReferenceType.Type, 
                                                  "RPRN", "Level", "RpcGetJob", "1", value);
        in out (array<BYTE> | _DATATYPES_INFO_1) pDatatypes
                    with Technologies.IDL.IDL{Size_is = [cbBuf],
                                             PointerType = PointerKind.UniquePtr,
                                             IndirectionLevel = 1};
        in DWORD cbBuf;
        out DWORD pcbNeeded with Technologies.IDL.IDL{IndirectionLevel = 1};
        out DWORD pcReturned with Technologies.IDL.IDL{IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RpcEnumPrintProcessorDatatypes" + ", ReturnValue: " +
                Win32ErrorCodesToText(ReturnValue) + ", pName: " +
                pName.ToString() + ", pPrintProcessorName: " +
                pPrintProcessorName.ToString() + ", Level: " + Level.ToString() +
                ", pDatatypes: " + pDatatypes.ToString() + 
                ", pcReturned: " + pcReturned.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 51};
    
    accepts operation RpcResetPrinter
    {
        in PRINTER_HANDLE hPrinter;
        in string pDatatype
               with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                         BaseStringType = TypeOf<wchar_t>(),
                                         String = true,
                                         IndirectionLevel = 1};
        in DEVMODE_CONTAINER pDevModeContainer
               with Technologies.IDL.IDL{IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RpcResetPrinter" + ", ReturnValue: " +
                Win32ErrorCodesToText(ReturnValue) + ", hPrinter: " + hPrinter.ToString() +
                ", pDatatype: " + pDatatype.ToString() + ", pDevModeContainer: " +
                pDevModeContainer.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 52};
    
    accepts operation RpcGetPrinterDriver2
    {
        in PRINTER_HANDLE hPrinter;
        in string pEnvironment
               with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                         BaseStringType = TypeOf<wchar_t>(),
                                         String = true,
                                         IndirectionLevel = 1};
        in DriverInfoLevel Level 
            with Encoding{Decoder = PatternDecoder<DriverInfoLevel>, SourcePattern = TypeOf<DWORD>()};
        in out (array<BYTE> | DriverInfoPattern) pDriver
                with Technologies.IDL.IDL{Size_is = [cbBuf],
                                            PointerType = PointerKind.UniquePtr,
                                            IndirectionLevel = 1};
        in DWORD cbBuf;
        out DWORD pcbNeeded with Technologies.IDL.IDL{IndirectionLevel = 1};
        in DWORD dwClientMajorVersion;
        in DWORD dwClientMinorVersion;
        out DWORD pdwServerMaxVersion
                with Technologies.IDL.IDL{IndirectionLevel = 1};
        out DWORD pdwServerMinVersion
                with Technologies.IDL.IDL{IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RpcGetPrinterDriver2" + ", ReturnValue: " +
                Win32ErrorCodesToText(ReturnValue) + ", hPrinter: " + hPrinter.ToString() +
                ", pEnvironment: " + pEnvironment.ToString() + ", Level: " + Level.ToString() + 
                ", pDriver: " + pDriver.ToString() +
                ", dwClientMajorVersion: " +dwClientMajorVersion.ToString() + ", dwClientMinorVersion: " +
                dwClientMinorVersion.ToString() + ", pdwServerMaxVersion: " +
                pdwServerMaxVersion.ToString() + ", pdwServerMinVersion: " +
                pdwServerMinVersion.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 53};
    
    accepts operation Opnum54NotUsedOnWire
    {
    }
    with Technologies.IDL.IDL{Opnum = 54};
    
    accepts operation Opnum55NotUsedOnWire
    {
    }
    with Technologies.IDL.IDL{Opnum = 55};
    
    accepts operation RpcFindClosePrinterChangeNotification
    {
        in PRINTER_HANDLE hPrinter;
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RpcFindClosePrinterChangeNotification" + 
                ", ReturnValue: " + Win32ErrorCodesToText(ReturnValue) + 
                ", hPrinter: " + hPrinter.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 56};
    
    accepts operation Opnum57NotUsedOnWire
    {
    }
    with Technologies.IDL.IDL{Opnum = 57};
    
    accepts operation RpcReplyOpenPrinter
    {
        in string pMachine
               with Technologies.IDL.IDL
                        {BaseStringType = TypeOf<STRING_HANDLE>(), String = true};
        out PRINTER_HANDLE phPrinterNotify
                with Technologies.IDL.IDL{IndirectionLevel = 1};
        in DWORD dwPrinterRemote;
        in DWORD dwType where ValidationCheckValue(value == 1, null, true, ReferenceType.Type,
                                                  "RPRN", "Level", "RpcGetJob", "1", value);
        in DWORD cbBuffer
               with Technologies.IDL.IDL
                        {Range = new RangePattern{Low = 0, High = 512}};
        in array<BYTE> pBuffer // A pointer that SHOULD be set to NULL when sent and MUST be ignored on receipt.
               with Technologies.IDL.IDL{Size_is = [cbBuffer],
                                         PointerType = PointerKind.UniquePtr,
                                         IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RpcReplyOpenPrinter" +
                ", ReturnValue: " + Win32ErrorCodesToText(ReturnValue) + 
                ", pMachine: " + pMachine.ToString() +
                ", phPrinterNotify: " + phPrinterNotify.ToString() +
                ", dwPrinterRemote: " + dwPrinterRemote.ToString() +
                ", dwType: " + dwType.ToString() + ", cbBuffer: " +
                cbBuffer.ToString() + ", pBuffer: " + pBuffer.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 58};
    
    accepts operation RpcRouterReplyPrinter
    {
        in PRINTER_HANDLE hNotify;
        in PrinterChangeFlags fdwFlags with Encoding
                                            {
                                                Decoder = PatternDecoder<PrinterChangeFlags>, 
                                                SourcePattern = TypeOf<DWORD>()
                                            };
        in DWORD cbBuffer
               with Technologies.IDL.IDL
                        {Range = new RangePattern{Low = 0, High = 512}};
        in array<BYTE> pBuffer // A pointer that SHOULD be set to NULL when sent and MUST be ignored on receipt.
               with Technologies.IDL.IDL{Size_is = [cbBuffer],
                                         PointerType = PointerKind.UniquePtr,
                                         IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RpcRouterReplyPrinter" +
                ", ReturnValue: " + Win32ErrorCodesToText(ReturnValue) + 
                ", hNotify: " + hNotify.ToString() +
                ", fdwFlags: " + fdwFlags.ToString() + ", cbBuffer: " +
                cbBuffer.ToString() + ", pBuffer: " + pBuffer.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 59};
    
    accepts operation RpcReplyClosePrinter
    {
        in out PRINTER_HANDLE phNotify
                   with Technologies.IDL.IDL{IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RpcReplyClosePrinter" +
                ", ReturnValue: " + Win32ErrorCodesToText(ReturnValue) + 
                ", phNotify: " + phNotify.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 60};
    
    accepts operation RpcAddPortEx
    {
        in string pName
               with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                         BaseStringType = TypeOf<STRING_HANDLE>(),
                                         String = true};
        in PORT_CONTAINER pPortContainer
               with Technologies.IDL.IDL{IndirectionLevel = 1};
        in PORT_VAR_CONTAINER pPortVarContainer
               with Technologies.IDL.IDL{IndirectionLevel = 1};
        in string pMonitorName
               with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                         String = true,
                                         IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RpcAddPortEx" + ", ReturnValue: " +
                Win32ErrorCodesToText(ReturnValue) + ", pName: " + pName.ToString() +
                ", pPortContainer: " + pPortContainer.ToString() +
                ", pPortVarContainer: " + pPortVarContainer.ToString() +
                ", pMonitorName: " + pMonitorName.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 61};
    
    accepts operation RpcRemoteFindFirstPrinterChangeNotification
    {
        in PRINTER_HANDLE hPrinter;
        in PrinterChangeFlags fdwFlags with Encoding
                                            {
                                                Decoder = PatternDecoder<PrinterChangeFlags>, 
                                                SourcePattern = TypeOf<DWORD>()
                                            };
        in PrinterNotificationValues fdwOptions
            where ValidationCheckEnumValue(InRange<PrinterNotificationValues>(value), null, true, ReferenceType.Type, 
                                           "RPRN", "fdwOptions", "RpcRemoteFindFirstPrinterChangeNotification", 
                                           "0x00000000, 0x00010000, 0x00020000", value);
        in string pszLocalMachine
               with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                         BaseStringType = TypeOf<wchar_t>(),
                                         String = true,
                                         IndirectionLevel = 1};
        in DWORD dwPrinterLocal;
        in DWORD cbBuffer
               with Technologies.IDL.IDL
                        {Range = new RangePattern{Low = 0, High = 512}};
        in out array<BYTE> pBuffer // A pointer that MUST be set to NULL when sent and MUST be ignored on receipt. 
                   where ValidationCheckValue(value == null, null, true, ReferenceType.Type, 
                                              "RPRN", "pBuffer", "RpcRemoteFindFirstPrinterChangeNotification", "null", value)
                   with Technologies.IDL.IDL{Size_is = [cbBuffer],
                                             PointerType = PointerKind.UniquePtr,
                                             IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RpcRemoteFindFirstPrinterChangeNotification" + ", ReturnValue: " +
                Win32ErrorCodesToText(ReturnValue) + ", hPrinter: " +
                hPrinter.ToString() + ", fdwFlags: " + fdwFlags.ToString() +
                ", fdwOptions: " + fdwOptions.ToString() + ", pszLocalMachine: " +
                pszLocalMachine.ToString() + ", dwPrinterLocal: " +
                dwPrinterLocal.ToString() + ", cbBuffer: " + cbBuffer.ToString() +
                ", pBuffer: " + pBuffer.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 62};
    
    accepts operation Opnum63NotUsedOnWire
    {
    }
    with Technologies.IDL.IDL{Opnum = 63};
    
    accepts operation Opnum64NotUsedOnWire
    {
    }
    with Technologies.IDL.IDL{Opnum = 64};
    
    accepts operation RpcRemoteFindFirstPrinterChangeNotificationEx
    {
        in PRINTER_HANDLE hPrinter;
        in PrinterChangeFlags fdwFlags with Encoding
                                            {
                                                Decoder = PatternDecoder<PrinterChangeFlags>, 
                                                SourcePattern = TypeOf<DWORD>()
                                            };
        in PrinterNotificationValues fdwOptions
            where ValidationCheckEnumValue(InRange<PrinterNotificationValues>(value), null, true, ReferenceType.Type, 
                                           "RPRN", "fdwOptions", "RpcRemoteFindFirstPrinterChangeNotificationEx", 
                                           "0x00000000, 0x00010000, 0x00020000", value);
        in string pszLocalMachine
               with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                         BaseStringType = TypeOf<wchar_t>(),
                                         String = true,
                                         IndirectionLevel = 1};
        in DWORD dwPrinterLocal;
        in RPC_V2_NOTIFY_OPTIONS pOptions
               with Technologies.IDL.IDL
                        {PointerType = PointerKind.UniquePtr, IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RpcRemoteFindFirstPrinterChangeNotificationEx" +
                ", ReturnValue: " + Win32ErrorCodesToText(ReturnValue) + ", hPrinter: " +
                hPrinter.ToString() + ", fdwFlags: " + fdwFlags.ToString() +
                ", fdwOptions: " + fdwOptions.ToString() + ", pszLocalMachine: " +
                pszLocalMachine.ToString() + ", dwPrinterLocal: " +
                dwPrinterLocal.ToString() + ", pOptions: " + pOptions.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 65};
    
    accepts operation RpcRouterReplyPrinterEx
    {
        in PRINTER_HANDLE hNotify;
        in DWORD dwColor;
        in PrinterChangeFlags fdwFlags with Encoding
                                            {
                                                Decoder = PatternDecoder<PrinterChangeFlags>, 
                                                SourcePattern = TypeOf<DWORD>()
                                            };
        out ChangeNotificationFlags pdwResult with Technologies.IDL.IDL{IndirectionLevel = 1};
        in DWORD dwReplyType where ValidationCheckValue(value == 0, null, true, ReferenceType.Type, 
                                                        "RPRN", "Level", "RpcGetJob", "0", value);
        in RPC_V2_UREPLY_PRINTER[dwReplyType] Reply
               with Technologies.IDL.IDL{Switch_Is = dwReplyType};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RpcRouterReplyPrinterEx" + ", ReturnValue: " + Win32ErrorCodesToText(ReturnValue) + 
                ", hNotify: " + hNotify.ToString() + ", dwColor: " + dwColor.ToString() + ", fdwFlags: " +
                fdwFlags.ToString() + ", pdwResult: " + pdwResult.ToString() +
                ", dwReplyType: " + dwReplyType.ToString() + ", Reply: " +
                Reply.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 66};
    
    accepts operation RpcRouterRefreshPrinterChangeNotification
    {
        in PRINTER_HANDLE hPrinter;
        in DWORD dwColor;
        in RPC_V2_NOTIFY_OPTIONS pOptions
               with Technologies.IDL.IDL
                        {PointerType = PointerKind.UniquePtr, IndirectionLevel = 1};
        out RPC_V2_NOTIFY_INFO ppInfo
                with Technologies.IDL.IDL{IndirectionLevel = 2};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RpcRouterRefreshPrinterChangeNotification" + ", ReturnValue: " + 
                Win32ErrorCodesToText(ReturnValue) + ", hPrinter: " +
                hPrinter.ToString() + ", dwColor: " + dwColor.ToString() +
                ", pOptions: " + pOptions.ToString() + ", ppInfo: " +
                ppInfo.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 67};
    
    accepts operation Opnum68NotUsedOnWire
    {
    }
    with Technologies.IDL.IDL{Opnum = 68};
    
    accepts operation RpcOpenPrinterEx
    {
        in string pPrinterName
               with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                         BaseStringType = TypeOf<STRING_HANDLE>(),
                                         String = true};
        out PRINTER_HANDLE pHandle
                with Technologies.IDL.IDL{IndirectionLevel = 1};
        in string pDatatype
               with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                         BaseStringType = TypeOf<wchar_t>(),
                                         String = true,
                                         IndirectionLevel = 1};
        in DEVMODE_CONTAINER pDevModeContainer
               with Technologies.IDL.IDL{IndirectionLevel = 1};
        in AccessValuesFlags AccessRequired
            with Encoding{Decoder = PatternDecoder<AccessMaskFlags>, SourcePattern = TypeOf<DWORD>()};
        in SPLCLIENT_CONTAINER pClientInfo
               with Technologies.IDL.IDL{IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RpcOpenPrinterEx" + ", ReturnValue: " +
                Win32ErrorCodesToText(ReturnValue) + ", pPrinterName: " +
                pPrinterName.ToString() + ", pHandle: " + pHandle.ToString() +
                ", pDatatype: " + pDatatype.ToString() + ", pDevModeContainer: " +
                pDevModeContainer.ToString() + ", AccessRequired: " +
                AccessRequired.ToString() + ", pClientInfo: " +
                pClientInfo.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 69};
    
    accepts operation RpcAddPrinterEx
    {
        in string pName
               with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                         BaseStringType = TypeOf<STRING_HANDLE>(),
                                         String = true};
        in PRINTER_CONTAINER pPrinterContainer
               with Technologies.IDL.IDL{IndirectionLevel = 1};
        in DEVMODE_CONTAINER pDevModeContainer
               with Technologies.IDL.IDL{IndirectionLevel = 1};
        in SECURITY_CONTAINER pSecurityContainer
               with Technologies.IDL.IDL{IndirectionLevel = 1};
        in SPLCLIENT_CONTAINER pClientInfo
               with Technologies.IDL.IDL{IndirectionLevel = 1};
        out PRINTER_HANDLE pHandle
                with Technologies.IDL.IDL{IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RpcAddPrinterEx" + ", ReturnValue: " + Win32ErrorCodesToText(ReturnValue) + 
                ", pName: " + pName.ToString() +
                ", pPrinterContainer: " + pPrinterContainer.ToString() +
                ", pDevModeContainer: " + pDevModeContainer.ToString() +
                ", pSecurityContainer: " + pSecurityContainer.ToString() +
                ", pClientInfo: " + pClientInfo.ToString() + ", pHandle: " +
                pHandle.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 70};
    
    accepts operation RpcSetPort
    {
        in string pName
               with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                         BaseStringType = TypeOf<STRING_HANDLE>(),
                                         String = true};
        in string pPortName
               with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                         BaseStringType = TypeOf<wchar_t>(),
                                         String = true,
                                         IndirectionLevel = 1};
        in PORT_CONTAINER pPortContainer
               with Technologies.IDL.IDL{IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RpcSetPort" + ", ReturnValue: " +
                Win32ErrorCodesToText(ReturnValue) + ", pName: " + pName.ToString() + ", pPortName: " +
                pPortName.ToString() + ", pPortContainer: " +
                pPortContainer.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 71};
    
    accepts operation RpcEnumPrinterData
    {
        in PRINTER_HANDLE hPrinter;
        in DWORD dwIndex;
        out array<UnicodeString> pValueName
               with Encoding{
                                Decoder = UnicodeStringArrayDecoder, 
                                SourceConverter = ConvertArrayWCHAR2Stream,
                                SourcePattern = TypeOf<array<wchar_t>>()
                            }
                with Technologies.IDL.IDL{Size_is = [cbValueName / (SizeOf<wchar_t>())], IndirectionLevel = 1};
        in DWORD cbValueName;
        out DWORD pcbValueName with Technologies.IDL.IDL{IndirectionLevel = 1};
        out RegistryTypeValues pType;
        out DynamicallyTypedQuery[pType] pData with Technologies.IDL.IDL{IndirectionLevel = 1};
        in DWORD cbData;
        out DWORD pcbData with Technologies.IDL.IDL{IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RpcEnumPrinterData" + ", ReturnValue: " + Win32ErrorCodesToText(ReturnValue) + 
                ", hPrinter: " + hPrinter.ToString() +
                ", dwIndex: " + dwIndex.ToString() + ", pValueName: " +
                (pValueName == nothing ? "" : pValueName.ToString()) + ", cbValueName: " +
                cbValueName.ToString() + ", pcbValueName: " +
                pcbValueName.ToString() + ", pType: " + pType.ToString() +
                ", pData: " + pData.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 72};
    
    accepts operation RpcDeletePrinterData
    {
        in PRINTER_HANDLE hPrinter;
        in string pValueName
               with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                         String = true,
                                         IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RpcDeletePrinterData" + ", ReturnValue: " +
                Win32ErrorCodesToText(ReturnValue) + ", hPrinter: " + hPrinter.ToString() +
                ", pValueName: " + pValueName.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 73};
    
    accepts operation Opnum74NotUsedOnWire
    {
    }
    with Technologies.IDL.IDL{Opnum = 74};
    
    accepts operation Opnum75NotUsedOnWire
    {
    }
    with Technologies.IDL.IDL{Opnum = 75};
    
    accepts operation Opnum76NotUsedOnWire
    {
    }
    with Technologies.IDL.IDL{Opnum = 76};
    
    accepts operation RpcSetPrinterDataEx
    {
        in PRINTER_HANDLE hPrinter;
        in string pKeyName
               with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                         String = true,
                                         IndirectionLevel = 1};
        in string pValueName
               with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                         String = true,
                                         IndirectionLevel = 1};
        in RegistryTypeValues Type;
        in DynamicallyTypedQuery[Type] pData with Technologies.IDL.IDL{IndirectionLevel = 1};
        in DWORD cbData;
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RpcSetPrinterDataEx" + ", ReturnValue: " + Win32ErrorCodesToText(ReturnValue) + 
                ", hPrinter: " + hPrinter.ToString() +
                ", pKeyName: " + pKeyName.ToString() + ", pValueName: " +
                pValueName.ToString() + ", Type: " + Type.ToString() +
                ", pData: " + pData.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 77};
    
    accepts operation RpcGetPrinterDataEx
    {
        in PRINTER_HANDLE hPrinter;
        in string pKeyName
               with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                         String = true,
                                         IndirectionLevel = 1};
        in string pValueName
               with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                         String = true,
                                         IndirectionLevel = 1};
        out RegistryTypeValues pType;
        out DynamicallyTypedQuery[pType] pData with Technologies.IDL.IDL{IndirectionLevel = 1};
        in DWORD nSize;
        out DWORD pcbNeeded with Technologies.IDL.IDL{IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RpcGetPrinterDataEx" + ", ReturnValue: " + Win32ErrorCodesToText(ReturnValue) + 
                ", hPrinter: " + hPrinter.ToString() +
                ", pKeyName: " + pKeyName.ToString() + ", pValueName: " +
                pValueName.ToString() + ", pType: " + pType.ToString() +
                ", pData: " + pData.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 78};
    
    accepts operation RpcEnumPrinterDataEx
    {
        in PRINTER_HANDLE hPrinter;
        in string pKeyName
               with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                         String = true,
                                         IndirectionLevel = 1};
        out (array<BYTE> | PRINTER_ENUM_VALUES) pEnumValues
                with Technologies.IDL.IDL
                         {Size_is = [cbEnumValues], IndirectionLevel = 1};
        in DWORD cbEnumValues;
        out DWORD pcbEnumValues with Technologies.IDL.IDL{IndirectionLevel = 1};
        out DWORD pnEnumValues with Technologies.IDL.IDL{IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RpcEnumPrinterDataEx" + ", ReturnValue: " + Win32ErrorCodesToText(ReturnValue) + 
                ", hPrinter: " + hPrinter.ToString() +
                ", pKeyName: " + pKeyName.ToString() + ", pEnumValues: " +
                pEnumValues.ToString() + pnEnumValues.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 79};
    
    accepts operation RpcEnumPrinterKey
    {
        in PRINTER_HANDLE hPrinter;
        in string pKeyName
               with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                         String = true,
                                         IndirectionLevel = 1};
        out (array<wchar_t> | array<string>) pSubkey
                with Technologies.IDL.IDL{Size_is = [cbSubkey / (SizeOf<wchar_t>())],
                                          IndirectionLevel = 1};
        in DWORD cbSubkey;
        out DWORD pcbSubkey with Technologies.IDL.IDL{IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RpcEnumPrinterKey" + ", ReturnValue: " + Win32ErrorCodesToText(ReturnValue) + 
                ", hPrinter: " + hPrinter.ToString() +
                ", pKeyName: " + pKeyName.ToString() + ", pSubkey: " + (pSubkey as string);
        }
    }
    with Technologies.IDL.IDL{Opnum = 80};
    
    accepts operation RpcDeletePrinterDataEx
    {
        in PRINTER_HANDLE hPrinter;
        in string pKeyName
               with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                         String = true,
                                         IndirectionLevel = 1};
        in string pValueName
               with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                         String = true,
                                         IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RpcDeletePrinterDataEx" + ", ReturnValue: " +
                Win32ErrorCodesToText(ReturnValue) + ", hPrinter: " + hPrinter.ToString() +
                ", pKeyName: " + pKeyName.ToString() + ", pValueName: " + pValueName.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 81};
    
    accepts operation RpcDeletePrinterKey
    {
        in PRINTER_HANDLE hPrinter;
        in string pKeyName
               with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                         String = true,
                                         IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RpcDeletePrinterKey" + ", ReturnValue: " +
                Win32ErrorCodesToText(ReturnValue) + ", hPrinter: " + hPrinter.ToString() +
                ", pKeyName: " + pKeyName.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 82};
    
    accepts operation Opnum83NotUsedOnWire
    {
    }
    with Technologies.IDL.IDL{Opnum = 83};
    
    accepts operation RpcDeletePrinterDriverEx
    {
        in string pName
               with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                         BaseStringType = TypeOf<STRING_HANDLE>(),
                                         String = true};
        in string pEnvironment
               with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                         String = true,
                                         IndirectionLevel = 1};
        in string pDriverName
               with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                         String = true,
                                         IndirectionLevel = 1};
        in DeletePrinterDriverFlags dwDeleteFlag
            with Encoding{Decoder = PatternDecoder<DeletePrinterDriverFlags>, SourcePattern = TypeOf<DWORD>()};
        in DWORD dwVersionNum;
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RpcDeletePrinterDriverEx" + ", ReturnValue: " +
                Win32ErrorCodesToText(ReturnValue) + ", pName: " + pName.ToString() +
                ", pEnvironment: " + pEnvironment.ToString() + ", pDriverName: " +
                pDriverName.ToString() + ", dwDeleteFlag: " +
                dwDeleteFlag.ToString() + ", dwVersionNum: " +
                dwVersionNum.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 84};
    
    accepts operation RpcAddPerMachineConnection
    {
        in string pServer
               with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                         BaseStringType = TypeOf<STRING_HANDLE>(),
                                         String = true};
        in string pPrinterName
               with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                         String = true,
                                         IndirectionLevel = 1};
        in string pPrintServer
               with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                         String = true,
                                         IndirectionLevel = 1};
        in string pProvider
               with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                         String = true,
                                         IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RpcAddPerMachineConnection" + ", ReturnValue: " + Win32ErrorCodesToText(ReturnValue) + 
                ", pServer: " + pServer.ToString() + ", pPrinterName: " +
                pPrinterName.ToString() + ", pPrintServer: " +
                pPrintServer.ToString() + ", pProvider: " + pProvider.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 85};
    
    accepts operation RpcDeletePerMachineConnection
    {
        in string pServer
               with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                         BaseStringType = TypeOf<STRING_HANDLE>(),
                                         String = true};
        in string pPrinterName
               with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                         String = true,
                                         IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RpcDeletePerMachineConnection" + ", ReturnValue: " +
                Win32ErrorCodesToText(ReturnValue) + ", pServer: " +
                pServer.ToString() + ", pPrinterName: " +
                pPrinterName.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 86};
    
    accepts operation RpcEnumPerMachineConnections
    {
        in string pServer
               with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                         BaseStringType = TypeOf<STRING_HANDLE>(),
                                         String = true};
        in out (array<BYTE> | PrinterInfoPattern) pPrinterEnum
                   with Technologies.IDL.IDL{Size_is = [cbBuf],
                                             PointerType = PointerKind.UniquePtr,
                                             IndirectionLevel = 1};
        in DWORD cbBuf;
        out DWORD pcbNeeded with Technologies.IDL.IDL{IndirectionLevel = 1};
        out DWORD pcReturned with Technologies.IDL.IDL{IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RpcEnumPerMachineConnections" + ", ReturnValue: " + Win32ErrorCodesToText(ReturnValue) + 
                ", pServer: " + pServer.ToString() + ", pPrinterEnum: " + pPrinterEnum.ToString() + 
                ", pcReturned: " + pcReturned.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 87};
    
    accepts operation RpcXcvData
    {
        in PRINTER_HANDLE hXcv;
        in string pszDataName
               with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                         String = true,
                                         IndirectionLevel = 1};
        in array<BYTE> pInputData
               with Technologies.IDL.IDL
                        {Size_is = [cbInputData], IndirectionLevel = 1};
        in DWORD cbInputData;
        out array<BYTE> pOutputData // No embeded structure
                with Technologies.IDL.IDL
                         {Size_is = [cbOutputData], IndirectionLevel = 1};
        in DWORD cbOutputData;
        out DWORD pcbOutputNeeded
                with Technologies.IDL.IDL{IndirectionLevel = 1};
        in out DWORD pdwStatus with Technologies.IDL.IDL{IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RpcXcvData" + ", ReturnValue: " + Win32ErrorCodesToText(ReturnValue) + 
                ", hXcv: " + hXcv.ToString() + ", pszDataName: " +
                pszDataName.ToString() + ", pInputData: " +
                cbInputData.ToString() + ", pOutputData: " + ", pdwStatus: " +
                pdwStatus.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 88};
    
    accepts operation RpcAddPrinterDriverEx
    {
        in string pName
               with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                         BaseStringType = TypeOf<STRING_HANDLE>(),
                                         String = true};
        in DRIVER_CONTAINER pDriverContainer
               with Technologies.IDL.IDL{IndirectionLevel = 1};
        in FileCopyFlags dwFileCopyFlags;
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RpcAddPrinterDriverEx" + ", ReturnValue: " + Win32ErrorCodesToText(ReturnValue) + 
                ", pName: " + pName.ToString() +
                ", pDriverContainer: " + pDriverContainer.ToString() +
                ", dwFileCopyFlags: " + dwFileCopyFlags.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 89};
    
    accepts operation Opnum90NotUsedOnWire
    {
    }
    with Technologies.IDL.IDL{Opnum = 90};
    
    accepts operation Opnum91NotUsedOnWire
    {
    }
    with Technologies.IDL.IDL{Opnum = 91};
    
    accepts operation Opnum92NotUsedOnWire
    {
    }
    with Technologies.IDL.IDL{Opnum = 92};
    
    accepts operation Opnum93NotUsedOnWire
    {
    }
    with Technologies.IDL.IDL{Opnum = 93};
    
    accepts operation Opnum94NotUsedOnWire
    {
    }
    with Technologies.IDL.IDL{Opnum = 94};
    
    accepts operation Opnum95NotUsedOnWire
    {
    }
    with Technologies.IDL.IDL{Opnum = 95};
    
    accepts operation RpcFlushPrinter
    {
        in PRINTER_HANDLE hPrinter;
        in array<BYTE> pBuf
               with Technologies.IDL.IDL{Size_is = [cbBuf], IndirectionLevel = 1};
        in DWORD cbBuf;
        out DWORD pcWritten with Technologies.IDL.IDL{IndirectionLevel = 1};
        in DWORD cSleep;
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RpcFlushPrinter" + ", ReturnValue: " + Win32ErrorCodesToText(ReturnValue) + 
                ", hPrinter: " + hPrinter.ToString() +
                ", pBuf: " + pBuf.ToString() + ", pcWritten: " + pcWritten.ToString() + ", cSleep: " +
                cSleep.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 96};
    
    accepts operation RpcSendRecvBidiData
    {
        in PRINTER_HANDLE hPrinter;
        in string pAction
               with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                         BaseStringType = TypeOf<wchar_t>(),
                                         String = true,
                                         IndirectionLevel = 1};
        in RPC_BIDI_REQUEST_CONTAINER pReqData
               with Technologies.IDL.IDL{IndirectionLevel = 1};
        out RPC_BIDI_RESPONSE_CONTAINER ppRespData
                with Technologies.IDL.IDL{IndirectionLevel = 2};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RpcSendRecvBidiData" + ", ReturnValue: " + Win32ErrorCodesToText(ReturnValue) + 
                ", hPrinter: " + hPrinter.ToString() +
                ", pAction: " + pAction.ToString() + ", pReqData: " +
                pReqData.ToString() + ", ppRespData: " + ppRespData.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 97};
    
    accepts operation Opnum98NotUsedOnWire
    {
    }
    with Technologies.IDL.IDL{Opnum = 98};
    
    accepts operation Opnum99NotUsedOnWire
    {
    }
    with Technologies.IDL.IDL{Opnum = 99};
    
    accepts operation Opnum100NotUsedOnWire
    {
    }
    with Technologies.IDL.IDL{Opnum = 100};
    
    accepts operation Opnum101NotUsedOnWire
    {
    }
    with Technologies.IDL.IDL{Opnum = 101};
    
    accepts operation RpcGetCorePrinterDrivers
    {
        in string pszServer
               with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                         BaseStringType = TypeOf<STRING_HANDLE>(),
                                         String = true};
        in string pszEnvironment
               with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                         String = true,
                                         IndirectionLevel = 1};
        in DWORD cchCoreDrivers;
        in UnicodeString pszzCoreDriverDependencies 
               with Encoding{
                                Decoder = BinaryDecoder<UnicodeString>, 
                                SourceConverter = ConvertArrayWCHAR2Stream,
                                SourcePattern = TypeOf<array<wchar_t>>()
                            }
               with Technologies.IDL.IDL
                        {Size_is = [cchCoreDrivers], IndirectionLevel = 1};
        in DWORD cCorePrinterDrivers;
        out array<CORE_PRINTER_DRIVER> pCorePrinterDrivers
                with Technologies.IDL.IDL
                         {Size_is = [cCorePrinterDrivers], IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RpcGetCorePrinterDrivers" +
                ", ReturnValue: " + Win32ErrorCodesToText(ReturnValue) + ", pszServer: " +
                pszServer.ToString() + ", pszEnvironment: " + pszEnvironment.ToString() + ", pszzCoreDriverDependencies" + 
                (pszzCoreDriverDependencies == nothing ? "" : pszzCoreDriverDependencies.ToString()) + 
                ", cCorePrinterDrivers: " + cCorePrinterDrivers.ToString() +
                ", pCorePrinterDrivers: " + pCorePrinterDrivers.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 102};
    
    accepts operation Opnum103NotUsedOnWire
    {
    }
    with Technologies.IDL.IDL{Opnum = 103};
    
    accepts operation RpcGetPrinterDriverPackagePath
    {
        in string pszServer
               with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                         BaseStringType = TypeOf<STRING_HANDLE>(),
                                         String = true};
        in string pszEnvironment
               with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                         String = true,
                                         IndirectionLevel = 1};
        in string pszLanguage
               with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                         BaseStringType = TypeOf<wchar_t>(),
                                         String = true,
                                         IndirectionLevel = 1};
        in string pszPackageID
               with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                         String = true,
                                         IndirectionLevel = 1};
        in out UnicodeString pszDriverPackageCab
                   with Encoding{
                                    Decoder = BinaryDecoder<UnicodeString>, 
                                    SourceConverter = ConvertArrayWCHAR2Stream,
                                    SourcePattern = TypeOf<array<wchar_t>>()
                                }
                   with Technologies.IDL.IDL{Size_is = [cchDriverPackageCab],
                                             PointerType = PointerKind.UniquePtr,
                                             IndirectionLevel = 1};
        in DWORD cchDriverPackageCab;
        out IDLUlong pcchRequiredSize
                with Technologies.IDL.IDL{IndirectionLevel = 1};
        result ERREF.HRESULT ReturnValue;
        
        override string ToString()
        {
            return "RpcGetPrinterDriverPackagePath" + ", ReturnValue: " + ReturnValue.ToString() +
                ", pszServer: " + pszServer.ToString() + ", pszEnvironment: " +
                pszEnvironment.ToString() + ", pszLanguage: " +
                pszLanguage.ToString() + ", pszPackageID: " +
                pszPackageID.ToString() + ", pszDriverPackageCab: " +
                (pszDriverPackageCab == nothing ? pszDriverPackageCab.ToString() : "");
        }
    }
    with Technologies.IDL.IDL{Opnum = 104};
    
    accepts operation Opnum105NotUsedOnWire
    {
    }
    with Technologies.IDL.IDL{Opnum = 105};
    
    accepts operation Opnum106NotUsedOnWire
    {
    }
    with Technologies.IDL.IDL{Opnum = 106};
    
    accepts operation Opnum107NotUsedOnWire
    {
    }
    with Technologies.IDL.IDL{Opnum = 107};
    
    accepts operation Opnum108NotUsedOnWire
    {
    }
    with Technologies.IDL.IDL{Opnum = 108};
    
    accepts operation Opnum109NotUsedOnWire
    {
    }
    with Technologies.IDL.IDL{Opnum = 109};
    
    accepts operation RpcGetJobNamedPropertyValue
    {
        in PRINTER_HANDLE hPrinter;
        in DWORD JobId where ValidationCheckValue(value != 0, null, true, ReferenceType.Type, 
                                                  "RPRN", "JobId", "RpcGetJobNamedPropertyValue", "not 0", value);
        in string pszName
               with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                         String = true,
                                         IndirectionLevel = 1};
        out RPC_PrintPropertyValue pValue
                with Technologies.IDL.IDL{IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RpcGetJobNamedPropertyValue" + ", ReturnValue: " + Win32ErrorCodesToText(ReturnValue) + 
                ", hPrinter: " + hPrinter.ToString() + ", JobId: " + JobId.ToString() +
                ", pszName: " + pszName.ToString() + ", pValue: " + pValue.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 110};
    
    accepts operation RpcSetJobNamedProperty
    {
        in PRINTER_HANDLE hPrinter;
        in DWORD JobId where ValidationCheckValue(value != 0, null, true, ReferenceType.Type, 
                                                  "RPRN", "JobId", "RpcSetJobNamedProperty", "not 0", value);
        in RPC_PrintNamedProperty pProperty
               with Technologies.IDL.IDL{IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RpcSetJobNamedProperty" + ", ReturnValue: " +
                Win32ErrorCodesToText(ReturnValue) + ", hPrinter: " + hPrinter.ToString() +
                ", JobId: " + JobId.ToString() + ", pProperty: " + pProperty.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 111};
    
    accepts operation RpcDeleteJobNamedProperty
    {
        in PRINTER_HANDLE hPrinter;
        in DWORD JobId where ValidationCheckValue(value != 0, null, true, ReferenceType.Type, 
                                                  "RPRN", "JobId", "RpcDeleteJobNamedProperty", "not 0", value);
        in string pszName
               with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                         String = true,
                                         IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RpcDeleteJobNamedProperty" + ", ReturnValue: " +
                Win32ErrorCodesToText(ReturnValue) + ", hPrinter: " +
                hPrinter.ToString() + ", JobId: " + JobId.ToString() +
                ", pszName: " + pszName.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 112};
    
    accepts operation RpcEnumJobNamedProperties
    {
        in PRINTER_HANDLE hPrinter;
        in DWORD JobId where ValidationCheckValue(value != 0, null, true, ReferenceType.Type, 
                                                  "RPRN", "JobId", "RpcEnumJobNamedProperties", "not 0", value);
        out DWORD pcProperties with Technologies.IDL.IDL{IndirectionLevel = 1};
        out array<RPC_PrintNamedProperty> ppProperties
                with Technologies.IDL.IDL
                         {Size_is = [null, pcProperties], IndirectionLevel = 2};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RpcEnumJobNamedProperties" + ", ReturnValue: " +
                Win32ErrorCodesToText(ReturnValue) + ", hPrinter: " +
                hPrinter.ToString() + ", JobId: " + JobId.ToString() +
                ", pcProperties: " + pcProperties.ToString() +
                ", ppProperties: " + ppProperties.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 113};
    
    accepts operation Opnum114NotUsedOnWire
    {
    }
    with Technologies.IDL.IDL{Opnum = 114};
    
    accepts operation Opnum115NotUsedOnWire
    {
    }
    with Technologies.IDL.IDL{Opnum = 115};
    
    accepts operation RpcLogJobInfoForBranchOffice
    {
        in PRINTER_HANDLE hPrinter;
        in RPC_BranchOfficeJobDataContainer pBranchOfficeJobDataContainer
               with Technologies.IDL.IDL
                        {PointerType = PointerKind.RefPtr, IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "RpcLogJobInfoForBranchOffice" + ", ReturnValue: " +
                Win32ErrorCodesToText(ReturnValue) + ", hPrinter: " +
                hPrinter.ToString() + ", pBranchOfficeJobDataContainer: " +
                pBranchOfficeJobDataContainer.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 116};
}

typedef STRING_HANDLE = wchar_t
    with Technologies.IDL.IDL{Handle = true, IndirectionLevel = 1};

typedef PRINTER_HANDLE = ContextHandle;

type DEVMODE_CONTAINER
{
    DWORD cbBuf;
    optional DEVMODE pDevMode
        with Technologies.IDL.IDL{Size_is = [cbBuf],
                                 PointerType = PointerKind.UniquePtr,
                                 IndirectionLevel = 1},
            Encoding{Decoder = DevmodeDecoder, SourcePattern = TypeOf<array<BYTE>>()};
    optional DEVMODE DevmodeDecoder(array<BYTE> arrayByte)
    {
        if (arrayByte == null || arrayByte == nothing)
            return nothing;
        binary binData = arrayByte as binary;
        var result = BinaryDecoder<DEVMODE>(binData as stream);
        if (result == nothing)
            ValidationCheck(false, null, DiagnosisLevel.Error,
                            Format(RPRN_GENERAL_DECODING_FAILURE, "DEVMODE", "DEVMODE_CONTAINER"));
        return result;
    }
}

type JOB_CONTAINER
{
    DWORD Level;
    __MIDL_winspool_0008[Level] JobInfo
        with Technologies.IDL.IDL{Switch_Is = Level, EmbedType = true};
}

type __MIDL_winspool_0008[DWORD Tag]
{
    optional [|Tag in {1}|] JOB_INFO_1 Level1
        with Technologies.IDL.IDL{Case = [1], IndirectionLevel = 1};
    optional [|Tag in {2}|] JOB_INFO_2 Level2
        with Technologies.IDL.IDL{Case = [2], IndirectionLevel = 1};
    optional [|Tag in {3}|] JOB_INFO_3 Level3
        with Technologies.IDL.IDL{Case = [3], IndirectionLevel = 1};
    optional [|Tag in {4}|] JOB_INFO_4 Level4
        with Technologies.IDL.IDL{Case = [4], IndirectionLevel = 1};
}
with Technologies.IDL.IDL
         {Switch_Type = TypeOf<DWORD>(), UnionKind = UnionKind.NonEncapsulated};

type JOB_INFO_1
{
    DWORD JobId;
    string pPrinterName
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    string pMachineName
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    string pUserName
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    string pDocument
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    string pDatatype
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    string pStatus
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    DWORD Status;
    DWORD Priority;
    DWORD Position;
    DWORD TotalPages;
    DWORD PagesPrinted;
    SYSTEMTIME Submitted;
}

type JOB_INFO_2
{
    DWORD JobId;
    string pPrinterName
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    string pMachineName
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    string pUserName
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    string pDocument
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    string pNotifyName
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    string pDatatype
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    string pPrintProcessor
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    string pParameters
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    string pDriverName
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    ULONG_PTR pDevMode;
    string pStatus
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    ULONG_PTR pSecurityDescriptor;
    DWORD Status;
    DWORD Priority;
    DWORD Position;
    DWORD StartTime;
    DWORD UntilTime;
    DWORD TotalPages;
    DWORD Size;
    SYSTEMTIME Submitted;
    DWORD Time;
    DWORD PagesPrinted;
}

type JOB_INFO_3
{
    DWORD JobId;
    DWORD NextJobId;
    DWORD Reserved;
}

type JOB_INFO_4
{
    DWORD JobId;
    string pPrinterName
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    string pMachineName
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    string pUserName
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    string pDocument
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    string pNotifyName
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    string pDatatype
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    string pPrintProcessor
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    string pParameters
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    string pDriverName
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    ULONG_PTR pDevMode;
    string pStatus
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    ULONG_PTR pSecurityDescriptor;
    DWORD Status;
    DWORD Priority;
    DWORD Position;
    DWORD StartTime;
    DWORD UntilTime;
    DWORD TotalPages;
    DWORD Size;
    SYSTEMTIME Submitted;
    DWORD Time;
    DWORD PagesPrinted;
    IDLLong SizeHigh;
}

type PRINTER_CONTAINER
{
    DWORD Level;
    __MIDL_winspool_0011[Level] PrinterInfo
        with Technologies.IDL.IDL{Switch_Is = Level, EmbedType = true};
}

type __MIDL_winspool_0011[DWORD Tag]
{
    optional [|Tag in {0}|] PRINTER_INFO_STRESS pPrinterInfoStress
        with Technologies.IDL.IDL{Case = [0], IndirectionLevel = 1};
    optional [|Tag in {1}|] PRINTER_INFO_1 pPrinterInfo1
        with Technologies.IDL.IDL{Case = [1], IndirectionLevel = 1};
    optional [|Tag in {2}|] PRINTER_INFO_2 pPrinterInfo2
        with Technologies.IDL.IDL{Case = [2], IndirectionLevel = 1};
    optional [|Tag in {3}|] PRINTER_INFO_3 pPrinterInfo3
        with Technologies.IDL.IDL{Case = [3], IndirectionLevel = 1};
    optional [|Tag in {4}|] PRINTER_INFO_4 pPrinterInfo4
        with Technologies.IDL.IDL{Case = [4], IndirectionLevel = 1};
    optional [|Tag in {5}|] PRINTER_INFO_5 pPrinterInfo5
        with Technologies.IDL.IDL{Case = [5], IndirectionLevel = 1};
    optional [|Tag in {6}|] PRINTER_INFO_6 pPrinterInfo6
        with Technologies.IDL.IDL{Case = [6], IndirectionLevel = 1};
    optional [|Tag in {7}|] PRINTER_INFO_7 pPrinterInfo7
        with Technologies.IDL.IDL{Case = [7], IndirectionLevel = 1};
    optional [|Tag in {8}|] PRINTER_INFO_8 pPrinterInfo8
        with Technologies.IDL.IDL{Case = [8], IndirectionLevel = 1};
    optional [|Tag in {9}|] PRINTER_INFO_9 pPrinterInfo9
        with Technologies.IDL.IDL{Case = [9], IndirectionLevel = 1};
}
with Technologies.IDL.IDL
         {Switch_Type = TypeOf<DWORD>(), UnionKind = UnionKind.NonEncapsulated};

type PRINTER_INFO_STRESS
{
    string pPrinterName
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    string pServerName
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    DWORD cJobs;
    DWORD cTotalJobs;
    DWORD cTotalBytes;
    SYSTEMTIME stUpTime;
    DWORD MaxcRef;
    DWORD cTotalPagesPrinted;
    DWORD dwGetVersion;
    DWORD fFreeBuild;
    DWORD cSpooling;
    DWORD cMaxSpooling;
    DWORD cRef;
    DWORD cErrorOutOfPaper;
    DWORD cErrorNotReady;
    DWORD cJobError;
    DWORD dwNumberOfProcessors;
    DWORD dwProcessorType;
    DWORD dwHighPartTotalBytes;
    DWORD cChangeID;
    DWORD dwLastError;
    DWORD Status;
    DWORD cEnumerateNetworkPrinters;
    DWORD cAddNetPrinters;
    ushort wProcessorArchitecture;
    ushort wProcessorLevel;
    DWORD cRefIC;
    DWORD dwReserved2;
    DWORD dwReserved3;
}

type PRINTER_INFO_1
{
    PrinterEnumerationFlags Flags
            with Encoding{Decoder = PatternDecoder<PrinterEnumerationFlags>, SourcePattern = TypeOf<DWORD>()};
    string pDescription
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    string pName with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                           String = true,
                                           IndirectionLevel = 1};
    string pComment
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
}

type PRINTER_INFO_2
{
    string pServerName
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    string pPrinterName
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    string pShareName
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    string pPortName
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    string pDriverName
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    string pComment
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    string pLocation
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    ULONG_PTR pDevMode;
    string pSepFile
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    string pPrintProcessor
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    string pDatatype
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    string pParameters
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    ULONG_PTR pSecurityDescriptor;
    DWORD Attributes;
    DWORD Priority;
    DWORD DefaultPriority;
    DWORD StartTime;
    DWORD UntilTime;
    DWORD Status;
    DWORD cJobs;
    DWORD AveragePPM;
}

type PRINTER_INFO_3
{
    ULONG_PTR pSecurityDescriptor;
}

type PRINTER_INFO_4
{
    string pPrinterName
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    string pServerName
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    DWORD Attributes;
}

type PRINTER_INFO_5
{
    string pPrinterName
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    string pPortName
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    DWORD Attributes;
    DWORD DeviceNotSelectedTimeout;
    DWORD TransmissionRetryTimeout;
}

type PRINTER_INFO_6
{
    DWORD dwStatus;
}

type PRINTER_INFO_7
{
    string pszObjectGUID
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    DWORD dwAction;
}

type PRINTER_INFO_8
{
    ULONG_PTR pDevMode;
}

type PRINTER_INFO_9
{
    ULONG_PTR pDevMode;
}

type SECURITY_CONTAINER
{
    DWORD cbBuf;
    array<BYTE> pSecurity
        with Technologies.IDL.IDL{Size_is = [cbBuf],
                                  PointerType = PointerKind.UniquePtr,
                                  IndirectionLevel = 1};
}

type DRIVER_CONTAINER
{
    DWORD Level;
    __MIDL_winspool_0006[Level] DriverInfo
        with Technologies.IDL.IDL{Switch_Is = Level, EmbedType = true};
}

type __MIDL_winspool_0006[DWORD Tag]
{
    optional [|Tag in {1}|] DRIVER_INFO_1 pNotUsed
        with Technologies.IDL.IDL{Case = [1], IndirectionLevel = 1};
    optional [|Tag in {2}|] DRIVER_INFO_2 Level2
        with Technologies.IDL.IDL{Case = [2], IndirectionLevel = 1};
    optional [|Tag in {3}|] RPC_DRIVER_INFO_3 Level3
        with Technologies.IDL.IDL{Case = [3], IndirectionLevel = 1};
    optional [|Tag in {4}|] RPC_DRIVER_INFO_4 Level4
        with Technologies.IDL.IDL{Case = [4], IndirectionLevel = 1};
    optional [|Tag in {6}|] RPC_DRIVER_INFO_6 Level6
        with Technologies.IDL.IDL{Case = [6], IndirectionLevel = 1};
    optional [|Tag in {8}|] RPC_DRIVER_INFO_8 Level8
        with Technologies.IDL.IDL{Case = [8], IndirectionLevel = 1};
}
with Technologies.IDL.IDL
         {Switch_Type = TypeOf<DWORD>(), UnionKind = UnionKind.NonEncapsulated};

type DRIVER_INFO_1
{
    string pName with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                           String = true,
                                           IndirectionLevel = 1};
}

type DRIVER_INFO_2
{
    DWORD cVersion;
    string pName with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                           String = true,
                                           IndirectionLevel = 1};
    string pEnvironment
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    string pDriverPath
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    string pDataFile
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    string pConfigFile
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
}

type RPC_DRIVER_INFO_3
{
    DWORD cVersion;
    string pName with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                           String = true,
                                           IndirectionLevel = 1};
    string pEnvironment
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    string pDriverPath
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    string pDataFile
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    string pConfigFile
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    string pHelpFile
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    string pMonitorName
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    string pDefaultDataType
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    DWORD cchDependentFiles;
    optional array<UnicodeString> pDependentFiles
            with Encoding{
                            Decoder = UnicodeStringArrayDecoder, 
                            SourceConverter = ConvertArrayWCHAR2Stream,
                            SourcePattern = TypeOf<array<wchar_t>>()
                        }
            with Technologies.IDL.IDL{Size_is = [cchDependentFiles],
                                      PointerType = PointerKind.UniquePtr,
                                      IndirectionLevel = 1};
}

type RPC_DRIVER_INFO_4
{
    DWORD cVersion;
    string pName with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                           String = true,
                                           IndirectionLevel = 1};
    string pEnvironment
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    string pDriverPath
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    string pDataFile
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    string pConfigFile
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    string pHelpFile
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    string pMonitorName
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    string pDefaultDataType
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    DWORD cchDependentFiles;
    optional array<UnicodeString> pDependentFiles
        with Encoding{
                        Decoder = UnicodeStringArrayDecoder,
                        SourceConverter = ConvertArrayWCHAR2Stream,
                        SourcePattern = TypeOf<array<wchar_t>>()
                     }
        with Technologies.IDL.IDL{Size_is = [cchDependentFiles],
                                  PointerType = PointerKind.UniquePtr,
                                  IndirectionLevel = 1};
    DWORD cchPreviousNames;
    optional array<UnicodeString> pszzPreviousNames
        with Encoding{Decoder = UnicodeStringArrayDecoder}
        with Technologies.IDL.IDL{Size_is = [cchPreviousNames],
                                  PointerType = PointerKind.UniquePtr,
                                  IndirectionLevel = 1};
}

type RPC_DRIVER_INFO_6
{
    DWORD cVersion;
    string pName with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                           String = true,
                                           IndirectionLevel = 1};
    string pEnvironment
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    string pDriverPath
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    string pDataFile
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    string pConfigFile
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    string pHelpFile
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    string pMonitorName
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    string pDefaultDataType
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    DWORD cchDependentFiles;
    optional array<UnicodeString> pDependentFiles
        with Encoding{
                        Decoder = UnicodeStringArrayDecoder,
                        SourceConverter = ConvertArrayWCHAR2Stream,
                        SourcePattern = TypeOf<array<wchar_t>>()
                     }
        with Technologies.IDL.IDL{Size_is = [cchDependentFiles],
                                  PointerType = PointerKind.UniquePtr,
                                  IndirectionLevel = 1};
    DWORD cchPreviousNames;
    optional array<UnicodeString> pszzPreviousNames
        with Encoding{
                        Decoder = UnicodeStringArrayDecoder,
                        SourceConverter = ConvertArrayWCHAR2Stream,
                        SourcePattern = TypeOf<array<wchar_t>>()
                     }
        with Technologies.IDL.IDL{Size_is = [cchPreviousNames],
                                  PointerType = PointerKind.UniquePtr,
                                  IndirectionLevel = 1};
    FILETIME ftDriverDate;
    DWORDLONG dwlDriverVersion;
    string pMfgName
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    string pOEMUrl
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    string pHardwareID
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    string pProvider
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
}

type RPC_DRIVER_INFO_8
{
    DWORD cVersion;
    string pName with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                           String = true,
                                           IndirectionLevel = 1};
    string pEnvironment
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    string pDriverPath
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    string pDataFile
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    string pConfigFile
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    string pHelpFile
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    string pMonitorName
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    string pDefaultDataType
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    DWORD cchDependentFiles;
    optional array<UnicodeString> pDependentFiles
            with Encoding{
                            Decoder = UnicodeStringArrayDecoder,
                            SourceConverter = ConvertArrayWCHAR2Stream,
                            SourcePattern = TypeOf<array<wchar_t>>()
                            }
            with Technologies.IDL.IDL{Size_is = [cchDependentFiles],
                                      PointerType = PointerKind.UniquePtr,
                                      IndirectionLevel = 1};
    DWORD cchPreviousNames;
    optional array<UnicodeString> pszzPreviousNames
            with Encoding{
                            Decoder = UnicodeStringArrayDecoder,
                            SourceConverter = ConvertArrayWCHAR2Stream,
                            SourcePattern = TypeOf<array<wchar_t>>()
                         }
            with Technologies.IDL.IDL{Size_is = [cchPreviousNames],
                                      PointerType = PointerKind.UniquePtr,
                                      IndirectionLevel = 1};
    FILETIME ftDriverDate;
    DWORDLONG dwlDriverVersion;
    string pMfgName
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    string pOEMUrl
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    string pHardwareID
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    string pProvider
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    string pPrintProcessor
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    string pVendorSetup
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    DWORD cchColorProfiles;
    optional array<UnicodeString> pszzColorProfiles
        with Encoding{
                        Decoder = UnicodeStringArrayDecoder,
                        SourceConverter = ConvertArrayWCHAR2Stream,
                        SourcePattern = TypeOf<array<wchar_t>>()
                     }
        with Technologies.IDL.IDL{Size_is = [cchColorProfiles],
                                  PointerType = PointerKind.UniquePtr,
                                  IndirectionLevel = 1};
    string pInfPath
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    DWORD dwPrinterDriverAttributes;
    DWORD cchCoreDependencies;
    optional array<UnicodeString> pszzCoreDriverDependencies
            with Encoding{
                            Decoder = UnicodeStringArrayDecoder,
                            SourceConverter = ConvertArrayWCHAR2Stream,
                            SourcePattern = TypeOf<array<wchar_t>>()
                         }
            with Technologies.IDL.IDL{Size_is = [cchCoreDependencies],
                                      PointerType = PointerKind.UniquePtr,
                                      IndirectionLevel = 1};
    FILETIME ftMinInboxDriverVerDate;
    DWORDLONG dwlMinInboxDriverVerVersion;
}

type DOC_INFO_CONTAINER
{
    DWORD Level;
    __MIDL_winspool_0005[Level] DocInfo
        with Technologies.IDL.IDL{Switch_Is = Level, EmbedType = true};
}

type __MIDL_winspool_0005[DWORD Tag]
{
    optional [|Tag in {1}|] DOC_INFO_1 pDocInfo1
        with Technologies.IDL.IDL{Case = [1], IndirectionLevel = 1};
}
with Technologies.IDL.IDL
         {Switch_Type = TypeOf<DWORD>(), UnionKind = UnionKind.NonEncapsulated};

type DOC_INFO_1
{
    string pDocName
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    string pOutputFile
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    string pDatatype
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
}

type FORM_CONTAINER
{
    DWORD Level;
    __MIDL_winspool_0007[Level] FormInfo
        with Technologies.IDL.IDL{Switch_Is = Level, EmbedType = true};
}

type __MIDL_winspool_0007[DWORD Tag]
{
    optional [|Tag in {1}|] FORM_INFO_1 pFormInfo1
        with Technologies.IDL.IDL{Case = [1], IndirectionLevel = 1};
    optional [|Tag in {2}|] RPC_FORM_INFO_2 pFormInfo2
        with Technologies.IDL.IDL{Case = [2], IndirectionLevel = 1};
}
with Technologies.IDL.IDL
         {Switch_Type = TypeOf<DWORD>(), UnionKind = UnionKind.NonEncapsulated};

type FORM_INFO_1
{
    DWORD Flags;
    string pName with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                           String = true,
                                           IndirectionLevel = 1};
    SIZE Size;
    RECTL ImageableArea;
}

typedef SIZE = __MIDL_winspool_0003;

type __MIDL_winspool_0003
{
    IDLLong cx;
    IDLLong cy;
}

typedef RECTL = __MIDL_winspool_0004;

type __MIDL_winspool_0004
{
    IDLLong left;
    IDLLong top;
    IDLLong right;
    IDLLong bottom;
}

type RPC_FORM_INFO_2
{
    DWORD Flags;
    string pName with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                           BaseStringType = TypeOf<wchar_t>(),
                                           String = true,
                                           IndirectionLevel = 1};
    SIZE Size;
    RECTL ImageableArea;
    string pKeyword
        with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                  BaseStringType = TypeOf<char>(),
                                  String = true,
                                  IndirectionLevel = 1};
    DWORD StringType;
    string pMuiDll
        with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                  BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    DWORD dwResourceId;
    string pDisplayName
        with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                  BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    LANGID wLangID;
}

typedef LANGID = ushort;

typedef GDI_HANDLE = ContextHandle;

type MONITOR_CONTAINER
{
    DWORD Level;
    __MIDL_winspool_0009[Level] MonitorInfo
        with Technologies.IDL.IDL{Switch_Is = Level, EmbedType = true};
}

type __MIDL_winspool_0009[DWORD Tag]
{
    optional [|Tag in {1}|] MONITOR_INFO_1 pMonitorInfo1
        with Technologies.IDL.IDL{Case = [1], IndirectionLevel = 1};
    optional [|Tag in {2}|] MONITOR_INFO_2 pMonitorInfo2
        with Technologies.IDL.IDL{Case = [2], IndirectionLevel = 1};
}
with Technologies.IDL.IDL
         {Switch_Type = TypeOf<DWORD>(), UnionKind = UnionKind.NonEncapsulated};

type MONITOR_INFO_1
{
    string pName with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                           String = true,
                                           IndirectionLevel = 1};
}

type MONITOR_INFO_2
{
    string pName with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                           String = true,
                                           IndirectionLevel = 1};
    string pEnvironment
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    string pDLLName
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
}

type PORT_CONTAINER
{
    DWORD Level;
    __MIDL_winspool_0010[0xFFFFFF & Level as IDLLong] PortInfo
        with Technologies.IDL.IDL{Switch_Is = 0xFFFFFF & Level, EmbedType = true};
}

type __MIDL_winspool_0010[IDLLong Tag]
{
    optional [|Tag in {1}|] PORT_INFO_1 pPortInfo1
        with Technologies.IDL.IDL{Case = [1], IndirectionLevel = 1};
    optional [|Tag in {2}|] PORT_INFO_2 pPortInfo2
        with Technologies.IDL.IDL{Case = [2], IndirectionLevel = 1};
    optional [|Tag in {3}|] PORT_INFO_3 pPortInfo3
        with Technologies.IDL.IDL{Case = [3], IndirectionLevel = 1};
    optional [|Tag in {0xFFFFFF}|] PORT_INFO_FF pPortInfoFF
        with Technologies.IDL.IDL{Case = [0xFFFFFF], IndirectionLevel = 1};
}
with Technologies.IDL.IDL
         {Switch_Type = TypeOf<IDLLong>(), UnionKind = UnionKind.NonEncapsulated};

type PORT_INFO_1
{
    string pPortName
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
}

type PORT_INFO_2
{
    string pPortName
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    string pMonitorName
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    string pDescription
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    DWORD fPortType;
    DWORD Reserved;
}

type PORT_INFO_3
{
    DWORD dwStatus;
    string pszStatus
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    DWORD dwSeverity;
}

type PORT_INFO_FF
{
    string pPortName
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    DWORD cbMonitorData;
    BYTE pMonitorData with Technologies.IDL.IDL{IndirectionLevel = 1};
}

type PORT_VAR_CONTAINER
{
    DWORD cbMonitorData;
    array<BYTE> pMonitorData
        with Technologies.IDL.IDL{Size_is = [cbMonitorData],
                                  PointerType = PointerKind.UniquePtr,
                                  IndirectionLevel = 1};
}

type RPC_V2_NOTIFY_OPTIONS
{
    DWORD Version;
    DWORD Reserved;
    DWORD Count;
    array<RPC_V2_NOTIFY_OPTIONS_TYPE> pTypes
        with Technologies.IDL.IDL{Size_is = [Count],
                                  PointerType = PointerKind.UniquePtr,
                                  IndirectionLevel = 1};
}

type RPC_V2_NOTIFY_OPTIONS_TYPE
{
    ushort Type;
    ushort Reserved0;
    DWORD Reserved1;
    DWORD Reserved2;
    DWORD Count;
    array<ushort> pFields
        with Technologies.IDL.IDL{Size_is = [Count],
                                  PointerType = PointerKind.UniquePtr,
                                  IndirectionLevel = 1};
}

type RPC_V2_UREPLY_PRINTER[DWORD Tag]
{
    optional [|Tag in {0}|] RPC_V2_NOTIFY_INFO pInfo
        with Technologies.IDL.IDL{Case = [0], IndirectionLevel = 1};
}
with Technologies.IDL.IDL
         {Switch_Type = TypeOf<DWORD>(), UnionKind = UnionKind.NonEncapsulated};

type RPC_V2_NOTIFY_INFO
{
    DWORD Version;
    DWORD Flags;
    DWORD Count;
    array<RPC_V2_NOTIFY_INFO_DATA> aData
        with Technologies.IDL.IDL{Size_is = [Count],
                                  PointerType = PointerKind.UniquePtr,
                                  Dimensions = [null]};
}

type RPC_V2_NOTIFY_INFO_DATA
{
    ushort Type;
    ushort Field;
    DWORD Reserved;
    DWORD Id;
    RPC_V2_NOTIFY_INFO_DATA_DATA[Reserved & 0xFFFF] Data
        with Technologies.IDL.IDL{Switch_Is = Reserved & 0xFFFF};
}

type RPC_V2_NOTIFY_INFO_DATA_DATA[DWORD Tag]
{
    optional [|Tag in {0x2}|] STRING_CONTAINER String
        with Technologies.IDL.IDL{Case = [0x2]};
    optional [|Tag in {0x1}|] array<DWORD> dwData
        with Technologies.IDL.IDL{Case = [0x1], Dimensions = [2]};
    optional [|Tag in {0x4}|] SYSTEMTIME_CONTAINER SystemTime
        with Technologies.IDL.IDL{Case = [0x4]};
    optional [|Tag in {0x3}|] DEVMODE_CONTAINER DevMode
        with Technologies.IDL.IDL{Case = [0x3]};
    optional [|Tag in {0x5}|] SECURITY_CONTAINER SecurityDescriptor
        with Technologies.IDL.IDL{Case = [0x5]};
}
with Technologies.IDL.IDL
         {Switch_Type = TypeOf<DWORD>(), UnionKind = UnionKind.NonEncapsulated};

type STRING_CONTAINER
{
    DWORD cbBuf;
    UnicodeString pszString
        with Encoding{Decoder = BinaryDecoder<UnicodeString>,
                        SourceConverter = ConvertArrayWCHAR2Stream,
                        SourcePattern = TypeOf<array<WCHAR>>()},
             Technologies.IDL.IDL{Size_is = [cbBuf / 2],
                                  BaseStringType = TypeOf<WCHAR>(),
                                  PointerType = PointerKind.UniquePtr,
                                  IndirectionLevel = 1};
}

type SYSTEMTIME_CONTAINER
{
    DWORD cbBuf;
    SYSTEMTIME pSystemTime with Technologies.IDL.IDL{IndirectionLevel = 1};
}

type SPLCLIENT_CONTAINER
{
    DWORD Level;
    __MIDL_winspool_0013[Level] ClientInfo
        with Technologies.IDL.IDL{Switch_Is = Level, EmbedType = true};
}

type __MIDL_winspool_0013[DWORD Tag]
{
    optional [|Tag in {1}|] SPLCLIENT_INFO_1 pClientInfo1
        with Technologies.IDL.IDL{Case = [1], IndirectionLevel = 1};
    optional [|Tag in {2}|] SPLCLIENT_INFO_2 pNotUsed1
        with Technologies.IDL.IDL{Case = [2], IndirectionLevel = 1};
    optional [|Tag in {3}|] SPLCLIENT_INFO_3 pNotUsed2
        with Technologies.IDL.IDL{Case = [3], IndirectionLevel = 1};
}
with Technologies.IDL.IDL
         {Switch_Type = TypeOf<DWORD>(), UnionKind = UnionKind.NonEncapsulated};

type SPLCLIENT_INFO_1
{
    DWORD dwSize;
    string pMachineName
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    string pUserName
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    DWORD dwBuildNum;
    DWORD dwMajorVersion;
    DWORD dwMinorVersion;
    ushort wProcessorArchitecture;
}

type SPLCLIENT_INFO_2
{
    LONG_PTR notUsed;
}

type SPLCLIENT_INFO_3
{
    uint cbSize;
    DWORD dwFlags;
    DWORD dwSize;
    string pMachineName
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    string pUserName
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    DWORD dwBuildNum;
    DWORD dwMajorVersion;
    DWORD dwMinorVersion;
    ushort wProcessorArchitecture;
    __uint64 hSplPrinter;
}

type RPC_BIDI_REQUEST_CONTAINER
{
    DWORD Version;
    DWORD Flags;
    DWORD Count;
    array<RPC_BIDI_REQUEST_DATA> aData
        with Technologies.IDL.IDL{Size_is = [Count],
                                  PointerType = PointerKind.UniquePtr,
                                  Dimensions = [null]};
}

type RPC_BIDI_REQUEST_DATA
{
    DWORD dwReqNumber;
    string pSchema
        with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                  BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    RPC_BIDI_DATA data;
}

type RPC_BIDI_DATA
{
    BidiType dwBidiType;
    __MIDL_winspool_0012[dwBidiType] u
        with Technologies.IDL.IDL{Switch_Is = dwBidiType, EmbedType = true};
}

pattern BidiType = enum uint
{
    BIDI_NULL = 0,
    BIDI_INT = 1,
    BIDI_FLOAT = 2,
    BIDI_BOOL = 3,
    BIDI_STRING = 4,
    BIDI_TEXT = 5,
    BIDI_ENUM = 6,
    BIDI_BLOB = 7
    ...
};

type __MIDL_winspool_0012[DWORD Tag]
{
    optional [|Tag in {0, 3}|] int bData
        with Technologies.IDL.IDL{Case = [0, 3]};
    optional [|Tag in {1}|] IDLLong iData with Technologies.IDL.IDL{Case = [1]};
    optional [|Tag in {4, 5, 6}|] string sData
        with Technologies.IDL.IDL{Case = [4, 5, 6],
                                  PointerType = PointerKind.UniquePtr,
                                  BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    optional [|Tag in {2}|] float fData with Technologies.IDL.IDL{Case = [2]};
    optional [|Tag in {7}|] RPC_BINARY_CONTAINER biData
        with Technologies.IDL.IDL{Case = [7]};
}
with Technologies.IDL.IDL
         {Switch_Type = TypeOf<DWORD>(), UnionKind = UnionKind.NonEncapsulated};

type RPC_BINARY_CONTAINER
{
    DWORD cbBuf;
    array<BYTE> pszString
        with Technologies.IDL.IDL{Size_is = [cbBuf],
                                  PointerType = PointerKind.UniquePtr,
                                  IndirectionLevel = 1};
}

type RPC_BIDI_RESPONSE_CONTAINER
{
    DWORD Version;
    DWORD Flags;
    DWORD Count;
    array<RPC_BIDI_RESPONSE_DATA> aData
        with Technologies.IDL.IDL{Size_is = [Count],
                                  PointerType = PointerKind.UniquePtr,
                                  Dimensions = [null]};
}

type RPC_BIDI_RESPONSE_DATA
{
    DWORD dwResult;
    DWORD dwReqNumber;
    string pSchema
        with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                  BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    RPC_BIDI_DATA data;
}

type CORE_PRINTER_DRIVER
{
    GUID CoreDriverGUID;
    FILETIME ftDriverDate;
    DWORDLONG dwlDriverVersion;
    optional UnicodeString szPackageID 
        with Encoding{
                        Decoder = BinaryDecoder<UnicodeString>, 
                        SourceConverter = ConvertArrayWCHAR2Stream,
                        SourcePattern = TypeOf<array<wchar_t>>()
                     }
        with Technologies.IDL.IDL{Dimensions = [260]};
}

typedef RPC_PrintPropertyValue = __MIDL_winspool_0014;

type __MIDL_winspool_0014
{
    RPC_EPrintPropertyType ePropertyType;
    __MIDL_winspool_0015[ePropertyType] @value
        with Technologies.IDL.IDL{Switch_Is = ePropertyType, EmbedType = true};
}

typedef RPC_EPrintPropertyType = __MIDL_winspool_0002;

pattern __MIDL_winspool_0002 = enum 
                               {
                                   kRpcPropertyTypeString = 1,
                                   kRpcPropertyTypeInt32 = 2,
                                   kRpcPropertyTypeInt64 = 3,
                                   kRpcPropertyTypeByte = 4,
                                   kRpcPropertyTypeBuffer = 5,
                                   ...
                               };

type __MIDL_winspool_0015[RPC_EPrintPropertyType Tag]
{
    optional [|Tag in {1}|] string propertyString
        with Technologies.IDL.IDL{Case = [1],
                                  BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    optional [|Tag in {(2)}|] LONG propertyInt32
        with Technologies.IDL.IDL{Case = [(2)]};
    optional [|Tag in {(3)}|] LONGLONG propertyInt64
        with Technologies.IDL.IDL{Case = [(3)]};
    optional [|Tag in {(4)}|] BYTE propertyByte
        with Technologies.IDL.IDL{Case = [(4)]};
    optional [|Tag in {(5)}|] __MIDL_winspool_0016 propertyBlob
        with Technologies.IDL.IDL{Case = [(5)]};
}
with Technologies.IDL.IDL{Switch_Type = TypeOf<RPC_EPrintPropertyType>(),
                          UnionKind = UnionKind.NonEncapsulated};

type __MIDL_winspool_0016
{
    DWORD cbBuf;
    array<BYTE> pBuf with Technologies.IDL.IDL{Size_is = [cbBuf], IndirectionLevel = 1};
}

typedef RPC_PrintNamedProperty = __MIDL_winspool_0017;

type __MIDL_winspool_0017
{
    string propertyName
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    RPC_PrintPropertyValue propertyValue;
}

typedef RPC_BranchOfficeJobDataContainer = __MIDL_winspool_0026;

type __MIDL_winspool_0026
{
    DWORD cJobDataEntries;
    array<RPC_BranchOfficeJobData> JobData
        with Technologies.IDL.IDL{Size_is = [cJobDataEntries],
                                  PointerType = PointerKind.UniquePtr,
                                  Dimensions = [null]};
}

typedef RPC_BranchOfficeJobData = __MIDL_winspool_0024;

type __MIDL_winspool_0024
{
    EBranchOfficeJobEventType eEventType;
    DWORD JobId;
    __MIDL_winspool_0025[eEventType] JobInfo
        with Technologies.IDL.IDL{Switch_Is = eEventType, EmbedType = true};
}

typedef EBranchOfficeJobEventType = __MIDL_winspool_0018;

pattern __MIDL_winspool_0018 = enum 
                               {
                                   kInvalidJobState = 0,
                                   kLogJobPrinted = 1,
                                   kLogJobRendered = 2,
                                   kLogJobError = 3,
                                   kLogJobPipelineError = 4,
                                   kLogOfflineFileFull = 5,
                                   ...
                               };

type __MIDL_winspool_0025[EBranchOfficeJobEventType Tag]
{
    optional [|Tag in {(1)}|] RPC_BranchOfficeJobDataPrinted LogJobPrinted
        with Technologies.IDL.IDL{Case = [(1)]};
    optional [|Tag in {(2)}|] RPC_BranchOfficeJobDataRendered LogJobRendered
        with Technologies.IDL.IDL{Case = [(2)]};
    optional [|Tag in {(3)}|] RPC_BranchOfficeJobDataError LogJobError
        with Technologies.IDL.IDL{Case = [(3)]};
    optional [|Tag in {(4)}|] RPC_BranchOfficeJobDataPipelineFailed
        LogPipelineFailed with Technologies.IDL.IDL{Case = [(4)]};
    optional [|Tag in {(5)}|] RPC_BranchOfficeLogOfflineFileFull
        LogOfflineFileFull with Technologies.IDL.IDL{Case = [(5)]};
}
with Technologies.IDL.IDL{Switch_Type = TypeOf<EBranchOfficeJobEventType>(),
                          UnionKind = UnionKind.NonEncapsulated};

typedef RPC_BranchOfficeJobDataPrinted = __MIDL_winspool_0019;

type __MIDL_winspool_0019
{
    DWORD Status;
    string pDocumentName
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    string pUserName
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    string pMachineName
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    string pPrinterName
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    string pPortName
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    LONGLONG Size;
    DWORD TotalPages;
}

typedef RPC_BranchOfficeJobDataRendered = __MIDL_winspool_0020;

type __MIDL_winspool_0020
{
    LONGLONG Size;
    DWORD ICMMethod;
    short Color;
    short PrintQuality;
    short YResolution;
    short Copies;
    short TTOption;
}

typedef RPC_BranchOfficeJobDataError = __MIDL_winspool_0021;

type __MIDL_winspool_0021
{
    DWORD LastError;
    string pDocumentName
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    string pUserName
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    string pPrinterName
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    string pDataType
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    LONGLONG TotalSize;
    LONGLONG PrintedSize;
    DWORD TotalPages;
    DWORD PrintedPages;
    string pMachineName
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    string pJobError
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    string pErrorDescription
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
}

typedef RPC_BranchOfficeJobDataPipelineFailed = __MIDL_winspool_0022;

type __MIDL_winspool_0022
{
    string pDocumentName
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    string pPrinterName
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
    string pExtraErrorInfo
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
}

typedef RPC_BranchOfficeLogOfflineFileFull = __MIDL_winspool_0023;

type __MIDL_winspool_0023
{
    string pMachineName
        with Technologies.IDL.IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
}

// 3.1.4.3.1 RpcSetJob (Opnum 2)
pattern JobControlCommand = enum DWORD
{
    No_Additional_Action = 0x00000000
        with Documentation{Description = "Perform no additional action."},
    JOB_CONTROL_PAUSE = 0x00000001
        with Documentation{Description = "Pause the print job."},
    JOB_CONTROL_RESUME = 0x00000002
        with Documentation{Description = "Resume a paused print job."},
    JOB_CONTROL_CANCEL = 0x00000003
        with Documentation{Description = "Delete a print job."},
    JOB_CONTROL_RESTART = 0x00000004
        with Documentation{Description = "Restart a print job."},
    JOB_CONTROL_DELETE = 0x00000005
        with Documentation{Description = "Delete a print job."},
    JOB_CONTROL_SENT_TO_PRINTER = 0x00000006
        with Documentation{Description = "Used by port monitors to signal that a print job has been sent to the printer."},
    JOB_CONTROL_LAST_PAGE_EJECTED = 0x00000007
        with Documentation{Description = "Used by language monitors to signal that the last page of a print job has been ejected from the printer."},
    JOB_CONTROL_RETAIN = 0x00000008
        with Documentation{Description = "Keep the print job in the print queue after it prints."},
    JOB_CONTROL_RELEASE = 0x00000009
        with Documentation{Description = "Release the print job, undoing the effect of a JOB_CONTROL_RETAIN action."},
    ...
} with IDL{DoNotGenerate = true};

// 3.1.4.2.5 RpcSetPrinter (Opnum 7)
pattern PrinterControlCommand = enum DWORD
{
    PRINTER_CONTROL_PAUSE = 0x00000001
        with Documentation{Description = "Pauses the printer object."},
    PRINTER_CONTROL_RESUME = 0x00000002
        with Documentation{Description = "Resumes a paused printer object."},
    PRINTER_CONTROL_PURGE = 0x00000003
        with Documentation{Description = "Deletes all print jobs queued for the printer object."},
    ...
} with IDL{DoNotGenerate = true};

// 2.2.3.2 Change Notification Flags
pattern ChangeNotificationFlags = enum DWORD
{
    PRINTER_NOTIFY_INFO_DISCARDNOTED = 0x00010000
        with Documentation{Description = "The client acknowledges receiving and processing the PRINTER_NOTIFY_INFO_DISCARDED notification."},
    PRINTER_NOTIFY_INFO_COLORMISMATCH = 0x00080000
        with Documentation{Description = "The value of the dwColor parameter in a call to RpcRouterReplyPrinterEx does not match the value the client previously passed to the server in a call to RpcRouterRefreshPrinterChangeNotification."},
    ...
} with IDL{DoNotGenerate = true};

// 2.2.3.9 Registry Type Values
pattern RegistryTypeValues = enum DWORD
{
    REG_NONE = 0x00000000
        with Documentation{Description = "No value type is defined."},
    REG_SZ = 0x00000001
        with Documentation{Description = "A string."},
    REG_EXPAND_SZ = 0x00000002
        with Documentation{Description = "A string that can contain unexpanded references to environment variables, for example, \"%PATH%\"."},
    REG_BINARY = 0x00000003
        with Documentation{Description = "Binary data in any form."},
    REG_DWORD_LITTLE_ENDIAN = 0x00000004
        with Documentation{Description = "A 32-bit number in little-endian format."},
    REG_DWORD_BIG_ENDIAN = 0x00000005
        with Documentation{Description = "A 32-bit number in big-endian format."},
    REG_LINK = 0x00000006
        with Documentation{Description = "ymbolic link to a registry key."},
    REG_MULTI_SZ = 0x00000007
        with Documentation{Description = "A REG_MULTI_SZ structure as specified in [MS-RRP] section 2.2.6."},
    REG_RESOURCE_LIST = 0x00000008
        with Documentation{Description = "A device driver resource list."},
    REG_QWORD_LITTLE_ENDIAN = 0x0000000B
        with Documentation{Description = "A 64-bit number in little-endian format."},
    ...
} with IDL{DoNotGenerate = true};

// 2.2.3.7 Printer Enumeration Flags
pattern PrinterEnumerationFlags = flags DWORD
{
    PRINTER_ENUM_LOCAL = 0x00000002
        with Documentation{Description = "Enumerate local printer objects."},
    PRINTER_ENUM_CONNECTIONS = 0x00000004
        with Documentation{Description = "Enumerate printer connections previously added through RpcAddPerMachineConnection."},
    PRINTER_ENUM_NAME = 0x00000008
        with Documentation{Description = "Enumerate printers on the print server, network domain, or a specific print provider."},
    PRINTER_ENUM_REMOTE = 0x00000010
        with Documentation{Description = "Enumerate network printers and other print servers that are in the same domain as the print server."},
    PRINTER_ENUM_SHARED = 0x00000020
        with Documentation{Description = "Only enumerate printers with the shared attribute set."},
    PRINTER_ENUM_NETWORK = 0x00000040
        with Documentation{Description = "Enumerate network printers that are in the same domain as the print server."},
    PRINTER_ENUM_EXPAND = 0x00004000
        with Documentation{Description = "Indicates that the printer object contains further enumerable child objects."},
    PRINTER_ENUM_CONTAINER = 0x00008000
        with Documentation{Description = "Indicates that the printer object is capable of containing enumerable objects."},
    PRINTER_ENUM_ICON1 = 0x00010000
        with Documentation{Description = "Indicates that, where appropriate, an application treats the printer object as a top-level network name, such as Windows network."},
    PRINTER_ENUM_ICON2 = 0x00020000
        with Documentation{Description = "Indicates that, where appropriate, an application treats an object as a network domain name."},
    PRINTER_ENUM_ICON3 = 0x00040000
        with Documentation{Description = "Indicates that, where appropriate, an application treats an object as a print server."},
    PRINTER_ENUM_ICON8 = 0x00800000
        with Documentation{Description = "Indicates that, where appropriate, an application treats an object as a print server."},
    PRINTER_ENUM_HIDE = 0x01000000
        with Documentation{Description = "Indicates that an application cannot display the printer object."},
    ...
} with IDL{DoNotGenerate = true};

// 2.2.3.6 Printer Change Flags
pattern PrinterChangeFlags = flags DWORD
{
    PRINTER_CHANGE_SET_PRINTER = 0x00000002
        with Documentation{Description = "Printer object properties were configured."},
    PRINTER_CHANGE_DELETE_PRINTER = 0x00000004
        with Documentation{Description = "A printer object was deleted."},
    PRINTER_CHANGE_PRINTER = 0x000000FF
        with Documentation{Description = "A printer object changed in some way."},
    PRINTER_CHANGE_ADD_JOB = 0x00000100
        with Documentation{Description = "A print job was added."},
    PRINTER_CHANGE_SET_JOB  = 0x00000200
        with Documentation{Description = "Print job properties were configured."},
    PRINTER_CHANGE_DELETE_JOB = 0x00000400
        with Documentation{Description = "A print job was deleted."},
    PRINTER_CHANGE_WRITE_JOB = 0x00000800
        with Documentation{Description = "A print job was written."},
    PRINTER_CHANGE_JOB = 0x0000FF00
        with Documentation{Description = "A print job changed in some way."},
    PRINTER_CHANGE_SET_PRINTER_DRIVER = 0x20000000
        with Documentation{Description = "A printer driver was specified."},
    PRINTER_CHANGE_TIMEOUT = 0x80000000
        with Documentation{Description = "Returned by RpcWaitForPrinterChange if the implementation-specific timeout has expired."},
    PRINTER_CHANGE_ALL = 0x7777FFFF
        with Documentation{Description = "A change was made to one or more printer-related objects, including print job, form, port, processor, or printer driver, or to the printer object itself."},
    PRINTER_CHANGE_ALL_2 = 0x7F77FFFF
        with Documentation{Description = "Identical with PRINTER_CHANGE_ALL (0x7777FFFF)."},
    PRINTER_CHANGE_ADD_PRINTER_DRIVER = 0x10000000
        with Documentation{Description = "A printer driver was added."},
    PRINTER_CHANGE_DELETE_PRINTER_DRIVER = 0x40000000
        with Documentation{Description = "A printer driver was deleted."},
    PRINTER_CHANGE_PRINTER_DRIVER = 0x70000000
        with Documentation{Description = "A printer driver was changed in some way."},
    PRINTER_CHANGE_ADD_FORM = 0x00010000
        with Documentation{Description = "A form was added."},
    PRINTER_CHANGE_DELETE_FORM = 0x00040000
        with Documentation{Description = "A form was deleted."},
    PRINTER_CHANGE_SET_FORM = 0x00020000
        with Documentation{Description = "Form properties were configured."},
    PRINTER_CHANGE_FORM = 0x00070000
        with Documentation{Description = "A form was changed in some way."},
    PRINTER_CHANGE_ADD_PORT = 0x00100000
        with Documentation{Description = "A port was added."},
    PRINTER_CHANGE_CONFIGURE_PORT = 0x00200000
        with Documentation{Description = "Port properties were configured."},
    PRINTER_CHANGE_DELETE_PORT = 0x00400000
        with Documentation{Description = "A port was deleted."},
    PRINTER_CHANGE_PORT = 0x00700000
        with Documentation{Description = "A port was changed in some way."},
    PRINTER_CHANGE_ADD_PRINT_PROCESSOR = 0x01000000
        with Documentation{Description = "A print processor was added."},
    PRINTER_CHANGE_DELETE_PRINT_PROCESSOR = 0x04000000
        with Documentation{Description = "A print processor was deleted."},
    PRINTER_CHANGE_PRINT_PROCESSOR = 0x07000000
        with Documentation{Description = "The properties for a print processor were updated."},
    PRINTER_CHANGE_ADD_PRINTER = 0x00000001
        with Documentation{Description = "A printer object was added."},
    PRINTER_CHANGE_FAILED_CONNECTION_PRINTER = 0x00000008
        with Documentation{Description = "A connection to a printer object failed."},
    PRINTER_CHANGE_SERVER = 0x08000000
        with Documentation{Description = "A change was made to one or more of the monitored server configuration settings."},
    ...
} with IDL{DoNotGenerate = true};

// 2.2.3.8 Printer Notification Values
pattern PrinterNotificationValues = enum DWORD
{
    PRINTER_2D_ONLY = 0x00000000
        with Documentation{Description = "Return notifications for 2D printers only."},
    PRINTER_NOTIFY_CATEGORY_ALL = 0x00010000
        with Documentation{Description = "Return notifications for both 2D and 3D printers."},
    PRINTER_NOTIFY_CATEGORY_3D = 0x00020000
        with Documentation{Description = "Return notifications for 3D printers only."},
    ...
} with IDL{DoNotGenerate = true};

pattern DeletePrinterDriverFlags = flags DWORD
{
    DPD_DELETE_UNUSED_FILES = 0x00000001
        with Documentation{Description = "Remove unused printer driver files."},
    DPD_DELETE_SPECIFIC_VERSION = 0x00000002
        with Documentation{Description = "Delete the version specified by the value of the dwVersionNum parameter."},
    DPD_DELETE_ALL_FILES = 0x00000004
        with Documentation{Description = "Delete the printer driver only if all its associated files can be removed."},
    ...
} with IDL{DoNotGenerate = true};

pattern FileCopyFlags = enum DWORD
{
    APD_STRICT_UPGRADE = 0x00000001
        with Documentation{Description = "Add the replacement printer driver only if none of the files of the replacement driver are older than any corresponding files of the currently installed driver."},
    APD_STRICT_DOWNGRADE = 0x00000002
        with Documentation{Description = "Add the replacement printer driver only if none of the files of the currently installed driver are older than any corresponding files of the replacement driver."},
    APD_COPY_ALL_FILES = 0x00000004
        with Documentation{Description = "Add the printer driver and copy all the files in the driver directory."},
    APD_COPY_NEW_FILES = 0x00000008
        with Documentation{Description = "Add the printer driver and copy the files in the driver directory that are newer than any of the corresponding files that are currently in use."},
    APD_COPY_FROM_DIRECTORY = 0x00000010
        with Documentation{Description = "Add the printer driver by using the fully qualified file names that are specified in the _DRIVER_INFO_6 structure."},
    APD_DONT_COPY_FILES_TO_CLUSTER = 0x00001000
        with Documentation{Description = "When adding a printer driver to a print server cluster, do not copy the driver files to the shared cluster disk."},
    APD_COPY_TO_ALL_SPOOLERS = 0x00002000
        with Documentation{Description = "Add the printer driver to cluster spooler servers."},
    APD_INSTALL_WARNED_DRIVER = 0x00008000
        with Documentation{Description = "Add the printer driver even if it is in the server's warned list."},
    APD_RETURN_BLOCKING_STATUS_CODE = 0x00010000
        with Documentation{Description = "Specifies the implementation-specific error code to return if the printer driver is blocked from installation by server policy."},
    ...
} with IDL{DoNotGenerate = true};

// 2.2.2   Custom-Marshaled Data Types
type DEVMODE
{
    string dmDeviceName with BinaryEncoding{TextEncoding = TextEncoding.Unicode, WidthForComposedType = 32 * 8};
    ushort dmSpecVersion;
    ushort dmDriverVersion;
    ushort dmSize;
    ushort dmDriverExtra;
    DEVMODE_DmFields_Flags dmFields;
    DEVMODE_DmOrientation dmOrientation;
    DEVMODE_DmPaperSize dmPaperSize;
    ushort dmPaperLength;
    ushort dmPaperWidth;
    ushort dmScale;
    ushort dmCopies;
    DEVMODE_DmDefaultSource dmDefaultSource;
    DEVMODE_DmPrintQuality dmPrintQuality;
    DEVMODE_DmColor dmColor
        where ValidationCheckEnumValue(InRange<DEVMODE_DmColor>(value), null, true, ReferenceType.Type, 
                                        "RPRN", "dmColor", "DEVMODE", "0x0001, 0x0002", value);
    DEVMODE_DmDuplex dmDuplex;
    ushort dmYResolution;
    DEVMODE_DmTTOption dmTTOption;
    DEVMODE_DmCollate dmCollate;
    ushort dmFormName;
    ushort reserved0;
    uint reserved1;
    uint reserved2;
    uint reserved3;
    DEVMODE_DmNup dmNup;
    uint reserved4;
    DEVMODE_DmICMMethod dmICMMethod;
    DEVMODE_DmICMIntent dmICMIntent;
    DEVMODE_DmMediaType dmMediaType;
    DEVMODE_DmDitherType dmDitherType;
    uint reserved5;
    uint reserved6;
    uint reserved7;
    uint reserved8;
    binary dmDriverExtraData with BinaryEncoding{Length = dmDriverExtra};
} with IDL{DoNotGenerate = true};

pattern DEVMODE_DmFields_Flags = flags uint
{
    UP = 0x00000002
        with Documentation{Description = "the dmNup field MUST be initialized."},
    SC = 0x00000008
        with Documentation{Description = "the dmScale field MUST be initialized."},
    PW = 0x00000010
        with Documentation{Description = "the dmPaperWidth field MUST be initialized. "},
    PL = 0x00000020
        with Documentation{Description = "the dmPaperLength field MUST be initialized."},
    PS = 0x00000040
        with Documentation{Description = "the dmPaperSize field MUST be initialized."},
    OR = 0x00000080
        with Documentation{Description = "the dmOrientation field MUST be initialized."},
    CL = 0x00000100
        with Documentation{Description = "the dmCollate field MUST be initialized."},
    TT = 0x00000200
        with Documentation{Description = "the dmTTOption field MUST be initialized."},
    Y = 0x00000400
        with Documentation{Description = "the dmYResolution field MUST be initialized."},
    DX = 0x00000800
        with Documentation{Description = "the dmDuplex field MUST be initialized."},
    CR = 0x00001000
        with Documentation{Description = "the dmColor field MUST be initialized."},
    PQ = 0x00002000
        with Documentation{Description = "the dmPrintQuality field MUST be initialized."},
    DS = 0x00004000
        with Documentation{Description = "the dmDefaultSource field MUST be initialized."},
    CP = 0x00008000
        with Documentation{Description = "the dmCopies field MUST be initialized."},
    CM = 0x00010000
        with Documentation{Description = "the dmICMMethod field MUST be initialized."},
    FM = 0x00800000
        with Documentation{Description = "the dmFormName field MUST be initialized."},
    DT = 0x20000000
        with Documentation{Description = "the dmDitherType field MUST be initialized."},
    MT = 0x40000000
        with Documentation{Description = "the dmMediaType field MUST be initialized."},
    CI = 0x80000000
        with Documentation{Description = "the dmICMIntent field MUST be initialized."},
    ...
} with IDL{DoNotGenerate = true};

pattern DEVMODE_DmOrientation = enum ushort
{
    DMORIENT_POTRAIT = 0x0001
        with Documentation
            {Description = "Portrait orientation."},
    DMORIENT_LANDSCAPE = 0x0002
        with Documentation
            {Description = "Landscape orientation."},
    ...
} with IDL{DoNotGenerate = true};

pattern DEVMODE_DmPaperSize = enum ushort
{
    DMPAPER_LETTER = 0x0001
        with Documentation{Description = "Letter, 8 1/2 x 11 inches."},
    DMPAPER_LEGAL = 0x0005
        with Documentation{Description = "Legal, 8 1/2 x 14 inches."},
    DMPAPER_10X14 = 0x0010
        with Documentation{Description = "10 x 14-inch sheet."},
    DMPAPER_11X17 = 0x0011
        with Documentation{Description = "11 x 17-inch sheet."},
    DMPAPER_12X11 = 0x005A
        with Documentation{Description = "12 x 11-inch sheet."},
    DMPAPER_A3 = 0x0008
        with Documentation{Description = "A3 sheet, 297 x 420 millimeters."},
    DMPAPER_A3_ROTATED = 0x004C
        with Documentation{Description = "A3 rotated sheet, 420 x 297 millimeters."},
    DMPAPER_A4 = 0x0009
        with Documentation{Description = "A4 sheet, 210 x 297 millimeters."},
    DMPAPER_A4_ROTATED = 0x004D
        with Documentation{Description = "A4 rotated sheet, 297 x 210 millimeters."},
    DMPAPER_A4SMALL = 0x000A
        with Documentation{Description = "A4 small sheet, 210 x 297 millimeters."},
    DMPAPER_A5 = 0x000B
        with Documentation{Description = "A5 sheet, 148 x 210 millimeters."},
    DMPAPER_A5_ROTATED = 0x004E
        with Documentation{Description = "A5 rotated sheet, 210 x 148 millimeters."},
    DMPAPER_A6 = 0x0046
        with Documentation{Description = "A6 sheet, 105 x 148 millimeters."},
    DMPAPER_A6_ROTATED = 0x0053
        with Documentation{Description = "A6 rotated sheet, 148 x 105 millimeters."},
    DMPAPER_B4 = 0x000C
        with Documentation{Description = "B4 sheet, 250 x 354 millimeters."},
    DMPAPER_B4_JIS_ROTATED = 0x004F
        with Documentation{Description = "B4 (JIS) rotated sheet, 364 x 257 millimeters."},
    DMPAPER_B5 = 0x000D
        with Documentation{Description = "B5 sheet, 182 x 257-millimeter paper."},
    DMPAPER_B5_JIS_ROTATED = 0x0050
        with Documentation{Description = "B5 (JIS) rotated sheet, 257 x 182 millimeters."},
    DMPAPER_B6_JIS = 0x0058
        with Documentation{Description = "B6 (JIS) sheet, 128 x 182 millimeters."},
    DMPAPER_B6_JIS_ROTATED = 0x0059
        with Documentation{Description = "B6 (JIS) rotated sheet, 182 x 128 millimeters."},
    DMPAPER_CSHEET = 0x0018
        with Documentation{Description = "C Sheet, 17 x 22 inches."},
    DMPAPER_DBL_JAPANESE_POSTCARD = 0x0045
        with Documentation{Description = "Double Japanese Postcard, 200 x 148 millimeters."},
    DMPAPER_DBL_JAPANESE_POSTCARD_ROTATED  = 0x0052
        with Documentation{Description = "Double Japanese Postcard Rotated, 148 x 200 millimeters."},
    DMPAPER_DSHEET = 0x0019
        with Documentation{Description = "D Sheet, 22 x 34 inches."},
    DMPAPER_ENV_9 = 0x0013
        with Documentation{Description = "#9 Envelope, 3 7/8 x 8 7/8 inches."},
    DMPAPER_ENV_10 = 0x0014
        with Documentation{Description = "#10 Envelope, 4 1/8 x 9 1/2 inches."},
    DMPAPER_ENV_11 = 0x0015
        with Documentation{Description = "#11 Envelope, 4 1/2 x 10 3/8 inches."},
    DMPAPER_ENV_12 = 0x0016
        with Documentation{Description = "#12 Envelope, 4 3/4 x 11 inches."},
    DMPAPER_ENV_14 = 0x0017
        with Documentation{Description = "#14 Envelope, 5 x 11 1/2 inches."},
    DMPAPER_ENV_C5 = 0x001C
        with Documentation{Description = "C5 Envelope, 162 x 229 millimeters."},
    DMPAPER_ENV_C3 = 0x001D
        with Documentation{Description = "C3 Envelope, 324 x 458 millimeters."},
    DMPAPER_ENV_C4 = 0x001E
        with Documentation{Description = "C4 Envelope, 229 x 324 millimeters."},
    DMPAPER_ENV_C6 = 0x001F
        with Documentation{Description = "C6 Envelope, 114 x 162 millimeters."},
    DMPAPER_ENV_C65 = 0x0020
        with Documentation{Description = "C65 Envelope, 114 x 229 millimeters."},
    DMPAPER_ENV_B4 = 0x0021
        with Documentation{Description = "B4 Envelope, 250 x 353 millimeters."},
    DMPAPER_ENV_B5 = 0x0022
        with Documentation{Description = "B5 Envelope, 176 x 250 millimeters."},
    DMPAPER_ENV_B6 = 0x0023
        with Documentation{Description = "B6 Envelope, 176 x 125 millimeters."},
    DMPAPER_ENV_DL = 0x001B
        with Documentation{Description = "DL Envelope, 110 x 220 millimeters."},
    DMPAPER_ENV_ITALY = 0x0024
        with Documentation{Description = "Italy Envelope, 110 x 230 millimeters."},
    DMPAPER_ENV_MONARCH = 0x0025
        with Documentation{Description = "Monarch Envelope, 3 7/8 x 7 1/2 inches."},
    DMPAPER_ENV_PERSONAL = 0x0026
        with Documentation{Description = "6 3/4 Envelope, 3 5/8 x 6 1/2 inches."},
    DMPAPER_ESHEET = 0x001A
        with Documentation{Description = "E Sheet, 34 x 44 inches."},
    DMPAPER_EXECUTIVE = 0x0007
        with Documentation{Description = "Executive, 7 1/4 x 10 1/2 inches."},
    DMPAPER_FANFOLD_US = 0x0027
        with Documentation{Description = "US Std Fanfold, 14 7/8 x 11 inches."},
    DMPAPER_FANFOLD_STD_GERMAN  = 0x0028
        with Documentation{Description = "German Std Fanfold, 8 1/2 x 12 inches."},
    DMPAPER_FANFOLD_LGL_GERMAN  = 0x0029
        with Documentation{Description = "German Legal Fanfold, 8 x 13 inches."},
    DMPAPER_FOLIO = 0x000E
        with Documentation{Description = "Folio, 8 1/2 x 13-inch paper."},
    DMPAPER_JAPANESE_POSTCARD_ROTATED = 0x0051
        with Documentation{Description = "Japanese Postcard Rotated, 148 x 100 millimeters."},
    DMPAPER_JENV_CHOU3 = 0x0049
        with Documentation{Description = "Japanese Envelope Chou #3."},
    DMPAPER_JENV_CHOU3_ROTATED = 0x0056
        with Documentation{Description = "Japanese Envelope Chou #3 Rotated."},
    DMPAPER_JENV_CHOU4 = 0x004A
        with Documentation{Description = "Japanese Envelope Chou #4."},
    DMPAPER_JENV_CHOU4_ROTATED = 0x0057
        with Documentation{Description = "Japanese Envelope Chou #4 Rotated."},
    DMPAPER_JENV_KAKU2 = 0x0047
        with Documentation{Description = "Japanese Envelope Kaku #2."},
    DMPAPER_JENV_KAKU2_ROTATED = 0x0054
        with Documentation{Description = "Japanese Envelope Kaku #2 Rotated."},
    DMPAPER_JENV_KAKU3 = 0x0048
        with Documentation{Description = "Japanese Envelope Kaku #3."},
    DMPAPER_JENV_KAKU3_ROTATED = 0x0055
        with Documentation{Description = "Japanese Envelope Kaku #3 Rotated."},
    DMPAPER_JENV_YOU4 = 0x005B
        with Documentation{Description = "Japanese Envelope You #4."},
    DMPAPER_JENV_YOU4_ROTATED  = 0x005C
        with Documentation{Description = "Japanese Envelope You #4."},
    DMPAPER_LEDGER = 0x0004
        with Documentation{Description = "Ledger, 17 x 11 inches."},
    DMPAPER_LETTER_ROTATED = 0x004B
        with Documentation{Description = "Letter Rotated, 11 by 8 1/2 inches."},
    DMPAPER_LETTERSMALL = 0x0002
        with Documentation{Description = "Letter Small, 8 1/2 x 11 inches."},
    DMPAPER_NOTE = 0x0012
        with Documentation{Description = "Note, 8 1/2 x 11-inches."},
    DMPAPER_P16K = 0x005D
        with Documentation{Description = "PRC 16K, 146 x 215 millimeters."},
    DMPAPER_P16K_ROTATED = 0x006A
        with Documentation{Description = "PRC 16K Rotated, 215 x 146 millimeters."},
    DMPAPER_P32K = 0x005E
        with Documentation{Description = "PRC 32K, 97 x 151 millimeters."},
    DMPAPER_P32K_ROTATED = 0x006B
        with Documentation{Description = "PRC 32K Rotated, 151 x 97 millimeters."},
    DMPAPER_P32KBIG = 0x005F
        with Documentation{Description = "PRC 32K(Big) 97 x 151 millimeters."},
    DMPAPER_P32KBIG_ROTATED = 0x006C
        with Documentation{Description = "PRC 32K(Big) Rotated, 151 x 97 millimeters."},
    DMPAPER_PENV_1 = 0x0060
        with Documentation{Description = "PRC Envelope #1, 102 by 165 millimeters."},
    DMPAPER_PENV_1_ROTATED = 0x006D
        with Documentation{Description = "PRC Envelope #1 Rotated, 165 x 102 millimeters."},
    DMPAPER_PENV_2 = 0x0061
        with Documentation{Description = "PRC Envelope #2, 102 x 176 millimeters."},
    DMPAPER_PENV_2_ROTATED = 0x006E
        with Documentation{Description = "PRC Envelope #2 Rotated, 176 x 102 millimeters."},
    DMPAPER_PENV_3 = 0x0062
        with Documentation{Description = "PRC Envelope #3, 125 x 176 millimeters."},
    DMPAPER_PENV_3_ROTATED = 0x006F
        with Documentation{Description = "PRC Envelope #3 Rotated, 176 x 125 millimeters."},
    DMPAPER_PENV_4 = 0x0063
        with Documentation{Description = "PRC Envelope #4, 110 x 208 millimeters."},
    DMPAPER_PENV_4_ROTATED = 0x0070
        with Documentation{Description = "PRC Envelope #4 Rotated, 208 x 110 millimeters."},
    DMPAPER_PENV_5 = 0x0064
        with Documentation{Description = "PRC Envelope #5, 110 x 220 millimeters."},
    DMPAPER_PENV_5_ROTATED = 0x0071
        with Documentation{Description = "PRC Envelope #5 Rotated, 220 x 110 millimeters."},
    DMPAPER_PENV_6 = 0x0065
        with Documentation{Description = "PRC Envelope #6, 120 x 230 millimeters."},
    DMPAPER_PENV_6_ROTATED = 0x0072
        with Documentation{Description = "PRC Envelope #6 Rotated, 230 x 120 millimeters."},
    DMPAPER_PENV_7 = 0x0066
        with Documentation{Description = "PRC Envelope #7, 160 x 230 millimeters."},
    DMPAPER_PENV_7_ROTATED = 0x0073
        with Documentation{Description = "PRC Envelope #7 Rotated, 230 x 160 millimeters."},
    DMPAPER_PENV_8 = 0x0067
        with Documentation{Description = "PRC Envelope #8, 120 x 309 millimeters."},
    DMPAPER_PENV_8_ROTATED = 0x0074
        with Documentation{Description = "PRC Envelope #8 Rotated, 309 x 120 millimeters."},
    DMPAPER_PENV_9 = 0x0068
        with Documentation{Description = "PRC Envelope #9, 229 x 324 millimeters."},
    DMPAPER_PENV_9_ROTATED = 0x0075
        with Documentation{Description = "PRC Envelope #9 Rotated, 324 x 229 millimeters."},
    DMPAPER_PENV_10 = 0x0069
        with Documentation{Description = "PRC Envelope #10, 324 x 458 millimeters."},
    DMPAPER_PENV_10_ROTATED = 0x0076
        with Documentation{Description = "PRC Envelope #10 Rotated, 458 x 324 millimeters."},
    DMPAPER_QUARTO = 0x000F
        with Documentation{Description = "Quarto, 215 x 275 millimeter paper."},
    DMPAPER_STATEMENT = 0x0006
        with Documentation{Description = "Statement, 5 1/2 x 8 1/2 inches."},
    DMPAPER_TABLOID = 0x0003
        with Documentation{Description = "Tabloid, 11 x 17 inches."},
    // 0x0100 or larger values indicate that the value is device-specific.
    ...
} with IDL{DoNotGenerate = true};

pattern DEVMODE_DmDefaultSource = enum ushort
{
    DMBIN_UPPER = 0x0001
        with Documentation{Description = "Select the upper paper bin. This value is also used for the paper source for printers that only have one paper bin."},
    DMBIN_LOWER = 0x0002
        with Documentation{Description = "Select the lower bin."},
    DMBIN_MIDDLE = 0x0003
        with Documentation{Description = "Select the middle paper bin."},
    DMBIN_MANUAL = 0x0004
        with Documentation{Description = "Manually select the paper bin."},
    DMBIN_ENVELOPE = 0x0005
        with Documentation{Description = "Select the auto envelope bin."},
    DMBIN_ENVMANUAL = 0x0006
        with Documentation{Description = "Select the manual envelope bin."},
    DMBIN_AUTO = 0x0007
        with Documentation{Description = "Auto-select the bin."},
    DMBIN_TRACTOR = 0x0008
        with Documentation{Description = "Select the bin with the tractor paper."},
    DMBIN_SMALLFMT = 0x0009
        with Documentation{Description = "Select the bin with the smaller paper format."},
    DMBIN_LARGEFMT = 0x000A
        with Documentation{Description = "Select the bin with the larger paper format."},
    DMBIN_LARGECAPACITY = 0x000B
        with Documentation{Description = "Select the bin with large capacity."},
    DMBIN_CASSETTE = 0x000E
        with Documentation{Description = "Select the cassette bin."},
    DMBIN_FORMSOURCE = 0x000F
        with Documentation{Description = "Select the bin with the required form."},
    // 0x0100 or larger values indicate that the value is device-specific.
    ...
} with IDL{DoNotGenerate = true};

pattern DEVMODE_DmPrintQuality = enum ushort
{
    DMRES_HIGH = 0xFFFC
        with Documentation{Description = "High-resolution printouts."},
    DMRES_MEDIUM = 0xFFFD
        with Documentation{Description = "Medium-resolution printouts."},
    DMRES_LOW = 0xFFFE
        with Documentation{Description = "Low-resolution printouts."},
    DMRES_DRAFT = 0xFFFF
        with Documentation{Description = "Draft-resolution printouts."},
    ...
} with IDL{DoNotGenerate = true};

pattern DEVMODE_DmColor = enum ushort
{
    DMRES_MONOCHROME = 0x0001
        with Documentation{Description = "Use monochrome printing mode."},
    DMRES_COLOR = 0x0002
        with Documentation{Description = "Use color printing mode."},
    ...
} with IDL{DoNotGenerate = true};

pattern DEVMODE_DmDuplex = enum ushort
{
    DMDUP_SIMPLEX = 0x0001
        with Documentation{Description = "Normal (non-duplex) printing."},
    DMDUP_VERTICAL = 0x0002
        with Documentation{Description = "Long-edge binding; that is, the long edge of the page is vertical."},
    DMDUP_HORIZONTAL = 0x0003
        with Documentation{Description = "Short-edge binding; that is, the long edge of the page is horizontal."},
    ...
} with IDL{DoNotGenerate = true};

pattern DEVMODE_DmTTOption = enum ushort
{
    DMTT_BITMAP = 0x0001
        with Documentation{Description = "Prints TrueType fonts as graphics."},
    DMTT_DOWNLOAD = 0x0002
        with Documentation{Description = "Downloads TrueType fonts as soft fonts."},
    DMTT_SUBDEV = 0x0003
        with Documentation{Description = "Substitutes device fonts for TrueType fonts."},
    DMTT_DOWNLOAD_OUTLINE = 0x0004
        with Documentation{Description = "Downloads TrueType fonts as outline soft fonts."},
    ...
} with IDL{DoNotGenerate = true};

pattern DEVMODE_DmCollate = enum ushort
{
    DMCOLLATE_FALSE = 0x0000
        with Documentation{Description = "Do not collate when printing multiple copies."},
    DMCOLLATE_TRUE = 0x0001
        with Documentation{Description = "Collate when printing multiple copies."},
    ...
} with IDL{DoNotGenerate = true};

pattern DEVMODE_DmNup = enum ushort
{
    DMNUP_SYSTEM = 0x00000001
        with Documentation{Description = "The print server does the page layout."},
    DMNUP_ONEUP = 0x00000002
        with Documentation{Description = "The application does the page layout."},
    ...
} with IDL{DoNotGenerate = true};

pattern DEVMODE_DmICMMethod = enum ushort
{
    DMICMMETHOD_NONE = 0x00000001
        with Documentation{Description = "Specifies that ICM is disabled."},
    DMICMMETHOD_SYSTEM = 0x00000002
        with Documentation{Description = "Specifies that ICM is handled by the system on which the page description language (PDL) data is generated."},
    DMICMMETHOD_DRIVER = 0x00000003
        with Documentation{Description = "Specifies that ICM is handled by the printer driver."},
    DMICMMETHOD_DEVICE = 0x00000004
        with Documentation{Description = "Specifies that ICM is handled by the destination device."},
    ...
    // 0x00000100 or larger values indicate that the value is device-specific.
} with IDL{DoNotGenerate = true};

pattern DEVMODE_DmICMIntent = enum ushort
{
    DMICM_SATURATE = 0x00000001
        with Documentation{Description = "Color matching SHOULD be optimized for color saturation."},
    DMICM_CONTRAST = 0x00000002
        with Documentation{Description = "Color matching SHOULD be optimized for color contrast."},
    DMICM_COLORIMETRIC = 0x00000003
        with Documentation{Description = "Color matching SHOULD be optimized to match the exact color requested."},
    DMICM_ABS_COLORIMETRIC = 0x00000004
        with Documentation{Description = "Color matching SHOULD be optimized to match the exact color requested without white point mapping."},
    ...
    // 0x00000100 or larger values indicate that the value is device-specific.
} with IDL{DoNotGenerate = true};

pattern DEVMODE_DmMediaType = enum ushort
{
    DMMEDIA_STANDARD = 0x00000001
        with Documentation{Description = "Plain paper."},
    DMMEDIA_TRANSPARENCY = 0x00000002
        with Documentation{Description = "Transparent film."},
    DMMEDIA_GLOSSY = 0x00000003
        with Documentation{Description = "Glossy paper."},
    ...
    // 0x00000100 or larger values indicate that the value is device-specific.
} with IDL{DoNotGenerate = true};

pattern DEVMODE_DmDitherType = enum ushort
{
    DMDITHER_NONE = 0x00000001
        with Documentation{Description = "No dithering."},
    DMDITHER_COARSE = 0x00000002
        with Documentation{Description = "Dithering with a coarse brush."},
    DMDITHER_FINE = 0x00000003
        with Documentation{Description = "Dithering with a fine brush."},
    DMDITHER_LINEART = 0x00000004
        with Documentation{Description = "Line art dithering, a special dithering method that produces well defined borders between black, white, and gray scaling."},
    DMDITHER_ERRORDIFFUSION = 0x00000005
        with Documentation{Description = "Error diffusion dithering."},
    DMDITHER_RESERVED6 = 0x00000006
        with Documentation{Description = "Same as DMDITHER_LINEART."},
    DMDITHER_RESERVED7 = 0x00000007
        with Documentation{Description = "Same as DMDITHER_LINEART."},
    DMDITHER_RESERVED8 = 0x00000008
        with Documentation{Description = "Same as DMDITHER_LINEART."},
    DMDITHER_RESERVED9 = 0x00000009
        with Documentation{Description = "Same as DMDITHER_LINEART."},
    DMDITHER_GRAYSCALE = 0x0000000A
        with Documentation{Description = "Device does gray scaling."},
    ...
    // 0x00000100 or larger values indicate that the value is device-specific.
} with IDL{DoNotGenerate = true};

optional stream ConvertArrayWCHAR2Stream(array<WCHAR> arrayWCHAR)
{
    array<byte> result = [];
    foreach (WCHAR c in arrayWCHAR)
    {
        result += [c as byte, (c >> 8) as byte];
    }
    return (result as binary) as stream;
}

optional array<UnicodeString> UnicodeStringArrayDecoder(stream s)
{
    if (s.RemainingByteLength == 0)
        return nothing;
    
    array<UnicodeString> arrayUnicodeString = [];
    while (s.RemainingByteLength > 0)
    {
        var result = BinaryDecoder<UnicodeString>(s);
        if (result == nothing)
            break;
        if ((result as UnicodeString).Value == "")
            break;
        arrayUnicodeString += [result as UnicodeString];
    }
    return arrayUnicodeString;
}

optional T CustomInfoStrucutureDecoder<T>(stream dataStream, InfoStructLevel level, uint pcReturned)
{
    int i = 0;
    switch (level)
    {
        case InfoStructLevel._DRIVER_INFO_1 =>
        {
            var infoStructure = new _DRIVER_INFO_1{Fixed_Portion = [], Variable_Data = []};
            while (i < pcReturned)
            {
                var fixed_Portion = BinaryDecoder<_DRIVER_INFO_1_Fixed_Portion>(dataStream);
                if (fixed_Portion == nothing)
                {
                    ValidationCheck(false, null, DiagnosisLevel.Error,
                            Format(RPRN_FIXED_PORTION_DECODING_FAILURE, i.ToString(), "_DRIVER_INFO_1"));
                    break;
                }

                infoStructure.Fixed_Portion += [fixed_Portion as _DRIVER_INFO_1_Fixed_Portion];
                var variable_Data = 
                    BinaryDecoder<_DRIVER_INFO_1_Variable_Data[fixed_Portion as _DRIVER_INFO_1_Fixed_Portion]>(dataStream);
                if (variable_Data != nothing)
                    infoStructure.Variable_Data += [variable_Data as _DRIVER_INFO_1_Variable_Data];
                else
                    ValidationCheck(false, null, DiagnosisLevel.Error,
                            Format(RPRN_VARIABLE_DATA_DECODING_FAILURE, i.ToString(), "_DRIVER_INFO_1"));
                i++;
            }
            return infoStructure as T;
        }
        case InfoStructLevel._DRIVER_INFO_2 =>
        {
            var infoStructure = new _DRIVER_INFO_2{Fixed_Portion = [], Variable_Data = []};
            while (i < pcReturned)
            {
                var fixed_Portion = BinaryDecoder<_DRIVER_INFO_2_Fixed_Portion>(dataStream);
                if (fixed_Portion == nothing)
                {
                    ValidationCheck(false, null, DiagnosisLevel.Error,
                            Format(RPRN_FIXED_PORTION_DECODING_FAILURE, i.ToString(), "_DRIVER_INFO_2"));
                    break;
                }

                infoStructure.Fixed_Portion += [fixed_Portion as _DRIVER_INFO_2_Fixed_Portion];
                var variable_Data = 
                    BinaryDecoder<_DRIVER_INFO_2_Variable_Data[fixed_Portion as _DRIVER_INFO_2_Fixed_Portion]>(dataStream);
                if (variable_Data != nothing)
                    infoStructure.Variable_Data += [variable_Data as _DRIVER_INFO_2_Variable_Data];
                else
                    ValidationCheck(false, null, DiagnosisLevel.Error,
                            Format(RPRN_VARIABLE_DATA_DECODING_FAILURE, i.ToString(), "_DRIVER_INFO_2"));
                i++;
            }
            return infoStructure as T;
        }
        case InfoStructLevel._DRIVER_INFO_3 =>
        {
            var infoStructure = new _DRIVER_INFO_3{Fixed_Portion = [], Variable_Data = []};
            while (i < pcReturned)
            {
                var fixed_Portion = BinaryDecoder<_DRIVER_INFO_3_Fixed_Portion>(dataStream);
                if (fixed_Portion == nothing)
                {
                    ValidationCheck(false, null, DiagnosisLevel.Error,
                            Format(RPRN_FIXED_PORTION_DECODING_FAILURE, i.ToString(), "_DRIVER_INFO_3"));
                    break;
                }

                infoStructure.Fixed_Portion += [fixed_Portion as _DRIVER_INFO_3_Fixed_Portion];
                var variable_Data = 
                    BinaryDecoder<_DRIVER_INFO_3_Variable_Data[fixed_Portion as _DRIVER_INFO_3_Fixed_Portion]>(dataStream);
                if (variable_Data != nothing)
                    infoStructure.Variable_Data += [variable_Data as _DRIVER_INFO_3_Variable_Data];
                else
                    ValidationCheck(false, null, DiagnosisLevel.Error,
                            Format(RPRN_VARIABLE_DATA_DECODING_FAILURE, i.ToString(), "_DRIVER_INFO_3"));
                i++;
            }
            return infoStructure as T;
        }
        case InfoStructLevel._DRIVER_INFO_4 =>
        {
            var infoStructure = new _DRIVER_INFO_4{Fixed_Portion = [], Variable_Data = []};
            while (i < pcReturned)
            {
                var fixed_Portion = BinaryDecoder<_DRIVER_INFO_4_Fixed_Portion>(dataStream);
                if (fixed_Portion == nothing)
                {
                    ValidationCheck(false, null, DiagnosisLevel.Error,
                            Format(RPRN_FIXED_PORTION_DECODING_FAILURE, i.ToString(), "_DRIVER_INFO_4"));
                    break;
                }

                infoStructure.Fixed_Portion += [fixed_Portion as _DRIVER_INFO_4_Fixed_Portion];
                var variable_Data = 
                    BinaryDecoder<_DRIVER_INFO_4_Variable_Data[fixed_Portion as _DRIVER_INFO_4_Fixed_Portion]>(dataStream);
                if (variable_Data != nothing)
                    infoStructure.Variable_Data += [variable_Data as _DRIVER_INFO_4_Variable_Data];
                else
                    ValidationCheck(false, null, DiagnosisLevel.Error,
                            Format(RPRN_VARIABLE_DATA_DECODING_FAILURE, i.ToString(), "_DRIVER_INFO_4"));
                i++;
            }
            return infoStructure as T;
        }
        case InfoStructLevel._DRIVER_INFO_5 =>
        {
            var infoStructure = new _DRIVER_INFO_5{Fixed_Portion = [], Variable_Data = []};
            while (i < pcReturned)
            {
                var fixed_Portion = BinaryDecoder<_DRIVER_INFO_5_Fixed_Portion>(dataStream);
                if (fixed_Portion == nothing)
                {
                    ValidationCheck(false, null, DiagnosisLevel.Error,
                            Format(RPRN_FIXED_PORTION_DECODING_FAILURE, i.ToString(), "_DRIVER_INFO_5"));
                    break;
                }

                infoStructure.Fixed_Portion += [fixed_Portion as _DRIVER_INFO_5_Fixed_Portion];
                var variable_Data = 
                    BinaryDecoder<_DRIVER_INFO_5_Variable_Data[fixed_Portion as _DRIVER_INFO_5_Fixed_Portion]>(dataStream);
                if (variable_Data != nothing)
                    infoStructure.Variable_Data += [variable_Data as _DRIVER_INFO_5_Variable_Data];
                else
                    ValidationCheck(false, null, DiagnosisLevel.Error,
                            Format(RPRN_VARIABLE_DATA_DECODING_FAILURE, i.ToString(), "_DRIVER_INFO_5"));
                i++;
            }
            return infoStructure as T;
        }
        case InfoStructLevel._DRIVER_INFO_6 =>
        {
            var infoStructure = new _DRIVER_INFO_6{Fixed_Portion = [], Variable_Data = []};
            while (i < pcReturned)
            {
                var fixed_Portion = BinaryDecoder<_DRIVER_INFO_6_Fixed_Portion>(dataStream);
                if (fixed_Portion == nothing)
                {
                    ValidationCheck(false, null, DiagnosisLevel.Error, 
                            Format(RPRN_FIXED_PORTION_DECODING_FAILURE, i.ToString(), "_DRIVER_INFO_6"));
                    break;
                }

                infoStructure.Fixed_Portion += [fixed_Portion as _DRIVER_INFO_6_Fixed_Portion];
                var variable_Data = 
                    BinaryDecoder<_DRIVER_INFO_6_Variable_Data[fixed_Portion as _DRIVER_INFO_6_Fixed_Portion]>(dataStream);
                if (variable_Data != nothing)
                    infoStructure.Variable_Data += [variable_Data as _DRIVER_INFO_6_Variable_Data];
                else
                    ValidationCheck(false, null, DiagnosisLevel.Error,
                            Format(RPRN_VARIABLE_DATA_DECODING_FAILURE, i.ToString(), "_DRIVER_INFO_6"));
                i++;
            }
            return infoStructure as T;
        }
        case InfoStructLevel._DRIVER_INFO_7 =>
        {
            var infoStructure = new _DRIVER_INFO_7{Fixed_Portion = [], Variable_Data = []};
            while (i < pcReturned)
            {
                var fixed_Portion = BinaryDecoder<_DRIVER_INFO_7_Fixed_Portion>(dataStream);
                if (fixed_Portion == nothing)
                {
                    ValidationCheck(false, null, DiagnosisLevel.Error,
                            Format(RPRN_FIXED_PORTION_DECODING_FAILURE, i.ToString(), "_DRIVER_INFO_7"));
                    break;
                }

                infoStructure.Fixed_Portion += [fixed_Portion as _DRIVER_INFO_7_Fixed_Portion];
                var variable_Data = 
                    BinaryDecoder<_DRIVER_INFO_7_Variable_Data[fixed_Portion as _DRIVER_INFO_7_Fixed_Portion]>(dataStream);
                if (variable_Data != nothing)
                    infoStructure.Variable_Data += [variable_Data as _DRIVER_INFO_7_Variable_Data];
                else
                    ValidationCheck(false, null, DiagnosisLevel.Error,
                            Format(RPRN_VARIABLE_DATA_DECODING_FAILURE, i.ToString(), "_DRIVER_INFO_7"));
                i++;
            }
            return infoStructure as T;
        }
        case InfoStructLevel._DRIVER_INFO_8 =>
        {
            var infoStructure = new _DRIVER_INFO_8{Fixed_Portion = [], Variable_Data = []};
            while (i < pcReturned)
            {
                var fixed_Portion = BinaryDecoder<_DRIVER_INFO_8_Fixed_Portion>(dataStream);
                if (fixed_Portion == nothing)
                {
                    ValidationCheck(false, null, DiagnosisLevel.Error,
                            Format(RPRN_FIXED_PORTION_DECODING_FAILURE, i.ToString(), "_DRIVER_INFO_8"));
                    break;
                }

                infoStructure.Fixed_Portion += [fixed_Portion as _DRIVER_INFO_8_Fixed_Portion];
                var variable_Data = 
                    BinaryDecoder<_DRIVER_INFO_8_Variable_Data[fixed_Portion as _DRIVER_INFO_8_Fixed_Portion]>(dataStream);
                if (variable_Data != nothing)
                    infoStructure.Variable_Data += [variable_Data as _DRIVER_INFO_8_Variable_Data];
                else
                    ValidationCheck(false, null, DiagnosisLevel.Error,
                            Format(RPRN_VARIABLE_DATA_DECODING_FAILURE, i.ToString(), "_DRIVER_INFO_8"));
                i++;
            }
            return infoStructure as T;
        }
        case InfoStructLevel._DRIVER_INFO_101 =>
        {
            var infoStructure = new _DRIVER_INFO_101{Fixed_Portion = [], Variable_Data = []};
            while (i < pcReturned)
            {
                var fixed_Portion = BinaryDecoder<_DRIVER_INFO_101_Fixed_Portion>(dataStream);
                if (fixed_Portion == nothing)
                {
                    ValidationCheck(false, null, DiagnosisLevel.Error,
                            Format(RPRN_FIXED_PORTION_DECODING_FAILURE, i.ToString(), "_DRIVER_INFO_101"));
                    break;
                }

                infoStructure.Fixed_Portion += [fixed_Portion as _DRIVER_INFO_101_Fixed_Portion];
                var variable_Data = 
                    BinaryDecoder<_DRIVER_INFO_101_Variable_Data[fixed_Portion as _DRIVER_INFO_101_Fixed_Portion]>(dataStream);
                if (variable_Data != nothing)
                    infoStructure.Variable_Data += [variable_Data as _DRIVER_INFO_101_Variable_Data];
                else
                    ValidationCheck(false, null, DiagnosisLevel.Error,
                            Format(RPRN_VARIABLE_DATA_DECODING_FAILURE, i.ToString(), "_DRIVER_INFO_101"));
                i++;
            }
            return infoStructure as T;
        }
        case InfoStructLevel._DRIVER_FILE_INFO =>
        {
            var infoStructure = new _DRIVER_FILE_INFO{Fixed_Portion = [], Variable_Data = []};
            while (i < pcReturned)
            {
                var fixed_Portion = BinaryDecoder<_DRIVER_FILE_INFO_Fixed_Portion>(dataStream);
                if (fixed_Portion == nothing)
                {
                    ValidationCheck(false, null, DiagnosisLevel.Error,
                            Format(RPRN_FIXED_PORTION_DECODING_FAILURE, i.ToString(), "_DRIVER_FILE_INFO"));
                    break;
                }

                infoStructure.Fixed_Portion += [fixed_Portion as _DRIVER_FILE_INFO_Fixed_Portion];
                var variable_Data = 
                    BinaryDecoder<_DRIVER_FILE_INFO_Variable_Data[fixed_Portion as _DRIVER_FILE_INFO_Fixed_Portion]>(dataStream);
                if (variable_Data != nothing)
                    infoStructure.Variable_Data += [variable_Data as _DRIVER_FILE_INFO_Variable_Data];
                else
                    ValidationCheck(false, null, DiagnosisLevel.Error,
                            Format(RPRN_VARIABLE_DATA_DECODING_FAILURE, i.ToString(), "_DRIVER_FILE_INFO"));
                i++;
            }
            return infoStructure as T;
        }
        case InfoStructLevel._FORM_INFO_1 =>
        {
            var infoStructure = new _FORM_INFO_1{Fixed_Portion = [], Variable_Data = []};
            while (i < pcReturned)
            {
                var fixed_Portion = BinaryDecoder<_FORM_INFO_1_Fixed_Portion>(dataStream);
                if (fixed_Portion == nothing)
                {
                    ValidationCheck(false, null, DiagnosisLevel.Error,
                            Format(RPRN_FIXED_PORTION_DECODING_FAILURE, i.ToString(), "_FORM_INFO_1"));
                    break;
                }

                infoStructure.Fixed_Portion += [fixed_Portion as _FORM_INFO_1_Fixed_Portion];
                var variable_Data = 
                    BinaryDecoder<_FORM_INFO_1_Variable_Data[fixed_Portion as _FORM_INFO_1_Fixed_Portion]>(dataStream);
                if (variable_Data != nothing)
                    infoStructure.Variable_Data += [variable_Data as _FORM_INFO_1_Variable_Data];
                else
                    ValidationCheck(false, null, DiagnosisLevel.Error,
                            Format(RPRN_VARIABLE_DATA_DECODING_FAILURE, i.ToString(), "_FORM_INFO_1"));
                i++;
            }
            return infoStructure as T;
        }
        case InfoStructLevel._FORM_INFO_2 =>
        {
            var infoStructure = new _FORM_INFO_2{Fixed_Portion = [], Variable_Data = []};
            while (i < pcReturned)
            {
                var fixed_Portion = BinaryDecoder<_FORM_INFO_2_Fixed_Portion>(dataStream);
                if (fixed_Portion == nothing)
                {
                    ValidationCheck(false, null, DiagnosisLevel.Error,
                            Format(RPRN_FIXED_PORTION_DECODING_FAILURE, i.ToString(), "_FORM_INFO_2"));
                    break;
                }

                infoStructure.Fixed_Portion += [fixed_Portion as _FORM_INFO_2_Fixed_Portion];
                var variable_Data = 
                    BinaryDecoder<_FORM_INFO_2_Variable_Data[fixed_Portion as _FORM_INFO_2_Fixed_Portion]>(dataStream);
                if (variable_Data != nothing)
                    infoStructure.Variable_Data += [variable_Data as _FORM_INFO_2_Variable_Data];
                else
                    ValidationCheck(false, null, DiagnosisLevel.Error,
                            Format(RPRN_VARIABLE_DATA_DECODING_FAILURE, i.ToString(), "_FORM_INFO_2"));
                i++;
            }
            return infoStructure as T;
        }
        case InfoStructLevel._JOB_INFO_1 =>
        {
            var infoStructure = new _JOB_INFO_1{Fixed_Portion = [], Variable_Data = []};
            while (i < pcReturned)
            {
                var fixed_Portion = BinaryDecoder<_JOB_INFO_1_Fixed_Portion>(dataStream);
                if (fixed_Portion == nothing)
                {
                    ValidationCheck(false, null, DiagnosisLevel.Error,
                            Format(RPRN_FIXED_PORTION_DECODING_FAILURE, i.ToString(), "_JOB_INFO_1"));
                    break;
                }

                infoStructure.Fixed_Portion += [fixed_Portion as _JOB_INFO_1_Fixed_Portion];
                var variable_Data = 
                    BinaryDecoder<_JOB_INFO_1_Variable_Data[fixed_Portion as _JOB_INFO_1_Fixed_Portion]>(dataStream);
                if (variable_Data != nothing)
                    infoStructure.Variable_Data += [variable_Data as _JOB_INFO_1_Variable_Data];
                else
                    ValidationCheck(false, null, DiagnosisLevel.Error,
                            Format(RPRN_VARIABLE_DATA_DECODING_FAILURE, i.ToString(), "_JOB_INFO_1"));
                i++;
            }
            return infoStructure as T;
        }
        case InfoStructLevel._JOB_INFO_2 =>
        {
            var infoStructure = new _JOB_INFO_2{Fixed_Portion = [], Variable_Data = []};
            while (i < pcReturned)
            {
                var fixed_Portion = BinaryDecoder<_JOB_INFO_2_Fixed_Portion>(dataStream);
                if (fixed_Portion == nothing)
                {
                    ValidationCheck(false, null, DiagnosisLevel.Error,
                            Format(RPRN_FIXED_PORTION_DECODING_FAILURE, i.ToString(), "_JOB_INFO_2"));
                    break;
                }

                infoStructure.Fixed_Portion += [fixed_Portion as _JOB_INFO_2_Fixed_Portion];
                var variable_Data = 
                    BinaryDecoder<_JOB_INFO_2_Variable_Data[fixed_Portion as _JOB_INFO_2_Fixed_Portion]>(dataStream);
                if (variable_Data != nothing)
                    infoStructure.Variable_Data += [variable_Data as _JOB_INFO_2_Variable_Data];
                else
                    ValidationCheck(false, null, DiagnosisLevel.Error,
                            Format(RPRN_VARIABLE_DATA_DECODING_FAILURE, i.ToString(), "_JOB_INFO_2"));
                i++;
            }
            return infoStructure as T;
        }
        case InfoStructLevel._JOB_INFO_3 => // No variable data block
        {
            var infoStructure = new _JOB_INFO_3{Fixed_Portion = []};
            while (i < pcReturned)
            {
                var fixed_Portion = BinaryDecoder<_JOB_INFO_3_Fixed_Portion>(dataStream);
                if (fixed_Portion == nothing)
                {
                    ValidationCheck(false, null, DiagnosisLevel.Error,
                            Format(RPRN_FIXED_PORTION_DECODING_FAILURE, i.ToString(), "_JOB_INFO_3"));
                    break;
                }

                infoStructure.Fixed_Portion += [fixed_Portion as _JOB_INFO_3_Fixed_Portion];
                i++;
            }
            return infoStructure as T;
        }
        case InfoStructLevel._JOB_INFO_4 =>
        {
            var infoStructure = new _JOB_INFO_4{Fixed_Portion = [], Variable_Data = []};
            while (i < pcReturned)
            {
                var fixed_Portion = BinaryDecoder<_JOB_INFO_4_Fixed_Portion>(dataStream);
                if (fixed_Portion == nothing)
                {
                    ValidationCheck(false, null, DiagnosisLevel.Error,
                            Format(RPRN_FIXED_PORTION_DECODING_FAILURE, i.ToString(), "_JOB_INFO_4"));
                    break;
                }

                infoStructure.Fixed_Portion += [fixed_Portion as _JOB_INFO_4_Fixed_Portion];
                var variable_Data = 
                    BinaryDecoder<_JOB_INFO_4_Variable_Data[fixed_Portion as _JOB_INFO_4_Fixed_Portion]>(dataStream);
                if (variable_Data != nothing)
                    infoStructure.Variable_Data += [variable_Data as _JOB_INFO_4_Variable_Data];
                else
                    ValidationCheck(false, null, DiagnosisLevel.Error,
                            Format(RPRN_VARIABLE_DATA_DECODING_FAILURE, i.ToString(), "_JOB_INFO_4"));
                i++;
            }
            return infoStructure as T;
        }
        case InfoStructLevel._MONITOR_INFO_1 =>
        {
            var infoStructure = new _MONITOR_INFO_1{Fixed_Portion = [], Variable_Data = []};
            while (i < pcReturned)
            {
                var fixed_Portion = BinaryDecoder<_MONITOR_INFO_1_Fixed_Portion>(dataStream);
                if (fixed_Portion == nothing)
                {
                    ValidationCheck(false, null, DiagnosisLevel.Error,
                            Format(RPRN_FIXED_PORTION_DECODING_FAILURE, i.ToString(), "_MONITOR_INFO_1"));
                    break;
                }

                infoStructure.Fixed_Portion += [fixed_Portion as _MONITOR_INFO_1_Fixed_Portion];
                var variable_Data = 
                    BinaryDecoder<_MONITOR_INFO_1_Variable_Data[fixed_Portion as _MONITOR_INFO_1_Fixed_Portion]>(dataStream);
                if (variable_Data != nothing)
                    infoStructure.Variable_Data += [variable_Data as _MONITOR_INFO_1_Variable_Data];
                else
                    ValidationCheck(false, null, DiagnosisLevel.Error,
                            Format(RPRN_VARIABLE_DATA_DECODING_FAILURE, i.ToString(), "_MONITOR_INFO_1"));
                i++;
            }
            return infoStructure as T;
        }
        case InfoStructLevel._MONITOR_INFO_2 =>
        {
            var infoStructure = new _MONITOR_INFO_2{Fixed_Portion = [], Variable_Data = []};
            while (i < pcReturned)
            {
                var fixed_Portion = BinaryDecoder<_MONITOR_INFO_2_Fixed_Portion>(dataStream);
                if (fixed_Portion == nothing)
                {
                    ValidationCheck(false, null, DiagnosisLevel.Error,
                            Format(RPRN_FIXED_PORTION_DECODING_FAILURE, i.ToString(), "_MONITOR_INFO_2"));
                    break;
                }

                infoStructure.Fixed_Portion += [fixed_Portion as _MONITOR_INFO_2_Fixed_Portion];
                var variable_Data = 
                    BinaryDecoder<_MONITOR_INFO_2_Variable_Data[fixed_Portion as _MONITOR_INFO_2_Fixed_Portion]>(dataStream);
                if (variable_Data != nothing)
                    infoStructure.Variable_Data += [variable_Data as _MONITOR_INFO_2_Variable_Data];
                else
                    ValidationCheck(false, null, DiagnosisLevel.Error,
                            Format(RPRN_VARIABLE_DATA_DECODING_FAILURE, i.ToString(), "_MONITOR_INFO_2"));
                i++;
            }
            return infoStructure as T;
        }
        case InfoStructLevel._PORT_INFO_1 =>
        {
            var infoStructure = new _PORT_INFO_1{Fixed_Portion = [], Variable_Data = []};
            while (i < pcReturned)
            {
                var fixed_Portion = BinaryDecoder<_PORT_INFO_1_Fixed_Portion>(dataStream);
                if (fixed_Portion == nothing)
                {
                    ValidationCheck(false, null, DiagnosisLevel.Error,
                            Format(RPRN_FIXED_PORTION_DECODING_FAILURE, i.ToString(), "_PORT_INFO_1"));
                    break;
                }

                infoStructure.Fixed_Portion += [fixed_Portion as _PORT_INFO_1_Fixed_Portion];
                var variable_Data = 
                    BinaryDecoder<_PORT_INFO_1_Variable_Data[fixed_Portion as _PORT_INFO_1_Fixed_Portion]>(dataStream);
                if (variable_Data != nothing)
                    infoStructure.Variable_Data += [variable_Data as _PORT_INFO_1_Variable_Data];
                else
                    ValidationCheck(false, null, DiagnosisLevel.Error,
                            Format(RPRN_VARIABLE_DATA_DECODING_FAILURE, i.ToString(), "_PORT_INFO_1"));
                i++;
            }
            return infoStructure as T;
        }
        case InfoStructLevel._PORT_INFO_2 =>
        {
            var infoStructure = new _PORT_INFO_2{Fixed_Portion = [], Variable_Data = []};
            while (i < pcReturned)
            {
                var fixed_Portion = BinaryDecoder<_PORT_INFO_2_Fixed_Portion>(dataStream);
                if (fixed_Portion == nothing)
                {
                    ValidationCheck(false, null, DiagnosisLevel.Error,
                            Format(RPRN_FIXED_PORTION_DECODING_FAILURE, i.ToString(), "_PORT_INFO_2"));
                    break;
                }

                infoStructure.Fixed_Portion += [fixed_Portion as _PORT_INFO_2_Fixed_Portion];
                var variable_Data = 
                    BinaryDecoder<_PORT_INFO_2_Variable_Data[fixed_Portion as _PORT_INFO_2_Fixed_Portion]>(dataStream);
                if (variable_Data != nothing)
                    infoStructure.Variable_Data += [variable_Data as _PORT_INFO_2_Variable_Data];
                else
                    ValidationCheck(false, null, DiagnosisLevel.Error,
                            Format(RPRN_VARIABLE_DATA_DECODING_FAILURE, i.ToString(), "_PORT_INFO_2"));
                i++;
            }
            return infoStructure as T;
        }
        case InfoStructLevel._PRINTER_INFO_STRESS =>
        {
            var infoStructure = new _PRINTER_INFO_STRESS{Fixed_Portion = [], Variable_Data = []};
            while (i < pcReturned)
            {
                var fixed_Portion = BinaryDecoder<_PRINTER_INFO_STRESS_Fixed_Portion>(dataStream);
                if (fixed_Portion == nothing)
                {
                    ValidationCheck(false, null, DiagnosisLevel.Error,
                            Format(RPRN_FIXED_PORTION_DECODING_FAILURE, i.ToString(), "_PRINTER_INFO_STRESS"));
                    break;
                }

                infoStructure.Fixed_Portion += [fixed_Portion as _PRINTER_INFO_STRESS_Fixed_Portion];
                var variable_Data = 
                    BinaryDecoder<_PRINTER_INFO_STRESS_Variable_Data[fixed_Portion as _PRINTER_INFO_STRESS_Fixed_Portion]>(dataStream);
                if (variable_Data != nothing)
                    infoStructure.Variable_Data += [variable_Data as _PRINTER_INFO_STRESS_Variable_Data];
                else
                    ValidationCheck(false, null, DiagnosisLevel.Error,
                            Format(RPRN_VARIABLE_DATA_DECODING_FAILURE, i.ToString(), "_PRINTER_INFO_STRESS"));
                i++;
            }
            return infoStructure as T;
        }
        case InfoStructLevel._PRINTER_INFO_1 =>
        {
            var infoStructure = new _PRINTER_INFO_1{Fixed_Portion = [], Variable_Data = []};
            while (i < pcReturned)
            {
                var fixed_Portion = BinaryDecoder<_PRINTER_INFO_1_Fixed_Portion>(dataStream);
                if (fixed_Portion == nothing)
                {
                    ValidationCheck(false, null, DiagnosisLevel.Error,
                            Format(RPRN_FIXED_PORTION_DECODING_FAILURE, i.ToString(), "_PRINTER_INFO_1"));
                    break;
                }

                infoStructure.Fixed_Portion += [fixed_Portion as _PRINTER_INFO_1_Fixed_Portion];
                var variable_Data = 
                    BinaryDecoder<_PRINTER_INFO_1_Variable_Data[fixed_Portion as _PRINTER_INFO_1_Fixed_Portion]>(dataStream);
                if (variable_Data != nothing)
                    infoStructure.Variable_Data += [variable_Data as _PRINTER_INFO_1_Variable_Data];
                else
                    ValidationCheck(false, null, DiagnosisLevel.Error,
                            Format(RPRN_VARIABLE_DATA_DECODING_FAILURE, i.ToString(), "_PRINTER_INFO_1"));
                i++;
            }
            return infoStructure as T;
        }
        case InfoStructLevel._PRINTER_INFO_2 =>
        {
            var infoStructure = new _PRINTER_INFO_2{Fixed_Portion = [], Variable_Data = []};
            while (i < pcReturned)
            {
                var fixed_Portion = BinaryDecoder<_PRINTER_INFO_2_Fixed_Portion>(dataStream);
                if (fixed_Portion == nothing)
                {
                    ValidationCheck(false, null, DiagnosisLevel.Error,
                            Format(RPRN_FIXED_PORTION_DECODING_FAILURE, i.ToString(), "_PRINTER_INFO_2"));
                    break;
                }

                infoStructure.Fixed_Portion += [fixed_Portion as _PRINTER_INFO_2_Fixed_Portion];
                var variable_Data = 
                    BinaryDecoder<_PRINTER_INFO_2_Variable_Data[fixed_Portion as _PRINTER_INFO_2_Fixed_Portion]>(dataStream);
                if (variable_Data != nothing)
                    infoStructure.Variable_Data += [variable_Data as _PRINTER_INFO_2_Variable_Data];
                else
                    ValidationCheck(false, null, DiagnosisLevel.Error,
                            Format(RPRN_VARIABLE_DATA_DECODING_FAILURE, i.ToString(), "_PRINTER_INFO_2"));
                i++;
            }
            return infoStructure as T;
        }
        case InfoStructLevel._PRINTER_INFO_3 =>
        {
            var infoStructure = new _PRINTER_INFO_3{Fixed_Portion = [], Variable_Data = []};
            while (i < pcReturned)
            {
                var fixed_Portion = BinaryDecoder<_PRINTER_INFO_3_Fixed_Portion>(dataStream);
                if (fixed_Portion == nothing)
                {
                    ValidationCheck(false, null, DiagnosisLevel.Error,
                            Format(RPRN_FIXED_PORTION_DECODING_FAILURE, i.ToString(), "_PRINTER_INFO_3"));
                    break;
                }

                infoStructure.Fixed_Portion += [fixed_Portion as _PRINTER_INFO_3_Fixed_Portion];
                var variable_Data = 
                    BinaryDecoder<_PRINTER_INFO_3_Variable_Data[fixed_Portion as _PRINTER_INFO_3_Fixed_Portion]>(dataStream);
                if (variable_Data != nothing)
                    infoStructure.Variable_Data += [variable_Data as _PRINTER_INFO_3_Variable_Data];
                else
                    ValidationCheck(false, null, DiagnosisLevel.Error,
                            Format(RPRN_VARIABLE_DATA_DECODING_FAILURE, i.ToString(), "_PRINTER_INFO_3"));
                i++;
            }
            return infoStructure as T;
        }
        case InfoStructLevel._PRINTER_INFO_4 =>
        {
            var infoStructure = new _PRINTER_INFO_4{Fixed_Portion = [], Variable_Data = []};
            while (i < pcReturned)
            {
                var fixed_Portion = BinaryDecoder<_PRINTER_INFO_4_Fixed_Portion>(dataStream);
                if (fixed_Portion == nothing)
                {
                    ValidationCheck(false, null, DiagnosisLevel.Error,
                            Format(RPRN_FIXED_PORTION_DECODING_FAILURE, i.ToString(), "_PRINTER_INFO_4"));
                    break;
                }

                infoStructure.Fixed_Portion += [fixed_Portion as _PRINTER_INFO_4_Fixed_Portion];
                var variable_Data = 
                    BinaryDecoder<_PRINTER_INFO_4_Variable_Data[fixed_Portion as _PRINTER_INFO_4_Fixed_Portion]>(dataStream);
                if (variable_Data != nothing)
                    infoStructure.Variable_Data += [variable_Data as _PRINTER_INFO_4_Variable_Data];
                else
                    ValidationCheck(false, null, DiagnosisLevel.Error,
                            Format(RPRN_VARIABLE_DATA_DECODING_FAILURE, i.ToString(), "_PRINTER_INFO_4"));
                i++;
            }
            return infoStructure as T;
        }
        case InfoStructLevel._PRINTER_INFO_5 =>
        {
            var infoStructure = new _PRINTER_INFO_5{Fixed_Portion = [], Variable_Data = []};
            while (i < pcReturned)
            {
                var fixed_Portion = BinaryDecoder<_PRINTER_INFO_5_Fixed_Portion>(dataStream);
                if (fixed_Portion == nothing)
                {
                    ValidationCheck(false, null, DiagnosisLevel.Error,
                            Format(RPRN_FIXED_PORTION_DECODING_FAILURE, i.ToString(), "_PRINTER_INFO_5"));
                    break;
                }

                infoStructure.Fixed_Portion += [fixed_Portion as _PRINTER_INFO_5_Fixed_Portion];
                var variable_Data = 
                    BinaryDecoder<_PRINTER_INFO_5_Variable_Data[fixed_Portion as _PRINTER_INFO_5_Fixed_Portion]>(dataStream);
                if (variable_Data != nothing)
                    infoStructure.Variable_Data += [variable_Data as _PRINTER_INFO_5_Variable_Data];
                else
                    ValidationCheck(false, null, DiagnosisLevel.Error,
                            Format(RPRN_VARIABLE_DATA_DECODING_FAILURE, i.ToString(), "_PRINTER_INFO_5"));
                i++;
            }
            return infoStructure as T;
        }
        case InfoStructLevel._PRINTER_INFO_6 => // No variable data
        {
            var infoStructure = new _PRINTER_INFO_6{Fixed_Portion = []};
            while (i < pcReturned)
            {
                var fixed_Portion = BinaryDecoder<_PRINTER_INFO_6_Fixed_Portion>(dataStream);
                if (fixed_Portion == nothing)
                {
                    ValidationCheck(false, null, DiagnosisLevel.Error,
                            Format(RPRN_FIXED_PORTION_DECODING_FAILURE, i.ToString(), "_PRINTER_INFO_6"));
                    break;
                }

                infoStructure.Fixed_Portion += [fixed_Portion as _PRINTER_INFO_6_Fixed_Portion];
                i++;
            }
            return infoStructure as T;
        }
        case InfoStructLevel._PRINTER_INFO_7 =>
        {
            var infoStructure = new _PRINTER_INFO_7{Fixed_Portion = [], Variable_Data = []};
            while (i < pcReturned)
            {
                var fixed_Portion = BinaryDecoder<_PRINTER_INFO_7_Fixed_Portion>(dataStream);
                if (fixed_Portion == nothing)
                {
                    ValidationCheck(false, null, DiagnosisLevel.Error,
                            Format(RPRN_FIXED_PORTION_DECODING_FAILURE, i.ToString(), "_PRINTER_INFO_7"));
                    break;
                }

                infoStructure.Fixed_Portion += [fixed_Portion as _PRINTER_INFO_7_Fixed_Portion];
                var variable_Data = 
                    BinaryDecoder<_PRINTER_INFO_7_Variable_Data[fixed_Portion as _PRINTER_INFO_7_Fixed_Portion]>(dataStream);
                if (variable_Data != nothing)
                    infoStructure.Variable_Data += [variable_Data as _PRINTER_INFO_7_Variable_Data];
                else
                    ValidationCheck(false, null, DiagnosisLevel.Error,
                            Format(RPRN_VARIABLE_DATA_DECODING_FAILURE, i.ToString(), "_PRINTER_INFO_7"));
                i++;
            }
            return infoStructure as T;
        }
        case InfoStructLevel._PRINTER_INFO_8 =>
        {
            var infoStructure = new _PRINTER_INFO_8{Fixed_Portion = [], Variable_Data = []};
            while (i < pcReturned)
            {
                var fixed_Portion = BinaryDecoder<_PRINTER_INFO_8_Fixed_Portion>(dataStream);
                if (fixed_Portion == nothing)
                {
                    ValidationCheck(false, null, DiagnosisLevel.Error,
                            Format(RPRN_FIXED_PORTION_DECODING_FAILURE, i.ToString(), "_PRINTER_INFO_8"));
                    break;
                }

                infoStructure.Fixed_Portion += [fixed_Portion as _PRINTER_INFO_8_Fixed_Portion];
                var variable_Data = 
                    BinaryDecoder<_PRINTER_INFO_8_Variable_Data[fixed_Portion as _PRINTER_INFO_8_Fixed_Portion]>(dataStream);
                if (variable_Data != nothing)
                    infoStructure.Variable_Data += [variable_Data as _PRINTER_INFO_8_Variable_Data];
                else
                    ValidationCheck(false, null, DiagnosisLevel.Error,
                            Format(RPRN_VARIABLE_DATA_DECODING_FAILURE, i.ToString(), "_PRINTER_INFO_8"));

                i++;
            }
            return infoStructure as T;
        }
        case InfoStructLevel.PRINTPROCESSOR_INFO_1 =>
        {
            var infoStructure = new PRINTPROCESSOR_INFO_1{Fixed_Portion = [], Variable_Data = []};
            while (i < pcReturned)
            {
                var fixed_Portion = BinaryDecoder<PRINTPROCESSOR_INFO_1_Fixed_Portion>(dataStream);
                if (fixed_Portion == nothing)
                {
                    ValidationCheck(false, null, DiagnosisLevel.Error,
                            Format(RPRN_FIXED_PORTION_DECODING_FAILURE, i.ToString(), "PRINTPROCESSOR_INFO_1"));
                    break;
                }

                infoStructure.Fixed_Portion += [fixed_Portion as PRINTPROCESSOR_INFO_1_Fixed_Portion];
                var variable_Data = 
                    BinaryDecoder<PRINTPROCESSOR_INFO_1_Variable_Data[fixed_Portion as PRINTPROCESSOR_INFO_1_Fixed_Portion]>(dataStream);
                if (variable_Data != nothing)
                    infoStructure.Variable_Data += [variable_Data as PRINTPROCESSOR_INFO_1_Variable_Data];
                else
                    ValidationCheck(false, null, DiagnosisLevel.Error,
                            Format(RPRN_VARIABLE_DATA_DECODING_FAILURE, i.ToString(), "PRINTPROCESSOR_INFO_1"));
                i++;
            }
            return infoStructure as T;
        }
        case InfoStructLevel._DATATYPES_INFO_1 =>
        {
            var infoStructure = new _DATATYPES_INFO_1{Fixed_Portion = [], Variable_Data = []};
            while (i < pcReturned)
            {
                var fixed_Portion = BinaryDecoder<_DATATYPES_INFO_1_Fixed_Portion>(dataStream);
                if (fixed_Portion == nothing)
                {
                    ValidationCheck(false, null, DiagnosisLevel.Error,
                            Format(RPRN_FIXED_PORTION_DECODING_FAILURE, i.ToString(), "_DATATYPES_INFO_1"));
                    break;
                }

                infoStructure.Fixed_Portion += [fixed_Portion as _DATATYPES_INFO_1_Fixed_Portion];
                var variable_Data = 
                    BinaryDecoder<_DATATYPES_INFO_1_Variable_Data[fixed_Portion as _DATATYPES_INFO_1_Fixed_Portion]>(dataStream);
                if (variable_Data != nothing)
                    infoStructure.Variable_Data += [variable_Data as _DATATYPES_INFO_1_Variable_Data];
                else
                    ValidationCheck(false, null, DiagnosisLevel.Error,
                            Format(RPRN_VARIABLE_DATA_DECODING_FAILURE, i.ToString(), "_DATATYPES_INFO_1"));
                
                i++;
            }
            return infoStructure as T;
        }
        case InfoStructLevel.PRINTER_ENUM_VALUES =>
        {
            var infoStructure = new PRINTER_ENUM_VALUES{Fixed_Portion = [], Variable_Data = []};
            while (i < pcReturned)
            {
                var fixed_Portion = BinaryDecoder<PRINTER_ENUM_VALUES_Fixed_Portion>(dataStream);
                if (fixed_Portion == nothing)
                {
                    ValidationCheck(false, null, DiagnosisLevel.Error,
                            Format(RPRN_FIXED_PORTION_DECODING_FAILURE, i.ToString(), "PRINTER_ENUM_VALUES"));
                    break;
                }

                infoStructure.Fixed_Portion += [fixed_Portion as PRINTER_ENUM_VALUES_Fixed_Portion];
                var variable_Data = 
                    BinaryDecoder<PRINTER_ENUM_VALUES_Variable_Data[fixed_Portion as PRINTER_ENUM_VALUES_Fixed_Portion]>(dataStream);
                if (variable_Data != nothing)
                    infoStructure.Variable_Data += [variable_Data as PRINTER_ENUM_VALUES_Variable_Data];
                else
                    ValidationCheck(false, null, DiagnosisLevel.Error,
                            Format(RPRN_VARIABLE_DATA_DECODING_FAILURE, i.ToString(), "PRINTER_ENUM_VALUES"));
                i++;
            }
            return infoStructure as T;
        }
        default => return nothing;
    }
}

type ArrayByte
{
    array<byte> Array with Technologies.IDL.IDL{Size_is = [0]};
} with IDL{Ignore = true};

// 3.1.4.1.7 String Query Parameters
// 2.2.3.9 Registry Type Values
// TD defines pcReturned field, but in RPRN it's never used.
optional array<string> StringQueryDecoder(stream streamData)
{
    array<string> parameters = [];
    while (streamData.RemainingByteLength > 2 && 
           !(streamData.PeekBytes(streamData.BitPosition, 2) in [$[0000], $[FFFF]]))
    {
        var result = BinaryDecoder<UnicodeString>(streamData);
        if (result == nothing)
            break;

        string s = (result as UnicodeString).Value;
        if (s != "")
            parameters += [s];
    }
    if (parameters != [])
        return parameters;
    return nothing;
}

 type UnicodeString
 {
    string Value with BinaryEncoding{TextEncoding = TextEncoding.Unicode};
 }

type DynamicallyTypedQuery[RegistryTypeValues Type]
 {
    optional any Data with Encoding{Decoder = DynamicallyTypedQueryDecoder};

    optional any DynamicallyTypedQueryDecoder(stream s)
    {
        var arrayByte = NdrDecoder<ArrayByte>(s);
        if (arrayByte == nothing)
            return nothing;

        if ((arrayByte as ArrayByte).Array.Count == 0)
            return arrayByte;

        binary binData = (arrayByte as ArrayByte).Array as binary;
        switch (Type)
        {
            case (RegistryTypeValues.REG_SZ | RegistryTypeValues.REG_EXPAND_SZ) => // 1 | 2
            {
                var data = BinaryDecoder<UnicodeString>(binData);
                if (data != nothing)
                    return data;
            }
            case (RegistryTypeValues.REG_NONE | RegistryTypeValues.REG_BINARY | 
                  RegistryTypeValues.REG_LINK | RegistryTypeValues.REG_RESOURCE_LIST) => // 0 | 3 | 6 | 8
            {
                return binData;
            }
            case RegistryTypeValues.REG_DWORD_LITTLE_ENDIAN => // 4
            {
                return BinaryPrimitiveTypeDecoder<uint>(binData, Endian.Little);
            }
            case RegistryTypeValues.REG_DWORD_BIG_ENDIAN => // 5
            {
                return BinaryPrimitiveTypeDecoder<uint>(binData, Endian.Big);
            }
            case RegistryTypeValues.REG_MULTI_SZ => // 7
            {
                stream sData = binData as stream;
                array<string> arrayString = [];
                while (sData.RemainingByteLength > 0)
                {
                    var result = BinaryDecoder<UnicodeString>(sData);
                    if (result == nothing)
                        break;
                    arrayString += [result as string];
                }
                return arrayString;
            }
            case RegistryTypeValues.REG_QWORD_LITTLE_ENDIAN => // 11
                return BinaryPrimitiveTypeDecoder<ulong>(binData, Endian.Little);
            default =>;
        }
        return arrayByte;
    }
 }

// 2.2.2.3 DATATYPES_INFO_1
type _DATATYPES_INFO_1
{
    array<_DATATYPES_INFO_1_Fixed_Portion> Fixed_Portion with IDL{Size_is = [0]};
    array<_DATATYPES_INFO_1_Variable_Data> Variable_Data with IDL{Size_is = [0]};
} with IDL{DoNotGenerate = true};

type _DATATYPES_INFO_1_Fixed_Portion
{
    uint NameOffset;
    
    uint SizeIs()
    { return 4; }
} with IDL{DoNotGenerate = true};

type _DATATYPES_INFO_1_Variable_Data[_DATATYPES_INFO_1_Fixed_Portion Portion]
{
    optional [|Portion.NameOffset > 0|] string NameArray 
        with Encoding{Offset = Portion.NameOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
} with IDL{DoNotGenerate = true};

pattern DriverInfoPattern = _DRIVER_INFO_1 | _DRIVER_INFO_2 | _DRIVER_INFO_3 | _DRIVER_INFO_4 | _DRIVER_INFO_5 | 
                            _DRIVER_INFO_6 | _DRIVER_INFO_7 | _DRIVER_INFO_8 | _DRIVER_INFO_101;

// 2.2.2.4.1 _DRIVER_INFO_1
type _DRIVER_INFO_1
{
    array<_DRIVER_INFO_1_Fixed_Portion> Fixed_Portion with IDL{Size_is = [0]};
    array<_DRIVER_INFO_1_Variable_Data> Variable_Data with IDL{Size_is = [0]};
} with IDL{DoNotGenerate = true};

type _DRIVER_INFO_1_Fixed_Portion
{
    uint NameOffset;
    
    uint SizeIs()
    { return 4; }
} with IDL{DoNotGenerate = true};

type _DRIVER_INFO_1_Variable_Data[_DRIVER_INFO_1_Fixed_Portion Portion]
{
    optional [|Portion.NameOffset > 0|] string NameArray 
        with Encoding{Offset = Portion.NameOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
} with IDL{DoNotGenerate = true};

// 2.2.2.4.2 _DRIVER_INFO_2
type _DRIVER_INFO_2
{
    array<_DRIVER_INFO_2_Fixed_Portion> Fixed_Portion with IDL{Size_is = [0]};
    array<_DRIVER_INFO_2_Variable_Data> Variable_Data with IDL{Size_is = [0]};
} with IDL{DoNotGenerate = true};

type _DRIVER_INFO_2_Fixed_Portion
{
    uint cVersion;
    uint NameOffset;
    uint EnvironmentOffset;
    uint DriverPathOffset;
    uint DataFileOffset;
    uint ConfigFileOffset;
    
    uint SizeIs()
    { return 24; }
} with IDL{DoNotGenerate = true};

type _DRIVER_INFO_2_Variable_Data[_DRIVER_INFO_2_Fixed_Portion Portion]
{
    optional [|Portion.ConfigFileOffset > 0|] string ConfigFileArray 
        with Encoding{Offset = Portion.ConfigFileOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.DataFileOffset > 0|] string DataFileArray 
        with Encoding{Offset = Portion.DataFileOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.DriverPathOffset > 0|] string DriverPathArray 
        with Encoding{Offset = Portion.DriverPathOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.EnvironmentOffset > 0|] string EnvironmentArray 
        with Encoding{Offset = Portion.EnvironmentOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.NameOffset > 0|] string NameArray 
        with Encoding{Offset = Portion.NameOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
} with IDL{DoNotGenerate = true};

// 2.2.2.4.3 _DRIVER_INFO_3
type _DRIVER_INFO_3
{
    array<_DRIVER_INFO_3_Fixed_Portion> Fixed_Portion with IDL{Size_is = [0]};
    array<_DRIVER_INFO_3_Variable_Data> Variable_Data with IDL{Size_is = [0]};
} with IDL{DoNotGenerate = true};

type _DRIVER_INFO_3_Fixed_Portion
{
    uint cVersion;
    uint NameOffset;
    uint EnvironmentOffset;
    uint DriverPathOffset;
    uint DataFileOffset;
    uint ConfigFileOffset;
    uint HelpFileOffset;
    uint DependentFilesOffset;
    uint MonitorNameOffset;
    uint DefaultDataTypeOffset;
    
    uint SizeIs()
    { return 40; }
} with IDL{DoNotGenerate = true};

type _DRIVER_INFO_3_Variable_Data[_DRIVER_INFO_3_Fixed_Portion Portion]
{
    optional [|Portion.DefaultDataTypeOffset > 0|] string DefaultDataTypeArray 
        with Encoding{Offset = Portion.DefaultDataTypeOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.MonitorNameOffset > 0|] string MonitorNameArray 
        with Encoding{Offset = Portion.MonitorNameOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.DependentFilesOffset > 0|] array<UnicodeString> DependentFilesArray
        with Encoding{
                        Offset = Portion.DependentFilesOffset - Portion.SizeIs(), 
                        Decoder = UnicodeStringArrayDecoder
                     };
    optional [|Portion.HelpFileOffset > 0|] string HelpFileArray 
        with Encoding{Offset = Portion.HelpFileOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.ConfigFileOffset > 0|] string ConfigFileArray 
        with Encoding{Offset = Portion.ConfigFileOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.DataFileOffset > 0|] string DataFileArray 
        with Encoding{Offset = Portion.DataFileOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.DriverPathOffset > 0|] string DriverPathArray 
        with Encoding{Offset = Portion.DriverPathOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.EnvironmentOffset > 0|] string EnvironmentArray 
        with Encoding{Offset = Portion.EnvironmentOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.NameOffset > 0|] string NameArray 
        with Encoding{Offset = Portion.NameOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
} with IDL{DoNotGenerate = true};

// 2.2.2.4.4 _DRIVER_INFO_4
type _DRIVER_INFO_4
{
    array<_DRIVER_INFO_4_Fixed_Portion> Fixed_Portion with IDL{Size_is = [0]};
    array<_DRIVER_INFO_4_Variable_Data> Variable_Data with IDL{Size_is = [0]};
} with IDL{DoNotGenerate = true};

type _DRIVER_INFO_4_Fixed_Portion
{
    uint cVersion;
    uint NameOffset;
    uint EnvironmentOffset;
    uint DriverPathOffset;
    uint DataFileOffset;
    uint ConfigFileOffset;
    uint HelpFileOffset;
    uint DependentFilesOffset;
    uint MonitorNameOffset;
    uint DefaultDataTypeOffset;
    uint szzPreviousNamesOffset;
    
    uint SizeIs()
    { return 44; }
} with IDL{DoNotGenerate = true};

type _DRIVER_INFO_4_Variable_Data[_DRIVER_INFO_4_Fixed_Portion Portion]
{
    optional [|Portion.szzPreviousNamesOffset > 0|] string szzPreviousNamesArray 
        with Encoding{Offset = Portion.szzPreviousNamesOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.DefaultDataTypeOffset > 0|] string DefaultDataTypeArray 
        with Encoding{Offset = Portion.DefaultDataTypeOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.MonitorNameOffset > 0|] string MonitorNameArray 
        with Encoding{Offset = Portion.MonitorNameOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.DependentFilesOffset > 0|] string DependentFilesArray 
        with Encoding{Offset = Portion.DependentFilesOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.HelpFileOffset > 0|] string HelpFileArray 
        with Encoding{Offset = Portion.HelpFileOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.ConfigFileOffset > 0|] string ConfigFileArray 
        with Encoding{Offset = Portion.ConfigFileOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.DataFileOffset > 0|] string DataFileArray 
        with Encoding{Offset = Portion.DataFileOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.DriverPathOffset > 0|] string DriverPathArray 
        with Encoding{Offset = Portion.DriverPathOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.EnvironmentOffset > 0|] string EnvironmentArray 
        with Encoding{Offset = Portion.EnvironmentOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.NameOffset > 0|] string NameArray 
        with Encoding{Offset = Portion.NameOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
} with IDL{DoNotGenerate = true};

// 2.2.2.4.5 _DRIVER_INFO_5
type _DRIVER_INFO_5
{
    array<_DRIVER_INFO_5_Fixed_Portion> Fixed_Portion with IDL{Size_is = [0]};
    array<_DRIVER_INFO_5_Variable_Data> Variable_Data with IDL{Size_is = [0]};
} with IDL{DoNotGenerate = true};

type _DRIVER_INFO_5_Fixed_Portion
{
    uint cVersion;
    uint NameOffset;
    uint EnvironmentOffset;
    uint DriverPathOffset;
    uint DataFileOffset;
    uint ConfigFileOffset;
    DRIVER_INFO_5_DriverAttributes dwDriverAttributes;
    uint dwConfigVersion;
    uint dwDriverVersion;
    
    uint SizeIs()
    { return 36; }
} with IDL{DoNotGenerate = true};

pattern DRIVER_INFO_5_DriverAttributes = flags uint
{
    PRINTER_DRIVER_PACKAGE_AWARE = 0x08000000
        with Documentation{Description = "The printer driver is part of a driver package."},
    ...
} with IDL{DoNotGenerate = true};

type _DRIVER_INFO_5_Variable_Data[_DRIVER_INFO_5_Fixed_Portion Portion]
{
    optional [|Portion.ConfigFileOffset > 0|] string ConfigFileArray 
        with Encoding{Offset = Portion.ConfigFileOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.DataFileOffset > 0|] string DataFileArray 
        with Encoding{Offset = Portion.DataFileOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.DriverPathOffset > 0|] string DriverPathArray 
        with Encoding{Offset = Portion.DriverPathOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.EnvironmentOffset > 0|] string EnvironmentArray 
        with Encoding{Offset = Portion.EnvironmentOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.NameOffset > 0|] string NameArray 
        with Encoding{Offset = Portion.NameOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
} with IDL{DoNotGenerate = true};

// 2.2.2.4.6 _DRIVER_INFO_6
type _DRIVER_INFO_6
{
    array<_DRIVER_INFO_6_Fixed_Portion> Fixed_Portion with IDL{Size_is = [0]};
    array<_DRIVER_INFO_6_Variable_Data> Variable_Data with IDL{Size_is = [0]};
} with IDL{DoNotGenerate = true};

type _DRIVER_INFO_6_Fixed_Portion
{
    uint cVersion;
    uint NameOffset;
    uint EnvironmentOffset;
    uint DriverPathOffset;
    uint DataFileOffset;
    uint ConfigFileOffset;
    uint HelpFileOffset;
    uint DependentFilesOffset;
    uint MonitorNameOffset;
    uint DefaultDataTypeOffset;
    uint szzPreviousNamesOffset;
    FILETIME ftDriverDate;
    uint PaddingForAlignment;
    ulong dwlDriverVersion;
    uint MfgNameOffset;
    uint OEMUrlOffset;
    uint HardwareIDOffset;
    uint ProviderOffset;
    
    uint SizeIs()
    { return 80; }
} with IDL{DoNotGenerate = true};

type _DRIVER_INFO_6_Variable_Data[_DRIVER_INFO_6_Fixed_Portion Portion]
{
    optional [|Portion.ProviderOffset > 0|] string ProviderArray 
        with Encoding{Offset = Portion.ProviderOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.HardwareIDOffset > 0|] string HardwareIDArray 
        with Encoding{Offset = Portion.HardwareIDOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.OEMUrlOffset > 0|] string OEMUrlArray 
        with Encoding{Offset = Portion.OEMUrlOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.MfgNameOffset > 0|] string MfgNameArray 
        with Encoding{Offset = Portion.MfgNameOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.szzPreviousNamesOffset > 0|] string szzPreviousNamesArray 
        with Encoding{Offset = Portion.szzPreviousNamesOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.DefaultDataTypeOffset > 0|] string DefaultDataTypeArray 
        with Encoding{Offset = Portion.DefaultDataTypeOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.MonitorNameOffset > 0|] string MonitorNameArray 
        with Encoding{Offset = Portion.MonitorNameOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.DependentFilesOffset > 0|] string DependentFilesArray 
        with Encoding{Offset = Portion.DependentFilesOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.HelpFileOffset > 0|] string HelpFileArray 
        with Encoding{Offset = Portion.HelpFileOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.ConfigFileOffset > 0|] string ConfigFileArray 
        with Encoding{Offset = Portion.ConfigFileOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.DataFileOffset > 0|] string DataFileArray 
        with Encoding{Offset = Portion.DataFileOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.DriverPathOffset > 0|] string DriverPathArray 
        with Encoding{Offset = Portion.DriverPathOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.EnvironmentOffset > 0|] string EnvironmentArray 
        with Encoding{Offset = Portion.EnvironmentOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.NameOffset > 0|] string NameArray 
        with Encoding{Offset = Portion.NameOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
} with IDL{DoNotGenerate = true};

// 2.2.2.4.7 _DRIVER_INFO_7
type _DRIVER_INFO_7
{
    array<_DRIVER_INFO_7_Fixed_Portion> Fixed_Portion with IDL{Size_is = [0]};
    array<_DRIVER_INFO_7_Variable_Data> Variable_Data with IDL{Size_is = [0]};
} with IDL{DoNotGenerate = true};

type _DRIVER_INFO_7_Fixed_Portion
{
    uint cbSize;
    uint cVersion;
    uint szDriverNameOffset;
    uint szInfNameOffset;
    uint szInstallSourceRootOffset;
    
    uint SizeIs()
    { return 20; }
} with IDL{DoNotGenerate = true};

type _DRIVER_INFO_7_Variable_Data[_DRIVER_INFO_7_Fixed_Portion Portion]
{
    optional [|Portion.szInstallSourceRootOffset > 0|] string szInstallSourceRootArray 
        with Encoding{Offset = Portion.szInstallSourceRootOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.szInfNameOffset > 0|] string szInfNameArray 
        with Encoding{Offset = Portion.szInfNameOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.szDriverNameOffset > 0|] string szDriverNameArray 
        with Encoding{Offset = Portion.szDriverNameOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
} with IDL{DoNotGenerate = true};

// 2.2.2.4.8 _DRIVER_INFO_8
type _DRIVER_INFO_8
{
    array<_DRIVER_INFO_8_Fixed_Portion> Fixed_Portion with IDL{Size_is = [0]};
    array<_DRIVER_INFO_8_Variable_Data> Variable_Data with IDL{Size_is = [0]};
} with IDL{DoNotGenerate = true};

type _DRIVER_INFO_8_Fixed_Portion
{
    uint cVersion;
    uint NameOffset;
    uint EnvironmentOffset;
    uint DriverPathOffset;
    uint DataFileOffset;
    uint ConfigFileOffset;
    uint HelpFileOffset;
    uint DependentFilesOffset;
    uint MonitorNameOffset;
    uint DefaultDataTypeOffset;
    uint szzPreviousNamesOffset;
    FILETIME ftDriverDate;
    uint PaddingForAlignment;
    ulong dwlDriverVersion;
    uint MfgNameOffset;
    uint OEMUrlOffset;
    uint HardwareIDOffset;
    uint ProviderOffset;
    uint PrintProcessorOffset;
    uint VendorSetupOffset;
    uint szzColorProfilesOffset;
    uint InfPathOffset;
    uint dwPrinterDriverAttributes;
    uint szzCoreDependenciesOffset;
    FILETIME ftMinInboxDriverVerDate;
    ulong dwlMinInboxDriverVerVersion;
    
    uint SizeIs()
    { return 120; }
} with IDL{DoNotGenerate = true};

type _DRIVER_INFO_8_Variable_Data[_DRIVER_INFO_8_Fixed_Portion Portion]
{
    optional [|Portion.InfPathOffset > 0|] string InfPathArray 
        with Encoding{Offset = Portion.InfPathOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.szzColorProfilesOffset > 0|] string szzColorProfilesArray 
        with Encoding{Offset = Portion.szzColorProfilesOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.VendorSetupOffset > 0|] string VendorSetupArray 
        with Encoding{Offset = Portion.VendorSetupOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.PrintProcessorOffset > 0|] string PrintProcessorArray 
        with Encoding{Offset = Portion.PrintProcessorOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.ProviderOffset > 0|] string ProviderArray 
        with Encoding{Offset = Portion.ProviderOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.HardwareIDOffset > 0|] string HardwareIDArray 
        with Encoding{Offset = Portion.HardwareIDOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.OEMUrlOffset > 0|] string OEMUrlArray 
        with Encoding{Offset = Portion.OEMUrlOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.MfgNameOffset > 0|] string MfgNameArray 
        with Encoding{Offset = Portion.MfgNameOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.szzPreviousNamesOffset > 0|] string szzPreviousNamesArray 
        with Encoding{Offset = Portion.szzPreviousNamesOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.DefaultDataTypeOffset > 0|] string DefaultDataTypeArray 
        with Encoding{Offset = Portion.DefaultDataTypeOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.MonitorNameOffset > 0|] string MonitorNameArray 
        with Encoding{Offset = Portion.MonitorNameOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.DependentFilesOffset > 0|] string DependentFilesArray 
        with Encoding{Offset = Portion.DependentFilesOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.HelpFileOffset > 0|] string HelpFileArray 
        with Encoding{Offset = Portion.HelpFileOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.ConfigFileOffset > 0|] string ConfigFileArray 
        with Encoding{Offset = Portion.ConfigFileOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.DataFileOffset > 0|] string DataFileArray 
        with Encoding{Offset = Portion.DataFileOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.DriverPathOffset > 0|] string DriverPathArray 
        with Encoding{Offset = Portion.DriverPathOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.EnvironmentOffset > 0|] string EnvironmentArray 
        with Encoding{Offset = Portion.EnvironmentOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.NameOffset > 0|] string NameArray 
        with Encoding{Offset = Portion.NameOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.szzCoreDependenciesOffset > 0|] string szzCoreDependenciesArray 
        with Encoding{Offset = Portion.szzCoreDependenciesOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
} with IDL{DoNotGenerate = true};

// 2.2.2.4.101 _DRIVER_INFO_101
type _DRIVER_INFO_101
{
    array<_DRIVER_INFO_101_Fixed_Portion> Fixed_Portion with IDL{Size_is = [0]};
    array<_DRIVER_INFO_101_Variable_Data> Variable_Data with IDL{Size_is = [0]};
} with IDL{DoNotGenerate = true};

type _DRIVER_INFO_101_Fixed_Portion
{
    uint cVersion;
    uint NameOffset;
    uint EnvironmentOffset;
    uint FileInfoOffset;
    uint dwFileCount;
    uint MonitorNameOffset;
    uint DefaultDataTypeOffset;
    uint szzPreviousNamesOffset;
    ulong ftDriverDate;
    ulong dwlDriverVersion;
    uint MfgNameOffset;
    uint OEMUrlOffset;
    uint HardwareIDOffset;
    uint ProviderOffset;
    
    uint SizeIs()
    { return 64; }
} with IDL{DoNotGenerate = true};

type _DRIVER_INFO_101_Variable_Data[_DRIVER_INFO_101_Fixed_Portion Portion]
{
    optional [|Portion.ProviderOffset > 0|] string ProviderArray 
        with Encoding{Offset = Portion.ProviderOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.HardwareIDOffset > 0|] string HardwareIDArray 
        with Encoding{Offset = Portion.HardwareIDOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.OEMUrlOffset > 0|] string OEMUrlArray 
        with Encoding{Offset = Portion.OEMUrlOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.MfgNameOffset > 0|] string MfgNameArray 
        with Encoding{Offset = Portion.MfgNameOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.szzPreviousNamesOffset > 0|] string szzPreviousNamesArray 
        with Encoding{Offset = Portion.szzPreviousNamesOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.DefaultDataTypeOffset > 0|] string DefaultDataTypeArray 
        with Encoding{Offset = Portion.DefaultDataTypeOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.MonitorNameOffset > 0|] string MonitorNameArray 
        with Encoding{Offset = Portion.MonitorNameOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.FileInfoOffset > 0 && Portion.dwFileCount > 0|] _DRIVER_FILE_INFO FileInfoArray
        with Encoding{Offset = Portion.FileInfoOffset - Portion.SizeIs()}, Encoding{Decoder = DriverFileInfoArrayDecoder};
    optional [|Portion.EnvironmentOffset > 0|] string EnvironmentArray 
        with Encoding{Offset = Portion.EnvironmentOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.NameOffset > 0|] string NameArray 
        with Encoding{Offset = Portion.NameOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};

    optional _DRIVER_FILE_INFO DriverFileInfoArrayDecoder(stream dataStream)
    {
        InfoStructLevel infoStructureLevel = InfoStructLevel._DRIVER_FILE_INFO;
        uint fileCount = Portion.dwFileCount;
        return CustomInfoStrucutureDecoder<_DRIVER_FILE_INFO>(dataStream, infoStructureLevel, fileCount);
    }
} with IDL{DoNotGenerate = true};

// 2.2.2.4.10 _DRIVER_FILE_INFO
type _DRIVER_FILE_INFO
{
    array<_DRIVER_FILE_INFO_Fixed_Portion> Fixed_Portion with IDL{Size_is = [0]};
    array<_DRIVER_FILE_INFO_Variable_Data> Variable_Data with IDL{Size_is = [0]};
} with IDL{DoNotGenerate = true};

type _DRIVER_FILE_INFO_Fixed_Portion
{
    uint FileNameOffset;
    _DRIVER_FILE_INFO_FileType FileType;
    uint FileVersion;
    
    uint SizeIs()
    { return 12; }
} with IDL{DoNotGenerate = true};

pattern _DRIVER_FILE_INFO_FileType = enum uint
{
    RenderingDriverModuleExecutable = 0x00000000
        with Documentation{Description = "The file is a rendering driver module executable."},
    ConfigurationModuleExecutable = 0x00000001
        with Documentation{Description = "The file is a configuration module executable."},
    DriverDataFile = 0x00000002
        with Documentation{Description = "The file is a driver data file."},
    DriverHelpFile = 0x00000003
        with Documentation{Description = "The file is a driver help file."},
    Other = 0x00000004
        with Documentation{Description = "The file is a dependent file with a type other than the preceding file types."},
    ...
} with IDL{DoNotGenerate = true};

type _DRIVER_FILE_INFO_Variable_Data[_DRIVER_FILE_INFO_Fixed_Portion Portion, uint StructOffset]
{
    optional [|Portion.FileNameOffset > 0|] string FileNameArray 
        with Encoding{Offset = Portion.FileNameOffset - Portion.SizeIs() - StructOffset}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
} with IDL{DoNotGenerate = true};

pattern FormInfoPattern = _FORM_INFO_1 | _FORM_INFO_2;

// 2.2.2.5.1 _FORM_INFO_1
type _FORM_INFO_1
{
    array<_FORM_INFO_1_Fixed_Portion> Fixed_Portion with IDL{Size_is = [0]};
    array<_FORM_INFO_1_Variable_Data> Variable_Data with IDL{Size_is = [0]};
} with IDL{DoNotGenerate = true};

type _FORM_INFO_1_Fixed_Portion
{
    FormInfoFlags Flags
        where ValidationCheckEnumValue(InRange<FormInfoFlags>(value), null, true, 
            ReferenceType.Type, "RPRN", "Flags", "_FORM_INFO_1_Fixed_Portion", "0x00000000, 0x00000001, 0x00000002", value);
    uint NameOffset;
    RprnSize Size;
    RprnImageableArea ImageableArea;
    
    uint SizeIs()
    { return 32; }
} with IDL{DoNotGenerate = true};

type _FORM_INFO_1_Variable_Data[_FORM_INFO_1_Fixed_Portion Portion]
{
    optional [|Portion.NameOffset > 0|] string NameArray 
        with Encoding{Offset = Portion.NameOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
} with IDL{DoNotGenerate = true};

// 2.2.2.5.2 _FORM_INFO_2
type _FORM_INFO_2
{
    array<_FORM_INFO_2_Fixed_Portion> Fixed_Portion with IDL{Size_is = [0]};
    array<_FORM_INFO_2_Variable_Data> Variable_Data with IDL{Size_is = [0]};
} with IDL{DoNotGenerate = true};

type _FORM_INFO_2_Fixed_Portion
{
    FormInfoFlags Flags
        where ValidationCheckEnumValue(InRange<FormInfoFlags>(value), null, true, 
            ReferenceType.Type, "RPRN", "Flags", "_FORM_INFO_2_Fixed_Portion", "0x00000000, 0x00000001, 0x00000002", value);
    uint NameOffset;
    RprnSize Size;
    RprnImageableArea ImageableArea;
    uint KeywordOffset;
    FormInfo2StringType StringType;
    uint MuiDllOffset;
    uint dwResourceID;
    uint DisplayNameOffset;
    ushort wLangID;
    ushort unused where ValidationCheckZero(value == 0, null, false, ReferenceType.Type, "RPRN", "unused", "_FORM_INFO_2_Fixed_Portion", value);
    
    uint SizeIs()
    { return 56; }
} with IDL{DoNotGenerate = true};

pattern FormInfoFlags = enum uint
{
    FORM_USER = 0x00000000, // If the value of this member is FORM_USER, the form has been defined by the user. Forms that have this flag set are defined in the registry.
    FORM_BUILTIN = 0x00000001, // If the value of this member is FORM_BUILTIN, the form is part of the spooler. Form definitions that have this flag set do not appear in the registry.
    FORM_PRINTER = 0x00000002, // If the value of this member is FORM_PRINTER, the form is associated with a particular printer and its definition appears in the registry.
    ...
} with IDL{DoNotGenerate = true};

type RprnSize
{
    uint Cx;
    uint Cy;
} with IDL{DoNotGenerate = true};

type RprnImageableArea
{
    uint Left;
    uint Top;
    uint Right;
    uint Bottom;
} with IDL{DoNotGenerate = true};

pattern FormInfo2StringType = enum DWORD
{
    STRING_NONE = 0x00000001, // Use the default display name, a string that is pointed to by the pName member. No localized display name exists.
    STRING_MUIDLL = 0x00000002, // Load the form name from the library of string resources that is identified by the pMuiDll member. The dwResourceId member specifies the ID of the form name string in that library.
    STRING_LANGPAIR = 0x00000004, // Use the form name, a string that is pointed to by the pDisplayName member, and the language that is identified by the wLangID member.
    ...
} with IDL{DoNotGenerate = true};

type _FORM_INFO_2_Variable_Data[_FORM_INFO_2_Fixed_Portion Portion]
{
    optional [|Portion.NameOffset > 0|] string NameArray 
        with Encoding{Offset = Portion.NameOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.KeywordOffset > 0|] string KeywordArray 
        with Encoding{Offset = Portion.KeywordOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.ASCII};
    optional [|Portion.MuiDllOffset > 0|] string MuiDllArray 
        with Encoding{Offset = Portion.MuiDllOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.DisplayNameOffset > 0|] string DisplayNameArray 
        with Encoding{Offset = Portion.DisplayNameOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
} with IDL{DoNotGenerate = true};

pattern JobInfoPattern = _JOB_INFO_1 | _JOB_INFO_2 | _JOB_INFO_3 | _JOB_INFO_4;

// 2.2.2.6.1 _JOB_INFO_1
type _JOB_INFO_1
{
    array<_JOB_INFO_1_Fixed_Portion> Fixed_Portion with IDL{Size_is = [0]};
    array<_JOB_INFO_1_Variable_Data> Variable_Data with IDL{Size_is = [0]};
} with IDL{DoNotGenerate = true};

type _JOB_INFO_1_Fixed_Portion
{
    uint JobId;
    uint PrinterNameOffset;
    uint MachineNameOffset;
    uint UserNameOffset;
    uint DocumentOffset;
    uint DatatypeOffset;
    uint StatusOffset;
    Job_Status Status;
    uint Priority;
    uint Position;
    uint TotalPages;
    uint PagesPrinted;
    SYSTEMTIME Submitted;
    
    uint SizeIs()
    { return 64; }
} with IDL{DoNotGenerate = true};

type _JOB_INFO_1_Variable_Data[_JOB_INFO_1_Fixed_Portion Portion]
{
    optional [|Portion.StatusOffset > 0|] string StatusArray 
        with Encoding{Offset = Portion.StatusOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.DatatypeOffset > 0|] string DatatypeArray 
        with Encoding{Offset = Portion.DatatypeOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.DocumentOffset > 0|] string DocumentArray 
        with Encoding{Offset = Portion.DocumentOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.UserNameOffset > 0|] string UserNameArray 
        with Encoding{Offset = Portion.UserNameOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.MachineNameOffset > 0|] string MachineNameArray 
        with Encoding{Offset = Portion.MachineNameOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.PrinterNameOffset > 0|] string PrinterNameArray 
        with Encoding{Offset = Portion.PrinterNameOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
} with IDL{DoNotGenerate = true};

// 2.2.2.6.2 _JOB_INFO_2
type _JOB_INFO_2
{
    array<_JOB_INFO_2_Fixed_Portion> Fixed_Portion with IDL{Size_is = [0]};
    array<_JOB_INFO_2_Variable_Data> Variable_Data with IDL{Size_is = [0]};
} with IDL{DoNotGenerate = true};

type _JOB_INFO_2_Fixed_Portion
{
    uint JobId;
    uint PrinterNameOffset;
    uint MachineNameOffset;
    uint UserNameOffset;
    uint DocumentOffset;
    uint NotifyNameOffset;
    uint DatatypeOffset;
    uint PrintProcessorOffset;
    uint ParametersOffset;
    uint DriverNameOffset;
    uint DevModeOffset;
    uint StatusOffset;
    uint SecurityDescriptorOffset;
    Job_Status Status;
    uint Priority;
    uint Position;
    uint StartTime;
    uint UntilTime;
    uint TotalPages;
    uint Size;
    SYSTEMTIME Submitted;
    uint Time;
    uint PagesPrinted;
    
    uint SizeIs()
    { return 104; }
} with IDL{DoNotGenerate = true};

pattern Job_Status = flags uint
{
    JOB_STATUS_BLOCKED_DEVQ = 0x00000200
        with Documentation{Description = "Printer driver cannot print the job."},
    JOB_STATUS_COMPLETE = 0x00001000
        with Documentation{Description = "Job has been delivered to the printer."},
    JOB_STATUS_DELETED = 0x00000100
        with Documentation{Description = "Job has been deleted."},
    JOB_STATUS_DELETING = 0x00000004
        with Documentation{Description = "Job is being deleted."},
    JOB_STATUS_ERROR = 0x00000002
        with Documentation{Description = "An error is associated with the job."},
    JOB_STATUS_OFFLINE = 0x00000020
        with Documentation{Description = "Printer is offline."},
    JOB_STATUS_PAPEROUT = 0x00000040
        with Documentation{Description = "Printer is out of paper."},
    JOB_STATUS_PAUSED = 0x00000001
        with Documentation{Description = "Job is paused."},
    JOB_STATUS_PRINTED = 0x00000080
        with Documentation{Description = "Job has printed."},
    JOB_STATUS_PRINTING = 0x00000010
        with Documentation{Description = "Job is printing."},
    JOB_STATUS_RESTART = 0x00000800
        with Documentation{Description = "Job has been restarted."},
    JOB_STATUS_SPOOLING = 0x00000008
        with Documentation{Description = "Job is spooling."},
    JOB_STATUS_USER_INTERVENTION = 0x00000400
        with Documentation{Description = "Printer has an error that requires the user to do something."},
    ...
} with IDL{DoNotGenerate = true};

type _JOB_INFO_2_Variable_Data[_JOB_INFO_2_Fixed_Portion Portion]
{
    optional [|Portion.SecurityDescriptorOffset > 0|] string SecurityDescriptorArray 
        with Encoding{Offset = Portion.SecurityDescriptorOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.StatusOffset > 0|] string StatusArray 
        with Encoding{Offset = Portion.StatusOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.DevModeOffset > 0|] string DevModeArray 
        with Encoding{Offset = Portion.DevModeOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.DriverNameOffset > 0|] string DriverNameArray 
        with Encoding{Offset = Portion.DriverNameOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.ParametersOffset > 0|] string ParametersArray 
        with Encoding{Offset = Portion.ParametersOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.PrintProcessorOffset > 0|] string PrintProcessorArray 
        with Encoding{Offset = Portion.PrintProcessorOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.DatatypeOffset > 0|] string DatatypeArray 
        with Encoding{Offset = Portion.DatatypeOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.NotifyNameOffset > 0|] string NotifyNameArray 
        with Encoding{Offset = Portion.NotifyNameOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.DocumentOffset > 0|] string DocumentArray 
        with Encoding{Offset = Portion.DocumentOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.UserNameOffset > 0|] string UserNameArray 
        with Encoding{Offset = Portion.UserNameOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.MachineNameOffset > 0|] string MachineNameArray 
        with Encoding{Offset = Portion.MachineNameOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.PrinterNameOffset > 0|] string PrinterNameArray 
        with Encoding{Offset = Portion.PrinterNameOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
} with IDL{DoNotGenerate = true};

// 2.2.2.6.3 _JOB_INFO_3
type _JOB_INFO_3
{
    array<_JOB_INFO_3_Fixed_Portion> Fixed_Portion with IDL{Size_is = [0]};
} with IDL{DoNotGenerate = true};

type _JOB_INFO_3_Fixed_Portion
{
    uint JobId;
    uint NextJobId;
    uint Reserved;
} with IDL{DoNotGenerate = true};

// 2.2.2.6.4 _JOB_INFO_4
type _JOB_INFO_4
{
    array<_JOB_INFO_4_Fixed_Portion> Fixed_Portion with IDL{Size_is = [0]};
    array<_JOB_INFO_4_Variable_Data> Variable_Data with IDL{Size_is = [0]};
} with IDL{DoNotGenerate = true};

type _JOB_INFO_4_Fixed_Portion
{
    uint JobId;
    uint PrinterNameOffset;
    uint MachineNameOffset;
    uint UserNameOffset;
    uint DocumentOffset;
    uint NotifyNameOffset;
    uint DatatypeOffset;
    uint PrintProcessorOffset;
    uint ParametersOffset;
    uint DriverNameOffset;
    uint DevModeOffset;
    uint StatusOffset;
    uint SecurityDescriptorOffset;
    Job_Status Status;
    uint Priority;
    uint Position;
    uint StartTime;
    uint UntilTime;
    uint TotalPages;
    uint Size;
    SYSTEMTIME Submitted;
    uint Time;
    uint PagesPrinted;
    uint SizeHigh;
    
    uint SizeIs()
    { return 108; }
} with IDL{DoNotGenerate = true};

type _JOB_INFO_4_Variable_Data[_JOB_INFO_4_Fixed_Portion Portion]
{
    optional [|Portion.SecurityDescriptorOffset > 0|] string SecurityDescriptorArray 
        with Encoding{Offset = Portion.SecurityDescriptorOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.StatusOffset > 0|] string StatusArray 
        with Encoding{Offset = Portion.StatusOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.DevModeOffset > 0|] string DevModeArray 
        with Encoding{Offset = Portion.DevModeOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.DriverNameOffset > 0|] string DriverNameArray 
        with Encoding{Offset = Portion.DriverNameOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.ParametersOffset > 0|] string ParametersArray 
        with Encoding{Offset = Portion.ParametersOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.PrintProcessorOffset > 0|] string PrintProcessorArray 
        with Encoding{Offset = Portion.PrintProcessorOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.DatatypeOffset > 0|] string DatatypeArray 
        with Encoding{Offset = Portion.DatatypeOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.NotifyNameOffset > 0|] string NotifyNameArray 
        with Encoding{Offset = Portion.NotifyNameOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.DocumentOffset > 0|] string DocumentArray 
        with Encoding{Offset = Portion.DocumentOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.UserNameOffset > 0|] string UserNameArray 
        with Encoding{Offset = Portion.UserNameOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.MachineNameOffset > 0|] string MachineNameArray 
        with Encoding{Offset = Portion.MachineNameOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.PrinterNameOffset > 0|] string PrinterNameArray 
        with Encoding{Offset = Portion.PrinterNameOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
} with IDL{DoNotGenerate = true};

pattern MonitorInfoPattern = _MONITOR_INFO_1 | _MONITOR_INFO_2;

// 2.2.2.7.1 _MONITOR_INFO_1
type _MONITOR_INFO_1
{
    array<_MONITOR_INFO_1_Fixed_Portion> Fixed_Portion with IDL{Size_is = [0]};
    array<_MONITOR_INFO_1_Variable_Data> Variable_Data with IDL{Size_is = [0]};
} with IDL{DoNotGenerate = true};

type _MONITOR_INFO_1_Fixed_Portion
{
    uint NameOffset;

    uint SizeIs()
    { return 4; }
} with IDL{DoNotGenerate = true};

type _MONITOR_INFO_1_Variable_Data[_MONITOR_INFO_1_Fixed_Portion Portion]
{
    optional [|Portion.NameOffset > 0|] string NameArray 
        with Encoding{Offset = Portion.NameOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
} with IDL{DoNotGenerate = true};

// 2.2.2.7.2 _MONITOR_INFO_2
type _MONITOR_INFO_2
{
    array<_MONITOR_INFO_2_Fixed_Portion> Fixed_Portion with IDL{Size_is = [0]};
    array<_MONITOR_INFO_2_Variable_Data> Variable_Data with IDL{Size_is = [0]};
} with IDL{DoNotGenerate = true};

type _MONITOR_INFO_2_Fixed_Portion
{
    uint NameOffset;
    uint EnvironmentOffset;
    uint DLLNameOffset;
    
    uint SizeIs()
    { return 12; }
} with IDL{DoNotGenerate = true};

type _MONITOR_INFO_2_Variable_Data[_MONITOR_INFO_2_Fixed_Portion Portion]
{
    optional [|Portion.DLLNameOffset > 0|] string DLLNameArray 
        with Encoding{Offset = Portion.DLLNameOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.EnvironmentOffset > 0|] string EnvironmentArray 
        with Encoding{Offset = Portion.EnvironmentOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.NameOffset > 0|] string NameArray 
        with Encoding{Offset = Portion.NameOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
} with IDL{DoNotGenerate = true};

pattern PortInfoPattern = _PORT_INFO_1 | _PORT_INFO_2;

// 2.2.2.8.1 _PORT_INFO_1
type _PORT_INFO_1
{
    array<_PORT_INFO_1_Fixed_Portion> Fixed_Portion with IDL{Size_is = [0]};
    array<_PORT_INFO_1_Variable_Data> Variable_Data with IDL{Size_is = [0]};
} with IDL{DoNotGenerate = true};

type _PORT_INFO_1_Fixed_Portion
{
    uint NameOffset;
    
    uint SizeIs()
    { return 4; }
} with IDL{DoNotGenerate = true};

type _PORT_INFO_1_Variable_Data[_PORT_INFO_1_Fixed_Portion Portion]
{
    optional [|Portion.NameOffset > 0|] string NameArray 
        with Encoding{Offset = Portion.NameOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
} with IDL{DoNotGenerate = true};

// 2.2.2.8.2 _PORT_INFO_2
type _PORT_INFO_2
{
    array<_PORT_INFO_2_Fixed_Portion> Fixed_Portion with IDL{Size_is = [0]};
    array<_PORT_INFO_2_Variable_Data> Variable_Data with IDL{Size_is = [0]};
} with IDL{DoNotGenerate = true};

type _PORT_INFO_2_Fixed_Portion
{
    uint PortNameOffset;
    uint MonitorNameOffset;
    uint DescriptionOffset;
    uint fPortType;
    uint Reserved;
    
    uint SizeIs()
    { return 20; }
} with IDL{DoNotGenerate = true};

type _PORT_INFO_2_Variable_Data[_PORT_INFO_2_Fixed_Portion Portion]
{
    optional [|Portion.DescriptionOffset > 0|] string DescriptionArray 
        with Encoding{Offset = Portion.DescriptionOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.MonitorNameOffset > 0|] string MonitorNameArray 
        with Encoding{Offset = Portion.MonitorNameOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.PortNameOffset > 0|] string PortNameArray 
        with Encoding{Offset = Portion.PortNameOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
} with IDL{DoNotGenerate = true};

pattern PrinterInfoPattern = _PRINTER_INFO_STRESS | _PRINTER_INFO_1 | _PRINTER_INFO_2 | _PRINTER_INFO_3 | 
                      _PRINTER_INFO_4 | _PRINTER_INFO_5 | _PRINTER_INFO_6 | _PRINTER_INFO_7 | _PRINTER_INFO_8;

// 2.2.2.9.1 _PRINTER_INFO_STRESS
type _PRINTER_INFO_STRESS
{
    array<_PRINTER_INFO_STRESS_Fixed_Portion> Fixed_Portion with IDL{Size_is = [0]};
    array<_PRINTER_INFO_STRESS_Variable_Data> Variable_Data with IDL{Size_is = [0]};
} with IDL{DoNotGenerate = true};

type _PRINTER_INFO_STRESS_Fixed_Portion
{
    uint PrinterNameOffset;
    uint ServerNameOffset;
    uint cJobs;
    uint cTotalJobs;
    uint cTotalBytes;
    SYSTEMTIME stUpTime;
    uint MaxcRef;
    uint cTotalPagesPrinted;
    uint dwGetVersion;
    uint fFreeBuild;
    uint cSpooling;
    uint cMaxSpooling;
    uint cRef;
    uint cErrorOutOfPaper;
    uint cErrorNotReady;
    uint cJobError;
    uint dwNumberOfProcessors;
    uint dwProcessorType;
    uint dwHighPartTotalBytes;
    uint cChangeID;
    uint dwLastError;
    Printer_Status Status;
    uint cEnumerateNetworkPrinters;
    uint cAddNetPrinters;
    ushort wProcessorArchitecture;
    ushort wProcessorLevel;
    uint cRefIC;
    uint dwReserved2;
    uint dwReserved3;
    
    uint SizeIs()
    { return 124; }
} with IDL{DoNotGenerate = true};

type _PRINTER_INFO_STRESS_Variable_Data[_PRINTER_INFO_STRESS_Fixed_Portion Portion]
{
    optional [|Portion.PrinterNameOffset > 0|] string PrinterNameArray 
        with Encoding{Offset = Portion.PrinterNameOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.ServerNameOffset > 0|] string ServerNameArray 
        with Encoding{Offset = Portion.ServerNameOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
} with IDL{DoNotGenerate = true};

// 2.2.2.9.2 _PRINTER_INFO_1
type _PRINTER_INFO_1
{
    array<_PRINTER_INFO_1_Fixed_Portion> Fixed_Portion with IDL{Size_is = [0]};
    array<_PRINTER_INFO_1_Variable_Data> Variable_Data with IDL{Size_is = [0]};
} with IDL{DoNotGenerate = true};

type _PRINTER_INFO_1_Fixed_Portion
{
    PrinterAttribute Flags;
    uint DescriptionOffset;
    uint NameOffset;
    uint CommentOffset;
    
    uint SizeIs()
    { return 16; }
} with IDL{DoNotGenerate = true};

type _PRINTER_INFO_1_Variable_Data[_PRINTER_INFO_1_Fixed_Portion Portion]
{
    optional [|Portion.CommentOffset > 0|] string CommentArray 
        with Encoding{Offset = Portion.CommentOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.NameOffset > 0|] string NameArray 
        with Encoding{Offset = Portion.NameOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.DescriptionOffset > 0|] string DescriptionArray 
        with Encoding{Offset = Portion.DescriptionOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
} with IDL{DoNotGenerate = true};

// 2.2.2.9.3 _PRINTER_INFO_2
type _PRINTER_INFO_2
{
    array<_PRINTER_INFO_2_Fixed_Portion> Fixed_Portion with IDL{Size_is = [0]};
    array<_PRINTER_INFO_2_Variable_Data> Variable_Data with IDL{Size_is = [0]};
} with IDL{DoNotGenerate = true};

type _PRINTER_INFO_2_Fixed_Portion
{
    uint ServerNameOffset;
    uint PrinterNameOffset;
    uint ShareNameOffset;
    uint PortNameOffset;
    uint DriverNameOffset;
    uint CommentOffset;
    uint LocationOffset;
    uint DevModeOffset;
    uint SepFileOffset;
    uint PrintProcessorOffset;
    uint DatatypeOffset;
    uint ParametersOffset;
    uint SecurityDescriptorOffset;
    PrinterAttribute Attributes;
    uint Priority;
    uint DefaultPriority;
    uint StartTime;
    uint UntilTime;
    Printer_Status Status;
    uint cJobs;
    uint AveragePPM;
    
    uint SizeIs()
    { return 84; }
} with IDL{DoNotGenerate = true};

type _PRINTER_INFO_2_Variable_Data[_PRINTER_INFO_2_Fixed_Portion Portion]
{
    optional [|Portion.SecurityDescriptorOffset > 0|] SECURITY_DESCRIPTOR_NonRpc SecurityDescriptorArray
        with Encoding{Offset = Portion.SecurityDescriptorOffset - Portion.SizeIs()};
    optional [|Portion.ParametersOffset > 0|] string ParametersArray 
        with Encoding{Offset = Portion.ParametersOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.DatatypeOffset > 0|] string DatatypeArray 
        with Encoding{Offset = Portion.DatatypeOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.PrintProcessorOffset > 0|] string PrintProcessorArray 
        with Encoding{Offset = Portion.PrintProcessorOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.SepFileOffset > 0|] string SepFileArray 
        with Encoding{Offset = Portion.SepFileOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.DevModeOffset > 0|] string DevModeArray 
        with Encoding{Offset = Portion.DevModeOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.LocationOffset > 0|] string LocationArray 
        with Encoding{Offset = Portion.LocationOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.CommentOffset > 0|] string CommentArray 
        with Encoding{Offset = Portion.CommentOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.DriverNameOffset > 0|] string DriverNameArray 
        with Encoding{Offset = Portion.DriverNameOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.PortNameOffset > 0|] string PortNameArray 
        with Encoding{Offset = Portion.PortNameOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.ShareNameOffset > 0|] string ShareNameArray 
        with Encoding{Offset = Portion.ShareNameOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.PrinterNameOffset > 0|] string PrinterNameArray 
        with Encoding{Offset = Portion.PrinterNameOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.ServerNameOffset > 0|] string ServerNameArray 
        with Encoding{Offset = Portion.ServerNameOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
} with IDL{DoNotGenerate = true};

// 2.2.2.9.4 _PRINTER_INFO_3
type _PRINTER_INFO_3
{
    array<_PRINTER_INFO_3_Fixed_Portion> Fixed_Portion with IDL{Size_is = [0]};
    array<_PRINTER_INFO_3_Variable_Data> Variable_Data with IDL{Size_is = [0]};
} with IDL{DoNotGenerate = true};

type _PRINTER_INFO_3_Fixed_Portion
{
    uint SecurityDescriptorOffset;
    
    uint SizeIs()
    { return 4; }
} with IDL{DoNotGenerate = true};

type _PRINTER_INFO_3_Variable_Data[_PRINTER_INFO_3_Fixed_Portion Portion]
{
    optional [|Portion.SecurityDescriptorOffset > 0|] string SecurityDescriptorArray 
        with Encoding{Offset = Portion.SecurityDescriptorOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
} with IDL{DoNotGenerate = true};

// 2.2.2.9.5 _PRINTER_INFO_4
type _PRINTER_INFO_4
{
    array<_PRINTER_INFO_4_Fixed_Portion> Fixed_Portion with IDL{Size_is = [0]};
    array<_PRINTER_INFO_4_Variable_Data> Variable_Data with IDL{Size_is = [0]};
} with IDL{DoNotGenerate = true};

type _PRINTER_INFO_4_Fixed_Portion
{
    uint PrinterNameOffset;
    uint ServerNameOffset;
    PrinterAttribute Attributes;
    
    uint SizeIs()
    { return 12; }
} with IDL{DoNotGenerate = true};

type _PRINTER_INFO_4_Variable_Data[_PRINTER_INFO_4_Fixed_Portion Portion]
{
    optional [|Portion.ServerNameOffset > 0|] string ServerNameArray 
        with Encoding{Offset = Portion.ServerNameOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.PrinterNameOffset > 0|] string PrinterNameArray 
        with Encoding{Offset = Portion.PrinterNameOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
} with IDL{DoNotGenerate = true};

// 2.2.2.9.6 _PRINTER_INFO_5
type _PRINTER_INFO_5
{
    array<_PRINTER_INFO_5_Fixed_Portion> Fixed_Portion with IDL{Size_is = [0]};
    array<_PRINTER_INFO_5_Variable_Data> Variable_Data with IDL{Size_is = [0]};
} with IDL{DoNotGenerate = true};

type _PRINTER_INFO_5_Fixed_Portion
{
    uint PrinterNameOffset;
    uint PortNameOffset;
    PrinterAttribute Attributes;
    uint DeviceNotSelectedTimeout;
    uint TransmissionRetryTimeout;
    
    uint SizeIs()
    { return 20; }
} with IDL{DoNotGenerate = true};

type _PRINTER_INFO_5_Variable_Data[_PRINTER_INFO_5_Fixed_Portion Portion]
{
    optional [|Portion.PortNameOffset > 0|] string PortNameArray 
        with Encoding{Offset = Portion.PortNameOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.PrinterNameOffset > 0|] string PrinterNameArray 
        with Encoding{Offset = Portion.PrinterNameOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
} with IDL{DoNotGenerate = true};

// 2.2.2.9.7 _PRINTER_INFO_6
type _PRINTER_INFO_6
{
    array<_PRINTER_INFO_6_Fixed_Portion> Fixed_Portion with IDL{Size_is = [0]};
} with IDL{DoNotGenerate = true};

type _PRINTER_INFO_6_Fixed_Portion
{
    Printer_Status dwStatus;
} with IDL{DoNotGenerate = true};

// 2.2.2.9.8 _PRINTER_INFO_7
type _PRINTER_INFO_7
{
    array<_PRINTER_INFO_7_Fixed_Portion> Fixed_Portion with IDL{Size_is = [0]};
    array<_PRINTER_INFO_7_Variable_Data> Variable_Data with IDL{Size_is = [0]};
} with IDL{DoNotGenerate = true};

type _PRINTER_INFO_7_Fixed_Portion
{
    uint szObjectGUIDOffset;
    uint dwAction;
    
    uint SizeIs()
    { return 8; }
} with IDL{DoNotGenerate = true};

type _PRINTER_INFO_7_Variable_Data[_PRINTER_INFO_7_Fixed_Portion Portion]
{
    optional [|Portion.szObjectGUIDOffset > 0|] string szObjectGUIDArray 
        with Encoding{Offset = Portion.szObjectGUIDOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
} with IDL{DoNotGenerate = true};

// 2.2.2.9.9 _PRINTER_INFO_8
type _PRINTER_INFO_8
{
    array<_PRINTER_INFO_8_Fixed_Portion> Fixed_Portion with IDL{Size_is = [0]};
    array<_PRINTER_INFO_8_Variable_Data> Variable_Data with IDL{Size_is = [0]};
} with IDL{DoNotGenerate = true};

type _PRINTER_INFO_8_Fixed_Portion
{
    uint DevModeOffset;
    
    uint SizeIs()
    { return 4; }
} with IDL{DoNotGenerate = true};

type _PRINTER_INFO_8_Variable_Data[_PRINTER_INFO_8_Fixed_Portion Portion]
{
    optional [|Portion.DevModeOffset > 0|] string DevModeArray 
        with Encoding{Offset = Portion.DevModeOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
} with IDL{DoNotGenerate = true};

pattern Printer_Status = flags uint
{
    PRINTER_STATUS_BUSY = 0x00000200
        with Documentation{Description = "The printer is busy."},
    PRINTER_STATUS_DOOR_OPEN = 0x00400000
        with Documentation{Description = "The printer door is open."},
    PRINTER_STATUS_ERROR = 0x00000002
        with Documentation{Description = "The printer is in an error state."},
    PRINTER_STATUS_INITIALIZING = 0x00008000
        with Documentation{Description = "The printer is initializing."},
    PRINTER_STATUS_IO_ACTIVE = 0x00000100
        with Documentation{Description = "The printer is in an active input or output state."},
    PRINTER_STATUS_MANUAL_FEED = 0x00000020
        with Documentation{Description = "The printer is in a manual feed state."},
    PRINTER_STATUS_NOT_AVAILABLE = 0x00001000
        with Documentation{Description = "The printer is not available for printing."},
    PRINTER_STATUS_NO_TONER = 0x00040000
        with Documentation{Description = "The printer is out of toner."},
    PRINTER_STATUS_OFFLINE = 0x00000080
        with Documentation{Description = "The printer is offline."},
    PRINTER_STATUS_OUTPUT_BIN_FULL = 0x00000800
        with Documentation{Description = "The printer's output bin is full."},
    PRINTER_STATUS_OUT_OF_MEMORY = 0x00200000
        with Documentation{Description = "The printer has run out of memory."},
    PRINTER_STATUS_PAGE_PUNT = 0x00080000
        with Documentation{Description = "The printer cannot print the current page."},
    PRINTER_STATUS_PAPER_JAM = 0x00000008
        with Documentation{Description = "Paper is stuck in the printer."},
    PRINTER_STATUS_PAPER_OUT = 0x00000010
        with Documentation{Description = "The printer is out of paper."},
    PRINTER_STATUS_PAPER_PROBLEM = 0x00000040
        with Documentation{Description = "The printer has an unspecified paper problem."},
    PRINTER_STATUS_PAUSED = 0x00000001
        with Documentation{Description = "The printer is paused."},
    PRINTER_STATUS_PENDING_DELETION = 0x00000004
        with Documentation{Description = "The printer is being deleted as a result of a client's call to RpcDeletePrinter."},
    PRINTER_STATUS_POWER_SAVE = 0x01000000
        with Documentation{Description = "The printer is in power-save mode."},
    PRINTER_STATUS_PRINTING = 0x00000400
        with Documentation{Description = "The printer is printing."},
    PRINTER_STATUS_PROCESSING = 0x00004000
        with Documentation{Description = "The printer is processing a print job."},
    PRINTER_STATUS_SERVER_OFFLINE = 0x02000000
        with Documentation{Description = "The printer is offline."},
    PRINTER_STATUS_SERVER_UNKNOWN = 0x00800000
        with Documentation{Description = "The printer status is unknown."},
    PRINTER_STATUS_TONER_LOW = 0x00020000
        with Documentation{Description = "The printer is low on toner."},
    PRINTER_STATUS_USER_INTERVENTION = 0x00100000
        with Documentation{Description = "The printer has an error that requires the user to do something."},
    PRINTER_STATUS_WAITING = 0x00002000
        with Documentation{Description = "The printer is waiting."},
    PRINTER_STATUS_WARMING_UP = 0x00010000
        with Documentation{Description = "The printer is warming up."},
    ...
} with IDL{DoNotGenerate = true};

pattern PrinterAttribute = flags uint
{
    PRINTER_ATTRIBUTE_DEFAULT = 0x00000004
        with Documentation{Description = "Indicates the printer is the default printer in the system."},
    PRINTER_ATTRIBUTE_DIRECT = 0x00000002
        with Documentation{Description = "Job is sent directly to the printer (it is not spooled)."},
    PRINTER_ATTRIBUTE_DO_COMPLETE_FIRST = 0x00000200
        with Documentation{Description = "If set and printer is set for print-while-spooling, any jobs that have completed spooling are scheduled to print before jobs that have not completed spooling."},
    PRINTER_ATTRIBUTE_ENABLE_BIDI = 0x00000800
        with Documentation{Description = "Indicates whether bidirectional communications are enabled for the printer."},
    PRINTER_ATTRIBUTE_ENABLE_DEVQ = 0x00000080
        with Documentation{Description = "Setting this flag causes mismatched documents to be held in the queue."},
    PRINTER_ATTRIBUTE_FAX = 0x00004000
        with Documentation{Description = "If set, printer is a fax printer."},
    PRINTER_ATTRIBUTE_KEEPPRINTEDJOBS = 0x00000100
        with Documentation{Description = "If set, jobs are kept after they are printed."},
    PRINTER_ATTRIBUTE_LOCAL = 0x00000040
        with Documentation{Description = "Printer is a local printer."},
    PRINTER_ATTRIBUTE_NETWORK = 0x00000010
        with Documentation{Description = "Printer is a network printer connection."},
    PRINTER_ATTRIBUTE_PUBLISHED = 0x00002000
        with Documentation{Description = "Indicates whether the printer is published in the directory service (DS)."},
    PRINTER_ATTRIBUTE_QUEUED = 0x00000001
        with Documentation{Description = "If set, the printer spools and starts printing after the last page is spooled."},
    PRINTER_ATTRIBUTE_RAW_ONLY = 0x00001000
        with Documentation{Description = "Indicates that only RAW data type print jobs MUST be spooled."},
    PRINTER_ATTRIBUTE_SHARED = 0x00000008
        with Documentation{Description = "Printer is shared."},
    PRINTER_ATTRIBUTE_TS = 0x00008000
        with Documentation{Description = "Printer is a redirected terminal server printer."},
    PRINTER_ATTRIBUTE_WORK_OFFLINE = 0x00000400
        with Documentation{Description = "Indicates whether the printer is currently connected."},
    ...
} with IDL{DoNotGenerate = true};

// 2.2.2.10 PRINTPROCESSOR_INFO_1
type PRINTPROCESSOR_INFO_1
{
    array<PRINTPROCESSOR_INFO_1_Fixed_Portion> Fixed_Portion with IDL{Size_is = [0]};
    array<PRINTPROCESSOR_INFO_1_Variable_Data> Variable_Data with IDL{Size_is = [0]};
} with IDL{DoNotGenerate = true};

type PRINTPROCESSOR_INFO_1_Fixed_Portion
{
    uint NameOffset;
    
    uint SizeIs()
    { return 4; }
} with IDL{DoNotGenerate = true};

type PRINTPROCESSOR_INFO_1_Variable_Data[PRINTPROCESSOR_INFO_1_Fixed_Portion Portion]
{
    optional [|Portion.NameOffset > 0|] string NameArray 
        with Encoding{Offset = Portion.NameOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
} with IDL{DoNotGenerate = true};

// 2.2.2.11 PRINTER_ENUM_VALUES
type PRINTER_ENUM_VALUES
{
    array<PRINTER_ENUM_VALUES_Fixed_Portion> Fixed_Portion with IDL{Size_is = [0]};
    array<PRINTER_ENUM_VALUES_Variable_Data> Variable_Data with IDL{Size_is = [0]};
} with IDL{DoNotGenerate = true};

type PRINTER_ENUM_VALUES_Fixed_Portion
{
    uint ValueNameOffset;
    uint cbValueName;
    RegistryTypeValues dwType;
    uint DataOffset;
    uint cbData;
    
    uint SizeIs()
    { return 20; }
} with IDL{DoNotGenerate = true};

type PRINTER_ENUM_VALUES_Variable_Data[PRINTER_ENUM_VALUES_Fixed_Portion Portion]
{
    optional [|Portion.ValueNameOffset > 0|] string ValueNameArray 
        with Encoding{Offset = Portion.ValueNameOffset - Portion.SizeIs()}, BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|Portion.DataOffset > 0|] DynamicallyTypedQuery[Portion.dwType] DataArray
        with Encoding{Offset = Portion.DataOffset - Portion.SizeIs(), Size = Portion.cbData};
} with IDL{DoNotGenerate = true};

type UniversalFonts
{
    optional (ArrayByte | _UNIVERSAL_FONT_ID) Fonts with Encoding{Decoder = UniversalFontDecoder};

    optional (ArrayByte | _UNIVERSAL_FONT_ID) UniversalFontDecoder(stream s)
    {
        var arrayByte = NdrDecoder<ArrayByte>(s);
        if (arrayByte == nothing)
            return nothing;

        if (arrayByte is arr:ArrayByte && arr.Array.Count == 0)
            return arr;
            
        binary binData = arr.Array as binary;
        var fontId = BinaryDecoder<_UNIVERSAL_FONT_ID>(binData as stream);
        if (fontId == nothing)
            ValidationCheck(false, null, DiagnosisLevel.Error, 
                            Format(RPRN_GENERAL_DECODING_FAILURE, "_UNIVERSAL_FONT_ID", "UniversalFonts"));

        return fontId as _UNIVERSAL_FONT_ID;
    }
}

type _UNIVERSAL_FONT_ID
{
    uint Count;
    optional array<UNIVERSAL_FONT_ID> Fonts with BinaryEncoding{Length = Count as uint}, IDL{Size_is = [0]};
} with IDL{DoNotGenerate = true};

// 2.2.2.12 UNIVERSAL_FONT_ID
type UNIVERSAL_FONT_ID
{
    uint Checksum;
    uint Index;
} with IDL{DoNotGenerate = true};

// 2.2.2.13 CORE_PRINTER_DRIVER, IDL generated.

// 2.2.2.14.1 CONFIG_INFO_DATA_1
type CONFIG_INFO_DATA_1
{
    string PortName with BinaryEncoding{TextEncoding = TextEncoding.Unicode, WidthForComposedType = 128 * 8};
    uint Version where ValidationCheckValue(value == 1 || value == 2, null, true, ReferenceType.Type, 
                                            "RPRN", "Version", "CONFIG_INFO_DATA_1", "1, 2", value);
} with IDL{DoNotGenerate = true};

// 2.2.2.14.2 DELETE_PORT_DATA_1
type DELETE_PORT_DATA_1
{
    string PortName with BinaryEncoding{TextEncoding = TextEncoding.Unicode, WidthForComposedType = 128 * 8};
    string Name with BinaryEncoding{TextEncoding = TextEncoding.Unicode, WidthForComposedType  = 98 * 8};
    binary PaddingForAlignment with BinaryEncoding{Length = 2};
    uint Version where ValidationCheckValue(value == 1, null, true, ReferenceType.Type,
                                            "RPRN", "Version", "DELETE_PORT_DATA_1", 1, value);
    uint Reserved;
} with IDL{DoNotGenerate = true};

// 2.2.2.14.3 PORT_DATA_1
type PORT_DATA_1
{
    string PortName with BinaryEncoding{TextEncoding = TextEncoding.Unicode, WidthForComposedType = 128 * 8};
    uint Version where ValidationCheckValue(value == 1, null, true, ReferenceType.Type,
                                            "RPRN", "Version", "PORT_DATA_1", 1, value);
    PORT_DATA_Protocol Protocol 
        where ValidationCheckEnumValue(InRange<PORT_DATA_Protocol>(value), null, true, ReferenceType.Type, 
                                        "RPRN", "Protocol", "PORT_DATA_1", "0x00000001, 0x00000002", value);
    uint Size;
    uint Reserved;
    string HostAddress with BinaryEncoding{TextEncoding = TextEncoding.Unicode, WidthForComposedType = 98 * 8};
    string SNMPCommunity with BinaryEncoding{TextEncoding = TextEncoding.Unicode, WidthForComposedType = 66 * 8};
    uint DoubleSpool;
    string Queue with BinaryEncoding{TextEncoding = TextEncoding.Unicode, WidthForComposedType = 66 * 8};
    string IPAddress with BinaryEncoding{TextEncoding = TextEncoding.Unicode, WidthForComposedType = 32 * 8};
    string HardwareAddress with BinaryEncoding{TextEncoding = TextEncoding.Unicode, WidthForComposedType = 26 * 8};
    string DeviceType with BinaryEncoding{TextEncoding = TextEncoding.Unicode, WidthForComposedType = 514 * 8};
    binary PaddingForAlignment with BinaryEncoding{Length = 2};
    uint PortNumber;
    uint SNMPEnabled;
    uint SNMPDevIndex;
} with IDL{DoNotGenerate = true};

pattern PORT_DATA_Protocol = enum uint
{
    PROTOCOL_RAWTCP_TYPE = 0x00000001, // "The port expects RAW print data."
    PROTOCOL_LPR_TYPE = 0x00000002,    // "The port expects to be driven as an LPR port."
    ...
} with IDL{DoNotGenerate = true};

// 2.2.2.14.3 PORT_DATA_2
type PORT_DATA_2
{
    string PortName with BinaryEncoding{TextEncoding = TextEncoding.Unicode, WidthForComposedType = 128 * 8};
    uint Version where ValidationCheckValue(value == 1, null, true, ReferenceType.Type,
                                            "RPRN", "Version", "PORT_DATA_1", 1, value);
    PORT_DATA_Protocol Protocol
        where ValidationCheckEnumValue(InRange<PORT_DATA_Protocol>(value), null, true, ReferenceType.Type, 
                                        "RPRN", "Protocol", "PORT_DATA_2", "0x00000001, 0x00000002", value);
    uint Size;
    uint Reserved;
    string HostAddress with BinaryEncoding{TextEncoding = TextEncoding.Unicode, WidthForComposedType = 256 * 8};
    string SNMPCommunity with BinaryEncoding{TextEncoding = TextEncoding.Unicode, WidthForComposedType = 66 * 8};
    binary PaddingForAlignment with BinaryEncoding{Length = 2};
    uint DoubleSpool;
    string Queue with BinaryEncoding{TextEncoding = TextEncoding.Unicode, WidthForComposedType = 66 * 8};
    string DeviceType with BinaryEncoding{TextEncoding = TextEncoding.Unicode, WidthForComposedType = 514 * 8};
    uint PortNumber;
    uint SNMPEnabled;
    uint SNMPDevIndex;
    uint PortMonitorMibIndex;
} with IDL{DoNotGenerate = true};

// 2.2.2.14.5 PORT_DATA_LIST_1
type PORT_DATA_LIST_1
{
    uint Version;
    uint PortDataNum;
    array<PORT_DATA_2> PortData 
        with BinaryEncoding{Length = PortDataNum}, IDL{Size_is = [0]};
} with IDL{DoNotGenerate = true};

// 2.2.2.15.1 WSD_DRIVER_DATA
type WSD_DRIVER_DATA
{
    string IEEE1284Id with BinaryEncoding{TextEncoding = TextEncoding.Unicode, WidthForComposedType = 520 * 8};
    string ModelName with BinaryEncoding{TextEncoding = TextEncoding.Unicode, WidthForComposedType = 520 * 8};
} with IDL{DoNotGenerate = true};

// 2.2.2.15.2 WSD_BACKUP_PORT_DATA
type WSD_BACKUP_PORT_DATA
{
    WSD_BACKUP_PORT_DATA_DiscoveryMethod DiscoveryMethod;
    ([|DiscoveryMethod == 0|] string | binary) GlobalID 
        with BinaryEncoding{TextEncoding = TextEncoding.Unicode, WidthForComposedType = (DiscoveryMethod == 0 ? 2048 * 8 : 32)};
    ([|DiscoveryMethod == 1|] string | binary)  RemoteURL 
        with BinaryEncoding{TextEncoding = TextEncoding.Unicode, WidthForComposedType = (DiscoveryMethod == 1 ? 2048 * 8: 32)};
} with IDL{DoNotGenerate = true};

pattern WSD_BACKUP_PORT_DATA_DiscoveryMethod = enum uint
{
    kMulticast = 0x00000000, // The WSD port was initially discovered by using multicast discovery.
    kDirected = 0x00000001,  // The WSD port was initially discovered by using directed discovery.
    ...
} with IDL{DoNotGenerate = true};

// 2.2.2.15.3 WSD_BACKUP_PORT_DATA_EX
type WSD_BACKUP_PORT_DATA_EX
{
    WSD_BACKUP_PORT_DATA_DiscoveryMethod DiscoveryMethod;
    string GlobalID with BinaryEncoding{TextEncoding = TextEncoding.Unicode, WidthForComposedType = 2048 * 8};
    string ServiceID with BinaryEncoding{TextEncoding = TextEncoding.Unicode, WidthForComposedType = 2048 * 8};
    ([|DiscoveryMethod == 1|] string | binary)  RemoteURL 
        with BinaryEncoding{TextEncoding = TextEncoding.Unicode, WidthForComposedType = (DiscoveryMethod == 1 ? 2048 * 8 : 32)};
} with IDL{DoNotGenerate = true};

pattern DriverInfoLevel = enum DWORD
{
    _DRIVER_INFO_1 = 0x00000001,
    _DRIVER_INFO_2 = 0x00000002,
    _DRIVER_INFO_3 = 0x00000003,
    _DRIVER_INFO_4 = 0x00000004,
    _DRIVER_INFO_5 = 0x00000005,
    _DRIVER_INFO_6 = 0x00000006,
    _DRIVER_INFO_7 = 0x00000007,
    _DRIVER_INFO_8 = 0x00000008,
    _DRIVER_INFO_101 = 0x00000009,
    _DRIVER_FILE_INFO = 0x00000065,
    ...
} with IDL{DoNotGenerate = true};

pattern FormInfoLevel = enum DWORD
{
    _FORM_INFO_1 = 0x00000001,
    _FORM_INFO_2 = 0x00000002,
    ...
} with IDL{DoNotGenerate = true};

pattern JobInfoLevel = enum DWORD
{
    _JOB_INFO_1 = 0x00000001,
    _JOB_INFO_2 = 0x00000002,
    _JOB_INFO_3 = 0x00000003,
    _JOB_INFO_4 = 0x00000004,
    ...
} with IDL{DoNotGenerate = true};

pattern MonitorInfoLevel = enum DWORD
{
    _MONITOR_INFO_1 = 0x00000001,
    _MONITOR_INFO_2 = 0x00000002,
    ...
} with IDL{DoNotGenerate = true};

pattern PrinterInfoLevel = enum DWORD
{
    _PRINTER_INFO_STRESS = 0x00000000,
    _PRINTER_INFO_1 = 0x00000001,
    _PRINTER_INFO_2 = 0x00000002,
    _PRINTER_INFO_3 = 0x00000003,
    _PRINTER_INFO_4 = 0x00000004,
    _PRINTER_INFO_5 = 0x00000005,
    _PRINTER_INFO_6 = 0x00000006,
    _PRINTER_INFO_7 = 0x00000007,
    _PRINTER_INFO_8 = 0x00000008,
    NotSupported = 0x00000009,
    ...
} with IDL{DoNotGenerate = true};

pattern PortInfoLevel = enum DWORD
{
    _PORT_INFO_1 = 0x00000001,
    _PORT_INFO_2 = 0x00000002,
    ...
} with IDL{DoNotGenerate = true};

pattern InfoStructLevel = enum ushort
{
    UndefinedLevel = 0,
    _DRIVER_INFO_1 = 1,
    _DRIVER_INFO_2 = 2,
    _DRIVER_INFO_3 = 3,
    _DRIVER_INFO_4 = 4,
    _DRIVER_INFO_5 = 5,
    _DRIVER_INFO_6 = 6,
    _DRIVER_INFO_7 = 7,
    _DRIVER_INFO_8 = 8,
    _DRIVER_INFO_101 = 9,
    _DRIVER_FILE_INFO = 10,
    _FORM_INFO_1 = 11,
    _FORM_INFO_2 = 12,
    _JOB_INFO_1 = 13,
    _JOB_INFO_2 = 14,
    _JOB_INFO_3 = 15,
    _JOB_INFO_4 = 16,
    _MONITOR_INFO_1 = 17,
    _MONITOR_INFO_2 = 18,
    _PORT_INFO_1 = 19,
    _PORT_INFO_2 = 20,
    _PRINTER_INFO_STRESS = 21,
    _PRINTER_INFO_1 = 22,
    _PRINTER_INFO_2 = 23,
    _PRINTER_INFO_3 = 24,
    _PRINTER_INFO_4 = 25,
    _PRINTER_INFO_5 = 26,
    _PRINTER_INFO_6 = 27,
    _PRINTER_INFO_7 = 28,
    _PRINTER_INFO_8 = 29,
    PRINTPROCESSOR_INFO_1 = 30,
    _DATATYPES_INFO_1 = 31,
    PRINTER_ENUM_VALUES = 32,
    ...
};

// 2.2.3.1 Access Values
pattern AccessValuesFlags = flags DWORD
{
    SERVER_ACCESS_ADMINISTER    = 0x00000001
        with Documentation{Description = "Printing-specific access rights to administer print servers."},
    SERVER_ACCESS_ENUMERATE     = 0x00000002
        with Documentation{Description = "Printing-specific access rights to enumerate print servers."},
    PRINTER_ACCESS_ADMINISTER   = 0x00000004
        with Documentation{Description = "Printing-specific access rights for printers to perform administrative tasks."},
    PRINTER_ACCESS_USE          = 0x00000008
        with Documentation{Description = "Printing-specific access rights for printers to perform basic printing operations."},
    JOB_ACCESS_ADMINISTER       = 0x00000010
        with Documentation{Description = "Printing-specific authorization to cancel, pause, resume, or restart the job."},
    JOB_ACCESS_READ             = 0x00000020
        with Documentation{Description = "Printing-specific read rights for the spool file."},
    PRINTER_ACCESS_MANAGE_LIMITED = 0x00000040
        with Documentation{Description = "Printing-specific access rights for printers to perform printer data management operations."},
    DELETE                      = 0x00010000
        with Documentation{Description = "The right to delete an object, set to DE (Delete) of ACCESS_MASK."},
    READ_CONTROL                = 0x00020000
        with Documentation{Description = "The right to read the information in the object's security descriptor, not including the information in the system access control list (SACL), set to RC (Read Control) of ACCESS_MASK.},"},
    WRITE_DAC                   = 0x00040000
        with Documentation{Description = "The right to modify the discretionary access control list (DACL) in the object's security descriptor, set to WD (Write DACL) of ACCESS_MASK.},"},
    WRITE_OWNER                 = 0x00080000
        with Documentation{Description = "The right to change the owner in the object's security descriptor, set to WO (Write Owner) of ACCESS_MASK."},
    SYNCHRONIZE                 = 0x00100000
        with Documentation{Description = "The right to use the object for synchronization, set to SY (Synchronize) of ACCESS_MASK. This value MUST NOT be passed over the wire. If it is, the server SHOULD return ERROR_ACCESS_DENIED.},"},
    GENERIC_ALL                 = 0x10000000
        with Documentation{Description = "GA (Generic All) of ACCESS_MASK: For server object, access is mapped to SERVER_ALL_ACCESS."},
    GENERIC_EXECUTE             = 0x20000000
        with Documentation{Description = "GX (Generic Execute) of ACCESS_MASK: For server object, access is mapped to SERVER_EXECUTE."},
    GENERIC_WRITE               = 0x40000000
        with Documentation{Description = "GW (Generic Write) of ACCESS_MASK: For server object, access is mapped to SERVER_WRITE."},
    GENERIC_READ                = 0x80000000
        with Documentation{Description = "GR (Generic Read) of ACCESS_MASK: For server object, access is mapped to SERVER_READ."},
    ...
} with IDL{DoNotGenerate = true}, Documentation{Ignore = true},
    Encoding{EncodingKind = EncodingKind.Binary};
