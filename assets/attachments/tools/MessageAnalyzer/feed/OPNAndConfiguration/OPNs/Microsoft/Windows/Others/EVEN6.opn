protocol EVEN6 with
Documentation
{
    ProtocolName = "EventLog Remoting Protocol Version 6.0",
    ProtocolType = "rpc",
    ShortName = "EVEN6",
    DocumentName = "MS-EVEN6",
    Description = ""
},
OPNAuthoring
{
    Copyright = "(c) Microsoft Corporation",
    References = 
    [
    new Reference{Name = "MS-EVEN6", Version = "18.0", Date = "05/15/2014"}
    ]
};

using Technologies.IDL;
using DTYP;
using MSRPCE;
using ERREF;
using Utility;

const int SizeOfWchar = 2;
const int SizeOfBool = 4;
const int SizeOfUint32 = 4;
const int SizeOfUint64 = 8;
const int SizeOfGuid = 16;
const int MAX_RPC_CHANNEL_NAME_LENGTH = 512;
const int MAX_PAYLOAD = 2097152;
const int MAX_RPC_QUERY_LENGTH = MAX_PAYLOAD / SizeOfWchar;
const int MAX_RPC_BOOKMARK_LENGTH = MAX_PAYLOAD / SizeOfWchar;
const int MAX_RPC_QUERY_CHANNEL_SIZE = 512;
const int MAX_RPC_RECORD_COUNT = 1024;
const int MAX_RPC_BATCH_SIZE = MAX_PAYLOAD;
const int MAX_RPC_CHANNEL_PATH_LENGTH = 32768;
const int MAX_RPC_FILE_PATH_LENGTH = 32768;
const int MAX_RPC_EVENT_ID_SIZE = 256;
const int MAX_RPC_RENDERED_STRING_SIZE = MAX_PAYLOAD;
const int MAX_RPC_PROPERTY_BUFFER_SIZE = MAX_PAYLOAD;
const int MAX_RPC_CHANNEL_COUNT = 8192;
const int MAX_RPC_PUBLISHER_COUNT = 8192;
const int MAX_RPC_PUBLISHER_ID_LENGTH = 2048;
const int MAX_RPC_FILTER_LENGTH = MAX_RPC_QUERY_LENGTH;
const int MAX_RPC_EVENT_METADATA_COUNT = 256;
const int MAX_RPC_VARIANT_LIST_COUNT = 256;
const int MAX_RPC_BOOL_ARRAY_COUNT = MAX_PAYLOAD / SizeOfBool;
const int MAX_RPC_UINT32_ARRAY_COUNT = MAX_PAYLOAD / SizeOfUint32;
const int MAX_RPC_UINT64_ARRAY_COUNT = MAX_PAYLOAD / SizeOfUint64;
const int MAX_RPC_STRING_ARRAY_COUNT = MAX_PAYLOAD / 512;
const int MAX_RPC_GUID_ARRAY_COUNT = MAX_PAYLOAD / SizeOfGuid;

endpoint Eventlog over MSRPCE.Server provides IEventService;

contract IEventService
{
    accepts operation EvtRpcRegisterRemoteSubscription
    {
        in string channelPath with Technologies.IDL.IDL
            {
                Range = new RangePattern{Low = 0, High = MAX_RPC_CHANNEL_NAME_LENGTH},
                PointerType = PointerKind.UniquePtr,
                BaseStringType = TypeOf<wchar_t>(),
                String = true,
                IndirectionLevel = 1
            };
        in string query with Technologies.IDL.IDL
            {
                Range = new RangePattern{Low = 1, High = MAX_RPC_QUERY_LENGTH},
                BaseStringType = TypeOf<wchar_t>(),
                String = true,
                IndirectionLevel = 1
            };
        in string bookmarkXml with Technologies.IDL.IDL
            {
                Range = new RangePattern{Low = 0, High = MAX_RPC_BOOKMARK_LENGTH},
                PointerType = PointerKind.UniquePtr,
                BaseStringType = TypeOf<wchar_t>(),
                String = true,
                IndirectionLevel = 1
            };
        in EvtRpcRegisterRemoteSubscriptionFlags $"flags" with Encoding{Decoder = EvtRpcRegisterRemoteSubscriptionFlagsDecoder, SourcePattern = TypeOf<DWORD>()};
        out PCONTEXT_HANDLE_REMOTE_SUBSCRIPTION handle with Technologies.IDL.IDL{Context_handle = true, IndirectionLevel = 1};
        out PCONTEXT_HANDLE_OPERATION_CONTROL control with Technologies.IDL.IDL{Context_handle = true, IndirectionLevel = 1};
        out DWORD queryChannelInfoSize with Technologies.IDL.IDL{IndirectionLevel = 1};
        out array<EvtRpcQueryChannelInfo> queryChannelInfo with Technologies.IDL.IDL
            {
                Size_is = [null, queryChannelInfoSize],
                Range = new RangePattern{Low = 0, High = MAX_RPC_QUERY_CHANNEL_SIZE},
                IndirectionLevel = 2
            };
        out RpcInfo $"error" with Technologies.IDL.IDL{IndirectionLevel = 1};
        result error_status_t ReturnValue;
        
        override string ToString()
        {
            return "EvtRpcRegisterRemoteSubscription" + ", ReturnValue: " + Win32ErrorCodesToText(ReturnValue) + ", channelPath: " +
                channelPath.ToString() + ", query: " + query.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 0};

    accepts operation EvtRpcRemoteSubscriptionNextAsync
    {
        in PCONTEXT_HANDLE_REMOTE_SUBSCRIPTION handle with Technologies.IDL.IDL{Context_handle = true};
        in DWORD numRequestedRecords;
        in DWORD $"flags" where ValidationCheckReservedZero(value == 0, this, true, ReferenceType.Message, "EVEN6", "flags", "EvtRpcRemoteSubscriptionNextAsync", value);
        out DWORD numActualRecords with Technologies.IDL.IDL{IndirectionLevel = 1};
        out array<DWORD> eventDataIndices with Technologies.IDL.IDL
            {
                Size_is = [null, numActualRecords],
                Range = new RangePattern{Low = 0, High = MAX_RPC_RECORD_COUNT},
                IndirectionLevel = 2
            };
        out array<DWORD> eventDataSizes with Technologies.IDL.IDL
            {
                Size_is = [null, numActualRecords],
                Range = new RangePattern{Low = 0, High = MAX_RPC_RECORD_COUNT},
                IndirectionLevel = 2
            };
        out DWORD resultBufferSize with Technologies.IDL.IDL{IndirectionLevel = 1};
        out array<ResultSet> resultBuffer with Encoding{Decoder = ResultBufferDecoder, SourcePattern = TypeOf<array<byte>>()},
            Technologies.IDL.IDL
            {
                Size_is = [null, resultBufferSize],
                Range = new RangePattern{Low = 0, High = MAX_RPC_BATCH_SIZE},
                IndirectionLevel = 2
            }; // BinXml
        result error_status_t ReturnValue;
        
        override string ToString()
        {
            return "EvtRpcRemoteSubscriptionNextAsync" + ", ReturnValue: " + Win32ErrorCodesToText(ReturnValue) + 
                ", numRequestedRecords: " + numRequestedRecords.ToString() + ", numActualRecords: " + numActualRecords.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 1};
    
    accepts operation EvtRpcRemoteSubscriptionNext
    {
        in PCONTEXT_HANDLE_REMOTE_SUBSCRIPTION handle with Technologies.IDL.IDL{Context_handle = true};
        in DWORD numRequestedRecords;
        in DWORD timeOut;
        in DWORD $"flags" where ValidationCheckReservedZero(value == 0, this, true, ReferenceType.Message, "EVEN6", "flags", "EvtRpcRemoteSubscriptionNext", value);
        out DWORD numActualRecords with Technologies.IDL.IDL{IndirectionLevel = 1};
        out array<DWORD> eventDataIndices with Technologies.IDL.IDL
            {
                Size_is = [null, numActualRecords],
                Range = new RangePattern{Low = 0, High = MAX_RPC_RECORD_COUNT},
                IndirectionLevel = 2
            };
        out array<DWORD> eventDataSizes with Technologies.IDL.IDL
            {
                Size_is = [null, numActualRecords],
                Range = new RangePattern{Low = 0, High = MAX_RPC_RECORD_COUNT},
                IndirectionLevel = 2
            };
        out DWORD resultBufferSize with Technologies.IDL.IDL{IndirectionLevel = 1};
        out array<ResultSet> resultBuffer with Encoding{Decoder = ResultBufferDecoder, SourcePattern = TypeOf<array<byte>>()},
            Technologies.IDL.IDL
            {
                Size_is = [null, resultBufferSize],
                Range = new RangePattern{Low = 0, High = MAX_RPC_BATCH_SIZE},
                IndirectionLevel = 2
            }; // BinXml
        result error_status_t ReturnValue;
        
        override string ToString()
        {
            return "EvtRpcRemoteSubscriptionNext" + ", ReturnValue: " + Win32ErrorCodesToText(ReturnValue) + ", numRequestedRecords: " + 
                numRequestedRecords.ToString() + ", timeOut: " + timeOut.ToString() + ", numActualRecords: " + numActualRecords.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 2};
    
    accepts operation EvtRpcRemoteSubscriptionWaitAsync
    {
        in PCONTEXT_HANDLE_REMOTE_SUBSCRIPTION handle with Technologies.IDL.IDL{Context_handle = true};
        result error_status_t ReturnValue;
        
        override string ToString()
        {
            return "EvtRpcRemoteSubscriptionWaitAsync" + ", ReturnValue: " + Win32ErrorCodesToText(ReturnValue);
        }
    }
    with Technologies.IDL.IDL{Opnum = 3};
    
    accepts operation EvtRpcRegisterControllableOperation
    {
        out PCONTEXT_HANDLE_OPERATION_CONTROL handle with Technologies.IDL.IDL {Context_handle = true, IndirectionLevel = 1};
        result error_status_t ReturnValue;
        
        override string ToString()
        {
            return "EvtRpcRegisterControllableOperation" + ", ReturnValue: " + Win32ErrorCodesToText(ReturnValue);
        }
    }
    with Technologies.IDL.IDL{Opnum = 4};
    
    accepts operation EvtRpcRegisterLogQuery
    {
        in string path with Technologies.IDL.IDL
            {
                Range = new RangePattern{Low = 0, High = MAX_RPC_CHANNEL_PATH_LENGTH},
                PointerType = PointerKind.UniquePtr,
                BaseStringType = TypeOf<wchar_t>(),
                String = true,
                IndirectionLevel = 1
            };
        in string query with Technologies.IDL.IDL
            {
                Range = new RangePattern{Low = 1, High = MAX_RPC_QUERY_LENGTH},
                BaseStringType = TypeOf<wchar_t>(),
                String = true,
                IndirectionLevel = 1
            };

        in EvtRpcRegisterLogQueryFlag $"flags" where ValidationCheckEnumValue(InRange<EvtRpcRegisterLogQueryFlag>(value), this, true, 
            ReferenceType.Message, "EVEN6", "flags", "EvtRpcRegisterLogQueryFlag", "0x00000001, 0x00000002, 0x00000100, 0x00000200, 0x00001000", value)
            with Encoding{Decoder = PatternDecoder<EvtRpcRegisterLogQueryFlag>, SourcePattern = TypeOf<DWORD>()};
        out PCONTEXT_HANDLE_LOG_QUERY handle with Technologies.IDL.IDL{Context_handle = true, IndirectionLevel = 1};
        out PCONTEXT_HANDLE_OPERATION_CONTROL opControl with Technologies.IDL.IDL{Context_handle = true, IndirectionLevel = 1};
        out DWORD queryChannelInfoSize with Technologies.IDL.IDL{IndirectionLevel = 1};
        out array<EvtRpcQueryChannelInfo> queryChannelInfo with Technologies.IDL.IDL
            {
                Size_is = [null, queryChannelInfoSize],
                Range = new RangePattern{Low = 0, High = MAX_RPC_QUERY_CHANNEL_SIZE},
                IndirectionLevel = 2
            };
        out RpcInfo $"error" with Technologies.IDL.IDL{IndirectionLevel = 1};
        result error_status_t ReturnValue;
        
        override string ToString()
        {
            return "EvtRpcRegisterLogQuery" + ", ReturnValue: " + Win32ErrorCodesToText(ReturnValue) + ", path: " + path.ToString() + 
                ", query: " + query.ToString() + ", flags: " + EnumToStringInSummary<EVEN6.EvtRpcRegisterLogQueryFlag>($"flags") +
                ", queryChannelInfoSize: " + queryChannelInfoSize.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 5};
    
    accepts operation EvtRpcClearLog
    {
        in PCONTEXT_HANDLE_OPERATION_CONTROL control with Technologies.IDL.IDL{Context_handle = true};
        in string channelPath with Technologies.IDL.IDL
            {
                Range = new RangePattern{Low = 0, High = MAX_RPC_CHANNEL_NAME_LENGTH},
                BaseStringType = TypeOf<wchar_t>(),
                String = true,
                IndirectionLevel = 1
            };
        in string backupPath with Technologies.IDL.IDL
            {
                Range = new RangePattern{Low = 0, High = MAX_RPC_FILE_PATH_LENGTH},
                PointerType = PointerKind.UniquePtr,
                BaseStringType = TypeOf<wchar_t>(),
                String = true,
                IndirectionLevel = 1
            };
        in DWORD $"flags" where ValidationCheckReservedZero(value == 0, this, true, ReferenceType.Message, "EVEN6", "flags", "EvtRpcClearLog", value);
        out RpcInfo $"error" with Technologies.IDL.IDL{IndirectionLevel = 1};
        result error_status_t ReturnValue;
        
        override string ToString()
        {
            return "EvtRpcClearLog" + ", ReturnValue: " + Win32ErrorCodesToText(ReturnValue) + ", channelPath: " + 
                channelPath.ToString() + ", backupPath: " + backupPath.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 6};
    
    accepts operation EvtRpcExportLog
    {
        in PCONTEXT_HANDLE_OPERATION_CONTROL control with Technologies.IDL.IDL{Context_handle = true};
        in string channelPath with Technologies.IDL.IDL
            {
                Range = new RangePattern{Low = 0, High = MAX_RPC_CHANNEL_NAME_LENGTH},
                PointerType = PointerKind.UniquePtr,
                BaseStringType = TypeOf<wchar_t>(),
                String = true,
                IndirectionLevel = 1
            };
        in string query with Technologies.IDL.IDL
            {
                Range = new RangePattern{Low = 1, High = MAX_RPC_QUERY_LENGTH},
                BaseStringType = TypeOf<wchar_t>(),
                String = true,
                IndirectionLevel = 1
            };
        in string backupPath with Technologies.IDL.IDL
            {
                Range = new RangePattern{Low = 1, High = MAX_RPC_FILE_PATH_LENGTH},
                BaseStringType = TypeOf<wchar_t>(),
                String = true,
                IndirectionLevel = 1
            };
        in EvtRpcExportLogFlags $"flags" where ValidationCheckEnumValue(InRange<EvtRpcExportLogFlags>(value), this, true, 
            ReferenceType.Message, "EVEN6", "flags", "EvtRpcExportLogFlags", "0x00000001, 0x00000002, 0x00001000", value)
            with Encoding{Decoder = PatternDecoder<EvtRpcExportLogFlags>, SourcePattern = TypeOf<DWORD>()};
        out RpcInfo $"error" with Technologies.IDL.IDL{IndirectionLevel = 1};
        result error_status_t ReturnValue;
        
        override string ToString()
        {
            return "EvtRpcExportLog" + ", ReturnValue: " + Win32ErrorCodesToText(ReturnValue) + ", channelPath: " + channelPath.ToString() + ", query: " + 
                query.ToString() + ", backupPath: " + backupPath.ToString() + ", flags: " + EnumToStringInSummary<EVEN6.EvtRpcExportLogFlags>($"flags");
        }
    }
    with Technologies.IDL.IDL{Opnum = 7};
    
    accepts operation EvtRpcLocalizeExportLog
    {
        in PCONTEXT_HANDLE_OPERATION_CONTROL control with Technologies.IDL.IDL{Context_handle = true};
        in string logFilePath with Technologies.IDL.IDL
            {
                Range = new RangePattern{Low = 1, High = MAX_RPC_FILE_PATH_LENGTH},
                BaseStringType = TypeOf<wchar_t>(),
                String = true,
                IndirectionLevel = 1
            };
        in LCID locale with Encoding{Decoder = BinaryDecoder<LCID>, SourceConverter = (DWORD val) => (val.ToBinary() as optional binary), SourcePattern = TypeOf<DWORD>()};
        in DWORD $"flags" where ValidationCheckReservedZero(value == 0, this, true, ReferenceType.Message, "EVEN6", "flags", "EvtRpcLocalizeExportLog", value);
        out RpcInfo $"error" with Technologies.IDL.IDL{IndirectionLevel = 1};
        result error_status_t ReturnValue;
        
        override string ToString()
        {
            return "EvtRpcLocalizeExportLog" + ", ReturnValue: " + Win32ErrorCodesToText(ReturnValue) + ", logFilePath: " + logFilePath.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 8};
    
    accepts operation EvtRpcMessageRender
    {
        in PCONTEXT_HANDLE_PUBLISHER_METADATA pubCfgObj with Technologies.IDL.IDL{Context_handle = true};
        in DWORD sizeEventId with Technologies.IDL.IDL {Range = new RangePattern{Low = 1, High = MAX_RPC_EVENT_ID_SIZE}};
        in EVENT_DESCRIPTOR eventId with Encoding{Decoder = BinaryDecoder<EVENT_DESCRIPTOR>, SourcePattern = TypeOf<array<BYTE>>()},
            Technologies.IDL.IDL {Size_is = [sizeEventId], IndirectionLevel = 1};
        in DWORD messageId;
        in EvtRpcVariantList values with Technologies.IDL.IDL{IndirectionLevel = 1};
        in EvtRpcMessageRenderFlags $"flags" where ValidationCheckEnumValueTooManyItems(InRange<EvtRpcMessageRenderFlags>(value), this, true, 
            ReferenceType.Message, "EVEN6", "flags", "EvtRpcMessageRender", "EvtRpcMessageRender", "EVEN6")
            with Encoding{Decoder = PatternDecoder<EvtRpcMessageRenderFlags>, SourcePattern = TypeOf<DWORD>()};
        in DWORD maxSizeString;
        out DWORD actualSizeString with Technologies.IDL.IDL{IndirectionLevel = 1};
        out DWORD neededSizeString with Technologies.IDL.IDL{IndirectionLevel = 1};
        out string $"string" with Encoding{Decoder = BinaryDecoder<string>, SourcePattern = TypeOf<array<BYTE>>()},
            Technologies.IDL.IDL
            {
                Size_is = [null, actualSizeString],
                Range = new RangePattern{Low = 0, High = MAX_RPC_RENDERED_STRING_SIZE},
                IndirectionLevel = 2
            };
        out RpcInfo $"error" with Technologies.IDL.IDL{IndirectionLevel = 1};
        result error_status_t ReturnValue;
        
        override string ToString()
        {
            return "EvtRpcMessageRender" + ", ReturnValue: " + Win32ErrorCodesToText(ReturnValue) + ", messageId: " + 
                messageId.ToString() + ", flags: " + EnumToStringInSummary<EVEN6.EvtRpcMessageRenderFlags>($"flags");
        }
    }
    with Technologies.IDL.IDL{Opnum = 9};
    
    accepts operation EvtRpcMessageRenderDefault
    {
        in optional handle_t IDL_handle;
        in DWORD sizeEventId with Technologies.IDL.IDL{Range = new RangePattern{Low = 1, High = MAX_RPC_EVENT_ID_SIZE}};
        in EVENT_DESCRIPTOR eventId with Encoding{Decoder = BinaryDecoder<EVENT_DESCRIPTOR>, SourcePattern = TypeOf<array<BYTE>>()}, Technologies.IDL.IDL{Size_is = [sizeEventId], IndirectionLevel = 1}; // EVENT_DESCRIPTOR structure
        in DWORD messageId;
        in EvtRpcVariantList values with Technologies.IDL.IDL{IndirectionLevel = 1};
        in EvtRpcMessageRenderDefaultFlags $"flags" where ValidationCheckEnumValueTooManyItems(InRange<EvtRpcMessageRenderDefaultFlags>(value), this, true, 
            ReferenceType.Message, "EVEN6", "flags", "EvtRpcMessageRenderDefault", "EvtRpcMessageRenderDefault", "EVEN6")
            with Encoding{Decoder = PatternDecoder<EvtRpcMessageRenderDefaultFlags>, SourcePattern = TypeOf<DWORD>()};
        in DWORD maxSizeString;
        out DWORD actualSizeString with Technologies.IDL.IDL{IndirectionLevel = 1};
        out DWORD neededSizeString with Technologies.IDL.IDL{IndirectionLevel = 1};
        out array<string> $"string" with Encoding{Decoder = BinaryDecoder<array<string>>, SourcePattern = TypeOf<array<BYTE>>()},
            Technologies.IDL.IDL
            {
                Size_is = [null, actualSizeString],
                Range = new RangePattern{Low = 0, High = MAX_RPC_RENDERED_STRING_SIZE},
                IndirectionLevel = 2
            };
        out RpcInfo $"error" with Technologies.IDL.IDL{IndirectionLevel = 1};
        result error_status_t ReturnValue;
        
        override string ToString()
        {
            return "EvtRpcMessageRenderDefault" + ", ReturnValue: " + Win32ErrorCodesToText(ReturnValue) + ", messageId: " + messageId.ToString() + 
                ", values: " + values.ToString() + ", flags: " + EnumToStringInSummary<EVEN6.EvtRpcMessageRenderDefaultFlags>($"flags");
        }
    }
    with Technologies.IDL.IDL{Opnum = 10};
    
    accepts operation EvtRpcQueryNext
    {
        in PCONTEXT_HANDLE_LOG_QUERY logQuery with Technologies.IDL.IDL{Context_handle = true};
        in DWORD numRequestedRecords;
        in DWORD timeOutEnd;
        in DWORD $"flags" where ValidationCheckReservedZero(value == 0, this, true, ReferenceType.Message, "EVEN6", "flags", "EvtRpcQueryNext", value);
        out DWORD numActualRecords with Technologies.IDL.IDL{IndirectionLevel = 1};
        out array<DWORD> eventDataIndices with Technologies.IDL.IDL
            {
                Size_is = [null, numActualRecords],
                Range = new RangePattern{Low = 0, High = MAX_RPC_RECORD_COUNT},
                IndirectionLevel = 2
            };
        out array<DWORD> eventDataSizes with Technologies.IDL.IDL
            {
                Size_is = [null, numActualRecords],
                Range = new RangePattern{Low = 0, High = MAX_RPC_RECORD_COUNT},
                IndirectionLevel = 2
            };
        out DWORD resultBufferSize with Technologies.IDL.IDL{IndirectionLevel = 1};

        // bug#81579:[PEF Codec] Compile error when using a method defined in an operation as the decoder for Encoding Aspect.
        // future reference: use informations in fields eventDataIndices and eventDataSizes to decode this field;
        out array<ResultSet> resultBuffer with Encoding{Decoder = ResultBufferDecoder, SourcePattern = TypeOf<array<byte>>()},
            Technologies.IDL.IDL
            {
                Size_is = [null, resultBufferSize],
                Range = new RangePattern{Low = 0, High = MAX_RPC_BATCH_SIZE},
                IndirectionLevel = 2
            }; // BinXml
        result error_status_t ReturnValue;

        override string ToString()
        {
            return "EvtRpcQueryNext" + ", ReturnValue: " + Win32ErrorCodesToText(ReturnValue) + ", numRequestedRecords: " + numRequestedRecords.ToString() +
                ", timeOutEnd: " + timeOutEnd.ToString() + ", numActualRecords: " + numActualRecords.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 11};
    
    accepts operation EvtRpcQuerySeek
    {
        in PCONTEXT_HANDLE_LOG_QUERY logQuery with Technologies.IDL.IDL{Context_handle = true};
        in __int64 pos;
        in string bookmarkXml with Technologies.IDL.IDL
            {
                Range = new RangePattern{Low = 0, High = MAX_RPC_BOOKMARK_LENGTH},
                PointerType = PointerKind.UniquePtr,
                BaseStringType = TypeOf<wchar_t>(),
                String = true,
                IndirectionLevel = 1
            };
        in DWORD timeOut;
        in EvtRpcQuerySeekFlags $"flags" with Encoding{Decoder = EvtRpcQuerySeekFlagsDecoder, SourcePattern = TypeOf<DWORD>()};
        out RpcInfo $"error" with Technologies.IDL.IDL{IndirectionLevel = 1};
        result error_status_t ReturnValue;
        
        override string ToString()
        {
            return "EvtRpcQuerySeek" + ", ReturnValue: " + Win32ErrorCodesToText(ReturnValue) + ", pos: " + pos.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 12};
    
    accepts operation EvtRpcClose
    {
        in out ContextHandle handle with Technologies.IDL.IDL{IndirectionLevel = 1};
        result error_status_t ReturnValue;
        
        override string ToString()
        {
            return "EvtRpcClose" + ", ReturnValue: " + Win32ErrorCodesToText(ReturnValue);
        }
    }
    with Technologies.IDL.IDL{Opnum = 13};
    
    accepts operation EvtRpcCancel
    {
        in PCONTEXT_HANDLE_OPERATION_CONTROL handle with Technologies.IDL.IDL{Context_handle = true};
        result error_status_t ReturnValue;
        
        override string ToString()
        {
            return "EvtRpcCancel" + ", ReturnValue: " + Win32ErrorCodesToText(ReturnValue);
        }
    }
    with Technologies.IDL.IDL{Opnum = 14};
    
    accepts operation EvtRpcAssertConfig
    {
        in optional handle_t IDL_handle;
        in string path with Technologies.IDL.IDL
            {
                Range = new RangePattern{Low = 1, High = MAX_RPC_CHANNEL_NAME_LENGTH},
                BaseStringType = TypeOf<wchar_t>(),
                String = true,
                IndirectionLevel = 1
            };
        in EvtRpcAssertConfigFlags $"flags" where ValidationCheckEnumValue(InRange<EvtRpcAssertConfigFlags>(value), this, true, 
            ReferenceType.Message, "EVEN6", "flags", "EvtRpcAssertConfig", "0x00000000, 0x00000001", value)
            with Encoding{Decoder = PatternDecoder<EvtRpcAssertConfigFlags>, SourcePattern = TypeOf<DWORD>()};
        result error_status_t ReturnValue;
        
        override string ToString()
        {
            return "EvtRpcAssertConfig" + ", ReturnValue: " + Win32ErrorCodesToText(ReturnValue) + ", path: " + path.ToString() +
                ", flags: " + EnumToStringInSummary<EVEN6.EvtRpcAssertConfigFlags>($"flags");
        }
    }
    with Technologies.IDL.IDL{Opnum = 15};
    
    accepts operation EvtRpcRetractConfig
    {
        in optional handle_t IDL_handle;
        in string path with Technologies.IDL.IDL
            {
                Range = new RangePattern{Low = 1, High = MAX_RPC_CHANNEL_NAME_LENGTH},
                BaseStringType = TypeOf<wchar_t>(),
                String = true,
                IndirectionLevel = 1
            };
        in EvtRpcRetractConfigFlags $"flags" where ValidationCheckEnumValue(InRange<EvtRpcRetractConfigFlags>(value), this, true, 
            ReferenceType.Message, "EVEN6", "flags", "EvtRpcRetractConfig", "0x00000000, 0x00000001", value)
            with Encoding{Decoder = PatternDecoder<EvtRpcRetractConfigFlags>, SourcePattern = TypeOf<DWORD>()};
        result error_status_t ReturnValue;
        
        override string ToString()
        {
            return "EvtRpcRetractConfig" + ", ReturnValue: " + Win32ErrorCodesToText(ReturnValue) + ", path: " + path.ToString() +
                ", flags: " + EnumToStringInSummary<EVEN6.EvtRpcRetractConfigFlags>($"flags");
        }
    }
    with Technologies.IDL.IDL{Opnum = 16};
    
    accepts operation EvtRpcOpenLogHandle
    {
        in string channel with Technologies.IDL.IDL
            {
                Range = new RangePattern{Low = 1, High = MAX_RPC_CHANNEL_NAME_LENGTH},
                BaseStringType = TypeOf<wchar_t>(),
                String = true,
                IndirectionLevel = 1
            };
        in EvtRpcOpenLogHandleFlags $"flags" where ValidationCheckEnumValue(InRange<EvtRpcOpenLogHandleFlags>(value), this, true, 
            ReferenceType.Message, "EVEN6", "flags", "EvtRpcOpenLogHandle", "0x00000001, 0x00000002", value)
            with Encoding{Decoder = PatternDecoder<EvtRpcOpenLogHandleFlags>, SourcePattern = TypeOf<DWORD>()};
        out PCONTEXT_HANDLE_LOG_HANDLE handle with Technologies.IDL.IDL{Context_handle = true, IndirectionLevel = 1};
        out RpcInfo $"error" with Technologies.IDL.IDL{IndirectionLevel = 1};
        result error_status_t ReturnValue;
        
        override string ToString()
        {
            return "EvtRpcOpenLogHandle" + ", ReturnValue: " + Win32ErrorCodesToText(ReturnValue) + ", channel: " + channel.ToString() +
                ", flags: " + EnumToStringInSummary<EVEN6.EvtRpcOpenLogHandleFlags>($"flags");
        }
    }
    with Technologies.IDL.IDL{Opnum = 17};
    
    accepts operation EvtRpcGetLogFileInfo
    {
        in PCONTEXT_HANDLE_LOG_HANDLE logHandle with Technologies.IDL.IDL{Context_handle = true};
        in PropertyIdType propertyId where ValidationCheckEnumValueTooManyItems(InRange<PropertyIdType>(value), this, true, 
            ReferenceType.Message, "EVEN6", "propertyId", "EvtRpcGetLogFileInfo", "EvtRpcGetLogFileInfo", "EVEN6")
            with Encoding{Decoder = PatternDecoder<PropertyIdType>, SourcePattern = TypeOf<DWORD>()};
        in DWORD propertyValueBufferSize with Technologies.IDL.IDL{Range = new RangePattern{Low = 0, High = MAX_RPC_PROPERTY_BUFFER_SIZE}};
        out BinXmlVariant propertyValueBuffer with Encoding{Decoder = BinaryDecoder<BinXmlVariant>, SourcePattern = TypeOf<array<byte>>()}
            with Technologies.IDL.IDL{Size_is = [propertyValueBufferSize], IndirectionLevel = 1};
        out DWORD propertyValueBufferLength with Technologies.IDL.IDL{IndirectionLevel = 1};
        result error_status_t ReturnValue;
        
        override string ToString()
        {
            return "EvtRpcGetLogFileInfo" + ", ReturnValue: " + Win32ErrorCodesToText(ReturnValue) + ", propertyId: " +
                EnumToStringInSummary<EVEN6.PropertyIdType>(propertyId) + ", propertyValueBufferSize: " + propertyValueBufferSize.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 18};

    accepts operation EvtRpcGetChannelList
    {
        in optional handle_t IDL_handle;
        in DWORD $"flags" where ValidationCheckReservedZero(value == 0, this, true, ReferenceType.Message, "EVEN6", "flags", "EvtRpcGetChannelList", value);
        out DWORD numChannelPaths with Technologies.IDL.IDL{IndirectionLevel = 1};
        out array<string> channelPaths with Technologies.IDL.IDL
            {
                Size_is = [null, numChannelPaths, null],
                Range = new RangePattern{Low = 0, High = MAX_RPC_CHANNEL_COUNT},
                BaseStringType = TypeOf<wchar_t>(),
                String = true,
                IndirectionLevel = 3
            };
        result error_status_t ReturnValue;
        
        override string ToString()
        {
            return "EvtRpcGetChannelList" + ", ReturnValue: " + Win32ErrorCodesToText(ReturnValue) + ", numChannelPaths: " + numChannelPaths.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 19};

    accepts operation EvtRpcGetChannelConfig
    {
        in optional handle_t IDL_handle;
        in string channelPath with Technologies.IDL.IDL
            {
                Range = new RangePattern{Low = 1, High = MAX_RPC_CHANNEL_NAME_LENGTH},
                BaseStringType = TypeOf<wchar_t>(),
                String = true,
                IndirectionLevel = 1
            };
        in DWORD $"flags" where ValidationCheckReservedZero(value == 0, this, true, ReferenceType.Message, "EVEN6", "flags", "EvtRpcGetChannelConfig", value);
        out EvtRpcVariantList props with Technologies.IDL.IDL{IndirectionLevel = 1};
        result error_status_t ReturnValue;
        
        override string ToString()
        {
            return "EvtRpcGetChannelConfig" + ", ReturnValue: " + Win32ErrorCodesToText(ReturnValue) + ", channelPath: " + channelPath.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 20};
    
    accepts operation EvtRpcPutChannelConfig
    {
        in optional handle_t IDL_handle;
        in string channelPath with Technologies.IDL.IDL
            {
                Range = new RangePattern{Low = 1, High = MAX_RPC_CHANNEL_NAME_LENGTH},
                BaseStringType = TypeOf<wchar_t>(),
                String = true,
                IndirectionLevel = 1
            };
        in EvtRpcPutChannelConfigFlags $"flags" where ValidationCheckEnumValue(InRange<EvtRpcPutChannelConfigFlags>(value), this, true, 
            ReferenceType.Message, "EVEN6", "flags", "EvtRpcPutChannelConfig", "0x00000000, 0x00000001, 0x00000002, 0x00000003", value)
            with Encoding{Decoder = PatternDecoder<EvtRpcPutChannelConfigFlags>, SourcePattern = TypeOf<DWORD>()};
        in EvtRpcVariantList props with Technologies.IDL.IDL{IndirectionLevel = 1};
        out RpcInfo $"error" with Technologies.IDL.IDL{IndirectionLevel = 1};
        result error_status_t ReturnValue;
        
        override string ToString()
        {
            return "EvtRpcPutChannelConfig" + ", ReturnValue: " + Win32ErrorCodesToText(ReturnValue) + ", channelPath: " +
                channelPath.ToString() + ", flags: " + EnumToStringInSummary<EVEN6.PropertyIdType>($"flags");
        }
    }
    with Technologies.IDL.IDL{Opnum = 21};
    
    accepts operation EvtRpcGetPublisherList
    {
        in optional handle_t IDL_handle;
        in DWORD $"flags" where ValidationCheckReservedZero(value == 0, this, true, ReferenceType.Message, "EVEN6", "flags", "EvtRpcGetPublisherList", value);
        out DWORD numPublisherIds with Technologies.IDL.IDL{IndirectionLevel = 1};
        out array<string> publisherIds with Technologies.IDL.IDL
            {
                Size_is = [null, numPublisherIds, null],
                Range = new RangePattern{Low = 0, High = MAX_RPC_PUBLISHER_COUNT},
                BaseStringType = TypeOf<wchar_t>(),
                String = true,
                IndirectionLevel = 3
            };
        result error_status_t ReturnValue;
        
        override string ToString()
        {
            return "EvtRpcGetPublisherList" + ", ReturnValue: " + Win32ErrorCodesToText(ReturnValue) + ", numPublisherIds: " + numPublisherIds.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 22};
    
    accepts operation EvtRpcGetPublisherListForChannel
    {
        in optional handle_t IDL_handle;
        in string channelName with Technologies.IDL.IDL
            {
                Range = new RangePattern{Low = 1, High = MAX_RPC_CHANNEL_NAME_LENGTH},
                BaseStringType = TypeOf<wchar_t>(),
                String = true,
                IndirectionLevel = 1
            };
        in DWORD $"flags" where ValidationCheckReservedZero(value == 0, this, true, ReferenceType.Message, "EVEN6", "flags", "EvtRpcGetPublisherListForChannel", value);
        out DWORD numPublisherIds with Technologies.IDL.IDL{IndirectionLevel = 1};
        out array<string> publisherIds with Technologies.IDL.IDL
            {
                Size_is = [null, numPublisherIds, null],
                Range = new RangePattern{Low = 0, High = MAX_RPC_PUBLISHER_COUNT},
                BaseStringType = TypeOf<wchar_t>(),
                String = true,
                IndirectionLevel = 3
            };
        result error_status_t ReturnValue;
        
        override string ToString()
        {
            return "EvtRpcGetPublisherListForChannel" + ", ReturnValue: " + Win32ErrorCodesToText(ReturnValue) + ", channelName: " + channelName.ToString() +
                ", numPublisherIds: " + numPublisherIds.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 23};
    
    accepts operation EvtRpcGetPublisherMetadata
    {
        in string publisherId with Technologies.IDL.IDL
            {
                Range = new RangePattern{Low = 0, High = MAX_RPC_PUBLISHER_ID_LENGTH},
                PointerType = PointerKind.UniquePtr,
                BaseStringType = TypeOf<wchar_t>(),
                String = true,
                IndirectionLevel = 1
            };
        in string logFilePath with Technologies.IDL.IDL
            {
                Range = new RangePattern{Low = 0, High = MAX_RPC_FILE_PATH_LENGTH},
                PointerType = PointerKind.UniquePtr,
                BaseStringType = TypeOf<wchar_t>(),
                String = true,
                IndirectionLevel = 1
            };
        in LCID locale with Encoding{Decoder = BinaryDecoder<LCID>, SourceConverter = (DWORD val) => (val.ToBinary() as optional binary), SourcePattern = TypeOf<DWORD>()};
        in DWORD $"flags" where ValidationCheckReservedZero(value == 0, this, true, ReferenceType.Message, "EVEN6", "flags", "EvtRpcGetPublisherMetadata", value);
        out EvtRpcVariantList pubMetadataProps with Technologies.IDL.IDL{IndirectionLevel = 1};
        out PCONTEXT_HANDLE_PUBLISHER_METADATA pubMetadata with Technologies.IDL.IDL{Context_handle = true, IndirectionLevel = 1};
        result error_status_t ReturnValue;
        
        override string ToString()
        {
            return "EvtRpcGetPublisherMetadata" + ", ReturnValue: " + Win32ErrorCodesToText(ReturnValue) + ", publisherId: " +
                publisherId.ToString() + ", logFilePath: " + logFilePath.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 24};
    
    accepts operation EvtRpcGetPublisherResourceMetadata
    {
        in PCONTEXT_HANDLE_PUBLISHER_METADATA handle with Technologies.IDL.IDL{Context_handle = true};
        in EvtRpcGetPublisherResourceMetadataPropertyId propertyId where ValidationCheckEnumValueTooManyItems(InRange<EvtRpcGetPublisherResourceMetadataPropertyId>(value), this, true, 
            ReferenceType.Message, "EVEN6", "propertyId", "EvtRpcGetPublisherResourceMetadata", "EvtRpcGetPublisherResourceMetadata", "EVEN6")
            with Encoding{Decoder = PatternDecoder<EvtRpcGetPublisherResourceMetadataPropertyId>, SourcePattern = TypeOf<DWORD>()};
        in DWORD $"flags" where ValidationCheckReservedZero(value == 0, this, true, ReferenceType.Message, "EVEN6", "flags", "EvtRpcGetPublisherResourceMetadata", value);
        out EvtRpcVariantList pubMetadataProps with Technologies.IDL.IDL{IndirectionLevel = 1};
        result error_status_t ReturnValue;
        
        override string ToString()
        {
            return "EvtRpcGetPublisherResourceMetadata" + ", ReturnValue: " + Win32ErrorCodesToText(ReturnValue) +
                ", propertyId: " + EnumToStringInSummary<EVEN6.EvtRpcGetPublisherResourceMetadataPropertyId>(propertyId);
        }
    }
    with Technologies.IDL.IDL{Opnum = 25};
    
    accepts operation EvtRpcGetEventMetadataEnum
    {
        in PCONTEXT_HANDLE_PUBLISHER_METADATA pubMetadata with Technologies.IDL.IDL{Context_handle = true};
        in DWORD $"flags" where ValidationCheckReservedZero(value == 0, this, true, ReferenceType.Message, "EVEN6", "flags", "EvtRpcGetEventMetadataEnum", value);
        in string reservedForFilter with Technologies.IDL.IDL
            {
                Range = new RangePattern{Low = 0, High = MAX_RPC_FILTER_LENGTH},
                PointerType = PointerKind.UniquePtr,
                BaseStringType = TypeOf<wchar_t>(),
                String = true,
                IndirectionLevel = 1
            };
        out PCONTEXT_HANDLE_EVENT_METADATA_ENUM eventMetaDataEnum with Technologies.IDL.IDL{Context_handle = true, IndirectionLevel = 1};
        result error_status_t ReturnValue;
        
        override string ToString()
        {
            return "EvtRpcGetEventMetadataEnum" + ", ReturnValue: " + Win32ErrorCodesToText(ReturnValue);
        }
    }
    with Technologies.IDL.IDL{Opnum = 26};
    
    accepts operation EvtRpcGetNextEventMetadata
    {
        in PCONTEXT_HANDLE_EVENT_METADATA_ENUM eventMetaDataEnum with Technologies.IDL.IDL{Context_handle = true};
        in DWORD $"flags" where ValidationCheckReservedZero(value == 0, this, true, ReferenceType.Message, "EVEN6", "flags", "EvtRpcGetEventMetadataEnum", value);
        in DWORD numRequested;
        out DWORD numReturned with Technologies.IDL.IDL{IndirectionLevel = 1};
        out array<EvtRpcVariantList> eventMetadataInstances with Technologies.IDL.IDL
            {
                Size_is = [null, numReturned],
                Range = new RangePattern{Low = 0, High = MAX_RPC_EVENT_METADATA_COUNT},
                IndirectionLevel = 2
            };
        result error_status_t ReturnValue;
        
        override string ToString()
        {
            return "EvtRpcGetNextEventMetadata" + ", ReturnValue: " + Win32ErrorCodesToText(ReturnValue) + ", numRequested: " +
                numRequested.ToString() + ", numReturned: " + numReturned.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 27};
    
    accepts operation EvtRpcGetClassicLogDisplayName
    {
        in optional handle_t IDL_handle;
        in string logName with Technologies.IDL.IDL
            {
                Range = new RangePattern{Low = 1, High = MAX_RPC_CHANNEL_NAME_LENGTH},
                BaseStringType = TypeOf<wchar_t>(),
                String = true,
                IndirectionLevel = 1
            };
        in LCID locale with Encoding{Decoder = BinaryDecoder<LCID>, SourceConverter = (DWORD val) => (val.ToBinary() as optional binary), SourcePattern = TypeOf<DWORD>()};
        in EvtRpcGetClassicLogDisplayNameFlags $"flags" where ValidationCheckEnumValue(InRange<EvtRpcGetClassicLogDisplayNameFlags>(value), this, true, 
            ReferenceType.Message, "EVEN6", "flags", "EvtRpcGetClassicLogDisplayName", "0x0, 0x100", value)
            with Encoding{Decoder = PatternDecoder<EvtRpcGetClassicLogDisplayNameFlags>, SourcePattern = TypeOf<DWORD>()};
        out string displayName with Technologies.IDL.IDL
            {
                PointerType = PointerKind.UniquePtr,
                BaseStringType = TypeOf<wchar_t>(),
                IndirectionLevel = 1
            };
        result error_status_t ReturnValue;
        
        override string ToString()
        {
            return "EvtRpcGetClassicLogDisplayName" + ", ReturnValue: " + Win32ErrorCodesToText(ReturnValue) + ", logName: " + logName.ToString() +
                ", flags: " + EnumToStringInSummary<EVEN6.EvtRpcGetClassicLogDisplayNameFlags>($"flags") + ", displayName: " + displayName.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 28};
}
with Technologies.IDL.IDL
    {
        Uuid = {f6beaff7-1e19-4fbb-9f8f-b89e2018337c},
        Version = "1.0",
        Pointer_default = PointerKind.UniquePtr
    };

typedef PCONTEXT_HANDLE_REMOTE_SUBSCRIPTION = ContextHandle;

typedef PCONTEXT_HANDLE_OPERATION_CONTROL = ContextHandle;

typedef EvtRpcQueryChannelInfo = tag_EvtRpcQueryChannelInfo;

type tag_EvtRpcQueryChannelInfo
{
    string name with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr, BaseStringType = TypeOf<wchar_t>(), IndirectionLevel = 1};
    DWORD status;
}

typedef RpcInfo = tag_RpcInfo;

type tag_RpcInfo
{
    DWORD m_error;
    DWORD m_subErr;
    DWORD m_subErrParam;

    override string ToString()
    {
        if (0 == m_error)
        {
            return "Success";
        }
        else
        {
            return "Failure";
        }
    }
}

typedef PCONTEXT_HANDLE_LOG_QUERY = ContextHandle;

typedef PCONTEXT_HANDLE_PUBLISHER_METADATA = ContextHandle;

typedef EvtRpcVariantList = tag_EvtRpcVariantList;

type tag_EvtRpcVariantList
{
    DWORD count with Technologies.IDL.IDL{Range = new RangePattern{Low = 0, High = MAX_RPC_VARIANT_LIST_COUNT}};
    array<EvtRpcVariant> props with Technologies.IDL.IDL{Size_is = [count], IndirectionLevel = 1};
}

typedef EvtRpcVariant = tag_EvtRpcVariant;

type tag_EvtRpcVariant
{
    EvtRpcVariantType $"type";
    EvtRpcVariantFlag $"flags" where ValidationCheckEnumValue(InRange<EvtRpcVariantFlag>(value), null, true, 
        ReferenceType.Type, "EVEN6", "flags", "tag_EvtRpcVariant", "0x0000, 0x0001", value)
        with Encoding{Decoder = PatternDecoder<EvtRpcVariantFlag>, SourcePattern = TypeOf<DWORD>()};
    tag_EvtRpcVariant_UnionType[$"type"] tag_EvtRpcVariant_UnionType with Technologies.IDL.IDL{Switch_Is = $"type", EmbedType = true};
}

pattern EvtRpcVariantFlag = enum DWORD
{
    NoChange = 0x0000,
    Changed = 0x0001,
    ...
} with BinaryEncodingDefaults{Endian = Endian.Little}, Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};

typedef EvtRpcVariantType = tag_EvtRpcVariantType with Technologies.IDL.IDL{V1_enum = true};

pattern tag_EvtRpcVariantType = enum 
    {
        EvtRpcVarTypeNull = 0,
        EvtRpcVarTypeBoolean = 1,
        EvtRpcVarTypeUInt32 = 2,
        EvtRpcVarTypeUInt64 = 3,
        EvtRpcVarTypeString = 4,
        EvtRpcVarTypeGuid = 5,
        EvtRpcVarTypeBooleanArray = 6,
        EvtRpcVarTypeUInt32Array = 7,
        EvtRpcVarTypeUInt64Array = 8,
        EvtRpcVarTypeStringArray = 9,
        EvtRpcVarTypeGuidArray = 10
    } with Technologies.IDL.IDL{V1_enum = true};

type tag_EvtRpcVariant_UnionType[EvtRpcVariantType Tag]
{
    optional [|Tag == 0|] int nullVal with Technologies.IDL.IDL{Case = [0]};
    optional [|Tag == 1|] boolean booleanVal with Technologies.IDL.IDL{Case = [(1)]};
    optional [|Tag == 2|] DWORD uint32Val with Technologies.IDL.IDL{Case = [(2)]};
    optional [|Tag == 3|] DWORD64 uint64Val with Technologies.IDL.IDL{Case = [(3)]};
    optional [|Tag == 4|] string stringVal with Technologies.IDL.IDL{Case = [(4)], BaseStringType = TypeOf<wchar_t>(), String = true, IndirectionLevel = 1};
    optional [|Tag == 5|] GUID guidVal with Technologies.IDL.IDL{Case = [(5)], IndirectionLevel = 1};
    optional [|Tag == 6|] BooleanArray booleanArray with Technologies.IDL.IDL{Case = [(6)]};
    optional [|Tag == 7|] UInt32Array uint32Array with Technologies.IDL.IDL{Case = [(7)]};
    optional [|Tag == 8|] UInt64Array uint64Array with Technologies.IDL.IDL{Case = [(8)]};
    optional [|Tag == 9|] StringArray stringArray with Technologies.IDL.IDL{Case = [(9)]};
    optional [|Tag == 10|] GuidArray guidArray with Technologies.IDL.IDL{Case = [(10)]};
}
with Technologies.IDL.IDL{Switch_Type = TypeOf<EvtRpcVariantType>(), UnionKind = UnionKind.NonEncapsulated};

type BooleanArray
{
    DWORD count with Technologies.IDL.IDL{Range = new RangePattern{Low = 0, High = MAX_RPC_BOOL_ARRAY_COUNT}};
    array<boolean> ptr with Technologies.IDL.IDL{Size_is = [count], IndirectionLevel = 1};
}

type UInt32Array
{
    DWORD count with Technologies.IDL.IDL{Range = new RangePattern{Low = 0, High = MAX_RPC_UINT32_ARRAY_COUNT}};
    array<DWORD> ptr with Technologies.IDL.IDL{Size_is = [count], IndirectionLevel = 1};
}

type UInt64Array
{
    DWORD count with Technologies.IDL.IDL{Range = new RangePattern{Low = 0, High = MAX_RPC_UINT64_ARRAY_COUNT}};
    array<DWORD64> ptr with Technologies.IDL.IDL{Size_is = [count], IndirectionLevel = 1};
}

type StringArray
{
    DWORD count with Technologies.IDL.IDL{Range = new RangePattern{Low = 0, High = MAX_RPC_STRING_ARRAY_COUNT}};
    array<string> ptr with Technologies.IDL.IDL{Size_is = [count, null], BaseStringType = TypeOf<wchar_t>(), String = true, IndirectionLevel = 2};
}

type GuidArray
{
    DWORD count with Technologies.IDL.IDL{Range = new RangePattern{Low = 0, High = MAX_RPC_GUID_ARRAY_COUNT}};
    array<GUID> ptr with Technologies.IDL.IDL{Size_is = [count], IndirectionLevel = 1};
}

typedef PCONTEXT_HANDLE_LOG_HANDLE = ContextHandle;

typedef PCONTEXT_HANDLE_EVENT_METADATA_ENUM = ContextHandle;

// 2.2.17   Result Set
type ResultSet
{
    uint totalSize;
    uint headerSize where ValidationCheckValue(value == 0x00000010, null, true, ReferenceType.Type, "EVEN6", "headerSize", "ResultSet", "0x00000010", value);
    uint eventOffset where ValidationCheckValue(value == 0x00000010, null, true, ReferenceType.Type, "EVEN6", "eventOffset", "ResultSet", "0x00000010", value);
    uint bookmarkOffset;
    uint binXmlSize;
    (Document | xml) eventData with BinaryEncoding{WidthForComposedType = binXmlSize * 8};
    uint numberOfSubqueryIDs;
    array<uint> subqueryIDs with BinaryEncoding{Length = numberOfSubqueryIDs};
    BookMark bookMarkData;
    optional [|(binXmlSize + bookMarkData.bookmarkSize) % 2 == 1|] byte padding;
} with BinaryEncodingDefaults{Endian = Endian.Little}, Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};

type BookMark
{
    uint bookmarkSize;
    uint headerSize where ValidationCheckValue(value == 0x00000018, null, true, ReferenceType.Type, "EVEN6", "headerSize", "BookMark", "0x00000018", value);
    uint channelSize;
    uint currentChannel;
    ReadDirection readDirection;
    uint recordIdsOffset;
    array<ulong> logRecordNumbers with BinaryEncoding{Length = channelSize};
} with BinaryEncodingDefaults{Endian = Endian.Little}, Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};

pattern ReadDirection = enum uint
{
    ChronologicalOrder = 0x00000000,
    ReverseOrder = 0x00000001,
    ...
} with BinaryEncodingDefaults{Endian = Endian.Little}, Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};

// 2.2.18   BinXmlVariant Structure
type BinXmlVariant
{
    ulong union;
    uint count;
    BinXmlVariantType $"type" where ValidationCheckEnumValue(InRange<BinXmlVariantType>(value), null, true, 
            ReferenceType.Type, "EVEN6", "type", "BinXmlVariant", "0x00000008, 0x0000000A, 0x0000000D, 0x00000011", value);
} with BinaryEncodingDefaults{Endian = Endian.Little}, Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};

pattern BinXmlVariantType = enum uint
{
    BinXmlVarUInt32 = 0x00000008,
    BinXmlVarUInt64 = 0x0000000A,
    BinXmlVarBool = 0x0000000D,
    BinXmlVarFileTime = 0x00000011,
    ...
} with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};

// 2.2.12 BinXml
// interface for helping get the xml string of BinXml structures
type BinXmlInterface
{
    virtual string ToBinXmlString(array<ValueSpecEntry> valueSpecEntrys, array<string> dataInstances)
    {
        return "";
    }
}

string BinXmlNodeToXmlString(any e, array<ValueSpecEntry> valueSpecEntrys, array<string> dataInstances)
{
    if (e is interf:BinXmlInterface)
    {
        return interf.ToBinXmlString(valueSpecEntrys, dataInstances);
    }
    return "";
}

// ==== Top-level Definitions ======================================
type Document : BinXmlInterface
{
    optional Prolog prolog;
    Fragment fragment;
    optional Misc misc;
    EOFToken eofToken;

    override string ToBinXmlString(array<ValueSpecEntry> valueSpecEntrys, array<string> dataInstances)
    {
        return fragment.ToBinXmlString(valueSpecEntrys, dataInstances);
    }
} with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};

typedef Prolog = PI;
typedef Misc = PI;

type Fragment : BinXmlInterface
{
    array<FragmentHeader> header;
    ([|CurrentByte(stream) is OpenStartElementToken|] Element | TemplateInstance) elementOrTempInstance;

    override string ToBinXmlString(array<ValueSpecEntry> valueSpecEntrys, array<string> dataInstances)
    {
        return BinXmlNodeToXmlString(elementOrTempInstance, valueSpecEntrys, dataInstances);
    }
} with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};

type FragmentHeader : BinXmlInterface
{
    FragmentHeaderToken token;
    MajorVersion major where ValidationCheckValue(value == 1, null, true, ReferenceType.Type, "EVEN6", "major", "FragmentHeader", "1", value);
    MinorVersion minor where ValidationCheckValue(value == 1, null, true, ReferenceType.Type, "EVEN6", "minor", "FragmentHeader", "1", value);
    Flags flag;
} with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};

typedef MajorVersion = byte with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};
typedef MinorVersion = byte with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};
typedef Flags = byte with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};

// ==== Basic XML Definitions ======================================
pattern Element = (Element1 | Element2) with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};

type Element1 : BinXmlInterface
{
    StartElement startElement;
    CloseStartElementToken closeStartElementToken;
    Content content;
    EndElementToken endElementToken;

    // 2.2.12.1   Emitting Instruction for the Element Rule
    override string ToBinXmlString(array<ValueSpecEntry> valueSpecEntrys, array<string> dataInstances)
    {
        return startElement.ToBinXmlString(valueSpecEntrys, dataInstances) + ">" + content.ToBinXmlString(valueSpecEntrys, dataInstances) + "</" + startElement.name.ToBinXmlString(valueSpecEntrys, dataInstances) + ">";
    }
} with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};

type Element2 : BinXmlInterface
{
    StartElement startElement;
    CloseEmptyElementToken closeEmptyElementToken;

    // 2.2.12.1   Emitting Instruction for the Element Rule
    override string ToBinXmlString(array<ValueSpecEntry> valueSpecEntrys, array<string> dataInstances)
    {
        return startElement.ToBinXmlString(valueSpecEntrys, dataInstances) + "/>";
    }
} with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};

type Content : BinXmlInterface
{
    optional array<ContentElementPat> elements;

    override string ToBinXmlString(array<ValueSpecEntry> valueSpecEntrys, array<string> dataInstances)
    {
        string xmlstr = "";
        if (elements is arr:array<ContentElementPat>)
        {
            foreach (var e in arr)
            {
                xmlstr += BinXmlNodeToXmlString(e, valueSpecEntrys, dataInstances);
            }
        }
        return xmlstr;
    }
} with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};

pattern ContentElementPat = (Element | CharData | CharRef | EntityRef | CDATASection | PI) with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};

pattern CharData = (ValueText | Substitution) with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};

type StartElement : BinXmlInterface
{
    OpenStartElementToken openStartElementToken;
    optional DependencyId dependencyId;
    ElementByteLength elementByteLength;
    Name name;
    optional [|openStartElementToken == 0x41|] AttributeList attributelist;

    override string ToBinXmlString(array<ValueSpecEntry> valueSpecEntrys, array<string> dataInstances)
    {
        return "<" + name.ToBinXmlString(valueSpecEntrys, dataInstances) + (attributelist is al:AttributeList && al != null ? al.ToBinXmlString(valueSpecEntrys, dataInstances) : "");
    }
} with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};

typedef DependencyId = short with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};
typedef ElementByteLength = int with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};

type AttributeList : BinXmlInterface
{
    AttributeListByteLength attributeListByteLength;
    array<Attribute> attributes;

    override string ToBinXmlString(array<ValueSpecEntry> valueSpecEntrys, array<string> dataInstances)
    {
        string xmlstr = "";
        foreach (var attr in attributes)
        {
            xmlstr += attr.ToBinXmlString(valueSpecEntrys, dataInstances);
        }
        return xmlstr;
    }
} with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};

type Attribute : BinXmlInterface
{
    AttributeToken attributeToken;
    Name name;
    AttributeCharData attributeCharData;

    // 2.2.12.3   Emitting Instruction for the Substitution Rule
    override string ToBinXmlString(array<ValueSpecEntry> valueSpecEntrys, array<string> dataInstances)
    {
        if (attributeCharData == null || attributeCharData.elements == null || attributeCharData.elements.Count == 0)
        {
            return "";
        }
        else
        {
            foreach (var e in attributeCharData.elements)
            {
                if (valueSpecEntrys != null && e is os:OptionalSubstitution && os.substitutionId > 0 && os.substitutionId < valueSpecEntrys.Count && 
                    valueSpecEntrys[os.substitutionId].valueType == ValueType.NullType)
                {
                    return "";
                }
            }
            return " " + name.ToBinXmlString(valueSpecEntrys, dataInstances) + "='" + attributeCharData.ToBinXmlString(valueSpecEntrys, dataInstances) + "'";
        }
    }
} with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};

type AttributeCharData : BinXmlInterface
{
    array<AttributeCharDataElementPat> elements;

    override string ToBinXmlString(array<ValueSpecEntry> valueSpecEntrys, array<string> dataInstances)
    {
        string xmlstr = "";
        foreach (var e in elements)
        {
            xmlstr += BinXmlNodeToXmlString(e, valueSpecEntrys, dataInstances);
        }
        return xmlstr;
    }
} with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};

pattern AttributeCharDataElementPat = ([|CurrentByte(stream) is ValueTextToken|] ValueText |
                                        [|CurrentByte(stream) is NormalSubstitutionToken || CurrentByte(stream) is OptionalSubstitutionToken|] Substitution |
                                        [|CurrentByte(stream) is CharRefToken|] CharRef |
                                        [|CurrentByte(stream) is EntityRefToken|] EntityRef) with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};

typedef AttributeListByteLength = int with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};

type ValueText : BinXmlInterface
{
    ValueTextToken valueTextToken;
    (ValueType where value == ValueType.StringType) stringType;
    LengthPrefixedUnicodeString lengthPrefixedUnicodeString;

    override string ToBinXmlString(array<ValueSpecEntry> valueSpecEntrys, array<string> dataInstances)
    {
        return lengthPrefixedUnicodeString.ToBinXmlString(valueSpecEntrys, dataInstances);
    }
} with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};

pattern Substitution = ([|CurrentByte(stream) is NormalSubstitutionToken|] NormalSubstitution |
                         [|CurrentByte(stream) is OptionalSubstitutionToken|] OptionalSubstitution) with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};

type NormalSubstitution : BinXmlInterface
{
    NormalSubstitutionToken normalSubstitutionToken;
    SubstitutionId substitutionId;
    ValueType valueType;

    override string ToBinXmlString(array<ValueSpecEntry> valueSpecEntrys, array<string> dataInstances)
    {
        if (dataInstances != null && substitutionId < dataInstances.Count)
        {
            return dataInstances[substitutionId];
        }
        return "subbstitution {%" + substitutionId.ToString() + "}";
    }
} with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};

type OptionalSubstitution : BinXmlInterface
{
    OptionalSubstitutionToken optionalSubstitutionToken;
    SubstitutionId substitutionId;
    ValueType valueType;

    override string ToBinXmlString(array<ValueSpecEntry> valueSpecEntrys, array<string> dataInstances)
    {
        if (dataInstances != null && substitutionId < dataInstances.Count)
        {
            return dataInstances[substitutionId];
        }
        return "subbstitution {%" + substitutionId.ToString() + "}";
    }
} with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};

typedef SubstitutionId = short with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};

type CharRef : BinXmlInterface
{
    CharRefToken charRefToken;
    short word;

    // 2.2.12.4   Emitting Instruction for the CharRef Rule
    override string ToBinXmlString(array<ValueSpecEntry> valueSpecEntrys, array<string> dataInstances)
    {
        return "&#" + word.ToString();
    }
} with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};

type EntityRef : BinXmlInterface
{
    EntityRefToken entityRefToken;
    Name name;

    // 2.2.12.5   Emitting Instruction for the EntityRef Rule
    override string ToBinXmlString(array<ValueSpecEntry> valueSpecEntrys, array<string> dataInstances)
    {
        return "&" + name.ToBinXmlString(valueSpecEntrys, dataInstances);
    }
} with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};

type CDATASection : BinXmlInterface
{
    CDATASectionToken cdataSectionToken;
    LengthPrefixedUnicodeString lengthPrefixedUnicodeString;

    // 2.2.12.6   Emitting Instruction for the CDATA Section Rule
    override string ToBinXmlString(array<ValueSpecEntry> valueSpecEntrys, array<string> dataInstances)
    {
        return "<[CDATA[" + lengthPrefixedUnicodeString.ToBinXmlString(valueSpecEntrys, dataInstances) + "]]";
    }
} with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};

type PI : BinXmlInterface
{
    PITarget piTarget;
    PIData piData;

    override string ToBinXmlString(array<ValueSpecEntry> valueSpecEntrys, array<string> dataInstances)
    {
        return piTarget.ToBinXmlString(valueSpecEntrys, dataInstances) + piData.ToBinXmlString(valueSpecEntrys, dataInstances);
    }
} with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};

type PITarget : BinXmlInterface
{
    PITargetToken piTargetToken;
    Name name;

    // 2.2.12.7   Emitting Instruction for the PITarget Rule
    override string ToBinXmlString(array<ValueSpecEntry> valueSpecEntrys, array<string> dataInstances)
    {
        return "<?" + name.ToBinXmlString(valueSpecEntrys, dataInstances) + " ";
    }
} with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};

type PIData : BinXmlInterface
{
    PIDataToken piDataToken;
    LengthPrefixedUnicodeString lengthPrefixedUnicodeString;

    // 2.2.12.8   Emitting Instruction for the PIData Rule
    override string ToBinXmlString(array<ValueSpecEntry> valueSpecEntrys, array<string> dataInstances)
    {
        return lengthPrefixedUnicodeString.ToBinXmlString(valueSpecEntrys, dataInstances) + "?>";
    }
} with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};

type Name : BinXmlInterface
{
    NameHash nameHash;
    NameNumChars nameNumChars;
    NullTerminatedUnicodeString nullTerminatedUnicodeString with BinaryEncoding{Length = nameNumChars + 1};

    override string ToBinXmlString(array<ValueSpecEntry> valueSpecEntrys, array<string> dataInstances)
    {
        return nullTerminatedUnicodeString.ToString();
    }
} with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};

typedef NameHash = short with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};
typedef NameNumChars = short with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};

// ==== Token Types ================================================
pattern EOFToken = byte where value == 0x00 with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};
pattern OpenStartElementToken = byte where (value == 0x01 || value == 0x41) with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};
pattern CloseStartElementToken = byte where value == 0x02 with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};
pattern CloseEmptyElementToken = byte where value == 0x03 with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};
pattern EndElementToken = byte where value == 0x04 with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};

pattern ValueTextToken = byte where (value == 0x05 || value == 0x45) with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};
pattern AttributeToken = byte where (value == 0x06 || value == 0x46) with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};
pattern CDATASectionToken = byte where (value == 0x07 || value == 0x47) with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};
pattern CharRefToken = byte where (value == 0x08 || value == 0x48) with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};
pattern EntityRefToken = byte where (value == 0x09 || value == 0x49) with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};

pattern PITargetToken = byte where value == 0x0A with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};
pattern PIDataToken = byte where value == 0x0B with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};
pattern TemplateInstanceToken = byte where value == 0x0C with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};
pattern NormalSubstitutionToken = byte where value == 0x0D with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};
pattern OptionalSubstitutionToken = byte where value == 0x0E with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};
pattern FragmentHeaderToken = byte where value == 0x0F with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};

// ==== Template-related definitions ===============================
type TemplateInstance : BinXmlInterface
{
    TemplateInstanceToken templateInstanceToken;
    TemplateDef templateDef;
    TemplateInstanceData templateInstanceData;

    override string ToBinXmlString(array<ValueSpecEntry> valueSpecEntrys, array<string> dataInstances)
    {
        return templateDef.ToBinXmlString(templateInstanceData.valueSpecEntrys, templateInstanceData.TemplateInstanceStrings());
    }
} with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};

type TemplateDef : BinXmlInterface
{
    byte reserved;
    TemplateId templateId;
    TemplateDefByteLength templateDefByteLength;
    optional FragmentHeader fragmentHeader;
    Element element;
    EOFToken eofToken;

    override string ToBinXmlString(array<ValueSpecEntry> valueSpecEntrys, array<string> dataInstances)
    {
        return BinXmlNodeToXmlString(element, valueSpecEntrys, dataInstances);
    }
} with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};

typedef TemplateId = guid with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};

type TemplateInstanceData
{
    NumValues numValues;
    array<ValueSpecEntry> valueSpecEntrys with BinaryEncoding{Length = numValues};
    array<VariableValue> values with Encoding{Decoder = ValueDecoder, SourcePattern = TypeOf<binary>()},
        BinaryEncoding{Length = DataLength()};

    int DataLength()
    {
        int len = 0;
        foreach (var entry in valueSpecEntrys)
        {
            len += entry.valueByteLength;
        }
        return len;
    }

    optional array<VariableValue> ValueDecoder(binary bin)
    {
        array<VariableValue> valueArray = [];
        int bytePos = 0;
        int nextBytePos;
        foreach (var entry in valueSpecEntrys)
        {
            nextBytePos = bytePos + entry.valueByteLength;
            if (nextBytePos <= bin.Count)
            {
                if (BinaryDecoder<VariableValue[entry.valueType]>(bin.Segment(bytePos, entry.valueByteLength)) is v:VariableValue)
                {
                    valueArray += [v];
                }
                else
                {
                    ThrowDecodingException("EVEN6", "TemplateInstanceData");
                }
                bytePos = nextBytePos;
            }
            else
            {
                break;
            }
        }
        return valueArray;
    }

    array<string> TemplateInstanceStrings()
    {
        array<string> xmlstrs = [];
        for (int i = 0; i < values.Count; i++)
        {
            xmlstrs += [values[i].ToBinXmlString(null, null)];
        }
        return xmlstrs;
    }
} with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};

typedef NumValues = int with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};

type ValueSpecEntry
{
    ValueByteLength valueByteLength;
    ValueType valueType with BinaryEncoding{WidthForComposedType = valueByteLength * 8};
    EOFToken eofToken;
} with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};

typedef ValueByteLength = short with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};

typedef TemplateDefByteLength = int with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};

// ==== Value Types =================================================
type VariableValue[ValueType Kind] : BinXmlInterface
{
    optional
    (
        [|Kind == ValueType.NullType|] NullValue |
        [|Kind == ValueType.StringType|] StringValue |
        [|Kind == ValueType.AnsiStringType|] AnsiStringValue |
        [|Kind == ValueType.Int8Type|] Int8Value |
        [|Kind == ValueType.UInt8Type|] UInt8Value |
        [|Kind == ValueType.Int16Type|] Int16Value |
        [|Kind == ValueType.UInt16Type|] UInt16Value |
        [|Kind == ValueType.Int32Type|] Int32Value |
        [|Kind == ValueType.UInt32Type|] UInt32Value |
        [|Kind == ValueType.Int64Type|] Int64Value |
        [|Kind == ValueType.UInt64Type|] UInt64Value |
        [|Kind == ValueType.Real32Type|] Real32Value |
        [|Kind == ValueType.Real64Type|] Real64Value |
        [|Kind == ValueType.BoolType|] BoolValue |
        [|Kind == ValueType.BinaryType|] BinaryValue |
        [|Kind == ValueType.GuidType|] GuidValue |
        [|Kind == ValueType.SizeTType|] SizeTValue |
        [|Kind == ValueType.FileTimeType|] FileTimeValue |
        [|Kind == ValueType.SysTimeType|] SysTimeValue |
        [|Kind == ValueType.SidType|] SidValue |
        [|Kind == ValueType.HexInt32Type|] HexInt32Value |
        [|Kind == ValueType.HexInt64Type|] HexInt64Value |
        [|Kind == ValueType.BinXmlType|] BinXmlValue |
        [|Kind == ValueType.StringArrayType|] StringArrayValue |
        [|Kind == ValueType.AnsiStringArrayType|] AnsiStringArrayValue |
        [|Kind == ValueType.Int8ArrayType|] Int8ArrayValue |
        [|Kind == ValueType.UInt8ArrayType|] UInt8ArrayValue |
        [|Kind == ValueType.Int16ArrayType|] Int16ArrayValue |
        [|Kind == ValueType.UInt16ArrayType|] UInt16ArrayValue |
        [|Kind == ValueType.Int32ArrayType|] Int32ArrayValue |
        [|Kind == ValueType.UInt32ArrayType|] UInt32ArrayValue |
        [|Kind == ValueType.Int64ArrayType|] Int64ArrayValue |
        [|Kind == ValueType.UInt64ArrayType|] UInt64ArrayValue |
        [|Kind == ValueType.Real32ArrayType|] Real32ArrayValue |
        [|Kind == ValueType.Real64ArrayType|] Real64ArrayValue |
        [|Kind == ValueType.BoolArrayType|] BoolArrayValue |
        [|Kind == ValueType.GuidArrayType|] GuidArrayValue |
        [|Kind == ValueType.SizeTArrayType|] SizeTArrayValue |
        [|Kind == ValueType.FileTimeArrayType|] FileTimeArrayValue |
        [|Kind == ValueType.SysTimeArrayType|] SysTimeArrayValue |
        [|Kind == ValueType.SidArrayType|] SidArrayValue |
        [|Kind == ValueType.HexInt32ArrayType|] HexInt32ArrayValue |
        [|Kind == ValueType.HexInt64ArrayType|] HexInt64ArrayValue |
        binary
    ) Value;

    override string ToBinXmlString(array<ValueSpecEntry> valueSpecEntrys, array<string> dataInstances)
    {
        switch (Kind)
        {
            case ValueType.StringType =>
                return Value.ToString();
            case ValueType.AnsiStringType =>
                return Value.ToString();
            case ValueType.Int8Type =>
                return Value.ToString();
            case ValueType.UInt8Type =>
                return Value.ToString();
            case ValueType.Int16Type =>
                return Value.ToString();
            case ValueType.UInt16Type =>
                return Value.ToString();
            case ValueType.Int32Type =>
                return Value.ToString();
            case ValueType.UInt32Type =>
                return Value.ToString();
            case ValueType.Int64Type =>
                return Value.ToString();
            case ValueType.UInt64Type =>
                return Value.ToString();
            case ValueType.Real32Type =>
                return Value.ToString();
            case ValueType.Real64Type =>
                return Value.ToString();
            case ValueType.BoolType =>
                return (Value as BoolValue) == 0 ? "false" : "true";
            case ValueType.BinaryType =>
                return Value.ToString();
            case ValueType.GuidType =>
                return Value.ToString();
            case ValueType.SizeTType =>
                return Utility.DecToHexFormat(Value as SizeTValue);
            case ValueType.FileTimeType =>
                return (Value as FileTimeValue).ToUtcString(); // use utc time here, to avoid UT case generates different result on different machines.
            case ValueType.SysTimeType =>
                return Value.ToString();
            case ValueType.SidType =>
                return Value.ToString();
            case ValueType.HexInt32Type =>
                return Value.ToString();
            case ValueType.HexInt64Type =>
                return Value.ToString();
            case ValueType.BinXmlType =>
                return (Value as BinXmlValue).ToBinXmlString(valueSpecEntrys, dataInstances);
            case ValueType.StringArrayType =>
                return Value.ToString();
            case ValueType.AnsiStringArrayType =>
                return Value.ToString();
            case ValueType.Int8ArrayType =>
                return Value.ToString();
            case ValueType.UInt8ArrayType =>
                return Value.ToString();
            case ValueType.Int16ArrayType =>
                return Value.ToString();
            case ValueType.UInt16ArrayType =>
                return Value.ToString();
            case ValueType.Int32ArrayType =>
                return Value.ToString();
            case ValueType.UInt32ArrayType =>
                return Value.ToString();
            case ValueType.Int64ArrayType =>
                return Value.ToString();
            case ValueType.UInt64ArrayType =>
                return Value.ToString();
            case ValueType.Real32ArrayType =>
                return Value.ToString();
            case ValueType.Real64ArrayType =>
                return Value.ToString();
            case ValueType.BoolArrayType =>
                return Value.ToString();
            case ValueType.GuidArrayType =>
                return Value.ToString();
            case ValueType.SizeTArrayType =>
                return Value.ToString();
            case ValueType.FileTimeArrayType =>
                return (Value as FileTimeArrayValue).Accumulate<FileTimeValue, string>((FileTimeValue val, string text) => text + ", " + val.ToUtcString());
            case ValueType.SysTimeArrayType =>
                return Value.ToString();
            case ValueType.SidArrayType =>
                return Value.ToString();
            case ValueType.HexInt32ArrayType =>
                return Value.ToString();
            case ValueType.HexInt64ArrayType =>
                return Value.ToString();
            default =>
                return "";
        }
    }
} with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};

pattern ValueType = enum byte
{
    NullType = 0x00,
    StringType = 0x01,
    AnsiStringType = 0x02,
    Int8Type = 0x03,
    UInt8Type = 0x04,
    Int16Type = 0x05,
    UInt16Type = 0x06,
    Int32Type = 0x07,
    UInt32Type = 0x08,
    Int64Type = 0x09,
    UInt64Type = 0x0A,
    Real32Type = 0x0B,
    Real64Type = 0x0C,
    BoolType = 0x0D,
    BinaryType = 0x0E,
    GuidType = 0x0F,
    SizeTType = 0x10,
    FileTimeType = 0x11,
    SysTimeType = 0x12,
    SidType = 0x13,
    HexInt32Type = 0x14,
    HexInt64Type = 0x15,
    BinXmlType = 0x21,
    StringArrayType = 0x81,
    AnsiStringArrayType = 0x82,
    Int8ArrayType = 0x83,
    UInt8ArrayType = 0x84,
    Int16ArrayType = 0x85,
    UInt16ArrayType = 0x86,
    Int32ArrayType = 0x87,
    UInt32ArrayType = 0x88,
    Int64ArrayType = 0x89,
    UInt64ArrayType = 0x8A,
    Real32ArrayType = 0x8B,
    Real64ArrayType = 0x8C,
    BoolArrayType = 0x8D,
    GuidArrayType = 0x8F,
    SizeTArrayType = 0x90,
    FileTimeArrayType = 0x91,
    SysTimeArrayType = 0x92,
    SidArrayType = 0x93,
    HexInt32ArrayType = 0x94,
    HexInt64ArrayType = 0x95
} with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};

// === Value Formats ================================================
pattern Value = (StringValue |AnsiStringValue | Int8Value | UInt8Value |  Int16Value | UInt16Value | Int32Value | UInt32Value | Int64Value |
    UInt64Value | Real32Value | Real64Value | BoolValue | BinaryValue |  GuidValue | SizeTValue | FileTimeValue | SysTimeValue | SidValue |
    HexInt32Value | HexInt64Value | BinXmlValue | StringArrayValue |  AnsiStringArrayValue | Int8ArrayValue | UInt8ArrayValue |  Int16ArrayValue |
    UInt16ArrayValue | Int32ArrayValue |  UInt32ArrayValue | Int64ArrayValue | UInt64ArrayValue |  Real32ArrayValue | Real64ArrayValue |
    BoolArrayValue |  GuidArrayValue | SizeTArrayValue | FileTimeArrayValue |  SysTimeArrayValue | SidArrayValue | HexInt32ArrayValue | HexInt64ArrayValue)
    with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};

typedef NullValue = Utility.Empty with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};
typedef StringValue = string with BinaryEncoding{TextEncoding = TextEncoding.Unicode}, Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};
typedef AnsiStringValue = string with BinaryEncoding{TextEncoding = TextEncoding.ASCII}, Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};
typedef Int8Value = byte with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};
typedef UInt8Value = byte with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};
typedef Int16Value = short with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};
typedef UInt16Value = ushort with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};
typedef Int32Value = int with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};
typedef UInt32Value = uint with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};
typedef Int64Value = long with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};
typedef UInt64Value = ulong with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};
typedef Real32Value = float with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};
typedef Real64Value = double with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};
typedef BoolValue = byte with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};
typedef BinaryValue = binary with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};
typedef GuidValue = guid with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};
pattern SizeTValue = (UInt32Value | UInt64Value) with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};
typedef FileTimeValue = DTYP.FILETIME with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};
typedef SysTimeValue = DTYP.SYSTEMTIME with BinaryEncoding{Length = 16}, Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};
typedef SidValue = DTYP.SID with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};
typedef HexInt32Value = UInt32Value with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};
typedef HexInt64Value = UInt64Value with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};

type BinXmlValue : BinXmlInterface
{
    Fragment fragment;
    EOFToken eofToken;

    override string ToBinXmlString(array<ValueSpecEntry> valueSpecEntrys, array<string> dataInstances)
    {
        return fragment.ToBinXmlString(valueSpecEntrys, dataInstances);
    }
} with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};

typedef StringArrayValue = array<NullTerminatedUnicodeString> with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};
typedef AnsiStringArrayValue = array<NullTerminatedAnsiString> with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};
typedef Int8ArrayValue = array<Int8Value> with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};
typedef UInt8ArrayValue = array<UInt8Value> with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};
typedef Int16ArrayValue = array<Int16Value> with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};
typedef UInt16ArrayValue = array<UInt16Value> with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};
typedef Int32ArrayValue = array<Int32Value> with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};
typedef UInt32ArrayValue = array<UInt32Value> with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};
typedef Int64ArrayValue = array<Int64Value> with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};
typedef UInt64ArrayValue = array<UInt64Value> with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};
typedef Real32ArrayValue = array<Real32Value> with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};
typedef Real64ArrayValue = array<Real64Value> with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};
typedef BoolArrayValue = array<BoolValue> with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};
typedef GuidArrayValue = array<GuidValue> with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};
typedef SizeTArrayValue = array<SizeTValue> with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};
typedef FileTimeArrayValue = array<FileTimeValue> with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};
typedef SysTimeArrayValue = array<SysTimeValue> with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};
typedef SidArrayValue = array<SidValue> with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};
typedef HexInt32ArrayValue = array<HexInt32Value> with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};
typedef HexInt64ArrayValue = array<HexInt64Value> with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};

// ==== Base Types =================================================
typedef NullTerminatedUnicodeString = StringValue with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};

typedef NullTerminatedAnsiString = AnsiStringValue with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};

type LengthPrefixedUnicodeString : BinXmlInterface
{
    short NumUnicodeChars;
    StringValue unicodeString with BinaryEncoding{Length = NumUnicodeChars};

    override string ToBinXmlString(array<ValueSpecEntry> valueSpecEntrys, array<string> dataInstances)
    {
        return unicodeString.ToString();
    }
} with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};

// 3.1.4.8   EvtRpcRegisterRemoteSubscription (Opnum 0)
type EvtRpcRegisterRemoteSubscriptionFlags
{
    EvtRpcRegisterRemoteSubscriptionQueryFlags QueryFlags;
    EvtRpcRegisterRemoteSubscriptionOtherFlags OtherFlags with BinaryEncoding{Width = 24};
}

pattern EvtRpcRegisterRemoteSubscriptionQueryFlags = enum byte
{
    EvtSubscribeToFutureEvents = 0x01,
    EvtSubscribeStartAtOldestRecord = 0x02,
    EvtSubscribeStartAfterBookmark = 0x03,
    ...
} with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};

pattern EvtRpcRegisterRemoteSubscriptionOtherFlags = flags uint
{
    EvtSubscribeTolerateQueryErrors = 0x00001000,
    EvtSubscribeStrict = 0x00010000,
    EvtSubscribePull = 0x10000000,
    ...
} with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};

// 3.1.4.12   EvtRpcRegisterLogQuery (Opnum 5)
pattern EvtRpcRegisterLogQueryFlag = flags uint
{
    EvtQueryChannelPath = 0x00000001,
    EvtQueryFilePath = 0x00000002,
    ReadFromOldestToNewest = 0x00000100,
    ReadFromNewestToOldest = 0x00000200,
    EvtQueryTolerateQueryErrors = 0x00001000,
    ...
} with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};

// 3.1.4.17   EvtRpcExportLog (Opnum 7)
pattern EvtRpcExportLogFlags = flags uint
{
    EvtQueryChannelPath = 0x00000001,
    EvtQueryFilePath = 0x00000002,
    EvtQueryTolerateQueryErrors = 0x00001000,
    ...
} with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};

// 3.1.4.31   EvtRpcMessageRender (Opnum 9)
pattern EvtRpcMessageRenderFlags = enum uint
{
    EvtFormatMessageEvent = 0x00000001,
    EvtFormatMessageLevel = 0x00000002,
    EvtFormatMessageTask = 0x00000003,
    EvtFormatMessageOpcode = 0x00000004,
    EvtFormatMessageKeyword = 0x00000005,
    EvtFormatMessageChannel = 0x00000006,
    EvtFormatMessageProvider = 0x00000007,
    EvtFormatMessageId = 0x00000008,
    ...
} with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};

// 3.1.4.32   EvtRpcMessageRenderDefault (Opnum 10)
pattern EvtRpcMessageRenderDefaultFlags = enum uint
{
    EvtFormatMessageEvent = 0x00000001,
    EvtFormatMessageLevel = 0x00000002,
    EvtFormatMessageTask = 0x00000003,
    EvtFormatMessageOpcode = 0x00000004,
    EvtFormatMessageKeyword = 0x00000005,
    EvtFormatMessageId = 0x00000008,
    ...
} with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};

// 3.1.4.14   EvtRpcQuerySeek (Opnum 12)
pattern EvtRpcQuerySeekOriginFlags = enum ushort
{
    EvtSeekRelativeToFirst = 0x0001,
    EvtSeekRelativeToLast = 0x0002,
    EvtSeekRelativeToCurrent = 0x0003,
    EvtSeekRelativeToBookmark = 0x0004,
    ...
} with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};

pattern EvtRpcQuerySeekOtherFlags = flags uint
{
    EvtSeekStrict = 0x00010000,
    ...
} with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};

type EvtRpcQuerySeekFlags
{
    EvtRpcQuerySeekOriginFlags OriginFlags;
    EvtRpcQuerySeekOtherFlags OtherFlags;
} with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};

// 3.1.4.29   EvtRpcAssertConfig (Opnum 15)
pattern EvtRpcAssertConfigFlags = enum uint
{
    EvtRpcChannelPath = 0x00000000,
    EvtRpcPublisherName = 0x00000001,
    ...
} with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};

// 3.1.4.30   EvtRpcRetractConfig (Opnum 16)
pattern EvtRpcRetractConfigFlags = enum uint
{
    EvtRpcChannelPath = 0x00000000,
    EvtRpcPublisherName = 0x00000001,
    ...
} with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};

// 3.1.4.19   EvtRpcOpenLogHandle (Opnum 17)
pattern EvtRpcOpenLogHandleFlags = enum uint
{
    ChannelName = 0x00000001,
    FileName = 0x00000002,
    ...
} with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};

// 3.1.4.15   EvtRpcGetLogFileInfo (Opnum 18)
pattern PropertyIdType = enum uint
{
    EvtLogCreationTime = 0x00000000,
    EvtLogLastAccessTime = 0x00000001,
    EvtLogLastWriteTime = 0x00000002,
    EvtLogFileSize = 0x00000003,
    EvtLogAttributes = 0x00000004,
    EvtLogNumberOfLogRecords = 0x00000005,
    EvtLogOldestRecordNumber = 0x00000006,
    EvtLogFull = 0x00000007,
    ...
} with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};

// 3.1.4.22   EvtRpcPutChannelConfig (Opnum 21)
pattern EvtRpcPutChannelConfigFlags = enum uint
{
    OpenOrCreate = 0x00000000,
    Open = 0x00000001,
    CreateAndDelete = 0x00000002,
    Create = 0x00000003,
    ...
} with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};

// 3.1.4.26   EvtRpcGetPublisherResourceMetadata (Opnum 25)
pattern EvtRpcGetPublisherResourceMetadataPropertyId = enum uint
{
    PublisherHelpLink = 0x00000004,
    PublisherFriendlyName = 0x00000005,
    LevelInformation = 0x0000000C,
    TaskInformation = 0x00000010,
    OpcodeInformation = 0x00000015,
    KeywordInformation = 0x00000019,
    ...
} with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};

// 3.1.4.36   EvtRpcGetClassicLogDisplayName (Opnum 28)
pattern EvtRpcGetClassicLogDisplayNameFlags = enum uint
{
    UseLocale = 0x0,
    PickBestLocale = 0x100,
    ...
} with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};

type ResultSetArrayWrapper
{
    array<ResultSet> Elements;
} with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};

optional array<ResultSet> ResultBufferDecoder(binary data)
{
    if (BinaryDecoder<ResultSetArrayWrapper>(data) is rs:ResultSetArrayWrapper && rs.Elements != null)
    {
        for (int i = 0; i < rs.Elements.Count; i++)
        {
            if (rs.Elements[i].eventData is doc:Document)
            {
                if (BuildXml(doc.ToBinXmlString(null, null)) is x:xml && x != null)
                {
                    rs.Elements[i].eventData = x;
                }
            }
        }
        return rs.Elements;
    }
    return nothing;
}

optional EvtRpcQuerySeekFlags EvtRpcQuerySeekFlagsDecoder(DWORD input)
{
    return new EvtRpcQuerySeekFlags{OriginFlags = (input & 0x000007FF) as EvtRpcQuerySeekOriginFlags, OtherFlags = (input & 0xFFFFF800) as EvtRpcQuerySeekOtherFlags};
}

optional EvtRpcRegisterRemoteSubscriptionFlags EvtRpcRegisterRemoteSubscriptionFlagsDecoder(DWORD input)
{
    return new EvtRpcRegisterRemoteSubscriptionFlags{QueryFlags = (input & 0x00000003) as EvtRpcRegisterRemoteSubscriptionQueryFlags, OtherFlags = (input & 0xFFFFFFFC) as EvtRpcRegisterRemoteSubscriptionOtherFlags};
}