protocol EFSR 
with BinaryEncodingDefaults{Endian = Endian.Little},
Documentation
{
    ProtocolName = "Encrypting File System Remote Protocol",
    ProtocolType = "rpc",
    ShortName = "EFSR",
    Description = ""
},
OPNAuthoring
{
    Copyright = "(c) Microsoft Corporation",
    References =
    [
    new Reference{Name = "MS-EFSR", Version = "23.0", Date = "10/16/2015", ProgramName = ProgramName.MCPP},
    ],
    RevisionSummary =
    [
    new Revision{Class = RevisionClass.Major, Version = "4764785", Date = "12/30/2015"}
    ]
};

using Technologies.IDL;
using DTYP;
using Utility;
using MSRPCE;
using X509;

// EfsRpc and LsaRpc have same methods but different Uuid.
endpoint DnsServerService over MSRPCE.Server 
    provides EfsRpc
    provides LsaRpc;

/* 3.1.4.2 EFSRPC Interface
 * This subsection specifies the syntax of the methods specified by the EFSRPC protocol and how to receive each one. 
 * These calls are received at the well-known endpoint of the named pipe \pipe\lsarpc or \pipe\efsrpc. 
 * The server interface for \pipe\lsarpc MUST be identified by UUID [c681d488-d850-11d0-8c52-00c04fd90f7e], version 1.0. 
 * The server interface for \pipe\efsrpc MUST be identified by UUID [df1941c5-fe89-4e79-bf10-463657acf44d], version 1.0.
 */
contract EfsRpc
{
    accepts operation EfsRpcOpenFileRaw
    {
        in optional handle_t binding_h;
        out PEXIMPORT_CONTEXT_HANDLE hContext
                with IDL{IndirectionLevel = 1};
        in string FileName
               with IDL{BaseStringType = TypeOf<wchar_t>(),
                                         String = true,
                                         IndirectionLevel = 1};
        in OpenFileRaw_Flags Flags
            with Encoding{Decoder = PatternDecoder<OpenFileRaw_Flags>, SourcePattern = TypeOf<DWORD>()};
        result IDLLong ReturnValue;
        
        override string ToString()
        {
            return "EfsRpcOpenFileRaw" + ", ReturnValue: " + ReturnValue.ToString() + 
                ", hContext: " + hContext.ToString() + 
                ", FileName: " + FileName.ToString() + 
                ", Flags: " + Flags.ToString();
        }
    }
    with IDL{Opnum = 0};
    
    accepts operation EfsRpcReadFileRaw
    {
        in PEXIMPORT_CONTEXT_HANDLE hContext;
        out RawData EfsOutPipe 
            with Encoding{Decoder = RpcPipeDecoder}, IDL{IndirectionLevel = 1};
        result IDLLong ReturnValue;
        
        override string ToString()
        {
            return "EfsRpcReadFileRaw" + ", ReturnValue: " + ReturnValue.ToString() + 
                ", hContext: " + hContext.ToString() +
                ", EfsOutPipe: " + EfsOutPipe.ToString();
        }
    }
    with IDL{Opnum = 1};
    
    accepts operation EfsRpcWriteFileRaw
    {
        in PEXIMPORT_CONTEXT_HANDLE hContext;
        in RawData EfsInPipe 
            with Encoding{Decoder = RpcPipeDecoder},
            IDL{IndirectionLevel = 1};
        result IDLLong ReturnValue;
        
        override string ToString()
        {
            return "EfsRpcWriteFileRaw" + ", ReturnValue: " + ReturnValue.ToString() + 
                ", hContext: " + hContext.ToString() +
                ", EfsInPipe: " + EfsInPipe.ToString();
        }
    }
    with IDL{Opnum = 2};
    
    accepts operation EfsRpcCloseRaw
    {
        in out PEXIMPORT_CONTEXT_HANDLE hContext
                   with IDL{IndirectionLevel = 1};
        
        override string ToString()
        {
            return "EfsRpcCloseRaw" + ", hContext: " + hContext.ToString();
        }
    }
    with IDL{Opnum = 3};
    
    accepts operation EfsRpcEncryptFileSrv
    {
        in optional handle_t binding_h;
        in string FileName
               with IDL{BaseStringType = TypeOf<wchar_t>(),
                                         String = true,
                                         IndirectionLevel = 1};
        result IDLLong ReturnValue;
        
        override string ToString()
        {
            return "EfsRpcEncryptFileSrv" + ", ReturnValue: " + ReturnValue.ToString() + 
                ", FileName: " + FileName.ToString();
        }
    }
    with IDL{Opnum = 4};
    
    accepts operation EfsRpcDecryptFileSrv
    {
        in optional handle_t binding_h;
        in string FileName
               with IDL{BaseStringType = TypeOf<wchar_t>(),
                                         String = true,
                                         IndirectionLevel = 1};
        in IDLUlong OpenFlag 
            where ValidationCheckZero(value == 0, this, true, ReferenceType.Message, 
                "EFSR", "OpenFlag", "EfsRpcDecryptFileSrv", value);
        result IDLLong ReturnValue;
        
        override string ToString()
        {
            return "EfsRpcDecryptFileSrv" + ", ReturnValue: " + ReturnValue.ToString() + 
                ", FileName: " + FileName.ToString();
        }
    }
    with IDL{Opnum = 5};
    
    accepts operation EfsRpcQueryUsersOnFile
    {
        in optional handle_t binding_h;
        in string FileName
               with IDL{BaseStringType = TypeOf<wchar_t>(),
                                         String = true,
                                         IndirectionLevel = 1};
        out ENCRYPTION_CERTIFICATE_HASH_LIST Users
                with IDL{IndirectionLevel = 2};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "EfsRpcQueryUsersOnFile" + ", ReturnValue: " + ReturnValue.ToString() + 
                ", FileName: " + FileName.ToString() + ", Users: " + Users.ToString();
        }
    }
    with IDL{Opnum = 6};
    
    accepts operation EfsRpcQueryRecoveryAgents
    {
        in optional handle_t binding_h;
        in string FileName
               with IDL{BaseStringType = TypeOf<wchar_t>(),
                                         String = true,
                                         IndirectionLevel = 1};
        out ENCRYPTION_CERTIFICATE_HASH_LIST RecoveryAgents
                with IDL{IndirectionLevel = 2};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "EfsRpcQueryRecoveryAgents" + ", ReturnValue: " + ReturnValue.ToString() + 
                ", FileName: " + FileName.ToString() +
                ", RecoveryAgents: " + RecoveryAgents.ToString();
        }
    }
    with IDL{Opnum = 7};
    
    accepts operation EfsRpcRemoveUsersFromFile
    {
        in optional handle_t binding_h;
        in string FileName
               with IDL{BaseStringType = TypeOf<wchar_t>(),
                                         String = true,
                                         IndirectionLevel = 1};
        in ENCRYPTION_CERTIFICATE_HASH_LIST Users
               with IDL{IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "EfsRpcRemoveUsersFromFile" + ", ReturnValue: " + ReturnValue.ToString() + 
                ", FileName: " + FileName.ToString() + ", Users: " + Users.ToString();
        }
    }
    with IDL{Opnum = 8};
    
    accepts operation EfsRpcAddUsersToFile
    {
        in optional handle_t binding_h;
        in string FileName
               with IDL{BaseStringType = TypeOf<wchar_t>(),
                                         String = true,
                                         IndirectionLevel = 1};
        in ENCRYPTION_CERTIFICATE_LIST EncryptionCertificates
               with IDL{IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "EfsRpcAddUsersToFile" + ", ReturnValue: " + ReturnValue.ToString() + 
                ", FileName: " + FileName.ToString() +
                ", EncryptionCertificates: " + EncryptionCertificates.ToString();
        }
    }
    with IDL{Opnum = 9};
    
    accepts operation Opnum10NotUsedOnWire
    {
    }
    with IDL{Opnum = 10};
    
    accepts operation EfsRpcNotSupported
    {
        in optional handle_t binding_h;
        in string Reserved1 
               where ValidationCheckValue(value == "", this, true, ReferenceType.Message, 
                                          "EFSR", "Reserved1", "EfsRpcNotSupported", "<empty>", value)
               with IDL{BaseStringType = TypeOf<wchar_t>(),
                                         String = true,
                                         IndirectionLevel = 1};
        in string Reserved2 
               where ValidationCheckValue(value == "", this, true, ReferenceType.Message, 
                                          "EFSR", "Reserved2", "EfsRpcNotSupported", "<empty>", value)
               with IDL{BaseStringType = TypeOf<wchar_t>(),
                                         String = true,
                                         IndirectionLevel = 1};
        in DWORD dwReserved1 
               where ValidationCheckReservedZero(value == 0, this, true, ReferenceType.Message, 
                                                 "EFSR", "dwReserved1", "EfsRpcNotSupported", value);
        in DWORD dwReserved2 where ValidationCheckReservedZero(value == 0, this, true, ReferenceType.Message, 
                                                               "EFSR", "dwReserved2", "EfsRpcNotSupported", value);
        in EFS_RPC_BLOB[0] Reserved 
               where ValidationCheckValue(value == null, this, true, ReferenceType.Message, 
                                          "EFSR", "Reserved", "EfsRpcNotSupported", "NULL", value)
               with IDL{PointerType = PointerKind.UniquePtr, IndirectionLevel = 1};
        in BOOL bReserved 
               where ValidationCheckReservedZero(value == 0, this, true, ReferenceType.Message, 
                                                 "EFSR", "bReserved", "EfsRpcNotSupported", value);
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "EfsRpcNotSupported" + ", ReturnValue: " + ReturnValue.ToString();
        }
    }
    with IDL{Opnum = 11};
    
    accepts operation EfsRpcFileKeyInfo
    {
        in optional handle_t binding_h;
        in string FileName
               with IDL{BaseStringType = TypeOf<wchar_t>(),
                                         String = true,
                                         IndirectionLevel = 1};
        in FileKeyInfo_InfoClass InfoClass
            with Encoding{Decoder = PatternDecoder<FileKeyInfo_InfoClass>, SourcePattern = TypeOf<DWORD>()};
        out EFS_RPC_BLOB[InfoClass] KeyInfo with IDL{IndirectionLevel = 2};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "EfsRpcFileKeyInfo" + ", ReturnValue: " + ReturnValue.ToString() + 
                ", FileName: " + FileName.ToString() + 
                ", InfoClass: " + InfoClass.ToString() + 
                ", KeyInfo: " + (KeyInfo == null ? "" : KeyInfo.ToString());
        }
    }
    with IDL{Opnum = 12};
    
    accepts operation EfsRpcDuplicateEncryptionInfoFile
    {
        in optional handle_t binding_h;
        in string SrcFileName
               with IDL{BaseStringType = TypeOf<wchar_t>(),
                                         String = true,
                                         IndirectionLevel = 1};
        in string DestFileName
               with IDL{BaseStringType = TypeOf<wchar_t>(),
                                         String = true,
                                         IndirectionLevel = 1};
        in DuplicateEncryptionInfoFile_dwCreationDisposition dwCreationDisposition
            where ValidationCheckEnumValue(InRange<DuplicateEncryptionInfoFile_dwCreationDisposition>(value), this, true, 
                                           ReferenceType.Message, "EFSR", "dwCreationDisposition", 
                                           "EfsRpcDuplicateEncryptionInfoFile", "0x00000001, 0x00000002", value)
               with Encoding{Decoder = PatternDecoder<DuplicateEncryptionInfoFile_dwCreationDisposition>, 
                             SourcePattern = TypeOf<DWORD>()};
        in DwAttributes_Flags dwAttributes
            with Encoding{Decoder = PatternDecoder<DwAttributes_Flags>, SourcePattern = TypeOf<DWORD>()};
        in EFS_RPC_BLOB[0] RelativeSD
               with IDL{PointerType = PointerKind.UniquePtr, IndirectionLevel = 1};
        in BOOL bInheritHandle 
            where ValidationCheckReservedZero(value == 0, this, true, ReferenceType.Message, 
                                              "EFSR", "bInheritHandle", "EfsRpcDuplicateEncryptionInfoFile", value);
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "EfsRpcDuplicateEncryptionInfoFile" + ", ReturnValue: " + ReturnValue.ToString() + 
                ", SrcFileName: " + SrcFileName.ToString() + ", DestFileName: " + DestFileName.ToString() + 
                ", dwCreationDisposition: " +dwCreationDisposition.ToString() + 
                ", dwAttributes: " + dwAttributes.ToString() + ", bInheritHandle: " + bInheritHandle.ToString();
        }
    }
    with IDL{Opnum = 13};
    
    accepts operation Opnum14NotUsedOnWire
    {
    }
    with IDL{Opnum = 14};
    
    accepts operation EfsRpcAddUsersToFileEx
    {
        in optional handle_t binding_h;
        in AddUsersToFileEx_dwFlags dwFlags
            with Encoding{Decoder = PatternDecoder<AddUsersToFileEx_dwFlags>, SourcePattern = TypeOf<DWORD>()};
        in EFS_RPC_BLOB[0] Reserved 
            where ValidationCheckValue(value == null, this, true, ReferenceType.Message, 
                                       "EFSR", "Reserved", "EfsRpcAddUsersToFileEx", "NULL", value)
            with IDL
                    {PointerType = PointerKind.UniquePtr, IndirectionLevel = 1};
        in string FileName
               with IDL{BaseStringType = TypeOf<wchar_t>(),
                                         String = true,
                                         IndirectionLevel = 1};
        in ENCRYPTION_CERTIFICATE_LIST EncryptionCertificates
               with IDL{IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "EfsRpcAddUsersToFileEx" + ", ReturnValue: " + ReturnValue.ToString() + 
                ", dwFlags: " + dwFlags.ToString() + ", FileName: " + FileName.ToString() + 
                ", EncryptionCertificates: " + EncryptionCertificates.ToString();
        }
    }
    with IDL{Opnum = 15};
    
    accepts operation EfsRpcFileKeyInfoEx
    {
        in optional handle_t binding_h;
        in DWORD dwFileKeyInfoFlags 
               where ValidationCheckZero(value == 0, this, true, ReferenceType.Message, "EFSR", 
                                          "dwFileKeyInfoFlags", "EfsRpcFileKeyInfoEx", value);
        in EFS_RPC_BLOB[0] Reserved
               where ValidationCheckValue(value == null, this, true, ReferenceType.Message, "EFSR", 
                                          "Reserved", "EfsRpcFileKeyInfoEx", "NULL", value)
               with IDL
                        {PointerType = PointerKind.UniquePtr, IndirectionLevel = 1};
        in string FileName
               with IDL{BaseStringType = TypeOf<wchar_t>(),
                                         String = true,
                                         IndirectionLevel = 1};
        in DWORD InfoClass;
        out EFS_RPC_BLOB[InfoClass] KeyInfo with IDL{IndirectionLevel = 2};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "EfsRpcFileKeyInfoEx" + ", ReturnValue: " + ReturnValue.ToString() + 
                ", FileName: " + FileName.ToString() + ", InfoClass: " + InfoClass.ToString() +
                ", KeyInfo: " + (KeyInfo == null ? "" : KeyInfo.ToString());
        }
    }
    with IDL{Opnum = 16};
    
    accepts operation Opnum17NotUsedOnWire
    {
    }
    with IDL{Opnum = 17};
    
    accepts operation EfsRpcGetEncryptedFileMetadata
    {
        in optional handle_t binding_h;
        in string FileName
               with IDL{PointerType = PointerKind.RefPtr,
                                         BaseStringType = TypeOf<wchar_t>(),
                                         String = true,
                                         IndirectionLevel = 1};
        out EFS_RPC_BLOB[0] EfsStreamBlob
                with IDL
                         {PointerType = PointerKind.RefPtr, IndirectionLevel = 2};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "EfsRpcGetEncryptedFileMetadata" + ", ReturnValue: " + ReturnValue.ToString() + 
                ", FileName: " + FileName.ToString();
        }
    }
    with IDL{Opnum = 18};
    
    accepts operation EfsRpcSetEncryptedFileMetadata
    {
        in optional handle_t binding_h;
        in string FileName
               with IDL{PointerType = PointerKind.RefPtr,
                                         BaseStringType = TypeOf<wchar_t>(),
                                         String = true,
                                         IndirectionLevel = 1};
        in EFS_RPC_BLOB[0] OldEfsStreamBlob
               where ValidationCheckValue(value == null, this, true, ReferenceType.Message, "EFSR", 
                                          "OldEfsStreamBlob", "EfsRpcSetEncryptedFileMetadata", "NULL", value)
               with IDL
                        {PointerType = PointerKind.UniquePtr, IndirectionLevel = 1};
        in EFS_RPC_BLOB[0] NewEfsStreamBlob
               where ValidationCheckValue(value == null, this, true, ReferenceType.Message, "EFSR", 
                                          "NewEfsStreamBlob", "EfsRpcSetEncryptedFileMetadata", "NULL", value)
               with IDL
                        {PointerType = PointerKind.RefPtr, IndirectionLevel = 1};
        in ENCRYPTED_FILE_METADATA_SIGNATURE NewEfsSignature
               where ValidationCheckValue(value == null, this, true, ReferenceType.Message, "EFSR", 
                                          "NewEfsSignature", "EfsRpcSetEncryptedFileMetadata", "NULL", value)
               with IDL
                        {PointerType = PointerKind.UniquePtr, IndirectionLevel = 1};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "EfsRpcSetEncryptedFileMetadata" + ", ReturnValue: " + ReturnValue.ToString() + 
                ", FileName: " + FileName.ToString() +
                ", OldEfsStreamBlob: " + OldEfsStreamBlob.ToString() +
                ", NewEfsStreamBlob: " + NewEfsStreamBlob.ToString() +
                ", NewEfsSignature: " + NewEfsSignature.ToString();
        }
    }
    with IDL{Opnum = 19};
    
    accepts operation EfsRpcFlushEfsCache
    {
        in optional handle_t binding_h;
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "EfsRpcFlushEfsCache" + ", ReturnValue: " + ReturnValue.ToString();
        }
    }
    with IDL{Opnum = 20};
    
    accepts operation EfsRpcEncryptFileExSrv
    {
        in optional handle_t binding_h;
        in string FileName
               with IDL{BaseStringType = TypeOf<wchar_t>(),
                                         String = true,
                                         IndirectionLevel = 1};
        in EncryptFileExSrv_Descriptor ProtectorDescriptor
               with IDL{PointerType = PointerKind.UniquePtr,
                                         BaseStringType = TypeOf<wchar_t>(),
                                         String = true,
                                         IndirectionLevel = 1},
                Encoding
                {
                    Decoder = DescriptorDecoder, 
                    SourceConverter = ArrayByte2String, 
                    SourcePattern = TypeOf<array<byte>>()
                };
        in IDLUlong Flags where ValidationCheckZero(value == 0, this, true, ReferenceType.Message, 
                                                    "EFSR", "Flags", "EfsRpcEncryptFileExSrv", value);
        result IDLLong ReturnValue;

        override string ToString()
        {
            return "EfsRpcEncryptFileExSrv" + ", ReturnValue: " +
                ReturnValue.ToString() + ", FileName: " + FileName.ToString() +
                ", ProtectorDescriptor: " + ProtectorDescriptor.ToString() +
                ", Flags: " + Flags.ToString();
        }
    }
    with IDL{Opnum = 21};
    
    accepts operation EfsRpcQueryProtectors
    {
        in optional handle_t binding_h;
        in string FileName
               with IDL{BaseStringType = TypeOf<wchar_t>(),
                                         String = true,
                                         IndirectionLevel = 1};
        out PENCRYPTION_PROTECTOR_LIST ppProtectorList
                with IDL{IndirectionLevel = 2};
        result DWORD ReturnValue;
        
        override string ToString()
        {
            return "EfsRpcQueryProtectors" + ", ReturnValue: " +
                ReturnValue.ToString() + ", FileName: " + FileName.ToString() + 
                ", ppProtectorList: " + ppProtectorList.ToString();
        }
    }
    with IDL{Opnum = 22};
    
    accepts operation Opnum23NotUsedOnWire
    {
    }
    with IDL{Opnum = 23};
    
    accepts operation Opnum24NotUsedOnWire
    {
    }
    with IDL{Opnum = 24};
    
    accepts operation Opnum25NotUsedOnWire
    {
    }
    with IDL{Opnum = 25};
    
    accepts operation Opnum26NotUsedOnWire
    {
    }
    with IDL{Opnum = 26};
    
    accepts operation Opnum27NotUsedOnWire
    {
    }
    with IDL{Opnum = 27};
    
    accepts operation Opnum28NotUsedOnWire
    {
    }
    with IDL{Opnum = 28};
    
    accepts operation Opnum29NotUsedOnWire
    {
    }
    with IDL{Opnum = 29};
    
    accepts operation Opnum30NotUsedOnWire
    {
    }
    with IDL{Opnum = 30};
    
    accepts operation Opnum31NotUsedOnWire
    {
    }
    with IDL{Opnum = 31};
    
    accepts operation Opnum32NotUsedOnWire
    {
    }
    with IDL{Opnum = 32};
    
    accepts operation Opnum33NotUsedOnWire
    {
    }
    with IDL{Opnum = 33};
    
    accepts operation Opnum34NotUsedOnWire
    {
    }
    with IDL{Opnum = 34};
    
    accepts operation Opnum35NotUsedOnWire
    {
    }
    with IDL{Opnum = 35};
    
    accepts operation Opnum36NotUsedOnWire
    {
    }
    with IDL{Opnum = 36};
    
    accepts operation Opnum37NotUsedOnWire
    {
    }
    with IDL{Opnum = 37};
    
    accepts operation Opnum38NotUsedOnWire
    {
    }
    with IDL{Opnum = 38};
    
    accepts operation Opnum39NotUsedOnWire
    {
    }
    with IDL{Opnum = 39};
    
    accepts operation Opnum40NotUsedOnWire
    {
    }
    with IDL{Opnum = 40};
    
    accepts operation Opnum41NotUsedOnWire
    {
    }
    with IDL{Opnum = 41};
    
    accepts operation Opnum42NotUsedOnWire
    {
    }
    with IDL{Opnum = 42};
    
    accepts operation Opnum43NotUsedOnWire
    {
    }
    with IDL{Opnum = 43};
    
    accepts operation Opnum44NotUsedOnWire
    {
    }
    with IDL{Opnum = 44};
}
with IDL{Uuid = {DF1941C5-FE89-4E79-BF10-463657ACF44D}, Version = "1.0"};

contract LsaRpc provides EfsRpc
{}
with IDL{Uuid = {C681D488-D850-11D0-8C52-00C04FD90F7E}, Version = "1.0"};

typedef PEXIMPORT_CONTEXT_HANDLE = ContextHandle;

type ENCRYPTION_CERTIFICATE_HASH_LIST
{
    DWORD nCert_Hash
        with IDL{Range = new RangePattern{Low = 0, High = 500}};
    array<ENCRYPTION_CERTIFICATE_HASH> Users
        with IDL{Size_is = [nCert_Hash, null], IndirectionLevel = 2};
}

type ENCRYPTION_CERTIFICATE_HASH
{
    DWORD cbTotalLength;
    RPC_SID UserSid with IDL{IndirectionLevel = 1};
    EFS_HASH_BLOB Hash with IDL{IndirectionLevel = 1};
    string lpDisplayInformation
        with IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1};
}

type EFS_HASH_BLOB
{
    DWORD cbData
        with IDL{Range = new RangePattern{Low = 0, High = 100}};
    array<char> bData
        with IDL{Size_is = [cbData], IndirectionLevel = 1};
}

type ENCRYPTION_CERTIFICATE_LIST
{
    DWORD nUsers
        with IDL{Range = new RangePattern{Low = 0, High = 500}};
    array<ENCRYPTION_CERTIFICATE> Users
        with IDL{Size_is = [nUsers, null], IndirectionLevel = 2};
}

type ENCRYPTION_CERTIFICATE
{
    DWORD cbTotalLength;
    RPC_SID UserSid with IDL{IndirectionLevel = 1};
    EFS_CERTIFICATE_BLOB CertBlob
        with IDL{IndirectionLevel = 1};
}

typedef EFS_CERTIFICATE_BLOB = CERTIFICATE_BLOB;

type CERTIFICATE_BLOB
{
    DwCertEncodingType dwCertEncodingType
        where ValidationCheckEnumValue(InRange<DwCertEncodingType>(value), null, true, 
            ReferenceType.Type, "EFSR", "dwCertEncodingType", "CERTIFICATE_BLOB", "0x00000001, 0x00000002", value)
        with Encoding{Decoder = PatternDecoder<DwCertEncodingType>, SourcePattern = TypeOf<DWORD>()};
    DWORD cbData
        with IDL{Range = new RangePattern{Low = 0, High = 32768}};
    (X509.Certificate | array<CHAR>) bData
        with Encoding{Decoder = CertificateDecoder}, IDL{Size_is = [cbData], IndirectionLevel = 1};

    optional (X509.Certificate | array<CHAR>) CertificateDecoder(stream s)
    {
        var arrayChar = NdrDecoder<ArrayChar>(s);
        if (arrayChar == nothing)
            return nothing;

        if (cbData == 0 || (arrayChar as ArrayChar).Array.Count == 0 || dwCertEncodingType == DwCertEncodingType.X509NDR)
            return arrayChar;

        binary  bin = (arrayChar as ArrayChar).Array as binary;
        return Asn1BerDecoder<X509.Certificate>(bin as stream);
    }
}

type ArrayChar
{
    array<CHAR> Array with Technologies.IDL.IDL{Size_is = [0]};
} with IDL{Ignore = true};

type EFS_RPC_BLOB[uint InfoClass]
{
    DWORD cbData
        with IDL{Range = new RangePattern{Low = 0, High = 266240}};
    optional PatternRpcBlobData bData
        with Encoding
            {
                Decoder = BlobDataDecoder,
                SourcePattern = TypeOf<array<char>>()
            },
            IDL{Size_is = [cbData], IndirectionLevel = 1};

    optional PatternRpcBlobData BlobDataDecoder(array<char> bData)
    {
        if (InfoClass == 0 || bData.Count == 0)
            return bData;

        array<byte> arrayByte = [];
        foreach (char c in bData)
        {
            arrayByte += [c as byte];
        }

        PatternRpcBlobData result;
        switch (InfoClass)
        {
            case 0x00000001 =>
                return(BinaryDecoder<EFS_KEY_INFO>(arrayByte as binary));
            case 0x00000002 =>
                return (BinaryDecoder<EFS_COMPATIBILITY_INFO>(arrayByte as binary));
            case 0x00000100 =>
                return (BinaryDecoder<EFS_UPDATE_KEY_USED_INFO>(arrayByte as binary));
            case 0x00000200 =>
                return (BinaryDecoder<EFS_ENCRYPTION_STATUS_INFO>(arrayByte as binary));
            case 0x00000400 =>
                return (BinaryDecoder<EFS_DECRYPTION_STATUS_INFO>(arrayByte as binary));
            default => return bData;
        }
    }
}

pattern PatternRpcBlobData = EFS_KEY_INFO | EFS_COMPATIBILITY_INFO | EFS_UPDATE_KEY_USED_INFO | 
                             EFS_ENCRYPTION_STATUS_INFO | EFS_DECRYPTION_STATUS_INFO | array<char>;

type EFS_KEY_INFO
{
    DWORD dwVersion 
        where ValidationCheckValue(value == 1, null, true, ReferenceType.Type, "EFSR", "dwVersion", "EFS_KEY_INFO", 1, value);
    IDLUlong Entropy;
    Algorithm_ID Algorithm;
    IDLUlong KeyLength;
} with IDL{DoNotGenerate = true};

type EFS_COMPATIBILITY_INFO
{
    MetadataEFS_Version1 EfsVersion
        where ValidationCheckEnumValue(InRange<MetadataEFS_Version1>(value), null, true, ReferenceType.Type, "EFSR", 
                                       "EFS_Version", "EFS_COMPATIBILITY_INFO", "0x00000001, 0x00000002, 0x00000003", value);
} with IDL{DoNotGenerate = true};

type EFS_UPDATE_KEY_USED_INFO
{
    string Value with BinaryEncoding{TextEncoding = TextEncoding.Unicode};
} with IDL{DoNotGenerate = true};

type EFS_ENCRYPTION_STATUS_INFO
{
    BOOL bHasCurrentKey;
    DWORD dwEncryptionError;
} with IDL{DoNotGenerate = true};

type EFS_DECRYPTION_STATUS_INFO
{
    DWORD dwDecryptionError;
    DWORD dwHashOffset;
    DWORD cbHash;
} with IDL{DoNotGenerate = true};

type ENCRYPTED_FILE_METADATA_SIGNATURE
{
    DwEfsAccessType dwEfsAccessType
        with Encoding{Decoder = PatternDecoder<DwEfsAccessType>, SourcePattern = TypeOf<DWORD>()};
    ENCRYPTION_CERTIFICATE_HASH_LIST CertificatesAdded
        with IDL{IndirectionLevel = 1};
    ENCRYPTION_CERTIFICATE EncryptionCertificate
        with IDL{IndirectionLevel = 1};
    EFS_RPC_BLOB[0] EfsStreamSignature
        with IDL{IndirectionLevel = 1};
}

typedef PENCRYPTION_PROTECTOR_LIST = ENCRYPTION_PROTECTOR_LIST with IDL{IndirectionLevel = 1};

type ENCRYPTION_PROTECTOR_LIST
{
    DWORD nProtectors;
    array<ENCRYPTION_PROTECTOR> pProtectors
        with IDL{Size_is = [nProtectors, null], IndirectionLevel = 2};
} with IDL{DoNotGenerate = true};

type ENCRYPTION_PROTECTOR
{
    DWORD cbTotalLength;
    RPC_SID UserSid with IDL{IndirectionLevel = 1};
    optional EncryptFileExSrv_Descriptor lpProtectorDescriptor
        with IDL{BaseStringType = TypeOf<wchar_t>(),
                                  String = true,
                                  IndirectionLevel = 1},
        Encoding
        {
            Decoder = DescriptorDecoder, 
            SourceConverter = ArrayByte2String, 
            SourcePattern = TypeOf<array<byte>>()
        };
} with IDL{DoNotGenerate = true};

optional RawData RpcPipeDecoder(stream s)
{
    array<byte> arrayByte = AssemblePipeData<byte>(s);
    if (arrayByte.Count > 0)
        return(BinaryDecoder<RawData>(arrayByte as binary));
    else
        return nothing;
}

array<T> AssemblePipeData<T>(stream s)
{
    array<T> pipeData = [];
    while (s.BytePosition + 4 < s.ByteLength)
    {
        // NdrDecoder only handles padding among fields inside T.
        // For paddings among pipe chunks we need to manually consume.
        int padLength = s.BytePosition % 4;
        if (padLength != 0)
        {
            optional NdrPad pad = BinaryDecoder<NdrPad[padLength]>(s);
        }
        
        uint chunkSize = s.PeekUInt(s.BitPosition, Endian.Little);
        if (chunkSize == 0)
            break;

        optional NdrPipeChunk<T> pipeChunk = NdrDecoder<NdrPipeChunk<T>>(s);
        if (!(pipeChunk is nothing))
        {
            pipeData += (pipeChunk as NdrPipeChunk).Elements;
        }
        else
            break;
    }
    return pipeData;
}

optional EncryptFileExSrv_Descriptor DescriptorDecoder(string str)
{
    if (str.Count == 0)
        return null;
    if (str.Count >= 11 && str.Segment(0, 11) == "EFSRMSDESC=")
        return new EncryptFileExSrv_Descriptor{Protectors = str};
    if ((str.Count >= 19 && str.Segment(0, 19) == "LOCKEDCREDENTIALS=") || 
        (str.Count >= 18 && str.Segment(0, 18) == "VAULTCREDENTIALS="))
        return new EncryptFileExSrv_Descriptor{Protectors = DpapiNgDescriptorDecoder(str)};
    return null;
};

optional xml BuildXmlDecoder(array<byte> arrayByte)
{
    if (arrayByte.Count == 0)
        return null;
    return BuildXml(arrayByte as binary);
}

array<EncryptFileExSrv_Protector> DpapiNgDescriptorDecoder(string str)
{
    array<EncryptFileExSrv_Protector> protectors = [];
    array<string> arrProtectors = str.Split(["OR"]);
    if (arrProtectors.Count == 0)
        return protectors;

    foreach (string item in arrProtectors)
    {
        if (item.Count < 3) // includes at least 1 "AND"
            continue;
        array<string> arrProtector = item.Split(["AND"]);
        if (arrProtector.Count == 0)
            continue;

        EncryptFileExSrv_Protector protector = new EncryptFileExSrv_Protector{Providers = []};
        foreach (string strProtector in arrProtector)
        {
            if (strProtector.Count == 0)
                continue;
            array<string> ele = strProtector.Split(["="]);
            if (ele.Count != 2)
                continue;
            EncryptFileExSrv_Provider provider = new EncryptFileExSrv_Provider{Name = ele[0], Attribute = ele[1]};
            protector.Providers += [provider];
        }
        if (protector.Providers.Count > 0)
            protectors += [protector];
    }
    return protectors;
}

optional string ArrayByte2String(array<byte> arr)
{
    if (arr != null && arr.Count > 0)
    {
        string sum = "";
        for (int i= 0; i < arr.Count; i++)
        {
            sum += arr[i] as string;
        }
        return sum.Segment(0, sum.Count - 1);
    }
    return "";
}

optional stream ArrayChar2Stream(array<CHAR> arrayChar)
{
    binary b = arrayChar as binary;
    return (b as stream);
}

optional binary ArrayChar2Binary(array<char> arrayChar)
{
    array<byte> arrayByte = [];
    foreach (char c in arrayChar)
    {
        arrayByte += [c as byte];
    }
    return arrayByte as binary;
}

type NdrPipeChunk<T>
{
    // NdrDecoder will consume the first 4 bytes as the actual unit size of the array.
    array<T> Elements with IDL{Size_is = [0]};
} with IDL{DoNotGenerate = true};

type NdrPad[int PadLength]
{
    binary Pad with BinaryEncoding{Length = PadLength};
} with IDL{DoNotGenerate = true};

type EncryptFileExSrv_Descriptor
{
    optional (string|array<EncryptFileExSrv_Protector>) Protectors with IDL{Size_is = [0]};
} with IDL{DoNotGenerate = true};

type EncryptFileExSrv_Protector
{
    array<EncryptFileExSrv_Provider> Providers with IDL{Size_is = [0]};
} with IDL{DoNotGenerate = true};

type EncryptFileExSrv_Provider
{
    string Name;
    string Attribute;

    override string ToString()
    {
        return Name + "=" + Attribute;
    }
} with IDL{DoNotGenerate = true};

// -------Structs embeded in pipe type, defined in section 2.2.2 and 2.2.3-------
type RawData
{
    binary Pad 
        where ValidationCheckValue(value == RawDataPadBinary, null, true, ReferenceType.Type, "EFSR", 
                                   "Pad", "RawData", RawDataPadBinary.ToString(), value)
        with BinaryEncoding{Length = 12};
    binary Reserved 
        where ValidationCheckValue(value == Reserved8Binary, null, true, ReferenceType.Type, "EFSR", 
                                   "Reserved", "RawData", Reserved8Binary.ToString(), value)
        with BinaryEncoding{Length = 8};
    MarshaledStream EFSRPCMetadataStream;
    array<PatternMarshaledStream> AdditionalStreams with IDL{Size_is = [0]};

    override string ToString()
    {
        string summary = "EFSRPCMetadataStream: {" + EFSRPCMetadataStream.ToString() + "}";
        if (AdditionalStreams.Count > 0)
        {
            int i = 0;
            foreach (MarshaledStream addtionalStream in AdditionalStreams)
            {
                i++;
                summary += "; AdditionalStream " + i.ToString() + ": {" + addtionalStream.ToString() + "}";
            }
        }
        return summary;
    }
} with IDL{DoNotGenerate = true};

pattern PatternMarshaledStream = [|PeekBytes(stream, stream.BitPosition + 32, 8) == MarshaledStreamPadBinary|] MarshaledStream;

type MarshaledStream
{
    uint Length;
    binary Pad 
        where ValidationCheckValue(value == MarshaledStreamPadBinary, null, true, ReferenceType.Type, "EFSR", "Pad", 
                                   "MarshaledStream", MarshaledStreamPadBinary.ToString(), value)
        with BinaryEncoding{Length = 8};
    MarshaledStream_Flag Flag
               where ValidationCheckEnumValue(InRange<MarshaledStream_Flag>(value), null, true, ReferenceType.Type, "EFSR", 
                                              "Flag", "MarshaledStream", "0x00000001, 0x00000002", value);
    binary Reserved 
        where ValidationCheckValue(value == Reserved8Binary, null, true, ReferenceType.Type, "EFSR", "Reserved", 
                                   "MarshaledStream", Reserved8Binary.ToString(), value)
        with BinaryEncoding{Length = 8};
    uint NameLength;
    ([|NameLength == 2|] ushort | string) StreamName 
        with BinaryEncoding{TextEncoding = TextEncoding.UTF16, Length = NameLength / 2};
    array<StreamDataSegment> StreamDataSegments with Encoding{Decoder = StreamDataSegmentsDecoder};

    optional array<StreamDataSegment> StreamDataSegmentsDecoder(stream s)
    {
        array<StreamDataSegment> dataSegements = [];
        while (s.RemainingByteLength > 12 && s.PeekBytes(s.BitPosition + 32, 8) == StreamDataPadBinary)
        {
            var dataSegement = BinaryDecoder<StreamDataSegment[NameLength != 2]>(s);
            if (dataSegement == nothing)
            {
                ValidationCheck(false, null, DiagnosisLevel.Error, "StreamDataSegment in MarshaledStream decoding failed.");
                break;
            }
            dataSegements += [dataSegement as StreamDataSegment];
        }
        return dataSegements;
    }
    
    override string ToString()
    {
        return "StreamName=" + (NameLength == 2 ? DecToHexFormat(StreamName as ushort) : (StreamName as string));
    }
} with IDL{DoNotGenerate = true};

pattern MarshaledStream_Flag = enum uint
{
    FEKEncryptionPresent = 0x00000000,
    FEKEncryptionNotPresent = 0x00000001,
    ...
} with IDL{DoNotGenerate = true};

pattern PatternStreamDataSegment = [|stream.RemainingByteLength > 12 &&
                                     PeekBytes(stream, stream.BitPosition + 32, 8) == StreamDataPadBinary|] StreamDataSegment
     with IDL{DoNotGenerate = true};

type StreamDataSegment[bool IsEncryptionHeaderPresent]
{
    uint Length;
    binary Pad
        where ValidationCheckValue(value == StreamDataPadBinary, null, true, ReferenceType.Type, "EFSR", "Pad", 
                                   "StreamDataSegment", StreamDataPadBinary.ToString(), value)
        with BinaryEncoding{Length = 8};
    binary Reserved
        where ValidationCheckValue(value == Reserved4Binary, null, true, ReferenceType.Type, "EFSR", "Reserved", 
                                   "StreamDataSegment", Reserved4Binary.ToString(), value)
        with BinaryEncoding{Length = 4};
    optional [|IsEncryptionHeaderPresent|] DataSegmentEncryptionHeader DataSegmentEncryptionHeader;
    optional ([|stream.RemainingByteLength > 12 &&
                PeekUInt(stream, stream.BitPosition + 64, Endian.Little) in [1, 2, 3]|] MetadataVersion1 |
              [|stream.RemainingByteLength > 12 && 
                PeekUInt(stream, stream.BitPosition + 64, Endian.Little) in [4, 5]|] MetadataVersion2 |
              [|stream.RemainingByteLength > 12 && 
                PeekUShort(stream, stream.BitPosition + 48, Endian.Little) == 2 &&
                PeekUShort(stream, stream.BitPosition + 80, Endian.Little) == 1 |] MetadataVersion3) StreamData
                    with BinaryEncoding
                        {
                            WidthForComposedType = 8 * (Length - 16 - 
                                                        (IsEncryptionHeaderPresent ? (DataSegmentEncryptionHeader as DataSegmentEncryptionHeader).Length : 0))
                        };
} with IDL{DoNotGenerate = true};

type DataSegmentEncryptionHeader
{
    ulong StartingFileOffset;
    uint Length;
    uint BytesWithinStreamSize;
    uint BytesWithinVDL;
    ushort Pad1 where ValidationCheckZero(value == 0, null, true, ReferenceType.Type, "EFSR", 
                                           "Pad1", "DataSegmentEncryptionHeader", value);
    byte DataUnitShift;
    byte ChunkShift;
    byte ClusterShift;
    byte Pad2 where ValidationCheckValue(value == 1, null, true, ReferenceType.Type, "EFSR", 
                                         "Pad2", "DataSegmentEncryptionHeader", 1, value);
    ushort NumberofDataBlocks;
    array<uint> DataBlockSizes 
        with BinaryEncoding{Length = NumberofDataBlocks}, IDL{Size_is = [NumberofDataBlocks]};
    optional [|PeekBytes(stream, stream.BitPosition, 4) == ExtendedHeaderPad1Binary|] ExtendedHeader ExtendedHeader;
    binary Pad3 with BinaryEncoding{Length = Length - 28 - NumberofDataBlocks * 4 - (ExtendedHeader == null ? 0 : 16)};
} with IDL{DoNotGenerate = true};

type ExtendedHeader
{
    binary Pad1 where ValidationCheckValue(value == ExtendedHeaderPad1Binary, null, true, ReferenceType.Type, "EFSR",
                                           "Pad1", "ExtendedHeader", ExtendedHeaderPad1Binary.ToString(), value)
        with BinaryEncoding{Length = 4};
    binary Pad2 where ValidationCheckValue(value == ExtendedHeaderPad2Binary, null, true, ReferenceType.Type, "EFSR",
                                           "Pad2", "ExtendedHeader", ExtendedHeaderPad2Binary.ToString(), value)
    with BinaryEncoding{Length = 4};
    ExtendedHeader_Falgs Flags
        where ValidationCheckEnumValue(InRange<ExtendedHeader_Falgs>(value), null, true, ReferenceType.Type, "EFSR", 
                                       "Flags", "ExtendedHeader", "0x00000000, 0x00000001", value);
    uint Reserved where ValidationCheckZero(value == 0, null, true, ReferenceType.Type, "EFSR", 
                                             "Reserved", "ExtendedHeader", value);
} with IDL{DoNotGenerate = true};

type MetadataVersion1
{
    uint Length;
    uint Reserved1 where ValidationCheckZero(value == 0, null, true, ReferenceType.Type, "EFSR", 
                                              "Reserved1", "MetadataVersion1", value);
    MetadataEFS_Version1 EFS_Version
        where ValidationCheckEnumValue(InRange<MetadataEFS_Version1>(value), null, true, ReferenceType.Type, "EFSR", 
                                       "EFS_Version", "MetadataVersion1", "0x00000001, 0x00000002, 0x00000003", value);
    uint Reserved2 where ValidationCheckZero(value == 0, null, true, ReferenceType.Type, "EFSR", 
                                              "Reserved2", "MetadataVersion1", value);
    guid EFS_ID;
    binary EFS_Hash
        where ValidationCheckValue(value == Reserved16Binary, null, true, ReferenceType.Type, "EFSR", 
                                   "EFS_Hash", "MetadataVersion1", Reserved16Binary.ToString(), value)
        with BinaryEncoding{Length = 16};
    binary Reserved3
        where ValidationCheckValue(value == Reserved16Binary, null, true, ReferenceType.Type, "EFSR", 
                                   "Reserved3", "MetadataVersion1", Reserved16Binary.ToString(), value)
        with BinaryEncoding{Length = 16};
    uint DDF_Offset;
    uint DRF_Offset;
    binary Reserved4
        where ValidationCheckValue(value == Reserved12Binary, null, true, ReferenceType.Type, "EFSR", 
                                   "Reserved3", "MetadataVersion1", Reserved12Binary.ToString(), value)
        with BinaryEncoding{Length = 12};
    KeyList DDF_key_list with Encoding{Offset = DDF_Offset};
    optional [|DRF_Offset != 0|] KeyList DRF_key_list with Encoding{Offset = DRF_Offset};
} with IDL{DoNotGenerate = true};

type KeyList
{
    uint Length;
    optional array<KeyListEntry> KeyList 
        with BinaryEncoding{Length = Length}, IDL{Size_is = [Length]},
            Encoding{Decoder = KeyListEntriesDecoder};

    optional array<KeyListEntry> KeyListEntriesDecoder(stream s)
    {
        uint i = 0;
        array<KeyListEntry> keyList = [];
        while (i < Length)
        {
            var result = BinaryDecoder<KeyListEntry>(s);
            if (result == nothing)
            {
                ValidationCheck(false, null, DiagnosisLevel.Error, "KeyListEntry in KeyList decoding failed.");
                break;
            }
            KeyListEntry keyListEntry = result as KeyListEntry;
            keyList += [keyListEntry];
            BinaryDecoder<Padding[keyListEntry.Length - 28]>(s); // BitPosition offsetting
            i++;
        }
        return keyList;
    }
} with IDL{DoNotGenerate = true};

type KeyListEntry
{
    uint Length;
    uint OffsettoPublicKeyInformation;
    uint EncryptedFEKLength;
    uint OffsettoEncryptedFEK;
    KeyListEntry_Flag Flag
        where ValidationCheckEnumValue(InRange<KeyListEntry_Flag>(value), null, true, ReferenceType.Type, "EFSR", 
                                       "Flag", "KeyListEntry", "0x00000000, 0x00000001", value);
    PublicKeyInformation PublicKeyInformation with Encoding{Offset = OffsettoPublicKeyInformation};
    binary EncryptedFEK with Encoding{Offset = OffsettoEncryptedFEK}, BinaryEncoding{Length = EncryptedFEKLength};
} with IDL{DoNotGenerate = true};

type Padding[uint Length]
{
    binary Padding with BinaryEncoding{Length = Length};
}

pattern KeyListEntry_Flag = enum uint
{
    EncryptedUsingRSA = 0x00000000,
    EncryptedUsingAES256 = 0x00000001,
    ...
} with IDL{DoNotGenerate = true};

type PublicKeyInformation
{
    uint Length;
    uint OffsettoOwnerHint;
    binary Pad 
        where ValidationCheckValue(value == PublicKeyInformationPadBinary, null, true, ReferenceType.Type, "EFSR", 
                                   "Pad", "PublicKeyInformation", PublicKeyInformationPadBinary.ToString(), value)
        with BinaryEncoding{Length = 4};
    uint LengthofCertificateData;
    uint OffsettoCertificateData;
    binary Reserved 
        where ValidationCheckValue(value == Reserved8Binary, null, true, ReferenceType.Type, "EFSR", 
                                   "Reserved", "PublicKeyInformation", Reserved8Binary.ToString(), value)
        with BinaryEncoding{Length = 8};
    optional [|OffsettoOwnerHint != 0|] SID OwnerHint with Encoding{Offset = OffsettoOwnerHint};
    CertificateData CertificateData with Encoding{Offset = OffsettoCertificateData};
} with IDL{DoNotGenerate = true};

type CertificateData
{
    uint OffsettoCertificateThumbprint;
    uint LengthofCertificateThumbprint;
    uint OffsetofContainerName;
    uint OffsetofProviderName;
    uint OffsetofDisplayName;
    binary CertificateThumbprint 
        with Encoding{Offset = OffsettoCertificateThumbprint, Size = LengthofCertificateThumbprint};
    optional [|OffsetofContainerName != 0|] string ContainerName 
        with Encoding{Offset = OffsetofContainerName},
             BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|OffsetofProviderName != 0|] string ProviderName 
        with Encoding{Offset = OffsetofProviderName},
             BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional [|OffsetofDisplayName != 0|] string DisplayName 
        with Encoding{Offset = OffsetofDisplayName},
             BinaryEncoding{TextEncoding = TextEncoding.Unicode};
} with IDL{DoNotGenerate = true};

// This type is not used in KeyListEntry because the data is always encryped.
type EncryptedFEK
{
    uint KeyLength;
    uint Entropy;
    Algorithm_ID Algorithm;
    uint Reserved;
    binary Key with BinaryEncoding{Length = KeyLength};
} with IDL{DoNotGenerate = true};

type MetadataVersion2
{
    uint Length;
    uint Reserved1 where ValidationCheckZero(value == 0, null, true, ReferenceType.Type, "EFSR", 
                                              "Reserved1", "MetadataVersion2", value);
    MetadataEFS_Version2 EFS_Version
        where ValidationCheckEnumValue(InRange<MetadataEFS_Version2>(value), null, true, 
            ReferenceType.Type, "EFSR", "EFS_Version", "Metadata", "0x00000004, 0x00000005", value);
    uint Reserved2 where ValidationCheckZero(value == 0, null, true, ReferenceType.Type, "EFSR", 
                                              "Reserved2", "MetadataVersion2", value);
    guid EFS_ID;
    uint DDF_Offset;
    uint DRF_Offset;
    EFSXDatum FekInfo_Datum;
    ProtectorList DDF_protector_list with Encoding{Offset = DDF_Offset};
    optional [|DRF_Offset != 0|] ProtectorList DRF_protector_list with Encoding{Offset = DRF_Offset};
} with IDL{DoNotGenerate = true};

pattern PatternEFSXDatum = 
    [|PeekUShort(stream, 16, Endian.Little) >= 0 && PeekUShort(stream, 16, Endian.Little) <= 12 && // Role in [0, 12]
        PeekUShort(stream, 32, Endian.Little) >= 0 && PeekUShort(stream, 32, Endian.Little) <= 7 && // Type in [0, 7]
        PeekUShort(stream, 48, Endian.Little) >= 0 && PeekUShort(stream, 48, Endian.Little) <= 3 // Flags in [0, 3]
    |] EFSXDatum 
    with IDL{DoNotGenerate = true};

type EFSXDatum
{
    ushort StructureSize;
    EFSXDatumRole Role;
    EFSXDatumType Type;
    EFSXDatum_Flag Flag where ValidationCheckEnumValue(InRange<EFSXDatum_Flag>(value), 
        null, true, ReferenceType.Type, "EFSR", "Flag", "EFSXDatum", "0x0000, 0x0001, 0x0002", value);
    ([|Type == 0x0001|] BlobDatum |
     [|Type == 0x0002|] DescriptorDatum |
     [|Type == 0x0003|] ProtectorListEntry |
     [|Type == 0x0004|] ProtectorInfoDatum |
     [|Type == 0x0005|] KeyAgreementDatum |
     [|Type == 0x0006|] FekInfoDatum) Data_Fields with BinaryEncoding{WidthForComposedType = (StructureSize - 8) * 8};
} with IDL{DoNotGenerate = true};

pattern EFSXDatumRole = enum ushort
{
    NoDefinedRole = 0x0000, // The EFSX Datum has no defined role.
    UserCertificateStore = 0x0001, // The EFSX Datum contains a reference to a user's certificate store. This reference could be, for example, a certificate hash or the public key from a certificate.
    ProtectorType = 0x0002, // The EFSX Datum contains data specific to a protector type. See section 2.2.2.2.5 for valid protector types and their associated protector data format.
    UserDisplayInfo = 0x0003, // The EFSX Datum contains information that is suitable for user display. For example, this could be the user name associated with a protector.
    PrivateKeyContainer = 0x0004, // The EFSX Datum contains information that identifies a private key container.
    ProviderNameInfo = 0x0005, // The EFSX Datum contains information that identifies the provider name of a CSP or KSP. 
    UserSID = 0x0006, // The EFSX Datum contains a user SID.
    EncryptedFileMasterKey = 0x0007, // The EFSX Datum contains the encrypted File Master Key (FMK).
    UserPublicKey = 0x0008, // The EFSX Datum contains a user's public key.
    EphemeralPublicKey = 0x0009, // The EFSX Datum contains an ephemeral public key.
    EncryptedFileEncryptionKey = 0x000A, // The EFSX Datum contains the encrypted File Encryption Key (FEK).
    FileInitializationVector = 0x000B, // The EFSX Datum contains the file Initialization Vector (IV). 
    ProtectorDescriptor = 0x000C, // The EFSX Datum contains a protector descriptor string.<14> This datum role MUST only be used when EFS_VERSION is 5.
    ...
} with IDL{DoNotGenerate = true};

pattern EFSXDatumType = enum ushort
{
    Reserved = 0x0000, // Reserved. Local use only.
    EFSX_TYPE_BLOB = 0x0001, // The EFSX Datum MUST be formatted as specified in section 2.2.2.2.3. 
    EFSX_TYPE_DESCRIPTOR = 0x0002, // The EFSX Datum MUST be formatted as specified in section 2.2.2.2.4. 
    EFSX_TYPE_KEY_PROTECTOR = 0x0003, // The EFSX Datum MUST be formatted as specified in section 2.2.2.2.5. 
    EFSX_TYPE_PROTECTOR_INFO = 0x0004, // The EFSX Datum MUST be formatted as specified in section 2.2.2.2.6. 
    EFSX_TYPE_KEY_AGMT_DATA = 0x0005, // The EFSX Datum MUST be formatted as specified in section 2.2.2.2.7.
    EFSX_TYPE_FEK_INFO = 0x0006, // The EFSX Datum MUST be formatted as specified in section 2.2.2.2.8.
    EFSX_TYPE_DPAPI_NG_DATA = 0x0007, // The EFSX Datum MUST be formatted as specified in section 2.2.2.2.9. This type MUST only be used when EFS_VERSION is 5.<15>
    ...
} with IDL{DoNotGenerate = true};

type BlobDatum[ushort StructureSize]
{
    BlobDatumBlobType BlobType;
    ushort BlobFlags where ValidationCheckZero(value == 0, null, true, ReferenceType.Type, "EFSR", 
                                                "BlobFlags", "BlobDatum", value);
    binary BlobData with BinaryEncoding{Length = StructureSize - 12};
} with IDL{DoNotGenerate = true};

pattern BlobDatumBlobType = enum ushort
{
    NoFormat = 0x0000, // The blob has no special formatting.
    BCRYPT_PUBLIC_KEY_BLOB = 0x0001, // The blob contains a public key formatted as a BCRYPT_PUBLIC_KEY_BLOB.
    SHA_1_Hash = 0x0002, // The blob contains a SHA-1 hash of a DER-encoded form of a certificate.
    Encrypted_FEK = 0x0003, // The blob contains the encrypted form of an Encrypted FEK structure, as defined in section 2.2.2.1.5. The contents of the key may be either the FEK or the FMK, see section 2.2.2.2.5.
    AES_256_key = 0x0004, // The blob contains key material wrapped with an AES-256 key wrapping key, as defined by [RFC3394].
    DPAPI_NG_Provider = 0x0005, // The blob contains key material encrypted by a DPAPI-NG provider on the endpoint. This BlobType MUST only be used when EFS_VERSION is 5.<16>
    ...
} with IDL{DoNotGenerate = true};

type DescriptorDatum[ushort StructureSize]
{
    string Descriptor_Text with BinaryEncoding{TextEncoding = TextEncoding.Unicode, Length = (StructureSize - 8) / 2};
} with IDL{DoNotGenerate = true};

type ProtectorListEntry
{
    ProtectorType ProtectorType;
    ProtectorFlags    ProtectorFlags;
    array<PatternEFSXDatum> Data_Fields with IDL{Size_is = [0]};
} with IDL{DoNotGenerate = true};

pattern ProtectorType = enum ushort
{
    EFSX_TYPE_KEY_AGMT_DATA = 0x0001, // The protector was derived from a public/private key pair using a key agreement. The Data Fields SHOULD include an EFSX_Datum of Type EFSX_TYPE_KEY_AGMT_DATA (0x0005) and Role 0x0002.
    EFSX_TYPE_BLOB = 0x0002, // The protector was derived from a public/private key pair capable of performing asymmetric encryption. The Data Fields SHOULD include an EFSX_Datum of Type EFSX_TYPE_BLOB (0x0001) and Role 0x0002.
    EFSX_TYPE_DPAPI_NG_DATA = 0x0003, // The protector was derived using a DPAPI-NG encryption provider on the endpoint. The Data Fields SHOULD include an EFSX_Datum of Type EFSX_TYPE_DPAPI_NG_DATA (0x0007) and Role 0x0002.
    ...
} with IDL{DoNotGenerate = true};

type ProtectorInfoDatum
{
    array<PatternEFSXDatum> Data_Fields with IDL{Size_is = [0]};
} with IDL{DoNotGenerate = true};

type KeyAgreementDatum
{
    ushort KeyAgmtFlags;
    array<PatternEFSXDatum> Data_Fields with IDL{Size_is = [0]};
} with IDL{DoNotGenerate = true};

type FekInfoDatum
{
    Algorithm_ID AlgorithmID;
    array<PatternEFSXDatum> Data_Fields with IDL{Size_is = [0]};
} with IDL{DoNotGenerate = true};

type DpapiNgDatum
{
    DWORD DpapiNgFlags where ValidationCheckValue(value == 0x0000, null, true, ReferenceType.Type, "EFSR", 
                                                  "DpapiNgFlags", "DpapiNgDatum", 0x0000, value);
    array<PatternEFSXDatum> Data_Fields with IDL{Size_is = [0]};
} with IDL{DoNotGenerate = true};

type ProtectorList
{
    uint StructureSize;
    ushort ProtectorsCount;
    array<EFSXDatum> Protector_List_Entries 
        with BinaryEncoding{Length = ProtectorsCount},
        IDL{Size_is = [0]};
} with IDL{DoNotGenerate = true};

type MetadataVersion3
{
    binary Preamble 
        where ValidationCheckValue(value == MetadataPreambleBinary, null, true, ReferenceType.Type, "EFSR", 
                                   "Preamble", "MetadataVersion3", MetadataPreambleBinary.ToString(), value)
        with BinaryEncoding{Length = 6};
    uint MajorVersion where ValidationCheckValue(value == 2, null, true, ReferenceType.Type, "EFSR", 
                                                 "MajorVersion", "MetadataVersion3", 2, value);
    uint MinorVersion where ValidationCheckValue(value == 1, null, true, ReferenceType.Type, "EFSR", 
                                                 "MinorVersion", "MetadataVersion3", 1, value);
    uint ClearTextRedirectionLength;
    string ClearTextRedirectionString 
        with BinaryEncoding{TextEncoding = TextEncoding.UTF8, Length = ClearTextRedirectionLength};
    uint TotalHeaderLength;
    uint OriginalFileExtensionOffset;
    uint OriginalFileExtensionLength;
    uint PLOffset;
    uint EncryptedDataOffset;
    ulong OriginalFileSize;
    uint MetaDataOffset;
    uint MetaDataLength;
    string OriginalFileExtensionData 
        with Encoding{Offset = OriginalFileExtensionOffset, Size = OriginalFileExtensionLength},
             BinaryEncoding{TextEncoding = TextEncoding.Unicode};
    optional xml PLData
        with XmlEncoding{Kind = XmlKind.Element},
            Encoding
            {
                Offset = PLOffset,
                Size = MetaDataOffset - PLOffset,
                Decoder = BuildXmlDecoder,
                SourcePattern = TypeOf<array<byte>>()
            };
    binary MetaData with Encoding{Offset = MetaDataOffset, Size = MetaDataLength};
    binary EncryptedData with Encoding{Offset = EncryptedDataOffset};
} with IDL{DoNotGenerate = true};

pattern MetadataEFS_Version1 = enum uint
{
    Version_1 = 0x00000001, // The file encryption key (FEK) will be a DESX key, and encrypted with RSA only
    Version_2 = 0x00000002, // The FEK will use DESX, 3DES, or AES-256. The FEK will be encrypted with RSA only. 
    Version_3 = 0x00000003, // The FEK will use DESX, 3DES, or AES-256. The FEK will be encrypted with either RSA or AES-256.
    ...
} with IDL{DoNotGenerate = true};

pattern MetadataEFS_Version2 = enum uint
{
    Version_4 = 0x00000004,
    Version_5 = 0x00000005,
    ...
} with IDL{DoNotGenerate = true};

pattern EFSXDatum_Flag  = enum ushort
{
    Reserved = 0x0000,
    DatumIsNestedInsideStructure = 0x0001,
    DatumIsContainingNestedDatum = 0x0002,
    ...
} with IDL{DoNotGenerate = true};

pattern ExtendedHeader_Falgs = enum uint
{
    StreamIsContainedWithinSparseFile = 0x00000001,
    ...
} with IDL{DoNotGenerate = true};

pattern ProtectorFlags = enum ushort
{
    Bit1 = 0x0001
        with Documentation
            {Description = "The protector is a legacy protector, and stores the Encrypted FEK."},
    Bit2 = 0x0002
        with Documentation
            {Description = "If this is a legacy protector, the Encrypted FEK is encrypted using AES 256, with a key that is obtained by signing the non-terminated Unicode string \"MICROSOFTE\" with the user's RSA and computing the SHA-256 hash of the result."},
    Bit3 = 0x0004
        with Documentation
            {Description = "If this bit is set, bit 0x0001 MUST also be set to indicate a legacy protector. This bit indicates that the legacy protector stores the File Master Key (FMK) encrypted in the Encrypted FEK structure instead of the File Encryption Key (FEK)."},
    ...
} with IDL{DoNotGenerate = true};
 // -------Block structures end-------

pattern OpenFileRaw_Flags = flags DWORD
{
    CREATE_FOR_IMPORT          = 0x00000001
        with Documentation
            {Description = "Open the object for writing. If this flag is not set, open the object for reading."},
    CREATE_FOR_DIR             = 0x00000002
        with Documentation
            {Description = "The object being restored is a container for other objects."},
    OVERWRITE_HIDDEN           = 0x00000004
        with Documentation
            {Description = "A request from the client for the server to overwrite an existing object even if the existing object is \"hidden\"."},
    EFS_DROP_ALTERNATE_STREAMS = 0x00000010
        with Documentation
            {Description = "Content from any alternate data streams, if present and implemented by the storage system, will be ignored."},
    ...
} with IDL{DoNotGenerate = true};

pattern FileKeyInfo_InfoClass = enum DWORD
{
    BASIC_KEY_INFO              = 0x00000001,
    CHECK_COMPATIBILITY_INFO    = 0x00000002,
    UPDATE_KEY_USED             = 0x00000100,
    CHECK_DECRYPTION_STATUS     = 0x00000200,
    CHECK_ENCRYPTION_STATUS     = 0x00000400,
    ...
} with IDL{DoNotGenerate = true};

pattern DuplicateEncryptionInfoFile_dwCreationDisposition = enum DWORD
{
    CREATE_NEW    = 0x00000001,
    CREATE_ALWAYS = 0x00000002,
    ...
} with IDL{DoNotGenerate = true};

pattern DwAttributes_Flags = flags DWORD
{
    FILE_ATTRIBUTE_HIDDEN = 0x00000002
        with Documentation
            {Description = "The file is hidden (not displayed in normal folder listings)."},
    FILE_ATTRIBUTE_ARCHIVE = 0x00000020
        with Documentation
            {Description = "This attribute is used by applications to mark files for backup or removal."},
    FILE_ATTRIBUTE_TEMPORARY = 0x00000100
        with Documentation
            {Description = "The file is being used for temporary storage."},
    FILE_ATTRIBUTE_NOT_CONTENT_INDEXED = 0x00002000
        with Documentation
            {Description = "The file's contents should not be indexed by the content indexing service."},
    FILE_ATTRIBUTE_NORMAL = 0x00000080
        with Documentation
            {Description = "No other attributes are to be set."},
    ...
} with IDL{DoNotGenerate = true};

pattern AddUsersToFileEx_dwFlags = flags DWORD
{
    ADDUSERFLAG_ADD_POLICY_KEYTYPE = 0x00000002
        with Documentation
            {Description = "For each certificate specified in the EncryptionCertificates parameter, the server MUST check whether the private key for the certificate is stored on a smart card."},
    ADDUSERFLAG_REPLACE_DDF = 0x00000004
        with Documentation
            {Description = "The EncryptionCertificates parameter MUST contain exactly one certificate."},
    ...
} with IDL{DoNotGenerate = true};

pattern DwEfsAccessType = enum DWORD
{
    EFS_METADATA_ADD_USER       = 0x00000001,
    EFS_METADATA_REMOVE_USER    = 0x00000002,
    EFS_METADATA_REPLACE_USER   = 0x00000004,
    EFS_METADATA_GENERAL_OP     = 0x00000008,
    ...
} with IDL{DoNotGenerate = true};

pattern DwCertEncodingType = enum DWORD
{
    X509ASN1 = 0x00000001,
    X509NDR  = 0x00000002,
    ...
} with IDL{DoNotGenerate = true};

pattern Algorithm_ID = enum DWORD
{
    CALG_AES_256 = 0x6610,
    CALG_3DES = 0x6603,
    ...
} with IDL{DoNotGenerate = true};

const binary Reserved4Binary= $[00000000];
const binary Reserved8Binary = $[0000000000000000];
const binary Reserved12Binary = $[000000000000000000000000];
const binary Reserved16Binary = $[00000000000000000000000000000000];
const binary MetadataPreambleBinary = $[2E7066696C65]; // .pfile
const binary RawDataPadBinary = $[0001000052004F0042005300]; // ROBS
const binary MarshaledStreamPadBinary= $[4E00540046005300]; // NTFS
const binary StreamDataPadBinary = $[4700550052004500]; // GURE
const binary ExtendedHeaderPad1Binary = $[45585444]; // EXTD
const binary ExtendedHeaderPad2Binary = $[10000000];
const binary PublicKeyInformationPadBinary = $[03000000];
