protocol WKST with
Documentation
{
    ProtocolName = "Workstation Service Remote Protocol",
    ProtocolType = "rpc",
    ShortName = "WKST",
    DocumentName = "MS-WKST",
    Description = ""
},
OPNAuthoring
{
    Copyright = "(c) Microsoft Corporation",
    References =
    [
        new Reference{Name = "MS-WKST", Version = "23.1", Date = "07/12/2012", ProgramName = ProgramName.WSPP}
    ],
    RevisionSummary =
    [
        new Revision{Class = RevisionClass.Major, Version = "358122", Date = "12/19/2013"}
    ]
};

using Technologies.IDL;
using DTYP;
using ERREF;
using MSRPCE;
using Utility;

const guid WkssvcUuid = {6BFFD098-A112-3610-9833-46C3F87E345A};

endpoint WkssvcService over MSRPCE.Server provides Wkssvc;

contract Wkssvc
{
    accepts operation NetrWkstaGetInfo
    {
        in string ServerName with IDL{BaseStringType = TypeOf<WKSSVC_IDENTIFY_HANDLE>(), PointerType = PointerKind.UniquePtr};
        in IDLUlong Level where ValidationCheck(value is NetrWkstaGetInfoLevel, this, DiagnosisLevel.Error,
            "WKST: The Level parameter in operation NetrWkstaGetInfo must be one of the values specified in NetrWkstaGetInfoLevel, not " + value.ToString() + ".");
        out LPWKSTA_INFO[Level] WkstaInfo with IDL{Switch_Is = Level};
        result IDLUlong ReturnValue where ValidationCheck(value is NetrWkstaGetInfoReturnValue, this, DiagnosisLevel.Error,
            "WKST: The ReturnValue in operation NetrWkstaGetInfo must be one of the values specified in NetrWkstaGetInfoReturnValue, not " + value.ToString() + ".");

        override string ToString()
        {
            return "NetrWkstaGetInfo, Level: " + NetrWkstaGetInfoLevelToString(Level) +
                ", ReturnValue: " + Win32ErrorCodesToText(ReturnValue);
        }
    } with IDL{Opnum = 0};

    accepts operation NetrWkstaSetInfo
    {
        in string ServerName with IDL{BaseStringType = TypeOf<WKSSVC_IDENTIFY_HANDLE>(), PointerType = PointerKind.UniquePtr};
        in IDLUlong Level where ValidationCheck(value is NetrWkstaSetInfoLevel, this, DiagnosisLevel.Error,
            "WKST: The Level parameter in operation NetrWkstaSetInfo should be one of the values specified in NetrWkstaSetInfoLevel, not " + value.ToString() + ".");
        in LPWKSTA_INFO[Level] WkstaInfo with IDL{Switch_Is = Level};
        in out IDLUlong ErrorParameter with IDL{PointerType = PointerKind.UniquePtr, IndirectionLevel = 1};
        result IDLUlong ReturnValue where ValidationCheck(value is NetrWkstaSetInfoReturnValue, this, DiagnosisLevel.Error,
            "WKST: The ReturnValue in operation NetrWkstaSetInfo must be one of the values specified in NetrWkstaSetInfoReturnValue, not " + value.ToString() + ".");

        override string ToString()
        {
            return "NetrWkstaSetInfo, Level: " + NetrWkstaSetInfoLevelToString(Level)
                + ", ErrorParameter: " + Utility.DecToHexFormat(ErrorParameter) +
                ", ReturnValue: " + Win32ErrorCodesToText(ReturnValue);
        }
    } with IDL{Opnum = 1};

    accepts operation NetrWkstaUserEnum
    {
        in string ServerName with IDL{BaseStringType = TypeOf<WKSSVC_IDENTIFY_HANDLE>(), PointerType = PointerKind.UniquePtr};
        in out LPWKSTA_USER_ENUM_STRUCT UserInfo;
        in IDLUlong PreferredMaximumLength;
        out IDLUlong TotalEntries with IDL{IndirectionLevel = 1};
        in out IDLUlong ResumeHandle with IDL{PointerType = PointerKind.UniquePtr, IndirectionLevel = 1};
        result IDLUlong ReturnValue where ValidationCheck(value is NetrWkstaUserEnumReturnValue, this, DiagnosisLevel.Error,
            "WKST: The ReturnValue in operation NetrWkstaUserEnum must be one of the values specified in NetrWkstaUserEnumReturnValue, not " + value.ToString() + ".");

        override string ToString()
        {
            return "NetrWkstaUserEnum, TotalEntries: " + (TotalEntries as string) +
                ", ReturnValue: " + Win32ErrorCodesToText(ReturnValue);
        }
    } with IDL{Opnum = 2};

    accepts operation Opnum3NotUsedOnWire{} with IDL{Opnum = 3}, Documentation{Ignore = true};

    accepts operation Opnum4NotUsedOnWire{} with IDL{Opnum = 4}, Documentation{Ignore = true};

    accepts operation NetrWkstaTransportEnum
    {
        in string ServerName with IDL{BaseStringType = TypeOf<WKSSVC_IDENTIFY_HANDLE>(), PointerType = PointerKind.UniquePtr};
        in out LPWKSTA_TRANSPORT_ENUM_STRUCT TransportInfo;
        in IDLUlong PreferredMaximumLength;
        out IDLUlong TotalEntries with IDL{IndirectionLevel = 1};
        in out IDLUlong ResumeHandle with IDL{PointerType = PointerKind.UniquePtr, IndirectionLevel = 1};
        result IDLUlong ReturnValue where ValidationCheck(value is NetrWkstaTransportEnumReturnValue, this, DiagnosisLevel.Error,
            "WKST: The ReturnValue in operation NetrWkstaTransportEnum must be one of the values specified in NetrWkstaTransportEnumReturnValue, not " + value.ToString() + ".");

        override string ToString()
        {
            return "NetrWkstaTransportEnum, ReturnValue: " + Win32ErrorCodesToText(ReturnValue);
        }
    } with IDL{Opnum = 5};

    accepts operation NetrWkstaTransportAdd
    {
        in string ServerName with IDL{BaseStringType = TypeOf<WKSSVC_IDENTIFY_HANDLE>(), PointerType = PointerKind.UniquePtr};
        in IDLUlong Level where ValidationCheck(value == 0, this, DiagnosisLevel.Error,
            "WKST: The Level parameter in operation NetrWkstaTransportAdd must be set to zero, not " + value.ToString() + ".");
        in LPWKSTA_TRANSPORT_INFO_0 TransportInfo;
        in out IDLUlong ErrorParameter with IDL{PointerType = PointerKind.UniquePtr, IndirectionLevel = 1};
        result IDLUlong ReturnValue where ValidationCheck(value is NetrWkstaTransportAddReturnValue, this, DiagnosisLevel.Error,
            "WKST: The ReturnValue in operation NetrWkstaTransportAdd must be one of the values specified in NetrWkstaTransportAddReturnValue, not " + value.ToString() + ".");

        override string ToString()
        {
            return "NetrWkstaTransportAdd, Level: " + NetrWkstaTransportAddLevelToString(Level) +
                ", ReturnValue: " + Win32ErrorCodesToText(ReturnValue);
        }
    } with IDL{Opnum = 6};

    accepts operation NetrWkstaTransportDel
    {
        in string ServerName with IDL{BaseStringType = TypeOf<WKSSVC_IDENTIFY_HANDLE>(), PointerType = PointerKind.UniquePtr};
        in string TransportName with IDL{BaseStringType = TypeOf<wchar_t>(), IndirectionLevel = 1, PointerType = PointerKind.UniquePtr};
        in IDLUlong ForceLevel where ValidationCheck(value is DelForceLevel, this, DiagnosisLevel.Error,
            "WKST: The ForceLevel parameter in operation NetrWkstaTransportDel must be one of the values specified in DelForceLevel, not " + value.ToString() + ".");
        result IDLUlong ReturnValue where ValidationCheck(value is NetrWkstaTransportDelReturnValue, this, DiagnosisLevel.Error,
            "WKST: The ReturnValue in operation NetrWkstaTransportDel must be one of the values specified in NetrWkstaTransportDelReturnValue, not " + value.ToString() + ".");

        override string ToString()
        {
            return "NetrWkstaTransportDel, ForceLevel: " + DelForceLevelToString(ForceLevel) +
                ", ReturnValue: " + Win32ErrorCodesToText(ReturnValue);
        }
    } with IDL{Opnum = 7};

    accepts operation NetrUseAdd
    {
        in string ServerName with IDL{BaseStringType = TypeOf<WKSSVC_IMPERSONATE_HANDLE>(), PointerType = PointerKind.UniquePtr};
        in IDLUlong Level where ValidationCheck(value is UseInfoLevel, this, DiagnosisLevel.Error,
            "WKST: The Level parameter in operation NetrUseAdd must be one of the values specified in UseInfoLevel, not " + value.ToString() + ".");
        in LPUSE_INFO[Level] InfoStruct with IDL{Switch_Is = Level};
        in out IDLUlong ErrorParameter with IDL{PointerType = PointerKind.UniquePtr, IndirectionLevel = 1};
        result IDLUlong ReturnValue where ValidationCheck(value is NetrUseAddReturnValue, this, DiagnosisLevel.Error,
            "WKST: The ReturnValue in operation NetrUseAdd must be one of the values specified in NetrUseAddReturnValue, not " + value.ToString() + ".");

        override string ToString()
        {
            return "NetrUseAdd, Level: " + UseInfoLevelToString(Level) +
                ", ReturnValue: " + Win32ErrorCodesToText(ReturnValue);
        }
    } with IDL{Opnum = 8};

    accepts operation NetrUseGetInfo
    {
        in string ServerName with IDL{BaseStringType = TypeOf<WKSSVC_IMPERSONATE_HANDLE>(), PointerType = PointerKind.UniquePtr};
        in string UseName with IDL{BaseStringType = TypeOf<wchar_t>(), IndirectionLevel = 1};
        in  IDLUlong Level where ValidationCheck(value is UseInfoLevel, this, DiagnosisLevel.Error,
            "WKST: The Level parameter in operation NetrUseGetInfo must be one of the values specified in UseInfoLevel, not " + value.ToString() + ".");
        out LPUSE_INFO[Level] InfoStruct with IDL{Switch_Is = Level};
        result IDLUlong ReturnValue where ValidationCheck(value is NetrUseGetInfoReturnValue, this, DiagnosisLevel.Error,
            "WKST: The ReturnValue in operation NetrUseGetInfo must be one of the values specified in NetrUseGetInfoReturnValue, not " + value.ToString() + ".");

        override string ToString()
        {
            return "NetrUseGetInfo, Level: " + UseInfoLevelToString(Level) +
                ", ReturnValue: " + Win32ErrorCodesToText(ReturnValue);
        }
    } with IDL{Opnum = 9};

    accepts operation NetrUseDel
    {
        in string ServerName with IDL{BaseStringType = TypeOf<WKSSVC_IMPERSONATE_HANDLE>(), PointerType = PointerKind.UniquePtr};
        in string UseName with IDL{BaseStringType = TypeOf<wchar_t>(), IndirectionLevel = 1};
        in IDLUlong ForceLevel where ValidationCheck(value is DelForceLevel, this, DiagnosisLevel.Error,
            "WKST: The ForceLevel parameter in operation NetrUseDel must be one of the values specified in DelForceLevel, not " + value.ToString() + ".");
        result IDLUlong ReturnValue where ValidationCheck(value is NetrUseDelReturnValue, this, DiagnosisLevel.Error,
            "WKST: The ReturnValue in operation NetrUseDel must be one of the values specified in NetrUseDelReturnValue, not " + value.ToString() + ".");

        override string ToString()
        {
            return "NetrUseDel, UseName: " + (UseName as string) + 
                ", ForceLevel: " + DelForceLevelToString(ForceLevel) +
                ", ReturnValue: " + Win32ErrorCodesToText(ReturnValue);
        }
    } with IDL{Opnum = 10};

    accepts operation NetrUseEnum
    {
        in string ServerName with IDL{BaseStringType = TypeOf<WKSSVC_IDENTIFY_HANDLE>(), PointerType = PointerKind.UniquePtr};
        in out LPUSE_ENUM_STRUCT InfoStruct;
        in IDLUlong PreferredMaximumLength;
        out IDLUlong TotalEntries with IDL{IndirectionLevel = 1};
        in out IDLUlong ResumeHandle with IDL{PointerType = PointerKind.UniquePtr, IndirectionLevel = 1};
        result IDLUlong ReturnValue where ValidationCheck(value is NetrUseEnumReturnValue, this, DiagnosisLevel.Error,
            "WKST: The ReturnValue in operation NetrUseEnum must be one of the values specified in NetrUseEnumReturnValue, not " + value.ToString() + ".");

        override string ToString()
        {
            return "NetrUseEnum, InfoStructLevel: " + (InfoStruct.Level as string) +
                ", TotalEntries: " + (TotalEntries as string) +
                ", ReturnValue: " + Win32ErrorCodesToText(ReturnValue);
        }
    } with IDL{Opnum = 11};

    accepts operation Opnum12NotUsedOnWire{} with IDL{Opnum = 12}, Documentation{Ignore = true};

    accepts operation NetrWorkstationStatisticsGet
    {
        in string ServerName with IDL{BaseStringType = TypeOf<WKSSVC_IDENTIFY_HANDLE>(), PointerType = PointerKind.UniquePtr};
        in string ServiceName with IDL{BaseStringType = TypeOf<wchar_t>(), IndirectionLevel = 1, PointerType = PointerKind.UniquePtr};
        in IDLUlong Level where ValidationCheck(value == 0, this, DiagnosisLevel.Error,
            "WKST: The Level parameter in operation NetrWorkstationStatisticsGet must be zero, not " + value.ToString() + ".");
        in IDLUlong Options where ValidationCheck(value == 0, this, DiagnosisLevel.Error,
            "WKST: The Options parameter in operation NetrWorkstationStatisticsGet must be zero, not " + value.ToString() + ".");
        out LPSTAT_WORKSTATION_0 Buffer with IDL{IndirectionLevel = 1};
        result IDLUlong ReturnValue where ValidationCheck(value is NetrWorkstationStatisticsGetReturnValue, this, DiagnosisLevel.Error,
            "WKST: The ReturnValue in operation NetrWorkstationStatisticsGet must be one of the values specified in NetrWorkstationStatisticsGetReturnValue, not " + value.ToString() + ".");

        override string ToString()
        {
            return "NetrWorkstationStatisticsGet, Level: " + (Level as string) +
                ", ReturnValue: " + Win32ErrorCodesToText(ReturnValue);
        }
    } with IDL{Opnum = 13};

    accepts operation Opnum14NotUsedOnWire{} with IDL{Opnum = 14}, Documentation{Ignore = true};

    accepts operation Opnum15NotUsedOnWire{} with IDL{Opnum = 15}, Documentation{Ignore = true};

    accepts operation Opnum16NotUsedOnWire{} with IDL{Opnum = 16}, Documentation{Ignore = true};

    accepts operation Opnum17NotUsedOnWire{} with IDL{Opnum = 17}, Documentation{Ignore = true};

    accepts operation Opnum18NotUsedOnWire{} with IDL{Opnum = 18}, Documentation{Ignore = true};

    accepts operation Opnum19NotUsedOnWire{} with IDL{Opnum = 19}, Documentation{Ignore = true};

    accepts operation NetrGetJoinInformation
    {
        in string ServerName with IDL{BaseStringType = TypeOf<WKSSVC_IMPERSONATE_HANDLE>(), PointerType = PointerKind.UniquePtr};
        in out string NameBuffer with IDL{BaseStringType = TypeOf<wchar_t>(), IndirectionLevel = 2};
        out PNETSETUP_JOIN_STATUS BufferType;
        result IDLUlong ReturnValue where ValidationCheck(value is NetrGetJoinInformationReturnValue, this, DiagnosisLevel.Error,
            "WKST: The ReturnValue in operation NetrGetJoinInformation must be one of the values specified in NetrGetJoinInformationReturnValue, not " + value.ToString() + ".");

        override string ToString()
        {
            return "NetrGetJoinInformation, NameBuffer: " + (NameBuffer as string) +
                ", BufferType: " + EnumToString(BufferType, "WKST.NETSETUP_JOIN_STATUS") +
                ", ReturnValue: " + Win32ErrorCodesToText(ReturnValue);
        }
    } with IDL{Opnum = 20};

    accepts operation Opnum21NotUsedOnWire{} with IDL{Opnum = 21}, Documentation{Ignore = true};

    accepts operation NetrJoinDomain2
    {
        in optional handle_t RpcBindingHandle;
        in string ServerName with IDL{BaseStringType = TypeOf<wchar_t>(), IndirectionLevel = 1, PointerType = PointerKind.UniquePtr};
        in string DomainNameParam with IDL{BaseStringType = TypeOf<wchar_t>(), IndirectionLevel = 1};
        in string MachineAccountOU with IDL{BaseStringType = TypeOf<wchar_t>(), IndirectionLevel = 1, PointerType = PointerKind.UniquePtr};
        in string AccountName with IDL{BaseStringType = TypeOf<wchar_t>(), IndirectionLevel = 1, PointerType = PointerKind.UniquePtr};
        in PJOINPR_ENCRYPTED_USER_PASSWORD Password with IDL{PointerType = PointerKind.UniquePtr};
        in IDLUlong Options where (value is flags ULONG
            {
                NetsetupJoinDomain = 0x00000001,
                NetsetupAcctCreate = 0x00000002,
                NetsetupAcctDelete = 0x00000004,
                NetsetupDomainJoinIfJoined = 0x00000020,
                NetsetupJoinUnsecure = 0x00000040,
                NetsetupMachinePwdPassed = 0x00000080,
                NetsetupDeferSpnSet = 0x00000100,
                NetsetupJoinDcAccount = 0x00000200,
                NetsetupJoinWithNewName = 0x00000400,
                NetsetupInstallInvocation = 0x00040000,
            } || value is IDLUlong);
        result IDLUlong ReturnValue where ValidationCheck(value is NetrJoinDomain2ReturnValue, this, DiagnosisLevel.Error,
            "WKST: The ReturnValue in operation NetrJoinDomain2 must be one of the values specified in NetrJoinDomain2ReturnValue, not " + value.ToString() + ".");

        override string ToString()
        {
            return "NetrJoinDomain2, DomainNameParam: " + (DomainNameParam as string) +
                ", Options: " + (Options as string) +
                ", AccountName: " + (AccountName as string) +
                ", ReturnValue: " + Win32ErrorCodesToText(ReturnValue);
        }
    } with IDL{Opnum = 22};

    accepts operation NetrUnjoinDomain2
    {
        in optional handle_t RpcBindingHandle;
        in string ServerName with IDL{BaseStringType = TypeOf<wchar_t>(), IndirectionLevel = 1, PointerType = PointerKind.UniquePtr};
        in string AccountName with IDL{BaseStringType = TypeOf<wchar_t>(), IndirectionLevel = 1, PointerType = PointerKind.UniquePtr};
        in PJOINPR_ENCRYPTED_USER_PASSWORD Password with IDL{PointerType = PointerKind.UniquePtr};
        in IDLUlong Options where (value is flags ULONG
            {
                NetsetupAcctDelete = 0x00000004,
                NetsetupIgnoreUnsupportedFlags = 0x10000000,
            } || value is IDLUlong);
        result IDLUlong ReturnValue where ValidationCheck(value is NetrUnjoinDomain2ReturnValue, this, DiagnosisLevel.Error,
            "WKST: The ReturnValue in operation NetrUnjoinDomain2 must be one of the values specified in NetrUnjoinDomain2ReturnValue, not " + value.ToString() + ".");
        
        override string ToString()
        {
            return "NetrUnjoinDomain2, AccountName: " + (AccountName as string) +
                ", Options: " + (Options as string) +
                ", ReturnValue: " + Win32ErrorCodesToText(ReturnValue);
        }
    } with IDL{Opnum = 23};

    accepts operation NetrRenameMachineInDomain2
    {
        in optional handle_t RpcBindingHandle;
        in string ServerName with IDL{BaseStringType = TypeOf<wchar_t>(), IndirectionLevel = 1, PointerType = PointerKind.UniquePtr};
        in string MachineName with IDL{BaseStringType = TypeOf<wchar_t>(), IndirectionLevel = 1, PointerType = PointerKind.UniquePtr};
        in string AccountName with IDL{BaseStringType = TypeOf<wchar_t>(), IndirectionLevel = 1, PointerType = PointerKind.UniquePtr};
        in PJOINPR_ENCRYPTED_USER_PASSWORD Password with IDL{PointerType = PointerKind.UniquePtr};
        in IDLUlong Options where (value is flags ULONG
            {
                NetsetupAcctCreate  = 0x00000002,
                NetsetupDnsNameChangesOnly = 0x00001000,
            } || value is IDLUlong);
        result IDLUlong ReturnValue where ValidationCheck(value is NetrRenameMachineInDomain2ReturnValue, this, DiagnosisLevel.Error,
            "WKST: The ReturnValue in operation NetrRenameMachineInDomain2 must be one of the values specified in NetrRenameMachineInDomain2ReturnValue, not " + value.ToString() + ".");

        override string ToString()
        {
            return "NetrRenameMachineInDomain2, MachineName: " + (MachineName as string) +
                ", Options: " + (Options as string) +
                ", AccountName: " + (AccountName as string) +
                ", ReturnValue: " + Win32ErrorCodesToText(ReturnValue);
        }
    } with IDL{Opnum = 24};

    accepts operation NetrValidateName2
    {
        in optional handle_t RpcBindingHandle;
        in string ServerName with IDL{BaseStringType = TypeOf<wchar_t>(), IndirectionLevel = 1, PointerType = PointerKind.UniquePtr};
        in string NameToValidate with IDL{BaseStringType = TypeOf<wchar_t>(), IndirectionLevel = 1};
        in string AccountName with IDL{BaseStringType = TypeOf<wchar_t>(), IndirectionLevel = 1, PointerType = PointerKind.UniquePtr};
        in PJOINPR_ENCRYPTED_USER_PASSWORD Password with IDL{PointerType = PointerKind.UniquePtr};
        in NETSETUP_NAME_TYPE NameType;
        result IDLUlong ReturnValue where ValidationCheck(value is NetrValidateName2ReturnValue, this, DiagnosisLevel.Error,
            "WKST: The ReturnValue in operation NetrValidateName2 must be one of the values specified in NetrValidateName2ReturnValue, not " + value.ToString() + ".");

        override string ToString()
        {
            return "NetrValidateName2, NameType: " + EnumToString(NameType, "WKST.NETSETUP_JOIN_STATUS") + 
                ", ReturnValue: " + ((ReturnValue != 0x8001011C) ? Win32ErrorCodesToText(ReturnValue) : "RPC_E_REMOTE_DISABLED");
        }
    } with IDL{Opnum = 25};

    accepts operation NetrGetJoinableOUs2
    {
        in optional handle_t RpcBindingHandle;
        in string ServerName with IDL{BaseStringType = TypeOf<wchar_t>(), IndirectionLevel = 1, PointerType = PointerKind.UniquePtr};
        in string DomainNameParam with IDL{BaseStringType = TypeOf<wchar_t>(), IndirectionLevel = 1};
        in string AccountName with IDL{BaseStringType = TypeOf<wchar_t>(), IndirectionLevel = 1, PointerType = PointerKind.UniquePtr};
        in PJOINPR_ENCRYPTED_USER_PASSWORD Password with IDL{PointerType = PointerKind.UniquePtr};
        in out IDLUlong OUCount with IDL{IndirectionLevel = 1};
        out array<string> OUs with IDL{BaseStringType = TypeOf<wchar_t>(), Size_is = [null, OUCount, null], IndirectionLevel = 3};
        result IDLUlong ReturnValue where ValidationCheck(value is NetrGetJoinableOUs2ReturnValue, this, DiagnosisLevel.Error,
            "WKST: The ReturnValue in operation NetrGetJoinableOUs2 must be one of the values specified in NetrGetJoinableOUs2ReturnValue, not " + value.ToString() + ".");

        override string ToString()
        {
            return "NetrGetJoinableOUs2, DomainNameParam: " + (DomainNameParam as string) +
                ", AccountName: " + (AccountName as string) +
                ", OUCount: " + (OUCount as string) +
                ", ReturnValue: " + ((ReturnValue != 0x8001011C) ? Win32ErrorCodesToText(ReturnValue) : "RPC_E_REMOTE_DISABLED");
        }
    } with IDL{Opnum = 26};

    accepts operation NetrAddAlternateComputerName
    {
        in optional handle_t RpcBindingHandle;
        in string ServerName with IDL{BaseStringType = TypeOf<wchar_t>(), IndirectionLevel = 1, PointerType = PointerKind.UniquePtr};
        in string AlternateName with IDL{BaseStringType = TypeOf<wchar_t>(), IndirectionLevel = 1, PointerType = PointerKind.UniquePtr};
        in string DomainAccount with IDL{BaseStringType = TypeOf<wchar_t>(), IndirectionLevel = 1, PointerType = PointerKind.UniquePtr};
        in PJOINPR_ENCRYPTED_USER_PASSWORD EncryptedPassword with IDL{PointerType = PointerKind.UniquePtr};
        in IDLUlong Reserved where (value is flags ULONG
            {
                NetIgnoreUnsupportedFlags = 0x00000001,
            } || value is IDLUlong);
        result IDLUlong ReturnValue where ValidationCheck(value is NetrAddAlternateComputerNameReturnValue, this, DiagnosisLevel.Error,
            "WKST: The ReturnValue in operation NetrAddAlternateComputerName must be one of the values specified in NetrAddAlternateComputerNameReturnValue, not " + value.ToString() + ".");

        override string ToString()
        {
            return "NetrAddAlternateComputerName, AlternateName: " + (AlternateName as string) +
                ", DomainAccount: " + (DomainAccount as string) +
                ", ReturnValue: " + Win32ErrorCodesToText(ReturnValue);
        }
    } with IDL{Opnum = 27};

    accepts operation NetrRemoveAlternateComputerName
    {
        in optional handle_t RpcBindingHandle;
        in string ServerName with IDL{BaseStringType = TypeOf<wchar_t>(), IndirectionLevel = 1, PointerType = PointerKind.UniquePtr};
        in string AlternateName with IDL{BaseStringType = TypeOf<wchar_t>(), IndirectionLevel = 1, PointerType = PointerKind.UniquePtr};
        in string DomainAccount with IDL{BaseStringType = TypeOf<wchar_t>(), IndirectionLevel = 1, PointerType = PointerKind.UniquePtr};
        in PJOINPR_ENCRYPTED_USER_PASSWORD EncryptedPassword with IDL{PointerType = PointerKind.UniquePtr};
        in IDLUlong Reserved where (value is flags ULONG
            {
                NetIgnoreUnsupportedFlags = 0x00000001,
            } || value is IDLUlong);
        result IDLUlong ReturnValue where ValidationCheck(value is NetrRemoveAlternateComputerNameReturnValue, this, DiagnosisLevel.Error,
            "WKST: The ReturnValue in operation NetrRemoveAlternateComputerName must be one of the values specified in NetrRemoveAlternateComputerNameReturnValue, not " + value.ToString() + ".");

        override string ToString()
        {
            return "NetrRemoveAlternateComputerName, AlternateName: " + (AlternateName as string) +
                ", DomainAccount: " + (DomainAccount as string) +
                ", ReturnValue: " + Win32ErrorCodesToText(ReturnValue);
        }
    } with IDL{Opnum = 28};

    accepts operation NetrSetPrimaryComputerName
    {
        in optional handle_t RpcBindingHandle;
        in string ServerName with IDL{BaseStringType = TypeOf<wchar_t>(), IndirectionLevel = 1, PointerType = PointerKind.UniquePtr};
        in string PrimaryName with IDL{BaseStringType = TypeOf<wchar_t>(), IndirectionLevel = 1, PointerType = PointerKind.UniquePtr};
        in string DomainAccount with IDL{BaseStringType = TypeOf<wchar_t>(), IndirectionLevel = 1, PointerType = PointerKind.UniquePtr};
        in PJOINPR_ENCRYPTED_USER_PASSWORD EncryptedPassword with IDL{PointerType = PointerKind.UniquePtr};
        in IDLUlong Reserved where (value is flags ULONG
            {
                NetIgnoreUnsupportedFlags = 0x00000001,
            } || value is IDLUlong);
        result IDLUlong ReturnValue where ValidationCheck(value is NetrSetPrimaryComputerNameReturnValue, this, DiagnosisLevel.Error,
            "WKST: The ReturnValue in operation NetrSetPrimaryComputerName must be one of the values specified in NetrSetPrimaryComputerNameReturnValue, not " + value.ToString() + ".");

        override string ToString()
        {
            return "NetrSetPrimaryComputerName, PrimaryName: " + (PrimaryName as string) +
                ", DomainAccount: " + (DomainAccount as string) +
                ", ReturnValue: " + Win32ErrorCodesToText(ReturnValue);
        }
    } with IDL{Opnum = 29};

    accepts operation NetrEnumerateComputerNames
    {
        in string ServerName with IDL{BaseStringType = TypeOf<WKSSVC_IMPERSONATE_HANDLE>(), PointerType = PointerKind.UniquePtr};
        in NET_COMPUTER_NAME_TYPE NameType;
        in IDLUlong Reserved where (value is flags ULONG
            {
                NetIgnoreUnsupportedFlags = 0x00000001,
            } || value is IDLUlong);
        out PNET_COMPUTER_NAME_ARRAY ComputerNames with IDL{IndirectionLevel = 1};
        result IDLUlong ReturnValue where ValidationCheck(value is NetrEnumerateComputerNamesReturnValue, this, DiagnosisLevel.Error,
            "WKST: The ReturnValue in operation NetrEnumerateComputerNames must be one of the values specified, not " + value.ToString() + ".");

        override string ToString()
        {
            return "NetrEnumerateComputerNames, NameType: " + EnumToString(NameType, "WKST.NET_COMPUTER_NAME_TYPE") +
                ", ReturnValue: " + Win32ErrorCodesToText(ReturnValue);
        }
    } with IDL{Opnum = 30};
} with IDL {
        Uuid = {6BFFD098-A112-3610-9833-46C3F87E345A},
        Version = "1.0",
        Pointer_default = PointerKind.UniquePtr,
    };

// _NETSETUP_JOIN_STATUS
pattern NETSETUP_JOIN_STATUS = enum ushort
    {
        NetSetupUnknownStatus = 0,
        NetSetupUnjoined,
        NetSetupWorkgroupName,
        NetSetupDomainName
        ...
    };

typedef PNETSETUP_JOIN_STATUS = NETSETUP_JOIN_STATUS with IDL{IndirectionLevel = 1};

// _NETSETUP_NAME_TYPE
pattern NETSETUP_NAME_TYPE = enum ushort
    {
        NetSetupUnknown = 0,
        NetSetupMachine,
        NetSetupWorkgroup,
        NetSetupDomain,
        NetSetupNonExistentDomain,
        NetSetupDnsMachine
        ...
    };

typedef PNETSETUP_NAME_TYPE = NETSETUP_NAME_TYPE with IDL{IndirectionLevel = 1};

// _NET_COMPUTER_NAME_TYPE
pattern NET_COMPUTER_NAME_TYPE = enum ushort
    {
        NetPrimaryComputerName = 0,
        NetAlternateComputerNames,
        NetAllComputerNames,
        NetComputerNameTypeMax
        ...
    };

typedef PNET_COMPUTER_NAME_TYPE = NET_COMPUTER_NAME_TYPE with IDL{IndirectionLevel = 1};

//----------------------------------- Data types/ Structures/ Uniouns -----------------------------------//
// _STAT_WORKSTATION_0
type STAT_WORKSTATION_0
{
    LARGE_INTEGER StatisticsStartTime;
    LARGE_INTEGER BytesReceived;
    LARGE_INTEGER SmbsReceived;
    LARGE_INTEGER PagingReadBytesRequested;
    LARGE_INTEGER NonPagingReadBytesRequested;
    LARGE_INTEGER CacheReadBytesRequested;
    LARGE_INTEGER NetworkReadBytesRequested;
    LARGE_INTEGER BytesTransmitted;
    LARGE_INTEGER SmbsTransmitted;
    LARGE_INTEGER PagingWriteBytesRequested;
    LARGE_INTEGER NonPagingWriteBytesRequested;
    LARGE_INTEGER CacheWriteBytesRequested;
    LARGE_INTEGER NetworkWriteBytesRequested;
    IDLUlong InitiallyFailedOperations;
    IDLUlong FailedCompletionOperations;
    IDLUlong ReadOperations;
    IDLUlong RandomReadOperations;
    IDLUlong ReadSmbs;
    IDLUlong LargeReadSmbs;
    IDLUlong SmallReadSmbs;
    IDLUlong WriteOperations;
    IDLUlong RandomWriteOperations;
    IDLUlong WriteSmbs;
    IDLUlong LargeWriteSmbs;
    IDLUlong SmallWriteSmbs;
    IDLUlong RawReadsDenied;
    IDLUlong RawWritesDenied;
    IDLUlong NetworkErrors;
    IDLUlong Sessions;
    IDLUlong FailedSessions;
    IDLUlong Reconnects;
    IDLUlong CoreConnects;
    IDLUlong Lanman20Connects;
    IDLUlong Lanman21Connects;
    IDLUlong LanmanNtConnects;
    IDLUlong ServerDisconnects;
    IDLUlong HungSessions;
    IDLUlong UseCount;
    IDLUlong FailedUseCount;
    IDLUlong CurrentCommands;
}

typedef LPSTAT_WORKSTATION_0 = STAT_WORKSTATION_0 with IDL{IndirectionLevel = 1};

// WKSTA_INFO_100
type WKSTA_INFO_100
{
    IDLUlong wki100_platform_id where ValidationCheck(value is Wki100PlatformIdPattern, null,
            "WKST: The wki100_platform_id in type WKSTA_INFO_100 must be one of 0x0000012C, 0x00000190, 0x000001F4, 0x00000258, and 0x000002BC.");
    string wki100_computername with IDL{BaseStringType = TypeOf<wchar_t>(), IndirectionLevel = 1};
    string wki100_langroup with IDL{BaseStringType = TypeOf<wchar_t>(), IndirectionLevel = 1};
    IDLUlong wki100_ver_major;
    IDLUlong wki100_ver_minor;
}

typedef LPWKSTA_INFO_100 = WKSTA_INFO_100 with IDL{IndirectionLevel = 1};

// WKSTA_INFO_101
type WKSTA_INFO_101
{
    IDLUlong wki101_platform_id;
    string wki101_computername with IDL{BaseStringType = TypeOf<wchar_t>(), IndirectionLevel = 1};
    string wki101_langroup with IDL{BaseStringType = TypeOf<wchar_t>(), IndirectionLevel = 1};
    IDLUlong wki101_ver_major;
    IDLUlong wki101_ver_minor;
    string wki101_lanroot with IDL{BaseStringType = TypeOf<wchar_t>(), IndirectionLevel = 1}; 
}

typedef LPWKSTA_INFO_101 = WKSTA_INFO_101 with IDL{IndirectionLevel = 1};

// _WKSTA_INFO_102
type WKSTA_INFO_102
{
    IDLUlong wki102_platform_id;
    string wki102_computername with IDL{BaseStringType = TypeOf<wchar_t>(), IndirectionLevel = 1};
    string wki102_langroup with IDL{BaseStringType = TypeOf<wchar_t>(), IndirectionLevel = 1};
    IDLUlong wki102_ver_major;
    IDLUlong wki102_ver_minor;
    string wki102_lanroot with IDL{BaseStringType = TypeOf<wchar_t>(), IndirectionLevel = 1};
    IDLUlong wki102_logged_on_users;
}

typedef LPWKSTA_INFO_102 = WKSTA_INFO_102 with IDL{IndirectionLevel = 1};

// _WKSTA_INFO_502
type WKSTA_INFO_502
{
    IDLUlong wki502_char_wait;
    IDLUlong wki502_collection_time;
    IDLUlong wki502_maximum_collection_count;
    IDLUlong wki502_keep_conn;
    IDLUlong wki502_max_cmds;
    IDLUlong wki502_sess_timeout;
    IDLUlong wki502_siz_char_buf;
    IDLUlong wki502_max_threads;
    IDLUlong wki502_lock_quota;
    IDLUlong wki502_lock_increment;
    IDLUlong wki502_lock_maximum;
    IDLUlong wki502_pipe_increment;
    IDLUlong wki502_pipe_maximum;
    IDLUlong wki502_cache_file_timeout;
    IDLUlong wki502_dormant_file_limit;
    IDLUlong wki502_read_ahead_throughput;
    IDLUlong wki502_num_mailslot_buffers;
    IDLUlong wki502_num_srv_announce_buffers;
    IDLUlong wki502_max_illegal_datagram_events;
    IDLUlong wki502_illegal_datagram_event_reset_frequency;
    int wki502_log_election_packets;
    int wki502_use_opportunistic_locking;
    int wki502_use_unlock_behind;
    int wki502_use_close_behind;
    int wki502_buf_named_pipes;
    int wki502_use_lock_read_unlock;
    int wki502_utilize_nt_caching;
    int wki502_use_raw_read;
    int wki502_use_raw_write;
    int wki502_use_write_raw_data;
    int wki502_use_encryption;
    int wki502_buf_files_deny_write;
    int wki502_buf_read_only_files;
    int wki502_force_core_create_mode;
    int wki502_use_512_byte_max_transfer;
}

typedef LPWKSTA_INFO_502 = WKSTA_INFO_502 with IDL{IndirectionLevel = 1};

// _WKSTA_INFO_1013
type WKSTA_INFO_1013
{
    IDLUlong wki1013_keep_conn;
}

typedef LPWKSTA_INFO_1013 = WKSTA_INFO_1013 with IDL{IndirectionLevel = 1};

// _WKSTA_INFO_1018
type WKSTA_INFO_1018
{
    IDLUlong wki1018_sess_timeout;
}

typedef LPWKSTA_INFO_1018 = WKSTA_INFO_1018 with IDL{IndirectionLevel = 1};

// _WKSTA_INFO_1046
type WKSTA_INFO_1046
{
    IDLUlong wki1046_dormant_file_limit;
}

typedef LPWKSTA_INFO_1046 = WKSTA_INFO_1046 with IDL{IndirectionLevel = 1};

// _WKSTA_USER_INFO_0
type WKSTA_USER_INFO_0
{
    string wkui0_username with IDL{BaseStringType = TypeOf<wchar_t>(), IndirectionLevel = 1};
}

// _WKSTA_USER_INFO_1
type WKSTA_USER_INFO_1
{
    string wkui1_username with IDL{BaseStringType = TypeOf<wchar_t>(), IndirectionLevel = 1};
    string wkui1_logon_domain with IDL{BaseStringType = TypeOf<wchar_t>(), IndirectionLevel = 1};
    string wkui1_oth_domains with IDL{BaseStringType = TypeOf<wchar_t>(), IndirectionLevel = 1};
    string wkui1_logon_server with IDL{BaseStringType = TypeOf<wchar_t>(), IndirectionLevel = 1};
}

// _WKSTA_TRANSPORT_INFO_0
type WKSTA_TRANSPORT_INFO_0
{
    IDLUlong wkti0_quality_of_service;
    IDLUlong wkti0_number_of_vcs;
    string wkti0_transport_name with IDL{BaseStringType = TypeOf<wchar_t>(), IndirectionLevel = 1};
    string wkti0_transport_address with IDL{BaseStringType = TypeOf<wchar_t>(), IndirectionLevel = 1};
    IDLUlong wkti0_wan_ish;
}

typedef LPWKSTA_TRANSPORT_INFO_0 = WKSTA_TRANSPORT_INFO_0 with IDL{IndirectionLevel = 1};

// WKSSVC_IDENTIFY_HANDLE
pattern WKSSVC_IDENTIFY_HANDLE =  wchar_t with IDL{IndirectionLevel = 1};

// WKSSVC_IMPERSONATE_HANDLE
pattern WKSSVC_IMPERSONATE_HANDLE = wchar_t with IDL{IndirectionLevel = 1};

// _WKSTA_INFO
type WKSTA_INFO[IDLUlong Tag]
{
    optional [|Tag == 100|] WKSTA_INFO_100 WkstaInfo100 with IDL{Case = [100], IndirectionLevel = 1};
    optional [|Tag == 101|] WKSTA_INFO_101 WkstaInfo101 with IDL{Case = [101], IndirectionLevel = 1};
    optional [|Tag == 102|] WKSTA_INFO_102 WkstaInfo102 with IDL{Case = [102], IndirectionLevel = 1};
    optional [|Tag == 502|] WKSTA_INFO_502 WkstaInfo502 with IDL{Case = [502], IndirectionLevel = 1};
    optional [|Tag == 1013|] WKSTA_INFO_1013 WkstaInfo1013 with IDL{Case = [1013], IndirectionLevel = 1};
    optional [|Tag == 1018|] WKSTA_INFO_1018 WkstaInfo1018 with IDL{Case = [1018], IndirectionLevel = 1};
    optional [|Tag == 1046|] WKSTA_INFO_1046 WkstaInfo1046 with IDL{Case = [1046], IndirectionLevel = 1};
} with IDL{UnionKind = UnionKind.NonEncapsulated, EmptyDefault = true, Switch_Type = TypeOf<IDLUlong>()};

typedef LPWKSTA_INFO = WKSTA_INFO with IDL{IndirectionLevel = 1};

// _USE_INFO_O
type USE_INFO_0
{
    string ui0_local with IDL{BaseStringType = TypeOf<wchar_t>(), IndirectionLevel = 1};
    string ui0_remote with IDL{BaseStringType = TypeOf<wchar_t>(), IndirectionLevel = 1};
}

typedef LPUSE_INFO_0 = USE_INFO_0 with IDL{IndirectionLevel = 1};

// _USE_INFO_1
type USE_INFO_1
{
    string ui1_local with IDL{BaseStringType = TypeOf<wchar_t>(), IndirectionLevel = 1};
    string ui1_remote with IDL{BaseStringType = TypeOf<wchar_t>(), IndirectionLevel = 1};
    string ui1_password with IDL{BaseStringType = TypeOf<wchar_t>(), IndirectionLevel = 1};
    IDLUlong ui1_status;
    IDLUlong ui1_asg_type;
    IDLUlong ui1_refcount;
    IDLUlong ui1_usecount;
}

typedef LPUSE_INFO_1 = USE_INFO_1 with IDL{IndirectionLevel = 1};

// _USE_INFO_2
type USE_INFO_2
{
    USE_INFO_1 ui2_useinfo;
    string ui2_username with IDL{BaseStringType = TypeOf<wchar_t>(), IndirectionLevel = 1};
    string ui2_domainname with IDL{BaseStringType = TypeOf<wchar_t>(), IndirectionLevel = 1};
}

typedef LPUSE_INFO_2 = USE_INFO_2 with IDL{IndirectionLevel = 1};

// _USE_INFO_3
type USE_INFO_3
{
    USE_INFO_2 ui3_ui2;
    IDLUlong ui3_flags;
}

typedef LPUseInfo3 = USE_INFO_3 with IDL{IndirectionLevel = 1};

// _USE_INFO
type USE_INFO[IDLUlong Tag]
{
    optional [|Tag == 0|] USE_INFO_0 UseInfo0 with IDL{Case = [0], IndirectionLevel = 1};
    optional [|Tag == 1|] USE_INFO_1 UseInfo1 with IDL{Case = [1], IndirectionLevel = 1};
    optional [|Tag == 2|] USE_INFO_2 UseInfo2 with IDL{Case = [2], IndirectionLevel = 1};
    optional [|Tag == 3|] USE_INFO_3 UseInfo3 with IDL{Case = [3], IndirectionLevel = 1};
} with IDL{UnionKind = UnionKind.NonEncapsulated, EmptyDefault = true, Switch_Type = TypeOf<IDLUlong>()};

typedef LPUSE_INFO = USE_INFO with IDL{IndirectionLevel = 1};

// _USE_INFO_0_CONTAINER
type USE_INFO_0_CONTAINER
{
    IDLUlong EntriesRead;
    USE_INFO_0 Buffer with IDL{IndirectionLevel = 1};
}

typedef LPUSE_INFO_0_CONTAINER = USE_INFO_0_CONTAINER with IDL{IndirectionLevel = 1};

// _USE_INFO_1_CONTAINER
type USE_INFO_1_CONTAINER
{
    IDLUlong EntriesRead;
    LPUSE_INFO_1 Buffer;
}

typedef LPUSE_INFO_1_CONTAINER = USE_INFO_1_CONTAINER with IDL{IndirectionLevel = 1};

// _USE_INFO_2_CONTAINER
type USE_INFO_2_CONTAINER
{
    IDLUlong EntriesRead;
    LPUSE_INFO_2 Buffer;
}

typedef LPUSE_INFO_2_CONTAINER = USE_INFO_2_CONTAINER with IDL{IndirectionLevel = 1};

// _USE_ENUM_STRUCT
type USE_ENUM_STRUCT
{
    DWORD Level;
    UseEnumUnion[Level] UseInfo with IDL{Switch_Is = Level};
}

typedef LPUSE_ENUM_STRUCT = USE_ENUM_STRUCT with IDL{IndirectionLevel = 1};

type UseEnumUnion [DWORD Tag]
{
    optional [|Tag == 0|] USE_INFO_0_CONTAINER Level0 with IDL{Case = [0], IndirectionLevel = 1};
    optional [|Tag == 1|] USE_INFO_1_CONTAINER Level1 with IDL{Case = [1], IndirectionLevel = 1};
    optional [|Tag == 2|] USE_INFO_2_CONTAINER Level2 with IDL{Case = [2], IndirectionLevel = 1};
} with IDL{UnionKind = UnionKind.NonEncapsulated, EmptyDefault = true};

// _WKSTA_USER_INFO_0_CONTAINER
type WKSTA_USER_INFO_0_CONTAINER
{
    IDLUlong EntriesRead;
    array<WKSTA_USER_INFO_0> Buffer with IDL{Size_is = [EntriesRead], IndirectionLevel = 1};
}

typedef LPWKSTA_USER_INFO_0_CONTAINER = WKSTA_USER_INFO_0_CONTAINER with IDL{IndirectionLevel = 1};

// _WKSTA_USER_INFO_1_CONTAINER
type WKSTA_USER_INFO_1_CONTAINER
{
    IDLUlong EntriesRead;
    array<WKSTA_USER_INFO_1> Buffer with IDL{Size_is = [EntriesRead], IndirectionLevel = 1};
}

typedef LPWKSTA_USER_INFO_1_CONTAINER = WKSTA_USER_INFO_1_CONTAINER with IDL{IndirectionLevel = 1};

// _WKSTA_USER_ENUM_STRUCT
type WKSTA_USER_ENUM_STRUCT
{
    IDLUlong Level;
    WkstaUserEnumUnion[Level] WkstaUserInfo with IDL{Switch_Is = Level};
}

typedef LPWKSTA_USER_ENUM_STRUCT = WKSTA_USER_ENUM_STRUCT with IDL{IndirectionLevel = 1};

type WkstaUserEnumUnion[IDLUlong Tag]
{
    optional [|Tag == 0|] WKSTA_USER_INFO_0_CONTAINER Level0 with IDL{Case = [0], IndirectionLevel = 1};
    optional [|Tag == 1|] WKSTA_USER_INFO_1_CONTAINER Level1 with IDL{Case = [1], IndirectionLevel = 1};
} with IDL{UnionKind = UnionKind.NonEncapsulated, EmptyDefault = true};

// _WKSTA_TRANSPORT_INFO_0_CONTAINER
type WKSTA_TRANSPORT_INFO_0_CONTAINER
{
    IDLUlong EntriesRead;
    array<WKSTA_TRANSPORT_INFO_0> Buffer with IDL{Size_is = [EntriesRead], IndirectionLevel = 1};
};

typedef LPWKSTA_TRANSPORT_INFO_0_CONTAINER = WKSTA_TRANSPORT_INFO_0_CONTAINER with IDL{IndirectionLevel = 1};

// _WKSTA_TRANSPORT_ENUM_STRUCT
type WKSTA_TRANSPORT_ENUM_STRUCT
{
    IDLUlong Level where ValidationCheck(value == 0, null, DiagnosisLevel.Error, 
            "WKST: The Level field in type WKSTA_TRANSPORT_ENUM_STRUCT must be set to zero, not " + value.ToString() + ".");
    WkstaTransportEnumUnion[Level] WkstaTransportInfo with IDL{Switch_Is = Level};
}

typedef LPWKSTA_TRANSPORT_ENUM_STRUCT = WKSTA_TRANSPORT_ENUM_STRUCT with IDL{IndirectionLevel = 1};

type WkstaTransportEnumUnion[IDLUlong Tag]
{
    optional [|Tag == 0|] WKSTA_TRANSPORT_INFO_0_CONTAINER Level0 with IDL{Case = [0], IndirectionLevel = 1};
} with IDL{UnionKind = UnionKind.NonEncapsulated, EmptyDefault = true};

// JOIN_OBFUSCATOR_LENGTH
const int JOIN_OBFUSCATOR_LENGTH = 8;
// JOIN_MAX_PASSWORD_LENGTH 256
const int JOIN_MAX_PASSWORD_LENGTH = 256;

// _JOINPR_USER_PASSWORD
// It's internal type, MMA can just get encrypted JOINPR_USER_PASSWORD type JOINPR_ENCRYPTED_USER_PASSWORD
// Just for TDGen
type JOINPR_USER_PASSWORD
{
    array<UCHAR> Obfuscator with IDL{Dimensions = [JOIN_OBFUSCATOR_LENGTH]};
    array<wchar_t> Buffer with IDL{Dimensions = [JOIN_MAX_PASSWORD_LENGTH]};
    IDLUlong Length;
}

// _JOINPR_ENCRYPTED_USER_PASSWORD
type JOINPR_ENCRYPTED_USER_PASSWORD
{
    array<UCHAR> Buffer with IDL {Dimensions = [(JOIN_OBFUSCATOR_LENGTH + (JOIN_MAX_PASSWORD_LENGTH * 2) + 4) as int]};
}

typedef PJOINPR_ENCRYPTED_USER_PASSWORD = JOINPR_ENCRYPTED_USER_PASSWORD with IDL{IndirectionLevel = 1};

// _UNICODE_STRING
type UNICODE_STRING
{
    USHORT Length;
    USHORT MaximumLength;
    array<USHORT> Buffer with IDL{Size_is = [MaximumLength / 2], Length_is = [Length / 2], IndirectionLevel = 1};
}

typedef PUNICODE_STRING = UNICODE_STRING with IDL{IndirectionLevel = 1};

// _NET_COMPUTER_NAME_ARRAY
type NET_COMPUTER_NAME_ARRAY
{
    IDLUlong EntryCount;
    array<UNICODE_STRING> ComputerNames with IDL{Size_is = [EntryCount], IndirectionLevel = 1};
}

typedef PNET_COMPUTER_NAME_ARRAY = NET_COMPUTER_NAME_ARRAY with IDL{IndirectionLevel = 1};

//---------------------------- Not defined in IDL ----------------------------//
// 2.2.5.1 WKSTA_INFO_100
pattern Wki100PlatformIdPattern = enum IDLUlong
{
    Dos = 0x0000012C,
    Os2 = 0x00000190,
    Windows = 0x000001F4,
    Osf = 0x00000258,
    Vms = 0x000002Bc,
} with IDL{DoNotGenerate = true};

// 3.2.4.1   NetrWkstaGetInfo (Opnum 0)
pattern NetrWkstaGetInfoLevel = enum IDLUlong
{
    WKSTA_INFO_100 = 0x00000064,
    WKSTA_INFO_101 = 0x00000065,
    WKSTA_INFO_102 = 0x00000066,
    WKSTA_INFO_502 = 0x000001F6
} with IDL{DoNotGenerate = true};

const map<IDLUlong, string> NetrWkstaGetInfoLevels =
    {
        0x00000064 -> "WKSTA_INFO_100",
        0x00000065 -> "WKSTA_INFO_101",
        0x00000066 -> "WKSTA_INFO_102",
        0x000001F6 -> "WKSTA_INFO_502"
    };

string NetrWkstaGetInfoLevelToString(IDLUlong key)
{
    if (key in NetrWkstaGetInfoLevels)
    {
        return NetrWkstaGetInfoLevels[key];
    }
    return "Unknown Value(" + (key as string) + ")";
}

// 3.2.4.2   NetrWkstaSetInfo (Opnum 1)
pattern NetrWkstaSetInfoLevel = enum IDLUlong
{
    WKSTA_INFO_502 = 0x000001F6,
    WKSTA_INFO_1013 = 0x000003F5,
    WKSTA_INFO_1018 = 0x000003FA,
    WKSTA_INFO_1046 = 0x00000416
} with IDL{DoNotGenerate = true};

const map<IDLUlong, string> NetrWkstaSetInfoLevels =
    {
        0x000001F6 -> "WKSTA_INFO_502",
        0x000003F5 -> "WKSTA_INFO_1013",
        0x000003FA -> "WKSTA_INFO_1018",
        0x00000416 -> "WKSTA_INFO_1046"
    };

string NetrWkstaSetInfoLevelToString(IDLUlong key)
{
    if (key in NetrWkstaSetInfoLevels)
    {
        return NetrWkstaSetInfoLevels[key];
    }
    return "Unknown Value(" + (key as string) + ")";
}

string NetrWkstaTransportAddLevelToString(IDLUlong v)
{
    if (v == 0)
    {
        return "WKSTA_TRANSPORT_INFO_0";
    }
    return "Unknown Value(" + (v as string) + ")";
}

// 3.2.4.6   NetrWkstaTransportDel (Opnum 7)
pattern DelForceLevel = enum IDLUlong
{
    UseNoforce = 0x00000000,
    UseForce = 0x00000001,
    UseLotsOfForce = 0x00000002,
} with IDL{DoNotGenerate = true};

const map<IDLUlong, string> DelForceLevels =
    {
        0x00000000 -> "USE_NOFORCE",
        0x00000001 -> "USE_FORCE",
        0x00000002 -> "USE_LOTS_OF_FORCE",
    };

string DelForceLevelToString(IDLUlong key)
{
    if (key in DelForceLevels)
    {
        return DelForceLevels[key];
    }
    return "Unknown Value(" + (key as string) + ")";
}

// 3.2.4.7   NetrUseAdd (Opnum 8)
pattern UseInfoLevel = enum IDLUlong
{
    USE_INFO_0 = 0x00000000,
    USE_INFO_1 = 0x00000001,
    USE_INFO_2 = 0x00000002,
    USE_INFO_3 = 0x00000003,
} with IDL{DoNotGenerate = true};

const map<IDLUlong, string> UseInfoLevels =
    {
        0x00000000 -> "USE_INFO_0",
        0x00000001 -> "USE_INFO_1",
        0x00000002 -> "USE_INFO_2",
        0x00000003 -> "USE_INFO_3",
    };

string UseInfoLevelToString(IDLUlong key)
{
    if (key in UseInfoLevels)
    {
        return UseInfoLevels[key];
    }
    return "Unknown Value(" + (key as string) + ")";
}

// Patterns that defined for value validation check of the ReturnVlaues
pattern NetrWkstaGetInfoReturnValue = enum IDLUlong
{
    ErrorSuccess = 0X00000000,
    ErrorAccessDenied = 0X00000005,
    ErrorInvalidLevel = 0X0000007C
} with IDL{DoNotGenerate = true};

pattern NetrWkstaSetInfoReturnValue = enum IDLUlong
{
    ErrorSuccess = 0x00000000,
    ErrorAccessDenied = 0x00000005,
    ErrorInvalidParameter = 0x00000057
} with IDL{DoNotGenerate = true};

pattern NetrWkstaUserEnumReturnValue = enum IDLUlong
{
    ErrorSuccess = 0x00000000,
    ErrorAccessDenied = 0x00000005,
    ErrorInvalidLevel = 0x0000007C,
    ErrorMoreData = 0x000000EA
} with IDL{DoNotGenerate = true};

pattern NetrWkstaTransportEnumReturnValue = enum IDLUlong
{
    NerrSuccess = 0x00000000,
    ErrorAccessDenied = 0x00000005,
    ErrorInvalidLevel = 0x0000007C,
    NerrBufTooSmall = 0x0000084B
} with IDL{DoNotGenerate = true};

pattern NetrWkstaTransportAddReturnValue = enum IDLUlong
{
    NerrSuccess = 0x00000000,
    ErrorAccessDenied = 0x00000005,
    ErrorInvalidParameter = 0x00000057,
    ErrorInvalidLevel = 0x0000007C
} with IDL{DoNotGenerate = true};

pattern NetrWkstaTransportDelReturnValue = enum IDLUlong
{
    NerrSuccess = 0x00000000,
    ErrorAccessDenied = 0x00000005,
    ErrorInvalidParameter = 0x00000057, 
    ErrorOpenFiles = 0x00002401,
    ErrorDeviceInUse = 0x00002404
} with IDL{DoNotGenerate = true};

pattern NetrUseAddReturnValue = enum IDLUlong
{
    NerrSuccess = 0x00000000,
    ErrorAccessDenied = 0x00000005,
    ErrorInvalidParameter = 0x00000057,
    ErrorInvalidLevel = 0x0000007C,
    ErrorCallNotImplemented = 0x00000078
} with IDL{DoNotGenerate = true};

pattern NetrUseGetInfoReturnValue = enum IDLUlong
{
    NerrSuccess = 0x00000000,
    ErrorAccessDenied = 0x00000005,
    ErrorInvalidParameter = 0x00000057,
    ErrorInvalidLevel = 0x0000007C, 
    NerrUseNotFound = 0x000008CA
} with IDL{DoNotGenerate = true};

pattern NetrUseDelReturnValue = enum IDLUlong
{
    NerrSuccess = 0x00000000,
    ErrorAccessDenied = 0x00000005,
    ErrorInvalidParameter = 0x00000057,
    ErrorInvalidLevel = 0x0000007C, 
    ErrorDeviceInUse = 0x00002404,
    ErrorRedirPaused = 0x00000048
} with IDL{DoNotGenerate = true};

pattern NetrUseEnumReturnValue = enum IDLUlong
{
    NerrSuccess = 0x00000000,
    ErrorInvalidLevel = 0x0000007C, 
    ErrorMoreData = 0x000000EA,
    ErrorNotEnoughMemory = 0x00000008,
    NerrBufTooSmall = 0x0000084B,
} with IDL{DoNotGenerate = true};

pattern NetrWorkstationStatisticsGetReturnValue = enum IDLUlong
{
    NerrSuccess = 0x00000000,
    ErrorAccessDenied = 0x00000005,
    ErrorInvalidParameter = 0x00000057,
    ErrorInvalidLevel = 0x0000007C
} with IDL{DoNotGenerate = true};

pattern NetrGetJoinInformationReturnValue = enum IDLUlong
{
    NerrSuccess = 0x00000000,
    ErrorAccessDenied = 0x00000005,
    RpcSProtseqNotSupported = 0x000006A7
} with IDL{DoNotGenerate = true};

pattern NetrJoinDomain2ReturnValue = enum IDLUlong
{
    NerrSuccess = 0x00000000,
    ErrorAccessDenied = 0x00000005,
    ErrorNotSupported = 0x00000032,
    ErrorNoSuchDomain = 0x0000054B,
    ErrorInvalidPassword = 0x00000056,
    ErrorInvalidParameter = 0x00000057,
    ErrorPasswordRestriction = 0x0000052D,
    ErrorInvalidDomainRole  = 0x0000054A,
    RpcSProtseqNotSupported = 0x000006A7,
    RpcSCallInProgress = 0x000006FF,
    NerrSetupAlreadyJoined = 0x00000A83,
    NerrSetupDomainController = 0x00000A85,
    NerrInvalidWorkgroupName = 0x00000A87,
} with IDL{DoNotGenerate = true};

pattern NetrUnjoinDomain2ReturnValue = enum IDLUlong
{
    NerrSuccess = 0x00000000,
    ErrorAccessDenied = 0x00000005,
    ErrorInvalidPassword = 0x00000056,
    ErrorInvalidParameter = 0x00000057,
    ErrorInvalidFlags = 0x000003EC,
    RpcSProtseqNotSupported = 0x000006A7,
    NerrSetupNotJoined = 0x00000A84,
    NerrSetupDomainController = 0x00000A85
} with IDL{DoNotGenerate = true};

pattern NetrRenameMachineInDomain2ReturnValue = enum IDLUlong
{
    NerrSuccess = 0x00000000,
    ErrorAccessDenied  = 0x00000005,
    ErrorNotSupported = 0x00000032,
    ErrorInvalidPassword  = 0x00000056,
    ErrorInvalidParameter  = 0x00000057,
    RpcSProtseqNotSupported  = 0x000006A7,
    NerrSetupNotJoined  = 0x00000A84,
    NerrSetupDomainController = 0x00000A85,
} with IDL{DoNotGenerate = true};

pattern NetrValidateName2ReturnValue = enum IDLUlong
{
    NerrSuccess = 0x00000000,
    ErrorAccessDenied  = 0x00000005,
    ErrorDupName  = 0x00000034,
    ErrorInvalidPassword = 0x00000056,
    ErrorInvalidParameter = 0x00000057,
    ErrorInvalidName = 0x0000007B,
    ErrorInvalidDomainname = 0x000004BC,
    ErrorNoSuchDomain = 0x0000054B,
    RpcSProtseqNotSupported = 0x000006A7,
    NerrInvalidComputer = 0x0000092F,
    NerrInvalidWorkgroupName = 0x00000A87,
    DnsErrorNonRfcName = 0x00002554,
    DnsErrorInvalidNameChar = 0x00002558,
    RpcERemoteDisabled = 0x8001011C,
} with IDL{DoNotGenerate = true};

pattern NetrGetJoinableOUs2ReturnValue = enum IDLUlong
{
    NerrSuccess = 0x00000000,
    ErrorAccessDenied = 0x00000005,
    ErrorNotEnoughMemory = 0x00000008,
    ErrorInvalidParameter = 0x00000057,
    RpcSProtseqNotSupported = 0x000006A7,
    NerrInvalidAPI  = 0x0000085E,
    NerrDefaultJoinRequired = 0x00000A86,
} with IDL{DoNotGenerate = true};

pattern NetrAddAlternateComputerNameReturnValue = enum IDLUlong
{
    NerrSuccess = 0x00000000,
    ErrorAccessDenied = 0x00000005,
    ErrorNotSupported = 0x00000032,
    ErrorInvalidPassword = 0x00000056,
    ErrorInvalidParameter = 0x00000057,
    ErrorInvalidName = 0x0000007B,
    ErrorInvalidFlags = 0x000003EC,
    RpcSProtseqNotSupported = 0x000006A7,
    RpcSCallInProgress  = 0x000006FF,
    DnsErrorInvalidNameChar = 0x00002558,
} with IDL{DoNotGenerate = true};

pattern NetrRemoveAlternateComputerNameReturnValue = enum IDLUlong
{
    NerrSuccess = 0x00000000,
    ErrorAccessDenied = 0x00000005,
    ErrorNotSupported = 0x00000032,
    ErrorInvalidPassword = 0x00000056,
    ErrorInvalidParameter = 0x00000057,
    ErrorInvalidName = 0x0000007B,
    ErrorInvalidFlags = 0x000003EC,
    ErrorNotFound  = 0x00000490,
    RpcSProtseqNotSupported  = 0x000006A7,
    RpcSCallInProgress  = 0x000006FF,
    DnsErrorInvalidNameChar = 0x00002558,
} with IDL{DoNotGenerate = true};

pattern NetrSetPrimaryComputerNameReturnValue = enum IDLUlong
{
    NerrSuccess = 0x00000000,
    ErrorAccessDenied = 0x00000005,
    ErrorNotSupported = 0x00000032,
    ErrorInvalidPassword = 0x00000056,
    ErrorInvalidParameter = 0x00000057,
    ErrorInvalidName = 0x0000007B,
    ErrorInvalidFlags = 0x000003EC,
    RpcSProtseqNotSupported  = 0x000006A7,
    RpcSCallInProgress  = 0x000006FF,
    NerrDefaultJoinRequired = 0x00000A86,
    DnsErrorInvalidNameChar = 0x00002558,
} with IDL{DoNotGenerate = true};

pattern NetrEnumerateComputerNamesReturnValue = enum IDLUlong
{
    NerrSuccess = 0x00000000,
    ErrorAccessDenied = 0x00000005,
    ErrorNotEnoughMemory = 0x00000008,
    ErrorInvalidParameter = 0x00000057,
    ErrorNotSupported = 0x00000032,
    ErrorInvalidFlags = 0x000003EC,
    RpcSProtseqNotSupported  = 0x000006A7,
    RpcSCallInProgress = 0x000006FF,
} with IDL{DoNotGenerate = true};
