protocol DCOM with 
Documentation
{
    ProtocolName = "Distributed Component Object Model (DCOM) Remote Protocol",
    ProtocolType = "rpc",
    ShortName = "DCOM",
    DocumentName = "MS-DCOM",
    Description = ""
},
OPNAuthoring
{
    Copyright = "(c) Microsoft Corporation",
    References = 
    [
        new Reference {Name = "MS-DCOM", Version = "15.1", Date = "01/31/2013", ProgramName = ProgramName.WSPP}
    ],
    RevisionSummary = 
    [
        new Revision {Class = RevisionClass.Major, Version = "363061", Date = "04/24/2014"}
    ]
};

using Technologies.IDL;
using DTYP;
using MSRPCE;
using Utility;
using MicrosoftCommonResources;
using Diagnostics;

//const guid definition
const guid GUID_NULL = {00000000-0000-0000-0000-000000000000} with IDL{DoNotGenerate = true};
const guid CLSID_ActivationContextInfo = {000001a5-0000-0000-c000-000000000046} with IDL{DoNotGenerate = true};
const guid CLSID_ActivationPropertiesIn = {00000338-0000-0000-c000-000000000046} with IDL{DoNotGenerate = true};
const guid CLSID_ActivationPropertiesOut = {00000339-0000-0000-c000-000000000046} with IDL{DoNotGenerate = true};
const guid CLSID_CONTEXT_EXTENSION = {00000334-0000-0000-c000-000000000046} with IDL{DoNotGenerate = true};
const guid CLSID_ContextMarshaler = {0000033b-0000-0000-c000-000000000046} with IDL{DoNotGenerate = true};
const guid CLSID_ERROR_EXTENSION = {0000031c-0000-0000-c000-000000000046} with IDL{DoNotGenerate = true};
const guid CLSID_ErrorObject = {0000031b-0000-0000-c000-000000000046} with IDL{DoNotGenerate = true};
const guid CLSID_InstanceInfo = {000001ad-0000-0000-c000-000000000046} with IDL{DoNotGenerate = true};
const guid CLSID_InstantiationInfo = {000001ab-0000-0000-c000-000000000046} with IDL{DoNotGenerate = true};
const guid CLSID_PropsOutInfo = {00000339-0000-0000-c000-000000000046} with IDL{DoNotGenerate = true};
const guid CLSID_ScmReplyInfo = {000001b6-0000-0000-c000-000000000046} with IDL{DoNotGenerate = true};
const guid CLSID_ScmRequestInfo = {000001aa-0000-0000-c000-000000000046} with IDL{DoNotGenerate = true};
const guid CLSID_SecurityInfo = {000001a6-0000-0000-c000-000000000046} with IDL{DoNotGenerate = true};
const guid CLSID_ServerLocationInfo = {000001a4-0000-0000-c000-000000000046} with IDL{DoNotGenerate = true};
const guid CLSID_SpecialSystemProperties = {000001b9-0000-0000-c000-000000000046} with IDL{DoNotGenerate = true};

endpoint DcomService 
    over MSRPCE.Server 
    provides IUnknown
    provides IActivation
    provides IRemoteSCMActivator
    provides IObjectExporter
    provides IRemUnknown
    provides IRemUnknown2;

contract IActivation
{
    accepts operation RemoteActivation
    {
        in optional handle_t hRpc;
        in ORPCTHIS ORPCthis where ValidationCheckValue(value.extensions == null, null, true, ReferenceType.Message, "DCOM", "ORPCthis.extensions", "RemoteActivation", "NULL", value)
            with Technologies.IDL.IDL{IndirectionLevel = 1};
        out ORPCTHAT ORPCthat where ValidationCheckValue(value.extensions == null, null, true, ReferenceType.Message, "DCOM", "ORPCthat.extensions", "RemoteActivation", "NULL", value)
            with Technologies.IDL.IDL{IndirectionLevel = 1};
        in GUID Clsid 
            with Technologies.IDL.IDL{IndirectionLevel = 1};
        in string pwszObjectName
               with Technologies.IDL.IDL{PointerType = PointerKind.UniquePtr,
                                         BaseStringType = TypeOf<wchar_t>(),
                                         IndirectionLevel = 1};
        in MInterfacePointer pObjectStorage
               with Technologies.IDL.IDL
                        {PointerType = PointerKind.UniquePtr, IndirectionLevel = 1};
        in DWORD ClientImpLevel;
        in DWORD Mode;
        in DWORD Interfaces
               with Technologies.IDL.IDL
                        {Range = new RangePattern
                                     {Low = 1, High = MAX_REQUESTED_INTERFACES}};
        in array<IID> pIIDs
               with Technologies.IDL.IDL{Size_is = [Interfaces],
                                         PointerType = PointerKind.UniquePtr,
                                         IndirectionLevel = 1};
        in ushort cRequestedProtseqs
               with Technologies.IDL.IDL
                        {Range = new RangePattern
                                     {Low = 0, High = MAX_REQUESTED_PROTSEQS}};
        in array<ushort> aRequestedProtseqs
               with Technologies.IDL.IDL
                        {Size_is = [cRequestedProtseqs], Dimensions = [null]};
        out OXID pOxid with Technologies.IDL.IDL{IndirectionLevel = 1};
        out DUALSTRINGARRAY ppdsaOxidBindings
                with Technologies.IDL.IDL{IndirectionLevel = 2};
        out IPID pipidRemUnknown with Technologies.IDL.IDL{IndirectionLevel = 1};
        out MSRPCE.AuthnLevel pAuthnHint where ValidationCheckEnumValueTooManyItems(InRange<MSRPCE.AuthnLevel>(value),
            null, true, ReferenceType.Message, "DCOM", "pAuthnHint", "RemoteActivation", "Authentication Levels", "[MS-RPCE]")
            with Encoding
                {
                    Decoder = PatternDecoder<MSRPCE.AuthnLevel>, 
                    SourceConverter = DWORD2Byte, 
                    SourcePattern = TypeOf<DWORD>()
                };
        out COMVERSION pServerVersion
                with Technologies.IDL.IDL{IndirectionLevel = 1};
        out DTYP.HRESULT phr with Technologies.IDL.IDL{IndirectionLevel = 1};
        out array<MInterfacePointer> ppInterfaceData
                with Technologies.IDL.IDL
                         {Size_is = [Interfaces, null], IndirectionLevel = 2};
        out array<DTYP.HRESULT> pResults
                with Technologies.IDL.IDL
                         {Size_is = [Interfaces], IndirectionLevel = 1};
        result error_status_t ReturnValue;
        
        override string ToString()
        {
            return "RemoteActivation, Clsid: " + Clsid.ToString() + ", " +
                ORPCthis.ToString() + ORPCthat.ToString() +
                ", ReturnValue: " + ReturnValue.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 0};
}
with Technologies.IDL.IDL{Uuid = {4d9f4ab8-7d1c-11cf-861e-0020af6e7c57},
                          Version = "0.0",
                          Pointer_default = PointerKind.UniquePtr};

contract IRemoteSCMActivator
{
    accepts operation Opnum0NotUsedOnWire
    {
    }
    with Technologies.IDL.IDL{Opnum = 0};
    
    accepts operation Opnum1NotUsedOnWire
    {
    }
    with Technologies.IDL.IDL{Opnum = 1};
    
    accepts operation Opnum2NotUsedOnWire
    {
    }
    with Technologies.IDL.IDL{Opnum = 2};
    
    accepts operation RemoteGetClassObject
    {
        in optional handle_t rpc;
        in ORPCTHIS orpcthis where ValidationCheckValue(value.extensions == null, null, true, ReferenceType.Message, "DCOM", "orpcthis.extensions", "RemoteGetClassObject", "NULL", value)
            with Technologies.IDL.IDL{IndirectionLevel = 1};
        out ORPCTHAT orpcthat where ValidationCheckValue(value.extensions == null, null, true, ReferenceType.Message, "DCOM", "orpcthat.extensions", "RemoteGetClassObject", "NULL", value)
            with Technologies.IDL.IDL{IndirectionLevel = 1};
        in MInterfacePointer pActProperties
               with Technologies.IDL.IDL
                        {PointerType = PointerKind.UniquePtr, IndirectionLevel = 1};
        out MInterfacePointer ppActProperties
                with Technologies.IDL.IDL{IndirectionLevel = 2};
        result DTYP.HRESULT ReturnValue;
        
        override string ToString()
        {
            return "RemoteGetClassObject, " + orpcthis.ToString() + orpcthat.ToString() +
                ", ReturnValue: " + ReturnValue.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 3};
    
    accepts operation RemoteCreateInstance
    {
        in optional handle_t rpc;
        in ORPCTHIS orpcthis where ValidationCheckValue(value.extensions == null, null, true, ReferenceType.Message, "DCOM", "orpcthis.extensions", "RemoteCreateInstance", "NULL", value)
            with Technologies.IDL.IDL{IndirectionLevel = 1};
        out ORPCTHAT orpcthat where ValidationCheckValue(value.extensions == null, null, true, ReferenceType.Message, "DCOM", "orpcthat.extensions", "RemoteCreateInstance", "NULL", value)
            with Technologies.IDL.IDL{IndirectionLevel = 1};
        in MInterfacePointer pUnkOuter where ValidationCheckValue(value == null, null, true, ReferenceType.Message, "DCOM", "pUnkOuter", "RemoteCreateInstance", "NULL", value)
               with Technologies.IDL.IDL
                        {PointerType = PointerKind.UniquePtr, IndirectionLevel = 1};
        in MInterfacePointer pActProperties
               with Technologies.IDL.IDL
                        {PointerType = PointerKind.UniquePtr, IndirectionLevel = 1};
        out MInterfacePointer ppActProperties
                with Technologies.IDL.IDL{IndirectionLevel = 2};
        result DTYP.HRESULT ReturnValue;
        
        override string ToString()
        {
            return
                "RemoteCreateInstance, " + orpcthis.ToString() + orpcthat.ToString() +
                ", ReturnValue: " + ReturnValue.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 4};
}
with Technologies.IDL.IDL{Uuid = {000001a0-0000-0000-c000-000000000046},
                          Version = "0.0",
                          Pointer_default = PointerKind.UniquePtr};

contract IObjectExporter
{
    accepts operation ResolveOxid
    {
        in optional handle_t hRpc;
        in OXID pOxid with Technologies.IDL.IDL{IndirectionLevel = 1};
        in ushort cRequestedProtseqs;
        in array<ushort> arRequestedProtseqs
               with Technologies.IDL.IDL{Size_is = [cRequestedProtseqs],
                                         PointerType = PointerKind.RefPtr,
                                         Dimensions = [null]};
        out DUALSTRINGARRAY ppdsaOxidBindings
                with Technologies.IDL.IDL
                         {PointerType = PointerKind.RefPtr, IndirectionLevel = 2};
        out IPID pipidRemUnknown
                with Technologies.IDL.IDL
                         {PointerType = PointerKind.RefPtr, IndirectionLevel = 1};
        out MSRPCE.AuthnLevel pAuthnHint where ValidationCheckEnumValueTooManyItems(InRange<MSRPCE.AuthnLevel>(value),
            null, true, ReferenceType.Message, "DCOM", "pAuthnHint", "ResolveOxid", "Authentication Levels", "[MS-RPCE]")
            with Technologies.IDL.IDL{PointerType = PointerKind.RefPtr, IndirectionLevel = 1},
                Encoding
                {
                    Decoder = PatternDecoder<MSRPCE.AuthnLevel>, 
                    SourceConverter = DWORD2Byte, 
                    SourcePattern = TypeOf<DWORD>()
                };
        result error_status_t ReturnValue;
        
        override string ToString()
        {
            return
                "ResolveOxid, pOxid: " + pOxid.ToString() + 
                ", pipidRemUnknown: " + pipidRemUnknown.ToString() + 
                ", pAuthnHint: " + EnumToString(pAuthnHint, "MSRPCE.AuthnLevel") +
                ", ReturnValue: " + ReturnValue.ToString();
        }
    }
    with Technologies.IDL.IDL{Idempotent = true, Opnum = 0};
    
    accepts operation SimplePing
    {
        in optional handle_t hRpc;
        in SETID pSetId with Technologies.IDL.IDL{IndirectionLevel = 1};
        result error_status_t ReturnValue;
        
        override string ToString()
        {
            return
                "SimplePing, ReturnValue: " + ReturnValue.ToString();
        }
    }
    with Technologies.IDL.IDL{Idempotent = true, Opnum = 1};
    
    /*
    [idempotent] error_status_t ComplexPing
    (
    [in] handle_t hRpc,
    [in, out] SETID *pSetId,
    [in] unsigned short SequenceNum,
    [in] unsigned short cAddToSet,
    [in] unsigned short cDelFromSet,
    [in, unique, size_is(cAddToSet)] OID AddToSet[],
    [in, unique, size_is(cDelFromSet)] OID DelFromSet[],
    [out] unsigned short *pPingBackoffFactor
    );
    */
    accepts operation ComplexPing
    {
        in optional handle_t hRpc;
        in out SETID pSetId with Technologies.IDL.IDL{IndirectionLevel = 1};
        in ushort SequenceNum;
        in ushort cAddToSet;
        in ushort cDelFromSet;
        in array<OID> AddToSet
               with Technologies.IDL.IDL{Size_is = [cAddToSet],
                                         Dimensions = [null],
                                         PointerType = PointerKind.UniquePtr};
        in array<OID> DelFromSet
               with Technologies.IDL.IDL{Size_is = [cDelFromSet],
                                         Dimensions = [null], 
                                         PointerType = PointerKind.UniquePtr};
        out ushort pPingBackoffFactor
                with Technologies.IDL.IDL{IndirectionLevel = 1};
        result error_status_t ReturnValue;
        
        override string ToString()
        {
            return
                "ComplexPing, cAddToSet: " + cAddToSet.ToString() + 
                ", cDelFromSet: " + cDelFromSet.ToString() +
                ", ReturnValue: " + ReturnValue.ToString();
        }
    }
    with Technologies.IDL.IDL{Idempotent = true, Opnum = 2};
    
    accepts operation ServerAlive
    {
        in optional handle_t hRpc;
        result error_status_t ReturnValue;
        
        override string ToString()
        {
            return
                "ServerAlive, ReturnValue: " +
                ReturnValue.ToString();
        }
    }
    with Technologies.IDL.IDL{Idempotent = true, Opnum = 3};
    
    accepts operation ResolveOxid2
    {
        in optional handle_t hRpc;
        in OXID pOxid with Technologies.IDL.IDL{IndirectionLevel = 1};
        in ushort cRequestedProtseqs;
        in array<ushort> arRequestedProtseqs
               with Technologies.IDL.IDL{Size_is = [cRequestedProtseqs],
                                         PointerType = PointerKind.RefPtr,
                                         Dimensions = [null]};
        out DUALSTRINGARRAY ppdsaOxidBindings
                with Technologies.IDL.IDL
                         {PointerType = PointerKind.RefPtr, IndirectionLevel = 2};
        out IPID pipidRemUnknown
                with Technologies.IDL.IDL
                         {PointerType = PointerKind.RefPtr, IndirectionLevel = 1};
        out MSRPCE.AuthnLevel pAuthnHint where ValidationCheckEnumValueTooManyItems(InRange<MSRPCE.AuthnLevel>(value),
            null, true, ReferenceType.Message, "DCOM", "pAuthnHint", "ResolveOxid2", "Authentication Levels", "[MS-RPCE]")
            with Technologies.IDL.IDL
                        {PointerType = PointerKind.RefPtr, IndirectionLevel = 1},
                Encoding
                {
                    Decoder = PatternDecoder<MSRPCE.AuthnLevel>, 
                    SourceConverter = DWORD2Byte, 
                    SourcePattern = TypeOf<DWORD>()
                };
        out COMVERSION pComVersion
                with Technologies.IDL.IDL
                         {PointerType = PointerKind.RefPtr, IndirectionLevel = 1};
        result error_status_t ReturnValue;
        
        override string ToString()
        {
            return
                "ResolveOxid2, pOxid: " + pOxid.ToString() +
                ", pipidRemUnknown: " + pipidRemUnknown.ToString() +
                ", pAuthnHint: " + EnumToString(pAuthnHint, "MSRPCE.AuthnLevel") +
                ", pComVersion: " + pComVersion.ToString() + 
                ", ReturnValue: " + ReturnValue.ToString();
        }
    }
    with Technologies.IDL.IDL{Idempotent = true, Opnum = 4};
    
    accepts operation ServerAlive2
    {
        in optional handle_t hRpc;
        out COMVERSION pComVersion
                with Technologies.IDL.IDL
                         {PointerType = PointerKind.RefPtr, IndirectionLevel = 1};
        out DUALSTRINGARRAY ppdsaOrBindings
                with Technologies.IDL.IDL
                         {PointerType = PointerKind.RefPtr, IndirectionLevel = 2};
        out DWORD pReserved where ValidationCheckZero(value == 0, null, true, ReferenceType.Message, "DCOM", "pReserved", "ServerAlive2", value)
                with Technologies.IDL.IDL
                         {PointerType = PointerKind.RefPtr, IndirectionLevel = 1};
        result error_status_t ReturnValue;
        
        override string ToString()
        {
            return
                "ServerAlive2, pComVersion: " + pComVersion.ToString() +
                ", ReturnValue: " + ReturnValue.ToString();
        }
    }
    with Technologies.IDL.IDL{Idempotent = true, Opnum = 5};
}
with Technologies.IDL.IDL{Uuid = {99fcfec4-5260-101b-bbcb-00aa0021347a},
                          Version = "0.0",
                          Pointer_default = PointerKind.UniquePtr};

contract IUnknown
{
    accepts operation Opnum0NotUsedOnWire
    {
        result DTYP.HRESULT ReturnValue;
        
        override string ToString()
        {
            return "Opnum0NotUsedOnWire, ReturnValue: " +
                   ReturnValue.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 0};
    
    accepts operation Opnum1NotUsedOnWire
    {
        result DTYP.HRESULT ReturnValue;
        
        override string ToString()
        {
            return "Opnum1NotUsedOnWire, ReturnValue: " +
                   ReturnValue.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 1};
    
    accepts operation Opnum2NotUsedOnWire
    {
        result DTYP.HRESULT ReturnValue;
        
        override string ToString()
        {
            return "Opnum2NotUsedOnWire, ReturnValue: " +
                   ReturnValue.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 2};
}
with Technologies.IDL.IDL{Uuid = {00000000-0000-0000-c000-000000000046},
                          Object = true,
                          Pointer_default = PointerKind.UniquePtr};

contract IRemUnknown provides IUnknown
{
    accepts operation RemQueryInterface
    {
        in REFIPID ripid;
        in IDLUlong cRefs;
        in ushort cIids;
        in array<IID> iids
               with Technologies.IDL.IDL{Size_is = [cIids], IndirectionLevel = 1};
        out array<PREMQIRESULT> ppQIResults
                with Technologies.IDL.IDL
                         {Size_is = [null, cIids], IndirectionLevel = 1};
        result DTYP.HRESULT ReturnValue;
        
        override string ToString()
        {
            return
                "RemQueryInterface, ripid: " + ripid.ToString() +
                ", cRefs: " + cRefs.ToString() + ", cIids: " + cIids.ToString() +
                ", ppQIResults: " + ppQIResults.ToString() +
                ", ReturnValue: " + ReturnValue.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 3};
    
    accepts operation RemAddRef
    {
        in ushort cInterfaceRefs;
        in array<REMINTERFACEREF> InterfaceRefs
               with Technologies.IDL.IDL
                        {Size_is = [cInterfaceRefs], Dimensions = [null]};
        out array<DTYP.HRESULT> pResults
                with Technologies.IDL.IDL
                         {Size_is = [cInterfaceRefs], IndirectionLevel = 1};
        result DTYP.HRESULT ReturnValue;
        
        override string ToString()
        {
            return
                "RemAddRef, cInterfaceRefs: " + cInterfaceRefs.ToString() +
                ", pResults: " + pResults.ToString() + 
                ", ReturnValue: " + ReturnValue.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 4};
    
    accepts operation RemRelease
    {
        in ushort cInterfaceRefs;
        in array<REMINTERFACEREF> InterfaceRefs
               with Technologies.IDL.IDL
                        {Size_is = [cInterfaceRefs], Dimensions = [null]};
        result DTYP.HRESULT ReturnValue;
        
        override string ToString()
        {
            return
                "RemRelease, cInterfaceRefs: " + cInterfaceRefs.ToString() +
                ", ReturnValue: " + ReturnValue.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 5};
}
with Technologies.IDL.IDL
         {Uuid = {00000131-0000-0000-c000-000000000046}, Object = true};

contract IRemUnknown2 provides IRemUnknown
{
    accepts operation RemQueryInterface2
    {
        in REFIPID ripid;
        in ushort cIids;
        in array<IID> iids
               with Technologies.IDL.IDL{Size_is = [cIids], IndirectionLevel = 1};
        out array<DTYP.HRESULT> phr
                with Technologies.IDL.IDL{Size_is = [cIids], IndirectionLevel = 1};
        out array<PMInterfacePointer> ppMIF
                with Technologies.IDL.IDL
                         {Size_is = [cIids], IndirectionLevel = 1};
        result DTYP.HRESULT ReturnValue;
        
        override string ToString()
        {
            return
                "RemQueryInterface2, ripid: " + ripid.ToString() +
                ", ReturnValue: " + ReturnValue.ToString();
        }
    }
    with Technologies.IDL.IDL{Opnum = 6};
}
with Technologies.IDL.IDL
         {Uuid = {00000143-0000-0000-c000-000000000046}, Object = true};

typedef CLSID = GUID;
typedef IID = GUID;
typedef ID = uhyper;
typedef OXID = uhyper;

typedef OID = uhyper;
typedef SETID = uhyper;
typedef IPID = GUID;
typedef CID = GUID;

pattern REFGUID = GUID with IDL{IndirectionLevel = 1, DoNotGenerate = true};
pattern REFIID = IID with IDL{IndirectionLevel = 1, DoNotGenerate = true};

typedef REFIPID = REFGUID;
         
typedef COMVERSION = tagCOMVERSION;

type tagCOMVERSION
{
    ushort MajorVersion;
    ushort MinorVersion;
    
    override string ToString()
    {
        return MajorVersion.ToString() + "." + MinorVersion.ToString();
    }
}

typedef ORPC_EXTENT = tagORPC_EXTENT;

type tagORPC_EXTENT
{
    GUID id;
    IDLUlong size;
    (OBJREF | ContextORPCExtension | binary) data
        with Technologies.IDL.IDL{Size_is = [(size+7)&(~7)], Dimensions = [null]},
            Encoding{Decoder = dataDecoder, SourcePattern = TypeOf<array<byte>>()};
    
    optional (OBJREF | ContextORPCExtension | binary) dataDecoder(binary bin)
    {
        optional (OBJREF | ContextORPCExtension | binary) res = nothing;
        switch (id)
        {
            case CLSID_ERROR_EXTENSION =>
                res = BinaryDecoder<OBJREF>(bin);
            case CLSID_CONTEXT_EXTENSION =>
                res = BinaryDecoder<ContextORPCExtension>(bin);
            default =>
                ;
        }
        
        if (res == nothing)
            return bin;
        else
            return res;
        }
}

typedef ORPC_EXTENT_ARRAY = tagORPC_EXTENT_ARRAY;

type tagORPC_EXTENT_ARRAY
{
    IDLUlong size;
    IDLUlong reserved where ValidationCheckZero(value == 0, null, true, ReferenceType.Type, "DCOM", "reserved", "tagORPC_EXTENT_ARRAY", value);
    array<ORPC_EXTENT> extent
        with Technologies.IDL.IDL{Size_is = [(size+1)&(~1), null],
                                  PointerType = PointerKind.UniquePtr,
                                  IndirectionLevel = 2};
}

typedef ORPCTHIS = tagORPCTHIS;

type tagORPCTHIS
{
    COMVERSION version;
    IDLUlong @flags;
    IDLUlong reserved1 where ValidationCheckZero(value == 0, null, true, ReferenceType.Type, "DCOM", "reserved1", "tagORPCTHIS", value);
    IID cid;
    ORPC_EXTENT_ARRAY extensions
        with Technologies.IDL.IDL
                 {PointerType = PointerKind.UniquePtr, IndirectionLevel = 1};
                 
    override string ToString()
    {
        return "version: " + version.ToString() + ", cid: " + cid.ToString() + (extensions == null ? "" : (", extensions: " + extensions.ToString()));
    }
}

typedef ORPCTHAT = tagORPCTHAT;

type tagORPCTHAT
{
    IDLUlong @flags;
    ORPC_EXTENT_ARRAY extensions
        with Technologies.IDL.IDL
                 {PointerType = PointerKind.UniquePtr, IndirectionLevel = 1};

    override string ToString()
    {
        return extensions == null ? "" : (", extensions: " + extensions.ToString());
    }
}

type DUALSTRINGARRAY_PacketVersion
{
    ushort wNumEntries;
    ushort wSecurityOffset;
    array<STRINGBINDING> StringBinding with BinaryEncoding{WidthForComposedType = (wSecurityOffset - 1) * 16};
    ushort nullterm1 where ValidationCheckZero(value == 0, null, true, ReferenceType.Type, "DCOM", "nullterm1", "DUALSTRINGARRAY_PacketVersion", value);
    array<SECURITYBINDING> SecBinding with BinaryEncoding{WidthForComposedType = (wNumEntries - 1 - wSecurityOffset) * 16};
    ushort nullterm2 where ValidationCheckZero(value == 0, null, true, ReferenceType.Type, "DCOM", "nullterm2", "DUALSTRINGARRAY_PacketVersion", value);
} with Encoding{EncodingKind = EncodingKind.Binary},
    IDL{DoNotGenerate = true};
    
type STRINGBINDING
{
    ProtocolSequenceIdentifier wTowerId where ValidationCheckEnumValueTooManyItems(InRange<ProtocolSequenceIdentifier>(value) || value == 0,
        null, true, ReferenceType.Type, "DCOM", "wTowerId", "STRINGBINDING", "STRINGBINDING", "[MS-DCOM]")
        with Encoding{Decoder = PatternDecoder<ProtocolSequenceIdentifier>, SourceConverter = Ushort2Byte, SourcePattern = TypeOf<ushort>()};
    optional [|wTowerId != 0|] string aNetworkAddr;
} with Encoding{EncodingKind = EncodingKind.Binary},
    IDL{DoNotGenerate = true};

// C706 Appendix I table I-2
pattern ProtocolSequenceIdentifier = enum byte
{
    OSI_TP4 = 0x05,
    OSI_CLNS = 0x06,
    DOD_TCP = 0x07,
    DOD_UDP = 0x08,
    DOD_IP = 0x09,
    RPC_connectionless_protocol = 0x0A,
    RPC_connection_oriented_protocol = 0x0B,
    DNA_Session_Control = 0x02,
    DNA_Session_Control_V3 = 0x03,
    DNA_NSP_Transport = 0x04,
    Named_Pipes = 0x10,
    MicrosoftNetBIOS = 0x11,
    NetBEUI = 0x12,
    Netware_SPX = 0x13,
    Netware_IPX = 0x14,
    Appletalk_Stream = 0x16,
    Appletalk_Datagram = 0x17,
    Appletalk = 0x18,
    NetBIOS_CL_over_all_protocols = 0x19,
    VINES_SPP = 0x1A,
    VINES_IPC = 0x1B,
    StreetTalk = 0x1C,
    Unix_Domain_socket = 0x20,
    @null = 0x21,
    NetBIOS = 0x22,
    ...
} with IDL{DoNotGenerate = true};

type SECURITYBINDING
{
    MSRPCE.AuthnType wAuthnSvc where ValidationCheckEnumValueTooManyItems(InRange<MSRPCE.AuthnType>(value),
        null, true, ReferenceType.Type, "DCOM", "wAuthnSvc", "SECURITYBINDING", "SECURITYBINDING", "[MS-DCOM]")
        with Encoding{Decoder = PatternDecoder<MSRPCE.AuthnType>, SourceConverter = Ushort2Byte, SourcePattern = TypeOf<ushort>()};
    optional [|wAuthnSvc != AuthnType.RpcCAuthnNone|] ushort Reserved where ValidationCheckValue(value == 0xFFFF, null, true, ReferenceType.Type, "DCOM", "Reserved", "SECURITYBINDING", "0xFFFF", value);
    optional [|wAuthnSvc != AuthnType.RpcCAuthnNone|] string aPrincName;
} with Encoding{EncodingKind = EncodingKind.Binary},
    IDL{DoNotGenerate = true};
    
typedef DUALSTRINGARRAY = tagDUALSTRINGARRAY;

type tagDUALSTRINGARRAY
{
    ushort wNumEntries;
    ushort wSecurityOffset;
    tagDUALSTRINGARRAY_aStringArray aStringArray
        with Technologies.IDL.IDL{Size_is = [wNumEntries], Dimensions = [null]},
            Encoding
            {
                Decoder = aStringArrayDecoder,
                SourceConverter = ConvertArrayUshort2BinaryLittleEndian,
                SourcePattern = TypeOf<array<ushort>>()
            };
            
    //Future Reference: Remove this method after bug#70991 fixed
    optional tagDUALSTRINGARRAY_aStringArray aStringArrayDecoder(stream s)
    {
        return BinaryDecoder<tagDUALSTRINGARRAY_aStringArray[wNumEntries, wSecurityOffset]>(s);
    }
}

// Type for decoding the field aStringArray
type tagDUALSTRINGARRAY_aStringArray[ushort wNumEntries, ushort wSecurityOffset]
{
    array<STRINGBINDING> StringBinding with BinaryEncoding{WidthForComposedType = (wSecurityOffset - 1) * 16};
    ushort nullterm1;
    array<SECURITYBINDING> SecBinding with BinaryEncoding{WidthForComposedType = (wNumEntries - 1 - wSecurityOffset) * 16};
    ushort nullterm2;
} with Encoding{EncodingKind = EncodingKind.Binary},
    IDL{DoNotGenerate = true};

type EnvoyContext
{
    ushort MajorVersion where ValidationCheckValue(value == 0x0001, null, true, ReferenceType.Type, "DCOM", "MajorVersion", "EnvoyContext", "0x0001", value);
    ushort MinVersion where ValidationCheckValue(value == 0x0001, null, true, ReferenceType.Type, "DCOM", "MinVersion", "EnvoyContext", "0x0001", value);
    guid ContextId;
    EnvoyContext_Flags Flags where ValidationCheckEnumValue(InRange<EnvoyContext_Flags>(value),
        null, true, ReferenceType.Type, "DCOM", "Flags", "EnvoyContext", "0x00000002", value);
    uint Reserved where ValidationCheckZero(value == 0, null, true, ReferenceType.Type, "DCOM", "Reserved", "EnvoyContext", value);
    uint dwNumExtents where ValidationCheckZero(value == 0, null, true, ReferenceType.Type, "DCOM", "dwNumExtents", "EnvoyContext", value);
    uint cbExtents where ValidationCheckZero(value == 0, null, true, ReferenceType.Type, "DCOM", "cbExtents", "EnvoyContext", value);
    MSHLFLAGS MshlFlags;
    uint Count;
    uint Frozen where ValidationCheckValue(value == 1, null, true, ReferenceType.Type, "DCOM", "Frozen", "EnvoyContext", "TRUE(1)", value)
        with DisplayInfo{ToText = (any input) => ((input as uint) != 0).ToString()};
    optional [|Count > 0|] array<PROPMARSHALHEADER> PropMarshalHeader with BinaryEncoding{Length = Count};
} with Encoding{EncodingKind = EncodingKind.Binary},
    IDL{DoNotGenerate = true};
    
pattern EnvoyContext_Flags = enum uint
{
    CTXMSHLFLAGS_BYVAL = 0x00000002,
    ...
} with IDL{DoNotGenerate = true};

// Windows DCOM clients set this field to a value from the MSHLFLAGS enumeration
pattern MSHLFLAGS = enum uint
{ 
    MSHLFLAGS_NORMAL       = 0,
    MSHLFLAGS_TABLESTRONG  = 1,
    MSHLFLAGS_TABLEWEAK    = 2,
    MSHLFLAGS_NOPING       = 4,
    ...
} with IDL{DoNotGenerate = true};

type PROPMARSHALHEADER
{
    guid clsid;
    guid policyId;
    tagCPFLAGS @flags where ValidationCheckEnumValue(InRange<tagCPFLAGS>(value),
        null, true, ReferenceType.Type, "DCOM", "flags", "PROPMARSHALHEADER", "0x00000001, 0x00000002, 0x00000004", value);
    uint cb;
    ([|clsid == GUID_NULL|] OBJREF
    | binary) ctxProperty with BinaryEncoding{WidthForComposedType = (cb * 8) as int};
} with Encoding{EncodingKind = EncodingKind.Binary},
    IDL{DoNotGenerate = true};

pattern tagCPFLAGS = enum
{
    CPFLAG_PROPAGATE = 0x1,
    CPFLAG_EXPOSE = 0x2,
    CPFLAG_ENVOY = 0x4,
    ...
};

typedef MInterfacePointer = tagMInterfacePointer;

type tagMInterfacePointer
{
    IDLUlong ulCntData;
    OBJREF abData
        with Technologies.IDL.IDL{Size_is = [ulCntData], Dimensions = [null]},
            Encoding{
                     Decoder = BinaryDecoder<OBJREF>,
                     SourcePattern = TypeOf<array<byte>>()
                    };
}

typedef PMInterfacePointer = MInterfacePointer with IDL{IndirectionLevel = 1, PointerType = PointerKind.UniquePtr};

typedef ErrorObjectData = tagErrorObjectData;

type tagErrorObjectData
{
    DWORD dwVersion;
    DWORD dwHelpContext;
    IID iid;
    string pszSource with IDL{PointerType = PointerKind.UniquePtr,
                                         BaseStringType = TypeOf<wchar_t>(),
                                         IndirectionLevel = 1};
    string pszDescription with IDL{PointerType = PointerKind.UniquePtr,
                                         BaseStringType = TypeOf<wchar_t>(),
                                         IndirectionLevel = 1};
    string pszHelpFile with IDL{PointerType = PointerKind.UniquePtr,
                                         BaseStringType = TypeOf<wchar_t>(),
                                         IndirectionLevel = 1};
}

type OBJREF
{
    uint signature where ValidationCheckValue(value == 0x574F454D, null, true, ReferenceType.Type, "DCOM", "signature", "OBJREF", "0x574F454D", value);
    OBJREF_flags @flags where ValidationCheckEnumValue(InRange<OBJREF_flags>(value),
        null, true, ReferenceType.Type, "DCOM", "flags", "OBJREF", "0x00000001, 0x00000002, 0x00000004, 0x00000008", value);
    guid iid;
    ([|@flags is OBJREF_flags.OBJREF_STANDARD|] OBJREF_STANDARD
    | [|@flags is OBJREF_flags.OBJREF_HANDLER|] OBJREF_HANDLER
    | [|@flags is OBJREF_flags.OBJREF_CUSTOM|] OBJREF_CUSTOM
    | [|@flags is OBJREF_flags.OBJREF_EXTENDED|] OBJREF_EXTENDED
    | binary) u_objref;
} with Encoding{EncodingKind = EncodingKind.Binary},
    IDL{DoNotGenerate = true};

pattern OBJREF_flags = enum uint
{
    OBJREF_STANDARD = 0x00000001,
    OBJREF_HANDLER = 0x00000002,
    OBJREF_CUSTOM = 0x00000004,
    OBJREF_EXTENDED = 0x00000008,
    ...
} with IDL{DoNotGenerate = true};

type STDOBJREF_PacketVersion
{
    STDOBJREF_flags @flags;
    uint cPublicRefs;
    ulong oxid;
    ulong oid;
    guid ipid;
} with Encoding{EncodingKind = EncodingKind.Binary},
    IDL{DoNotGenerate = true};

pattern STDOBJREF_flags = enum uint
{
    SORF_PING = 0x00000000,
    SORF_NOPING = 0x00001000,
    ...
} with IDL{DoNotGenerate = true};
    
typedef STDOBJREF = tagSTDOBJREF;

type tagSTDOBJREF
{
    STDOBJREF_flags @flags with Encoding{Decoder = PatternDecoder<STDOBJREF_flags>, SourcePattern = TypeOf<IDLUlong>()};
    IDLUlong cPublicRefs;
    OXID oxid;
    OID oid;
    IPID ipid;
}

type OBJREF_STANDARD
{
    STDOBJREF_PacketVersion std;
    DUALSTRINGARRAY_PacketVersion saResAddr;
} with Encoding{EncodingKind = EncodingKind.Binary},
    IDL{DoNotGenerate = true};
    
type OBJREF_HANDLER
{
    STDOBJREF_PacketVersion std;
    guid clsid;
    DUALSTRINGARRAY_PacketVersion saResAddr;
} with Encoding{EncodingKind = EncodingKind.Binary},
    IDL{DoNotGenerate = true};
    
type OBJREF_CUSTOM
{
    guid clsid;
    uint cbExtension where ValidationCheckZero(value == 0, null, true, ReferenceType.Type, "DCOM", "cbExtension", "OBJREF_CUSTOM", value);
    uint reserved;
    ([|clsid == CLSID_ContextMarshaler|] EnvoyContext
    | [|clsid == CLSID_ErrorObject|] CustomMarshaledErrorInformationFormat
    | [|clsid == CLSID_ActivationPropertiesIn || clsid == CLSID_ActivationPropertiesOut|] ActivationPropertiesBLOB
    | binary) pObjectData;
} with Encoding{EncodingKind = EncodingKind.Binary},
    IDL{DoNotGenerate = true};

type OBJREF_EXTENDED
{
    STDOBJREF_PacketVersion std;
    uint Signature1 where ValidationCheckValue(value == 0x4E535956, null, true, ReferenceType.Type, "DCOM", "Signature1", "OBJREF_EXTENDED", "0x4E535956", value);
    DUALSTRINGARRAY_PacketVersion saResAddr;
    uint nElms where ValidationCheckValue(value == 1, null, true, ReferenceType.Type, "DCOM", "nElms", "OBJREF_EXTENDED", "1", value);
    uint Signature2 where ValidationCheckValue(value == 0x4E535956, null, true, ReferenceType.Type, "DCOM", "Signature2", "OBJREF_EXTENDED", "0x4E535956", value);
    array<DATAELEMENT> ElmArray with BinaryEncoding{Length = nElms};
} with Encoding{EncodingKind = EncodingKind.Binary},
    IDL{DoNotGenerate = true};
    
type DATAELEMENT
{
    guid dataID;
    uint cbSize where ValidationCheckGreaterThan(value > 0, null, true, ReferenceType.Type, "DCOM", "cbSize", "DATAELEMENT", "0", value);
    uint cbRounded;
    EnvoyContext Data with BinaryEncoding{WidthForComposedType = (cbSize * 8) as int};
    binary Padding with BinaryEncoding{Length = cbRounded - cbSize};
} with Encoding{EncodingKind = EncodingKind.Binary},
    IDL{DoNotGenerate = true};
    
type CustomMarshaledErrorInformationFormat
{
    uint dwVersion where ValidationCheckZero(value == 0, null, true, ReferenceType.Type, "DCOM", "dwVersion", "CustomMarshaledErrorInformationFormat", value);
    uint dwHelpContext;
    guid idd;
    uint dwSourceSignature;
    optional [|dwSourceSignature == 0xFFFFFFFF|] ErrorInfoString Source;
    uint dwDescriptionSignature;
    optional [|dwDescriptionSignature == 0xFFFFFFFF|] ErrorInfoString Description;
    uint dwHelpFileSignature;
    optional [|dwHelpFileSignature == 0xFFFFFFFF|] ErrorInfoString HelpFile;
} with Encoding{EncodingKind = EncodingKind.Binary},
    IDL{DoNotGenerate = true};
    
type ErrorInfoString
{
    uint dwMax;
    uint dwOffset where ValidationCheckZero(value == 0, null, true, ReferenceType.Type, "DCOM", "dwOffset", "ErrorInfoString", value);
    uint dwActual;
    string Name with BinaryEncoding{Length = (dwMax - 1)};
} with Encoding{EncodingKind = EncodingKind.Binary},
    IDL{DoNotGenerate = true};
    
type ContextORPCExtension
{
    uint Signature where ValidationCheckValue(value == 0x414E554B, null, true, ReferenceType.Type, "DCOM", "Signature", "ContextORPCExtension", "0x414E554B", value);
    uint Version where ValidationCheckValue(value == 0x00010000, null, true, ReferenceType.Type, "DCOM", "Version", "ContextORPCExtension", "0x00010000", value);
    uint cPolicies;
    uint cbBuffer;
    DTYP.HRESULT hr where ValidationCheckZero(value == 0, null, true, ReferenceType.Type, "DCOM", "hr", "ContextORPCExtension", value);
    DTYP.HRESULT hrServer;
    uint reserved where ValidationCheckZero(value == 0, null, true, ReferenceType.Type, "DCOM", "reserved", "ContextORPCExtension", value);
    optional [|cPolicies > 0|] array<EntryHeader> EntryHeader with BinaryEncoding{Length = cPolicies};
    optional [|cPolicies > 0|] array<binary> PolicyData with Encoding{Decoder = PolicyDataDecoder};
    
    optional array<binary> PolicyDataDecoder(stream s)
    {
        array<binary> polData = [];
        array<EntryHeader> arrayEH = this.EntryHeader as array<EntryHeader>;
        foreach (EntryHeader eh in arrayEH)
        {
            polData += [(BinaryDecoder<Blob[eh.cbEHBuffer]>(s) as Blob).Data];
        }
        return polData;
    }
} with Encoding{EncodingKind = EncodingKind.Binary},
    IDL{DoNotGenerate = true};
    
type EntryHeader
{
    uint Signature where ValidationCheckValue(value == 0x494E414E, null, true, ReferenceType.Type, "DCOM", "Signature", "EntryHeader", "0x494E414E", value);
    uint cbEHBuffer;
    uint cbSize;
    uint reserved where ValidationCheckZero(value == 0, null, true, ReferenceType.Type, "DCOM", "reserved", "EntryHeader", value);
    guid policyID;
} with Encoding{EncodingKind = EncodingKind.Binary},
    IDL{DoNotGenerate = true};
    
type ActivationPropertiesBLOB
{
    uint dwSize;
    uint dwReserved where ValidationCheckZero(value == 0, null, true, ReferenceType.Type, "DCOM", "dwReserved", "ActivationPropertiesBLOB", value);
    CustomHeader CustomHeader with Encoding{Decoder = NDRTypeSerializationV1Decoder<CustomHeader>};
    array<Property> Property with Encoding{Decoder = PropertyDecoder};
    
    optional T NDRTypeSerializationV1Decoder<T>(stream s)
    {
        return NDRTypeSerializationVersion1Decoder<T>(s, true);
    }
    
    optional array<Property> PropertyDecoder(stream s)
    {
        array<Property> properties= [];
        optional Property prop;
        guid gid;
        binary bin;
        for (int i = 0; i < this.CustomHeader.cIfs; i++)
        {
            gid = this.CustomHeader.pclsid[i];
            bin = (BinaryDecoder<Blob[this.CustomHeader.pSizes[i]]>(s) as Blob).Data;
            switch (gid)
            {
                case CLSID_InstantiationInfo =>
                    prop = NDRTypeSerializationV1Decoder<InstantiationInfoData>(bin);
                case CLSID_SpecialSystemProperties =>
                    prop = NDRTypeSerializationV1Decoder<SpecialPropertiesData>(bin);
                    if (prop == nothing)
                    {
                        prop = NDRTypeSerializationV1Decoder<SpecialPropertiesData_Alternate>(bin);
                    }
                case CLSID_InstanceInfo =>
                    prop = NDRTypeSerializationV1Decoder<InstanceInfoData>(bin);
                case CLSID_ScmRequestInfo =>
                    prop = NDRTypeSerializationV1Decoder<ScmRequestInfoData>(bin);
                case CLSID_ActivationContextInfo =>
                    prop = NDRTypeSerializationV1Decoder<ActivationContextInfoData>(bin);
                case CLSID_ServerLocationInfo =>
                    prop = NDRTypeSerializationV1Decoder<LocationInfoData>(bin);
                case CLSID_SecurityInfo =>
                    prop = NDRTypeSerializationV1Decoder<SecurityInfoData>(bin);
                case CLSID_ScmReplyInfo =>
                    prop = NDRTypeSerializationV1Decoder<ScmReplyInfoData>(bin);
                case CLSID_PropsOutInfo =>
                    prop = NDRTypeSerializationV1Decoder<PropsOutInfo>(bin);
                default =>
                    prop = nothing;
            }
            
            if (prop == nothing)
            {
                ValidationCheck(false, null, DiagnosisLevel.Warning, () => Format(DCOM_DECODING_PROPERTY_FAILURE, gid.ToString()));
                prop = bin;
            }
            
            properties += [prop];
        }
        
        return properties;
    }
} with Encoding{EncodingKind = EncodingKind.Binary},
    IDL{DoNotGenerate = true};

pattern Property = InstantiationInfoData | SpecialPropertiesData | InstanceInfoData | ScmRequestInfoData | ActivationContextInfoData 
                    | LocationInfoData | SecurityInfoData | ScmReplyInfoData | PropsOutInfo | binary;
    
typedef REMQIRESULT = tagREMQIRESULT;

type tagREMQIRESULT
{
    DTYP.HRESULT hResult;
    STDOBJREF std;
}

typedef REMINTERFACEREF = tagREMINTERFACEREF;

type tagREMINTERFACEREF
{
    IPID ipid;
    IDLUlong cPublicRefs;
    IDLUlong cPrivateRefs;
}

typedef PREMQIRESULT = REMQIRESULT with IDL{IndirectionLevel = 1};
typedef PMInterfacePointerInternal = MInterfacePointer with IDL{IndirectionLevel = 1};

const IDLUlong MIN_ACTPROP_LIMIT = 1;
const IDLUlong MAX_ACTPROP_LIMIT = 10;

type COSERVERINFO
{
    DWORD dwReserved1 where ValidationCheckZero(value == 0, null, true, ReferenceType.Type, "DCOM", "dwReserved1", "COSERVERINFO", value);
    string pwszName with IDL{BaseStringType = TypeOf<wchar_t>(), IndirectionLevel = 1};
    DWORD? pdwReserved where ValidationCheckValue(value == null, null, true, ReferenceType.Type, "DCOM", "pdwReserved", "COSERVERINFO", "NULL", value)
        with IDL{IndirectionLevel = 1};
    DWORD dwReserved2 where ValidationCheckZero(value == 0, null, true, ReferenceType.Type, "DCOM", "dwReserved2", "COSERVERINFO", value);
}

type customREMOTE_REQUEST_SCM_INFO
{
    DWORD ClientImpLevel;
    ushort cRequestedProtseqs where ValidationCheckGreaterThanOrEqualTo(value >= 1,
        null, true, ReferenceType.Type, "DCOM", "cRequestedProtseqs", "customREMOTE_REQUEST_SCM_INFO", "1", value)
        with IDL{Range = new RangePattern{Low = 0, High = MAX_REQUESTED_PROTSEQS}};
    array<ushort> pRequestedProtseqs with IDL{Size_is = [cRequestedProtseqs], IndirectionLevel = 1};
}

type customREMOTE_REPLY_SCM_INFO
{
    OXID Oxid;
    DUALSTRINGARRAY pdsaOxidBindings with IDL{IndirectionLevel = 1};
    IPID ipidRemUnknown;
    MSRPCE.AuthnLevel authnHint where ValidationCheckEnumValueTooManyItems(InRange<MSRPCE.AuthnLevel>(value),
        null, true, ReferenceType.Type, "DCOM", "authnHint", "customREMOTE_REPLY_SCM_INFO", "Authentication Levels", "[MS-RPCE]")
    with Encoding
        {
            Decoder = PatternDecoder<MSRPCE.AuthnLevel>, 
            SourceConverter = DWORD2Byte, 
            SourcePattern = TypeOf<DWORD>()
        };
    COMVERSION serverVersion;
}

typedef InstantiationInfoData = tagInstantiationInfoData;

type tagInstantiationInfoData
{
    CLSID classId;
    DWORD classCtx;
    tagInstantiationInfoData_actvflags actvflags where ValidationCheckCombinationValueIncludeZero(InRange<tagInstantiationInfoData_actvflags>(value),
        null, true, ReferenceType.Type, "DCOM", "actvflags", "tagInstantiationInfoData", "0x00000002, 0x00000004, 0x00000008, 0x00000020", value)
        with Encoding{Decoder = PatternDecoder<tagInstantiationInfoData_actvflags>, SourcePattern = TypeOf<DWORD>()};
    IDLLong fIsSurrogate where ValidationCheckValue(value == 0, null, true, ReferenceType.Type, "DCOM", "fIsSurrogate", "tagInstantiationInfoData", "FALSE(0)", value)
        with DisplayInfo{ToText = (any input) => ((input as IDLLong) != 0).ToString()};
    DWORD cIID with IDL{Range = new RangePattern
                                    {Low = 1, High = MAX_REQUESTED_INTERFACES}};
    DWORD instFlag where ValidationCheckZero(value == 0, null, true, ReferenceType.Type, "DCOM", "instFlag", "tagInstantiationInfoData", value);
    array<IID> pIID with IDL{Size_is = [cIID], IndirectionLevel = 1};
    DWORD thisSize;
    COMVERSION clientCOMVersion;
}

pattern tagInstantiationInfoData_actvflags = flags DWORD
{
    ACTVFLAGS_DISABLE_AAA = 0x00000002,
    ACTVFLAGS_ACTIVATE_32_BIT_SERVER = 0x00000004,
    ACTVFLAGS_ACTIVATE_64_BIT_SERVER = 0x00000008,
    ACTVFLAGS_NO_FAILURE_LOG = 0x00000020,
} with IDL{DoNotGenerate = true};

typedef LocationInfoData = tagLocationInfoData;

type tagLocationInfoData
{
    string machineName where ValidationCheckValue(value == null, null, true, ReferenceType.Type, "DCOM", "machineName", "tagLocationInfoData", "NULL", value)
        with IDL{BaseStringType = TypeOf<wchar_t>(),
                    IndirectionLevel = 1};
    DWORD processId where ValidationCheckZero(value == 0, null, true, ReferenceType.Type, "DCOM", "processId", "tagLocationInfoData", value);
    DWORD apartmentId where ValidationCheckZero(value == 0, null, true, ReferenceType.Type, "DCOM", "apartmentId", "tagLocationInfoData", value);
    DWORD contextId where ValidationCheckZero(value == 0, null, true, ReferenceType.Type, "DCOM", "contextId", "tagLocationInfoData", value);
}

typedef ActivationContextInfoData = tagActivationContextInfoData;

type tagActivationContextInfoData
{
    IDLLong clientOK where ValidationCheckValue(value == 0, null, true, ReferenceType.Type, "DCOM", "clientOK", "tagActivationContextInfoData", "FALSE(0)", value)
        with DisplayInfo{ToText = (any input) => ((input as IDLLong) != 0).ToString()};
    IDLLong bReserved1 where ValidationCheckValue(value == 0, null, true, ReferenceType.Type, "DCOM", "clientOK", "tagActivationContextInfoData", "FALSE(0)", value)
        with DisplayInfo{ToText = (any input) => ((input as IDLLong) != 0).ToString()};
    DWORD dwReserved1 where ValidationCheckZero(value == 0, null, true, ReferenceType.Type, "DCOM", "dwReserved1", "tagActivationContextInfoData", value);
    DWORD dwReserved2 where ValidationCheckZero(value == 0, null, true, ReferenceType.Type, "DCOM", "dwReserved2", "tagActivationContextInfoData", value);
    MInterfacePointer pIFDClientCtx with IDL{IndirectionLevel = 1};
    MInterfacePointer pIFDPrototypeCtx with IDL{IndirectionLevel = 1};
}

typedef CustomHeader = tagCustomHeader;

type tagCustomHeader
{
    DWORD totalSize;
    DWORD headerSize;
    DWORD dwReserved where ValidationCheckZero(value == 0, null, true, ReferenceType.Type, "DCOM", "dwReserved", "tagCustomHeader", value);
    DWORD destCtx;
    DWORD cIfs with IDL{Range = new RangePattern
                                    {Low = MIN_ACTPROP_LIMIT as int, High = MAX_ACTPROP_LIMIT as int}};
    CLSID classInfoClsid where ValidationCheckValue(value == GUID_NULL, null, true, ReferenceType.Type, "DCOM", "classInfoClsid", "tagCustomHeader", "GUID_NULL", value);
    array<CLSID> pclsid with IDL{Size_is = [cIfs], IndirectionLevel = 1};
    array<DWORD> pSizes with IDL{Size_is = [cIfs], IndirectionLevel = 1};
    DWORD? pdwReserved where ValidationCheckValue(value == null, null, true, ReferenceType.Type, "DCOM", "pdwReserved", "tagCustomHeader", "NULL", value)
        with IDL{IndirectionLevel = 1};
}

typedef PropsOutInfo = tagPropsOutInfo;

type tagPropsOutInfo
{
    DWORD cIfs with IDL{Range = new RangePattern
                                    {Low = 1, High = MAX_REQUESTED_INTERFACES}};
    array<IID> piid with IDL{Size_is = [cIfs], IndirectionLevel = 1};
    array<DTYP.HRESULT> phresults with IDL{Size_is = [cIfs], IndirectionLevel = 1};
    array<MInterfacePointer> ppIntfData with IDL{Size_is = [cIfs, null], IndirectionLevel = 2};
}

typedef SecurityInfoData = tagSecurityInfoData;

type tagSecurityInfoData
{
    DWORD dwAuthnFlags where ValidationCheckZero(value == 0, null, true, ReferenceType.Type, "DCOM", "dwAuthnFlags", "tagSecurityInfoData", value);
    COSERVERINFO pServerInfo with IDL{IndirectionLevel = 1};
    DWORD? pdwReserved where ValidationCheckValue(value == null, null, true, ReferenceType.Type, "DCOM", "pdwReserved", "tagSecurityInfoData", "NULL", value)
        with IDL{IndirectionLevel = 1};
}

typedef ScmRequestInfoData = tagScmRequestInfoData;

type tagScmRequestInfoData
{
    DWORD? pdwReserved where ValidationCheckValue(value == null, null, true, ReferenceType.Type, "DCOM", "pdwReserved", "tagScmRequestInfoData", "NULL", value)
        with IDL{IndirectionLevel = 1};
    customREMOTE_REQUEST_SCM_INFO remoteRequest with IDL{IndirectionLevel = 1};
}

typedef ScmReplyInfoData = tagScmReplyInfoData;

type tagScmReplyInfoData
{
    DWORD? pdwReserved where ValidationCheckValue(value == null, null, true, ReferenceType.Type, "DCOM", "pdwReserved", "tagScmReplyInfoData", "NULL", value)
        with IDL{IndirectionLevel = 1};
    customREMOTE_REPLY_SCM_INFO remoteReply with IDL{IndirectionLevel = 1};
}

typedef InstanceInfoData = tagInstanceInfoData;

type tagInstanceInfoData
{
    string fileName with IDL{BaseStringType = TypeOf<wchar_t>(),
                                         IndirectionLevel = 1};
    DWORD mode;
    MInterfacePointer ifdROT where ValidationCheckValue(value == null, null, true, ReferenceType.Type, "DCOM", "ifdROT", "tagInstanceInfoData", "NULL", value)
        with IDL{IndirectionLevel = 1};
    MInterfacePointer ifdStg with IDL{IndirectionLevel = 1};
}

pattern SPD_FLAGS = enum
{
    SPD_FLAG_USE_CONSOLE_SESSION   = 0x00000001,
    SPD_FLAG_USE_DEFAULT_AUTHN_LVL = 0x00000002
};

typedef SpecialPropertiesData = tagSpecialPropertiesData;

type tagSpecialPropertiesData
{
    IDLUlong dwSessionId;
    IDLLong fRemoteThisSessionId;
    IDLLong fClientImpersonating where ValidationCheckValue(value == 0, null, true, ReferenceType.Type, "DCOM", "fClientImpersonating", "tagSpecialPropertiesData", "FALSE(0)", value)
        with DisplayInfo{ToText = (any input) => ((input as IDLLong) != 0).ToString()};
    IDLLong fPartitionIDPresent;
    MSRPCE.AuthnLevel dwDefaultAuthnLvl where ValidationCheckEnumValueTooManyItems(InRange<MSRPCE.AuthnLevel>(value),
        null, true, ReferenceType.Type, "DCOM", "dwDefaultAuthnLvl", "tagSpecialPropertiesData", "Authentication Levels", "[MS-RPCE]")
        with Encoding
            {
                Decoder = PatternDecoder<MSRPCE.AuthnLevel>, 
                SourceConverter = DWORD2Byte, 
                SourcePattern = TypeOf<DWORD>()
            };
    GUID guidPartition;
    DWORD dwPRTFlags where ValidationCheckZero(value == 0, null, true, ReferenceType.Type, "DCOM", "dwPRTFlags", "tagSpecialPropertiesData", value);
    DWORD dwOrigClsctx;
    tagSpecialPropertiesData_dwFlags dwFlags where ValidationCheckCombinationValueIncludeZero(InRange<tagSpecialPropertiesData_dwFlags>(value),
        null, true, ReferenceType.Type, "DCOM", "dwFlags", "tagSpecialPropertiesData", "0x00000001", value)
        with Encoding{Decoder = PatternDecoder<tagSpecialPropertiesData_dwFlags>, SourcePattern = TypeOf<DWORD>()};
    DWORD Reserved1 where ValidationCheckZero(value == 0, null, true, ReferenceType.Type, "DCOM", "Reserved1", "tagSpecialPropertiesData", value);
    __uint64 Reserved2 where ValidationCheckZero(value == 0, null, true, ReferenceType.Type, "DCOM", "Reserved2", "tagSpecialPropertiesData", value);
    array<DWORD> Reserved3 with IDL{Dimensions = [5]}; 
}

// TODO: TD bug?
pattern tagSpecialPropertiesData_dwFlags = flags DWORD
{
    SPD_FLAG_USE_CONSOLE_SESSION = 0x00000001,
    SPD_FLAG_USE_DEFAULT_AUTHN_LVL = 0x00000002
} with IDL{DoNotGenerate = true};

typedef SpecialPropertiesData_Alternate = tagSpecialPropertiesData_Alternate;

type tagSpecialPropertiesData_Alternate
{
    IDLUlong dwSessionId;
    IDLLong fRemoteThisSessionId;
    IDLLong fClientImpersonating where ValidationCheckValue(value == 0, null, true, ReferenceType.Type, "DCOM", "fClientImpersonating", "tagSpecialPropertiesData_Alternate", "FALSE(0)", value)
        with DisplayInfo{ToText = (any input) => ((input as IDLLong) != 0).ToString()};
    IDLLong fPartitionIDPresent;
    MSRPCE.AuthnLevel dwDefaultAuthnLvl where ValidationCheckEnumValueTooManyItems(InRange<MSRPCE.AuthnLevel>(value),
        null, true, ReferenceType.Type, "DCOM", "dwDefaultAuthnLvl", "tagSpecialPropertiesData_Alternate", "Authentication Levels", "[MS-RPCE]")
        with Encoding
            {
                Decoder = PatternDecoder<MSRPCE.AuthnLevel>, 
                SourceConverter = DWORD2Byte, 
                SourcePattern = TypeOf<DWORD>()
            };
    GUID guidPartition;
    DWORD dwPRTFlags where ValidationCheckZero(value == 0, null, true, ReferenceType.Type, "DCOM", "dwPRTFlags", "tagSpecialPropertiesData_Alternate", value);
    DWORD dwOrigClsctx;
    tagSpecialPropertiesData_dwFlags dwFlags where ValidationCheckCombinationValueIncludeZero(InRange<tagSpecialPropertiesData_dwFlags>(value),
        null, true, ReferenceType.Type, "DCOM", "dwFlags", "tagSpecialPropertiesData_Alternate", "0x00000001", value)
        with Encoding{Decoder = PatternDecoder<tagSpecialPropertiesData_dwFlags>, SourcePattern = TypeOf<DWORD>()};
    array<DWORD> Reserved3 with IDL{Dimensions = [8]}; 
}

const int MAX_REQUESTED_INTERFACES = 0x8000;
const int MAX_REQUESTED_PROTSEQS = 0x8000;

optional binary ConvertArrayUshort2BinaryLittleEndian(array<ushort> arrayUshort)
{
    // ToBinary with LittleEndian and decode also with Little Endian
    return arrayUshort.Accumulate<ushort, binary>((ushort i, binary r) => r + i.ToBinary(true));
}

// SourceConvertor
optional byte DWORD2Byte(DWORD input)
{
    return input as byte;
}

optional byte Ushort2Byte(ushort input)
{
    return input as byte;
}

// ORPCRequest and ORPCResponse are used by RPC AOP

message ORPCRequest
{
    ORPCTHIS orpcthis with IDL{IndirectionLevel = 1};
    binary Payload;
    
    override string ToString()
    {
        return "ORPCRequest, Version: " + orpcthis.version.ToString() + ", cid:" + orpcthis.cid.ToString();
    }
} with IDL{DoNotGenerate = true};

message ORPCResponse
{
    ORPCTHAT orpcthat with IDL{IndirectionLevel = 1};
    binary Payload;
    
    override string ToString()
    {
        return "ORPCResponse";
    }
} with IDL{DoNotGenerate = true};


// ORPCDecoder is used by RPC AOP (Aspect Oriented Parsing) generated OPN code
// to decode an ORPC message.

optional T ORPCDecoder<T>(RpcconnRequestHdrT rpcRequest, NdrInfo ndrInfo, out ORPCRequest orpcRequest)
{
    // Firstly decode OrpcRequest
    var decoded = NdrDecoder<ORPCRequest>(rpcRequest.StubData, ndrInfo);
    
    // Return nothing when decoding failed
    if(decoded == nothing)
    {
        orpcRequest = null;
        return nothing;
    }
    
    // Get the ORPC request and assign origins
    orpcRequest = decoded as ORPCRequest;
    orpcRequest.Origins = [rpcRequest as any message];
    
    // Finally decode the target message from ORPC payload
    return NdrDecoder<T>(orpcRequest.Payload, ndrInfo);
}

optional T ORPCDecoder<T>(RpcconnResponseHdrT rpcResponse, NdrInfo ndrInfo, out ORPCResponse orpcResponse)
{
    // Firstly decode ORPCResponse
    var decoded = NdrDecoder<ORPCResponse>(rpcResponse.StubData, ndrInfo);
    
    // Return nothing when decoding failed
    if(decoded == nothing)
    {
        orpcResponse = null;
        return nothing;
    }
    
    // Get the ORPC response and assign origins
    orpcResponse = decoded as ORPCResponse;	
    orpcResponse.Origins = [rpcResponse as any message];
    
    // Finally decode the target message from ORPC payload
    return NdrDecoder<T>(orpcResponse.Payload, ndrInfo);
}
