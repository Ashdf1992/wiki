protocol TSGU with
Visualization{AliasName = "RDP"},
Documentation
{
    ProtocolName = "Terminal Services Gateway Server Protocol",
    ShortName = "TSGU",
    Description = ""
},
OPNAuthoring
{
    Copyright = "(c) Microsoft Corporation",
    References =
        [
            new Reference{Name = "MS-TSGU", Version = "37.0", Date = "06/01/2017", ProgramName = ProgramName.MCPP},
        ],
    RevisionSummary =
        [
            new Revision{Class=RevisionClass.Major, Version="383234", Date="12/23/2015"}
        ]
};

using Technologies.IDL;
using MSRPCE;
using HTTP;
using TCP;
using Utility;
using InfrastructureResources;
using RemoteDesktopResources;
using DecodingUtility;
using MicrosoftCommonResources;
using Diagnostics;

annotation uint TSGUBaseMessage#CallId;

endpoint Server over ExtendedServer
                accepts Opnum0NotUsedOnWireRequest issues Opnum0NotUsedOnWireResponse
                accepts TsProxyCreateTunnelRequest issues TsProxyCreateTunnelResponse
                accepts TsProxyAuthorizeTunnelRequest issues TsProxyAuthorizeTunnelResponse
                accepts TsProxyMakeTunnelCallRequest issues TsProxyMakeTunnelCallResponse
                accepts TsProxyCreateChannelRequest issues TsProxyCreateChannelResponse
                accepts Opnum5NotUsedOnWireRequest issues Opnum5NotUsedOnWireResponse
                accepts TsProxyCloseChannelRequest issues TsProxyCloseChannelResponse
                accepts TsProxyCloseTunnelRequest issues TsProxyCloseTunnelResponse
                accepts TsProxySetupReceivePipeRequest issues TsProxySetupReceivePipeResponse
                accepts TsProxySendToServerRequest issues TsProxySendToServerResponse
                issues Opnum0NotUsedOnWire
                issues TsProxyCreateTunnel
                issues TsProxyAuthorizeTunnel
                issues TsProxyMakeTunnelCall
                issues TsProxyCreateChannel
                issues Opnum5NotUsedOnWire
                issues TsProxyCloseChannel
                issues TsProxyCloseTunnel
                issues TsProxySendToServer
                accepts HTTP_CHANNEL_PACKET issues HTTP_CHANNEL_RESPONSE
                accepts HTTP_DATA_PACKET issues HTTP_DATA_PACKET
                accepts HTTP_EXTENDED_AUTH_PACKET issues HTTP_EXTENDED_AUTH_PACKET
                accepts HTTP_KEEPALIVE_PACKET issues HTTP_KEEPALIVE_PACKET
                accepts HTTP_HANDSHAKE_REQUEST_PACKET issues HTTP_HANDSHAKE_RESPONSE_PACKET
                accepts HTTP_REAUTH_MESSAGE issues HTTP_SERVICE_MESSAGE
                accepts HTTP_TUNNEL_AUTH_PACKET issues HTTP_TUNNEL_AUTH_RESPONSE
                accepts HTTP_TUNNEL_PACKET issues HTTP_TUNNEL_RESPONSE
                provides ExtendedtsguContract
{
    ushort tunnelPort;
    ushort remotePort;
}

// In HTTPS transport, the SrcPort of request is different from the DstPort of response, 
// so add index to make sure the request and response are in the same ExtendedServer instance.
// RDG-Connection-Id is a GUID generate by client so we consider it is unique. Now we use it as index.
// If met the rare case that two client use the same RDG-Connection-Id connect to Gateway, then we can add the TunnelId to index.
endpoint ExtendedServer[string Index] over MSRPCE.Server | over HTTP.Server
                accepts Opnum0NotUsedOnWireRequest issues Opnum0NotUsedOnWireResponse
                accepts TsProxyCreateTunnelRequest issues TsProxyCreateTunnelResponse
                accepts TsProxyAuthorizeTunnelRequest issues TsProxyAuthorizeTunnelResponse
                accepts TsProxyMakeTunnelCallRequest issues TsProxyMakeTunnelCallResponse
                accepts TsProxyCreateChannelRequest issues TsProxyCreateChannelResponse
                accepts Opnum5NotUsedOnWireRequest issues Opnum5NotUsedOnWireResponse
                accepts TsProxyCloseChannelRequest issues TsProxyCloseChannelResponse
                accepts TsProxyCloseTunnelRequest issues TsProxyCloseTunnelResponse
                accepts TsProxySetupReceivePipeRequest issues TsProxySetupReceivePipeResponse
                accepts TsProxySendToServerRequest issues TsProxySendToServerResponse
                issues Opnum0NotUsedOnWire
                issues TsProxyCreateTunnel
                issues TsProxyAuthorizeTunnel
                issues TsProxyMakeTunnelCall
                issues TsProxyCreateChannel
                issues Opnum5NotUsedOnWire
                issues TsProxyCloseChannel
                issues TsProxyCloseTunnel
                issues TsProxySendToServer
                accepts HTTP_CHANNEL_PACKET issues HTTP_CHANNEL_RESPONSE
                accepts HTTP_DATA_PACKET issues HTTP_DATA_PACKET
                accepts HTTP_EXTENDED_AUTH_PACKET issues HTTP_EXTENDED_AUTH_PACKET
                accepts HTTP_KEEPALIVE_PACKET issues HTTP_KEEPALIVE_PACKET
                accepts HTTP_HANDSHAKE_REQUEST_PACKET issues HTTP_HANDSHAKE_RESPONSE_PACKET
                accepts HTTP_REAUTH_MESSAGE issues HTTP_SERVICE_MESSAGE
                accepts HTTP_TUNNEL_AUTH_PACKET issues HTTP_TUNNEL_AUTH_RESPONSE
                accepts HTTP_TUNNEL_PACKET issues HTTP_TUNNEL_RESPONSE
                provides ExtendedtsguContract
{
    binary localAddress;
    binary remoteAddress;
    ushort localPort;
    ushort remotePort;
    ushort tunnelPort;
}

message TSGUBaseMessage
{
}

message Opnum0NotUsedOnWireRequest
{
}

message Opnum0NotUsedOnWireResponse
{
}

virtual operation Opnum0NotUsedOnWire
{
}
with Technologies.IDL.IDL{Opnum = 0}
=
accepts Opnum0NotUsedOnWireRequest{}
later issues Opnum0NotUsedOnWireResponse{};

message TsProxyCreateTunnelRequest : TSGUBaseMessage
{
    PTSG_PACKET TSGPacket
        with Technologies.IDL.IDL{PointerType = PointerKind.RefPtr};
    override string ToString()
    {
        return "TsProxyCreateTunnelRequest, " + TSGPacket.ToString();
    }
}

message TsProxyCreateTunnelResponse : TSGUBaseMessage
{
    PTSG_PACKET TSGPacketResponse
        with Technologies.IDL.IDL{PointerType = PointerKind.RefPtr, IndirectionLevel = 1};
    PTUNNEL_CONTEXT_HANDLE_SERIALIZE tunnelContext
        with Technologies.IDL.IDL{IndirectionLevel = 1};
    IDLUlong tunnelId with Technologies.IDL.IDL{IndirectionLevel = 1};
    ReturnValuePattern ReturnValue;
    override string ToString()
    {
        string summary = "TsProxyCreateTunnelResponse";
        if (TSGPacketResponse != null)
        {
            summary += ", " + TSGPacketResponse.ToString();
        }
        summary += ", ReturnValue: " + EnumToStringInSummary<ReturnValuePattern>(ReturnValue) + 
            ", tunnelId: " + tunnelId.ToString();
        return summary;
    }
}

virtual operation TsProxyCreateTunnel
{
    in PTSG_PACKET TSGPacket = tsgPacket;
    out PTSG_PACKET TSGPacketResponse = tsgPacketRes;
    out PTUNNEL_CONTEXT_HANDLE_SERIALIZE tunnelContext = tunnelCon;
    out IDLUlong tunnelId = tunnelid;
    result ReturnValuePattern ReturnValue = returnValue;

    override string ToString()
    {
        string summary = "TsProxyCreateTunnel, TSGPacket: " + TSGPacket.ToString();
        if (TSGPacketResponse != null)
        {
            summary += ", TSGPacketResponse" + TSGPacketResponse.ToString();
        }
        summary += ", ReturnValue: " + EnumToStringInSummary<ReturnValuePattern>(ReturnValue) + 
            ", tunnelId: " + tunnelId.ToString();
        return summary;
    }
}
with Technologies.IDL.IDL{Opnum = 1}
=
accepts TsProxyCreateTunnelRequest{#CallId is var callId, TSGPacket is var tsgPacket}
later issues TsProxyCreateTunnelResponse{#CallId == callId, TSGPacketResponse is var tsgPacketRes,
    tunnelContext is var tunnelCon, tunnelId is var tunnelid, ReturnValue is var returnValue};

message TsProxyAuthorizeTunnelRequest : TSGUBaseMessage
{
    PTUNNEL_CONTEXT_HANDLE_NOSERIALIZE tunnelContext;
    PTSG_PACKET TSGPacket
        with Technologies.IDL.IDL{PointerType = PointerKind.RefPtr};
    override string ToString()
    {
        return "TsProxyAuthorizeTunnelRequest, " + TSGPacket.ToString();
    }
}
    
message TsProxyAuthorizeTunnelResponse : TSGUBaseMessage
{
    PTSG_PACKET TSGPacketResponse
        with Technologies.IDL.IDL{PointerType = PointerKind.RefPtr, IndirectionLevel = 1};
    ReturnValuePattern ReturnValue;
    override string ToString()
    {
        string summary = "TsProxyAuthorizeTunnelResponse";
        if (TSGPacketResponse != null)
        {
            summary += ", " + TSGPacketResponse.ToString();
        }
        summary += ", ReturnValue: " + EnumToStringInSummary<ReturnValuePattern>(ReturnValue);
        return summary;
    }
}

virtual operation TsProxyAuthorizeTunnel
{
    in PTUNNEL_CONTEXT_HANDLE_NOSERIALIZE tunnelContext = tunnelCon;
    in PTSG_PACKET TSGPacket = tsgPacket;
    out PTSG_PACKET TSGPacketResponse = tsgPacketRes;
    result ReturnValuePattern ReturnValue = returnValue;

    override string ToString()
    {
        string summary = "TsProxyAuthorizeTunnel, TSGPacket: " + TSGPacket.ToString();
        if (TSGPacketResponse != null)
        {
            summary += ", TSGPacketResponse" + TSGPacketResponse.ToString();
        }
        summary += ", ReturnValue: " + EnumToStringInSummary<ReturnValuePattern>(ReturnValue);
        return summary;
    }
}
with Technologies.IDL.IDL{Opnum = 2}
=
accepts TsProxyAuthorizeTunnelRequest{#CallId is var callId, tunnelContext is var tunnelCon, TSGPacket is var tsgPacket}
later issues TsProxyAuthorizeTunnelResponse{#CallId == callId, TSGPacketResponse is var tsgPacketRes, ReturnValue is var returnValue};

message TsProxyMakeTunnelCallRequest : TSGUBaseMessage
{
    PTUNNEL_CONTEXT_HANDLE_NOSERIALIZE tunnelContext;
    TsProxyMakeTunnelCall_procId procId;
    PTSG_PACKET TSGPacket with Technologies.IDL.IDL
        {PointerType = PointerKind.RefPtr};
    override string ToString()
    {
        return "TsProxyMakeTunnelCallRequest, " + TSGPacket.ToString() + 
            ", procId: " + EnumToStringInSummary<TsProxyMakeTunnelCall_procId>(procId);
    }
}
    
message TsProxyMakeTunnelCallResponse : TSGUBaseMessage
{
    PTSG_PACKET TSGPacketResponse
        with Technologies.IDL.IDL
                    {PointerType = PointerKind.RefPtr, IndirectionLevel = 1};
    ReturnValuePattern ReturnValue;
    override string ToString()
    {
        string summary = "TsProxyMakeTunnelCallResponse";
        if (TSGPacketResponse != null)
        {
            summary += ", " + TSGPacketResponse.ToString();
        }
        summary += ", ReturnValue: " + EnumToStringInSummary<ReturnValuePattern>(ReturnValue);
        return summary;
    }
}
    
virtual operation TsProxyMakeTunnelCall
{
    in PTUNNEL_CONTEXT_HANDLE_NOSERIALIZE tunnelContext = tunnelCon;
    in TsProxyMakeTunnelCall_procId procId = proid;
    in PTSG_PACKET TSGPacket = tsgPacket;
    out PTSG_PACKET TSGPacketResponse = tsgPacketRes;
    result ReturnValuePattern ReturnValue = returnValue;
        
    override string ToString()
    {
        string summary = "TsProxyMakeTunnelCall, TSGPacket: " + TSGPacket.ToString() + 
            ", procId: " + EnumToStringInSummary<TsProxyMakeTunnelCall_procId>(procId);
        if (TSGPacketResponse != null)
        {
            summary += ", TSGPacketResponse: " + TSGPacketResponse.ToString();
        }
        summary += ", ReturnValue: " + EnumToStringInSummary<ReturnValuePattern>(ReturnValue);
        return summary;
    }
}
with Technologies.IDL.IDL{Opnum = 3}
=
accepts TsProxyMakeTunnelCallRequest{#CallId is var callId, tunnelContext is var tunnelCon, procId is var proid, TSGPacket is var tsgPacket}
later issues TsProxyMakeTunnelCallResponse{#CallId == callId, TSGPacketResponse is var tsgPacketRes, ReturnValue is var returnValue};

message TsProxyCreateChannelRequest : TSGUBaseMessage
{
    PTUNNEL_CONTEXT_HANDLE_NOSERIALIZE tunnelContext;
    PTSENDPOINTINFO  tsEndPointInfo
        with Technologies.IDL.IDL{PointerType = PointerKind.RefPtr};
    override string ToString()
    {
        return "TsProxyCreateChannelRequest, " + tsEndPointInfo.ToString();
    }
}
    
message TsProxyCreateChannelResponse : TSGUBaseMessage
{
    PCHANNEL_CONTEXT_HANDLE_SERIALIZE channelContext
        with Technologies.IDL.IDL{IndirectionLevel = 1};
    IDLUlong channelId with Technologies.IDL.IDL{IndirectionLevel = 1};
    ReturnValuePattern ReturnValue;
    override string ToString()
    {
        return "TsProxyCreateChannelResponse, channelId: " + channelId.ToString() + 
            ", ReturnValue: " + EnumToStringInSummary<ReturnValuePattern>(ReturnValue);
    }
}

virtual operation TsProxyCreateChannel
{
    in PTUNNEL_CONTEXT_HANDLE_NOSERIALIZE tunnelContext = tunnelCon;
    in PTSENDPOINTINFO tsEndPointInfo = tsEPTInfo;
    out PCHANNEL_CONTEXT_HANDLE_SERIALIZE channelContext = channelCon;
    out IDLUlong channelId = channelid;
    result ReturnValuePattern ReturnValue = returnValue;

    override string ToString()
    {
        return "TsProxyCreateChannel, " + tsEndPointInfo.ToString() + 
            ", channelId: " + channelId.ToString() + 
            ", ReturnValue: " + EnumToStringInSummary<ReturnValuePattern>(ReturnValue);
    }
}
with Technologies.IDL.IDL{Opnum = 4}
=
accepts TsProxyCreateChannelRequest{#CallId is var callId, tunnelContext is var tunnelCon, tsEndPointInfo is var tsEPTInfo}
later issues TsProxyCreateChannelResponse{#CallId == callId, channelContext is var channelCon, channelId is var channelid, ReturnValue is var returnValue};

message Opnum5NotUsedOnWireRequest
{
}

message Opnum5NotUsedOnWireResponse
{
}

virtual operation Opnum5NotUsedOnWire
{
}
with Technologies.IDL.IDL{Opnum = 5}
=
accepts Opnum5NotUsedOnWireRequest{}
later issues Opnum5NotUsedOnWireResponse{};

message TsProxyCloseChannelRequest : TSGUBaseMessage
{
    PCHANNEL_CONTEXT_HANDLE_NOSERIALIZE context
        with Technologies.IDL.IDL{IndirectionLevel = 1};
    override string ToString()
    {
        return "TsProxyCloseChannelRequest";
    }
}

message TsProxyCloseChannelResponse : TSGUBaseMessage
{
    PCHANNEL_CONTEXT_HANDLE_NOSERIALIZE context
        with Technologies.IDL.IDL{IndirectionLevel = 1};
    ReturnValuePattern ReturnValue;
    override string ToString()
    {
        return "TsProxyCloseChannelResponse, ReturnValue: " + EnumToStringInSummary<ReturnValuePattern>(ReturnValue);
    }
}

virtual operation TsProxyCloseChannel
{
    in out PCHANNEL_CONTEXT_HANDLE_NOSERIALIZE context = con;
    result ReturnValuePattern ReturnValue = returnValue;

    override string ToString()
    {
        return "TsProxyCloseChannel, ReturnValue: " + EnumToStringInSummary<ReturnValuePattern>(ReturnValue);
    }
}
with Technologies.IDL.IDL{Opnum = 6}
=
accepts TsProxyCloseChannelRequest{#CallId is var callId}
later issues TsProxyCloseChannelResponse{#CallId == callId, context is var con, ReturnValue is var returnValue};

message TsProxyCloseTunnelRequest : TSGUBaseMessage
{
    PTUNNEL_CONTEXT_HANDLE_SERIALIZE context
        with Technologies.IDL.IDL{IndirectionLevel = 1};
    override string ToString()
    {
        return "TsProxyCloseTunnelRequest";
    }
}

message TsProxyCloseTunnelResponse : TSGUBaseMessage
{
    PTUNNEL_CONTEXT_HANDLE_SERIALIZE context
        with Technologies.IDL.IDL{IndirectionLevel = 1};
    ReturnValuePattern ReturnValue;
    override string ToString()
    {
        return "TsProxyCloseTunnelResponse, ReturnValue: " + EnumToStringInSummary<ReturnValuePattern>(ReturnValue);
    }
}

virtual operation TsProxyCloseTunnel
{
    in out PTUNNEL_CONTEXT_HANDLE_SERIALIZE context = con;
    result ReturnValuePattern ReturnValue = returnValue;

    override string ToString()
    {
        return "TsProxyCloseTunnel, ReturnValue: " + EnumToStringInSummary<ReturnValuePattern>(ReturnValue);
    }
}
with Technologies.IDL.IDL{Opnum = 7}
=
accepts TsProxyCloseTunnelRequest{#CallId is var callId}
later issues TsProxyCloseTunnelResponse{#CallId == callId, context is var con, ReturnValue is var returnValue};

message TsProxySetupReceivePipeRequest : TSGUBaseMessage
{
    optional handle_t IDL_handle;
    RDGClienttoRDGServerPacketFormat pRpcMessage;
    override string ToString()
    {
        return "TsProxySetupReceivePipeRequest";
    }
}

message TsProxySetupReceivePipeResponse[RpcCoPfcFlags F] : TSGUBaseMessage
{
    optional [|F != RpcCoPfcFlags.PfcLastFrag|] binary data; // do not reassemble because upper layer will do
    optional [|F == RpcCoPfcFlags.PfcLastFrag|] ReturnValuePattern ReturnValue;
    override string ToString()
    {
        string summary = "TsProxySetupReceivePipeResponse";
        if (F == RpcCoPfcFlags.PfcLastFrag)
        {
            summary += ", ReturnValue: " + EnumToStringInSummary<ReturnValuePattern>(ReturnValue as ReturnValuePattern);
        }
        return summary;
    }
}

message TsProxySendToServerRequest : TSGUBaseMessage
{
    optional handle_t IDL_handle;
    GenericSendDataMessagePacket pRpcMessage;
    override string ToString()
    {
        return "TsProxySendToServerRequest: " + pRpcMessage.ToString();
    }
}
message TsProxySendToServerResponse : TSGUBaseMessage
{
    ReturnValuePattern ReturnValue;
    override string ToString()
    {
        return "TsProxySendToServerResponse, ReturnValue: " + EnumToStringInSummary<ReturnValuePattern>(ReturnValue);
    }
}

virtual operation TsProxySendToServer
{
    in optional handle_t IDL_handle = idl_handl;
    result ReturnValuePattern ReturnValue = returnValue;

    override string ToString()
    {
        return "TsProxySendToServer, ReturnValue:" + EnumToStringInSummary<ReturnValuePattern>(ReturnValue);
    }
}
with Technologies.IDL.IDL{Opnum = 9}
=
accepts TsProxySendToServerRequest{#CallId is var callId, IDL_handle is var idl_handl}
later issues TsProxySendToServerResponse{#CallId == callId, ReturnValue is var returnValue};

// type for binary decode TsProxySendToServerRequest (opnum 9)
type GenericSendDataMessagePacket
{
    ContextHandle PCHANNEL_CONTEXT_HANDLE_NOSERIALIZE_NR;
    uint totalDataBytes with BinaryEncoding{Endian = Endian.Big};
    uint numBuffers with BinaryEncoding{Endian = Endian.Big};
    uint buffer1Length with BinaryEncoding{Endian = Endian.Big};
    optional [|numBuffers > 1|] uint buffer2Length with BinaryEncoding{Endian = Endian.Big};
    optional [|numBuffers > 2|] uint buffer3Length with BinaryEncoding{Endian = Endian.Big};
    array<byte> buffer1 with BinaryEncoding{Length = buffer1Length};
    optional [|numBuffers > 1|] array<byte> buffer2 with BinaryEncoding{Length = buffer2Length as uint};
    optional [|numBuffers > 2|] array<byte> buffer3 with BinaryEncoding{Length = buffer3Length as uint};
    override string ToString()
    {
        string summary = "totalDataBytes: " + totalDataBytes.ToString() +
            ", buffer1Length: " + buffer1Length.ToString();
        if (numBuffers > 1)
        {
            summary += ", buffer2Length: " + buffer2Length.ToString();
        }
        if (numBuffers > 2)
        {
            summary += ", buffer3Length: " + buffer3Length.ToString();
        }
        return summary;
    }
}with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};

// type for binary decode TsProxySetupReceivePipe (opnum 8)
type RDGClienttoRDGServerPacketFormat
{
    ContextHandle PCHANNEL_CONTEXT_HANDLE_NOSERIALIZE_NR;
}

typedef PTSG_PACKET = TSG_PACKET with Technologies.IDL.IDL{IndirectionLevel = 1};
typedef PTSENDPOINTINFO = tsendpointinfo with Technologies.IDL.IDL{IndirectionLevel = 1};

type TSG_PACKET
{
    TSG_PACKET_packetId packetId;
    TSG_PACKET_TYPE_UNION[packetId] TSGPacket
        with Technologies.IDL.IDL{Switch_Is = packetId};

    override string ToString()
    {
        string summary = "packetId: " + EnumToStringInSummary<TSG_PACKET_packetId>(packetId);
        string tsgPacketToString = TSGPacket.ToString();
        if (tsgPacketToString.Count > 0)
        {
            summary += ", " + tsgPacketToString;
        }
        return summary;
    }
}

pattern TSG_PACKET_packetId = enum IDLUlong
{
    TSG_PACKET_TYPE_HEADER = 0x4844,
    TSG_PACKET_TYPE_VERSIONCAPS = 0x5643,
    TSG_PACKET_TYPE_QUARCONFIGREQUEST = 0x5143,
    TSG_PACKET_TYPE_QUARREQUEST = 0x5152,
    TSG_PACKET_TYPE_RESPONSE = 0x5052,
    TSG_PACKET_TYPE_QUARENC_RESPONSE = 0x4552,
    TSG_PACKET_TYPE_CAPS_RESPONSE = 0x4350,
    TSG_PACKET_TYPE_MSG_REQUEST = 0x4752,
    TSG_PACKET_TYPE_MSG_RESPONSE = 0x4750,
    TSG_PACKET_TYPE_AUTH = 0x4054,
    TSG_PACKET_TYPE_REAUTH = 0x5250,
    ...
};

type TSG_PACKET_TYPE_UNION[IDLUlong Tag]
{
    optional [|Tag == TSG_PACKET_packetId.TSG_PACKET_TYPE_HEADER|] 
        PTSG_PACKET_HEADER packetHeader
        with Technologies.IDL.IDL{Case = [0x4844]};
    optional [|Tag == TSG_PACKET_packetId.TSG_PACKET_TYPE_VERSIONCAPS|] 
        PTSG_PACKET_VERSIONCAPS packetVersionCaps
        with Technologies.IDL.IDL{Case = [0x5643]};
    optional [|Tag == TSG_PACKET_packetId.TSG_PACKET_TYPE_QUARCONFIGREQUEST|] 
        PTSG_PACKET_QUARCONFIGREQUEST packetQuarConfigRequest
        with Technologies.IDL.IDL{Case = [0x5143]}; // not used by any version of Windows
    optional [|Tag == TSG_PACKET_packetId.TSG_PACKET_TYPE_QUARREQUEST|] 
        PTSG_PACKET_QUARREQUEST packetQuarRequest
        with Technologies.IDL.IDL{Case = [0x5152]};
    optional [|Tag == TSG_PACKET_packetId.TSG_PACKET_TYPE_RESPONSE|] 
        PTSG_PACKET_RESPONSE packetResponse
        with Technologies.IDL.IDL{Case = [0x5052]};
    optional [|Tag == TSG_PACKET_packetId.TSG_PACKET_TYPE_QUARENC_RESPONSE|] 
        PTSG_PACKET_QUARENC_RESPONSE packetQuarEncResponse
        with Technologies.IDL.IDL{Case = [0x4552]};
    optional [|Tag == TSG_PACKET_packetId.TSG_PACKET_TYPE_CAPS_RESPONSE|] 
        PTSG_PACKET_CAPS_RESPONSE packetCapsResponse
        with Technologies.IDL.IDL{Case = [0x4350]};
    optional [|Tag == TSG_PACKET_packetId.TSG_PACKET_TYPE_MSG_REQUEST|] 
        PTSG_PACKET_MSG_REQUEST packetMsgRequest
        with Technologies.IDL.IDL{Case = [0x4752]};
    optional [|Tag == TSG_PACKET_packetId.TSG_PACKET_TYPE_MSG_RESPONSE|] 
        PTSG_PACKET_MSG_RESPONSE packetMsgResponse
        with Technologies.IDL.IDL{Case = [0x4750]};
    optional [|Tag == TSG_PACKET_packetId.TSG_PACKET_TYPE_AUTH|] 
        PTSG_PACKET_AUTH packetAuth
        with Technologies.IDL.IDL{Case = [0x4054]};
    optional [|Tag == TSG_PACKET_packetId.TSG_PACKET_TYPE_REAUTH|] 
        PTSG_PACKET_REAUTH packetReauth
        with Technologies.IDL.IDL{Case = [0x5250]};
    override string ToString()
    {
        if (packetHeader != nothing)
        {
            return "";
        }
        else if (packetVersionCaps != nothing)
        {
            return packetVersionCaps.ToString();
        }
        else if (packetQuarRequest != nothing)
        {
            return packetQuarRequest.ToString();
        }
        else if (packetResponse != nothing)
        {
            return packetResponse.ToString();
        }
        else if (packetQuarEncResponse != nothing)
        {
            return packetQuarEncResponse.ToString();
        }
        else if (packetCapsResponse != nothing)
        {
            return packetCapsResponse.ToString();
        }
        else if (packetMsgRequest != nothing)
        {
            return packetMsgRequest.ToString();
        }
        else if (packetMsgResponse != nothing)
        {
            return packetMsgResponse.ToString();
        }
        else if (packetAuth != nothing)
        {
            return packetAuth.ToString();
        }
        else if (packetReauth != nothing)
        {
            return packetReauth.ToString();
        }
        else
        {
            return "";
        }
    }
}
with Technologies.IDL.IDL
         {Switch_Type = TypeOf<IDLUlong>(), UnionKind = UnionKind.NonEncapsulated};

typedef PTSG_PACKET_TYPE_UNION = TSG_PACKET_TYPE_UNION with Technologies.IDL.IDL{IndirectionLevel = 1};

type TSG_PACKET_HEADER
{
    ushort ComponentId where ValidationCheckValue(value == 0x5452, null, true, ReferenceType.Type, "TSGU", "ComponentId", "TSG_PACKET_HEADER", "0x5452", value);
    ushort PacketId;
}

typedef PTSG_PACKET_HEADER = TSG_PACKET_HEADER with Technologies.IDL.IDL{IndirectionLevel = 1};

type TSG_PACKET_VERSIONCAPS
{
    TSG_PACKET_HEADER tsgHeader;
    PTSG_PACKET_CAPABILITIES TSGCaps
        with Technologies.IDL.IDL{Size_is = [numCapabilities]};
    IDLUlong numCapabilities
        with Technologies.IDL.IDL{Range = new RangePattern{Low = 0, High = 32}};
    ushort majorVersion where ValidationCheckValue(value == 0x0001, null, true, ReferenceType.Type, 
        "TSGU", "majorVersion", "TSG_PACKET_VERSIONCAPS", "0x0001", value);
    ushort minorVersion where ValidationCheckValue(value == 0x0001, null, true, ReferenceType.Type, 
        "TSGU", "minorVersion", "TSG_PACKET_VERSIONCAPS", "0x0001", value);
    ushort quarantineCapabilities where ValidationCheckValue(value == 0x0001, null, false, 
        ReferenceType.Type, "TSGU", "quarantineCapabilities", "TSG_PACKET_VERSIONCAPS", "0x0001", value);
    override string ToString()
    {
        return TSGCaps.ToString();
    }
}

typedef PTSG_PACKET_VERSIONCAPS = TSG_PACKET_VERSIONCAPS with Technologies.IDL.IDL{IndirectionLevel = 1};

type TSG_PACKET_CAPABILITIES
{
    IDLUlong capabilityType where ValidationCheckValue(value == 0x00000001, null, true, 
        ReferenceType.Type, "TSGU", "capabilityType", "TSG_PACKET_CAPABILITIES", "0x00000001", value);
    TSG_CAPABILITIES_UNION[capabilityType] TSGPacket
        with Technologies.IDL.IDL{Switch_Is = capabilityType};
    override string ToString()
    {
        return TSGPacket.ToString();
    }
}

typedef PTSG_PACKET_CAPABILITIES = TSG_PACKET_CAPABILITIES with Technologies.IDL.IDL{IndirectionLevel = 1};

type TSG_CAPABILITIES_UNION[IDLUlong Tag]
{
    optional [|Tag in {0x1}|] TSG_CAPABILITY_NAP TSGCapNap
        with Technologies.IDL.IDL{Case = [0x1]};
    override string ToString()
    {
        if (TSGCapNap != nothing)
        {
            return TSGCapNap.ToString();
        }
        else
        {
            return "";
        }
    }
}
with Technologies.IDL.IDL
         {Switch_Type = TypeOf<IDLUlong>(), UnionKind = UnionKind.NonEncapsulated};

typedef PTSG_CAPABILITIES_UNION = TSG_CAPABILITIES_UNION with Technologies.IDL.IDL{IndirectionLevel = 1};

type TSG_CAPABILITY_NAP
{
    TSG_CAPABILITY_NAP_capabilities capabilities;
    override string ToString()
    {
        return "capabilities: " + EnumToStringInSummary<TSG_CAPABILITY_NAP_capabilities>(capabilities);
    }
}

pattern TSG_CAPABILITY_NAP_capabilities = flags IDLUlong
{
    TSG_NAP_CAPABILITY_QUAR_SOH = 0x00000001
        with Documentation
            {Description = "This constant is used to represent the NAP quarantine capability."},
    TSG_NAP_CAPABILITY_IDLE_TIMEOUT = 0x00000002
        with Documentation
            {Description = "This constant is used to represent the Idle timeout capability."},
    TSG_MESSAGING_CAP_CONSENT_SIGN = 0x00000004
        with Documentation
            {Description = "This constant is used to represent the consent message capability."},
    TSG_MESSAGING_CAP_SERVICE_MSG = 0x00000008
        with Documentation
            {Description = "This constant is used to represent the service message capability."},
    TSG_MESSAGING_CAP_REAUTH = 0x00000010
        with Documentation
            {Description = "This constant is used to represent the reauthentication capability."},
    ...
};

typedef PTSG_CAPABILITY_NAP = TSG_CAPABILITY_NAP with Technologies.IDL.IDL{IndirectionLevel = 1};

type TSG_PACKET_QUARCONFIGREQUEST
{
    IDLUlong @flags;
}

typedef PTSG_PACKET_QUARCONFIGREQUEST = TSG_PACKET_QUARCONFIGREQUEST with Technologies.IDL.IDL{IndirectionLevel = 1};

type TSG_PACKET_QUARREQUEST
{
    IDLUlong @flags;
    string machineName
        with Technologies.IDL.IDL{Size_is = [nameLength], 
            BaseStringType = TypeOf<wchar_t>(), IndirectionLevel = 1};
    IDLUlong nameLength
        with Technologies.IDL.IDL{Range = new RangePattern{Low = 0, High = 513}};
    byte data with Technologies.IDL.IDL{Size_is = [dataLen], 
        PointerType = PointerKind.UniquePtr, IndirectionLevel = 1};
    IDLUlong dataLen
        with Technologies.IDL.IDL{Range = new RangePattern{Low = 0, High = 8000}};
    override string ToString()
    {
        return "machineName: " + machineName;
    }
}

typedef PTSG_PACKET_QUARREQUEST = TSG_PACKET_QUARREQUEST with Technologies.IDL.IDL{IndirectionLevel = 1};

type TSG_PACKET_RESPONSE
{
    TSG_PACKET_packetId @flags where ValidationCheckValue(value == TSG_PACKET_packetId.TSG_PACKET_TYPE_QUARREQUEST, null, false, 
        ReferenceType.Type, "TSGU", "flags", "TSG_PACKET_RESPONSE", "0x00005152", value);
    IDLUlong reserved;
    byte responseData with Technologies.IDL.IDL{Size_is = [responseDataLen], IndirectionLevel = 1};
    IDLUlong responseDataLen with Technologies.IDL.IDL{Range = new RangePattern{Low = 0, High = 24000}};
    TSG_REDIRECTION_FLAGS redirectionFlags;
    override string ToString()
    {
        string redirectionFlagsToString = redirectionFlags.ToString();
        if (redirectionFlagsToString.Count > 0)
        {
            return "redirectionFlags: " + redirectionFlagsToString;
        }
        else
        {
            return "";
        }
    }
}

typedef PTSG_PACKET_RESPONSE = TSG_PACKET_RESPONSE with Technologies.IDL.IDL{IndirectionLevel = 1};

type TSG_REDIRECTION_FLAGS
{
    bool enableAllRedirections;
    bool disableAllRedirections;
    bool driveRedirectionDisabled;
    bool printerRedirectionDisabled;
    bool portRedirectionDisabled;
    bool reserved;
    bool clipboardRedirectionDisabled;
    bool pnpRedirectionDisabled;
    override string ToString()
    {
        string summary = "";
        if (enableAllRedirections)
        {
            summary += "enableAllRedirections|";
        }
        else if (disableAllRedirections)
        {
            summary += "disableAllRedirections|";
        }
        else if (driveRedirectionDisabled)
        {
            summary += "driveRedirectionDisabled|";
        }
        else if (printerRedirectionDisabled)
        {
            summary += "printerRedirectionDisabled|";
        }
        else if (portRedirectionDisabled)
        {
            summary += "portRedirectionDisabled|";
        }
        else if (reserved)
        {
            summary += "reserved|";
        }
        else if (clipboardRedirectionDisabled)
        {
            summary += "clipboardRedirectionDisabled|";
        }
        else if (pnpRedirectionDisabled)
        {
            summary += "pnpRedirectionDisabled|";
        }
        return summary.Count > 0 ? summary.Segment(0, summary.Count - 1) : summary;
    }
}

type TSG_PACKET_QUARENC_RESPONSE
{
    IDLUlong @flags where ValidationCheckValue(value == 0, null, false, ReferenceType.Type, 
        "TSGU", "flags", "TSG_PACKET_QUARENC_RESPONSE", INFRASTRUCTURE_STR_ZERO, value);
    IDLUlong certChainLen
        with Technologies.IDL.IDL{Range = new RangePattern{Low = 0, High = 24000}};
    string certChainData
        with Technologies.IDL.IDL{Size_is = [certChainLen],
                                  BaseStringType = TypeOf<wchar_t>(),
                                  IndirectionLevel = 1};
    guid nonce;
    PTSG_PACKET_VERSIONCAPS versionCaps;
    override string ToString()
    {
        return "nonce: " + nonce.ToString();
    }
}

typedef PTSG_PACKET_QUARENC_RESPONSE = TSG_PACKET_QUARENC_RESPONSE with Technologies.IDL.IDL{IndirectionLevel = 1};

type TSG_PACKET_CAPS_RESPONSE
{
    TSG_PACKET_QUARENC_RESPONSE pktQuarEncResponse;
    TSG_PACKET_MSG_RESPONSE pktConsentMessage;
    override string ToString()
    {
        return pktQuarEncResponse.ToString() + ", " + pktConsentMessage.ToString();
    }
}

typedef PTSG_PACKET_CAPS_RESPONSE = TSG_PACKET_CAPS_RESPONSE with Technologies.IDL.IDL{IndirectionLevel = 1};

type TSG_PACKET_MSG_RESPONSE
{
    IDLUlong msgID;
    TSG_PACKET_MSG_RESPONSE_msgType msgType;
    IDLLong isMsgPresent;
    TSG_PACKET_TYPE_MESSAGE_UNION[msgType] messagePacket
        with Technologies.IDL.IDL{Switch_Is = msgType};
    override string ToString()
    {
        return "msgType: " + EnumToStringInSummary<TSG_PACKET_MSG_RESPONSE_msgType>(msgType);
    }
}

 // 2.2.9.2.1.9
pattern TSG_PACKET_MSG_RESPONSE_msgType = enum IDLUlong
{
    TSG_ASYNC_MESSAGE_CONSENT_MESSAGE = 0x00000001,
    TSG_ASYNC_MESSAGE_SERVICE_MESSAGE = 0x00000002,
    TSG_ASYNC_MESSAGE_REAUTH = 0x00000003,
    ...
};

typedef PTSG_PACKET_MSG_RESPONSE = TSG_PACKET_MSG_RESPONSE with Technologies.IDL.IDL{IndirectionLevel = 1};

type TSG_PACKET_TYPE_MESSAGE_UNION[IDLUlong Tag]
{
    optional [|Tag in {0x1}|] PTSG_PACKET_STRING_MESSAGE consentMessage
        with Technologies.IDL.IDL{Case = [0x1]};
    optional [|Tag in {0x2}|] PTSG_PACKET_STRING_MESSAGE serviceMessage
        with Technologies.IDL.IDL{Case = [0x2]};
    optional [|Tag in {0x3}|] PTSG_PACKET_REAUTH_MESSAGE reauthMessage
        with Technologies.IDL.IDL{Case = [0x3]};
}
with Technologies.IDL.IDL
         {Switch_Type = TypeOf<IDLUlong>(), UnionKind = UnionKind.NonEncapsulated};

type TSG_PACKET_STRING_MESSAGE
{
    IDLLong isDisplayMandatory;
    IDLLong isConsentMandatory;
    IDLUlong msgBytes
        with Technologies.IDL.IDL{Range = new RangePattern{Low = 0, High = 65536}};
    wchar_t msgBuffer
        with Technologies.IDL.IDL{Size_is = [msgBytes], IndirectionLevel = 1};
}

typedef PTSG_PACKET_STRING_MESSAGE = TSG_PACKET_STRING_MESSAGE with Technologies.IDL.IDL{IndirectionLevel = 1};

type TSG_PACKET_REAUTH_MESSAGE
{
    __uint64 tunnelContext;
}

typedef PTSG_PACKET_REAUTH_MESSAGE = TSG_PACKET_REAUTH_MESSAGE with Technologies.IDL.IDL{IndirectionLevel = 1};

type TSG_PACKET_MSG_REQUEST
{
    IDLUlong maxMessagesPerBatch;
    override string ToString()
    {
        return "maxMessagesPerBatch: " + maxMessagesPerBatch.ToString();
    }
}

typedef PTSG_PACKET_MSG_REQUEST = TSG_PACKET_MSG_REQUEST with Technologies.IDL.IDL{IndirectionLevel = 1};

type TSG_PACKET_AUTH
{
    TSG_PACKET_VERSIONCAPS TSGVersionCaps;
    IDLUlong cookieLen with Technologies.IDL.IDL{Range = new RangePattern{Low = 0, High = 65536}};
    byte cookie with Technologies.IDL.IDL{Size_is = [cookieLen], IndirectionLevel = 1};
    override string ToString()
    {
        return TSGVersionCaps.ToString();
    }
}

typedef PTSG_PACKET_AUTH = TSG_PACKET_AUTH with Technologies.IDL.IDL{IndirectionLevel = 1};

type TSG_PACKET_REAUTH
{
    __uint64 tunnelContext;
    IDLUlong packetId;
    TSG_INITIAL_PACKET_TYPE_UNION[packetId] TSGInitialPacket
        with Technologies.IDL.IDL{Switch_Is = packetId};
}

typedef PTSG_PACKET_REAUTH = TSG_PACKET_REAUTH with Technologies.IDL.IDL{IndirectionLevel = 1};

type TSG_INITIAL_PACKET_TYPE_UNION[IDLUlong Tag]
{
    optional [|Tag in {0x5643}|] PTSG_PACKET_VERSIONCAPS packetVersionCaps
        with Technologies.IDL.IDL{Case = [0x5643]};
    optional [|Tag in {0x4054}|] PTSG_PACKET_AUTH packetAuth
        with Technologies.IDL.IDL{Case = [0x4054]};
    override string ToString()
    {
        if (packetVersionCaps != nothing)
        {
            return packetVersionCaps.ToString();
        }
        else if (packetAuth != nothing)
        {
            return packetAuth.ToString();
        }
        else
        {
            return "";
        }
    }
}
with Technologies.IDL.IDL
         {Switch_Type = TypeOf<IDLUlong>(), UnionKind = UnionKind.NonEncapsulated};

typedef PTSG_INITIAL_PACKET_TYPE_UNION = TSG_INITIAL_PACKET_TYPE_UNION with Technologies.IDL.IDL{IndirectionLevel = 1};

typedef PTUNNEL_CONTEXT_HANDLE_NOSERIALIZE = ContextHandle;

typedef PTUNNEL_CONTEXT_HANDLE_SERIALIZE = PTUNNEL_CONTEXT_HANDLE_NOSERIALIZE
    with Technologies.IDL.IDL{Context_handle = true};

type tsendpointinfo
{
    wchar_t resourceName
        with Technologies.IDL.IDL
                 {Size_is = [numResourceNames, null], IndirectionLevel = 2};
    IDLUlong numResourceNames
        with Technologies.IDL.IDL{Range = new RangePattern{Low = 1, High = 50}};
    wchar_t alternateResourceNames
        with Technologies.IDL.IDL{Size_is = [numAlternateResourceNames, null],
                                  PointerType = PointerKind.UniquePtr,
                                  IndirectionLevel = 2};
    ushort numAlternateResourceNames
        with Technologies.IDL.IDL{Range = new RangePattern{Low = 0, High = 3}};
    uint Port; // the low order 16 bits are protocol ID, the high order 16 bits are port number
    
    override string ToString()
    {
        return "PortNumber: " + (Port >> 16).ToString();
    }
}

typedef PCHANNEL_CONTEXT_HANDLE_NOSERIALIZE = ContextHandle;

typedef PCHANNEL_CONTEXT_HANDLE_SERIALIZE = PCHANNEL_CONTEXT_HANDLE_NOSERIALIZE
    with Technologies.IDL.IDL{Context_handle = true};

pattern _tsguOpnums = enum ushort
{
    Opnum0NotUsedOnWire = 0,
    TsProxyCreateTunnel = 1,
    TsProxyAuthorizeTunnel = 2,
    TsProxyMakeTunnelCall = 3,
    TsProxyCreateChannel = 4,
    Opnum5NotUsedOnWire = 5,
    TsProxyCloseChannel = 6,
    TsProxyCloseTunnel = 7,
    TsProxySetupReceivePipe = 8,
    TsProxySendToServer = 9,
    ...
};

pattern TsProxyMakeTunnelCall_procId = enum IDLUlong
{
    TSG_TUNNEL_CALL_ASYNC_MSG_REQUEST = 0x00000001,
    TSG_TUNNEL_CANCEL_ASYNC_MSG_REQUEST = 0x00000002,
    ...
};

pattern ReturnValuePattern = enum uint
{
    E_PROXY_INTERNALERROR = 0x800759D8,
    E_PROXY_RAP_ACCESSDENIED = 0x800759DA,
    E_PROXY_NAP_ACCESSDENIED = 0x800759DB,
    E_PROXY_ALREADYDISCONNECTED = 0x800759DF,
    E_PROXY_QUARANTINE_ACCESSDENIED = 0x800759ED,
    E_PROXY_NOCERTAVAILABLE = 0x800759EE,
    E_PROXY_COOKIE_BADPACKET = 0x800759F7,
    E_PROXY_COOKIE_AUTHENTICATION_ACCESS_DENIED = 0x800759F8,
    E_PROXY_UNSUPPORTED_AUTHENTICATION_METHOD = 0x800759F9,
    E_PROXY_CAPABILITYMISMATCH = 0x800759E9,
    ERROR_SUCCESS = 0x00000000,
    ERROR_ACCESS_DENIED = 0x00000005,
    E_PROXY_TS_CONNECTFAILED = 0x000059DD,
    E_PROXY_MAXCONNECTIONSREACHED = 0x000059E6,
    $"HRESULT_CODE(E_PROXY_INTERNALERROR)" = 0X000059D8,
    ERROR_GRACEFUL_DISCONNECT = 0x000004CA,
    E_PROXY_NOTSUPPORTED = 0x000059E8,
    E_PROXY_SESSIONTIMEOUT = 0x000059F6,
    E_PROXY_REAUTH_AUTHN_FAILED = 0X000059FA,
    E_PROXY_REAUTH_CAP_FAILED = 0x000059FB,
    E_PROXY_REAUTH_RAP_FAILED = 0x000059FC,
    E_PROXY_SDR_NOT_SUPPORTED_BY_TS = 0x000059FD,
    E_PROXY_REAUTH_NAP_FAILED = 0x00005A00,
    E_PROXY_CONNECTIONABORTED = 0x000004D4,
    ERROR_BAD_ARGUMENTS = 0x000000A0,
    RPC_S_CALL_CANCELLED = 0x8007071A,
    ERROR_ONLY_IF_CONNECTED = 0x000004E3,
    ERROR_INVALID_PARAMETER = 0x00000057,
    ERROR_OPERATION_ABORTED = 0x000003E3,
    ...
};

contract ExtendedtsguContract // messages over RPC not defined in TD
{
    accepts message EncryptedRequest
    {
        binary EncryptedData;

        override string ToString()
        {
            return EnumToString(this#RpcOpnum as ushort, "TSGU._tsguOpnums") +
                " Request(Encrypted)";
        }
    }
    
    issues message EncryptedResponse
    {
        binary EncryptedData;

        override string ToString()
        {
            return EnumToString(this#RpcOpnum as ushort, "TSGU._tsguOpnums") +
                " Response(Encrypted)";
        }
    }

    virtual operation EncryptedOperation
    {
        ushort Opnum;

        override string ToString()
        {
            return EnumToString(Opnum, "TSGU._tsguOpnums") + 
                ("(Encrypted, Opnum " + Opnum.ToString() + ")");
        }
    }
    =
    accepts ExtendedtsguContract.EncryptedRequest{}
    issues ExtendedtsguContract.EncryptedResponse{};
}

binary GetAllBufferData(TsProxySendToServerRequest request)
{
    if (request.pRpcMessage.numBuffers == 1)
    {
        return request.pRpcMessage.buffer1 as binary;
    }
    array<byte> arr = request.pRpcMessage.buffer1;
    if (request.pRpcMessage.numBuffers > 1)
    {
        arr += request.pRpcMessage.buffer2 as array<byte>;
    }
    if (request.pRpcMessage.numBuffers > 2)
    {
        arr += request.pRpcMessage.buffer3 as array<byte>;
    }
    return arr as binary;
}

// actor for TSGU over MSRPCE
autostart actor TSGUOverMSRPCE(MSRPCE.Server server)
{
    TSGU.ExtendedServer extendedEPT = null;
    NdrInfo ndrInfo = null;
    process server accepts rpcMsg:RpcconnRequestHdrT
        where server.MatchInterface(rpcMsg.PContId, TSGUInterface, 196609)
    {
        InitializeExtendedServerIfNot(rpcMsg, MessageDirection.Accepts);
        if (ndrInfo == null)
        {
            ndrInfo = new NdrInfo {isBigEndian = rpcMsg.IsBigEndian,
                                 isNdr64 = server.IsNdr64(rpcMsg.PContId),
                                 isMsUnion = false,
                                 defaultPointerKind = 2};
        }
        if (rpcMsg.IsEncrypted && rpcMsg.Opnum is _tsguOpnums)
        {
            if (BinaryDecoder<ExtendedtsguContract.EncryptedRequest>(rpcMsg.StubData) is msg:ExtendedtsguContract.EncryptedRequest)
            {
                dispatch extendedEPT accepts msg;
            }
            else
            {
                ThrowDecodingException("TSGU", "EncryptedRequest");
            }
        }
        else
        {
            switch (rpcMsg.Opnum)
            {
                case $ 0 =>
                    NdrDecodeMessage<Opnum0NotUsedOnWireRequest>
                        (AcceptDispatcher, rpcMsg.CallId, rpcMsg.StubData, "Opnum0NotUsedOnWireRequest");
                case $ 1 =>
                    NdrDecodeMessage<TsProxyCreateTunnelRequest>
                        (AcceptDispatcher, rpcMsg.CallId, rpcMsg.StubData, "TsProxyCreateTunnelRequest");
                case $ 2 =>
                    NdrDecodeMessage<TsProxyAuthorizeTunnelRequest>
                        (AcceptDispatcher, rpcMsg.CallId, rpcMsg.StubData, "TsProxyAuthorizeTunnelRequest");
                case $ 3 =>
                    NdrDecodeMessage<TsProxyMakeTunnelCallRequest>
                        (AcceptDispatcher, rpcMsg.CallId, rpcMsg.StubData, "TsProxyMakeTunnelCallRequest");
                case $ 4 =>
                    if (NdrDecoder<TsProxyCreateChannelRequest>(rpcMsg.StubData) is msg:TsProxyCreateChannelRequest)
                    {
                        extendedEPT.tunnelPort = (msg.tsEndPointInfo.Port >> 16) as ushort;
                        AcceptDispatcher(msg, rpcMsg.CallId);
                    }
                    else
                    {
                        ThrowDecodingException("TSGU", "TsProxyCreateChannelRequest");
                    }
                case $ 5 =>
                    NdrDecodeMessage<Opnum5NotUsedOnWireRequest>
                        (AcceptDispatcher, rpcMsg.CallId, rpcMsg.StubData, "Opnum5NotUsedOnWireRequest");
                case $ 6 =>
                    NdrDecodeMessage<TsProxyCloseChannelRequest>
                        (AcceptDispatcher, rpcMsg.CallId, rpcMsg.StubData, "TsProxyCloseChannelRequest");
                case $ 7 =>
                    NdrDecodeMessage<TsProxyCloseTunnelRequest>
                        (AcceptDispatcher, rpcMsg.CallId, rpcMsg.StubData, "TsProxyCloseTunnelRequest");
                case $ 8 =>
                    BinaryDecodeMessage<TsProxySetupReceivePipeRequest>
                        (AcceptDispatcher, rpcMsg.CallId, rpcMsg.StubData, "TsProxySetupReceivePipeRequest");
                case $ 9 =>
                    BinaryDecodeMessage<TsProxySendToServerRequest>
                        (AcceptDispatcher, rpcMsg.CallId, rpcMsg.StubData, "TsProxySendToServerRequest");
                default =>
                    ThrowDecodingException("TSGU");
            }
        }
    }

    process server issues rpcMsg:RpcconnResponseHdrT
        where server.MatchInterface(rpcMsg.PContId, TSGUInterface, 196609)
    {
        InitializeExtendedServerIfNot(rpcMsg, MessageDirection.Issues);
        if (ndrInfo == null)
        {
            ndrInfo = new NdrInfo {isBigEndian = rpcMsg.IsBigEndian,
                                    isNdr64 = server.IsNdr64(rpcMsg.PContId),
                                    isMsUnion = false,
                                    defaultPointerKind = 2};
        }

        if (rpcMsg#RpcOpnum == nothing)
        {
            assert !(rpcMsg.CallId in server.OpnumMap),
                "Found request with CallId " +
                (rpcMsg.CallId.ToString() +
                 " but the response with same CallId doesn\'t have annotation #RpcOpnum attached!");
            ThrowDecodingException("TSGU", TSGU_RESPONSE_WITHOUT_OPNUM, []);
        }
        if (rpcMsg.IsEncrypted && (rpcMsg#RpcOpnum as ushort) is _tsguOpnums)
        {
            if (BinaryDecoder<ExtendedtsguContract.EncryptedResponse>(rpcMsg.StubData) is msg:ExtendedtsguContract.EncryptedResponse)
            {
                dispatch extendedEPT issues msg;
            }
            else
            {
                ThrowDecodingException("TSGU", "EncryptedResponse");
            }
        }
        else
        {
            switch (rpcMsg#RpcOpnum as ushort)
            {
                case $ 0 =>
                    NdrDecodeMessage<Opnum0NotUsedOnWireResponse>
                        (IssueDispatcher, rpcMsg.CallId, rpcMsg.StubData, "Opnum0NotUsedOnWireResponse");
                case $ 1 =>
                    NdrDecodeMessage<TsProxyCreateTunnelResponse>
                        (IssueDispatcher, rpcMsg.CallId, rpcMsg.StubData, "TsProxyCreateTunnelResponse");
                case $ 2 =>
                    NdrDecodeMessage<TsProxyAuthorizeTunnelResponse>
                        (IssueDispatcher, rpcMsg.CallId, rpcMsg.StubData, "TsProxyAuthorizeTunnelResponse");
                case $ 3 =>
                    NdrDecodeMessage<TsProxyMakeTunnelCallResponse>
                        (IssueDispatcher, rpcMsg.CallId, rpcMsg.StubData, "TsProxyMakeTunnelCallResponse");
                case $ 4 =>
                    NdrDecodeMessage<TsProxyCreateChannelResponse>
                        (IssueDispatcher, rpcMsg.CallId, rpcMsg.StubData, "TsProxyCreateChannelResponse");
                case $ 5 =>
                    NdrDecodeMessage<Opnum5NotUsedOnWireResponse>
                        (IssueDispatcher, rpcMsg.CallId, rpcMsg.StubData, "Opnum5NotUsedOnWireResponse");
                case $ 6 =>
                    NdrDecodeMessage<TsProxyCloseChannelResponse>
                        (IssueDispatcher, rpcMsg.CallId, rpcMsg.StubData, "TsProxyCloseChannelResponse");
                case $ 7 =>
                    NdrDecodeMessage<TsProxyCloseTunnelResponse>
                        (IssueDispatcher, rpcMsg.CallId, rpcMsg.StubData, "TsProxyCloseTunnelResponse");
                case $ 8 =>
                    if (BinaryDecoder<TsProxySetupReceivePipeResponse[rpcMsg.PfcFlags]>(rpcMsg.StubData) 
                            is msg:TsProxySetupReceivePipeResponse)
                    {
                        IssueDispatcher(msg, rpcMsg.CallId);
                    }
                    else
                    {
                        ThrowDecodingException("TSGU", "TsProxySetupReceivePipeResponse");
                    }
                case $ 9 =>
                    NdrDecodeMessage<TsProxySendToServerResponse>
                        (IssueDispatcher, rpcMsg.CallId, rpcMsg.StubData, "TsProxySendToServerResponse");
                default =>
                    ThrowDecodingException("TSGU");
            }
        }
    }

    void InitializeExtendedServerIfNot(any message currentMsg, MessageDirection dir)
    {
        if (extendedEPT == null)
        {
            extendedEPT = endpoint TSGU.ExtendedServer[EmptyString] over server;
            if (extendedEPT.localPort == 0)
            {
                // Future Reference: #1995715: Runtime support the way to get field/property/annotation 
                // value from Origins (may be the Origins of the Origins) via Selector Query
                while (currentMsg.Origins != null && !(currentMsg.Origins[0] is TCP.Segment))
                {
                    currentMsg = currentMsg.Origins[0];
                }
                if (currentMsg.Origins != null && currentMsg.Origins[0] is s:TCP.Segment)
                {
                    if (dir == MessageDirection.Accepts)
                    {
                        extendedEPT.localAddress = s#DestinationAddrBin is b1:binary ? b1 : EmptyBinary;
                        extendedEPT.remoteAddress = s#SourceAddrBin is b2:binary ? b2 : EmptyBinary;
                        extendedEPT.localPort = s.DestinationPort;
                        extendedEPT.remotePort = s.SourcePort;
                    }
                    else
                    {
                        extendedEPT.localAddress = s#SourceAddrBin is b1:binary ? b1 : EmptyBinary;
                        extendedEPT.remoteAddress = s#DestinationAddrBin is b2:binary ? b2 : EmptyBinary;
                        extendedEPT.localPort = s.SourcePort;
                        extendedEPT.remotePort = s.DestinationPort;
                    }
                }
            }
        }
    }

    void AcceptDispatcher(TSGUBaseMessage msg, uint callId)
    {
        msg#CallId = callId;
        dispatch extendedEPT accepts msg;
    }

    void IssueDispatcher(TSGUBaseMessage msg, uint callId)
    {
        msg#CallId = callId;
        dispatch extendedEPT issues msg;
    }

    void NdrDecodeMessage<T>(void(TSGUBaseMessage, uint) dispatcher, uint callId, binary bin, string messageName)
    {
        if (NdrDecoder<T>(bin, ndrInfo) is msg:T)
        {
            dispatcher(msg as TSGUBaseMessage, callId);
        }
        else
        {
            ThrowDecodingException("TSGU", messageName);
        }
    }

    void BinaryDecodeMessage<T>(void(TSGUBaseMessage, uint) dispatcher, uint callId, binary bin, string messageName)
    {
        if (BinaryDecoder<T>(bin) is msg:T)
        {
            dispatcher(msg as TSGUBaseMessage, callId);
        }
        else
        {
            ThrowDecodingException("TSGU", messageName);
        }
    }
}

// actor for TSGU over HTTP
autostart actor TSGUOverHTTP(HTTP.Server server)
{
    TSGU.ExtendedServer extendedEPT = null;
    TSGUOverHTTPDecodingCache requestCache = null;
    TSGUOverHTTPDecodingCache responseCache = null;
    bool isTSGUTraffic = false;
    // It exists in HTTP request with "RDG_IN_DATA" or "RDG_OUT_DATA" method, ExtendedServer use it as index.
    // if the HTTP request with "RDG_IN_DATA" or "RDG_OUT_DATA" missed, then the handshake TLS messages before them are missed, too. 
    // With out these TLS messages, we cannot parse the messages later. So In/Out channel always dispath to the same endpont instance.
    string rdgConnectionId = EmptyString;
    // The server sends back status code 200 and a random entity body of limited size (100 bytes), it is not TSGU message, 
    // so keep the state whether HTTP connection has been setup and whether it is possible be the random entity body.
    ConnectionStatus connectionStatus = ConnectionStatus.ConnectionNotReady;

    process server accepts req:HttpContract.Request where req.Payload.Count > 0 && 
        ((requestCache != null && requestCache.BufferCount() > 0) || IsTSGU(req, req.Payload))
    {
        InitializeExtendedServerAndDCIfNot(req, MessageDirection.Accepts);
        requestCache.AddMessage(req, IsSegmentLost, (any message req) => (req as HttpContract.Request).Payload);
        requestCache.TryDecodeAndDispatchMessage();
    }

    process server accepts seg:HttpContract.HTTPPayload where seg.Payload.Count > 0 && 
        ((requestCache != null && requestCache.BufferCount() > 0) || IsTSGU(seg, seg.Payload))
    {
        InitializeExtendedServerAndDCIfNot(seg, MessageDirection.Accepts);
        requestCache.AddMessage(seg, IsSegmentLost, (any message seg) => (seg as HttpContract.HTTPPayload).Payload);
        requestCache.TryDecodeAndDispatchMessage();
    }
    
    process server issues res:HttpContract.Response where res.Payload.Count > 0 && res.StatusCode == 200 && 
        ((responseCache != null && responseCache.BufferCount() > 0) || IsTSGU(res, res.Payload))
    {
        InitializeExtendedServerAndDCIfNot(res, MessageDirection.Issues);
        responseCache.AddMessage(res, IsSegmentLost, (any message res) => (res as HttpContract.Response).Payload);
        responseCache.TryDecodeAndDispatchMessage();
    }

    process server issues seg:HttpContract.HTTPPayload where seg.Payload.Count > 0 && 
        ((responseCache != null && responseCache.BufferCount() > 0) || IsTSGU(seg, seg.Payload))
    {
        InitializeExtendedServerAndDCIfNot(seg, MessageDirection.Issues);
        responseCache.AddMessage(seg, IsSegmentLost, (any message seg) => (seg as HttpContract.HTTPPayload).Payload);
        responseCache.TryDecodeAndDispatchMessage();
    }

    observe server accepts req:HttpContract.Request where (connectionStatus == ConnectionStatus.ConnectionNotReady) && (req.Method == "RDG_IN_DATA" || req.Method == "RDG_OUT_DATA")
    {
        if (rdgConnectionId == null)
        {
            if ("RDG-Connection-Id" in req.Headers)
            {
                rdgConnectionId = req.Headers["RDG-Connection-Id"] as string;
            }
        }
    }

    observe server issues res:HttpContract.Response where (connectionStatus == ConnectionStatus.ConnectionNotReady) && res.StatusCode == 200 && (res#HttpMethod == "RDG_IN_DATA" || res#HttpMethod == "RDG_OUT_DATA")
    {
        connectionStatus = ConnectionStatus.ConnectionSetup;
    }

    bool IsTSGU((HttpContract.Request | HttpContract.Response | HttpContract.HTTPPayload) s, binary bin)
    {
        if (isTSGUTraffic)
        {
            return true;
        }
        else if (connectionStatus == ConnectionStatus.ConnectionNotReady)
        {
            return false;
        }
        else if (connectionStatus == ConnectionStatus.ConnectionSetup)
        {
            connectionStatus = ConnectionStatus.FirstFrameParsed;
            return IsTSGUMessage(bin) == true;
        }
        else
        {
            if (s is seg:HttpContract.HTTPPayload)
            {
                 if (seg#UpperProtocol == UpperProtocolType.TSGU)
                {
                    isTSGUTraffic = true;
                    return true;
                }
            }
            if (s is req:HttpContract.Request)
            {
                if (req.Method == "RDG_IN_DATA" || req.Method == "RDG_OUT_DATA")
                {
                    isTSGUTraffic = true;
                    return true;
                }
            }
            else if (s is res:HttpContract.Response)
            {
                if ((res#HttpMethod == "RDG_IN_DATA" || res#HttpMethod == "RDG_OUT_DATA"))
                {
                    isTSGUTraffic = true;
                    return true;
                }
            }
        }
        return false;
    }

    void InitializeExtendedServerAndDCIfNot(any message currentMsg, MessageDirection dir)
    {
        if (extendedEPT == null)
        {
            extendedEPT = endpoint TSGU.ExtendedServer[rdgConnectionId];
            if (extendedEPT.localPort == 0)
            {
                // Future Reference: #1995715: Runtime support the way to get field/property/annotation 
                // value from Origins (may be the Origins of the Origins) via Selector Query
                while (currentMsg.Origins != null && !(currentMsg.Origins[0] is TCP.Segment))
                {
                    currentMsg = currentMsg.Origins[0];
                }
                if (currentMsg.Origins != null && currentMsg.Origins[0] is s:TCP.Segment)
                {
                    if (dir == MessageDirection.Accepts)
                    {
                        extendedEPT.localAddress = s#DestinationAddrBin is b1:binary ? b1 : EmptyBinary;
                        extendedEPT.remoteAddress = s#SourceAddrBin is b2:binary ? b2 : EmptyBinary;
                        extendedEPT.localPort = s.DestinationPort;
                        extendedEPT.remotePort = s.SourcePort;
                    }
                    else
                    {
                        extendedEPT.localAddress = s#SourceAddrBin is b1:binary ? b1 : EmptyBinary;
                        extendedEPT.remoteAddress = s#DestinationAddrBin is b2:binary ? b2 : EmptyBinary;
                        extendedEPT.localPort = s.SourcePort;
                        extendedEPT.remotePort = s.DestinationPort;
                    }
                }
            }

            requestCache = new TSGUOverHTTPDecodingCache();
            requestCache.InitializeTSGUCache(MessageDirection.Accepts, extendedEPT);
            responseCache = new TSGUOverHTTPDecodingCache();
            responseCache.InitializeTSGUCache(MessageDirection.Issues, extendedEPT);
        }
    }
}

type TSGUOverHTTPDecodingCache : StreamDecodingCache
{
    TSGU.ExtendedServer extendedEPT = null;
    void InitializeTSGUCache(MessageDirection direction, TSGU.ExtendedServer ept)
    {
        extendedEPT = ept;
        base.Initialize("TSGU", ept, direction, IsTSGUMessage, IsDataSufficient, DecodeTSGUMessage, DecodeIncompleteTSGUMessage);
    }

    optional any message DecodeIncompleteTSGUMessage(binary buffer)
    {
        if (BinaryDecoder<IncompleteTSGUOverHTTPMessage>(buffer) is m:IncompleteTSGUOverHTTPMessage)
        {
            return m as any message;
        }
        else
        {
            return nothing;
        }
    }

    optional any message DecodeTSGUMessage(stream s)
    {
        ushort packetType = PeekUShort(s, 0, Endian.Little);
        if (Direction is MessageDirection.Accepts)
        {
            switch (packetType)
            {
                case HTTP_PACKET_TYPE.PKT_TYPE_HANDSHAKE_REQUEST =>
                    return DecodeMessage<HTTP_HANDSHAKE_REQUEST_PACKET>(s);
                case HTTP_PACKET_TYPE.PKT_TYPE_EXTENDED_AUTH_MSG =>
                    return DecodeMessage<HTTP_EXTENDED_AUTH_PACKET>(s);
                case HTTP_PACKET_TYPE.PKT_TYPE_TUNNEL_CREATE =>
                    return DecodeMessage<HTTP_TUNNEL_PACKET>(s);
                case HTTP_PACKET_TYPE.PKT_TYPE_TUNNEL_AUTH =>
                    return DecodeMessage<HTTP_TUNNEL_AUTH_PACKET>(s);
                case HTTP_PACKET_TYPE.PKT_TYPE_CHANNEL_CREATE =>
                    if (BinaryDecoder<HTTP_CHANNEL_PACKET>(s) is msg:HTTP_CHANNEL_PACKET)
                    {
                        extendedEPT.tunnelPort = msg.port;
                        return msg as any message;
                    }
                    else
                    {
                        return nothing;
                    }
                    return DecodeMessage<HTTP_HANDSHAKE_RESPONSE_PACKET>(s);
                case HTTP_PACKET_TYPE.PKT_TYPE_DATA =>
                    return DecodeMessage<HTTP_DATA_PACKET>(s);
                case HTTP_PACKET_TYPE.PKT_TYPE_SERVICE_MESSAGE =>
                    return DecodeMessage<HTTP_SERVICE_MESSAGE>(s);
                case HTTP_PACKET_TYPE.PKT_TYPE_REAUTH_MESSAGE =>
                    return DecodeMessage<HTTP_REAUTH_MESSAGE>(s);
                case HTTP_PACKET_TYPE.PKT_TYPE_KEEPALIVE =>
                    return DecodeMessage<HTTP_KEEPALIVE_PACKET>(s);
                case HTTP_PACKET_TYPE.PKT_TYPE_CLOSE_CHANNEL =>
                    return DecodeMessage<HTTP_CLOSE_PACKET>(s);
                default =>
                    return nothing;
            }
        }
        else
        {
            switch (packetType)
            {
                case HTTP_PACKET_TYPE.PKT_TYPE_HANDSHAKE_RESPONSE =>
                    return DecodeMessage<HTTP_HANDSHAKE_RESPONSE_PACKET>(s);
                case HTTP_PACKET_TYPE.PKT_TYPE_EXTENDED_AUTH_MSG =>
                    return DecodeMessage<HTTP_EXTENDED_AUTH_PACKET>(s);
                case HTTP_PACKET_TYPE.PKT_TYPE_TUNNEL_RESPONSE =>
                    return DecodeMessage<HTTP_TUNNEL_RESPONSE>(s);
                case HTTP_PACKET_TYPE.PKT_TYPE_TUNNEL_AUTH_RESPONSE =>
                    return DecodeMessage<HTTP_TUNNEL_AUTH_RESPONSE>(s);
                case HTTP_PACKET_TYPE.PKT_TYPE_CHANNEL_RESPONSE =>
                    return DecodeMessage<HTTP_CHANNEL_RESPONSE>(s);
                case HTTP_PACKET_TYPE.PKT_TYPE_DATA =>
                    return DecodeMessage<HTTP_DATA_PACKET>(s);
                case HTTP_PACKET_TYPE.PKT_TYPE_SERVICE_MESSAGE =>
                    return DecodeMessage<HTTP_SERVICE_MESSAGE>(s);
                case HTTP_PACKET_TYPE.PKT_TYPE_REAUTH_MESSAGE =>
                    return DecodeMessage<HTTP_REAUTH_MESSAGE>(s);
                case HTTP_PACKET_TYPE.PKT_TYPE_KEEPALIVE =>
                    return DecodeMessage<HTTP_KEEPALIVE_PACKET>(s);
                case HTTP_PACKET_TYPE.PKT_TYPE_CLOSE_CHANNEL_RESPONSE =>
                    return DecodeMessage<HTTP_CLOSE_PACKET>(s);
                default =>
                    return nothing;
            }
        }
    }

    optional any message DecodeMessage<T>(stream s)
    {
        if (BinaryDecoder<T>(s) is msg:T)
        {
            return msg as any message;
        }
        else
        {
            return nothing;
        }
    }
}with IDL{DoNotGenerate = true}, Encoding{EncodingKind = EncodingKind.Binary};

bool IsSegmentLost(any message httpMessage)
{
    TCP.Segment seg = null;
    if ((httpMessage.Origins).Count > 0
        && (httpMessage.Origins)[0] is v:TCP.Segment)
    {
        seg = v;
    }
    return seg != null && IsTrue(seg#SegmentLost);
}

uint? IsDataSufficient(binary data)
{
    if (data.Count < 8)
    {
        return null;
    }
    else
    {
        var temp = PeekUInt(data, 32, Endian.Little) as uint;
        return (temp <= data.Count) ? 0 : temp;
    }
}

bool? IsTSGUMessage(binary data)
{
    if (data.Count < 2)
    {
        return null;
    }
    else
    {
        return (PeekUShort(data, 0, Endian.Little) is packetType:ushort) && (InRange<HTTP_PACKET_TYPE>(packetType));
    }
}

message IncompleteTSGUOverHTTPMessage
{
    HTTP_PACKET_HEADER hdr;
    binary payload;
}

// 2.2.10.2   HTTP_CHANNEL_PACKET Structure
message HTTP_CHANNEL_PACKET
{
    HTTP_PACKET_HEADER hdr where value.packetType == HTTP_PACKET_TYPE.PKT_TYPE_CHANNEL_CREATE;
    byte numResources where ValidationCheckValueInRange(value >= 1 && value <= 50, this, true, 
        ReferenceType.Message, "TSGU", "numResources", "HTTP_CHANNEL_PACKET", "1", "50", value);
    byte numAltResources where ValidationCheckValueInRange(value >= 0 && value <= 3, this, true, 
        ReferenceType.Message, "TSGU", "numAltResources", "HTTP_CHANNEL_PACKET", INFRASTRUCTURE_STR_ZERO, "3", value);
    ushort port;
    ushort $"protocol" where ValidationCheckValue(value == 3, this, true, ReferenceType.Message, 
        "TSGU", "protocol", "HTTP_CHANNEL_PACKET", "3", value);
    optional [|numResources > 0 || numAltResources > 0|] HTTP_CHANNEL_PACKET_VARIABLE[numResources, numAltResources] channelPacketVariable;

    override string ToString()
    {
        return "HTTP_CHANNEL_PACKET, " + hdr.ToString() + ", port: " + port.ToString();
    }
}with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};

// 2.2.10.4   HTTP_CHANNEL_RESPONSE Structure
message HTTP_CHANNEL_RESPONSE
{
    HTTP_PACKET_HEADER hdr where value.packetType == HTTP_PACKET_TYPE.PKT_TYPE_CHANNEL_RESPONSE;
    ReturnValuePattern errorCode;
    HTTP_CHANNEL_RESPONSE_FIELDS_PRESENT_FLAGS fieldsPresent;
    ushort reserved;
    optional [|fieldsPresent > 0|] HTTP_CHANNEL_RESPONSE_OPTIONAL[fieldsPresent] channelResponseOptional;

    override string ToString()
    {
        string summary = "HTTP_CHANNEL_RESPONSE, " + hdr.ToString() +
            ", errorCode: " + EnumToStringInSummary<ReturnValuePattern>(errorCode);
        string optionalToString;
        if (channelResponseOptional != nothing)
        {
            optionalToString = channelResponseOptional.ToString();
        }
        if (optionalToString.Count > 0)
        {
            summary += ", " + optionalToString;
        }
        return summary;
    }
}with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};

// 2.2.10.6   HTTP_DATA_PACKET Structure
message HTTP_DATA_PACKET
{
    HTTP_PACKET_HEADER hdr where value.packetType == HTTP_PACKET_TYPE.PKT_TYPE_DATA;
    ushort cbDataLen;
    array<byte> data with BinaryEncoding{Length = cbDataLen};

    override string ToString()
    {
        return "HTTP_DATA_PACKET, " + hdr.ToString();
    }
}with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};

// 2.2.10.7   HTTP_EXTENDED_AUTH_PACKET Structure
message HTTP_EXTENDED_AUTH_PACKET
{
    HTTP_PACKET_HEADER hdr where value.packetType == HTTP_PACKET_TYPE.PKT_TYPE_EXTENDED_AUTH_MSG;
    ReturnValuePattern errorCode;
    ushort cbBlobLen;
    array<byte> authBlob with BinaryEncoding{Length = cbBlobLen};

    override string ToString()
    {
        return "HTTP_EXTENDED_AUTH_PACKET, " + hdr.ToString() +
            ", errorCode: "+ EnumToStringInSummary<ReturnValuePattern>(errorCode);
    }
}with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};

// 2.2.10.8   HTTP_KEEPALIVE_PACKET Structure
message HTTP_KEEPALIVE_PACKET
{
    HTTP_PACKET_HEADER hdr where value.packetType == HTTP_PACKET_TYPE.PKT_TYPE_KEEPALIVE;

    override string ToString()
    {
        return "HTTP_KEEPALIVE_PACKET, " + hdr.ToString();
    }
}with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};

// 2.2.10.10   HTTP_HANDSHAKE_REQUEST_PACKET Structure
message HTTP_HANDSHAKE_REQUEST_PACKET
{
    HTTP_PACKET_HEADER hdr where value.packetType == HTTP_PACKET_TYPE.PKT_TYPE_HANDSHAKE_REQUEST;
    byte verMajor;
    byte verMinor;
    ushort clientVersion where ValidationCheckZero(value == 0, this, true, 
        ReferenceType.Message, "TSGU", "clientVersion", "HTTP_HANDSHAKE_REQUEST_PACKET", value);
    HTTP_EXTENDED_AUTH ExtendedAuth;

    override string ToString()
    {
        return "HTTP_HANDSHAKE_REQUEST_PACKET, " + hdr.ToString() + 
            ", verMajor: " + verMajor.ToString() + 
            ", verMinor: " + verMinor.ToString() +
            ", ExtendedAuth: " + EnumToStringInSummary<HTTP_EXTENDED_AUTH>(ExtendedAuth);
    }
}with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};

// 2.2.10.11   HTTP_HANDSHAKE_RESPONSE_PACKET Structure
message HTTP_HANDSHAKE_RESPONSE_PACKET
{
    HTTP_PACKET_HEADER hdr where value.packetType == HTTP_PACKET_TYPE.PKT_TYPE_HANDSHAKE_RESPONSE;
    ReturnValuePattern errorCode;
    byte verMajor;
    byte verMinor;
    ushort servertVersion where ValidationCheckZero(value == 0, this, true, 
        ReferenceType.Message, "TSGU", "servertVersion", "HTTP_HANDSHAKE_REQUEST_PACKET", value);
    HTTP_EXTENDED_AUTH ExtendedAuth;

    override string ToString()
    {
        return "HTTP_HANDSHAKE_RESPONSE_PACKET, " + hdr.ToString() +
            ", errorCode: " + EnumToStringInSummary<ReturnValuePattern>(errorCode) + 
            ", verMajor: " + verMajor.ToString() + 
            ", verMinor: " + verMinor.ToString() +
            ", ExtendedAuth: " + EnumToStringInSummary<HTTP_EXTENDED_AUTH>(ExtendedAuth);
    }
}with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};

// 2.2.10.12   HTTP_REAUTH_MESSAGE Structure
message HTTP_REAUTH_MESSAGE
{
    HTTP_PACKET_HEADER hdr where value.packetType == HTTP_PACKET_TYPE.PKT_TYPE_REAUTH_MESSAGE;
    ulong reauthTunnelContext;

    override string ToString()
    {
        return "HTTP_REAUTH_MESSAGE, " + hdr.ToString();
    }
}with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};

// 2.2.10.13   HTTP_SERVICE_MESSAGE Structure
message HTTP_SERVICE_MESSAGE
{
    HTTP_PACKET_HEADER hdr where value.packetType == HTTP_PACKET_TYPE.PKT_TYPE_SERVICE_MESSAGE;
    ushort cbMessageLen;
    array<byte> serviceMessage with BinaryEncoding{Length = cbMessageLen};

    override string ToString()
    {
        return "HTTP_SERVICE_MESSAGE, " + hdr.ToString();
    }
}with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};

// 2.2.10.14   HTTP_TUNNEL_AUTH_PACKET Structure
message HTTP_TUNNEL_AUTH_PACKET
{
    HTTP_PACKET_HEADER hdr where value.packetType == HTTP_PACKET_TYPE.PKT_TYPE_TUNNEL_AUTH;
    HTTP_TUNNEL_AUTH_FIELDS_PRESENT_FLAGS fieldsPresent;
    ushort cbClientName;
    string clientName with BinaryEncoding{TextEncoding = TextEncoding.Unicode, Length = (cbClientName / 2)};
    optional [|fieldsPresent > 0|] HTTP_TUNNEL_AUTH_PACKET_OPTIONAL[fieldsPresent] tunnelAuthPacketOptional;

    override string ToString()
    {
        return "HTTP_TUNNEL_AUTH_PACKET, " + hdr.ToString() + 
            ", clientName: " + clientName;
    }
}with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};

// 2.2.10.16   HTTP_TUNNEL_AUTH_RESPONSE Structure
message HTTP_TUNNEL_AUTH_RESPONSE
{
    HTTP_PACKET_HEADER hdr where value.packetType == HTTP_PACKET_TYPE.PKT_TYPE_TUNNEL_AUTH_RESPONSE;
    ReturnValuePattern errorCode;
    HTTP_TUNNEL_AUTH_RESPONSE_FIELDS_PRESENT_FLAGS fieldsPresent;
    ushort reserved;
    optional [|fieldsPresent > 0|] HTTP_TUNNEL_AUTH_RESPONSE_OPTIONAL[fieldsPresent] tunnelAuthResponseOptional;

    override string ToString()
    {
        string summary = "HTTP_TUNNEL_AUTH_RESPONSE, " + hdr.ToString() +
            ", errorCode: " + EnumToStringInSummary<ReturnValuePattern>(errorCode);
        string optionalToString;
        if (tunnelAuthResponseOptional != nothing)
        {
            optionalToString = tunnelAuthResponseOptional.ToString();
        }
        if (optionalToString.Count > 0)
        {
            summary += ", " + optionalToString;
        }
        return summary;
    }
}with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};

// 2.2.10.18   HTTP_TUNNEL_PACKET Structure
message HTTP_TUNNEL_PACKET
{
    HTTP_PACKET_HEADER hdr where value.packetType == HTTP_PACKET_TYPE.PKT_TYPE_TUNNEL_CREATE;
    HTTP_CAPABILITY_TYPE capsFlags;
    HTTP_TUNNEL_PACKET_FIELDS_PRESENT_FLAGS fieldsPresent;
    ushort reserved;
    optional [|fieldsPresent > 0|] HTTP_TUNNEL_PACKET_OPTIONAL[fieldsPresent] tunnelPacketOptional;

    override string ToString()
    {
        return "HTTP_TUNNEL_PACKET, " + hdr.ToString() + 
            ", capsFlags: " + EnumToStringInSummary<HTTP_CAPABILITY_TYPE>(capsFlags);
    }
}with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};

// 2.2.10.20   HTTP_TUNNEL_RESPONSE Structure
message HTTP_TUNNEL_RESPONSE
{
    HTTP_PACKET_HEADER hdr where value.packetType == HTTP_PACKET_TYPE.PKT_TYPE_TUNNEL_RESPONSE;
    ushort serverVersion;
    ReturnValuePattern statusCode;
    HTTP_TUNNEL_RESPONSE_FIELDS_PRESENT_FLAGS fieldsPresent;
    ushort reserved;
    optional [|fieldsPresent > 0|] HTTP_TUNNEL_RESPONSE_OPTIONAL[fieldsPresent] tunnelResponseOptional;

    override string ToString()
    {
        string summary = "HTTP_TUNNEL_RESPONSE, " + hdr.ToString() +
            ", statusCode: " + EnumToStringInSummary<ReturnValuePattern>(statusCode) +
            ", serverVersion:" + serverVersion.ToString();
        string optionalToString;
        if (tunnelResponseOptional != nothing)
        {
            optionalToString = tunnelResponseOptional.ToString();
        }
        if (optionalToString.Count > 0)
        {
            summary += ", " + optionalToString;
        }
        return summary;
    }
}with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};

// 2.2.10.23   HTTP_CLOSE_PACKET Structure
message HTTP_CLOSE_PACKET
{
    HTTP_PACKET_HEADER hdr where value.packetType == HTTP_PACKET_TYPE.PKT_TYPE_CLOSE_CHANNEL || value.packetType == HTTP_PACKET_TYPE.PKT_TYPE_CLOSE_CHANNEL_RESPONSE;
    ReturnValuePattern statusCode;

    override string ToString()
    {
        return "HTTP_CLOSE_PACKET, " + hdr.ToString() +
            ", statusCode: " + EnumToStringInSummary<ReturnValuePattern>(statusCode);
    }
}with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};

// 2.2.10.1   HTTP_byte_BLOB Structure
type HTTP_byte_BLOB
{
    ushort cbLen;
    array<byte> blob with BinaryEncoding{Length = cbLen};
}with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};

// 2.2.10.3   HTTP_CHANNEL_PACKET_VARIABLE Structure
type HTTP_CHANNEL_PACKET_VARIABLE [byte NumResources, byte NumAltResources]
{
    array<HTTP_UNICODE_STRING> pResource with BinaryEncoding{Length = NumResources};
    array<HTTP_UNICODE_STRING> pAltResources with BinaryEncoding{Length = NumAltResources};
}with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};

// 2.2.10.5   HTTP_CHANNEL_RESPONSE_OPTIONAL Structure
type HTTP_CHANNEL_RESPONSE_OPTIONAL[HTTP_CHANNEL_RESPONSE_FIELDS_PRESENT_FLAGS FieldsPresent]
{
    optional [|(FieldsPresent & HTTP_CHANNEL_RESPONSE_FIELDS_PRESENT_FLAGS.HTTP_CHANNEL_RESPONSE_FIELD_CHANNELID) > 0|] 
        uint channelId;
    optional [|(FieldsPresent & HTTP_CHANNEL_RESPONSE_FIELDS_PRESENT_FLAGS.HTTP_CHANNEL_RESPONSE_FIELD_UDPPORT) > 0|] 
        ushort udpPort;
    optional [|(FieldsPresent & HTTP_CHANNEL_RESPONSE_FIELDS_PRESENT_FLAGS.HTTP_CHANNEL_RESPONSE_FIELD_AUTHNCOOKIE) > 0|] 
        HTTP_byte_BLOB authnCookie;
    override string ToString()
    {
        string summary = "";
        if (channelId != nothing)
        {
            summary += "channelId: " + channelId.ToString() + ", ";
        }
        if (udpPort != nothing)
        {
            summary += "udpPort: " + udpPort.ToString() + ", ";
        }
        return summary.Count > 2 ? summary.Segment(0 , summary.Count - 2) : summary;
    }
}with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};

// 2.2.10.9   HTTP_PACKET_HEADER Structure
type HTTP_PACKET_HEADER
{
    HTTP_PACKET_TYPE packetType;
    ushort headerReserved;
    uint packetLength;

    override string ToString()
    {
        return "packetType: " + EnumToStringInSummary<HTTP_PACKET_TYPE>(packetType) + ", packetLength: " + packetLength.ToString();
    }
}with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};

// 2.2.10.15   HTTP_TUNNEL_AUTH_PACKET_OPTIONAL Structure
type HTTP_TUNNEL_AUTH_PACKET_OPTIONAL[HTTP_TUNNEL_AUTH_FIELDS_PRESENT_FLAGS FieldsPresent]
{
    // HTTP_UNICODE_STRING clientName; // TDI?
    optional [|(FieldsPresent & HTTP_TUNNEL_AUTH_FIELDS_PRESENT_FLAGS.HTTP_TUNNEL_AUTH_FIELD_SOH) > 0|] 
        HTTP_byte_BLOB statementOfHealth;
}with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};

// 2.2.10.17   HTTP_TUNNEL_AUTH_RESPONSE_OPTIONAL Structure
type HTTP_TUNNEL_AUTH_RESPONSE_OPTIONAL[HTTP_TUNNEL_AUTH_RESPONSE_FIELDS_PRESENT_FLAGS FieldsPresent]
{
    optional [|(FieldsPresent & HTTP_TUNNEL_AUTH_RESPONSE_FIELDS_PRESENT_FLAGS.HTTP_TUNNEL_AUTH_RESPONSE_FIELD_REDIR_FLAGS) > 0|] 
        HTTP_TUNNEL_REDIR_FLAGS redirFlags;
    optional [|(FieldsPresent & HTTP_TUNNEL_AUTH_RESPONSE_FIELDS_PRESENT_FLAGS.HTTP_TUNNEL_AUTH_RESPONSE_FIELD_IDLE_TIMEOUT) > 0|] 
        uint idleTimeout;
    optional [|(FieldsPresent & HTTP_TUNNEL_AUTH_RESPONSE_FIELDS_PRESENT_FLAGS.HTTP_TUNNEL_AUTH_RESPONSE_FIELD_SOH_RESPONSE) > 0|]
        HTTP_byte_BLOB SoHResponse;
    override string ToString()
    {
        string summary = "";
        if (redirFlags is redir:HTTP_TUNNEL_REDIR_FLAGS)
        {
            summary += "redirFlags: " + EnumToStringInSummary<HTTP_TUNNEL_REDIR_FLAGS>(redir) + ", ";
        }
        if (idleTimeout != nothing)
        {
            summary += "idleTimeout: " + idleTimeout.ToString() + ", ";
        }
        return summary.Count > 2 ? summary.Segment(0 , summary.Count - 2) : summary;
    }
}with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};

// 2.2.10.19   HTTP_TUNNEL_PACKET_OPTIONAL Structure
type HTTP_TUNNEL_PACKET_OPTIONAL[HTTP_TUNNEL_PACKET_FIELDS_PRESENT_FLAGS FieldsPresent]
{
    optional [|(FieldsPresent & HTTP_TUNNEL_PACKET_FIELDS_PRESENT_FLAGS.HTTP_TUNNEL_PACKET_FIELD_REAUTH) > 0|] 
        ulong reauthTunnelContext;
    optional [|(FieldsPresent & HTTP_TUNNEL_PACKET_FIELDS_PRESENT_FLAGS.HTTP_TUNNEL_PACKET_FIELD_PAA_COOKIE) > 0|] 
        HTTP_byte_BLOB PAACookie;
}with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};

// 2.2.10.21   HTTP_TUNNEL_RESPONSE_OPTIONAL Structure
type HTTP_TUNNEL_RESPONSE_OPTIONAL[HTTP_TUNNEL_RESPONSE_FIELDS_PRESENT_FLAGS FieldsPresent]
{
    optional [|(FieldsPresent & HTTP_TUNNEL_RESPONSE_FIELDS_PRESENT_FLAGS.HTTP_TUNNEL_RESPONSE_FIELD_TUNNEL_ID) > 0|] 
        uint tunnelId;
    optional [|(FieldsPresent & HTTP_TUNNEL_RESPONSE_FIELDS_PRESENT_FLAGS.HTTP_TUNNEL_RESPONSE_FIELD_CAPS) > 0|] 
        HTTP_CAPABILITY_TYPE capsFlags;
    optional [|(FieldsPresent & HTTP_TUNNEL_RESPONSE_FIELDS_PRESENT_FLAGS.HTTP_TUNNEL_RESPONSE_FIELD_SOH_REQ) > 0|] 
        guid nonce with BinaryEncoding{Length = 20};
    optional [|(FieldsPresent & HTTP_TUNNEL_RESPONSE_FIELDS_PRESENT_FLAGS.HTTP_TUNNEL_RESPONSE_FIELD_SOH_REQ) > 0|] 
        HTTP_UNICODE_STRING serverCert;
    optional [|(FieldsPresent & HTTP_TUNNEL_RESPONSE_FIELDS_PRESENT_FLAGS.HTTP_TUNNEL_RESPONSE_FIELD_CONSENT_MSG) > 0|] 
        HTTP_UNICODE_STRING consentMsg;
    override string ToString()
    {
        string summary = "";
        if (tunnelId != nothing)
        {
            summary += "tunnelId: " + tunnelId.ToString() + ", ";
        }
        if (nonce != nothing)
        {
            summary += "nonce: " + nonce.ToString() + ", ";
        }
        if (capsFlags is caps:HTTP_CAPABILITY_TYPE)
        {
            summary += "capsFlags: " + EnumToStringInSummary<HTTP_CAPABILITY_TYPE>(caps) + ", ";
        }
        return summary.Count > 2 ? summary.Segment(0 , summary.Count - 2) : summary;
    }
}with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};

// 2.2.10.22   HTTP_UNICODE_STRING 
type HTTP_UNICODE_STRING
{
    ushort cbLen;
    string str with BinaryEncoding{TextEncoding = TextEncoding.Unicode, Length = (cbLen / 2)};
    override string ToString()
    {
        return str;
    }
}with Encoding{EncodingKind = EncodingKind.Binary}, IDL{DoNotGenerate = true};

// 2.2.5.3.1   HTTP_CHANNEL_RESPONSE_FIELDS_PRESENT_FLAGS Enumeration
pattern HTTP_CHANNEL_RESPONSE_FIELDS_PRESENT_FLAGS = flags short
{
    HTTP_CHANNEL_RESPONSE_FIELD_CHANNELID = 0x01
        with Documentation
            {Description = "This constant is used to represent that the structure contains the channelId field, as specified in section."},
    HTTP_CHANNEL_RESPONSE_FIELD_AUTHNCOOKIE = 0x02
        with Documentation
            {Description = "This constant is used to represent that the HTTP_CHANNEL_RESPONSE_OPTIONAL structure contains the authnCookie field that describes the UDP authentication cookie."},
    HTTP_CHANNEL_RESPONSE_FIELD_UDPPORT = 0x04
        with Documentation
            {Description = "This constant is used to represent that the HTTP_CHANNEL_RESPONSE_OPTIONAL structure contains the udpPort field."},
    ...
};

// 2.2.5.3.2   HTTP_EXTENDED_AUTH Enumeration
pattern HTTP_EXTENDED_AUTH  = enum short
{
    HTTP_EXTENDED_AUTH_NONE = 0x00,
    HTTP_EXTENDED_AUTH_SC = 0x01,
    HTTP_EXTENDED_AUTH_PAA = 0x02,
    ...
};

// 2.2.5.3.3   HTTP_PACKET_TYPE Enumeration
pattern HTTP_PACKET_TYPE = enum ushort
{
    PKT_TYPE_HANDSHAKE_REQUEST = 0x01,
    PKT_TYPE_HANDSHAKE_RESPONSE = 0x02,
    PKT_TYPE_EXTENDED_AUTH_MSG = 0x03,
    PKT_TYPE_TUNNEL_CREATE = 0x04,
    PKT_TYPE_TUNNEL_RESPONSE = 0x05,
    PKT_TYPE_TUNNEL_AUTH = 0x06,
    PKT_TYPE_TUNNEL_AUTH_RESPONSE = 0x07,
    PKT_TYPE_CHANNEL_CREATE = 0x08,
    PKT_TYPE_CHANNEL_RESPONSE = 0x09,
    PKT_TYPE_DATA = 0xA,
    PKT_TYPE_SERVICE_MESSAGE = 0xB,
    PKT_TYPE_REAUTH_MESSAGE = 0xC,
    PKT_TYPE_KEEPALIVE = 0xD,
    PKT_TYPE_CLOSE_CHANNEL = 0x10,
    PKT_TYPE_CLOSE_CHANNEL_RESPONSE = 0x11,
    ...
};

// 2.2.5.3.4   HTTP_TUNNEL_AUTH_FIELDS_PRESENT_FLAGS Enumeration
pattern HTTP_TUNNEL_AUTH_FIELDS_PRESENT_FLAGS  = flags short
{
    HTTP_TUNNEL_AUTH_FIELD_SOH = 0x01
        with Documentation
            {Description = "This constant represents that the structure contains the statementOfHealth field."},
    ...
};

// 2.2.5.3.5   HTTP_TUNNEL_AUTH_RESPONSE_FIELDS_PRESENT_FLAGS Enumeration
pattern HTTP_TUNNEL_AUTH_RESPONSE_FIELDS_PRESENT_FLAGS  = flags short
{
    HTTP_TUNNEL_AUTH_RESPONSE_FIELD_REDIR_FLAGS = 0x01
        with Documentation
            {Description = "This constant represents that contains the redirFlags field."},
    HTTP_TUNNEL_AUTH_RESPONSE_FIELD_IDLE_TIMEOUT = 0x02
        with Documentation
            {Description = "This constant represents that HTTP_TUNNEL_AUTH_RESPONSE_OPTIONAL contains the idleTimeout field."},
    HTTP_TUNNEL_AUTH_RESPONSE_FIELD_SOH_RESPONSE = 0x04
        with Documentation
            {Description = "This constant represents that HTTP_TUNNEL_AUTH_RESPONSE_OPTIONAL contains the SoHResponse field."},
    ...
};

// 2.2.5.3.6   HTTP_TUNNEL_PACKET_FIELDS_PRESENT_FLAGS Enumeration
pattern HTTP_TUNNEL_PACKET_FIELDS_PRESENT_FLAGS   = flags ushort
{
    HTTP_TUNNEL_PACKET_FIELD_PAA_COOKIE = 0x01
        with Documentation
            {Description = "This constant represents that contains the PAACookie field."},
    HTTP_TUNNEL_PACKET_FIELD_REAUTH = 0x02
        with Documentation
            {Description = "This constant represents that HTTP_TUNNEL_PACKET_OPTIONAL contains the reauthTunnelContext field."},
    ...
};

// 2.2.5.3.7   HTTP_TUNNEL_REDIR_FLAGS Enumeration
pattern HTTP_TUNNEL_REDIR_FLAGS = flags uint
{
    HTTP_TUNNEL_REDIR_ENABLE_ALL = 0x80000000
        with Documentation
            {Description = "This constant represents that device redirection is enabled for all devices."},
    HTTP_TUNNEL_REDIR_DISABLE_ALL = 0x40000000
        with Documentation
            {Description = "This constant represents that device redirection is disabled for all devices."},
    HTTP_TUNNEL_REDIR_DISABLE_DRIVE = 0x01
        with Documentation
            {Description = "This constant represents that drive redirection is disabled."},
    HTTP_TUNNEL_REDIR_DISABLE_PRINTER = 0x02
        with Documentation
            {Description = "This constant represents that printer redirection is disabled."},
    HTTP_TUNNEL_REDIR_DISABLE_PORT = 0x04
        with Documentation
            {Description = "This constant represents that port redirection is disabled."},
    HTTP_TUNNEL_REDIR_DISABLE_CLIPBOARD = 0x08
        with Documentation
            {Description = "This constant represents that clibboard redirection is disabled."},
    HTTP_TUNNEL_REDIR_DISABLE_PNP = 0x10
        with Documentation
            {Description = "This constant represents that PnP redirection is disabled."},
    ...
};

// 2.2.5.3.8   HTTP_TUNNEL_RESPONSE_FIELDS_PRESENT_FLAGS Enumeration
pattern HTTP_TUNNEL_RESPONSE_FIELDS_PRESENT_FLAGS = flags ushort
{
    HTTP_TUNNEL_RESPONSE_FIELD_TUNNEL_ID = 0x01
        with Documentation
            {Description = "This constant represents that contains the tunnelId field."},
    HTTP_TUNNEL_RESPONSE_FIELD_CAPS = 0x02
        with Documentation
            {Description = "This constant represents that HTTP_TUNNEL_RESPONSE_OPTIONAL contains the capsFlags field."},
    HTTP_TUNNEL_RESPONSE_FIELD_SOH_REQ = 0x04
        with Documentation
            {Description = "This constant represents that HTTP_TUNNEL_RESPONSE_OPTIONAL contains the nonce and the serverCert fields."},
    HTTP_TUNNEL_RESPONSE_FIELD_CONSENT_MSG = 0x10
        with Documentation
            {Description = "This constant represents that HTTP_TUNNEL_RESPONSE_OPTIONAL contains the consentMsg field."},
    ...
};

// 2.2.5.3.9   HTTP_CAPABILITY_TYPE Enumeration
pattern HTTP_CAPABILITY_TYPE = flags uint
{
    HTTP_CAPABILITY_TYPE_QUAR_SOH = 0x01
        with Documentation
            {Description = "This constant represents whether the RDG client or the RDG server is NAP capable."},
    HTTP_CAPABILITY_IDLE_TIMEOUT = 0x02
        with Documentation
            {Description = "This constant represents whether the RDG client or the RDG server supports idle timeout."},
    HTTP_CAPABILITY_MESSAGING_CONSENT_SIGN = 0x04
        with Documentation
            {Description = "This constant represents whether the RDG client or the RDG server supports consent messaging."},
    HTTP_CAPABILITY_MESSAGING_SERVICE_MSG = 0x08
        with Documentation
            {Description = "This constant represents whether the RDG client or the RDG server supports service messaging."},
    HTTP_CAPABILITY_REAUTH = 0x10
        with Documentation
            {Description = "This constant represents whether the RDG client or the RDG server supports reauthentication."},
    HTTP_CAPABILITY_UDP_TRANSPORT = 0x20
        with Documentation
            {Description = "This constant represents whether the RDG client or the RDG server supports UDP transport."},
    ...
};

bool CheckIfTSGUMsgAndGetData(ref TransportTypePatt transportType, any message msg, ref binary bin, bool isAccept)
{
    if (transportType == TransportTypePatt.HTTPS)
    {
        if (msg is tsguHttp:TSGU.HTTP_DATA_PACKET)
        {
            bin = tsguHttp.data as binary;
            return true;
        }
        else
        {
            return false;
        }
    }
    else if (transportType == TransportTypePatt.RPC)
    {
        if (isAccept && msg is tsguRpc:TSGU.TsProxySendToServerRequest)
        {
            bin = GetAllBufferData(tsguRpc);
            return true;
        }
        else if (!isAccept && msg is tsguRpcRes:TSGU.TsProxySetupReceivePipeResponse && tsguRpcRes.data is dataTmp:binary)
        {
            bin = dataTmp;
            return true;
        }
        else
        {
            return false;
        }
    }
    else
    {
        if (msg is tsguHttp:TSGU.HTTP_DATA_PACKET)
        {
            bin = tsguHttp.data as binary;
            transportType = TransportTypePatt.HTTPS;
            return true;
        }
        else if (isAccept && (msg is tsguRpc:TSGU.TsProxySendToServerRequest))
        {
            bin = GetAllBufferData(tsguRpc);
            transportType = TransportTypePatt.RPC;
            return true;
        }
        else if (!isAccept && msg is tsguRpcRes:TSGU.TsProxySetupReceivePipeResponse && tsguRpcRes.data is dataTmp:binary)
        {
            bin = dataTmp;
            transportType = TransportTypePatt.RPC;
            return true;
        }
        else
        {
            return false;
        }
    }
}

pattern TransportTypePatt = enum byte
{
    Unknown = 0,
    HTTPS = 1,
    RPC = 2,
    ...
};

pattern ConnectionStatus = enum byte
{
    ConnectionNotReady = 0,
    ConnectionSetup = 1, // HTTP reponse with status code 200 received
    FirstFrameParsed = 2, // the frist frame after connection setup is possible be the random entity body
};

const binary EmptyBinary = $[];
const string EmptyString = "";
