protocol WSMV with 
XmlEncodingDefaults{Namespace = WSMVShellNamespace},
Documentation
{
    ProtocolName = "Web Services Management Protocol Extensions for Windows Vista",
    ShortName = "WSMV",
    Description = ""
},
OPNAuthoring
{
    Copyright = "(c) Microsoft Corporation",
    References = 
        [
            new Reference{Name = "MS-WSMV", Version = "27.0", Date = "02/13/2014", ProgramName = ProgramName.MCPP},
        ],
    RevisionSummary =
        [
            new Revision{Class=RevisionClass.Major, Version="376094", Date="03/30/2015"},
        ]
};

using Standard;
using Utility;
using SOAP;
using Technologies.SOAP;
using XSD;
using WSTransfer;
using WSManagement;
using WSEventing;
using WSEnumeration;
using WSA2004;
using WSA2005;


endpoint WSMVIntermediateServer 
    over SOAP.Server 
    provides mutable WSMVMessages
    consumes mutable WSMVOperations;
client endpoint WSMVIntermediateClient connected to WSMVIntermediateServer;

autostart actor WSMVOverSOAP(SOAP.Server node)
{
    // Command request
    process node accepts soap:SOAP.SoapMessage where soap.WsaAction == WSMVCommandAction
    {
        switch (soap.Body)
        {
            case m:WSMVMessages.CommandRequest from XmlDecoder<WSMVMessages.CommandRequest> =>
                var server = endpoint WSMVIntermediateServer over node;
                dispatch server accepts m;
            default =>
                ThrowDecodingException(WSMVProtocolName, "Command Request");
        }    
    }   
    
    // Command response
    process node issues soap:SOAP.SoapMessage where soap.WsaAction == WSMVCommandResponseAction
    {
        switch (soap.Body)
        {
            case m:WSMVMessages.CommandResponse from XmlDecoder<WSMVMessages.CommandResponse> =>
                var server = endpoint WSMVIntermediateServer over node;
                dispatch server issues m;
            default =>
                ThrowDecodingException(WSMVProtocolName, "Command Response");
        }    
    }   
       
    // Send request
    process node accepts soap:SOAP.SoapMessage where soap.WsaAction == WSMVSendAction
    {
        switch (soap.Body)
        {
            case m:WSMVMessages.SendRequest from XmlDecoder<WSMVMessages.SendRequest> =>
                string shellId = GetShellIdFromSoapHeader(soap);
                if (shellId in CompressionTypePerShellId)
                {
                    m#CompressionType = CompressionTypePerShellId[shellId];
                }
                var server = endpoint WSMVIntermediateServer over node;
                dispatch server accepts m;
            default =>
                ThrowDecodingException(WSMVProtocolName, "Send Request");
        }    
    }   
    
    // Send response
    process node issues soap:SOAP.SoapMessage where soap.WsaAction == WSMVSendResponseAction
    {
        switch (soap.Body)
        {
            case m:WSMVMessages.SendResponse from XmlDecoder<WSMVMessages.SendResponse> =>
                var server = endpoint WSMVIntermediateServer over node;
                dispatch server issues m;
            default =>
                ThrowDecodingException(WSMVProtocolName, "Send Response");
        }    
    }     
     
    string ReceiveResponseCompressionType = "";
    
    // Receive request
    process node accepts soap:SOAP.SoapMessage where soap.WsaAction == WSMVReceiveAction
    {
        switch (soap.Body)
        {
            case m:WSMVMessages.ReceiveRequest from XmlDecoder<WSMVMessages.ReceiveRequest> =>
                string shellId = GetShellIdFromSoapHeader(soap);
                ReceiveResponseCompressionType = (shellId in CompressionTypePerShellId) ? CompressionTypePerShellId[shellId] : "";
                var server = endpoint WSMVIntermediateServer over node;
                dispatch server accepts m;
            default =>
                ThrowDecodingException(WSMVProtocolName, "Receive Request");
        }    
    }   
    
    // Receive response
    process node issues soap:SOAP.SoapMessage where soap.WsaAction == WSMVReceiveResponseAction
    {
        switch (soap.Body)
        {
            case m:WSMVMessages.ReceiveResponse from XmlDecoder<WSMVMessages.ReceiveResponse> =>
                if (ReceiveResponseCompressionType != "")
                {
                    m#CompressionType = ReceiveResponseCompressionType;
                    ReceiveResponseCompressionType = "";
                }
                var server = endpoint WSMVIntermediateServer over node;
                dispatch server issues m;
            default =>
                ThrowDecodingException(WSMVProtocolName, "Receive Response");
        }    
    }  
    
    // Connect request
    process node accepts soap:SOAP.SoapMessage where soap.WsaAction == WSMVConnectAction
    {
        switch (soap.Body)
        {
            case m:WSMVMessages.ConnectRequest from XmlDecoder<WSMVMessages.ConnectRequest> =>
                var server = endpoint WSMVIntermediateServer over node;
                dispatch server accepts m;
            default =>
                ThrowDecodingException(WSMVProtocolName, "Connect Request");
        }    
    }   
    
    // Connect response
    process node issues soap:SOAP.SoapMessage where soap.WsaAction == WSMVConnectResponseAction
    {
        switch (soap.Body)
        {
            case m:WSMVMessages.ConnectResponse from XmlDecoder<WSMVMessages.ConnectResponse> =>
                var server = endpoint WSMVIntermediateServer over node;
                dispatch server issues m;
            default =>
                ThrowDecodingException(WSMVProtocolName, "Connect Response");
        }    
    }  
    
    // Signal request
    process node accepts soap:SOAP.SoapMessage where soap.WsaAction == WSMVSignalAction
    {
        switch (soap.Body)
        {
            case m:WSMVMessages.SignalRequest from XmlDecoder<WSMVMessages.SignalRequest> =>
                var server = endpoint WSMVIntermediateServer over node;
                dispatch server accepts m;
            default =>
                ThrowDecodingException(WSMVProtocolName, "Signal Request");
        }    
    }   
    
    // Signal response
    process node issues soap:SOAP.SoapMessage where soap.WsaAction == WSMVSignalResponseAction
    {
        switch (soap.Body)
        {
            case m:WSMVMessages.SignalResponse from XmlDecoder<WSMVMessages.SignalResponse> =>
                var server = endpoint WSMVIntermediateServer over node;
                dispatch server issues m;
            default =>
                ThrowDecodingException(WSMVProtocolName, "Signal Response");
        }    
    }  
    
    // Disconnect request
    process node accepts soap:SOAP.SoapMessage where soap.WsaAction == WSMVDisconnectAction
    {
        switch (soap.Body)
        {
            case m:WSMVMessages.DisconnectRequest from XmlDecoder<WSMVMessages.DisconnectRequest> =>
                var server = endpoint WSMVIntermediateServer over node;
                dispatch server accepts m;
            default =>
                ThrowDecodingException(WSMVProtocolName, "Disconnect Request");
        }    
    }   
    
    // Disconnect response
    process node issues soap:SOAP.SoapMessage where soap.WsaAction == WSMVDisconnectResponseAction
    {
        WSMVMessages.DisconnectResponse m = new WSMVMessages.DisconnectResponse{}; 
        var server = endpoint WSMVIntermediateServer over node;
        dispatch server issues m;
    }
    
    // Reconnect request
    process node accepts soap:SOAP.SoapMessage where soap.WsaAction == WSMVReconnectAction
    {
        WSMVMessages.ReconnectRequest m = new WSMVMessages.ReconnectRequest{}; 
        var server = endpoint WSMVIntermediateServer over node;
        dispatch server accepts m;
    }   
    
    // Reconnect response
    process node issues soap:SOAP.SoapMessage where soap.WsaAction == WSMVReconnectResponseAction
    {
        WSMVMessages.ReconnectResponse m = new WSMVMessages.ReconnectResponse{}; 
        var server = endpoint WSMVIntermediateServer over node;
        dispatch server issues m;
    }
    
    // Acknowledge Request
    process node accepts soap:SOAP.SoapMessage where soap.WsaAction == WSMVAcknowledgeRequestAction
    {
        WSMVMessages.AcknowledgeRequest m = new WSMVMessages.AcknowledgeRequest{}; 
        var server = endpoint WSMVIntermediateServer over node;
        dispatch server accepts m;
    }   
    
    // Acknowledge Response
    process node issues soap:SOAP.SoapMessage where soap.WsaAction == WSMVAcknowledgeAction
    {
        switch (soap.Body)
        {
            case m:WSMVMessages.AcknowledgeResponse from XmlDecoder<WSMVMessages.AcknowledgeResponse> =>
                var server = endpoint WSMVIntermediateServer over node;
                dispatch server issues m;
            default =>
                ThrowDecodingException(WSMVProtocolName, "Acknowledge Response");
        }    
    }
    
    // Interactive Response
    process node issues soap:SOAP.SoapMessage where soap.WsaAction == WSMVInteractiveResponseAction
    {
        switch (soap.Body)
        {
            case m:WSMVMessages.InteractiveResponse from XmlDecoder<WSMVMessages.InteractiveResponse> =>
                var server = endpoint WSMVIntermediateServer over node;
                dispatch server issues m;
            default =>
                ThrowDecodingException(WSMVProtocolName, "Interactive Response");
        }    
    }
    
    // End Request
    process node accepts soap:SOAP.SoapMessage where soap.WsaAction == WSMVEndAction
    {
        WSMVMessages.EndRequest m = new WSMVMessages.EndRequest{}; 
        var server = endpoint WSMVIntermediateServer over node;
        dispatch server accepts m;
    }   
    
    // Cancel Request
    process node accepts soap:SOAP.SoapMessage where soap.WsaAction == WSMVCancelAction
    {
        WSMVMessages.CancelRequest m = new WSMVMessages.CancelRequest{}; 
        var server = endpoint WSMVIntermediateServer over node;
        dispatch server accepts m;
    }   
    
    // KeepAlive Request
    process node accepts soap:SOAP.SoapMessage where soap.WsaAction == WSMVKeepAliveAction
    {
        WSMVMessages.KeepAliveRequest m = new WSMVMessages.KeepAliveRequest{}; 
        var server = endpoint WSMVIntermediateServer over node;
        dispatch server accepts m;
    }   
}

string GetShellIdFromSoapHeader(SoapMessage soap)
{
    if (soap.Header is header:xml 
        && header.GetChild(new XmlName{LocalName = "SelectorSet", NamespaceUri = WSManagementNamespace}) is selectorSet:xml)
    {
        XmlName nameXmlName = new XmlName{LocalName = "Name", NamespaceUri = ""};
        foreach (xml child in selectorSet.GetChildren(new XmlName{LocalName = "Selector", NamespaceUri = WSManagementNamespace}))
        {
            if (child.GetAttribute(nameXmlName) is attr:xml && attr.Value == "ShellId"
                && child.InnerXml is id:string)
            {
                return id;  
            }
        }
    }
    return "";
}

// Extensions to WSTransfer
autostart actor WSMVExtendingWSTransfer(WSTransfer.ResourceIntermidiateEndpoint server) follows WSManExtendingWsTransfer
{
    string getRequestResourceUri = "";
    
    observe server accepts getRequest:WSTransfer.ResourceMessageContract.GetResourceRequest
    {
        getRequestResourceUri = (getRequest.Origins[0] as SoapMessage).ResourceURI;
    }
    
    observe server issues getResponse:WSTransfer.ResourceMessageContract.GetResourceResponse where (getResponse.AnyElement.Value is x:xml) && (x != null) && !(getResponse.AnyElement is XmlWrapperEx)
    {
        string resourceUri = (getResponse.Origins[0] as SoapMessage).ResourceURI;
        
        if (DecodeWSMVExtendedGetResponse(x, getResponse, resourceUri.Count == 0 ? getRequestResourceUri : resourceUri) is wrapper:XmlWrapperWSMVEx)
        {
            getResponse.AnyElement = wrapper;
            AppendWSMVExtensionSummary(getResponse);
        }
        getRequestResourceUri = "";
    }
    
    string putRequestResourceUri = "";
    
    observe server accepts putRequest:WSTransfer.ResourceMessageContract.PutResourceRequest where (putRequest.AnyElement.Value is x:xml) && (x != null) && !(putRequest.AnyElement is XmlWrapperEx)
    {
        putRequestResourceUri = (putRequest.Origins[0] as SoapMessage).ResourceURI;
        
        if (DecodeWSMVExtendedPutRequest(x, putRequest, putRequestResourceUri) is wrapper:XmlWrapperWSMVEx)
        {
            putRequest.AnyElement = wrapper;
            AppendWSMVExtensionSummary(putRequest);
        }
    }
    
    observe server issues putResponse:WSTransfer.ResourceMessageContract.PutResourceResponse where (putResponse.AnyOptionalElement is w:XmlWrapper) && (w.Value is x:xml) && (x != null) && !(w is XmlWrapperEx)
    {
        string resourceUri = (putResponse.Origins[0] as SoapMessage).ResourceURI;
             
        if (DecodeWSMVExtendedPutResponse(x, putResponse, resourceUri.Count == 0 ? putRequestResourceUri : resourceUri) is wrapper:XmlWrapperWSMVEx)
        {
            putResponse.AnyOptionalElement = wrapper;
            AppendWSMVExtensionSummary(putResponse);
        }
        putRequestResourceUri = "";
    }
    
    // WSMV clients MAY send the optional SOAP header CompressionType as part of a Create request for a remote shell 
    // to indicate that the data sent as part of the ensuing Send and ReceiveResponse messages will be compressed
    string compressionType = "";
    
    observe server accepts createRequest:WSTransfer.ResourceFactoryMessageContract.CreateRequest where (createRequest.AnyElement.Value is x:xml) && (x != null) && !(createRequest.AnyElement is XmlWrapperEx)
    {
        if (DecodeWSMVExtendedCreateRequest(x, createRequest, (createRequest.Origins[0] as SoapMessage).ResourceURI) is wrapper:XmlWrapperWSMVEx)
        {
            createRequest.AnyElement = wrapper;
            AppendWSMVExtensionSummary(createRequest);
        }
        if (createRequest.Origins[0] is soapMsg:SoapMessage && soapMsg.Header is header:xml
            && header.GetChild(new XmlName{LocalName = "CompressionType", NamespaceUri = WSMVShellNamespace}) is ct:xml
            && ct.InnerXml is c:string)
        {
            compressionType = c;
        }
        else
        {
            compressionType = "";
        }
    }
    
    observe server issues createResponse:WSTransfer.ResourceFactoryMessageContract.CreateResponse 
        where (createResponse.AnyOptionalElement is wrapper:XmlWrapper) && (wrapper.Value is x:xml) && (x != null) && !(wrapper is XmlWrapperEx)
    {
        bool decodeSucceed = false;
        if (wrapper.Value.Name is xmlName:XmlName && xmlName.NamespaceUri == WSMVShellNamespace && xmlName.LocalName == "Shell")
        {
            XmlWrapperWSMVEx element = new XmlWrapperWSMVEx{};
            element.Shell = DecodeElementAndValidationCheck<Shell>(createResponse, wrapper.Value, WSMVProtocolName, "Shell", ref decodeSucceed);
            if (decodeSucceed)
            {
                createResponse.AnyOptionalElement = element;
                AppendWSMVExtensionSummary(createResponse);
                if (compressionType != "" && (element.Shell as Shell).ShellId is s:string)
                {
                    CompressionTypePerShellId[s] = compressionType;
                    compressionType = "";
                }
            }
        }
    }
    
    observe server accepts deleteRequest:ResourceMessageContract.DeleteResourceRequest
    {
        string shellId = GetShellIdFromSoapHeader(deleteRequest.Origins[0] as SoapMessage);
        if (shellId in CompressionTypePerShellId)
        {
            CompressionTypePerShellId = CompressionTypePerShellId.Remove(shellId);
        }
    }
}

optional XmlWrapperWSMVEx DecodeWSMVExtendedCreateRequest(xml body, any message msg, string resourceUri)
{
    XmlWrapperWSMVEx element = new XmlWrapperWSMVEx{};
    bool decodeSucceed = false;
    switch (resourceUri)
    {
        case CertMappingResourceUri =>
            element.CertMapping = DecodeElementAndValidationCheck<CertMappingType>(msg, body, WSMVProtocolName, "CertMappingType", ref decodeSucceed);
        case ListenerResourceUri =>
            element.Listener = DecodeElementAndValidationCheck<ListenerType>(msg, body, WSMVProtocolName, "ListenerType", ref decodeSucceed);
        case ShellResourceUri =>
            element.Shell = DecodeElementAndValidationCheck<Shell>(msg, body, WSMVProtocolName, "Shell", ref decodeSucceed);
        case PluginResourceUri =>
            element.Plugin = DecodeElementAndValidationCheck<CfgPluginType>(msg, body, WSMVProtocolName, "PluginType", ref decodeSucceed);
        case CustomRemoteShellResourceUri =>
            element.CustomRemoteShell = DecodeElementAndValidationCheck<CfgCustomRemoteShell>(msg, body, WSMVProtocolName, "CustomRemoteShell", ref decodeSucceed);
        default =>
            // Custom Shell
            if (body != null && body.Name is xmlName:XmlName && xmlName.NamespaceUri == WSMVShellNamespace && xmlName.LocalName == "Shell")
            {
                element.Shell = DecodeElementAndValidationCheck<Shell>(msg, body, WSMVProtocolName, "Shell", ref decodeSucceed);
            }
    }
    return decodeSucceed ? element : nothing;
}

optional XmlWrapperWSMVEx DecodeWSMVExtendedPutRequest(xml body, any message msg, string resourceUri)
{
    XmlWrapperWSMVEx element = new XmlWrapperWSMVEx{};
    bool decodeSucceed = false;
    switch (resourceUri)
    {
        case SecurityResourceUri =>
            element.Security = DecodeElementAndValidationCheck<CfgSecurityType>(msg, body, WSMVProtocolName, "SecurityType", ref decodeSucceed);
        default =>
            DecodeWSMVExtendedWSTransferCommon(body, msg, resourceUri, ref element, ref decodeSucceed);
    }
    return decodeSucceed ? element : nothing;
}

optional XmlWrapperWSMVEx DecodeWSMVExtendedPutResponse(xml body, any message msg, string resourceUri)
{
    XmlWrapperWSMVEx element = new XmlWrapperWSMVEx{};
    bool decodeSucceed = false;
    if (body.Name is xmlName:XmlName && xmlName.NamespaceUri == INamespace && xmlName.LocalName == "InteractiveEvent")
    {
        element.InteractiveEvent = DecodeElementAndValidationCheck<InteractiveEventType>(msg, body, WSMVProtocolName, "InteractiveEventType", ref decodeSucceed);
        return decodeSucceed ? element : nothing;
    }

    switch (resourceUri)
    {
        case SecurityResourceUri =>
            element.Plugin = DecodeElementAndValidationCheck<CfgPluginType>(msg, body, WSMVProtocolName, "PluginType", ref decodeSucceed);
        default =>
            DecodeWSMVExtendedWSTransferCommon(body, msg, resourceUri, ref element, ref decodeSucceed);
    }
    return decodeSucceed ? element : nothing;
}

optional XmlWrapperWSMVEx DecodeWSMVExtendedGetResponse(xml body, any message msg, string resourceUri)
{
    XmlWrapperWSMVEx element = new XmlWrapperWSMVEx{};
    bool decodeSucceed = false;
    switch (resourceUri)
    {
        case ShellResourceUri =>
            element.Shell = DecodeElementAndValidationCheck<Shell>(msg, body, WSMVProtocolName, "Shell", ref decodeSucceed);
        case SecurityResourceUri =>
            element.Security = DecodeElementAndValidationCheck<CfgSecurityType>(msg, body, WSMVProtocolName, "SecurityType", ref decodeSucceed);
        default =>
            DecodeWSMVExtendedWSTransferCommon(body, msg, resourceUri, ref element, ref decodeSucceed);
    }
    return decodeSucceed ? element : nothing;
}

void DecodeWSMVExtendedWSTransferCommon(xml body, any message msg, string resourceUri, ref XmlWrapperWSMVEx element, ref bool decodeSucceed)
{
    switch (resourceUri)
    {
        case ConfigResourceUri =>
            element.Config = DecodeElementAndValidationCheck<ConfigType>(msg, body, WSMVProtocolName, "ConfigType", ref decodeSucceed);
        case ClientResourceUri =>
            element.Client = DecodeElementAndValidationCheck<ClientType>(msg, body, WSMVProtocolName, "ClientType", ref decodeSucceed);
        case ClientAuthResourceUri =>
            element.ClientAuth = DecodeElementAndValidationCheck<ClientAuthType>(msg, body, WSMVProtocolName, "ClientAuthType", ref decodeSucceed);
        case ClientDefaultPortsResourceUri =>
            element.ClientDefaultPorts = DecodeElementAndValidationCheck<ClientDefaultPortsType>(msg, body, WSMVProtocolName, "ClientDefaultPortsType", ref decodeSucceed);
        case ServiceResourceUri =>
            element.Service = DecodeElementAndValidationCheck<ServiceType>(msg, body, WSMVProtocolName, "ServiceType", ref decodeSucceed);
        case ServiceAuthResourceUri =>
            element.ServiceAuth = DecodeElementAndValidationCheck<ServiceAuthType>(msg, body, WSMVProtocolName, "ServiceAuthType", ref decodeSucceed);
        case ServiceDefaultPortsResourceUri =>
            element.ServiceDefaultPorts = DecodeElementAndValidationCheck<ServiceDefaultPortsType>(msg, body, WSMVProtocolName, "ServiceDefaultPortsType", ref decodeSucceed);
        case WinrsResourceUri =>
            element.Winrs = DecodeElementAndValidationCheck<WinrsType>(msg, body, WSMVProtocolName, "WinrsType", ref decodeSucceed);
        case ListenerResourceUri =>
            element.Listener = DecodeElementAndValidationCheck<ListenerType>(msg, body, WSMVProtocolName, "ListenerType", ref decodeSucceed);
        case PluginResourceUri =>
            element.Plugin = DecodeElementAndValidationCheck<CfgPluginType>(msg, body, WSMVProtocolName, "PluginType", ref decodeSucceed);
        case CertMappingResourceUri =>
            element.CertMapping = DecodeElementAndValidationCheck<CertMappingType>(msg, body, WSMVProtocolName, "CertMappingType", ref decodeSucceed);
        case CustomRemoteShellResourceUri =>
            element.CustomRemoteShell = DecodeElementAndValidationCheck<CfgCustomRemoteShell>(msg, body, WSMVProtocolName, "CustomRemoteShell", ref decodeSucceed);
        default =>
            // Custom Shell
            if (body != null && body.Name is xmlName:XmlName && xmlName.NamespaceUri == WSMVShellNamespace && xmlName.LocalName == "Shell")
            {
                element.Shell = DecodeElementAndValidationCheck<Shell>(msg, body, WSMVProtocolName, "Shell", ref decodeSucceed);
            }
    }
}

// Extended XmlWrapper
type XmlWrapperWSMVEx : WSTransfer.XmlWrapper
{
    new optional xml Value;
    optional ConfigType Config;
    optional ClientType Client;
    optional ClientAuthType ClientAuth;
    optional ClientDefaultPortsType ClientDefaultPorts;
    optional ServiceType Service;
    optional ServiceAuthType ServiceAuth;
    optional ServiceDefaultPortsType ServiceDefaultPorts;
    optional CertMappingType CertMapping;
    optional WinrsType Winrs;
    optional ListenerType Listener;
    optional CfgPluginType Plugin;
    optional Shell Shell;
    optional CfgSecurityType Security;
    optional CfgCustomRemoteShell CustomRemoteShell;
    optional InteractiveEventType InteractiveEvent;
}

optional T DecodeElementAndValidationCheck<T>(any message context, xml x, string moduleName, string typeName, ref bool decodeSucceed)
{
    switch (x)
    {
        case v:T from XmlDecoder<T> =>
            decodeSucceed = true;
            return v;
        default =>
            ValidationCheckDecodingFailure(context, moduleName, typeName);
            return nothing;
    }
}

pattern CfgPluginType = PluginType with XmlEncoding{Namespace = CfgNamespace};

pattern CfgSecurityType = SecurityType with XmlEncoding{Namespace = CfgNamespace};

pattern CfgCustomRemoteShell = CustomRemoteShell with XmlEncoding{Namespace = CfgNamespace};

void AppendWSMVExtensionSummary(any message msg)
{
    if (msg#SummaryPrefix is pre:string && pre.Count > 0)
    {
        msg#SummaryPrefix = pre + ", WSMV";
    }
    else
    {
        msg#SummaryPrefix = "WSMV";
    }
}

// Extensions to WSEventing
autostart actor WSMVExtendingWSEventing(WSEventing.EventSourceIntermidiateEndpoint server) follows WSManExtendingWSEventing
{
    observe server accepts m:EventSourceMessageContract.SubscribeRequest
    {
        array<xml> leftElements = [];
        bool hasExtendedField = false;
        bool needUpdateSummaryline = false;
        
        if (m.Subscribe is subscribe:WSManagement.SubscribeTypeEx && subscribe.Filter is f:WSManagement.Filter 
            && f.Dialect == "http://schemas.microsoft.com/win/2004/08/events/eventquery"
            && f.AnyElements is arrElems:array<xml> && arrElems.Count > 0)
        {
            FilterTypeEx filterEx = new FilterTypeEx{Dialect = f.Dialect};
            
            for (int i = 0; i < arrElems.Count; i++)
            {
                xml x = arrElems[i];
                if (x.Name is xmlName:XmlName && xmlName.LocalName == "QueryList")
                {
                    filterEx.QueryList = DecodeElementAndValidationCheck<QueryListType>(m, x, WSMVProtocolName, "QueryList", ref hasExtendedField, ref leftElements);
                }
                else
                {
                    leftElements += [x];
                }
            }
            if (hasExtendedField)
            {
                filterEx.Dialect = f.Dialect;
                filterEx.Text = f.Text;
                filterEx.SelectorSet = f.SelectorSet;
                filterEx.AnyElements = leftElements.Count > 0 ? leftElements : nothing;
                filterEx.AnyAttributes = (f.AnyAttributes is a:array<xml> && a.Count > 0) ? a : nothing;
                subscribe.Filter = filterEx;
                needUpdateSummaryline = true;
            }
        }
        
        if (m.Subscribe.Delivery.AnyElements is arr:array<xml> && arr.Count > 0)
        {
            hasExtendedField = false;
            leftElements = [];
            DeliveryTypeWSMVEx deliveryEx = new DeliveryTypeWSMVEx{};
            
            for (int i = 0; i < arr.Count; i++)
            {
                xml x = arr[i];
                if (x.Name is xmlName:XmlName && xmlName.NamespaceUri == WSMVNamespace)
                {
                    switch (xmlName.LocalName)
                    {
                        case "DataLocale" =>
                            deliveryEx.DataLocale = DecodeElementAndValidationCheck<DataLocale>(m, x, WSMVProtocolName, "DataLocale", ref hasExtendedField, ref leftElements);
                        case "ActivityId" =>
                            deliveryEx.ActivityId = DecodeElementAndValidationCheck<ActivityId>(m, x, WSMVProtocolName, "ActivityId", ref hasExtendedField, ref leftElements);
                        default =>
                            leftElements += [x];
                    }
                }
                else
                {
                    leftElements += [x];
                }
            }
            if (hasExtendedField)
            {
                deliveryEx.NotifyTo = m.Subscribe.Delivery.NotifyTo;
                deliveryEx.Mode = m.Subscribe.Delivery.Mode;
                deliveryEx.AnyElements = leftElements.Count == 0 ? nothing : leftElements;
                deliveryEx.AnyAttributes = m.Subscribe.Delivery.AnyAttributes;
                
                if (m.Subscribe.Delivery is d:WSManagement.DeliveryTypeEx)
                {
                    deliveryEx.Locale = d.Locale;
                    deliveryEx.ContentEncoding = d.ContentEncoding;
                    deliveryEx.ConnectionRetry = d.ConnectionRetry;
                    deliveryEx.Heartbeats = d.Heartbeats;
                    deliveryEx.MaxEnvelopeSize = d.MaxEnvelopeSize;
                    deliveryEx.MaxElements = d.MaxElements;
                    deliveryEx.MaxTime = d.MaxTime;
                }
                
                m.Subscribe.Delivery = deliveryEx;
                needUpdateSummaryline = true;
            }
        }
        if (needUpdateSummaryline)
        {
            AppendWSMVExtensionSummary(m);
        }
    }
}

type FilterTypeEx : WSManagement.Filter
{
    optional QueryListType QueryList;
}

type DataLocale
{
    string lang with XmlEncoding{Kind = XmlKind.Attribute, Namespace = XmlNamespace};
    optional bool mustUnderstand with XmlEncoding{Kind = XmlKind.Attribute, Namespace = Soap12Namespace};
} with XmlEncodingDefaults{Namespace = WSMVNamespace};

type ActivityId
{
    string Value with XmlEncoding{Kind = XmlKind.Text};
    optional bool mustUnderstand with XmlEncoding{Kind = XmlKind.Attribute, Namespace = Soap12Namespace};
} with XmlEncodingDefaults{Namespace = WSMVNamespace};

type DeliveryTypeWSMVEx : WSManagement.DeliveryTypeEx
{
    optional DataLocale DataLocale;
    optional ActivityId ActivityId;
}

// Extensions to WSEnumeration
autostart actor WSMVExtendingWSEnumeration(WSEnumeration.IntermediateServer server) follows WSManExtendingWSEnumeration
{
    observe server accepts m:MessageContract.Enumerate
    {
        array<xml> leftElements = [];
        bool hasExtendedField = false;
        bool needUpdateSummaryline = false;
        
        if (m.Enumerate is enumerate:EnumerateTypeEx && enumerate.Filter is f:WSManagement.Filter 
            && f.Dialect == "http://schemas.microsoft.com/win/2004/08/events/eventquery"
            && f.AnyElements is arrElems:array<xml> && arrElems.Count > 0)
        {
            FilterTypeEx filterEx = new FilterTypeEx{Dialect = f.Dialect};
            
            for (int i = 0; i < arrElems.Count; i++)
            {
                xml x = arrElems[i];
                if (x.Name is xmlName:XmlName && xmlName.LocalName == "QueryList")
                {
                    filterEx.QueryList = DecodeElementAndValidationCheck<QueryListType>(m, x, WSMVProtocolName, "QueryList", ref hasExtendedField, ref leftElements);
                }
                else
                {
                    leftElements += [x];
                }
            }
            if (hasExtendedField)
            {
                filterEx.Dialect = f.Dialect;
                filterEx.Text = f.Text;
                filterEx.SelectorSet = f.SelectorSet;
                filterEx.AnyElements = leftElements.Count > 0 ? leftElements : nothing;
                filterEx.AnyAttributes = (f.AnyAttributes is arr:array<xml> && arr.Count > 0) ? arr : nothing;
                enumerate.Filter = filterEx;
                needUpdateSummaryline = true;
            }
        }
        if (needUpdateSummaryline)
        {
            AppendWSMVExtensionSummary(m);
        }
    }
    
    observe server issues m:MessageContract.EnumerateResponse
    {
        if (m.EnumerateResponse is res:EnumerateResponseTypeEx && res.Items is itemList:AnyListType 
            && itemList.AnyElements is arr:array<xml> && arr.Count > 0)  
        {
            AnyListTypeWSMVEx itemListEx = new AnyListTypeWSMVEx{};
            
            bool hasExtendedField = false;
            array<xml> leftElements = [];
            array<Shell> shellArr = [];
            array<CertMappingType> certArr = [];
            
            foreach (xml x in arr)
            {
                XmlName xmlName = x.Name as XmlName;
                if (xmlName.NamespaceUri == WSMVShellNamespace && xmlName.LocalName == "Shell"
                    && DecodeElementAndValidationCheck<Shell>(m, x, WSMVProtocolName, "Shell", ref hasExtendedField) is s:Shell)
                {
                    shellArr += [s];
                }
                else if (xmlName.NamespaceUri == CertNamespace && xmlName.LocalName == "CertMapping"
                    && DecodeElementAndValidationCheck<CertMappingType>(m, x, WSMVProtocolName, "CertMappingType", ref hasExtendedField) is c:CertMappingType)
                {
                    certArr += [c];
                }
                else
                {
                    leftElements += [x];
                }
            }
            if (hasExtendedField)
            {
                itemListEx.AnyElements = leftElements.Count > 0 ? leftElements : nothing;
                itemListEx.AnyAttributes = (itemList.AnyAttributes is x:array<xml> && x.Count > 0) ? x : nothing;
                itemListEx.Shell = shellArr.Count > 0 ? shellArr : nothing;
                itemListEx.CertMapping = certArr.Count > 0 ? certArr : nothing;
                res.Items = itemListEx;
                AppendWSMVExtensionSummary(m);
            }
        }
    }    
    
    string pullResourceUri = "";
    
    observe server accepts m:MessageContract.Pull
    {
        pullResourceUri = (m.Origins[0] as SoapMessage).ResourceURI;
    }
    
    observe server issues m:MessageContract.PullResponse
    {
        if (m.PullResponse.Items is itemList:ItemListType && itemList.AnyElements is arr:array<xml> && arr.Count > 0)  
        {
            ItemListTypeWSMVEx itemListEx = new ItemListTypeWSMVEx{};
            
            bool hasExtendedField = false;
            array<xml> leftElements = [];
            
            string resourceUri = (m.Origins[0] as SoapMessage).ResourceURI;
            if (resourceUri.Count == 0)
            {
                resourceUri = pullResourceUri;
            }
            
            array<CertMappingType> certArr = [];
            array<ListenerType> listenerArr = [];
            array<Shell> shellArr = [];
            array<CustomRemoteShell> customShellArr = [];
                        
            switch (resourceUri)
            {
                case CertMappingResourceUri =>
                    foreach (xml x in arr)
                    {
                        if (DecodeElementAndValidationCheck<CertMappingType>(m, x, WSMVProtocolName, "CertMapping", ref hasExtendedField, ref leftElements) is c:CertMappingType)
                        {
                            certArr += [c];
                        }
                    }
                case ListenerResourceUri =>
                    foreach (xml x in arr)
                    {
                        if (DecodeElementAndValidationCheck<ListenerType>(m, x, WSMVProtocolName, "Listener", ref hasExtendedField, ref leftElements) is c:ListenerType)
                        {
                            listenerArr += [c];
                        }
                    }
                case ShellResourceUri =>
                    foreach (xml x in arr)
                    {
                        if (DecodeElementAndValidationCheck<Shell>(m, x, WSMVProtocolName, "Shell", ref hasExtendedField, ref leftElements) is c:Shell)
                        {
                            shellArr += [c];
                        }
                    }
                case CustomRemoteShellResourceUri =>
                    foreach (xml x in arr)
                    {
                        if (DecodeElementAndValidationCheck<CustomRemoteShell>(m, x, WSMVProtocolName, "CustomRemoteShell", ref hasExtendedField, ref leftElements) is c:CustomRemoteShell)
                        {
                            customShellArr += [c];
                        }
                    }
                default =>
                    foreach (xml x in arr)
                    {
                        // Custom Shell
                        if (x.Name is xmlName:XmlName && xmlName.NamespaceUri == WSMVShellNamespace && xmlName.LocalName == "Shell")
                        {
                            if (DecodeElementAndValidationCheck<Shell>(m, x, WSMVProtocolName, "Shell", ref hasExtendedField, ref leftElements) is c:Shell)
                            {
                                shellArr += [c];
                            }
                        }
                        else
                        {
                            leftElements += [x];
                        }
                    }
            }
            if (hasExtendedField)
            {
                itemListEx.AnyElements = leftElements.Count > 0 ? leftElements : nothing;
                itemListEx.CertMapping = certArr.Count > 0 ? certArr : nothing;
                itemListEx.Listener = listenerArr.Count > 0 ? listenerArr : nothing;
                itemListEx.Shell = shellArr.Count > 0 ? shellArr : nothing;
                itemListEx.CustomRemoteShell = customShellArr.Count > 0 ? customShellArr : nothing;
                if (itemList is il:ItemListTypeEx)
                {
                    itemListEx.XmlFragments = (il.XmlFragments is farr:array<XmlFragment> && farr.Count > 0) ? farr : nothing;
                    itemListEx.Items = (il.Items is iarr:array<Item> && iarr.Count > 0) ? iarr : nothing;
                }
                m.PullResponse.Items = itemListEx;
                AppendWSMVExtensionSummary(m);
            }
        }
    }
}

type AnyListTypeWSMVEx : AnyListType
{
    optional array<CertMappingType> CertMapping;
    optional array<Shell> Shell;
}

type ItemListTypeWSMVEx : WSManagement.ItemListTypeEx
{
    optional array<CertMappingType> CertMapping;
    optional array<ListenerType> Listener;
    optional array<Shell> Shell;
    optional array<CustomRemoteShell> CustomRemoteShell;
}

// Operations
contract WSMVOperations
{
    accepts virtual operation CommandOperation
    {
        in WSMVMessages.CommandRequest Request = req;
        out WSMVMessages.CommandResponse Response = res;
        
        override string ToString()
        {
            return "Command Operation, Command: " + Request.CommandLine.Command;
        }
    }
    =
    accepts WSMVMessages.CommandRequest{value is var req}
    issues WSMVMessages.CommandResponse{value is var res};
    
    accepts virtual operation SignalOperation
    {
        in WSMVMessages.SignalRequest Request = req;
        out WSMVMessages.SignalResponse Response = res;
        
        override string ToString()
        {
            return "Signal Operation, Code: " + EnumToString(Request.Signal.Code, "WSMV.SignalCodeEnumeration");
        }
    }
    =
    accepts WSMVMessages.SignalRequest{value is var req}
    issues WSMVMessages.SignalResponse{value is var res};
    
    accepts virtual operation SendOperation
    {
        in WSMVMessages.SendRequest Request = req;
        out WSMVMessages.SendResponse Response = res;
        
        override string ToString()
        {
            string summary = "Send Operation";
            if ((this.Origins[0] as WSMVMessages.SendRequest)#CompressionType is s:StringNotNullOrEmpty)
            {
                summary += ", CompressionType: " + s;
            }
            return summary;
        }
    }
    =
    accepts WSMVMessages.SendRequest{value is var req}
    issues WSMVMessages.SendResponse{value is var res};
    
    accepts virtual operation ReceiveOperation
    {
        in WSMVMessages.ReceiveRequest Request = req;
        out WSMVMessages.ReceiveResponse Response = res;
        
        override string ToString()
        {
            string summary = "Receive Operation, DesiredStream: " + Request.Receive.DesiredStream.Value;
            if (Response.ReceiveResponse.CommandState is c:CommandStateType)
            {
                summary += ", CommandState: " + EnumToString(c.State, "WSMV.CommandStateEnumeration");
            }
            if ((this.Origins[1] as WSMVMessages.ReceiveResponse)#CompressionType is s:StringNotNullOrEmpty)
            {
                summary += ", CompressionType: " + s;
            }
            return summary;
        }
   }
    =
    accepts WSMVMessages.ReceiveRequest{value is var req}
    issues WSMVMessages.ReceiveResponse{value is var res};
   
   accepts virtual operation ConnectOperation
   {
        in WSMVMessages.ConnectRequest Request = req;
        out WSMVMessages.ConnectResponse Response = res;
        
        override string ToString()
        {
            return "Connect Operation";
        }
   }
    =
    accepts WSMVMessages.ConnectRequest{value is var req}
    issues WSMVMessages.ConnectResponse{value is var res};
   
   accepts virtual operation DisconnectOperation
   {
        in WSMVMessages.DisconnectRequest Request = req;
        out WSMVMessages.DisconnectResponse Response = res;
        
        override string ToString()
        {
            return "Disconnect Operation";
        }
   }
    =
    accepts WSMVMessages.DisconnectRequest{value is var req}
    issues WSMVMessages.DisconnectResponse{value is var res};
   
   accepts virtual operation ReconnectOperation
   {
        in WSMVMessages.ReconnectRequest Request = req;
        out WSMVMessages.ReconnectResponse Response = res;
        
        override string ToString()
        {
            return "Reconnect Operation";
        }
   }
    =
    accepts WSMVMessages.ReconnectRequest{value is var req}
    issues WSMVMessages.ReconnectResponse{value is var res};
}

annotation string WSMVMessages.SendRequest#CompressionType;
annotation string WSMVMessages.ReceiveResponse#CompressionType;

map<string, string> CompressionTypePerShellId = {};

// Messages
contract WSMVMessages
{
    accepts message CommandRequest
    {
        CommandLine CommandLine with XmlEncoding{Namespace = WSMVShellNamespace};
        
        override string ToString()
        {
            return "Command Request, Command: " + CommandLine.Command;
        }
    }
    
    issues message CommandResponse
    {
        CommandResponseType CommandResponse with XmlEncoding{Namespace = WSMVShellNamespace};
        
        override string ToString()
        {
            return "Command Response";
        }
    }
    
    accepts message SignalRequest
    {
        Signal Signal with XmlEncoding{Namespace = WSMVShellNamespace};
        
        override string ToString()
        {
            return "Signal Request, Code: " + EnumToString(Signal.Code, "WSMV.SignalCodeEnumeration");
        }
    }
    
    issues message SignalResponse
    {
        SignalResponseType SignalResponse with XmlEncoding{Namespace = WSMVShellNamespace};
        
        override string ToString()
        {
            return "Signal Response";
        }
    }
    
    accepts message SendRequest
    {
        Send Send with XmlEncoding{Namespace = WSMVShellNamespace};
        
        override string ToString()
        {
            string summary = "Send Request";
            if (this#CompressionType is s:StringNotNullOrEmpty)
            {
                summary += ", CompressionType: " + s;
            }
            return summary;
        }
    }
    
    issues message SendResponse
    {
        SendResponseType SendResponse with XmlEncoding{Namespace = WSMVShellNamespace};
        
        override string ToString()
        {
            return "Send Response";
        }
    }
    
    accepts message ReceiveRequest
    {
        Receive Receive with XmlEncoding{Namespace = WSMVShellNamespace};
        
        override string ToString()
        {
            return "Receive Request, DesiredStream: " + Receive.DesiredStream.Value;
        }
    }
    
    issues message ReceiveResponse
    {
        ReceiveResponseType ReceiveResponse with XmlEncoding{Namespace = WSMVShellNamespace};
        
        override string ToString()
        {
            string summary = "Receive Response";
            if (ReceiveResponse.CommandState is c:CommandStateType)
            {
                summary += ", CommandState: " + EnumToString(c.State, "WSMV.CommandStateEnumeration");
            } 
            if (this#CompressionType is s:StringNotNullOrEmpty)
            {
                summary += ", CompressionType: " + s;
            }
            return summary;
        }
    }
    
    accepts message DisconnectRequest
    {
        DisconnectType Disconnect with XmlEncoding{Namespace = WSMVShellNamespace};
        
        override string ToString()
        {
            return "Disconnect Request";
        }
    }
    
    // Empty message
    issues message DisconnectResponse
    {
        override string ToString()
        {
            return "Disconnect Response";
        }
    }
    
    // Empty message
    accepts message ReconnectRequest
    {
        override string ToString()
        {
            return "Reconnect Request";
        }
    }
    
    // Empty message
    issues message ReconnectResponse
    {
        override string ToString()
        {
            return "Reconnect Response";
        }
    }
    
    accepts message ConnectRequest
    {
        ConnectType Connect with XmlEncoding{Namespace = WSMVShellNamespace};
        
        override string ToString()
        {
            return "Connect Request";
        }
    }
    
    issues message ConnectResponse
    {
        ConnectResponseType ConnectResponse with XmlEncoding{Namespace = WSMVShellNamespace};
        
        override string ToString()
        {
            return "Connect Response";
        }
    }
    
    // Empty message
    accepts message AcknowledgeRequest
    {
        override string ToString()
        {
            return "Acknowledge Request";
        }
    }
    
    issues message AcknowledgeResponse
    {
        ulong LastSequenceIdReceived with XmlEncoding{Namespace = WSMVNamespace};
        
        override string ToString()
        {
            return "Acknowledge Response";
        }
    }
    
    issues message InteractiveResponse
    {
        InteractiveResponseType InteractiveResponse with XmlEncoding{Namespace = INamespace};
        
        override string ToString()
        {
            return "Interactive Response";
        }
    }
    
    // Empty message
    accepts message EndRequest
    {
        override string ToString()
        {
            return "End Request";
        }
    }
    
    // Empty message
    accepts message CancelRequest
    {
        override string ToString()
        {
            return "Cancel Request";
        }
    }
    
    // Empty message
    accepts message KeepAliveRequest
    {
        override string ToString()
        {
            return "KeepAlive Request";
        }
    }
}

// Types
// 2.2.4.1 AuthenticationType Complex Type
type AuthenticationType
{
    optional ClientCertificateType ClientCertificate;
    XSAnyURI Profile with XmlEncoding{Kind = XmlKind.Attribute, Namespace = ""};
} with XmlEncodingDefaults{Namespace = WSManagementNamespace};

type ClientCertificateType
{
    ThumbprintType Thumbprint;
}

type ThumbprintType
{
    string Value with XmlEncoding{Kind = XmlKind.Text};
    string Role with XmlEncoding{Kind = XmlKind.Attribute, Namespace = ""};
}

// 2.2.4.2 Capability Type
type CapabilityType
{
    CapabilityEnumeration Type where ValidationCheckEnumValueTooManyItems(InRange<CapabilityEnumeration>(value),
            null, true, ReferenceType.Type, WSMVProtocolName, "Type", "CapabilityType", "CapabilityEnumeration", "[MS-WSMV]")
            with XmlEncoding{Kind = XmlKind.Attribute, Namespace = ""};
    optional bool SupportsFragment with XmlEncoding{Kind = XmlKind.Attribute, Namespace = ""};
    optional bool SupportsFiltering with XmlEncoding{Kind = XmlKind.Attribute, Namespace = ""};
} with XmlEncodingDefaults{Namespace = PluginNamespace};

// 2.2.4.3 CertMappingType
type CertMappingType
{
    string URI;
    string Subject;
    string Issuer;
    optional string UserName;
    optional bool Enabled;
    optional string Password;
} with XmlEncodingDefaults{Namespace = CertNamespace};

// 2.2.4.4 ClientAuthType
type ClientAuthType
{
    bool Basic;
    bool Digest;
    bool Kerberos;
    bool Negotiate;
    bool Certificate;
    optional bool CredSSP;
} with XmlEncodingDefaults{Namespace = CfgNamespace};

// 2.2.4.5 ClientDefaultPortsType
type ClientDefaultPortsType
{
    uint HTTP;
    uint HTTPS;
} with XmlEncodingDefaults{Namespace = CfgNamespace};

// 2.2.4.6 ClientType
type ClientType
{
    uint NetworkDelayms;
    string URLPrefix;
    bool AllowUnencrypted;
    ClientAuthType Auth with XmlEncoding{Namespace = CfgNamespace};
    ClientDefaultPortsType DefaultPorts with XmlEncoding{Namespace = CfgNamespace};
    string TrustedHosts;    
} with XmlEncodingDefaults{Namespace = CfgNamespace};

// 2.2.4.7 CommandLine
type CommandLine
{
    string Command;
    optional array<ArgumentType> Arguments;
}

// 2.2.4.8 CommandResponse
type CommandResponseType
{
    XSAnyURI CommandId;
}

// 2.2.4.9 CommandStateType
type CommandStateType
{
    optional ExitCodeType ExitCode;
    XSAnyURI CommandId with XmlEncoding{Kind = XmlKind.Attribute, Namespace = ""};
    CommandStateEnumeration State where ValidationCheckEnumValueTooManyItems(InRange<CommandStateEnumeration>(value),
            null, true, ReferenceType.Type, WSMVProtocolName, "State", "CommandStateType", "CommandStateEnumeration", "[MS-WSMV]") 
            with XmlEncoding{Kind = XmlKind.Attribute, Namespace = ""};
}

// 2.2.4.10 ConfigType
type ConfigType
{
    uint MaxEnvelopeSizekb;
    uint MaxTimeoutms;
    uint MaxBatchItems;
    uint MaxProviderRequests;
    ClientType Client;
    ServiceType Service;
    WinrsType Winrs;
} with XmlEncodingDefaults{Namespace = CfgNamespace};

// 2.2.4.11 ConnectResponseType
type ConnectResponseType
{
    optional array<xml> AnyElements with XmlEncoding{IsAny = true, Namespace = XmlNamespaceIndicator.Other};
} with XmlEncodingDefaults{Namespace = WSMVShellNamespace};

// 2.2.4.12 ConnectType
type ConnectType
{
    optional array<xml> AnyElements with XmlEncoding{IsAny = true, Namespace = XmlNamespaceIndicator.Other};
} with XmlEncodingDefaults{Namespace = WSMVShellNamespace};

// 2.2.4.13 CustomRemoteShell
type CustomRemoteShell
{
    optional XSAnyURI URI;
    string Shell;
    optional string Arguments;
} with XmlEncodingDefaults{Namespace = CustomRemoteShellNamespace};

// 2.2.4.14 DesiredStreamType
type DesiredStreamType
{
    StreamNameList Value with XmlEncoding{Kind = XmlKind.Text};
    optional XSAnyURI CommandId with XmlEncoding{Kind = XmlKind.Attribute, Namespace = ""};
} with XmlEncodingDefaults{Namespace = WSMVShellNamespace};

// 2.2.4.15 DisconnectType
type DisconnectType
{
    optional XSDuration IdleTimeOut;
    optional OutputBufferingModeEnumeration BufferMode;
} with XmlEncodingDefaults{Namespace = WSMVShellNamespace};

// 2.2.4.16 EnviromentVariable
type EnvironmentVariable
{
    string Value with XmlEncoding{Kind = XmlKind.Text};
    string Name with XmlEncoding{Kind = XmlKind.Attribute, Namespace = ""};
}

// 2.2.4.17 EnvironmentVariableList
type EnvironmentVariableList
{
    array<EnvironmentVariable> Variable;
}

// 2.2.4.18 InitializationParametersType
type InitializationParametersType
{
    array<ParamType> Param;
} with XmlEncodingDefaults{Namespace = PluginNamespace};

// 2.2.4.19 ListenerType
type ListenerType
{
    string Address;
    string Transport;
    uint Port;
    string Hostname;
    optional bool Enabled;
    optional string URLPrefix;
    optional string CertificateThumbprint;
    array<string> ListeningOn;
} with XmlEncodingDefaults{Namespace = CfgNamespace};

// 2.2.4.20 MachineIDType Complex Type
type MachineIDType
{
    string MachineID;
    xml AnyAttribute with XmlEncoding{IsAny = true, Kind = XmlKind.Attribute, Namespace = XmlNamespaceIndicator.Any};
} with XmlEncodingDefaults{Namespace = MNamespace};

// 2.2.4.21 ParamType
type ParamType
{
    string Name with XmlEncoding{Kind = XmlKind.Attribute, Namespace = ""};
    string Value with XmlEncoding{Kind = XmlKind.Attribute, Namespace = ""};
} with XmlEncodingDefaults{Namespace = PluginNamespace};

// 2.2.4.22 PluginType
type PluginType
{
    ResourcesContainerType Resources;
    optional InitializationParametersType InitializationParameters;
    optional QuotasType Quotas;
    string Name with XmlEncoding{Kind = XmlKind.Attribute, Namespace = ""};
    string FileName with XmlEncoding{Kind = XmlKind.Attribute, Namespace = ""};
    int SDKVersion with XmlEncoding{Kind = XmlKind.Attribute, Namespace = ""};
    XmlRenderingTypeEnumeration XmlRenderingType
        where ValidationCheckEnumValue(InRange<XmlRenderingTypeEnumeration>(value), null, true, ReferenceType.Type, WSMVProtocolName, "XmlRenderingType", "PluginType", "text, XmlReader", value)
        with XmlEncoding{Kind = XmlKind.Attribute, Namespace = ""};
    optional int Architecture with XmlEncoding{Kind = XmlKind.Attribute, Namespace = ""};
    optional bool UseSharedProcess with XmlEncoding{Kind = XmlKind.Attribute, Namespace = ""};
    optional bool AutoRestart with XmlEncoding{Kind = XmlKind.Attribute, Namespace = ""};
    optional int ProcessIdleTimeoutSec with XmlEncoding{Kind = XmlKind.Attribute, Namespace = ""};
    optional string RunAsUser with XmlEncoding{Kind = XmlKind.Attribute, Namespace = ""};
    optional string RunAsPassword with XmlEncoding{Kind = XmlKind.Attribute, Namespace = ""};
    optional OutputBufferingModeEnumeration OutputBufferingMode
        where ValidationCheckEnumValue(value == nothing || InRange<OutputBufferingModeEnumeration>(value as string), null, true, ReferenceType.Type, WSMVProtocolName, "OutputBufferingMode", "PluginType", "Block, Drop", value)
        with XmlEncoding{Kind = XmlKind.Attribute, Namespace = ""};
    optional bool Enabled with XmlEncoding{Kind = XmlKind.Attribute, Namespace = ""};
} with XmlEncodingDefaults{Namespace = PluginNamespace};

// 2.2.4.23 QuotasType
type QuotasType
{
    int MaxConcurrentUsers with XmlEncoding{Kind = XmlKind.Attribute, Namespace = ""};
    optional int MaxConcurrentOperationsPerUser with XmlEncoding{Kind = XmlKind.Attribute, Namespace = ""};
    optional int MaxConcurrentOperations with XmlEncoding{Kind = XmlKind.Attribute, Namespace = ""};
    optional int MaxMemoryPerShellMB with XmlEncoding{Kind = XmlKind.Attribute, Namespace = ""};
    optional int MaxIdleTimeoutms with XmlEncoding{Kind = XmlKind.Attribute, Namespace = ""};
    optional int IdleTimeoutms with XmlEncoding{Kind = XmlKind.Attribute, Namespace = ""};
    optional int MaxProcessesPerShell with XmlEncoding{Kind = XmlKind.Attribute, Namespace = ""};
    optional int MaxConcurrentCommandsPerShell with XmlEncoding{Kind = XmlKind.Attribute, Namespace = ""};
    optional int MaxShells with XmlEncoding{Kind = XmlKind.Attribute, Namespace = ""};
    optional int MaxShellsPerUser with XmlEncoding{Kind = XmlKind.Attribute, Namespace = ""};
} with XmlEncodingDefaults{Namespace = PluginNamespace};

// 2.2.4.24 QueryListType
type QueryListType
{
    array<QueryType> Query;
}

// 2.2.4.25 QueryType
type QueryType
{
    array<SelectType> Select;
    int Id with XmlEncoding{Kind = XmlKind.Text};
}

// 2.2.4.26 Receive
type Receive
{
    DesiredStreamType DesiredStream;
}

// 2.2.4.27 ReceiveResponse
type ReceiveResponseType
{
    array<StreamType> Stream;
    optional CommandStateType CommandState;
    optional ulong SequenceID with XmlEncoding{Kind = XmlKind.Attribute, Namespace = ""};
}

// 2.2.4.28 ResourcesContainerType
type ResourcesContainerType
{
    array<ResourceType> Resource;
} with XmlEncodingDefaults{Namespace = PluginNamespace};

// 2.2.4.29 ResourceType
type ResourceType
{
    array<SecurityType> Security;
    array<CapabilityType> Capability;
    XSAnyURI ResourceURI with XmlEncoding{Kind = XmlKind.Attribute, Namespace = ""};
    optional bool SupportsOptions with XmlEncoding{Kind = XmlKind.Attribute, Namespace = ""};
    optional bool ExactMatch with XmlEncoding{Kind = XmlKind.Attribute, Namespace = ""};
} with XmlEncodingDefaults{Namespace = PluginNamespace};

// 2.2.4.30 SecurityType
type SecurityType
{
    string Uri with XmlEncoding{Kind = XmlKind.Attribute, Namespace = ""};
    string Sddl with XmlEncoding{Kind = XmlKind.Attribute, Namespace = ""};
    optional bool ExactMatch with XmlEncoding{Kind = XmlKind.Attribute, Namespace = ""};
} with XmlEncodingDefaults{Namespace = PluginNamespace};

// 2.2.4.31 SelectType
type SelectType
{
    string Value with XmlEncoding{Kind = XmlKind.Text};
    string Path with XmlEncoding{Kind = XmlKind.Attribute, Namespace = ""};
}

// 2.2.4.32 Send
type Send
{
    array<StreamType> Stream;
}

// 2.2.4.33
type SendResponseType
{
    optional StreamType DesiredStream;
}

// 2.2.4.34 ServiceAuthType
type ServiceAuthType
{
    bool Basic;
    bool Kerberos;
    bool Negotiate;
    bool Certificate;
    optional bool CredSSP;
    optional string CbtHardeningLevel;
} with XmlEncodingDefaults{Namespace = CfgNamespace};

// 2.2.4.35 ServiceDefaultPortsType
type ServiceDefaultPortsType
{
    uint HTTP;
    uint HTTPS;
} with XmlEncodingDefaults{Namespace = CfgNamespace};

// 2.2.4.36 ServiceType
type ServiceType
{
    string RootSDDL;
    uint MaxConcurrentOperations;
    optional uint MaxConcurrentOperationsPerUser;
    uint EnumerationTimeoutms;
    uint MaxConnections;
    optional uint MaxPacketRetrievalTimeSeconds;
    bool AllowUnencrypted;
    ServiceAuthType Auth with XmlEncoding{Namespace = CfgNamespace};
    ServiceDefaultPortsType DefaultPorts with XmlEncoding{Namespace = CfgNamespace};
    string IPv4Filter;
    string IPv6Filter;
    optional string CertificateThumbprint;
} with XmlEncodingDefaults{Namespace = CfgNamespace};

// 2.2.4.37 Shell
type Shell
{
    optional XSAnyURI ShellId;
    optional string Name;
    optional XSAnyURI ResourceUri;
    optional string Owner;
    optional string ClientIP;
    optional int ProcessId;
    optional EnvironmentVariableList Environment;
    optional string WorkingDirectory;
    optional XSDuration Lifetime;
    optional XSDuration IdleTimeOut;
    optional StreamNameList InputStreams;
    optional StreamNameList OutputStreams;
    optional XSDuration MaxIdleTimeOut;
    optional string Locale;
    optional string DataLocale;
    optional string CompressionMode;
    optional bool ProfileLoaded;
    optional string Encoding;
    optional OutputBufferingModeEnumeration BufferMode
        where ValidationCheckEnumValue(value == nothing || InRange<OutputBufferingModeEnumeration>(value as string), null, true, ReferenceType.Type, WSMVProtocolName, "BufferMode", "Shell", "Block, Drop", value);
    optional StateType State
        where ValidationCheckEnumValue(value == nothing || InRange<StateType>(value as string), null, true, ReferenceType.Type, WSMVProtocolName, "State", "Shell", "Connected, Disconnected", value);
    optional XSDuration ShellRunTime;
    optional XSDuration ShellInactivity;
    optional array<xml> AnyElements with XmlEncoding{IsAny = true, Namespace = XmlNamespaceIndicator.Other};
} with XmlEncodingDefaults{Namespace = WSMVShellNamespace};

// 2.2.4.38 Signal
type Signal
{
    SignalCodeEnumeration Code where ValidationCheckEnumValueTooManyItems(InRange<SignalCodeEnumeration>(value),
            null, true, ReferenceType.Type, WSMVProtocolName, "Code", "Signal", "SignalCodeEnumeration", "[MS-WSMV]") ;
    optional XSAnyURI CommandId with XmlEncoding{Kind = XmlKind.Attribute, Namespace = ""};
}

// 2.2.4.39 SignalResponse
type SignalResponseType
{
    optional array<xml> AnyElements with XmlEncoding{IsAny = true, Namespace = XmlNamespaceIndicator.Other};
}

// 2.2.4.40 StreamType
type StreamType
{
    // Base64 Encoded String
    string Value with XmlEncoding{Kind = XmlKind.Text};
    StreamName Name with XmlEncoding{Kind = XmlKind.Attribute, Namespace = ""};
    optional XSAnyURI CommandId with XmlEncoding{Kind = XmlKind.Attribute, Namespace = ""};
    optional bool End with XmlEncoding{Kind = XmlKind.Attribute, Namespace = ""};
    optional XSAnyURI Unit with XmlEncoding{Kind = XmlKind.Attribute, Namespace = ""};
    optional bool EndUnit with XmlEncoding{Kind = XmlKind.Attribute, Namespace = ""};
}

// 2.2.4.41 SubscriptionType Complex Type
type SubscriptionType
{
    string Version;
    xml Envelope with XmlEncoding{Namespace = SNamespace};
} with XmlEncodingDefaults{Namespace = SubNamespace};

// 2.2.4.42 WinrsType
type WinrsType
{
    bool AllowRemoteShellAccess;
    ulong IdleTimeout;
    ushort MaxConcurrentUsers;
    ulong MaxShellRunTime;
    ulong MaxProcessesPerShell;
    ulong MaxMemoryPerShellMB;
    ulong MaxShellsPerUser;
} with XmlEncodingDefaults{Namespace = CfgNamespace};

// 2.2.4.43 WSManFaultType
type WSManFaultType
{
    optional MessageType Message;
    uint Code with XmlEncoding{Kind = XmlKind.Attribute, Namespace = ""};
    string Machine with XmlEncoding{Kind = XmlKind.Attribute, Namespace = ""};
    xml AnyAttribute with XmlEncoding{IsAny = true, Kind = XmlKind.Attribute, Namespace = ""};
} with XmlEncodingDefaults{Namespace = WsmanFaultNamespace};

type WSManFault
{
    WSManFaultType WSManFault with XmlEncoding{Namespace = WsmanFaultNamespace};
}

pattern GUIDType = guid;

type ProviderFaultType
{
    optional array<xml> AnyElements with XmlEncoding{IsAny = true};
    GUIDType providerId with XmlEncoding{Kind = XmlKind.Attribute, Namespace = ""};
    xml AnyAttribute with XmlEncoding{IsAny = true, Kind = XmlKind.Attribute, Namespace = ""};
} with XmlEncodingDefaults{Namespace = WsmanFaultNamespace};

type MessageType
{
    optional ProviderFaultType ProviderFault with XmlEncoding{Namespace = WsmanFaultNamespace};
}

// 2.2.4.44 AcknowledgeType
type AcknowledgeType
{
    ulong LastSequenceIdReceived;
} with XmlEncodingDefaults{Namespace = WSMVNamespace};

// 2.2.4.45 OperationIDType Complex Type
type OperationIDType
{
    GUIDType OperationID with XmlEncoding{Namespace = WSManagementNamespace};
    xml AnyAttribute with XmlEncoding{IsAny = true, Kind = XmlKind.Attribute, Namespace = XmlNamespaceIndicator.Any};
} with XmlEncodingDefaults{Namespace = WSMVNamespace};

// 2.2.4.46 SequenceIDType Complex Type
type SequenceIDType
{
    ulong SequenceID;
    xml AnyAttribute with XmlEncoding{IsAny = true, Kind = XmlKind.Attribute, Namespace = XmlNamespaceIndicator.Any};
} with XmlEncodingDefaults{Namespace = WSMVNamespace};

// 2.2.4.47 InteractiveEventType Complex Type
type InteractiveEventType
{
    EventType_Type EventType
         where ValidationCheckEnumValueTooManyItems(InRange<EventType_Type>(value),
            null, true, ReferenceType.Type, WSMVProtocolName, "EventType", "InteractiveEventType", "EventType_Type", "[MS-WSMV]");
    optional InteractiveEventComplexType Description;
    optional string Activity;
    optional string CurrentOperation;
    optional string StatusDescription;
    optional uint PercentComplete;
    optional uint SecondsRemaining;
    optional ActionType_Type ActionType
        where ValidationCheckEnumValue(value == nothing || InRange<ActionType_Type>(value as string), null, true, ReferenceType.Type, WSMVProtocolName, "ActionType", "InteractiveEventType", "Inquire, Report", value);
    optional PromptType_Type PromptType
        where ValidationCheckEnumValue(value == nothing || InRange<PromptType_Type>(value as string), null, true, ReferenceType.Type, WSMVProtocolName, "PromptType", "InteractiveEventType", "Normal, Critical", value);
    optional string Name;
    optional Type_Type Type
         where ValidationCheckEnumValueTooManyItems(value == nothing || InRange<Type_Type>(value as uint),
            null, true, ReferenceType.Type, WSMVProtocolName, "Type", "InteractiveEventType", "Type_Type", "[MS-WSMV]");
    optional InteractiveEventComplexType Value;
    optional xml AnyAttribute with XmlEncoding{IsAny = true, Kind = XmlKind.Attribute, Namespace = XmlNamespaceIndicator.Any};
} with XmlEncodingDefaults{Namespace = INamespace};

// 2.2.4.48 InteractiveResponseType Complex Type
type InteractiveResponseType
{
    EventType_Type EventType
        where ValidationCheckEnumValueTooManyItems(InRange<EventType_Type>(value),
            null, true, ReferenceType.Type, WSMVProtocolName, "EventType", "InteractiveResponseType", "EventType_Type", "[MS-WSMV]");
    ResponseType Response
        where ValidationCheckEnumValue(InRange<ResponseType>(value), null, true, ReferenceType.Type, WSMVProtocolName, "Response", "InteractiveResponseType", "yes, no, yesToAll, noToAll", value);
    xml AnyAttribute with XmlEncoding{IsAny = true, Kind = XmlKind.Attribute, Namespace = XmlNamespaceIndicator.Any};
} with XmlEncodingDefaults{Namespace = INamespace};

// 2.2.4.49 InteractiveEventComplexType Complex Type
type InteractiveEventComplexType
{
    optional array<xml> AnyElements with XmlEncoding{IsAny = true};
} with XmlEncodingDefaults{Namespace = INamespace};

// 2.2.5.1 ArgumentType
pattern ArgumentType = string;

// 2.2.5.2 CapabilityEnumeration
pattern CapabilityEnumeration = enum string
{
    Get = "Get",
    Put = "Put",
    Create = "Create",
    Delete = "Delete",
    Invoke = "Invoke",
    Enumerate = "Enumerate",
    Subscribe = "Subscribe",
    Shell = "Shell",
    Identify = "Identify",
    ...
};

// 2.2.5.3 cim:cimDateTime
// http://go.microsoft.com/fwlink/?LinkId=89852 Section 8.1
// Future Reference: use choice
type cimDateTime
{
    optional string CIM_DateTime;
    optional XSDuration Interval;
    optional string Date;
    optional string Time;
    optional XSDDateTime Datetime;
    xml AnyAttribute with XmlEncoding{IsAny = true, Kind = XmlKind.Attribute, Namespace = XmlNamespaceIndicator.Any};
}

// 2.2.5.4 CommandStateEnumeration
pattern CommandStateEnumeration = enum XSAnyURI
{
    Done = "http://schemas.microsoft.com/wbem/wsman/1/windows/shell/CommandState/Done",
    Pending = "http://schemas.microsoft.com/wbem/wsman/1/windows/shell/CommandState/Pending",
    Running = "http://schemas.microsoft.com/wbem/wsman/1/windows/shell/CommandState/Running",
    ...
};

// 2.2.5.5 ExitCodeType
pattern ExitCodeType = int;

// 2.2.5.6 SignalCodeEnumeration
pattern SignalCodeEnumeration = enum XSAnyURI
{
    terminate = "http://schemas.microsoft.com/wbem/wsman/1/windows/shell/signal/terminate",
    ctrl_c = "http://schemas.microsoft.com/wbem/wsman/1/windows/shell/signal/ctrl_c",
    ctrl_break = "http://schemas.microsoft.com/wbem/wsman/1/windows/shell/signal/ctrl_break",
    $"powershell/signal/ctrl_c" = "powershell/signal/ctrl_c",
    ...
};

// 2.2.5.7 StreamName
pattern StreamName = XSD.Token;

// 2.2.5.8 StreamNameList
pattern StreamNameList = string;

// 2.2.5.9 XmlRenderingTypeEnumeration
pattern XmlRenderingTypeEnumeration = enum string
{
    text = "text",
    XmlReader = "XmlReader",
    ...
};

// 2.2.5.10 OutputBufferingModeEnumeration
pattern OutputBufferingModeEnumeration = enum string
{
    Block = "Block",
    Drop = "Drop",
    ...
};

// 2.2.5.11 EventType_Type
pattern EventType_Type = enum string
{
    NoSemantics = "NoSemantics",
    Debug = "Debug",
    Warning = "Warning",
    Verbose = "Verbose",
    Progress = "Progress",
    Confirm = "Confirm",
    ErrorAction = "ErrorAction",
    StreamingOutput = "StreamingOutput",
    ...
};

// 2.2.5.12 PromptType_Type
pattern PromptType_Type = enum string
{
    Normal = "Normal",
    Critical = "Critical",
    ...
};

// 2.2.5.13 ActionType_Type
pattern ActionType_Type = enum string
{
    Inquire = "Inquire",
    Report = "Report",
    ...
};

// 2.2.5.14 ResponseType
pattern ResponseType = enum string
{
    yes = "yes",
    no = "no",
    yesToAll = "yesToAll",
    noToAll = "noToAll",
    ...
};

// 2.2.5.15 StateType
pattern StateType = enum string
{
    Connected = "Connected",
    Disconnected = "Disconnected",
    ...
};

// 2.2.5.16 Type_Type
pattern Type_Type = enum uint
{
    CIMTypeBoolean = 0,
    CIMTypeUint8 = 1,
    CIMTypeSint8 = 2,
    CIMTypeUint16 = 3,
    CIMTypeSint16 = 4,
    CIMTypeUint32 = 5,
    CIMTypeSint32 = 6,
    CIMTypeUint64 = 7,
    CIMTypeSint64 = 8,
    CIMTypeReal32 = 9,
    CIMTypeReal64 = 10,
    CIMTypeChar16 = 11,
    CIMTypeDateTime = 12,
    CIMTypeString = 13,
    CIMTypeClassReference = 14,
    CIMTypeEmbeddedObjectInstance = 15,
    ArrayOfCIMTypeBoolean = 16,
    ArrayOfCIMTypeUint8 = 17,
    ArrayOfCIMTypeSint8 = 18,
    ArrayOfCIMTypeUint16 = 19,
    ArrayOfCIMTypeSint16 = 20,
    ArrayOfCIMTypeUint32 = 21,
    ArrayOfCIMTypeSint32 = 22,
    ArrayOfCIMTypeUint64 = 23,
    ArrayOfCIMTypeSint64 = 24,
    ArrayOfCIMTypeReal32 = 25,
    ArrayOfCIMTypeReal64 = 26,
    ArrayOfCIMTypeChar16 = 27,
    ArrayOfCIMTypeDateTime = 28,
    ArrayOfCIMTypeString = 29,
    ArrayOfCIMTypeClassReference = 30,
    ArrayOfCIMTypeEmbeddedObjectInstance = 31,
    ...
};

// Namespaces
const string XmlNamespace = "http://www.w3.org/XML/1998/namespace";
const string WSMVNamespace = "http://schemas.microsoft.com/wbem/wsman/1/wsman.xsd";
const string PluginNamespace = "http://schemas.microsoft.com/wbem/wsman/1/config/PluginConfiguration";
const string SNamespace = "http://www.w3.org/2003/05/soap-envelope";
const string XSNamespace = "http://www.w3.org/2001/XMLSchema";
const string CertNamespace = "http://schemas.microsoft.com/wbem/wsman/1/config/service/certmapping";
const string CfgNamespace = "http://schemas.microsoft.com/wbem/wsman/1/config";
const string SubNamespace = "http://schemas.microsoft.com/wbem/wsman/1/subscription";
const string WsmanFaultNamespace = "http://schemas.microsoft.com/wbem/wsman/1/wsmanfault";
const string INamespace = "http://schemas.microsoft.com/wbem/wsman/1/cim/interactive.xsd";
const string MNamespace = "http://schemas.microsoft.com/wbem/wsman/1/machineid";
const string CustomRemoteShellNamespace = "http://schemas.microsoft.com/wbem/wsman/1/config/winrs/customremoteshell";

const string WSMVShellNamespace = "http://schemas.microsoft.com/wbem/wsman/1/windows/shell";
const string WSMVCommandAction = WSMVShellNamespace + "/Command";
const string WSMVCommandResponseAction = WSMVShellNamespace + "/CommandResponse";
const string WSMVSignalAction = WSMVShellNamespace + "/Signal";
const string WSMVSignalResponseAction = WSMVShellNamespace + "/SignalResponse";
const string WSMVSendAction = WSMVShellNamespace + "/Send";
const string WSMVSendResponseAction = WSMVShellNamespace + "/SendResponse";
const string WSMVReceiveAction = WSMVShellNamespace + "/Receive";
const string WSMVReceiveResponseAction = WSMVShellNamespace + "/ReceiveResponse";
const string WSMVDisconnectAction = WSMVShellNamespace + "/Disconnect";
const string WSMVDisconnectResponseAction = WSMVShellNamespace + "/DisconnectResponse";
const string WSMVReconnectAction = WSMVShellNamespace + "/Reconnect";
const string WSMVReconnectResponseAction = WSMVShellNamespace + "/ReconnectResponse";
const string WSMVConnectAction = WSMVShellNamespace + "/Connect";
const string WSMVConnectResponseAction = WSMVShellNamespace + "/ConnectResponse";

const string WSMVPrefix = "http://schemas.microsoft.com/wbem/wsman/1/wsman/";
const string WSMVAcknowledgeRequestAction = WSMVPrefix + "AcknowledgeRequest"; 
const string WSMVAcknowledgeAction = WSMVPrefix + "Acknowledge";
const string WSMVKeepAliveAction = WSMVPrefix + "KeepAlive";
const string WSMVEndAction= WSMVPrefix + "End";
const string WSMVCancelAction = WSMVPrefix + "Cancel";
const string WSMVInteractiveResponseAction = "/InteractiveResponse";

// Resource URIs
const string ConfigResourceUri = "http://schemas.microsoft.com/wbem/wsman/1/config";
const string ClientResourceUri = "http://schemas.microsoft.com/wbem/wsman/1/config/client";
const string ClientAuthResourceUri = "http://schemas.microsoft.com/wbem/wsman/1/config/client/auth";
const string ClientDefaultPortsResourceUri = "http://schemas.microsoft.com/wbem/wsman/1/config/client/defaultports";
const string ServiceResourceUri = "http://schemas.microsoft.com/wbem/wsman/1/config/service";
const string ServiceAuthResourceUri = "http://schemas.microsoft.com/wbem/wsman/1/config/service/auth";
const string ServiceDefaultPortsResourceUri = "http://schemas.microsoft.com/wbem/wsman/1/config/service/defaultports";
const string CertMappingResourceUri = "http://schemas.microsoft.com/wbem/wsman/1/config/service/certmapping";
const string WinrsResourceUri = "http://schemas.microsoft.com/wbem/wsman/1/config/winrs";
const string ListenerResourceUri = "http://schemas.microsoft.com/wbem/wsman/1/config/listener";
const string PluginResourceUri = "http://schemas.microsoft.com/wbem/wsman/1/config/plugin";
const string ShellResourceUri = "http://schemas.microsoft.com/wbem/wsman/1/windows/shell/cmd";
const string SecurityResourceUri = "http://schemas.microsoft.com/wbem/wsman/1/config/service/security";
const string CustomRemoteShellResourceUri = "http://schemas.microsoft.com/wbem/wsman/1/config/winrs/customremoteshell";

const string WSMVProtocolName = "WSMV";
