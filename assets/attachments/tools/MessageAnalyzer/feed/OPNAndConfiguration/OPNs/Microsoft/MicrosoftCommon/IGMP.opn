protocol IGMP with 
BinaryEncodingDefaults{Endian = Endian.Big},
Documentation
{
    ProtocolName = "Internet Group Management Protocol",
    ShortName = "IGMP",
    Description = ""
},
OPNAuthoring
{
    Copyright = "(c) Microsoft Corporation",
    References = 
        [
            new Reference{Name = "RFC 988"},
            new Reference{Name = "RFC 1112"},
            new Reference{Name = "RFC 2236"},
            new Reference{Name = "RFC 3376"},
            new Reference{Name = "igmp-type-numbers", Link = "http://www.iana.org/assignments/igmp-type-numbers"}, 
            new Reference{Name = "MSNIP", Link = "http://tools.ietf.org/html/draft-ietf-idmr-msnip-00"},
            new Reference{Name = "IGAP", Link = "http://bgp.potaroo.net/ietf/all-ids/draft-andou-igmp-auth-00.txt"},
            new Reference{Name = "DVMRP", Link = "http://tools.ietf.org/html/draft-ietf-idmr-dvmrp-v3-11"},
            new Reference{Name = "RFC 1075"},
            new Reference{Name = "PIM-DM", Link = "http://tools.ietf.org/html/draft-ietf-idmr-pim-dm-spec-05"},
            new Reference{Name = "PIM-SM", Link = "http://tools.ietf.org/html/draft-ietf-idmr-pim-spec-02"},
            new Reference{Name = "RFC 4601"},
            new Reference{Name = "traceroute", Link = "http://tools.ietf.org/html/draft-ietf-idmr-traceroute-ipm-07"},
            new Reference{Name = "RFC 4286"},
        ],
    RevisionSummary =    
        [
            new Revision{Class = RevisionClass.Major, Version = "380144", Date = "09/22/2015"}
        ]
};

using IPv4;
using IPv6;
using Standard;
using IANA;
using Utility;
using ESP;
using AH;
using MicrosoftCommonResources;
using Diagnostics;

endpoint Node[binary LocalAddress]
    provides Messages;

autostart actor IGMPOverIPv4(IPv4.Node node)
{
    bool netmaskFlag = false;
    process node accepts p:IPv4.Datagram where p.Protocol == ProtocolType.IGMP 
    {
        DecodeAndDispatchDatagram( p.DestinationAddress.FlatAddress, p.Payload, ref netmaskFlag);
    }
}

autostart actor IGMPOverESP(ESP.Node node)
{  
    bool netmaskFlag = false;
    process node accepts p:ESP.Packet where p.Trailer.NextHeader == IANA.ProtocolType.IGMP
    {
        DecodeAndDispatchDatagram(p#DestinationAddress as binary, p.Payload, ref netmaskFlag);
    }
}

autostart actor IGMPOverIPv6(IPv6.Node node)
{  
    bool netmaskFlag = false;
    process node accepts p:IPv6.Datagram where p.NextProtocol == ProtocolType.IGMP 
    {
        DecodeAndDispatchDatagram(p.DestinationAddress.FlatAddress, p.Payload, ref netmaskFlag);
    }
}

autostart actor IGMPOverAH(AH.Node node)
{
    bool netmaskFlag = false;
    process node accepts p:AH.Msg where (p.NextHeader == ProtocolType.IGMP)
    {
        DecodeAndDispatchDatagram(p#DestinationAddress as binary, p.Payload, ref netmaskFlag);
    }
}

// Decode IGMP segment and dispatch to IGMP layer
void DecodeAndDispatchDatagram(binary destinationAddress, binary payload, ref bool netmaskFlag)
{
    stream s = payload;
    binary secondByte = s.PeekBytes(1 * 8, 1);
    switch (s.CurrentByte)
    {
        case MessageType.CreateGroupRequest => 
            switch (s)
            {
                case m:Messages.CreateGroupRequest from BinaryDecoder<Messages.CreateGroupRequest> =>
                    ValidationCheck(Utility.ValidateCheckSum(payload, m.CheckSum), m, () => Format(IGMP_CHECKSUM_INVALID, "CreateGroupRequest"));
                    dispatch (endpoint Node[destinationAddress]) accepts m;
                default => 
                    ThrowDecodingException("IGMP", "CreateGroupRequest");
            }
        case MessageType.CreateGroupReply =>
            switch (s)
            {
                case m:Messages.CreateGroupReply from BinaryDecoder<Messages.CreateGroupReply> =>
                     ValidationCheck(Utility.ValidateCheckSum(payload, m.CheckSum), m, () => Format(IGMP_CHECKSUM_INVALID, "CreateGroupReply"));
                     dispatch (endpoint Node[destinationAddress]) accepts m;
                default => 
                    ThrowDecodingException("IGMP", "CreateGroupReply");
            }        
        case MessageType.JoinGroupRequest =>
            switch (s)
            {
                case m:Messages.JoinGroupRequest from BinaryDecoder<Messages.JoinGroupRequest> =>
                    ValidationCheck(Utility.ValidateCheckSum(payload, m.CheckSum), m, () => Format(IGMP_CHECKSUM_INVALID, "JoinGroupRequest"));
                    dispatch (endpoint Node[destinationAddress]) accepts m;
                default => 
                    ThrowDecodingException("IGMP", "JoinGroupRequest");
            }  
        case MessageType.JoinGroupReply =>
            switch (s)
            {
                case m:Messages.JoinGroupReply from BinaryDecoder<Messages.JoinGroupReply> =>
                    ValidationCheck(Utility.ValidateCheckSum(payload, m.CheckSum), m, () => Format(IGMP_CHECKSUM_INVALID, "JoinGroupReply"));
                    dispatch (endpoint Node[destinationAddress]) accepts m;
                default => 
                    ThrowDecodingException("IGMP", "JoinGroupReply");
            } 
        case MessageType.LeaveGroupRequest =>
            switch (s)
            {
                case m:Messages.LeaveGroupRequest from BinaryDecoder<Messages.LeaveGroupRequest> =>
                    ValidationCheck(Utility.ValidateCheckSum(payload, m.CheckSum), m, () => Format(IGMP_CHECKSUM_INVALID, "LeaveGroupRequest"));
                    dispatch (endpoint Node[destinationAddress]) accepts m;
                default => 
                    ThrowDecodingException("IGMP", "LeaveGroupRequest");
            } 
        case MessageType.LeaveGroupReply =>
            switch (s)
            {
                case m:Messages.LeaveGroupReply from BinaryDecoder<Messages.LeaveGroupReply> =>
                    ValidationCheck(Utility.ValidateCheckSum(payload, m.CheckSum), m, () => Format(IGMP_CHECKSUM_INVALID, "LeaveGroupReply"));
                     dispatch (endpoint Node[destinationAddress]) accepts m;
                default => 
                    ThrowDecodingException("IGMP", "LeaveGroupReply");
            } 
        case MessageType.ConfirmGroupRequest =>
            switch (s)
            {
                case m:Messages.ConfirmGroupRequest from BinaryDecoder<Messages.ConfirmGroupRequest> =>
                    ValidationCheck(Utility.ValidateCheckSum(payload, m.CheckSum), m, () => Format(IGMP_CHECKSUM_INVALID, "ConfirmGroupRequest"));
                    dispatch (endpoint Node[destinationAddress]) accepts m;
                default => 
                    ThrowDecodingException("IGMP", "ConfirmGroupRequest");
            } 
        case MessageType.ConfirmGroupReply =>
            switch (s)
            {
                case m:Messages.ConfirmGroupReply from BinaryDecoder<Messages.ConfirmGroupReply> =>
                     ValidationCheck(Utility.ValidateCheckSum(payload, m.CheckSum), m, () => Format(IGMP_CHECKSUM_INVALID, "ConfirmGroupReply"));
                     dispatch (endpoint Node[destinationAddress]) accepts m;
                default => 
                    ThrowDecodingException("IGMP", "ConfirmGroupReply");
            }
        case MessageType.MembershipQuery =>
        {
            if (s.ByteLength == 8 && secondByte == $[00])
            {
                switch (s)
                {
                    case m:Messages.V1MembershipQueryMessage from BinaryDecoder<Messages.V1MembershipQueryMessage> =>
                         ValidationCheck(Utility.ValidateCheckSum(payload, m.CheckSum), m, () => Format(IGMP_CHECKSUM_INVALID, "V1MembershipQueryMessage"));
                         dispatch (endpoint Node[destinationAddress]) accepts m;
                    default => 
                        ThrowDecodingException("IGMP", "V1MembershipQueryMessage");
                }
            }
            else if (s.ByteLength == 8 && secondByte != $[00])
            {
                switch (s)
                {
                    case m:Messages.V2MembershipQueryMessage from BinaryDecoder<Messages.V2MembershipQueryMessage> =>
                         ValidationCheck(Utility.ValidateCheckSum(payload, m.CheckSum), m, () => Format(IGMP_CHECKSUM_INVALID, "V2MembershipQueryMessage"));
                         dispatch (endpoint Node[destinationAddress]) accepts m;
                    default => 
                        ThrowDecodingException("IGMP", "V2MembershipQueryMessage");
                }
            }
            else if (s.ByteLength >= 12)
            {
                switch (s)
                {
                    case m:Messages.V3MembershipQueryMessage from BinaryDecoder<Messages.V3MembershipQueryMessage> =>
                        ValidationCheck(Utility.ValidateCheckSum(payload, m.CheckSum), m, () => Format(IGMP_CHECKSUM_INVALID, "V3MembershipQueryMessage"));
                        dispatch (endpoint Node[destinationAddress]) accepts m;
                    default => 
                        ThrowDecodingException("IGMP", "V3MembershipQueryMessage");
                }
            } 
        } 
        case MessageType.V1MembershipReport =>
            switch (s)
            {
                case m:Messages.V1MembershipReport from BinaryDecoder<Messages.V1MembershipReport> =>
                     ValidationCheck(Utility.ValidateCheckSum(payload, m.CheckSum), m, () => Format(IGMP_CHECKSUM_INVALID, "V1MembershipReport"));
                     dispatch (endpoint Node[destinationAddress]) accepts m;
                default => 
                    ThrowDecodingException("IGMP", "V1MembershipReport");
            }
        case MessageType.DVMRP =>
        {
            if (s.PeekBytes(6 * 8, 1) == $[FF] && s.PeekBytes(7 * 8, 1) == $[03])
            {
                switch (s)
                {
                    case m:Messages.DVMRPV3 from BinaryDecoder<Messages.DVMRPV3> =>
                         ValidationCheck(Utility.ValidateCheckSum(payload, m.CheckSum), m, () => Format(IGMP_CHECKSUM_INVALID, "DVMRPV3"));
                         if (s.PeekBytes(1 * 8, 1) == $[01])
                         {
                             // Keep N bit in ProbeCapabilityFlags for network masks appended to the Prune, Graft, and Graft Ack messages or not
                             netmaskFlag = (s.PeekByte(5 * 8) & 0x20) as bool;
                         }
                         else if (!netmaskFlag)
                         {
                             if (secondByte == $[07])
                             {
                                 DVMRPPrune prune = m.Messages as DVMRPPrune;
                                 prune.SourceNetworkMask = nothing;
                                 m.Messages = prune;
                             }
                             else if (secondByte == $[08])
                             {
                                 DVMRPGraft graft = m.Messages as DVMRPGraft;
                                 graft.SourceNetworkMask = nothing;
                                 m.Messages = graft;
                             }
                             else if (secondByte == $[09])
                             {
                                 DVMRPGraftAck graftAck = m.Messages as DVMRPGraftAck;
                                 graftAck.SourceNetworkMask = nothing;
                                 m.Messages = graftAck;
                             }
                         }  
                         dispatch (endpoint Node[destinationAddress]) accepts m;
                    default => 
                        ThrowDecodingException("IGMP", "DVMRPV3");
                }
            }
            else
            {
                switch (s)
                {
                    case m:Messages.DVMRPV1 from BinaryDecoder<Messages.DVMRPV1> =>
                         ValidationCheck(Utility.ValidateCheckSum(payload, m.CheckSum), m, () => Format(IGMP_CHECKSUM_INVALID, "DVMRPV1"));
                         dispatch (endpoint Node[destinationAddress]) accepts m;
                    default => 
                        ThrowDecodingException("IGMP", "DVMRPV1");
                }
            }
        }
        case MessageType.PIMVersion1 =>
        {
            if (secondByte == $[00])
            {
                switch (s)
                {
                    case m:Messages.PIMQuery from BinaryDecoder<Messages.PIMQuery> =>
                        ValidationCheck(Utility.ValidateCheckSum(payload, m.PIMHeader.CheckSum), m, () => Format(IGMP_CHECKSUM_INVALID, "PIMQuery"));
                        dispatch (endpoint Node[destinationAddress]) accepts m;
                    default => 
                        ThrowDecodingException("IGMP", "PIMQuery");
                }
            }
            else if (secondByte == $[01])
            {
                switch (s)
                {
                    case m:Messages.PIMRegister from BinaryDecoder<Messages.PIMRegister> =>
                        ValidationCheck(Utility.ValidateCheckSum(payload, m.PIMHeader.CheckSum), m, () => Format(IGMP_CHECKSUM_INVALID, "PIMRegister"));
                        dispatch (endpoint Node[destinationAddress]) accepts m;
                    default => 
                        ThrowDecodingException("IGMP", "PIMRegister");
                }
            }
            else if (secondByte == $[02])
            {
                switch (s)
                {
                    case m:Messages.PIMRegister from BinaryDecoder<Messages.PIMRegister> =>
                        ValidationCheck(Utility.ValidateCheckSum(payload, m.PIMHeader.CheckSum), m, () => Format(IGMP_CHECKSUM_INVALID, "PIMRegister"));
                        dispatch (endpoint Node[destinationAddress]) accepts m;
                    default => 
                        ThrowDecodingException("IGMP", "PIMRegister");
                }
            }
            else if (secondByte == $[03])
            {
                switch (s)
                {
                    case m:Messages.PIMJoinPrune  from BinaryDecoder<Messages.PIMJoinPrune> =>
                        ValidationCheck(Utility.ValidateCheckSum(payload, m.PIMHeader.CheckSum), m, () => Format(IGMP_CHECKSUM_INVALID, "PIMJoinPrune"));
                        dispatch (endpoint Node[destinationAddress]) accepts m;
                    default => 
                        ThrowDecodingException("IGMP", "PIMJoinPrune");
                }
            }
            else if (secondByte == $[04])
            {
                switch (s)
                {
                    case m:Messages.PIMRPReachability from BinaryDecoder<Messages.PIMRPReachability> =>
                        ValidationCheck(Utility.ValidateCheckSum(payload, m.PIMHeader.CheckSum), m, () => Format(IGMP_CHECKSUM_INVALID, "PIMRPReachability"));
                        dispatch (endpoint Node[destinationAddress]) accepts m;
                    default => 
                        ThrowDecodingException("IGMP", "PIMRPReachability");
                }
            }
            else if (secondByte == $[05])
            {
                switch (s)
                {
                    case m:Messages.PIMAssert from BinaryDecoder<Messages.PIMAssert> =>
                        ValidationCheck(Utility.ValidateCheckSum(payload, m.PIMHeader.CheckSum), m, () => Format(IGMP_CHECKSUM_INVALID, "PIMAssert"));
                        dispatch (endpoint Node[destinationAddress]) accepts m;
                    default => 
                        ThrowDecodingException("IGMP", "PIMAssert");
                }
            }
            else if (secondByte == $[08])
            {
                switch (s)
                {
                    case m:Messages.PIMCandidateRPAdvertisement from BinaryDecoder<Messages.PIMCandidateRPAdvertisement> =>
                        ValidationCheck(Utility.ValidateCheckSum(payload, m.PIMHeader.CheckSum), m, () => Format(IGMP_CHECKSUM_INVALID, "PIMCandidateRPAdvertisement"));
                        dispatch (endpoint Node[destinationAddress]) accepts m;
                    default => 
                        ThrowDecodingException("IGMP", "PIMCandidateRPAdvertisement");
                }
            }
            else if (secondByte == $[09])
            {
                switch (s)
                {
                    case m:Messages.PIMPoll from BinaryDecoder<Messages.PIMPoll> =>
                        ValidationCheck(Utility.ValidateCheckSum(payload, m.PIMHeader.CheckSum), m, () => Format(IGMP_CHECKSUM_INVALID, "PIMPoll"));
                        dispatch (endpoint Node[destinationAddress]) accepts m;
                    default => 
                        ThrowDecodingException("IGMP", "PIMPoll");
                }
            }
        }
        case MessageType.CiscoTraceMessages =>
            switch (s)
            {
                case m:Messages.CiscoTraceMessages from BinaryDecoder<Messages.CiscoTraceMessages> =>
                     dispatch (endpoint Node[destinationAddress]) accepts m;
                default => 
                    ThrowDecodingException("IGMP", "CiscoTraceMessages");
            }
        case MessageType.V2MembershipReport =>
            switch (s)
            {
                case m:Messages.V2MembershipReport from BinaryDecoder<Messages.V2MembershipReport> =>
                     ValidationCheck(Utility.ValidateCheckSum(payload, m.CheckSum), m, () => Format(IGMP_CHECKSUM_INVALID, "V2MembershipReport"));
                     dispatch (endpoint Node[destinationAddress]) accepts m;
                default => 
                    ThrowDecodingException("IGMP", "V2MembershipReport");
            }
        case MessageType.V2LeaveGroup =>
            switch (s)
            {
                case m:Messages.V2LeaveGroup from BinaryDecoder<Messages.V2LeaveGroup> =>
                     ValidationCheck(Utility.ValidateCheckSum(payload, m.CheckSum), m, () => Format(IGMP_CHECKSUM_INVALID, "V2LeaveGroup"));
                     dispatch (endpoint Node[destinationAddress]) accepts m;
                default => 
                    ThrowDecodingException("IGMP", "V2LeaveGroup");
            }
        case MessageType.MulticastTracerouteResponse =>
            switch (s)
            {
                case m:Messages.MulticastTracerouteResponse from BinaryDecoder<Messages.MulticastTracerouteResponse> =>
                     ValidationCheck(Utility.ValidateCheckSum(payload, m.CheckSum), m, () => Format(IGMP_CHECKSUM_INVALID, "MulticastTracerouteResponse"));
                     dispatch (endpoint Node[destinationAddress]) accepts m;
                default => 
                    ThrowDecodingException("IGMP", "MulticastTracerouteResponse");
            }
        case MessageType.MulticastTraceroute =>
            switch (s)
            {
                case m:Messages.MulticastTraceroute from BinaryDecoder<Messages.MulticastTraceroute> =>
                     ValidationCheck(Utility.ValidateCheckSum(payload, m.CheckSum), m, () => Format(IGMP_CHECKSUM_INVALID, "MulticastTraceroute"));
                     dispatch (endpoint Node[destinationAddress]) accepts m;
                default => 
                    ThrowDecodingException("IGMP", "MulticastTraceroute");
            }
        case MessageType.V3MembershipReport =>
            switch (s)
            {
                case m:Messages.V3MembershipReport from BinaryDecoder<Messages.V3MembershipReport> =>
                     ValidationCheck(Utility.ValidateCheckSum(payload, m.CheckSum), m, () => Format(IGMP_CHECKSUM_INVALID, "V3MembershipReport"));
                     dispatch (endpoint Node[destinationAddress]) accepts m;
                default => 
                    ThrowDecodingException("IGMP", "V3MembershipReport");
            }
        case MessageType.GroupMap =>
            switch (s)
            {
                case m:Messages.GroupMap from BinaryDecoder<Messages.GroupMap> =>
                     ValidationCheck(Utility.ValidateCheckSum(payload, m.CheckSum), m, () => Format(IGMP_CHECKSUM_INVALID, "GroupMap"));
                     dispatch (endpoint Node[destinationAddress]) accepts m;
                default => 
                    ThrowDecodingException("IGMP", "GroupMap");
            }
        case MessageType.InterestSolicitation =>
            switch (s)
            {
                case m:Messages.InterestSolicitation from BinaryDecoder<Messages.InterestSolicitation> =>
                     ValidationCheck(Utility.ValidateCheckSum(payload, m.CheckSum), m, () => Format(IGMP_CHECKSUM_INVALID, "InterestSolicitation"));
                     dispatch (endpoint Node[destinationAddress]) accepts m;
                default => 
                    ThrowDecodingException("IGMP", "InterestSolicitation");
            }
        case MessageType.ReceiverMembershipReport =>
            switch (s)
            {
                case m:Messages.ReceiverMembershipReport from BinaryDecoder<Messages.ReceiverMembershipReport> =>
                     ValidationCheck(Utility.ValidateCheckSum(payload, m.CheckSum), m, () => Format(IGMP_CHECKSUM_INVALID, "ReceiverMembershipReport"));
                     dispatch (endpoint Node[destinationAddress]) accepts m;
                default => 
                    ThrowDecodingException("IGMP", "ReceiverMembershipReport");
            }
        case MessageType.MulticastRouterAdvertisement =>
            switch (s)
            {
                case m:Messages.MulticastRouterAdvertisement from BinaryDecoder<Messages.MulticastRouterAdvertisement> =>
                     ValidationCheck(Utility.ValidateCheckSum(payload, m.CheckSum), m, () => Format(IGMP_CHECKSUM_INVALID, "MulticastRouterAdvertisement"));
                     dispatch (endpoint Node[destinationAddress]) accepts m;
                default => 
                    ThrowDecodingException("IGMP", "MulticastRouterAdvertisement");
            }
        case MessageType.MulticastRouterSolicitation =>
            switch (s)
            {
                case m:Messages.MulticastRouterSolicitation from BinaryDecoder<Messages.MulticastRouterSolicitation> =>
                     ValidationCheck(Utility.ValidateCheckSum(payload, m.CheckSum), m, () => Format(IGMP_CHECKSUM_INVALID, "MulticastRouterSolicitation"));
                     dispatch (endpoint Node[destinationAddress]) accepts m;
                default => 
                    ThrowDecodingException("IGMP", "MulticastRouterSolicitation");
            }
        case MessageType.MulticastRouterTermination =>
            switch (s)
            {
                case m:Messages.MulticastRouterTermination from BinaryDecoder<Messages.MulticastRouterTermination> =>
                     ValidationCheck(Utility.ValidateCheckSum(payload, m.CheckSum), m, () => Format(IGMP_CHECKSUM_INVALID, "MulticastRouterTermination"));
                     dispatch (endpoint Node[destinationAddress]) accepts m;
                default => 
                    ThrowDecodingException("IGMP", "MulticastRouterTermination");
            }
        case MessageType.IGAPMembershipReport =>
            switch (s)
            {
                case m:Messages.IGAPMembershipReport from BinaryDecoder<Messages.IGAPMembershipReport> =>
                     ValidationCheck(Utility.ValidateCheckSum(payload, m.CheckSum), m, () => Format(IGMP_CHECKSUM_INVALID, "IGAPMembershipReport"));
                     dispatch (endpoint Node[destinationAddress]) accepts m;
                default => 
                    ThrowDecodingException("IGMP", "IGAPMembershipReport");
            }
        case MessageType.IGAPMembershipQuery =>
            switch (s)
            {
                case m:Messages.IGAPMembershipQuery from BinaryDecoder<Messages.IGAPMembershipQuery> =>
                     ValidationCheck(Utility.ValidateCheckSum(payload, m.CheckSum), m, () => Format(IGMP_CHECKSUM_INVALID, "IGAPMembershipQuery"));
                     dispatch (endpoint Node[destinationAddress]) accepts m;
                default => 
                    ThrowDecodingException("IGMP", "IGAPMembershipQuery");
            }
        case MessageType.IGAPLeaveGroup =>
            switch (s)
            {
                case m:Messages.IGAPLeaveGroup from BinaryDecoder<Messages.IGAPLeaveGroup> =>
                     ValidationCheck(Utility.ValidateCheckSum(payload, m.CheckSum), m, () => Format(IGMP_CHECKSUM_INVALID, "IGAPLeaveGroup"));
                     dispatch (endpoint Node[destinationAddress]) accepts m;
                default => 
                    ThrowDecodingException("IGMP", "IGAPLeaveGroup");
            }
        default =>
            switch (s)
            {
                case m:Messages.UndefinedMessages from BinaryDecoder<Messages.UndefinedMessages> =>
                     dispatch (endpoint Node[destinationAddress]) accepts m;
                default => 
                    ThrowDecodingException("IGMP", "UndefinedMessages");
            }
    }
}

//igmp-type-numbers, other type
//draft-ietf-idmr-msnip-00.txt, type 0x23~0x25
//draft-andou-igmp-auth-00.txt, type 0x40~0x42
pattern MessageType = enum byte
{
    CreateGroupRequest = 0x1,                                    
    CreateGroupReply = 0x2,                                      
    JoinGroupRequest = 0x3,                                     
    JoinGroupReply = 0x4,                                       
    LeaveGroupRequest = 0x5,                                     
    LeaveGroupReply = 0x6,                                       
    ConfirmGroupRequest = 0x7,                                   
    ConfirmGroupReply = 0x8,                                     
    MembershipQuery = 0x11,                                  
    V1MembershipReport = 0x12,                               
    DVMRP = 0x13,                                                
    PIMVersion1 = 0x14,                                          
    CiscoTraceMessages = 0x15,                                   
    V2MembershipReport = 0x16,                               
    V2LeaveGroup = 0x17,                                     
    MulticastTracerouteResponse = 0x1E,                          
    MulticastTraceroute = 0x1F,                                  
    V3MembershipReport = 0x22,                               
    GroupMap = 0x23,                                             
    InterestSolicitation = 0x24,                                 
    ReceiverMembershipReport = 0x25,                             
    MulticastRouterAdvertisement = 0x30,                         
    MulticastRouterSolicitation = 0x31,                          
    MulticastRouterTermination = 0x32,                           
    IGAPMembershipReport = 0x40,                                 
    IGAPMembershipQuery = 0x41,                                  
    IGAPLeaveGroup = 0x42,
    ...
};

contract Messages
{
    // In order to pass message as parameter to define this message
    accepts message Imessage
    {
    }
    
    // RFC 988
    accepts message CreateGroupRequest : Imessage
    {
        (byte where value == 1) Type;
        byte Code where ValidationCheck(value in {0, 1}, null , "IGMP: The Code in message CreateGroupRequest should be zero or 1.");
        ushort CheckSum;
        uint Identifier;
        IPv4Address GroupAddress;
        long AccessKey;
    
        override string ToString()
        {
            return "Create Group Request (Obsoleted)";
        }  
    }

    accepts message CreateGroupReply : Imessage
    {
        (byte where value == 2) Type;
        byte Code where ErrorCodeIf(value in {1, 2, 3, 4}, null , "Request denied.");
        ushort CheckSum;
        uint Identifier;
        IPv4Address GroupAddress;
        long AccessKey;
    
        override string ToString()
        {
            return "Create Group Reply (Obsoleted)";
        } 
    }

    accepts message JoinGroupRequest : Imessage
    {
        (byte where value == 3) Type;
        byte Code where ValidationCheck(value == 0, null , "IGMP: The Code in message JoinGroupRequest should be set to zero.");
        ushort CheckSum;
        uint Identifier;
        IPv4Address GroupAddress;
        long AccessKey;
    
        override string ToString()
        {
            return "Join Group Request (Obsoleted)";
        } 
    }

    accepts message JoinGroupReply : Imessage
    {
        (byte where value == 4) Type;
        byte Code where ErrorCodeIf(value in {1, 2, 3, 4}, null , "Request denied.");
        ushort CheckSum;
        uint Identifier;
        IPv4Address GroupAddress;
        long AccessKey;
    
        override string ToString()
        {
            return "Join Group Reply (Obsoleted)";
        }
    }

    accepts message LeaveGroupRequest : Imessage
    {
        (byte where value == 5) Type;
        byte Code where ValidationCheck(value == 0, null , "IGMP: The Code in message LeaveGroupRequest should be set to zero.");
        ushort CheckSum;
        uint Identifier;
        IPv4Address GroupAddress;
        long AccessKey;
    
        override string ToString()
        {
            return "Leave Group Request (Obsoleted)";
        }
    }

    accepts message LeaveGroupReply : Imessage
    {
        (byte where value == 6) Type;
        byte Code where ErrorCodeIf(value in {1, 2, 3, 4}, null , "Request denied.");
        ushort CheckSum;
        uint Identifier;
        IPv4Address GroupAddress;
        long AccessKey;
    
        override string ToString()
        {
            return "Leave Group Reply (Obsoleted)";
        }
    }

    accepts message ConfirmGroupRequest : Imessage
    {
        (byte where value == 7) Type;
        byte Code where ValidationCheck(value == 0, null , "IGMP: The Code in message ConfirmGroupRequest should be set to zero.");
        ushort CheckSum;
        uint Identifier;
        IPv4Address GroupAddress;
        long AccessKey;
    
        override string ToString()
        {
            return "Confirm Group Request (Obsoleted)";
        }
    }

    accepts message ConfirmGroupReply : Imessage
    {
        (byte where value == 8) Type;
        byte Code where ErrorCodeIf(value in {1, 2, 3, 4}, null , "Request denied.");
        ushort CheckSum;
        uint Identifier;
        IPv4Address GroupAddress;
        long AccessKey;
    
        override string ToString()
        {
            return "Confirm Group Reply (Obsoleted)";
        }
    }
    
    // RFC 1112
    accepts message V1MembershipQueryMessage : Imessage
    {
        (byte where value == 1) Version with BinaryEncoding{Width = 4};
        (byte where value == 1) Type with BinaryEncoding{Width = 4}; 
        byte Unused;
        ushort CheckSum;
        IPv4Address GroupAddress;
    
        override string ToString()
        {
            return "IGMPv1 Membership Query";
        }
    }

    accepts message V1MembershipReport : Imessage
    {
       (byte where value == 1) Version with BinaryEncoding{Width = 4};
       (byte where value == 2) Type with BinaryEncoding{Width = 4}; 
       byte Unused;
       ushort CheckSum;
       IPv4Address GroupAddress;
   
       override string ToString()
       {
           return  "IGMPv1 Membership Report";
       }
    }

    // RFC 2236
    accepts message V2MembershipQueryMessage : Imessage
    {
        (byte where value == 17) Type ;
        byte MaxRespTime;
        ushort CheckSum;
        IPv4Address GroupAddress;
    
       override string ToString()
       {
           return "IGMPv2 Membership Query";
       }
    }

    accepts message V2MembershipReport : Imessage
    {
       (byte where value == 22) Type;
        byte MaxRespTime;
        ushort CheckSum;
        IPv4Address GroupAddress;
    
       override string ToString()
       {
           return "IGMPv2 Membership Report";
       }
    }

    accepts message V2LeaveGroup : Imessage
    {
        (byte where value == 23) Type;
        byte MaxRespTime;
        ushort CheckSum;
        IPv4Address GroupAddress;
    
       override string ToString()
       {
           return "IGMPv2 Leave Group";
       }
    }

    // RFC 3376
    accepts message V3MembershipQueryMessage : Imessage
    {
        (byte where value == 17) Type;
        byte MaxRespCode;
        ushort CheckSum;
        IPv4Address GroupAddress;
        V3MembershipQueryMessageFlag Flag;
        byte QQIC;
        ushort NumberofSources;
        optional [|NumberofSources > 0|] array<IPv4Address> SourceAddresses 
            where ValidationCheckLength(NumberofSources > 0 ? (value as array<IPv4Address>).Count == NumberofSources : true, null, false, Utility.ReferenceType.Message, 
                                        "IGMP", "SourceAddresses", "V3MembershipQueryMessage", NumberofSources, NumberofSources > 0 ? (value as array<IPv4Address>).Count : 0)
            with BinaryEncoding{MaxLength = NumberofSources};
    
       override string ToString()
       {
           return "IGMPv3 Membership Query";
       }
    }
    
    accepts message V3MembershipReport : Imessage
    {
        (byte where value == 34) Type;
        byte Reserved1 where ValidationCheck(value == 0, null, "IGMP: The Reserved1 in message V3MembershipReport should be set to zero.");
        ushort CheckSum;
        ushort Reserved2 where ValidationCheck(value == 0, null, "IGMP: The Reserved2 in message V3MembershipReport should be set to zero.");
        ushort NumOfGroupRecords;
        optional [|NumOfGroupRecords > 0|] array<GroupRecord> GroupRecords with BinaryEncoding{Length = NumOfGroupRecords};

       override string ToString()
       {
           return "IGMPv3 Membership Report";
       }
    }
      
    // RFC 1075
    accepts message DVMRPV1 : Imessage
    {
       (byte where value == 1) Version with BinaryEncoding{Width = 4};
       (byte where value == 3) Type with BinaryEncoding{Width = 4};
        byte SubType where ValidationCheck(value is SubType , null , "Sub Type undefined.");
           ushort CheckSum;
        (NULLCommand | AddressFamilyIndicatorCommand | SubnetmaskCommand | MetricCommand | Flags0Command |
        InfinityCommand | DestinationAddressCommand | RequestedDestinationAddressCommand | NonMembershipReportCommand |
        NonMembershipReportCancelCommand) Command;
    
       override string ToString()
       {
           return "DVMRPv1 " + EnumToString<IGMP.SubType>(SubType, false);
       }
    }
    
    // http://tools.ietf.org/html/draft-ietf-idmr-dvmrp-v3-11
    accepts message DVMRPV3 : Imessage
    {
        (byte where value == 19) Type;
        byte Code where ValidationCheck(value is Code, null, "Code undefined.");
        ushort CheckSum;
        array <byte> Reserved with BinaryEncoding{Length = Code in {1,6}? 1: 2};
        optional ([|Code == 6|] FlagCapabilities | [|Code == 1|] ProbeCapabilityFlags) Capabilities;
        (byte where value == 255) Minor;
        (byte where value == 3) Major;
        ([|Code == 1|] DVMRPProbe        | 
         [|Code == 2|] DVMRPReport       | 
         [|Code == 5|] DVMRPAskNeighbors2| 
         [|Code == 6|] DVMRPNeighbors2   | 
         [|Code == 7|] DVMRPPrune        | 
         [|Code == 8|] DVMRPGraft        | 
         [|Code == 9|] DVMRPGraftAck     | 
        UndefinedMessage) Messages;
    
       override string ToString()
       {
           return "DVMRPv3 " + EnumToString<IGMP.Code>(Code, false);
       }
    }
    
    // http://tools.ietf.org/html/draft-ietf-idmr-pim-spec-02 0x14
    accepts message PIMQuery : Imessage
    {
        PIMVersion1 PIMHeader;
        uint PIMVer with BinaryEncoding{Width = 4};
        uint Reserved1 with BinaryEncoding{Width = 20};
        byte AddrLength;
        ushort Reserved2;
        ushort Holdtime;
    
       override string ToString()
       {
           return "PIM Router-Query";
       }
    }
    
    accepts message PIMRegister : Imessage
    {
        PIMVersion1 PIMHeader;
        uint PIMVer with BinaryEncoding{Width = 4};
        uint Reserved1 with BinaryEncoding{Width = 20};
        byte AddrLength;
        bool D with BinaryEncoding{Width = 1};
        bool Q with BinaryEncoding{Width = 1};
        uint Reserved2 with BinaryEncoding{Width = 24};
        uint RPCnt with BinaryEncoding{Width = 4};
        optional [|RPCnt > 0|] array<IPv4Address> UnicastRPAddress with BinaryEncoding{Length = RPCnt};
        optional (binary where D == true) MulticastDataPacket;
        
       override string ToString()
       {
           return "PIM Register";
       }
    }
    
    accepts message PIMRegisterAck : Imessage
    {
        PIMVersion1 PIMHeader;
        uint PIMVer with BinaryEncoding{Width = 4};
        uint Reserved1 with BinaryEncoding{Width = 20};
        byte AddrLength;
        IPv4Address EncodedGroupAddress;
        IPv4Address UnicastSourceAddress;
        IPv4Address UnicastActiveRPAddress;
        bool N with BinaryEncoding{Width = 1};
        uint Reserved2 with BinaryEncoding{Width = 31};
        
       override string ToString()
       {
           return "PIM Register-Ack";
       }
    }
    
    accepts message PIMJoinPrune : Imessage
    {
        PIMVersion1 PIMHeader;
        uint PIMVer with BinaryEncoding{Width = 4};
        uint Reserved1 with BinaryEncoding{Width = 20};
        byte AddrLength;
        IPv4Address UnicastUpstreamNeighborAddress;
        byte Reserved2;
        byte NumGroups;
        ushort Holdtime;
        optional [|NumGroups > 0|] array<PIMJoinPruneGroup> PIMJoinPruneGroups with BinaryEncoding{Length = NumGroups};
                
       override string ToString()
       {
           return "PIM Join/Prune";
       }
    }
    
    accepts message PIMRPReachability : Imessage
    {
        PIMVersion1 PIMHeader;
        uint PIMVer with BinaryEncoding{Width = 4};
        uint Reserved1 with BinaryEncoding{Width = 20};
        byte AddrLength;
        IPv4Address EncodedGroupAddress;
        IPv4Address UnicastRPAddress;
        ushort Reserved2;
        ushort Holdtime;
                
       override string ToString()
       {
           return "PIM RP-Reachability";
       }
    }
    
    accepts message PIMAssert : Imessage
    {
        PIMVersion1 PIMHeader;
        uint PIMVer with BinaryEncoding{Width = 4};
        uint Reserved1 with BinaryEncoding{Width = 20};
        byte AddrLength;
        IPv4Address EncodedGroupAddress;
        IPv4Address UnicastSourceAddress;
        bool R with BinaryEncoding{Width = 1};
        uint MetricPreference with BinaryEncoding{Width = 31};
        uint Metric;
                
       override string ToString()
       {
           return "PIM Assert";
       }
    }
    
    accepts message PIMCandidateRPAdvertisement : Imessage
    {
        PIMVersion1 PIMHeader;
        uint PIMVer with BinaryEncoding{Width = 4};
        uint Reserved1 with BinaryEncoding{Width = 20};
        byte AddrLength;
        ushort IntendedHopCount;
        ushort HoldTime;
        IPv4Address EncodedGroupAddress;
                
       override string ToString()
       {
           return "PIM Candidate-RP-Advertisement";
       }
    }
    
    accepts message PIMPoll : Imessage
    {
        PIMVersion1 PIMHeader;
        uint PIMVer with BinaryEncoding{Width = 4};
        uint Reserved1 with BinaryEncoding{Width = 20};
        byte AddrLength;
        bool P with BinaryEncoding{Width = 1};
        uint Reserved2 with BinaryEncoding{Width = 31};
                
       override string ToString()
       {
           return "PIM Poll";
       }
    }
    
    accepts message CiscoTraceMessages : Imessage
    {                  
       override string ToString()
       {
           return "Cisco Trace Messages";
       }             
    }

    // http://tools.ietf.org/html/draft-ietf-idmr-traceroute-ipm-07
    accepts message MulticastTracerouteResponse : Imessage
    {   
        (byte where value == 30) Type;
        byte Hops;
        ushort CheckSum;
        IPv4Address MulticastGroupAddress;
        IPv4Address SourceAddress;
        IPv4Address DestinationAddress;
        IPv4Address ResponseAddress;
        byte RespTTL;
        array<byte> QueryID with BinaryEncoding{Length = 3};
        ResposeData ResposeData;
    
       override string ToString()
       {
           return "Multicast Traceroute Response";
       }             
    }
    
    accepts message MulticastTraceroute : Imessage
    {   
        (byte where value == 31) Type;
        byte Hops;
        ushort CheckSum;
        IPv4Address MulticastGroupAddress;
        IPv4Address SourceAddress;
        IPv4Address DestinationAddress;
        IPv4Address ResponseAddress;
        byte RespTTL;
        array<byte> QueryID with BinaryEncoding{Length = 3};
    
       override string ToString()
       {
           return "Multicast Traceroute";
       }           
    }

    // http://tools.ietf.org/html/draft-ietf-idmr-msnip-01
    accepts message GroupMap : Imessage
    {
        (byte where value == 35) Type;
        byte RangeCount;
        ushort CheckSum;
        uint HoldTime;
        optional [|RangeCount > 0|] array<GroupRangeRecord> GroupRangeRecords with BinaryEncoding{Length = RangeCount};
    
       override string ToString()
       {
           return "Range Map";
       }
    }
    
    accepts message InterestSolicitation : Imessage
    {
        (byte where value == 36) Type;
        byte Reserved where ValidationCheck(value == 0, null, "IGMP: The Reserved in message InterestSolicitation should be set to zero.");
        ushort CheckSum;
        ushort HoldTime;
        ushort GenID;
    
       override string ToString()
       {
           return "Interest Solicitation";
       }
    }

    accepts message ReceiverMembershipReport : Imessage
    {
        (byte where value == 37) Type;
        byte DestCount;
        ushort CheckSum;
        optional [|DestCount > 0|] array<ReceiverMembershipReportGroupAddress> ReceiverMembershipReportGroupAddresses with BinaryEncoding{Length = DestCount};
    
       override string ToString()
       {
           return "Receiver Membership Report";
       }
    }
    
    // RFC 4286
    accepts message MulticastRouterAdvertisement : Imessage
    {
        (byte where value == 48) Type;
        byte AdInterval;
        ushort CheckSum;
        ushort QueryInterval;
        ushort RobustnessVariable;
    
       override string ToString()
       {
           return "Multicast Router Advertisement";
       }
    }

    accepts message MulticastRouterSolicitation : Imessage
    {
        (byte where value == 49) Type;
        byte Reserved where ValidationCheck(value == 0, null, "IGMP: The Reserved in message MulticastRouterSolicitation should be set to zero.");
        ushort CheckSum;
    
       override string ToString()
       {
           return "Multicast Router Solicitation";
       }
    }

    accepts message MulticastRouterTermination : Imessage
    {
        (byte where value == 50) Type;
        byte Reserved where ValidationCheck(value == 0, null, "IGMP: The Reserved in message MulticastRouterTermination should be set to zero.");
        ushort CheckSum;
    
       override string ToString()
       {
           return "Multicast Router Termination";
       }
    }

    // http://tools.ietf.org/html/draft-andou-igmp-auth-00
    accepts message IGAPMembershipReport : Imessage
    {
        (byte where value == 64) Type;
        byte MaxRespTime;
        ushort CheckSum;
        IPv4Address GroupAddress;
        byte Version where ValidationCheck(value == 16, null, "IGMP: The Version in message IGAPMembershipReport must be set to 0x10.");
        byte ReportType where ValidationCheck(value in {1, 2, 3, 4} , null, "ReportType undefined.");
        byte Reserved1;
        byte CHAPID;
        byte AccountSize;
        byte MessageSize;
        ushort Reserved2;
        optional [|AccountSize > 0|] string UserAccount with BinaryEncoding{Length = AccountSize};
        // WORKAROUND: Use "TrailPadding" attribute for UserAccount when it supports 
        optional array<byte> AccountPadding with BinaryEncoding{Length = (16 - AccountSize)};
        optional [|MessageSize > 0|] ([|ReportType == 2|] UserPassword[MessageSize] | [|ReportType == 4|] ResponseValue[MessageSize]) Message;
        optional array<byte> MessagePadding with BinaryEncoding{Length = (16 - MessageSize)};
    
       override string ToString()
       {
           return "IGAP Membership Report (IGAP Join)";
       }
    }
    
    accepts message IGAPMembershipQuery : Imessage
    {
        (byte where value == 65) Type;
        byte MaxRespTime;
        ushort CheckSum;
        IPv4Address GroupAddress;
        byte Version where ValidationCheck(value == 16, null, "IGMP: The Version in message IGAPMembershipQuery must be set to 0x10.");
        byte ReportType where ValidationCheck(value in {33, 34, 35, 36, 37, 38, 39}, null, "ReportType undefined.");
        byte Reserved1;
        byte CHAPID;
        byte AccountSize;
        byte MessageSize;
        ushort Reserved2;
        optional [|AccountSize > 0|] string UserAccount with BinaryEncoding{Length = AccountSize};
        optional array<byte> AccountPadding with BinaryEncoding{Length = (16 - AccountSize)};
        optional [|MessageSize > 0|] ([|ReportType == 35|] ChallengeValue[MessageSize]
            | [|ReportType == 36|] Authentication[MessageSize]
            | [|ReportType == 37|] Accounting[MessageSize]
            | UndefinedMessage[MessageSize]) Message;
        optional array<byte> MessagePadding with BinaryEncoding{Length = (16 - MessageSize)};
    
       override string ToString()
       {
           return "IGAP Membership Query";
       }
    }
    
    accepts message IGAPLeaveGroup : Imessage
    {
        (byte where value == 66) Type;
        byte MaxRespTime;
        ushort CheckSum;
        IPv4Address GroupAddress;
        byte Version where ValidationCheck(value == 16, null, "IGMP: The Version in message IGAPLeaveGroup must be set to 0x10.");
        byte ReportType where ValidationCheck(value in {65, 66, 67, 68} , null, "ReportType undefined.");
        byte Reserved1;
        byte CHAPID;
        byte AccountSize;
        byte MessageSize;
        ushort Reserved2;
        optional [|AccountSize > 0|] string UserAccount with BinaryEncoding{Length = AccountSize};
        optional array<byte> AccountPadding with BinaryEncoding{Length = (16 - AccountSize)};
        optional [|MessageSize > 0|] ([|ReportType == 66|] UserPassword[MessageSize] | [|ReportType == 68|] ResponseValue[MessageSize]) Message;
        optional array<byte> MessagePadding with BinaryEncoding{Length = (16 - MessageSize)};
    
       override string ToString()
       {
           return "IGAP Leave Group";
       }
    }
    
    accepts message UndefinedMessages : Imessage
    {
        byte Type;
        binary Data;
    
        override string ToString()
        {
            return "Undefined Message";
        }  
    }
}

pattern SubType = enum byte
{
   Response  = 1,                                    
   Request = 2,                                      
   $"Non-Membership Report" = 3,                                     
   $"Non-Membership Cancellation" = 4
};

pattern Code = enum byte
{
   $"Neighbor Discovery" = 1,                                    
   $"Route Exchange" = 2,                                      
   $"Request Neighbor List" = 5,                                     
   $"Respond With Neighbor List" = 6,
   $"Pruning Multicast Delivery Trees" = 7,                                      
   $"Grafting Multicast Delivery Trees" = 8,                                     
   $"Acknowledging Graft Messages" = 9
};

pattern PIMCode = enum byte
{
   RouterQuery = 0,
   Register = 1,                                    
   RegisterAck = 2,                                      
   JoinPrune = 3,
   RPReachability = 4,
   Assert = 5,                                   
   Graft = 6,
   GraftAck = 7,                                      
   CandidateRPAdvertisement = 8,                                     
   Poll = 9
};

type V3MembershipQueryMessageFlag
{
    byte Resv with BinaryEncoding{Width = 4};
    bool S with BinaryEncoding{Width = 1};                
    bool v with BinaryEncoding{Width = 3};
} 

pattern RecordType = enum byte
{
     ModeIsInclude  = 1,                                    
     ModeIsExclude = 2,                                      
     ChangeToIncludeMode = 3,                                     
     ChangeToExcludeMode = 4,                                       
     AlownewSources = 5,                                     
     BlockOldSources = 6,
     ...
};

type GroupRecord
{
   RecordType RecordType where ValidationCheck(InRange<RecordType>(value), null, "Record Type undefined.");
   byte AuxDataLen;
   ushort NumOfSources;
   IPv4Address MulticastAddress;
   optional [|NumOfSources > 0|] array<IPv4Address> IPAddresses with BinaryEncoding{Length = NumOfSources};
   optional [|AuxDataLen > 0|] string AuxData with BinaryEncoding{TextEncoding = TextEncoding.ASCII,Width = (AuxDataLen * 4 )};
}

type NULLCommand
{
    (byte where value == 0) Command;
    byte Ignored;
}

type AddressFamilyIndicatorCommand
{
    (byte where value == 2) Command;
    byte Family;
}
    
type SubnetmaskCommand
{
    (byte where value == 3) Command;
    byte Count where ValidationCheck(value == 0 | value == 1, null, "IGMP: The Count in type SubnetmaskCommand should be zero or 1.");
    optional [|Count == 1|] IPv4Address Subnetmask;
}            

type MetricCommand
{
    (byte where value == 4) Command;
    byte Value;
}

type Flags0Command
{
    (byte where value == 5) Command;
    Flag Value;
}

type Flag
{
    byte Reserved with BinaryEncoding{Width = 6};
    bool DestinationIsHUnreachable with BinaryEncoding{Width = 1};                
    bool SplitHorizonConcealedRoute with BinaryEncoding{Width = 1};
}

type InfinityCommand
{
    (byte where value == 6) Command;
    byte Value;
}    

type DestinationAddressCommand
{
    (byte where value == 7) Command;
    byte Count;
    array<IPv4Address> DestinationAddress with BinaryEncoding{Length = Count};
}    
            
type RequestedDestinationAddressCommand
{
    (byte where value == 8) Command;
    byte Count;
    optional array<IPv4Address> DestinationAddress with BinaryEncoding{Length = Count};
}                

type NonMembershipReportCommand
{
    (byte where value == 9) Command;
    byte Count;
    array<NonMembershipReport> NonMembershipReports with BinaryEncoding{Length = Count};
}

type NonMembershipReport
{
    IPv4Address MulticastAddress;
    uint HoldDownTime;
}            

type NonMembershipReportCancelCommand
{
    (byte where value == 10) Command;
    byte Count;
    optional array<IPv4Address> MulticastAddress with BinaryEncoding{Length = Count};
}

type FlagCapabilities
{
    byte Reserved with BinaryEncoding{Width = 3};
    bool Snmp with BinaryEncoding{Width = 1};
    bool Mtrace with BinaryEncoding{Width = 1};                                                        
    bool GenId with BinaryEncoding{Width = 1};                
    bool Prune with BinaryEncoding{Width = 1};                                                        
    bool Leaf with BinaryEncoding{Width = 1};
}

type DVMRPProbe
{
    uint GenerationID;
    array<IPv4Address> NeighborIP;
}

type ProbeCapabilityFlags
{
   byte U with BinaryEncoding{Width = 2};
   bool N with BinaryEncoding{Width = 1};
   bool S with BinaryEncoding{Width = 1};                                                        
   bool M with BinaryEncoding{Width = 1};                
   bool G with BinaryEncoding{Width = 1};                                                        
   bool P with BinaryEncoding{Width = 1};
   bool L with BinaryEncoding{Width = 1}; 
}

type DVMRPReport
{
    array<SourceNet> SourceNetwork;
}

type SourceNet
{
    array<byte> Mask with BinaryEncoding{Length = 3};
    ([|(Mask[0] !=0) && (Mask[1] !=0) && (Mask[2] !=0)|] IPv4Address |
     [|(Mask[0] !=0) && (Mask[1] !=0) && (Mask[2] ==0)|] SrcNet3      |
     [|(Mask[0] !=0) && (Mask[1] ==0) && (Mask[2] !=0)|] SrcNet3      |
     [|(Mask[0] ==0) && (Mask[1] !=0) && (Mask[2] !=0)|] SrcNet3      |
     [|(Mask[0] ==0) && (Mask[1] ==0) && (Mask[2] !=0)|] ushort       |
     [|(Mask[0] ==0) && (Mask[1] !=0) && (Mask[2] ==0)|] ushort       |
     [|(Mask[0] !=0) && (Mask[1] ==0) && (Mask[2] ==0)|] ushort       |
     [|(Mask[0] ==0) && (Mask[1] ==0) && (Mask[2] ==0)|] byte) SourceNetwork;
     byte Metric;
}

type SrcNet3
{
    array<byte> Mask with BinaryEncoding{Length = 3};
}

type DVMRPAskNeighbors2
{
}

type DVMRPNeighbors2
{
   array<DVMRPNeighbors2element>  DVMRPNeighbors2;
}

type DVMRPNeighbors2element
{
    IPv4Address LocalAddr; 
    byte Metric;
    byte Threshold;
    FlagDVMRPNeighbors2    Flags;
    byte NeighborCount;
    optional [|NeighborCount > 0|] array<IPv4Address> NeighborIP with BinaryEncoding{Length = NeighborCount};
}

type FlagDVMRPNeighbors2
{
    bool Leaf with BinaryEncoding{Width = 1};
    bool Querier with BinaryEncoding{Width = 1};
    bool Disabled with BinaryEncoding{Width = 1};                        
    bool Down with BinaryEncoding{Width = 1};
    byte Reserved with BinaryEncoding{Width = 2};
    bool SourceRoute with BinaryEncoding{Width = 1};
    bool Tunnel with BinaryEncoding{Width = 1};
}

type DVMRPPrune
{
    IPv4Address  SourceHostAddress;
    IPv4Address  GroupAddress;
    uint PruneLifetime;
    optional IPv4Address SourceNetworkMask;
}

type DVMRPGraft
{
    IPv4Address  SourceHostAddress;
    IPv4Address  GroupAddress;
    optional IPv4Address SourceNetworkMask;
}

type DVMRPGraftAck
{
    IPv4Address  SourceHostAddress;
    IPv4Address  GroupAddress;
    optional IPv4Address SourceNetworkMask;
}

type PIMVersion1
{
    (byte where value == 1) PIMVer with BinaryEncoding{Width = 4};
    (byte where value == 4) Type with BinaryEncoding{Width = 4};
    byte Code where ValidationCheck(value is PIMCode, null , "Code undefined.");
    ushort CheckSum;
}

type PIMJoinPruneGroup 
{
    IPv4Address EncodedMulticastGroupAddress;
    byte Reserved3;
    uint RPCnt with BinaryEncoding{Width = 4};
    uint NumberOfJoinSrcs with BinaryEncoding{Width = 10};
    uint NumberOfPruneSrcs with BinaryEncoding{Width = 10};
    optional [|RPCnt > 0|] array<IPv4Address> UnicastRPAddress with BinaryEncoding{Length = RPCnt};
    optional [|NumberOfJoinSrcs > 0|] array<IPv4Address> EncodedJoinSourceAddress with BinaryEncoding{Length = NumberOfJoinSrcs};
    optional [|NumberOfPruneSrcs > 0|] array<IPv4Address> EncodedPruneSourceAddress with BinaryEncoding{Length = NumberOfPruneSrcs};
}

type ResposeData
{
    uint QueryArrivalTime;
    IPv4Address IncomingInterfaceAddress;
    IPv4Address OutgoingInterfaceAddress;
    IPv4Address PreviousHopRouterAddress;
    uint InputPacketCountOnIncomingInterface;
    uint OutputPacketCountOnOutgoingInterface;
    uint TotalNumberOfPackets;
    byte RtgProtocol;
    byte FwdTTL;
    bool MBZ with BinaryEncoding{Width = 1};
    bool S with BinaryEncoding{Width = 1};
    byte SrcMask with BinaryEncoding{Width = 6};
    byte ForwardingCode;
}

type GroupRangeRecord
{
    uint DestinationPrefix1;
    byte MaskLen1;
    array<byte> Reserved with BinaryEncoding{Length = 3};
}

type ReceiverMembershipReportGroupAddress
{
    byte RecordType1;
    array<byte> Reserved where ValidationCheck(value is $ [0, 0, 0], null, "IGMP: The Reserved in type ReceiverMembershipReportGroupAddress should be zero.") with BinaryEncoding{Length = 3};
    IPv4Address DestinationAddress1;
}

type UserPassword[byte Size]
{
    optional string UserPassword with BinaryEncoding{Length = Size};
}

type ResponseValue[byte Size]
{
    optional string ResponseValue with BinaryEncoding{Length = Size};
}

type ChallengeValue[byte Size]
{
    optional string ChallengeValue with BinaryEncoding{Length = Size};
}

type Authentication[byte Size]
{
    optional string AuthStatus with BinaryEncoding{Length = Size};
}

type Accounting[byte Size]
{
    optional string AccountStatus with BinaryEncoding{Length = Size};
}

type UndefinedMessage[byte Size]
{
    optional string UndefinedMessage with BinaryEncoding{Length = Size};
}
