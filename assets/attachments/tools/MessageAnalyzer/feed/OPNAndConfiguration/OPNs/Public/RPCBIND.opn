protocol RPCBIND with 
BinaryEncodingDefaults{Endian = Endian.Big, TextEncoding = TextEncoding.ASCII},
Documentation
{
    ProtocolName = "Binding Protocols for ONC RPC Version 2",
    ShortName = "RPCBIND",
    Description = ""
},
OPNAuthoring
{
    Copyright = "(c) Microsoft Corporation",
    References = 
        [
            new Reference{Name = "RFC 1833"},
            new Reference{Name = "RFC 4506"},
        ],
    RevisionSummary =
        [
            new Revision{Class = RevisionClass.Major, Version = "360482", Date = "03/21/2014"}
        ]
};

using Utility;
using SunRPC;
using UDP;
using IANA;
using XDR;
using TCP;

annotation uint IMessage#SunRpcVers;

endpoint Server over IntermediateServer provides Rpcbprog consumes Rpcbprog;
client endpoint Client connected to Server;

endpoint IntermediateServer over SunRPC.Node provides RpcbprogMessage consumes RpcbprogMessage;
client endpoint IntermediateClient connected to IntermediateServer;
/*
 * A mapping of (program, version, network ID) to address
 *
 * The network identifier  (r_netid):
 * This is a string that represents a local identification for a
 * network. This is defined by a system administrator based on local
 * conventions, and cannot be depended on to have the same value on
 * every system.
 */
type Rpcb
{
    XdrUnsignedInt RProg;    /* program number */
    XdrUnsignedInt RVers;    /* version number */
    XDRString RNetid;        /* network id */
    XDRString RAddr;         /* universal address */
    XDRString ROwner;        /* owner of this service */
};

type RpList
{
    Rpcb RpcbMap;
    XDRBool Opted;
    optional [|Opted == XDRBool.TRUE|] RpList RpcbNext;
}

/* results of RpcbprocDUMP */
type RpcblistPtr
{
    XDRBool Opted;
    optional [|Opted == XDRBool.TRUE|] RpList RpList;
}

/*
 * Arguments of remote calls
 */
type RpcbRmtcallargs
{
    XdrUnsignedInt Prog;        /* program number */
    XdrUnsignedInt Vers;        /* version number */
    XdrUnsignedInt Proc;        /* procedure number */
    XdrOpaqueVariable Args;             /* argument */
}

/*
 * Results of the remote call
 */
type RpcbRmtcallres
{
    XDRString Addr;
    XdrOpaqueVariable Results;         /* result */
}

// This represents the type of transport, and has the following values:
pattern TransportSemantics = enum XdrUnsignedInt
{
    NcTpiClts       = 1, //      Connectionless
    NcTpiCots       = 2, //      Connection oriented
    NcTpiCotsOrd    = 3, //      Connection oriented with graceful close
    NcTpiRaw        = 4, //      Raw transport
};

// This identifies the family to which the protocol belongs.  The following values are defined:
pattern ProtocolFamily = enum string
{
    NcNoprotofmly   = "-",
    NcLoopback      = "loopback",
    NcInet          = "inet",
    NcImpLink       = "implink",
    NcPup           = "pup",
    NcChaos         = "chaos",
    NcNs            = "ns",
    NcNbs           = "nbs",
    NcEcma          = "ecma",
    NcDatakit       = "datakit",
    NcCcitt         = "ccitt",
    NcSna           = "sna",
    NcDecnet        = "decnet",
    NcDli           = "dli",
    NcLat           = "lat",
    NcHylink        = "hylink",
    NcAppletalk     = "appletalk",
    NcNit           = "nit",
    NcIeee802       = "ieee802",
    NcOsi           = "osi",
    NcX25           = "x25",
    NcOsinet        = "osinet",
    NcGosip         = "gosip",
};

// This identifies a protocol within a family.  The following are currently defined:
pattern ProtocolName = enum string
{
    NcNoproto      = "-",
    NcTcp          = "tcp",
    NcUdp          = "udp",
    NcIcmp         = "icmp",
};

/*
 * rpcb_entry contains a merged address of a service on a particular
 * transport, plus associated netconfig information.  A list of
 * rpcb_entry items is returned by RpcbprocGETADDRLIST.  The meanings
 * and values used for the r_nc_* fields are given below.
 */
type RpcbEntry
{
    XDRString RMaddr;            /* merged address of service */
    XDRString RNcNetid;         /* netid field */
    TransportSemantics RNcSemantics;       /* semantics of transport */
    XDRString RNcProtofmly where ValidationCheck(value.Value is ProtocolFamily, null, "RncProtofmly should be one value of enum ProtocolFamily.");     /* protocol family */
    XDRString RNcProto where ValidationCheck(value.Value is ProtocolName, null, "RNcProto should be one value of enum ProtocolName.");         /* protocol name */
};

/*
 * A list of addresses supported by a service.
 */
type RpcbEntryList
{
    RpcbEntry RpcbEntryMap;
    XDRBool Opted;
    optional [|Opted == XDRBool.TRUE|] RpcbEntryList RpcbEntryNext;
};

type RpcbEntryListPtr
{
    XDRBool Opted;
    optional [|Opted == XDRBool.TRUE|] RpcbEntryList RpcbEntryList;
}

/*
 * rpcbind statistics
 */

//const rpcb_highproc_2 = RPCBPROC_CALLIT;
//const rpcb_highproc_3 = RPCBPROC_TADDR2UADDR;
//const rpcb_highproc_4 = RPCBPROC_GETSTAT;

const uint RpcbStatHighProc = 13; /* # of procs in rpcbind V4 plus one */
const uint RpcbVersStat     = 3; /* provide only for rpcbind V2, V3 and V4 */
const uint RpcbVers4Stat   = 2;
const uint RpcbVers3Stat   = 1;
const uint RpcbVers2Stat   = 0;

/* Link list of all the stats about getport and getaddr */
type RpcbsAddrList
{
    XdrUnsignedInt Prog;
    XdrUnsignedInt Vers;
    XDRInt Success;
    XDRInt Failure;
    XDRString Netid;
    RpcbsAddrlistPtr Next;
}

/* Link list of all the stats about rmtcall */
type RpcbsRmtcalllist
{
    XdrUnsignedInt Prog;
    XdrUnsignedInt Vers;
    XdrUnsignedInt Proc;
    XDRInt Success;
    XDRInt Failure;
    XDRInt Indirect;    /* whether callit or indirect */
    XDRString Netid;
    RpcbsRmtcalllistPtr Next;
}

type RpcbsProc
{
    array<XDRInt> Value with BinaryEncoding{Length = RpcbStatHighProc};
}

type RpcbsAddrlistPtr
{
    XDRBool Opted;
    optional [|Opted == XDRBool.TRUE|] RpcbsAddrList OptedValue;
}

type RpcbsRmtcalllistPtr
{
    XDRBool Opted;
    optional [|Opted == XDRBool.TRUE|] RpcbsRmtcalllist OptedValue;
}

type RpcbStat
{
    RpcbsProc Info;
    XDRInt Setinfo;
    XDRInt Unsetinfo;
    XDRBool AddrListOpted;
    optional [|AddrListOpted == XDRBool.TRUE|] RpcbsAddrList Addrinfo;
    // WORDAROUND:Bug#30723 Cannot reference gerneric type defined in another project
    //XDROptional<RpcbsAddrList> Addrinfo;
    XDRBool RmtcalllistOpted;
    optional [|RmtcalllistOpted == XDRBool.TRUE|] RpcbsRmtcalllist Rmtinfo;
    // WORDAROUND:Bug#30723 Cannot reference gerneric type defined in another project
    //XDROptional<RpcbsRmtcalllist> Rmtinfo;
};

/*
 * One rpcb_stat structure is returned for each version of rpcbind
 * being monitored.
 */
type RpcbStatByvers
{
    array<RpcbStat> Items with BinaryEncoding{Length = RpcbVersStat};
}

/*
 * netbuf structure, used to store the transport specific form of
 * a universal transport address.
 */
type Netbuf
{
    XdrUnsignedInt Maxlen;
    XdrOpaqueVariable Buf;
};

/*
 * rpcbind procedures
 */
contract Rpcbprog
{
    // Proc = 1;
    operation RPCBPROC_SET
    {
        in Rpcb Rpcb;
        out XDRBool Result;
        
        override string ToString()
        {
            return "V" + (this.Origins[0] as IMessage)#SunRpcVers.ToString() + " RPCBPROC_SET";
        }
    }

    // Proc = 2;
    operation RPCBPROC_UNSET
    {
        in Rpcb Rpcb;
        out XDRBool Result;
        
        override string ToString()
        {
            return "V" + (this.Origins[0] as IMessage)#SunRpcVers.ToString() + " RPCBPROC_UNSET";
        }
    }

    // Proc = 3;
    operation RPCBPROC_GETADDR
    {
        in Rpcb Rpcb;
        out XDRString Addr;
        
        override string ToString()
        {
            return "V" + (this.Origins[0] as IMessage)#SunRpcVers.ToString() + " RPCBPROC_GETADDR";
        }
    }

    // Proc = 4;
    operation RPCBPROC_DUMP
    {
        out RpcblistPtr Addr;
        
        override string ToString()
        {
            return "V" + (this.Origins[0] as IMessage)#SunRpcVers.ToString() + " RPCBPROC_DUMP";
        }
    }

    // Proc = 5; Vers = 3
    operation RPCBPROC_CALLIT
    {
        // Currently we can't find any sections in TD specified the 'RpcbRmtcallargs' is optional, but some frames of SunRPC doesn't have payload.
        in optional RpcbRmtcallargs Callargs;
        out RpcbRmtcallres Callres;
        
        override string ToString()
        {
            return "V" + (this.Origins[0] as IMessage)#SunRpcVers.ToString() + " RPCBPROC_CALLIT";
        }
    }

    // Proc = 6;
    operation RPCBPROC_GETTIME
    {
        out uint Time; // This procedure returns the local time on its own machine in seconds since the midnight of the First day of January, 1970.
        
        override string ToString()
        {
            return "V" + (this.Origins[0] as IMessage)#SunRpcVers.ToString() + " RPCBPROC_GETTIME";
        }
    }

    // Proc = 7;
    operation RPCBPROC_UADDR2TADDR
    {
        in XDRString UniversalAddresses;
        out Netbuf TransportSpecificAddresses;
        
        override string ToString()
        {
            return "V" + (this.Origins[0] as IMessage)#SunRpcVers.ToString() + " RPCBPROC_UADDR2TADDR";
        }
    }

    // Proc = 8;
    operation RPCBPROC_TADDR2UADDR
    {
        in Netbuf TransportSpecificAddresses;
        out XDRString UniversalAddresses;
        
        override string ToString()
        {
            return "V" + (this.Origins[0] as IMessage)#SunRpcVers.ToString() + " RPCBPROC_TADDR2UADDR";
        }
    }

    // Proc = 5;Vers = 4
    operation RPCBPROC_BCAST // = RpcbprocCallit;
    {
        // Currently we can't find any sections in TD specified the 'RpcbRmtcallargs' is optional, but some frames of SunRPC doesn't have payload.
        in optional RpcbRmtcallargs Callargs;
        out RpcbRmtcallres Callres;
        
        override string ToString()
        {
            return "V" + (this.Origins[0] as IMessage)#SunRpcVers.ToString() + " RPCBPROC_BCAST";
        }
    }

    // ________________________________Below operations is only for Vers = 4_______________________________________

    // This procedure is similar to RPCBPROC_GETADDR.  The difference is the
    // "r_vers" field of the rpcb structure can be used to specify the
    // version of interest.  If that version is not registered, no address
    // is returned.
    // Proc = 9;
    operation RPCBPROC_GETVERSADDR
    {
        in Rpcb Rpcb;
        out XDRString Addr;
        
        override string ToString()
        {
            return "V4 RPCBPROC_GETVERSADDR";
        }
    }

    // Proc = 10;
    operation RPCBPROC_INDIRECT
    {
        // Currently we can't find any sections in TD specified the 'RpcbRmtcallargs' is optional, but some frames of SunRPC doesn't have payload.
        in optional RpcbRmtcallargs Callargs;
        out optional RpcbRmtcallres Callres;
        
        override string ToString()
        {
            return "V4 RPCBPROC_INDIRECT";
        }
    }

    // Proc = 11;
    operation RPCBPROC_GETADDRLIST
    {
        in Rpcb Rpcb;
        out RpcbEntryListPtr Addr;
        
        override string ToString()
        {
            return "V4 RPCBPROC_GETADDRLIST";
        }
    }

    // Proc = 12;
    operation RPCBPROC_GETSTAT
    {
        out RpcbStatByvers RpcbStatByvers;
        
        override string ToString()
        {
            return "V4 RPCBPROC_GETSTAT";
        }
    }
}

message IMessage
{
}

contract RpcbprogMessage
{
    accepts message CallRpcbprocSet : IMessage
    {
        Rpcb Rpcb;
        
        override string ToString()
        {
            return "V" + (this#SunRpcVers as string) + " RPCBPROC_SET Call";
        }  
    }

    issues message ReturnRpcbprocSet : IMessage
    {
        XDRBool Result;
        
        override string ToString()
        {
            return "V" + (this#SunRpcVers as string) + " RPCBPROC_SET Return";
        }
    }

    accepts message CallRpcbprocUnset : IMessage
    {
        Rpcb Rpcb;
        
        override string ToString()
        {
            return "V" + (this#SunRpcVers as string) + " RPCBPROC_UNSET Call";
        }
    }

    issues message ReturnRpcbprocUnset : IMessage
    {
        XDRBool Result;
        
        override string ToString()
        {
            return "V" + (this#SunRpcVers as string) + " RPCBPROC_UNSET Return";
        }
    }

    accepts message CallRpcbprocGetaddr : IMessage
    {
        Rpcb Rpcb;
        
        override string ToString()
        {
            return "V" + (this#SunRpcVers as string) + " RPCBPROC_GETADDR Call";
        }
    }

    issues message ReturnRpcbprocGetaddr : IMessage
    {
        XDRString Addr;
        
        override string ToString()
        {
            return "V" + (this#SunRpcVers as string) + " RPCBPROC_GETADDR Return";
        }
    }
    
    accepts message CallRpcbprocDump : IMessage
    {
        override string ToString()
        {
            return "V" + (this#SunRpcVers as string) + " RPCBPROC_Dump Call";
        }
    }

    issues message ReturnRpcbprocDump : IMessage
    {
        RpcblistPtr Addr;
        
        override string ToString()
        {
            return "V" + (this#SunRpcVers as string) + " RPCBPROC_DUMP Return";
        }
    }

    // Proc = 5; Vers = 3
    accepts message CallRpcbprocCallit : IMessage
    {
        // Currently we can't find any sections in TD specified the 'RpcbRmtcallargs' is optional, but some frames of SunRPC doesn't have payload.
        optional RpcbRmtcallargs Callargs where ValidationCheck(value != nothing, this, "The RPCBPROC_CALLIT request must have parameters for program, version, and procedure number.");
        
        override string ToString()
        {
            return "V" + (this#SunRpcVers as string) + " RPCBPROC_CALLIT Call";
        }
    }

    issues message ReturnRpcbprocCallit : IMessage
    {
        RpcbRmtcallres Callres;
        
        override string ToString()
        {
            return "V" + (this#SunRpcVers as string) + " RPCBPROC_CALLIT Return";
        }
    }
    
    accepts message CallRpcbprocGettime : IMessage
    {
        override string ToString()
        {
            return "V" + (this#SunRpcVers as string) + " RPCBPROC_GETTIME Call";
        }
    }

    issues message ReturnRpcbprocGettime : IMessage
    {
        uint Time;
        
        override string ToString()
        {
            return "V" + (this#SunRpcVers as string) + " RPCBPROC_GETTIME Return";
        }
    }

    accepts message CallRpcbprocUaddr2taddr : IMessage
    {
        XDRString UniversalAddresses;
        
        override string ToString()
        {
            return "V" + (this#SunRpcVers as string) + " RPCBPROC_UADDR2TADDR Call";
        }
    }

    issues message ReturnRpcbprocUaddr2taddr : IMessage
    {
        Netbuf TransportSpecificAddresses;
        
        override string ToString()
        {
            return "V" + (this#SunRpcVers as string) + " RPCBPROC_UADDR2TADDR Return";
        }
    }

    accepts message CallRpcbprocTaddr2uaddr : IMessage
    {
        Netbuf TransportSpecificAddresses;
        
        override string ToString()
        {
            return "V" + (this#SunRpcVers as string) + " RPCBPROC_TADDR2UADDR Call";
        }
    }

    issues message ReturnRpcbprocTaddr2uaddr : IMessage
    {
        XDRString UniversalAddresses;
        
        override string ToString()
        {
            return "V" + (this#SunRpcVers as string) + " RPCBPROC_TADDR2UADDR Return";
        }
    }

    // Proc = 5;Vers = 4
    accepts message CallRpcbprocBcast : IMessage // = RpcbprocCallit;
    {
        // Currently we can't find any sections in TD specified the 'RpcbRmtcallargs' is optional, but some frames of SunRPC doesn't have payload.
        optional RpcbRmtcallargs Callargs where ValidationCheck(value != nothing, this, "The RPCBPROC_BCAST request must have parameters for program, version, and procedure number.");
        
        override string ToString()
        {
            return "V" + (this#SunRpcVers as string) + " RPCBPROC_BCAST Call";
        }
    }

    issues message ReturnRpcbprocBcast : IMessage
    {
        RpcbRmtcallres Callres;
        
        override string ToString()
        {
            return "V" + (this#SunRpcVers as string) + " RPCBPROC_BCAST Return";
        }
    }

    accepts message CallRpcbprocGetversaddr : IMessage
    {
        Rpcb Rpcb;
        
        override string ToString()
        {
            return "V" + (this#SunRpcVers as string) + " RPCBPROC_GETVERSADDR Call";
        }
    }

    issues message ReturnRpcbprocGetversaddr : IMessage
    {
        XDRString Addr;
        
        override string ToString()
        {
            return "V" + (this#SunRpcVers as string) + " RPCBPROC_GETVERSADDR Return";
        }
    }

    accepts message CallRpcbprocIndirect : IMessage
    {
        // Currently we can't find any sections in TD specified the 'RpcbRmtcallargs' is optional, but some frames of SunRPC doesn't have payload.
        optional RpcbRmtcallargs Callargs where ValidationCheck(value != nothing, this, "The RPCBPROC_INDIRECT request must have parameters for program, version, and procedure number.");
        
        override string ToString()
        {
            return "V" + (this#SunRpcVers as string) + " RPCBPROC_INDIRECT Call";
        }
    }

    issues message ReturnRpcbprocIndirect : IMessage
    {
        // we use optional and throw ValidationError here to let users know that's an ambiguous case which not fit RFC. RFC need to be clarified with SHOULD or MUST.
        optional RpcbRmtcallres Callres where ValidationCheck(value != nothing, this, "The RPCBPROC_INDIRECT response must contain the remote program's universal address, and the results of the remote procedure.");
        
        override string ToString()
        {
            return "V" + (this#SunRpcVers as string) + " RPCBPROC_INDIRECT Return";
        }
    }

    accepts message CallRpcbprocGetaddrlist : IMessage
    {
        Rpcb Rpcb;
        
        override string ToString()
        {
            return "V" + (this#SunRpcVers as string) + " RPCBPROC_GETADDRLIST Call";
        }
    }

    issues message ReturnRpcbprocGetaddrlist : IMessage
    {
        RpcbEntryListPtr Addr;
        
        override string ToString()
        {
            return "V" + (this#SunRpcVers as string) + " RPCBPROC_GETADDRLIST Return";
        }
    }
    
    accepts message CallRpcbprocGetstat : IMessage
    {
        override string ToString()
        {
            return "V" + (this#SunRpcVers as string) + " RPCBPROC_GETSTAT Call";
        }
    }

    issues message ReturnRpcbprocGetstat : IMessage
    {
        RpcbStatByvers RpcbStatByvers;
        
        override string ToString()
        {
            return "V" + (this#SunRpcVers as string) + " RPCBPROC_GETSTAT Return";
        }
    }
}

// SunRPC Over TCP actor, Port.SunRPC is 111, and it's little than 1024, which isn't in the scope of Client selected port. so we could ignore the missingThreeWayHandshake issue.
autostart actor SunRPCOverTCP(TCP.Server server)
{
    bool IsSunRPCFlag = false;
    bool IsSunRPCAssist= false; // Set and used only when port is SunRPC

    process server accepts s:TCP.Segment where (Port.SunRPC == s.DestinationPort && IsSunRPC(s.Payload, ref IsSunRPCAssist)) || 
        IsSunRPCRequest(s.Payload, SunRpcVersSet, RPCBPROG, ref IsSunRPCFlag)
    {
        var ept = endpoint SunRPC.RecordMarking over server;
        ept.ExpectedProgram = RPCBPROG;
        // both of PortMapper and RPCBIND use the same Program Number(100000) and port(SunRPC), message may processed by either PortMapper or RPCBIND
        ept.VerSet = RpcBindPortMapperVersSet;
        dispatch ept accepts s;
    }
    
    process server issues s:TCP.Segment where IsSunRPCFlag || (Port.SunRPC == s.SourcePort && IsSunRPC(s.Payload, ref IsSunRPCAssist))
    {
        dispatch (endpoint SunRPC.RecordMarking over server) issues s;
    }
}

// SunRPC Over UDP actor
autostart actor SunRPCOverUDP(UDP.Host host)
{
    set<uint> XidSet = {};

    process host accepts d:UDP.Datagram where ((d.DestinationPort == Port.SunRPC || d.SourcePort == Port.SunRPC) && IsSunRPC(d.Payload)) || 
        (IsSunRPCRequest(d.Payload, SunRpcVersSet, RPCBPROG) is isSunRPCRequest:bool && isSunRPCRequest) || 
        (IsSunRPCResponse(d.Payload, ref XidSet) is isSunRPCResponse:bool && isSunRPCResponse)
    {
        if (d.DestinationPort != Port.SunRPC && d.SourcePort != Port.SunRPC && isSunRPCRequest)
        {
            AddXidSet(d.Payload, ref XidSet, false);
        }
        if (d.DestinationPort != Port.SunRPC && d.SourcePort != Port.SunRPC && isSunRPCResponse)
        {
            RemoveXidSet(d.Payload, ref XidSet, false);
        }
        dispatch (endpoint SunRPC.RecordMarking over host) accepts d;
    }
    
    // destructor
    ~endpoint(UDP.Host host)
    {
        XidSet = {};
    }
}

/* RFC 1833:
program RPCBPROG {
    .....
} = 100000;
*/
const uint RPCBPROG = 100000;
const set<uint> SunRpcVersSet = {3, 4};
const set<uint> RpcBindPortMapperVersSet = {2, 3, 4}; // 2 is PortMapper, 3 or 4 is RPCBIND

// RpcBind Over SunRPC
autostart actor RpcBindOverSunRPC(SunRPC.Node sunRpcNode)
{
    map<uint, array<uint>> ServerTransactionMap = {};
    // accepts Call from UDP/TCP
    process sunRpcNode accepts r:RpcMsg where (r.MType == MsgType.Call && (r.Body as CallBody).Prog == 100000 && SunRpcVersSet[(r.Body as CallBody).Vers])
    {
        if (!(r.Xid in ServerTransactionMap))
        {
            ServerTransactionMap[r.Xid] = [(r.Body as CallBody).Proc, (r.Body as CallBody).Vers];
        }
        MessageProcessing(r, ServerTransactionMap[r.Xid][0], ServerTransactionMap[r.Xid][1], true, AcceptsDispatcher);
    }
    // accepts Reply from UDP, reverse accept/issues direction for operation set up.
    process sunRpcNode accepts r:RpcMsg where ((r.MType == MsgType.Reply) && (r.Xid in ServerTransactionMap) && (r.Body as ReplyBody).Stat == ReplyStat.MsgAccepted)
    {
        MessageProcessing(r, ServerTransactionMap[r.Xid][0], ServerTransactionMap[r.Xid][1], false, IssuesDispatcher);
    }
    // issues Reply from TCP
    process sunRpcNode issues r:RpcMsg where ((r.MType == MsgType.Reply) && (r.Xid in ServerTransactionMap) && (r.Body as ReplyBody).Stat == ReplyStat.MsgAccepted)
    {
        MessageProcessing(r, ServerTransactionMap[r.Xid][0], ServerTransactionMap[r.Xid][1], false, IssuesDispatcher);
    }
    
    void AcceptsDispatcher(any message m)
    {
        dispatch (endpoint IntermediateServer over sunRpcNode) accepts m;
    }
    
    void IssuesDispatcher(any message m)
    {
        dispatch (endpoint IntermediateServer over sunRpcNode) issues m;
    }
}

void MessageProcessing(RpcMsg msg, uint proc, uint vers, bool isCall, void(any message) dispatcher)
{
    binary callData = $[];
    if (isCall && ((msg.Body as CallBody).CallData is BinaryCallDataType))
    {
        callData = ((msg.Body as CallBody).CallData as BinaryCallDataType).Data;
    }
    binary replyData = $[];
    if (!isCall && ((msg.Body as ReplyBody).Reply as AcceptedReply).ReplyData is binary)
    {
        replyData = ((msg.Body as ReplyBody).Reply as AcceptedReply).ReplyData as binary;
    }
    switch (proc)
    {
        case 1 =>
            if (isCall)
            {
                optional RpcbprogMessage.CallRpcbprocSet setOpCallOptional = BinaryDecoder<RpcbprogMessage.CallRpcbprocSet>(callData);
                if (setOpCallOptional != nothing)
                {
                    RpcbprogMessage.CallRpcbprocSet setOpCall = setOpCallOptional as RpcbprogMessage.CallRpcbprocSet;
                    setOpCall#SunRpcVers = vers;
                    dispatcher(setOpCall);
                }
                else
                {
                    ThrowDecodingException("RPCBIND", "RpcbprogMessage.CallRpcbprocSet");
                }
            }
            else
            {
                optional RpcbprogMessage.ReturnRpcbprocSet setOpReplyOptional = BinaryDecoder<RpcbprogMessage.ReturnRpcbprocSet>(replyData);
                if (setOpReplyOptional != nothing)
                {
                    RpcbprogMessage.ReturnRpcbprocSet setOpReply = setOpReplyOptional as RpcbprogMessage.ReturnRpcbprocSet;
                    setOpReply#SunRpcVers = vers;
                    dispatcher(setOpReply);
                }
                else
                {
                    ThrowDecodingException("RPCBIND", "RpcbprogMessage.ReturnRpcbprocSet");
                }
            }

        case 2 =>
            if (isCall)
            {
                optional RpcbprogMessage.CallRpcbprocUnset unsetOpCallOptional = BinaryDecoder<RpcbprogMessage.CallRpcbprocUnset>(callData);
                if (unsetOpCallOptional != nothing)
                {
                    RpcbprogMessage.CallRpcbprocUnset unsetOpCall = unsetOpCallOptional as RpcbprogMessage.CallRpcbprocUnset;
                    unsetOpCall#SunRpcVers = vers;
                    dispatcher(unsetOpCall);
                }
                else
                {
                    ThrowDecodingException("RPCBIND", "RpcbprogMessage.CallRpcbprocUnset");
                }
            }
            else
            {
                optional RpcbprogMessage.ReturnRpcbprocUnset unsetOpReplyOptional = BinaryDecoder<RpcbprogMessage.ReturnRpcbprocUnset>(replyData);
                if (unsetOpReplyOptional != nothing)
                {
                    RpcbprogMessage.ReturnRpcbprocUnset unsetOpReply = unsetOpReplyOptional as RpcbprogMessage.ReturnRpcbprocUnset;
                    unsetOpReply#SunRpcVers = vers;
                    dispatcher(unsetOpReply);
                }
                else
                {
                    ThrowDecodingException("RPCBIND", "RpcbprogMessage.ReturnRpcbprocUnset");
                }
            }
        case 3 =>
            if (isCall)
            {
                optional RpcbprogMessage.CallRpcbprocGetaddr getaddrOpCallOptional = BinaryDecoder<RpcbprogMessage.CallRpcbprocGetaddr>(callData);
                if (getaddrOpCallOptional != nothing)
                {
                    RpcbprogMessage.CallRpcbprocGetaddr getaddrOpCall = getaddrOpCallOptional as RpcbprogMessage.CallRpcbprocGetaddr;
                    getaddrOpCall#SunRpcVers = vers;
                    dispatcher(getaddrOpCall);
                }
                else
                {
                    ThrowDecodingException("RPCBIND", "RpcbprogMessage.CallRpcbprocGetaddr");
                }
            }
            else
            {
                optional RpcbprogMessage.ReturnRpcbprocGetaddr getaddrOpReplyOptional = BinaryDecoder<RpcbprogMessage.ReturnRpcbprocGetaddr>(replyData);
                if (getaddrOpReplyOptional != nothing)
                {
                    RpcbprogMessage.ReturnRpcbprocGetaddr getaddrOpReply = getaddrOpReplyOptional as RpcbprogMessage.ReturnRpcbprocGetaddr;
                    getaddrOpReply#SunRpcVers = vers;
                    dispatcher(getaddrOpReply);
                }
                else
                {
                    ThrowDecodingException("RPCBIND", "RpcbprogMessage.ReturnRpcbprocGetaddr");
                }
            }
        case 4 =>
            if (isCall)
            {
                optional RpcbprogMessage.CallRpcbprocDump dumpOpCallOptional = BinaryDecoder<RpcbprogMessage.CallRpcbprocDump>(callData);
                if (dumpOpCallOptional != nothing)
                {
                    RpcbprogMessage.CallRpcbprocDump dumpOpCall = dumpOpCallOptional as RpcbprogMessage.CallRpcbprocDump;
                    dumpOpCall#SunRpcVers = vers;
                    dispatcher(dumpOpCall);
                }
                else
                {
                    ThrowDecodingException("RPCBIND", "RpcbprogMessage.CallRpcbprocDump");
                }
            }
            else
            {
                optional RpcbprogMessage.ReturnRpcbprocDump dumpOpReplyOptional = BinaryDecoder<RpcbprogMessage.ReturnRpcbprocDump>(replyData);
                if (dumpOpReplyOptional != nothing)
                {
                    RpcbprogMessage.ReturnRpcbprocDump dumpOpReply = dumpOpReplyOptional as RpcbprogMessage.ReturnRpcbprocDump;
                    dumpOpReply#SunRpcVers = vers;
                    dispatcher(dumpOpReply);
                }
                else
                {
                    ThrowDecodingException("RPCBIND", "RpcbprogMessage.ReturnRpcbprocDump");
                }
            }
        case 5 =>
            switch (vers)
            {
                case 3 =>
                    if (isCall)
                    {
                        optional RpcbprogMessage.CallRpcbprocCallit callitOpCallOptional = BinaryDecoder<RpcbprogMessage.CallRpcbprocCallit>(callData);
                        if (callitOpCallOptional != nothing)
                        {
                            RpcbprogMessage.CallRpcbprocCallit callitOpCall = callitOpCallOptional as RpcbprogMessage.CallRpcbprocCallit;
                            callitOpCall#SunRpcVers = vers;
                            dispatcher(callitOpCall);
                        }
                        else
                        {
                            ThrowDecodingException("RPCBIND", "RpcbprogMessage.CallRpcbprocCallit");
                        }
                    }
                    else
                    {
                        optional RpcbprogMessage.ReturnRpcbprocCallit callitOpReplyOptional = BinaryDecoder<RpcbprogMessage.ReturnRpcbprocCallit>(replyData);
                        if (callitOpReplyOptional != nothing)
                        {
                            RpcbprogMessage.ReturnRpcbprocCallit callitOpReply = callitOpReplyOptional as RpcbprogMessage.ReturnRpcbprocCallit;
                            callitOpReply#SunRpcVers = vers;
                            dispatcher(callitOpReply);
                        }
                        else
                        {
                            ThrowDecodingException("RPCBIND", "RpcbprogMessage.ReturnRpcbprocCallit");
                        }
                    }
                case 4 =>
                    if (isCall)
                    {
                        optional RpcbprogMessage.CallRpcbprocBcast bcastCallOptional = BinaryDecoder<RpcbprogMessage.CallRpcbprocBcast>(callData);
                        if (bcastCallOptional != nothing)
                        {
                            RpcbprogMessage.CallRpcbprocBcast bcastOpCall = bcastCallOptional as RpcbprogMessage.CallRpcbprocBcast;
                            bcastOpCall#SunRpcVers = vers;
                            dispatcher(bcastOpCall);
                        }
                        else
                        {
                            ThrowDecodingException("RPCBIND", "RpcbprogMessage.CallRpcbprocBcast");
                        }
                    }
                    else
                    {
                        optional RpcbprogMessage.ReturnRpcbprocBcast bcastOpReplyOptional = BinaryDecoder<RpcbprogMessage.ReturnRpcbprocBcast>(replyData);
                        if (bcastOpReplyOptional != nothing)
                        {
                            RpcbprogMessage.ReturnRpcbprocBcast bcastOpReply = bcastOpReplyOptional as RpcbprogMessage.ReturnRpcbprocBcast;
                            bcastOpReply#SunRpcVers = vers;
                            dispatcher(bcastOpReply);
                        }
                        else
                        {
                            ThrowDecodingException("RPCBIND", "RpcbprogMessage.ReturnRpcbprocBcast");
                        }
                    }
            }
        case 6 =>
            if (isCall)
            {
                optional RpcbprogMessage.CallRpcbprocGettime gettimeOpCallOptional = BinaryDecoder<RpcbprogMessage.CallRpcbprocGettime>(callData);
                if (gettimeOpCallOptional != nothing)
                {
                    RpcbprogMessage.CallRpcbprocGettime gettimeOpCall = gettimeOpCallOptional as RpcbprogMessage.CallRpcbprocGettime;
                    gettimeOpCall#SunRpcVers = vers;
                    dispatcher(gettimeOpCall);
                }
                else
                {
                    ThrowDecodingException("RPCBIND", "RpcbprogMessage.CallRpcbprocGettime");
                }
            }
            else
            {
                optional RpcbprogMessage.ReturnRpcbprocGettime gettimeOpReplyOptional = BinaryDecoder<RpcbprogMessage.ReturnRpcbprocGettime>(replyData);
                if (gettimeOpReplyOptional != nothing)
                {
                    RpcbprogMessage.ReturnRpcbprocGettime gettimeOpReply = gettimeOpReplyOptional as RpcbprogMessage.ReturnRpcbprocGettime;
                    gettimeOpReply#SunRpcVers = vers;
                    dispatcher(gettimeOpReply);
                }
                else
                {
                    ThrowDecodingException("RPCBIND", "RpcbprogMessage.ReturnRpcbprocGettime");
                }
            }

        case 7 =>
            if (isCall)
            {
                optional RpcbprogMessage.CallRpcbprocUaddr2taddr uaddr2taddrOpCallOptional = BinaryDecoder<RpcbprogMessage.CallRpcbprocUaddr2taddr>(callData);
                if (uaddr2taddrOpCallOptional != nothing)
                {
                    RpcbprogMessage.CallRpcbprocUaddr2taddr uaddr2taddrOpCall = uaddr2taddrOpCallOptional as RpcbprogMessage.CallRpcbprocUaddr2taddr;
                    uaddr2taddrOpCall#SunRpcVers = vers;
                    dispatcher(uaddr2taddrOpCall);
                }
                else
                {
                    ThrowDecodingException("RPCBIND", "RpcbprogMessage.CallRpcbprocUaddr2taddr");
                }
            }
            else
            {
                optional RpcbprogMessage.ReturnRpcbprocUaddr2taddr uaddr2taddrOpReplyOptional = BinaryDecoder<RpcbprogMessage.ReturnRpcbprocUaddr2taddr>(replyData);
                if (uaddr2taddrOpReplyOptional != nothing)
                {
                    RpcbprogMessage.ReturnRpcbprocUaddr2taddr uaddr2taddrOpReply = uaddr2taddrOpReplyOptional as RpcbprogMessage.ReturnRpcbprocUaddr2taddr;
                    uaddr2taddrOpReply#SunRpcVers = vers;
                    dispatcher(uaddr2taddrOpReply);
                }
                else
                {
                    ThrowDecodingException("RPCBIND", "RpcbprogMessage.ReturnRpcbprocUaddr2taddr");
                }
            }
        case 8 =>
            if (isCall)
            {
                optional RpcbprogMessage.CallRpcbprocTaddr2uaddr taddr2uaddrOpCallOptional = BinaryDecoder<RpcbprogMessage.CallRpcbprocTaddr2uaddr>(callData);
                if (taddr2uaddrOpCallOptional != nothing)
                {
                    RpcbprogMessage.CallRpcbprocTaddr2uaddr taddr2uaddrOpCall = taddr2uaddrOpCallOptional as RpcbprogMessage.CallRpcbprocTaddr2uaddr;
                    taddr2uaddrOpCall#SunRpcVers = vers;
                    dispatcher(taddr2uaddrOpCall);
                }
                else
                {
                    ThrowDecodingException("RPCBIND", "RpcbprogMessage.CallRpcbprocTaddr2uaddr");
                }
            }
            else
            {
                optional RpcbprogMessage.ReturnRpcbprocTaddr2uaddr taddr2uaddrOpReplyOptional = BinaryDecoder<RpcbprogMessage.ReturnRpcbprocTaddr2uaddr>(replyData);
                if (taddr2uaddrOpReplyOptional != nothing)
                {
                    RpcbprogMessage.ReturnRpcbprocTaddr2uaddr taddr2uaddrOpReply = taddr2uaddrOpReplyOptional as RpcbprogMessage.ReturnRpcbprocTaddr2uaddr;
                    taddr2uaddrOpReply#SunRpcVers = vers;
                    dispatcher(taddr2uaddrOpReply);
                }
                else
                {
                    ThrowDecodingException("RPCBIND", "RpcbprogMessage.ReturnRpcbprocTaddr2uaddr");
                }
            }
        case 9 =>
            if (isCall)
            {
                optional RpcbprogMessage.CallRpcbprocGetversaddr getversaddrOpCallOptional = BinaryDecoder<RpcbprogMessage.CallRpcbprocGetversaddr>(callData);
                if (getversaddrOpCallOptional != nothing)
                {
                    RpcbprogMessage.CallRpcbprocGetversaddr getversaddrOpCall = getversaddrOpCallOptional as RpcbprogMessage.CallRpcbprocGetversaddr;
                    getversaddrOpCall#SunRpcVers = vers;
                    dispatcher(getversaddrOpCall);
                }
                else
                {
                    ThrowDecodingException("RPCBIND", "RpcbprogMessage.CallRpcbprocGetversaddr");
                }
            }
            else
            {
                optional RpcbprogMessage.ReturnRpcbprocGetversaddr getversaddrOpReplyOptional = BinaryDecoder<RpcbprogMessage.ReturnRpcbprocGetversaddr>(replyData);
                if (getversaddrOpReplyOptional != nothing)
                {
                    RpcbprogMessage.ReturnRpcbprocGetversaddr getversaddrOpReply = getversaddrOpReplyOptional as RpcbprogMessage.ReturnRpcbprocGetversaddr;
                    getversaddrOpReply#SunRpcVers = vers;
                    dispatcher(getversaddrOpReply);
                }
                else
                {
                    ThrowDecodingException("RPCBIND", "RpcbprogMessage.ReturnRpcbprocGetversaddr");
                }
            }
        case 10 =>
            if (isCall)
            {
                optional RpcbprogMessage.CallRpcbprocIndirect indirectOpCallOptional = BinaryDecoder<RpcbprogMessage.CallRpcbprocIndirect>(callData);
                if (indirectOpCallOptional != nothing)
                {
                    RpcbprogMessage.CallRpcbprocIndirect indirectOpCall = indirectOpCallOptional as RpcbprogMessage.CallRpcbprocIndirect;
                    indirectOpCall#SunRpcVers = vers;
                    dispatcher(indirectOpCall);
                }
                else
                {
                    ThrowDecodingException("RPCBIND", "RpcbprogMessage.CallRpcbprocIndirect");
                }
            }
            else
            {
                optional RpcbprogMessage.ReturnRpcbprocIndirect indirectOpReplyOptional = BinaryDecoder<RpcbprogMessage.ReturnRpcbprocIndirect>(replyData);
                if (indirectOpReplyOptional != nothing)
                {
                    RpcbprogMessage.ReturnRpcbprocIndirect indirectOpReply = indirectOpReplyOptional as RpcbprogMessage.ReturnRpcbprocIndirect;
                    indirectOpReply#SunRpcVers = vers;
                    dispatcher(indirectOpReply);
                }
                else
                {
                    ThrowDecodingException("RPCBIND", "RpcbprogMessage.ReturnRpcbprocIndirect");
                }
            }
        case 11 =>
            if (isCall)
            {
                optional RpcbprogMessage.CallRpcbprocGetaddrlist getaddrlistOpCallOptional = BinaryDecoder<RpcbprogMessage.CallRpcbprocGetaddrlist>(callData);
                if (getaddrlistOpCallOptional != nothing)
                {
                    RpcbprogMessage.CallRpcbprocGetaddrlist getaddrlistOpCall = getaddrlistOpCallOptional as RpcbprogMessage.CallRpcbprocGetaddrlist;
                    getaddrlistOpCall#SunRpcVers = vers;
                    dispatcher(getaddrlistOpCall);
                }
                else
                {
                    ThrowDecodingException("RPCBIND", "RpcbprogMessage.CallRpcbprocGetaddrlist");
                }
            }
            else
            {
                optional RpcbprogMessage.ReturnRpcbprocGetaddrlist getaddrlistOpReplyOptional = BinaryDecoder<RpcbprogMessage.ReturnRpcbprocGetaddrlist>(replyData);
                if (getaddrlistOpReplyOptional != nothing)
                {
                    RpcbprogMessage.ReturnRpcbprocGetaddrlist getaddrlistOpReply = getaddrlistOpReplyOptional as RpcbprogMessage.ReturnRpcbprocGetaddrlist;
                    getaddrlistOpReply#SunRpcVers = vers;
                    dispatcher(getaddrlistOpReply);
                }
                else
                {
                    ThrowDecodingException("RPCBIND", "RpcbprogMessage.ReturnRpcbprocGetaddrlist");
                }
            }
        case 12 =>
            if (isCall)
            {
                optional RpcbprogMessage.CallRpcbprocGetstat getstatOpCallOptional = BinaryDecoder<RpcbprogMessage.CallRpcbprocGetstat>(callData);
                if (getstatOpCallOptional != nothing)
                {
                    RpcbprogMessage.CallRpcbprocGetstat getstatOpCall = getstatOpCallOptional as RpcbprogMessage.CallRpcbprocGetstat;
                    getstatOpCall#SunRpcVers = vers;
                    dispatcher(getstatOpCall);
                }
                else
                {
                    ThrowDecodingException("RPCBIND", "RpcbprogMessage.CallRpcbprocGetstat");
                }
            }
            else
            {
                optional RpcbprogMessage.ReturnRpcbprocGetstat getstatOpReplyOptional = BinaryDecoder<RpcbprogMessage.ReturnRpcbprocGetstat>(replyData);
                if (getstatOpReplyOptional != nothing)
                {
                    RpcbprogMessage.ReturnRpcbprocGetstat getstatOpReply = getstatOpReplyOptional as RpcbprogMessage.ReturnRpcbprocGetstat;
                    getstatOpReply#SunRpcVers = vers;
                    dispatcher(getstatOpReply);
                }
                else
                {
                    ThrowDecodingException("RPCBIND", "RpcbprogMessage.ReturnRpcbprocGetstat");
                }
            }
        default =>
            ThrowDecodingException("RPCBIND");
    }
}

autostart actor RpcBindOverMessageEndpoint(IntermediateServer ep)
{
    RpcbprogMessage.CallRpcbprocSet callRpcbprocSet = null;
    RpcbprogMessage.CallRpcbprocUnset callRpcbprocUnset = null;
    RpcbprogMessage.CallRpcbprocGetaddr callRpcbprocGetaddr = null;
    RpcbprogMessage.CallRpcbprocDump callRpcbprocDump = null;
    RpcbprogMessage.CallRpcbprocCallit callRpcbprocCallit = null;
    RpcbprogMessage.CallRpcbprocGettime callRpcbprocGettime = null;
    RpcbprogMessage.CallRpcbprocUaddr2taddr callRpcbprocUaddr2taddr = null;
    RpcbprogMessage.CallRpcbprocTaddr2uaddr callRpcbprocTaddr2uaddr = null;
    RpcbprogMessage.CallRpcbprocBcast callRpcbprocBcast = null;
    RpcbprogMessage.CallRpcbprocGetversaddr callRpcbprocGetversaddr = null;
    RpcbprogMessage.CallRpcbprocIndirect callRpcbprocIndirect = null;
    RpcbprogMessage.CallRpcbprocGetaddrlist callRpcbprocGetaddrlist = null;
    RpcbprogMessage.CallRpcbprocGetstat callRpcbprocGetstat = null;
    
    ~endpoint(IntermediateServer ep)
    {
        if (callRpcbprocSet != null)
        {
            ReportInsufficientOperation(callRpcbprocSet, "RPCBIND", "SET", false);
            release callRpcbprocSet;
        }
        if (callRpcbprocUnset != null)
        {
            ReportInsufficientOperation(callRpcbprocUnset, "RPCBIND", "UNSET", false);
            release callRpcbprocUnset;
        }
        if (callRpcbprocGetaddr != null)
        {
            ReportInsufficientOperation(callRpcbprocGetaddr, "RPCBIND", "GETADDR", false);
            release callRpcbprocGetaddr;
        }
        if (callRpcbprocDump != null)
        {
            ReportInsufficientOperation(callRpcbprocDump, "RPCBIND", "DUMP", false);
            release callRpcbprocDump;
        }
        if (callRpcbprocCallit != null)
        {
            ReportInsufficientOperation(callRpcbprocCallit, "RPCBIND", "CALLIT", false);
            release callRpcbprocCallit;
        }
        if (callRpcbprocGettime != null)
        {
            ReportInsufficientOperation(callRpcbprocGettime, "RPCBIND", "GETTIME", false);
            release callRpcbprocGettime;
        }
        if (callRpcbprocUaddr2taddr != null)
        {
            ReportInsufficientOperation(callRpcbprocUaddr2taddr, "RPCBIND", "UADDR2TADDR", false);
            release callRpcbprocUaddr2taddr;
        }
        if (callRpcbprocTaddr2uaddr != null)
        {
            ReportInsufficientOperation(callRpcbprocTaddr2uaddr, "RPCBIND", "TADDR2UADDR", false);
            release callRpcbprocTaddr2uaddr;
        }
        if (callRpcbprocBcast != null)
        {
            ReportInsufficientOperation(callRpcbprocBcast, "RPCBIND", "BCAST", false);
            release callRpcbprocBcast;
        }
        if (callRpcbprocGetversaddr != null)
        {
            ReportInsufficientOperation(callRpcbprocGetversaddr, "RPCBIND", "GETVERSADDR", false);
            release callRpcbprocGetversaddr;
        }
        if (callRpcbprocIndirect != null)
        {
            ReportInsufficientOperation(callRpcbprocIndirect, "RPCBIND", "INDIRECT", false);
            release callRpcbprocIndirect;
        }
        if (callRpcbprocGetaddrlist != null)
        {
            ReportInsufficientOperation(callRpcbprocGetaddrlist, "RPCBIND", "GETADDRLIST", false);
            release callRpcbprocGetaddrlist;
        }
        if (callRpcbprocGetstat != null)
        {
            ReportInsufficientOperation(callRpcbprocGetstat, "RPCBIND", "GETSTAT", false);
            release callRpcbprocGetstat;
        }
    }
    
    // RPCBPROC_SET
    process ep accepts req:RpcbprogMessage.CallRpcbprocSet
    {
        if (callRpcbprocSet != null)
        {
            ReportInsufficientOperation(callRpcbprocSet, "RPCBIND", "SET", false);
            release callRpcbprocSet;
        }
        callRpcbprocSet = req;
    }
    process ep issues res:RpcbprogMessage.ReturnRpcbprocSet
    {
        if (callRpcbprocSet == null)
        {
            ReportInsufficientOperation(res, "RPCBIND", "SET", true);
            reject;
        }
        else
        {
            Rpcbprog.RPCBPROC_SET setOp = new Rpcbprog.RPCBPROC_SET{Rpcb = callRpcbprocSet.Rpcb, Result = res.Result};
            setOp.Origins = [callRpcbprocSet as any message, res as any message];
            callRpcbprocSet = null;
            dispatch (endpoint Server over ep) accepts setOp;
        }
    }
    
    // RPCBPROC_UNSET
    process ep accepts req:RpcbprogMessage.CallRpcbprocUnset
    {
        if (callRpcbprocUnset != null)
        {
            ReportInsufficientOperation(callRpcbprocUnset, "RPCBIND", "UNSET", false);
            release callRpcbprocUnset;
        }
        callRpcbprocUnset = req;
    }
    process ep issues res:RpcbprogMessage.ReturnRpcbprocUnset
    {
        if (callRpcbprocUnset == null)
        {
            ReportInsufficientOperation(res, "RPCBIND", "UNSET", true);
            reject;
        }
        else
        {
            Rpcbprog.RPCBPROC_UNSET unSetOp = new Rpcbprog.RPCBPROC_UNSET{Rpcb = callRpcbprocUnset.Rpcb, Result = res.Result};
            unSetOp.Origins = [callRpcbprocUnset as any message, res as any message];
            callRpcbprocUnset = null;
            dispatch (endpoint Server over ep) accepts unSetOp;
        }
    }
    
    // RPCBPROC_GETADDR
    process ep accepts req:RpcbprogMessage.CallRpcbprocGetaddr
    {
        if (callRpcbprocGetaddr != null)
        {
            ReportInsufficientOperation(callRpcbprocGetaddr, "RPCBIND", "GETADDR", false);
            release callRpcbprocGetaddr;
        }
        callRpcbprocGetaddr = req;
    }
    process ep issues res:RpcbprogMessage.ReturnRpcbprocGetaddr
    {
        if (callRpcbprocGetaddr == null)
        {
            ReportInsufficientOperation(res, "RPCBIND", "GETADDR", true);
            reject;
        }
        else
        {
            Rpcbprog.RPCBPROC_GETADDR getaddrOp = new Rpcbprog.RPCBPROC_GETADDR{Rpcb = callRpcbprocGetaddr.Rpcb, Addr = res.Addr};
            getaddrOp.Origins = [callRpcbprocGetaddr as any message, res as any message];
            callRpcbprocGetaddr = null;
            dispatch (endpoint Server over ep) accepts getaddrOp;
        }
    }
    
    // RPCBPROC_DUMP
    process ep accepts req:RpcbprogMessage.CallRpcbprocDump
    {
        if (callRpcbprocDump != null)
        {
            ReportInsufficientOperation(callRpcbprocDump, "RPCBIND", "DUMP", false);
            release callRpcbprocDump;
        }
        callRpcbprocDump = req;
    }
    process ep issues res:RpcbprogMessage.ReturnRpcbprocDump
    {
        if (callRpcbprocDump == null)
        {
            ReportInsufficientOperation(res, "RPCBIND", "DUMP", true);
            reject;
        }
        else
        {
            Rpcbprog.RPCBPROC_DUMP dumpOp = new Rpcbprog.RPCBPROC_DUMP{Addr = res.Addr};
            dumpOp.Origins = [callRpcbprocDump as any message, res as any message];
            callRpcbprocDump = null;
            dispatch (endpoint Server over ep) accepts dumpOp;
        }
    }
    
    // RPCBPROC_CALLIT
    process ep accepts req:RpcbprogMessage.CallRpcbprocCallit
    {
        if (callRpcbprocCallit != null)
        {
            ReportInsufficientOperation(callRpcbprocCallit, "RPCBIND", "CALLIT", false);
            release callRpcbprocCallit;
        }
        callRpcbprocCallit = req;
    }
    process ep issues res:RpcbprogMessage.ReturnRpcbprocCallit
    {
        if (callRpcbprocCallit == null)
        {
            ReportInsufficientOperation(res, "RPCBIND", "CALLIT", true);
            reject;
        }
        else
        {
            Rpcbprog.RPCBPROC_CALLIT callitOp = new Rpcbprog.RPCBPROC_CALLIT{Callargs = callRpcbprocCallit.Callargs};
            callitOp.Origins = [callRpcbprocCallit as any message, res as any message];
            callRpcbprocCallit = null;
            dispatch (endpoint Server over ep) accepts callitOp;
        }
    }
    
    // RPCBPROC_GETTIME
    process ep accepts req:RpcbprogMessage.CallRpcbprocGettime
    {
        if (callRpcbprocGettime != null)
        {
            ReportInsufficientOperation(callRpcbprocGettime, "RPCBIND", "GETTIME", false);
            release callRpcbprocGettime;
        }
        callRpcbprocGettime = req;
    }
    process ep issues res:RpcbprogMessage.ReturnRpcbprocGettime
    {
        if (callRpcbprocGettime == null)
        {
            ReportInsufficientOperation(res, "RPCBIND", "GETTIME", true);
            reject;
        }
        else
        {
            Rpcbprog.RPCBPROC_GETTIME gettimeOp = new Rpcbprog.RPCBPROC_GETTIME{Time = res.Time};
            gettimeOp.Origins = [callRpcbprocGettime as any message, res as any message];
            callRpcbprocGettime = null;
            dispatch (endpoint Server over ep) accepts gettimeOp;
        }
    }
    
    // RPCBPROC_UADDR2TADDR
    process ep accepts req:RpcbprogMessage.CallRpcbprocUaddr2taddr
    {
        if (callRpcbprocUaddr2taddr != null)
        {
            ReportInsufficientOperation(callRpcbprocUaddr2taddr, "RPCBIND", "UADDR2TADDR", false);
            release callRpcbprocUaddr2taddr;
        }
        callRpcbprocUaddr2taddr = req;
    }
    process ep issues res:RpcbprogMessage.ReturnRpcbprocUaddr2taddr
    {
        if (callRpcbprocUaddr2taddr == null)
        {
            ReportInsufficientOperation(res, "RPCBIND", "UADDR2TADDR", true);
            reject;
        }
        else
        {
            Rpcbprog.RPCBPROC_UADDR2TADDR uaddr2taddrOp = new Rpcbprog.RPCBPROC_UADDR2TADDR{UniversalAddresses = callRpcbprocUaddr2taddr.UniversalAddresses, TransportSpecificAddresses = res.TransportSpecificAddresses};
            uaddr2taddrOp.Origins = [callRpcbprocUaddr2taddr as any message, res as any message];
            callRpcbprocUaddr2taddr = null;
            dispatch (endpoint Server over ep) accepts uaddr2taddrOp;
        }
    }
    
    // RPCBPROC_TADDR2UADDR
    process ep accepts req:RpcbprogMessage.CallRpcbprocTaddr2uaddr
    {
        if (callRpcbprocTaddr2uaddr != null)
        {
            ReportInsufficientOperation(callRpcbprocTaddr2uaddr, "RPCBIND", "TADDR2UADDR", false);
            release callRpcbprocTaddr2uaddr;
        }
        callRpcbprocTaddr2uaddr = req;
    }
    process ep issues res:RpcbprogMessage.ReturnRpcbprocTaddr2uaddr
    {
        if (callRpcbprocTaddr2uaddr == null)
        {
            ReportInsufficientOperation(res, "RPCBIND", "TADDR2UADDR", true);
            reject;
        }
        else
        {
            Rpcbprog.RPCBPROC_TADDR2UADDR taddr2uaddrOp = new Rpcbprog.RPCBPROC_TADDR2UADDR{TransportSpecificAddresses = callRpcbprocTaddr2uaddr.TransportSpecificAddresses, UniversalAddresses = res.UniversalAddresses};
            taddr2uaddrOp.Origins = [callRpcbprocTaddr2uaddr as any message, res as any message];
            callRpcbprocTaddr2uaddr = null;
            dispatch (endpoint Server over ep) accepts taddr2uaddrOp;
        }
    }
    
    // RPCBPROC_BCAST
    process ep accepts req:RpcbprogMessage.CallRpcbprocBcast
    {
        if (callRpcbprocBcast != null)
        {
            ReportInsufficientOperation(callRpcbprocBcast, "RPCBIND", "BCAST", false);
            release callRpcbprocBcast;
        }
        callRpcbprocBcast = req;
    }
    process ep issues res:RpcbprogMessage.ReturnRpcbprocBcast
    {
        if (callRpcbprocBcast == null)
        {
            ReportInsufficientOperation(res, "RPCBIND", "BCAST", true);
            reject;
        }
        else
        {
            Rpcbprog.RPCBPROC_BCAST bcastOp = new Rpcbprog.RPCBPROC_BCAST{Callargs = callRpcbprocCallit.Callargs};
            bcastOp.Origins = [callRpcbprocBcast as any message, res as any message];
            callRpcbprocBcast = null;
            dispatch (endpoint Server over ep) accepts bcastOp;
        }
    }
    
    // RPCBPROC_GETVERSADDR
    process ep accepts req:RpcbprogMessage.CallRpcbprocGetversaddr
    {
        if (callRpcbprocGetversaddr != null)
        {
            ReportInsufficientOperation(callRpcbprocGetversaddr, "RPCBIND", "GETVERSADDR", false);
            release callRpcbprocGetversaddr;
        }
        callRpcbprocGetversaddr = req;
    }
    process ep issues res:RpcbprogMessage.ReturnRpcbprocGetversaddr
    {
        if (callRpcbprocGetversaddr == null)
        {
            ReportInsufficientOperation(res, "RPCBIND", "GETVERSADDR", true);
            reject;
        }
        else
        {
            Rpcbprog.RPCBPROC_GETVERSADDR getversaddrOp = new Rpcbprog.RPCBPROC_GETVERSADDR{Rpcb = callRpcbprocGetversaddr.Rpcb, Addr = res.Addr};
            getversaddrOp.Origins = [callRpcbprocGetversaddr as any message, res as any message];
            callRpcbprocGetversaddr = null;
            dispatch (endpoint Server over ep) accepts getversaddrOp;
        }
    }
    
    // RPCBPROC_INDIRECT
    process ep accepts req:RpcbprogMessage.CallRpcbprocIndirect
    {
        if (callRpcbprocIndirect != null)
        {
            ReportInsufficientOperation(callRpcbprocIndirect, "RPCBIND", "INDIRECT", false);
            release callRpcbprocIndirect;
        }
        callRpcbprocIndirect = req;
    }
    process ep issues res:RpcbprogMessage.ReturnRpcbprocIndirect
    {
        if (callRpcbprocIndirect == null)
        {
            ReportInsufficientOperation(res, "RPCBIND", "INDIRECT", true);
            reject;
        }
        else
        {
            Rpcbprog.RPCBPROC_INDIRECT indirectOp = new Rpcbprog.RPCBPROC_INDIRECT{Callargs = callRpcbprocIndirect.Callargs, Callres = res.Callres};
            indirectOp.Origins = [callRpcbprocIndirect as any message, res as any message];
            callRpcbprocIndirect = null;
            dispatch (endpoint Server over ep) accepts indirectOp;
        }
    }
    
    // RPCBPROC_GETADDRLIST
    process ep accepts req:RpcbprogMessage.CallRpcbprocGetaddrlist
    {
        if (callRpcbprocGetaddrlist != null)
        {
            ReportInsufficientOperation(callRpcbprocGetaddrlist, "RPCBIND", "GETADDRLIST", false);
            release callRpcbprocGetaddrlist;
        }
        callRpcbprocGetaddrlist = req;
    }
    process ep issues res:RpcbprogMessage.ReturnRpcbprocGetaddrlist
    {
        if (callRpcbprocGetaddrlist == null)
        {
            ReportInsufficientOperation(res, "RPCBIND", "GETADDRLIST", true);
            reject;
        }
        else
        {
            Rpcbprog.RPCBPROC_GETADDRLIST getaddrlistOp = new Rpcbprog.RPCBPROC_GETADDRLIST{Rpcb = callRpcbprocGetaddrlist.Rpcb, Addr = res.Addr};
            getaddrlistOp.Origins = [callRpcbprocGetaddrlist as any message, res as any message];
            callRpcbprocGetaddrlist = null;
            dispatch (endpoint Server over ep) accepts getaddrlistOp;
        }
    }
    
    // RPCBPROC_GETSTAT
    process ep accepts req:RpcbprogMessage.CallRpcbprocGetstat
    {
        if (callRpcbprocGetstat != null)
        {
            ReportInsufficientOperation(callRpcbprocGetstat, "RPCBIND", "GETSTAT", false);
            release callRpcbprocGetstat;
        }
        callRpcbprocGetstat = req;
    }
    process ep issues res:RpcbprogMessage.ReturnRpcbprocGetstat
    {
        if (callRpcbprocGetstat == null)
        {
            ReportInsufficientOperation(res, "RPCBIND", "GETSTAT", true);
            reject;
        }
        else
        {
            Rpcbprog.RPCBPROC_GETSTAT getstatOp = new Rpcbprog.RPCBPROC_GETSTAT{RpcbStatByvers = res.RpcbStatByvers};
            getstatOp.Origins = [callRpcbprocGetstat as any message, res as any message];
            callRpcbprocGetstat = null;
            dispatch (endpoint Server over ep) accepts getstatOp;
        }
    }
}
